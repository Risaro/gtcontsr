{
    var t = 1e-6
      , i = "undefined" != typeof Float32Array ? Float32Array : Array
      , e = Math.random;
    function Tt(t) {
        i = t
    }
    var s = Math.PI / 180;
    function It(t) {
        return t * s
    }
    function Pt(i, e) {
        return Math.abs(i - e) <= t * Math.max(1, Math.abs(i), Math.abs(e))
    }
    Math.hypot || (Math.hypot = function() {
        for (var t = 0, i = arguments.length; i--; )
            t += arguments[i] * arguments[i];
        return Math.sqrt(t)
    }
    );
    var n = {
        __proto__: null,
        EPSILON: t,
        get t6t() {
            return i
        },
        i6t: e,
        e6t: "zyx",
        s6t: Tt,
        n6t: It,
        equals: Pt
    };
    function Gt() {
        var t = new i(4);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0),
        t[0] = 1,
        t[3] = 1,
        t
    }
    function At(t) {
        var e = new i(4);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e
    }
    function Rt(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t
    }
    function kt(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t
    }
    function Ot(t, e, s, n) {
        var r = new i(4);
        return r[0] = t,
        r[1] = e,
        r[2] = s,
        r[3] = n,
        r
    }
    function Dt(t, i, e, s, n) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t
    }
    function Ft(t, i) {
        if (t === i) {
            var e = i[1];
            t[1] = i[2],
            t[2] = e
        } else
            t[0] = i[0],
            t[1] = i[2],
            t[2] = i[1],
            t[3] = i[3];
        return t
    }
    function Lt(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e * r - n * s;
        return h ? (h = 1 / h,
        t[0] = r * h,
        t[1] = -s * h,
        t[2] = -n * h,
        t[3] = e * h,
        t) : null
    }
    function Bt(t, i) {
        var e = i[0];
        return t[0] = i[3],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = e,
        t
    }
    function Ut(t) {
        return t[0] * t[3] - t[2] * t[1]
    }
    function Nt(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return t[0] = s * o + r * a,
        t[1] = n * o + h * a,
        t[2] = s * l + r * u,
        t[3] = n * l + h * u,
        t
    }
    function jt(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a + r * o,
        t[1] = n * a + h * o,
        t[2] = s * -o + r * a,
        t[3] = n * -o + h * a,
        t
    }
    function $t(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1];
        return t[0] = s * o,
        t[1] = n * o,
        t[2] = r * a,
        t[3] = h * a,
        t
    }
    function zt(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = -e,
        t[3] = s,
        t
    }
    function Vt(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = i[1],
        t
    }
    function Wt(t) {
        return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }
    function Ht(t) {
        return Math.hypot(t[0], t[1], t[2], t[3])
    }
    function Kt(t, i, e, s) {
        return t[2] = s[2] / s[0],
        e[0] = s[0],
        e[1] = s[1],
        e[3] = s[3] - t[2] * e[1],
        [t, i, e]
    }
    function qt(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t
    }
    function Xt(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t
    }
    function Yt(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3]
    }
    function Jt(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return Math.abs(s - o) <= t * Math.max(1, Math.abs(s), Math.abs(o)) && Math.abs(n - a) <= t * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - l) <= t * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(h - u) <= t * Math.max(1, Math.abs(h), Math.abs(u))
    }
    function Zt(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t
    }
    function Qt(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t
    }
    var r = Nt
      , h = Xt
      , o = Object.freeze({
        __proto__: null,
        create: Gt,
        clone: At,
        Qr: Rt,
        identity: kt,
        r6t: Ot,
        set: Dt,
        h6t: Ft,
        o6t: Lt,
        a6t: Bt,
        l6t: Ut,
        multiply: Nt,
        rotate: jt,
        scale: $t,
        u6t: zt,
        c6t: Vt,
        d6t: Wt,
        f6t: Ht,
        p6t: Kt,
        add: qt,
        m6t: Xt,
        w6t: Yt,
        equals: Jt,
        g6t: Zt,
        y6t: Qt,
        mul: r,
        sub: h
    });
    function ti() {
        var t = new i(6);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0,
        t[4] = 0,
        t[5] = 0),
        t[0] = 1,
        t[3] = 1,
        t
    }
    function ii(t) {
        var e = new i(6);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e
    }
    function ei(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t
    }
    function si(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = 0,
        t[5] = 0,
        t
    }
    function ni(t, e, s, n, r, h) {
        var o = new i(6);
        return o[0] = t,
        o[1] = e,
        o[2] = s,
        o[3] = n,
        o[4] = r,
        o[5] = h,
        o
    }
    function ri(t, i, e, s, n, r, h) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t
    }
    function hi(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = e * r - s * n;
        return a ? (a = 1 / a,
        t[0] = r * a,
        t[1] = -s * a,
        t[2] = -n * a,
        t[3] = e * a,
        t[4] = (n * o - r * h) * a,
        t[5] = (s * h - e * o) * a,
        t) : null
    }
    function oi(t) {
        return t[0] * t[3] - t[1] * t[2]
    }
    function ai(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1]
          , c = e[2]
          , d = e[3]
          , f = e[4]
          , p = e[5];
        return t[0] = s * l + r * u,
        t[1] = n * l + h * u,
        t[2] = s * c + r * d,
        t[3] = n * c + h * d,
        t[4] = s * f + r * p + o,
        t[5] = n * f + h * p + a,
        t
    }
    function li(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = Math.sin(e)
          , u = Math.cos(e);
        return t[0] = s * u + r * l,
        t[1] = n * u + h * l,
        t[2] = s * -l + r * u,
        t[3] = n * -l + h * u,
        t[4] = o,
        t[5] = a,
        t
    }
    function ui(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1];
        return t[0] = s * l,
        t[1] = n * l,
        t[2] = r * u,
        t[3] = h * u,
        t[4] = o,
        t[5] = a,
        t
    }
    function ci(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1];
        return t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = s * l + r * u + o,
        t[5] = n * l + h * u + a,
        t
    }
    function di(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = -e,
        t[3] = s,
        t[4] = 0,
        t[5] = 0,
        t
    }
    function fi(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = i[1],
        t[4] = 0,
        t[5] = 0,
        t
    }
    function pi(t, i) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = i[0],
        t[5] = i[1],
        t
    }
    function mi(t) {
        return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
    }
    function wi(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1)
    }
    function gi(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t
    }
    function yi(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t[4] = i[4] - e[4],
        t[5] = i[5] - e[5],
        t
    }
    function bi(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t
    }
    function vi(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t[4] = i[4] + e[4] * s,
        t[5] = i[5] + e[5] * s,
        t
    }
    function Si(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5]
    }
    function xi(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1]
          , c = e[2]
          , d = e[3]
          , f = e[4]
          , p = e[5];
        return Math.abs(s - l) <= t * Math.max(1, Math.abs(s), Math.abs(l)) && Math.abs(n - u) <= t * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(r - c) <= t * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(h - d) <= t * Math.max(1, Math.abs(h), Math.abs(d)) && Math.abs(o - f) <= t * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(a - p) <= t * Math.max(1, Math.abs(a), Math.abs(p))
    }
    var a = ai
      , l = yi
      , u = Object.freeze({
        __proto__: null,
        create: ti,
        clone: ii,
        Qr: ei,
        identity: si,
        r6t: ni,
        set: ri,
        o6t: hi,
        l6t: oi,
        multiply: ai,
        rotate: li,
        scale: ui,
        translate: ci,
        u6t: di,
        c6t: fi,
        b6t: pi,
        d6t: mi,
        f6t: wi,
        add: gi,
        m6t: yi,
        g6t: bi,
        y6t: vi,
        w6t: Si,
        equals: xi,
        mul: a,
        sub: l
    });
    function Mi() {
        var t = new i(9);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0),
        t[0] = 1,
        t[4] = 1,
        t[8] = 1,
        t
    }
    function Ei(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[4],
        t[4] = i[5],
        t[5] = i[6],
        t[6] = i[8],
        t[7] = i[9],
        t[8] = i[10],
        t
    }
    function Ci(t) {
        var e = new i(9);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        e
    }
    function _i(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t
    }
    function Ti(t, e, s, n, r, h, o, a, l) {
        var u = new i(9);
        return u[0] = t,
        u[1] = e,
        u[2] = s,
        u[3] = n,
        u[4] = r,
        u[5] = h,
        u[6] = o,
        u[7] = a,
        u[8] = l,
        u
    }
    function Ii(t, i, e, s, n, r, h, o, a, l) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t[6] = o,
        t[7] = a,
        t[8] = l,
        t
    }
    function Pi(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 1,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 1,
        t
    }
    function Gi(t, i) {
        if (t === i) {
            var e = i[1]
              , s = i[2]
              , n = i[5];
            t[1] = i[3],
            t[2] = i[6],
            t[3] = e,
            t[5] = i[7],
            t[6] = s,
            t[7] = n
        } else
            t[0] = i[0],
            t[1] = i[3],
            t[2] = i[6],
            t[3] = i[1],
            t[4] = i[4],
            t[5] = i[7],
            t[6] = i[2],
            t[7] = i[5],
            t[8] = i[8];
        return t
    }
    function Ai(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = u * h - o * l
          , d = -u * r + o * a
          , f = l * r - h * a
          , p = e * c + s * d + n * f;
        return p ? (p = 1 / p,
        t[0] = c * p,
        t[1] = (-u * s + n * l) * p,
        t[2] = (o * s - n * h) * p,
        t[3] = d * p,
        t[4] = (u * e - n * a) * p,
        t[5] = (-o * e + n * r) * p,
        t[6] = f * p,
        t[7] = (-l * e + s * a) * p,
        t[8] = (h * e - s * r) * p,
        t) : null
    }
    function Ri(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8];
        return t[0] = h * u - o * l,
        t[1] = n * l - s * u,
        t[2] = s * o - n * h,
        t[3] = o * a - r * u,
        t[4] = e * u - n * a,
        t[5] = n * r - e * o,
        t[6] = r * l - h * a,
        t[7] = s * a - e * l,
        t[8] = e * h - s * r,
        t
    }
    function ki(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3]
          , r = t[4]
          , h = t[5]
          , o = t[6]
          , a = t[7]
          , l = t[8];
        return i * (l * r - h * a) + e * (-l * n + h * o) + s * (a * n - r * o)
    }
    function Oi(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = e[0]
          , f = e[1]
          , p = e[2]
          , m = e[3]
          , w = e[4]
          , g = e[5]
          , y = e[6]
          , b = e[7]
          , v = e[8];
        return t[0] = d * s + f * h + p * l,
        t[1] = d * n + f * o + p * u,
        t[2] = d * r + f * a + p * c,
        t[3] = m * s + w * h + g * l,
        t[4] = m * n + w * o + g * u,
        t[5] = m * r + w * a + g * c,
        t[6] = y * s + b * h + v * l,
        t[7] = y * n + b * o + v * u,
        t[8] = y * r + b * a + v * c,
        t
    }
    function Di(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = e[0]
          , f = e[1];
        return t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = o,
        t[5] = a,
        t[6] = d * s + f * h + l,
        t[7] = d * n + f * o + u,
        t[8] = d * r + f * a + c,
        t
    }
    function Fi(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = Math.sin(e)
          , f = Math.cos(e);
        return t[0] = f * s + d * h,
        t[1] = f * n + d * o,
        t[2] = f * r + d * a,
        t[3] = f * h - d * s,
        t[4] = f * o - d * n,
        t[5] = f * a - d * r,
        t[6] = l,
        t[7] = u,
        t[8] = c,
        t
    }
    function Li(t, i, e) {
        var s = e[0]
          , n = e[1];
        return t[0] = s * i[0],
        t[1] = s * i[1],
        t[2] = s * i[2],
        t[3] = n * i[3],
        t[4] = n * i[4],
        t[5] = n * i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t
    }
    function Bi(t, i) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 1,
        t[5] = 0,
        t[6] = i[0],
        t[7] = i[1],
        t[8] = 1,
        t
    }
    function Ui(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = 0,
        t[3] = -e,
        t[4] = s,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 1,
        t
    }
    function Ni(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = i[1],
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 1,
        t
    }
    function ji(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = 0,
        t[3] = i[2],
        t[4] = i[3],
        t[5] = 0,
        t[6] = i[4],
        t[7] = i[5],
        t[8] = 1,
        t
    }
    function $i(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e + e
          , o = s + s
          , a = n + n
          , l = e * h
          , u = s * h
          , c = s * o
          , d = n * h
          , f = n * o
          , p = n * a
          , m = r * h
          , w = r * o
          , g = r * a;
        return t[0] = 1 - c - p,
        t[3] = u - g,
        t[6] = d + w,
        t[1] = u + g,
        t[4] = 1 - l - p,
        t[7] = f - m,
        t[2] = d - w,
        t[5] = f + m,
        t[8] = 1 - l - c,
        t
    }
    function zi(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = i[9]
          , d = i[10]
          , f = i[11]
          , p = i[12]
          , m = i[13]
          , w = i[14]
          , g = i[15]
          , y = e * o - s * h
          , b = e * a - n * h
          , v = e * l - r * h
          , S = s * a - n * o
          , x = s * l - r * o
          , M = n * l - r * a
          , E = u * m - c * p
          , C = u * w - d * p
          , _ = u * g - f * p
          , T = c * w - d * m
          , I = c * g - f * m
          , P = d * g - f * w
          , G = y * P - b * I + v * T + S * _ - x * C + M * E;
        return G ? (G = 1 / G,
        t[0] = (o * P - a * I + l * T) * G,
        t[1] = (a * _ - h * P - l * C) * G,
        t[2] = (h * I - o * _ + l * E) * G,
        t[3] = (n * I - s * P - r * T) * G,
        t[4] = (e * P - n * _ + r * C) * G,
        t[5] = (s * _ - e * I - r * E) * G,
        t[6] = (m * M - w * x + g * S) * G,
        t[7] = (w * v - p * M - g * b) * G,
        t[8] = (p * x - m * v + g * y) * G,
        t) : null
    }
    function Vi(t, i, e) {
        return t[0] = 2 / i,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = -2 / e,
        t[5] = 0,
        t[6] = -1,
        t[7] = 1,
        t[8] = 1,
        t
    }
    function Wi(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
    }
    function Hi(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8])
    }
    function Ki(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t[6] = i[6] + e[6],
        t[7] = i[7] + e[7],
        t[8] = i[8] + e[8],
        t
    }
    function qi(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t[4] = i[4] - e[4],
        t[5] = i[5] - e[5],
        t[6] = i[6] - e[6],
        t[7] = i[7] - e[7],
        t[8] = i[8] - e[8],
        t
    }
    function Xi(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t[6] = i[6] * e,
        t[7] = i[7] * e,
        t[8] = i[8] * e,
        t
    }
    function Yi(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t[4] = i[4] + e[4] * s,
        t[5] = i[5] + e[5] * s,
        t[6] = i[6] + e[6] * s,
        t[7] = i[7] + e[7] * s,
        t[8] = i[8] + e[8] * s,
        t
    }
    function Ji(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5] && t[6] === i[6] && t[7] === i[7] && t[8] === i[8]
    }
    function Zi(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = e[0]
          , f = e[1]
          , p = e[2]
          , m = e[3]
          , w = e[4]
          , g = e[5]
          , y = e[6]
          , b = e[7]
          , v = e[8];
        return Math.abs(s - d) <= t * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(n - f) <= t * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(r - p) <= t * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(h - m) <= t * Math.max(1, Math.abs(h), Math.abs(m)) && Math.abs(o - w) <= t * Math.max(1, Math.abs(o), Math.abs(w)) && Math.abs(a - g) <= t * Math.max(1, Math.abs(a), Math.abs(g)) && Math.abs(l - y) <= t * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - b) <= t * Math.max(1, Math.abs(u), Math.abs(b)) && Math.abs(c - v) <= t * Math.max(1, Math.abs(c), Math.abs(v))
    }
    var c = Oi
      , d = qi
      , f = Object.freeze({
        __proto__: null,
        create: Mi,
        v6t: Ei,
        clone: Ci,
        Qr: _i,
        r6t: Ti,
        set: Ii,
        identity: Pi,
        h6t: Gi,
        o6t: Ai,
        a6t: Ri,
        l6t: ki,
        multiply: Oi,
        translate: Di,
        rotate: Fi,
        scale: Li,
        b6t: Bi,
        u6t: Ui,
        c6t: Ni,
        S6t: ji,
        x6t: $i,
        M6t: zi,
        E6t: Vi,
        d6t: Wi,
        f6t: Hi,
        add: Ki,
        m6t: qi,
        g6t: Xi,
        y6t: Yi,
        w6t: Ji,
        equals: Zi,
        mul: c,
        sub: d
    });
    function Qi() {
        var t = new i(16);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0),
        t[0] = 1,
        t[5] = 1,
        t[10] = 1,
        t[15] = 1,
        t
    }
    function te(t) {
        var e = new i(16);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        e[9] = t[9],
        e[10] = t[10],
        e[11] = t[11],
        e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15],
        e
    }
    function ie(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        t
    }
    function ee(t, e, s, n, r, h, o, a, l, u, c, d, f, p, m, w) {
        var g = new i(16);
        return g[0] = t,
        g[1] = e,
        g[2] = s,
        g[3] = n,
        g[4] = r,
        g[5] = h,
        g[6] = o,
        g[7] = a,
        g[8] = l,
        g[9] = u,
        g[10] = c,
        g[11] = d,
        g[12] = f,
        g[13] = p,
        g[14] = m,
        g[15] = w,
        g
    }
    function se(t, i, e, s, n, r, h, o, a, l, u, c, d, f, p, m, w) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t[6] = o,
        t[7] = a,
        t[8] = l,
        t[9] = u,
        t[10] = c,
        t[11] = d,
        t[12] = f,
        t[13] = p,
        t[14] = m,
        t[15] = w,
        t
    }
    function ne(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = 1,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 1,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function re(t, i) {
        if (t === i) {
            var e = i[1]
              , s = i[2]
              , n = i[3]
              , r = i[6]
              , h = i[7]
              , o = i[11];
            t[1] = i[4],
            t[2] = i[8],
            t[3] = i[12],
            t[4] = e,
            t[6] = i[9],
            t[7] = i[13],
            t[8] = s,
            t[9] = r,
            t[11] = i[14],
            t[12] = n,
            t[13] = h,
            t[14] = o
        } else
            t[0] = i[0],
            t[1] = i[4],
            t[2] = i[8],
            t[3] = i[12],
            t[4] = i[1],
            t[5] = i[5],
            t[6] = i[9],
            t[7] = i[13],
            t[8] = i[2],
            t[9] = i[6],
            t[10] = i[10],
            t[11] = i[14],
            t[12] = i[3],
            t[13] = i[7],
            t[14] = i[11],
            t[15] = i[15];
        return t
    }
    function he(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = i[9]
          , d = i[10]
          , f = i[11]
          , p = i[12]
          , m = i[13]
          , w = i[14]
          , g = i[15]
          , y = e * o - s * h
          , b = e * a - n * h
          , v = e * l - r * h
          , S = s * a - n * o
          , x = s * l - r * o
          , M = n * l - r * a
          , E = u * m - c * p
          , C = u * w - d * p
          , _ = u * g - f * p
          , T = c * w - d * m
          , I = c * g - f * m
          , P = d * g - f * w
          , G = y * P - b * I + v * T + S * _ - x * C + M * E;
        return G ? (G = 1 / G,
        t[0] = (o * P - a * I + l * T) * G,
        t[1] = (n * I - s * P - r * T) * G,
        t[2] = (m * M - w * x + g * S) * G,
        t[3] = (d * x - c * M - f * S) * G,
        t[4] = (a * _ - h * P - l * C) * G,
        t[5] = (e * P - n * _ + r * C) * G,
        t[6] = (w * v - p * M - g * b) * G,
        t[7] = (u * M - d * v + f * b) * G,
        t[8] = (h * I - o * _ + l * E) * G,
        t[9] = (s * _ - e * I - r * E) * G,
        t[10] = (p * x - m * v + g * y) * G,
        t[11] = (c * v - u * x - f * y) * G,
        t[12] = (o * C - h * T - a * E) * G,
        t[13] = (e * T - s * C + n * E) * G,
        t[14] = (m * b - p * S - w * y) * G,
        t[15] = (u * S - c * b + d * y) * G,
        t) : null
    }
    function oe(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = i[9]
          , d = i[10]
          , f = i[11]
          , p = i[12]
          , m = i[13]
          , w = i[14]
          , g = i[15]
          , y = e * o - s * h
          , b = e * a - n * h
          , v = e * l - r * h
          , S = s * a - n * o
          , x = s * l - r * o
          , M = n * l - r * a
          , E = u * m - c * p
          , C = u * w - d * p
          , _ = u * g - f * p
          , T = c * w - d * m
          , I = c * g - f * m
          , P = d * g - f * w;
        return t[0] = o * P - a * I + l * T,
        t[1] = n * I - s * P - r * T,
        t[2] = m * M - w * x + g * S,
        t[3] = d * x - c * M - f * S,
        t[4] = a * _ - h * P - l * C,
        t[5] = e * P - n * _ + r * C,
        t[6] = w * v - p * M - g * b,
        t[7] = u * M - d * v + f * b,
        t[8] = h * I - o * _ + l * E,
        t[9] = s * _ - e * I - r * E,
        t[10] = p * x - m * v + g * y,
        t[11] = c * v - u * x - f * y,
        t[12] = o * C - h * T - a * E,
        t[13] = e * T - s * C + n * E,
        t[14] = m * b - p * S - w * y,
        t[15] = u * S - c * b + d * y,
        t
    }
    function ae(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3]
          , r = t[4]
          , h = t[5]
          , o = t[6]
          , a = t[7]
          , l = t[8]
          , u = t[9]
          , c = t[10]
          , d = t[11]
          , f = t[12]
          , p = t[13]
          , m = t[14]
          , w = i * h - e * r
          , g = i * o - s * r
          , y = e * o - s * h
          , b = l * p - u * f
          , v = l * m - c * f
          , S = u * m - c * p;
        return a * (i * S - e * v + s * b) - n * (r * S - h * v + o * b) + t[15] * (l * y - u * g + c * w) - d * (f * y - p * g + m * w)
    }
    function le(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = i[9]
          , f = i[10]
          , p = i[11]
          , m = i[12]
          , w = i[13]
          , g = i[14]
          , y = i[15]
          , b = e[0]
          , v = e[1]
          , S = e[2]
          , x = e[3];
        return t[0] = b * s + v * o + S * c + x * m,
        t[1] = b * n + v * a + S * d + x * w,
        t[2] = b * r + v * l + S * f + x * g,
        t[3] = b * h + v * u + S * p + x * y,
        b = e[4],
        v = e[5],
        S = e[6],
        x = e[7],
        t[4] = b * s + v * o + S * c + x * m,
        t[5] = b * n + v * a + S * d + x * w,
        t[6] = b * r + v * l + S * f + x * g,
        t[7] = b * h + v * u + S * p + x * y,
        b = e[8],
        v = e[9],
        S = e[10],
        x = e[11],
        t[8] = b * s + v * o + S * c + x * m,
        t[9] = b * n + v * a + S * d + x * w,
        t[10] = b * r + v * l + S * f + x * g,
        t[11] = b * h + v * u + S * p + x * y,
        b = e[12],
        v = e[13],
        S = e[14],
        x = e[15],
        t[12] = b * s + v * o + S * c + x * m,
        t[13] = b * n + v * a + S * d + x * w,
        t[14] = b * r + v * l + S * f + x * g,
        t[15] = b * h + v * u + S * p + x * y,
        t
    }
    function ue(t, i, e) {
        var s, n, r, h, o, a, l, u, c, d, f, p, m = e[0], w = e[1], g = e[2];
        return i === t ? (t[12] = i[0] * m + i[4] * w + i[8] * g + i[12],
        t[13] = i[1] * m + i[5] * w + i[9] * g + i[13],
        t[14] = i[2] * m + i[6] * w + i[10] * g + i[14],
        t[15] = i[3] * m + i[7] * w + i[11] * g + i[15]) : (s = i[0],
        n = i[1],
        r = i[2],
        h = i[3],
        o = i[4],
        a = i[5],
        l = i[6],
        u = i[7],
        c = i[8],
        d = i[9],
        f = i[10],
        p = i[11],
        t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = o,
        t[5] = a,
        t[6] = l,
        t[7] = u,
        t[8] = c,
        t[9] = d,
        t[10] = f,
        t[11] = p,
        t[12] = s * m + o * w + c * g + i[12],
        t[13] = n * m + a * w + d * g + i[13],
        t[14] = r * m + l * w + f * g + i[14],
        t[15] = h * m + u * w + p * g + i[15]),
        t
    }
    function ce(t, i, e) {
        var s = e[0]
          , n = e[1]
          , r = e[2];
        return t[0] = i[0] * s,
        t[1] = i[1] * s,
        t[2] = i[2] * s,
        t[3] = i[3] * s,
        t[4] = i[4] * n,
        t[5] = i[5] * n,
        t[6] = i[6] * n,
        t[7] = i[7] * n,
        t[8] = i[8] * r,
        t[9] = i[9] * r,
        t[10] = i[10] * r,
        t[11] = i[11] * r,
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        t
    }
    function de(i, e, s, n) {
        var r, h, o, a, l, u, c, d, f, p, m, w, g, y, b, v, S, x, M, E, C, _, T, I, P = n[0], G = n[1], A = n[2], R = Math.hypot(P, G, A);
        return R < t ? null : (P *= R = 1 / R,
        G *= R,
        A *= R,
        r = Math.sin(s),
        o = 1 - (h = Math.cos(s)),
        a = e[0],
        l = e[1],
        u = e[2],
        c = e[3],
        d = e[4],
        f = e[5],
        p = e[6],
        m = e[7],
        w = e[8],
        g = e[9],
        y = e[10],
        b = e[11],
        v = P * P * o + h,
        S = G * P * o + A * r,
        x = A * P * o - G * r,
        M = P * G * o - A * r,
        E = G * G * o + h,
        C = A * G * o + P * r,
        _ = P * A * o + G * r,
        T = G * A * o - P * r,
        I = A * A * o + h,
        i[0] = a * v + d * S + w * x,
        i[1] = l * v + f * S + g * x,
        i[2] = u * v + p * S + y * x,
        i[3] = c * v + m * S + b * x,
        i[4] = a * M + d * E + w * C,
        i[5] = l * M + f * E + g * C,
        i[6] = u * M + p * E + y * C,
        i[7] = c * M + m * E + b * C,
        i[8] = a * _ + d * T + w * I,
        i[9] = l * _ + f * T + g * I,
        i[10] = u * _ + p * T + y * I,
        i[11] = c * _ + m * T + b * I,
        e !== i && (i[12] = e[12],
        i[13] = e[13],
        i[14] = e[14],
        i[15] = e[15]),
        i)
    }
    function fe(t, i, e) {
        var s = Math.sin(e)
          , n = Math.cos(e)
          , r = i[4]
          , h = i[5]
          , o = i[6]
          , a = i[7]
          , l = i[8]
          , u = i[9]
          , c = i[10]
          , d = i[11];
        return i !== t && (t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15]),
        t[4] = r * n + l * s,
        t[5] = h * n + u * s,
        t[6] = o * n + c * s,
        t[7] = a * n + d * s,
        t[8] = l * n - r * s,
        t[9] = u * n - h * s,
        t[10] = c * n - o * s,
        t[11] = d * n - a * s,
        t
    }
    function pe(t, i, e) {
        var s = Math.sin(e)
          , n = Math.cos(e)
          , r = i[0]
          , h = i[1]
          , o = i[2]
          , a = i[3]
          , l = i[8]
          , u = i[9]
          , c = i[10]
          , d = i[11];
        return i !== t && (t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15]),
        t[0] = r * n - l * s,
        t[1] = h * n - u * s,
        t[2] = o * n - c * s,
        t[3] = a * n - d * s,
        t[8] = r * s + l * n,
        t[9] = h * s + u * n,
        t[10] = o * s + c * n,
        t[11] = a * s + d * n,
        t
    }
    function me(t, i, e) {
        var s = Math.sin(e)
          , n = Math.cos(e)
          , r = i[0]
          , h = i[1]
          , o = i[2]
          , a = i[3]
          , l = i[4]
          , u = i[5]
          , c = i[6]
          , d = i[7];
        return i !== t && (t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15]),
        t[0] = r * n + l * s,
        t[1] = h * n + u * s,
        t[2] = o * n + c * s,
        t[3] = a * n + d * s,
        t[4] = l * n - r * s,
        t[5] = u * n - h * s,
        t[6] = c * n - o * s,
        t[7] = d * n - a * s,
        t
    }
    function we(t, i) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = 1,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 1,
        t[11] = 0,
        t[12] = i[0],
        t[13] = i[1],
        t[14] = i[2],
        t[15] = 1,
        t
    }
    function ge(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = i[1],
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = i[2],
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function ye(i, e, s) {
        var n, r, h, o = s[0], a = s[1], l = s[2], u = Math.hypot(o, a, l);
        return u < t ? null : (o *= u = 1 / u,
        a *= u,
        l *= u,
        n = Math.sin(e),
        h = 1 - (r = Math.cos(e)),
        i[0] = o * o * h + r,
        i[1] = a * o * h + l * n,
        i[2] = l * o * h - a * n,
        i[3] = 0,
        i[4] = o * a * h - l * n,
        i[5] = a * a * h + r,
        i[6] = l * a * h + o * n,
        i[7] = 0,
        i[8] = o * l * h + a * n,
        i[9] = a * l * h - o * n,
        i[10] = l * l * h + r,
        i[11] = 0,
        i[12] = 0,
        i[13] = 0,
        i[14] = 0,
        i[15] = 1,
        i)
    }
    function be(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = s,
        t[6] = e,
        t[7] = 0,
        t[8] = 0,
        t[9] = -e,
        t[10] = s,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function ve(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = 0,
        t[2] = -e,
        t[3] = 0,
        t[4] = 0,
        t[5] = 1,
        t[6] = 0,
        t[7] = 0,
        t[8] = e,
        t[9] = 0,
        t[10] = s,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function Se(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = 0,
        t[3] = 0,
        t[4] = -e,
        t[5] = s,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 1,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function xe(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = s + s
          , a = n + n
          , l = r + r
          , u = s * o
          , c = s * a
          , d = s * l
          , f = n * a
          , p = n * l
          , m = r * l
          , w = h * o
          , g = h * a
          , y = h * l;
        return t[0] = 1 - (f + m),
        t[1] = c + y,
        t[2] = d - g,
        t[3] = 0,
        t[4] = c - y,
        t[5] = 1 - (u + m),
        t[6] = p + w,
        t[7] = 0,
        t[8] = d + g,
        t[9] = p - w,
        t[10] = 1 - (u + f),
        t[11] = 0,
        t[12] = e[0],
        t[13] = e[1],
        t[14] = e[2],
        t[15] = 1,
        t
    }
    function Me(t, e) {
        var s = new i(3)
          , n = -e[0]
          , r = -e[1]
          , h = -e[2]
          , o = e[3]
          , a = e[4]
          , l = e[5]
          , u = e[6]
          , c = e[7]
          , d = n * n + r * r + h * h + o * o;
        return d > 0 ? (s[0] = 2 * (a * o + c * n + l * h - u * r) / d,
        s[1] = 2 * (l * o + c * r + u * n - a * h) / d,
        s[2] = 2 * (u * o + c * h + a * r - l * n) / d) : (s[0] = 2 * (a * o + c * n + l * h - u * r),
        s[1] = 2 * (l * o + c * r + u * n - a * h),
        s[2] = 2 * (u * o + c * h + a * r - l * n)),
        xe(t, e, s),
        t
    }
    function Ee(t, i) {
        return t[0] = i[12],
        t[1] = i[13],
        t[2] = i[14],
        t
    }
    function Ce(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[4]
          , h = i[5]
          , o = i[6]
          , a = i[8]
          , l = i[9]
          , u = i[10];
        return t[0] = Math.hypot(e, s, n),
        t[1] = Math.hypot(r, h, o),
        t[2] = Math.hypot(a, l, u),
        t
    }
    function _e(t, e) {
        var s = new i(3);
        Ce(s, e);
        var n = 1 / s[0]
          , r = 1 / s[1]
          , h = 1 / s[2]
          , o = e[0] * n
          , a = e[1] * r
          , l = e[2] * h
          , u = e[4] * n
          , c = e[5] * r
          , d = e[6] * h
          , f = e[8] * n
          , p = e[9] * r
          , m = e[10] * h
          , w = o + c + m
          , g = 0;
        return w > 0 ? (g = 2 * Math.sqrt(w + 1),
        t[3] = .25 * g,
        t[0] = (d - p) / g,
        t[1] = (f - l) / g,
        t[2] = (a - u) / g) : o > c && o > m ? (g = 2 * Math.sqrt(1 + o - c - m),
        t[3] = (d - p) / g,
        t[0] = .25 * g,
        t[1] = (a + u) / g,
        t[2] = (f + l) / g) : c > m ? (g = 2 * Math.sqrt(1 + c - o - m),
        t[3] = (f - l) / g,
        t[0] = (a + u) / g,
        t[1] = .25 * g,
        t[2] = (d + p) / g) : (g = 2 * Math.sqrt(1 + m - o - c),
        t[3] = (a - u) / g,
        t[0] = (f + l) / g,
        t[1] = (d + p) / g,
        t[2] = .25 * g),
        t
    }
    function Te(t, i, e, s) {
        i[0] = s[12],
        i[1] = s[13],
        i[2] = s[14];
        var n = s[0]
          , r = s[1]
          , h = s[2]
          , o = s[4]
          , a = s[5]
          , l = s[6]
          , u = s[8]
          , c = s[9]
          , d = s[10];
        e[0] = Math.hypot(n, r, h),
        e[1] = Math.hypot(o, a, l),
        e[2] = Math.hypot(u, c, d);
        var f = 1 / e[0]
          , p = 1 / e[1]
          , m = 1 / e[2]
          , w = n * f
          , g = r * p
          , y = h * m
          , b = o * f
          , v = a * p
          , S = l * m
          , x = u * f
          , M = c * p
          , E = d * m
          , C = w + v + E
          , _ = 0;
        return C > 0 ? (_ = 2 * Math.sqrt(C + 1),
        t[3] = .25 * _,
        t[0] = (S - M) / _,
        t[1] = (x - y) / _,
        t[2] = (g - b) / _) : w > v && w > E ? (_ = 2 * Math.sqrt(1 + w - v - E),
        t[3] = (S - M) / _,
        t[0] = .25 * _,
        t[1] = (g + b) / _,
        t[2] = (x + y) / _) : v > E ? (_ = 2 * Math.sqrt(1 + v - w - E),
        t[3] = (x - y) / _,
        t[0] = (g + b) / _,
        t[1] = .25 * _,
        t[2] = (S + M) / _) : (_ = 2 * Math.sqrt(1 + E - w - v),
        t[3] = (g - b) / _,
        t[0] = (x + y) / _,
        t[1] = (S + M) / _,
        t[2] = .25 * _),
        t
    }
    function Ie(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2]
          , o = i[3]
          , a = n + n
          , l = r + r
          , u = h + h
          , c = n * a
          , d = n * l
          , f = n * u
          , p = r * l
          , m = r * u
          , w = h * u
          , g = o * a
          , y = o * l
          , b = o * u
          , v = s[0]
          , S = s[1]
          , x = s[2];
        return t[0] = (1 - (p + w)) * v,
        t[1] = (d + b) * v,
        t[2] = (f - y) * v,
        t[3] = 0,
        t[4] = (d - b) * S,
        t[5] = (1 - (c + w)) * S,
        t[6] = (m + g) * S,
        t[7] = 0,
        t[8] = (f + y) * x,
        t[9] = (m - g) * x,
        t[10] = (1 - (c + p)) * x,
        t[11] = 0,
        t[12] = e[0],
        t[13] = e[1],
        t[14] = e[2],
        t[15] = 1,
        t
    }
    function Pe(t, i, e, s, n) {
        var r = i[0]
          , h = i[1]
          , o = i[2]
          , a = i[3]
          , l = r + r
          , u = h + h
          , c = o + o
          , d = r * l
          , f = r * u
          , p = r * c
          , m = h * u
          , w = h * c
          , g = o * c
          , y = a * l
          , b = a * u
          , v = a * c
          , S = s[0]
          , x = s[1]
          , M = s[2]
          , E = n[0]
          , C = n[1]
          , _ = n[2]
          , T = (1 - (m + g)) * S
          , I = (f + v) * S
          , P = (p - b) * S
          , G = (f - v) * x
          , A = (1 - (d + g)) * x
          , R = (w + y) * x
          , k = (p + b) * M
          , O = (w - y) * M
          , D = (1 - (d + m)) * M;
        return t[0] = T,
        t[1] = I,
        t[2] = P,
        t[3] = 0,
        t[4] = G,
        t[5] = A,
        t[6] = R,
        t[7] = 0,
        t[8] = k,
        t[9] = O,
        t[10] = D,
        t[11] = 0,
        t[12] = e[0] + E - (T * E + G * C + k * _),
        t[13] = e[1] + C - (I * E + A * C + O * _),
        t[14] = e[2] + _ - (P * E + R * C + D * _),
        t[15] = 1,
        t
    }
    function Ge(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e + e
          , o = s + s
          , a = n + n
          , l = e * h
          , u = s * h
          , c = s * o
          , d = n * h
          , f = n * o
          , p = n * a
          , m = r * h
          , w = r * o
          , g = r * a;
        return t[0] = 1 - c - p,
        t[1] = u + g,
        t[2] = d - w,
        t[3] = 0,
        t[4] = u - g,
        t[5] = 1 - l - p,
        t[6] = f + m,
        t[7] = 0,
        t[8] = d + w,
        t[9] = f - m,
        t[10] = 1 - l - c,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function Ae(t, i, e, s, n, r, h) {
        var o = 1 / (e - i)
          , a = 1 / (n - s)
          , l = 1 / (r - h);
        return t[0] = 2 * r * o,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = 2 * r * a,
        t[6] = 0,
        t[7] = 0,
        t[8] = (e + i) * o,
        t[9] = (n + s) * a,
        t[10] = (h + r) * l,
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[14] = h * r * 2 * l,
        t[15] = 0,
        t
    }
    function Re(t, i, e, s, n) {
        var r = 1 / Math.tan(i / 2);
        if (t[0] = r / e,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = r,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[15] = 0,
        null != n && n !== 1 / 0) {
            var h = 1 / (s - n);
            t[10] = (n + s) * h,
            t[14] = 2 * n * s * h
        } else
            t[10] = -1,
            t[14] = -2 * s;
        return t
    }
    var p = Re;
    function ke(t, i, e, s, n) {
        var r = 1 / Math.tan(i / 2);
        if (t[0] = r / e,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = r,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[15] = 0,
        null != n && n !== 1 / 0) {
            var h = 1 / (s - n);
            t[10] = n * h,
            t[14] = n * s * h
        } else
            t[10] = -1,
            t[14] = -s;
        return t
    }
    function Oe(t, i, e, s) {
        var n = Math.tan(i.upDegrees * Math.PI / 180)
          , r = Math.tan(i.downDegrees * Math.PI / 180)
          , h = Math.tan(i.leftDegrees * Math.PI / 180)
          , o = Math.tan(i.rightDegrees * Math.PI / 180)
          , a = 2 / (h + o)
          , l = 2 / (n + r);
        return t[0] = a,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = l,
        t[6] = 0,
        t[7] = 0,
        t[8] = -(h - o) * a * .5,
        t[9] = (n - r) * l * .5,
        t[10] = s / (e - s),
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[14] = s * e / (e - s),
        t[15] = 0,
        t
    }
    function De(t, i, e, s, n, r, h) {
        var o = 1 / (i - e)
          , a = 1 / (s - n)
          , l = 1 / (r - h);
        return t[0] = -2 * o,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = -2 * a,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 2 * l,
        t[11] = 0,
        t[12] = (i + e) * o,
        t[13] = (n + s) * a,
        t[14] = (h + r) * l,
        t[15] = 1,
        t
    }
    var m = De;
    function Fe(t, i, e, s, n, r, h) {
        var o = 1 / (i - e)
          , a = 1 / (s - n)
          , l = 1 / (r - h);
        return t[0] = -2 * o,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = -2 * a,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = l,
        t[11] = 0,
        t[12] = (i + e) * o,
        t[13] = (n + s) * a,
        t[14] = r * l,
        t[15] = 1,
        t
    }
    function Le(i, e, s, n) {
        var r, h, o, a, l, u, c, d, f, p, m = e[0], w = e[1], g = e[2], y = n[0], b = n[1], v = n[2], S = s[0], x = s[1], M = s[2];
        return Math.abs(m - S) < t && Math.abs(w - x) < t && Math.abs(g - M) < t ? ne(i) : (c = m - S,
        d = w - x,
        f = g - M,
        r = b * (f *= p = 1 / Math.hypot(c, d, f)) - v * (d *= p),
        h = v * (c *= p) - y * f,
        o = y * d - b * c,
        (p = Math.hypot(r, h, o)) ? (r *= p = 1 / p,
        h *= p,
        o *= p) : (r = 0,
        h = 0,
        o = 0),
        a = d * o - f * h,
        l = f * r - c * o,
        u = c * h - d * r,
        (p = Math.hypot(a, l, u)) ? (a *= p = 1 / p,
        l *= p,
        u *= p) : (a = 0,
        l = 0,
        u = 0),
        i[0] = r,
        i[1] = a,
        i[2] = c,
        i[3] = 0,
        i[4] = h,
        i[5] = l,
        i[6] = d,
        i[7] = 0,
        i[8] = o,
        i[9] = u,
        i[10] = f,
        i[11] = 0,
        i[12] = -(r * m + h * w + o * g),
        i[13] = -(a * m + l * w + u * g),
        i[14] = -(c * m + d * w + f * g),
        i[15] = 1,
        i)
    }
    function Be(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2]
          , o = s[0]
          , a = s[1]
          , l = s[2]
          , u = n - e[0]
          , c = r - e[1]
          , d = h - e[2]
          , f = u * u + c * c + d * d;
        f > 0 && (u *= f = 1 / Math.sqrt(f),
        c *= f,
        d *= f);
        var p = a * d - l * c
          , m = l * u - o * d
          , w = o * c - a * u;
        return (f = p * p + m * m + w * w) > 0 && (p *= f = 1 / Math.sqrt(f),
        m *= f,
        w *= f),
        t[0] = p,
        t[1] = m,
        t[2] = w,
        t[3] = 0,
        t[4] = c * w - d * m,
        t[5] = d * p - u * w,
        t[6] = u * m - c * p,
        t[7] = 0,
        t[8] = u,
        t[9] = c,
        t[10] = d,
        t[11] = 0,
        t[12] = n,
        t[13] = r,
        t[14] = h,
        t[15] = 1,
        t
    }
    function Ue(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
    }
    function Ne(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
    }
    function je(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t[6] = i[6] + e[6],
        t[7] = i[7] + e[7],
        t[8] = i[8] + e[8],
        t[9] = i[9] + e[9],
        t[10] = i[10] + e[10],
        t[11] = i[11] + e[11],
        t[12] = i[12] + e[12],
        t[13] = i[13] + e[13],
        t[14] = i[14] + e[14],
        t[15] = i[15] + e[15],
        t
    }
    function $e(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t[4] = i[4] - e[4],
        t[5] = i[5] - e[5],
        t[6] = i[6] - e[6],
        t[7] = i[7] - e[7],
        t[8] = i[8] - e[8],
        t[9] = i[9] - e[9],
        t[10] = i[10] - e[10],
        t[11] = i[11] - e[11],
        t[12] = i[12] - e[12],
        t[13] = i[13] - e[13],
        t[14] = i[14] - e[14],
        t[15] = i[15] - e[15],
        t
    }
    function ze(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t[6] = i[6] * e,
        t[7] = i[7] * e,
        t[8] = i[8] * e,
        t[9] = i[9] * e,
        t[10] = i[10] * e,
        t[11] = i[11] * e,
        t[12] = i[12] * e,
        t[13] = i[13] * e,
        t[14] = i[14] * e,
        t[15] = i[15] * e,
        t
    }
    function Ve(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t[4] = i[4] + e[4] * s,
        t[5] = i[5] + e[5] * s,
        t[6] = i[6] + e[6] * s,
        t[7] = i[7] + e[7] * s,
        t[8] = i[8] + e[8] * s,
        t[9] = i[9] + e[9] * s,
        t[10] = i[10] + e[10] * s,
        t[11] = i[11] + e[11] * s,
        t[12] = i[12] + e[12] * s,
        t[13] = i[13] + e[13] * s,
        t[14] = i[14] + e[14] * s,
        t[15] = i[15] + e[15] * s,
        t
    }
    function We(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5] && t[6] === i[6] && t[7] === i[7] && t[8] === i[8] && t[9] === i[9] && t[10] === i[10] && t[11] === i[11] && t[12] === i[12] && t[13] === i[13] && t[14] === i[14] && t[15] === i[15]
    }
    function He(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = i[9]
          , f = i[10]
          , p = i[11]
          , m = i[12]
          , w = i[13]
          , g = i[14]
          , y = i[15]
          , b = e[0]
          , v = e[1]
          , S = e[2]
          , x = e[3]
          , M = e[4]
          , E = e[5]
          , C = e[6]
          , _ = e[7]
          , T = e[8]
          , I = e[9]
          , P = e[10]
          , G = e[11]
          , A = e[12]
          , R = e[13]
          , k = e[14]
          , O = e[15];
        return Math.abs(s - b) <= t * Math.max(1, Math.abs(s), Math.abs(b)) && Math.abs(n - v) <= t * Math.max(1, Math.abs(n), Math.abs(v)) && Math.abs(r - S) <= t * Math.max(1, Math.abs(r), Math.abs(S)) && Math.abs(h - x) <= t * Math.max(1, Math.abs(h), Math.abs(x)) && Math.abs(o - M) <= t * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(a - E) <= t * Math.max(1, Math.abs(a), Math.abs(E)) && Math.abs(l - C) <= t * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(u - _) <= t * Math.max(1, Math.abs(u), Math.abs(_)) && Math.abs(c - T) <= t * Math.max(1, Math.abs(c), Math.abs(T)) && Math.abs(d - I) <= t * Math.max(1, Math.abs(d), Math.abs(I)) && Math.abs(f - P) <= t * Math.max(1, Math.abs(f), Math.abs(P)) && Math.abs(p - G) <= t * Math.max(1, Math.abs(p), Math.abs(G)) && Math.abs(m - A) <= t * Math.max(1, Math.abs(m), Math.abs(A)) && Math.abs(w - R) <= t * Math.max(1, Math.abs(w), Math.abs(R)) && Math.abs(g - k) <= t * Math.max(1, Math.abs(g), Math.abs(k)) && Math.abs(y - O) <= t * Math.max(1, Math.abs(y), Math.abs(O))
    }
    var w = le
      , g = $e
      , y = Object.freeze({
        __proto__: null,
        create: Qi,
        clone: te,
        Qr: ie,
        r6t: ee,
        set: se,
        identity: ne,
        h6t: re,
        o6t: he,
        a6t: oe,
        l6t: ae,
        multiply: le,
        translate: ue,
        scale: ce,
        rotate: de,
        C6t: fe,
        _6t: pe,
        T6t: me,
        b6t: we,
        c6t: ge,
        u6t: ye,
        I6t: be,
        P6t: ve,
        G6t: Se,
        A6t: xe,
        R6t: Me,
        k6t: Ee,
        O6t: Ce,
        D6t: _e,
        F6t: Te,
        L6t: Ie,
        B6t: Pe,
        x6t: Ge,
        U6t: Ae,
        N6t: Re,
        perspective: p,
        j6t: ke,
        $6t: Oe,
        z6t: De,
        V6t: m,
        W6t: Fe,
        H6t: Le,
        K6t: Be,
        d6t: Ue,
        f6t: Ne,
        add: je,
        m6t: $e,
        g6t: ze,
        y6t: Ve,
        w6t: We,
        equals: He,
        mul: w,
        sub: g
    });
    function Ke() {
        var t = new i(3);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0),
        t
    }
    function qe(t) {
        var e = new i(3);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e
    }
    function Xe(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2];
        return Math.hypot(i, e, s)
    }
    function Ye(t, e, s) {
        var n = new i(3);
        return n[0] = t,
        n[1] = e,
        n[2] = s,
        n
    }
    function Je(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t
    }
    function Ze(t, i, e, s) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t
    }
    function Qe(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t
    }
    function ts(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t
    }
    function is(t, i, e) {
        return t[0] = i[0] * e[0],
        t[1] = i[1] * e[1],
        t[2] = i[2] * e[2],
        t
    }
    function es(t, i, e) {
        return t[0] = i[0] / e[0],
        t[1] = i[1] / e[1],
        t[2] = i[2] / e[2],
        t
    }
    function ss(t, i) {
        return t[0] = Math.ceil(i[0]),
        t[1] = Math.ceil(i[1]),
        t[2] = Math.ceil(i[2]),
        t
    }
    function ns(t, i) {
        return t[0] = Math.floor(i[0]),
        t[1] = Math.floor(i[1]),
        t[2] = Math.floor(i[2]),
        t
    }
    function rs(t, i, e) {
        return t[0] = Math.min(i[0], e[0]),
        t[1] = Math.min(i[1], e[1]),
        t[2] = Math.min(i[2], e[2]),
        t
    }
    function hs(t, i, e) {
        return t[0] = Math.max(i[0], e[0]),
        t[1] = Math.max(i[1], e[1]),
        t[2] = Math.max(i[2], e[2]),
        t
    }
    function os(t, i) {
        return t[0] = Math.round(i[0]),
        t[1] = Math.round(i[1]),
        t[2] = Math.round(i[2]),
        t
    }
    function as(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t
    }
    function ls(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t
    }
    function us(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2];
        return Math.hypot(e, s, n)
    }
    function cs(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2];
        return e * e + s * s + n * n
    }
    function ds(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2];
        return i * i + e * e + s * s
    }
    function fs(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t
    }
    function ps(t, i) {
        return t[0] = 1 / i[0],
        t[1] = 1 / i[1],
        t[2] = 1 / i[2],
        t
    }
    function ms(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = e * e + s * s + n * n;
        return r > 0 && (r = 1 / Math.sqrt(r)),
        t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t
    }
    function ws(t, i) {
        return t[0] * i[0] + t[1] * i[1] + t[2] * i[2]
    }
    function gs(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[0]
          , o = e[1]
          , a = e[2];
        return t[0] = n * a - r * o,
        t[1] = r * h - s * a,
        t[2] = s * o - n * h,
        t
    }
    function ys(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2];
        return t[0] = n + s * (e[0] - n),
        t[1] = r + s * (e[1] - r),
        t[2] = h + s * (e[2] - h),
        t
    }
    function bs(t, i, e, s) {
        var n = Math.acos(Math.min(Math.max(ws(i, e), -1), 1))
          , r = Math.sin(n)
          , h = Math.sin((1 - s) * n) / r
          , o = Math.sin(s * n) / r;
        return t[0] = h * i[0] + o * e[0],
        t[1] = h * i[1] + o * e[1],
        t[2] = h * i[2] + o * e[2],
        t
    }
    function vs(t, i, e, s, n, r) {
        var h = r * r
          , o = h * (2 * r - 3) + 1
          , a = h * (r - 2) + r
          , l = h * (r - 1)
          , u = h * (3 - 2 * r);
        return t[0] = i[0] * o + e[0] * a + s[0] * l + n[0] * u,
        t[1] = i[1] * o + e[1] * a + s[1] * l + n[1] * u,
        t[2] = i[2] * o + e[2] * a + s[2] * l + n[2] * u,
        t
    }
    function Ss(t, i, e, s, n, r) {
        var h = 1 - r
          , o = h * h
          , a = r * r
          , l = o * h
          , u = 3 * r * o
          , c = 3 * a * h
          , d = a * r;
        return t[0] = i[0] * l + e[0] * u + s[0] * c + n[0] * d,
        t[1] = i[1] * l + e[1] * u + s[1] * c + n[1] * d,
        t[2] = i[2] * l + e[2] * u + s[2] * c + n[2] * d,
        t
    }
    function xs(t, i) {
        i = i || 1;
        var s = 2 * e() * Math.PI
          , n = 2 * e() - 1
          , r = Math.sqrt(1 - n * n) * i;
        return t[0] = Math.cos(s) * r,
        t[1] = Math.sin(s) * r,
        t[2] = n * i,
        t
    }
    function Ms(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[3] * s + e[7] * n + e[11] * r + e[15];
        return h = h || 1,
        t[0] = (e[0] * s + e[4] * n + e[8] * r + e[12]) / h,
        t[1] = (e[1] * s + e[5] * n + e[9] * r + e[13]) / h,
        t[2] = (e[2] * s + e[6] * n + e[10] * r + e[14]) / h,
        t
    }
    function Es(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2];
        return t[0] = s * e[0] + n * e[3] + r * e[6],
        t[1] = s * e[1] + n * e[4] + r * e[7],
        t[2] = s * e[2] + n * e[5] + r * e[8],
        t
    }
    function Cs(t, i, e) {
        var s = e[0]
          , n = e[1]
          , r = e[2]
          , h = e[3]
          , o = i[0]
          , a = i[1]
          , l = i[2]
          , u = n * l - r * a
          , c = r * o - s * l
          , d = s * a - n * o
          , f = n * d - r * c
          , p = r * u - s * d
          , m = s * c - n * u
          , w = 2 * h;
        return u *= w,
        c *= w,
        d *= w,
        f *= 2,
        p *= 2,
        m *= 2,
        t[0] = o + u + f,
        t[1] = a + c + p,
        t[2] = l + d + m,
        t
    }
    function _s(t, i, e, s) {
        var n = []
          , r = [];
        return n[0] = i[0] - e[0],
        n[1] = i[1] - e[1],
        n[2] = i[2] - e[2],
        r[0] = n[0],
        r[1] = n[1] * Math.cos(s) - n[2] * Math.sin(s),
        r[2] = n[1] * Math.sin(s) + n[2] * Math.cos(s),
        t[0] = r[0] + e[0],
        t[1] = r[1] + e[1],
        t[2] = r[2] + e[2],
        t
    }
    function Ts(t, i, e, s) {
        var n = []
          , r = [];
        return n[0] = i[0] - e[0],
        n[1] = i[1] - e[1],
        n[2] = i[2] - e[2],
        r[0] = n[2] * Math.sin(s) + n[0] * Math.cos(s),
        r[1] = n[1],
        r[2] = n[2] * Math.cos(s) - n[0] * Math.sin(s),
        t[0] = r[0] + e[0],
        t[1] = r[1] + e[1],
        t[2] = r[2] + e[2],
        t
    }
    function Is(t, i, e, s) {
        var n = []
          , r = [];
        return n[0] = i[0] - e[0],
        n[1] = i[1] - e[1],
        n[2] = i[2] - e[2],
        r[0] = n[0] * Math.cos(s) - n[1] * Math.sin(s),
        r[1] = n[0] * Math.sin(s) + n[1] * Math.cos(s),
        r[2] = n[2],
        t[0] = r[0] + e[0],
        t[1] = r[1] + e[1],
        t[2] = r[2] + e[2],
        t
    }
    function Ps(t, i) {
        var e = t[0]
          , s = t[1]
          , n = t[2]
          , r = i[0]
          , h = i[1]
          , o = i[2]
          , a = Math.sqrt((e * e + s * s + n * n) * (r * r + h * h + o * o))
          , l = a && ws(t, i) / a;
        return Math.acos(Math.min(Math.max(l, -1), 1))
    }
    function Gs(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t
    }
    function As(t) {
        return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
    }
    function Rs(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2]
    }
    function ks(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[0]
          , o = e[1]
          , a = e[2];
        return Math.abs(s - h) <= t * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(n - o) <= t * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - a) <= t * Math.max(1, Math.abs(r), Math.abs(a))
    }
    var b = ts
      , v = is
      , S = es
      , x = us
      , M = cs
      , E = Xe
      , C = ds
      , _ = (_t = Ke(),
    function(t, i, e, s, n, r) {
        var h, o;
        for (i || (i = 3),
        e || (e = 0),
        o = s ? Math.min(s * i + e, t.length) : t.length,
        h = e; h < o; h += i)
            _t[0] = t[h],
            _t[1] = t[h + 1],
            _t[2] = t[h + 2],
            n(_t, _t, r),
            t[h] = _t[0],
            t[h + 1] = _t[1],
            t[h + 2] = _t[2];
        return t
    }
    )
      , T = Object.freeze({
        __proto__: null,
        create: Ke,
        clone: qe,
        length: Xe,
        r6t: Ye,
        Qr: Je,
        set: Ze,
        add: Qe,
        m6t: ts,
        multiply: is,
        xm: es,
        ceil: ss,
        floor: ns,
        min: rs,
        max: hs,
        round: os,
        scale: as,
        q6t: ls,
        X6t: us,
        Y6t: cs,
        J6t: ds,
        Z6t: fs,
        inverse: ps,
        normalize: ms,
        dot: ws,
        Q6t: gs,
        mi: ys,
        t8t: bs,
        i8t: vs,
        e8t: Ss,
        random: xs,
        s8t: Ms,
        n8t: Es,
        r8t: Cs,
        C6t: _s,
        _6t: Ts,
        T6t: Is,
        angle: Ps,
        h8t: Gs,
        d6t: As,
        w6t: Rs,
        equals: ks,
        sub: b,
        mul: v,
        div: S,
        o8t: x,
        a8t: M,
        l8t: E,
        u8t: C,
        forEach: _
    });
    function Os() {
        var t = new i(4);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0),
        t
    }
    function Ds(t) {
        var e = new i(4);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e
    }
    function Fs(t, e, s, n) {
        var r = new i(4);
        return r[0] = t,
        r[1] = e,
        r[2] = s,
        r[3] = n,
        r
    }
    function Ls(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t
    }
    function Bs(t, i, e, s, n) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t
    }
    function Us(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t
    }
    function Ns(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t
    }
    function js(t, i, e) {
        return t[0] = i[0] * e[0],
        t[1] = i[1] * e[1],
        t[2] = i[2] * e[2],
        t[3] = i[3] * e[3],
        t
    }
    function $s(t, i, e) {
        return t[0] = i[0] / e[0],
        t[1] = i[1] / e[1],
        t[2] = i[2] / e[2],
        t[3] = i[3] / e[3],
        t
    }
    function zs(t, i) {
        return t[0] = Math.ceil(i[0]),
        t[1] = Math.ceil(i[1]),
        t[2] = Math.ceil(i[2]),
        t[3] = Math.ceil(i[3]),
        t
    }
    function Vs(t, i) {
        return t[0] = Math.floor(i[0]),
        t[1] = Math.floor(i[1]),
        t[2] = Math.floor(i[2]),
        t[3] = Math.floor(i[3]),
        t
    }
    function Ws(t, i, e) {
        return t[0] = Math.min(i[0], e[0]),
        t[1] = Math.min(i[1], e[1]),
        t[2] = Math.min(i[2], e[2]),
        t[3] = Math.min(i[3], e[3]),
        t
    }
    function Hs(t, i, e) {
        return t[0] = Math.max(i[0], e[0]),
        t[1] = Math.max(i[1], e[1]),
        t[2] = Math.max(i[2], e[2]),
        t[3] = Math.max(i[3], e[3]),
        t
    }
    function Ks(t, i) {
        return t[0] = Math.round(i[0]),
        t[1] = Math.round(i[1]),
        t[2] = Math.round(i[2]),
        t[3] = Math.round(i[3]),
        t
    }
    function qs(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t
    }
    function Xs(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t
    }
    function Ys(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2]
          , r = i[3] - t[3];
        return Math.hypot(e, s, n, r)
    }
    function Js(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2]
          , r = i[3] - t[3];
        return e * e + s * s + n * n + r * r
    }
    function Zs(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3];
        return Math.hypot(i, e, s, n)
    }
    function Qs(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3];
        return i * i + e * e + s * s + n * n
    }
    function tn(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = -i[3],
        t
    }
    function en(t, i) {
        return t[0] = 1 / i[0],
        t[1] = 1 / i[1],
        t[2] = 1 / i[2],
        t[3] = 1 / i[3],
        t
    }
    function sn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e * e + s * s + n * n + r * r;
        return h > 0 && (h = 1 / Math.sqrt(h)),
        t[0] = e * h,
        t[1] = s * h,
        t[2] = n * h,
        t[3] = r * h,
        t
    }
    function nn(t, i) {
        return t[0] * i[0] + t[1] * i[1] + t[2] * i[2] + t[3] * i[3]
    }
    function rn(t, i, e, s) {
        var n = e[0] * s[1] - e[1] * s[0]
          , r = e[0] * s[2] - e[2] * s[0]
          , h = e[0] * s[3] - e[3] * s[0]
          , o = e[1] * s[2] - e[2] * s[1]
          , a = e[1] * s[3] - e[3] * s[1]
          , l = e[2] * s[3] - e[3] * s[2]
          , u = i[0]
          , c = i[1]
          , d = i[2]
          , f = i[3];
        return t[0] = c * l - d * a + f * o,
        t[1] = -u * l + d * h - f * r,
        t[2] = u * a - c * h + f * n,
        t[3] = -u * o + c * r - d * n,
        t
    }
    function hn(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2]
          , o = i[3];
        return t[0] = n + s * (e[0] - n),
        t[1] = r + s * (e[1] - r),
        t[2] = h + s * (e[2] - h),
        t[3] = o + s * (e[3] - o),
        t
    }
    function on(t, i) {
        var s, n, r, h, o, a;
        i = i || 1;
        do {
            o = (s = 2 * e() - 1) * s + (n = 2 * e() - 1) * n
        } while (o >= 1);
        do {
            a = (r = 2 * e() - 1) * r + (h = 2 * e() - 1) * h
        } while (a >= 1);
        var l = Math.sqrt((1 - o) / a);
        return t[0] = i * s,
        t[1] = i * n,
        t[2] = i * r * l,
        t[3] = i * h * l,
        t
    }
    function an(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3];
        return t[0] = e[0] * s + e[4] * n + e[8] * r + e[12] * h,
        t[1] = e[1] * s + e[5] * n + e[9] * r + e[13] * h,
        t[2] = e[2] * s + e[6] * n + e[10] * r + e[14] * h,
        t[3] = e[3] * s + e[7] * n + e[11] * r + e[15] * h,
        t
    }
    function ln(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[0]
          , o = e[1]
          , a = e[2]
          , l = e[3]
          , u = l * s + o * r - a * n
          , c = l * n + a * s - h * r
          , d = l * r + h * n - o * s
          , f = -h * s - o * n - a * r;
        return t[0] = u * l + f * -h + c * -a - d * -o,
        t[1] = c * l + f * -o + d * -h - u * -a,
        t[2] = d * l + f * -a + u * -o - c * -h,
        t[3] = i[3],
        t
    }
    function un(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t
    }
    function cn(t) {
        return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }
    function dn(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3]
    }
    function fn(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return Math.abs(s - o) <= t * Math.max(1, Math.abs(s), Math.abs(o)) && Math.abs(n - a) <= t * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - l) <= t * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(h - u) <= t * Math.max(1, Math.abs(h), Math.abs(u))
    }
    var I = Ns
      , P = js
      , G = $s
      , A = Ys
      , R = Js
      , k = Zs
      , O = Qs
      , D = function() {
        var t = Os();
        return function(i, e, s, n, r, h) {
            var o, a;
            for (e || (e = 4),
            s || (s = 0),
            a = n ? Math.min(n * e + s, i.length) : i.length,
            o = s; o < a; o += e)
                t[0] = i[o],
                t[1] = i[o + 1],
                t[2] = i[o + 2],
                t[3] = i[o + 3],
                r(t, t, h),
                i[o] = t[0],
                i[o + 1] = t[1],
                i[o + 2] = t[2],
                i[o + 3] = t[3];
            return i
        }
    }()
      , F = Object.freeze({
        __proto__: null,
        create: Os,
        clone: Ds,
        r6t: Fs,
        Qr: Ls,
        set: Bs,
        add: Us,
        m6t: Ns,
        multiply: js,
        xm: $s,
        ceil: zs,
        floor: Vs,
        min: Ws,
        max: Hs,
        round: Ks,
        scale: qs,
        q6t: Xs,
        X6t: Ys,
        Y6t: Js,
        length: Zs,
        J6t: Qs,
        Z6t: tn,
        inverse: en,
        normalize: sn,
        dot: nn,
        Q6t: rn,
        mi: hn,
        random: on,
        s8t: an,
        r8t: ln,
        h8t: un,
        d6t: cn,
        w6t: dn,
        equals: fn,
        sub: I,
        mul: P,
        div: G,
        o8t: A,
        a8t: R,
        l8t: k,
        u8t: O,
        forEach: D
    });
    function pn() {
        var t = new i(4);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0),
        t[3] = 1,
        t
    }
    function mn(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t
    }
    function wn(t, i, e) {
        e *= .5;
        var s = Math.sin(e);
        return t[0] = s * i[0],
        t[1] = s * i[1],
        t[2] = s * i[2],
        t[3] = Math.cos(e),
        t
    }
    function gn(i, e) {
        var s = 2 * Math.acos(e[3])
          , n = Math.sin(s / 2);
        return n > t ? (i[0] = e[0] / n,
        i[1] = e[1] / n,
        i[2] = e[2] / n) : (i[0] = 1,
        i[1] = 0,
        i[2] = 0),
        s
    }
    function yn(t, i) {
        var e = V(t, i);
        return Math.acos(2 * e * e - 1)
    }
    function bn(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return t[0] = s * u + h * o + n * l - r * a,
        t[1] = n * u + h * a + r * o - s * l,
        t[2] = r * u + h * l + s * a - n * o,
        t[3] = h * u - s * o - n * a - r * l,
        t
    }
    function vn(t, i, e) {
        e *= .5;
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a + h * o,
        t[1] = n * a + r * o,
        t[2] = r * a - n * o,
        t[3] = h * a - s * o,
        t
    }
    function Sn(t, i, e) {
        e *= .5;
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a - r * o,
        t[1] = n * a + h * o,
        t[2] = r * a + s * o,
        t[3] = h * a - n * o,
        t
    }
    function xn(t, i, e) {
        e *= .5;
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a + n * o,
        t[1] = n * a - s * o,
        t[2] = r * a + h * o,
        t[3] = h * a - r * o,
        t
    }
    function Mn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2];
        return t[0] = e,
        t[1] = s,
        t[2] = n,
        t[3] = Math.sqrt(Math.abs(1 - e * e - s * s - n * n)),
        t
    }
    function En(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = Math.sqrt(e * e + s * s + n * n)
          , o = Math.exp(r)
          , a = h > 0 ? o * Math.sin(h) / h : 0;
        return t[0] = e * a,
        t[1] = s * a,
        t[2] = n * a,
        t[3] = o * Math.cos(h),
        t
    }
    function Cn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = Math.sqrt(e * e + s * s + n * n)
          , o = h > 0 ? Math.atan2(h, r) / h : 0;
        return t[0] = e * o,
        t[1] = s * o,
        t[2] = n * o,
        t[3] = .5 * Math.log(e * e + s * s + n * n + r * r),
        t
    }
    function _n(t, i, e) {
        return Cn(t, i),
        z(t, t, e),
        En(t, t),
        t
    }
    function Tn(i, e, s, n) {
        var r, h, o, a, l, u = e[0], c = e[1], d = e[2], f = e[3], p = s[0], m = s[1], w = s[2], g = s[3];
        return (h = u * p + c * m + d * w + f * g) < 0 && (h = -h,
        p = -p,
        m = -m,
        w = -w,
        g = -g),
        1 - h > t ? (r = Math.acos(h),
        o = Math.sin(r),
        a = Math.sin((1 - n) * r) / o,
        l = Math.sin(n * r) / o) : (a = 1 - n,
        l = n),
        i[0] = a * u + l * p,
        i[1] = a * c + l * m,
        i[2] = a * d + l * w,
        i[3] = a * f + l * g,
        i
    }
    function In(t) {
        var i = e()
          , s = e()
          , n = e()
          , r = Math.sqrt(1 - i)
          , h = Math.sqrt(i);
        return t[0] = r * Math.sin(2 * Math.PI * s),
        t[1] = r * Math.cos(2 * Math.PI * s),
        t[2] = h * Math.sin(2 * Math.PI * n),
        t[3] = h * Math.cos(2 * Math.PI * n),
        t
    }
    function Pn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e * e + s * s + n * n + r * r
          , o = h ? 1 / h : 0;
        return t[0] = -e * o,
        t[1] = -s * o,
        t[2] = -n * o,
        t[3] = r * o,
        t
    }
    function Gn(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = i[3],
        t
    }
    function An(t, i) {
        var e, s = i[0] + i[4] + i[8];
        if (s > 0)
            e = Math.sqrt(s + 1),
            t[3] = .5 * e,
            e = .5 / e,
            t[0] = (i[5] - i[7]) * e,
            t[1] = (i[6] - i[2]) * e,
            t[2] = (i[1] - i[3]) * e;
        else {
            var n = 0;
            i[4] > i[0] && (n = 1),
            i[8] > i[3 * n + n] && (n = 2);
            var r = (n + 1) % 3
              , h = (n + 2) % 3;
            e = Math.sqrt(i[3 * n + n] - i[3 * r + r] - i[3 * h + h] + 1),
            t[n] = .5 * e,
            e = .5 / e,
            t[3] = (i[3 * r + h] - i[3 * h + r]) * e,
            t[r] = (i[3 * r + n] + i[3 * n + r]) * e,
            t[h] = (i[3 * h + n] + i[3 * n + h]) * e
        }
        return t
    }
    function Rn(t, i, e, s) {
        var n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "zyx"
          , r = Math.PI / 360;
        i *= r,
        s *= r,
        e *= r;
        var h = Math.sin(i)
          , o = Math.cos(i)
          , a = Math.sin(e)
          , l = Math.cos(e)
          , u = Math.sin(s)
          , c = Math.cos(s);
        switch (n) {
        case "xyz":
            t[0] = h * l * c + o * a * u,
            t[1] = o * a * c - h * l * u,
            t[2] = o * l * u + h * a * c,
            t[3] = o * l * c - h * a * u;
            break;
        case "xzy":
            t[0] = h * l * c - o * a * u,
            t[1] = o * a * c - h * l * u,
            t[2] = o * l * u + h * a * c,
            t[3] = o * l * c + h * a * u;
            break;
        case "yxz":
            t[0] = h * l * c + o * a * u,
            t[1] = o * a * c - h * l * u,
            t[2] = o * l * u - h * a * c,
            t[3] = o * l * c + h * a * u;
            break;
        case "yzx":
            t[0] = h * l * c + o * a * u,
            t[1] = o * a * c + h * l * u,
            t[2] = o * l * u - h * a * c,
            t[3] = o * l * c - h * a * u;
            break;
        case "zxy":
            t[0] = h * l * c - o * a * u,
            t[1] = o * a * c + h * l * u,
            t[2] = o * l * u + h * a * c,
            t[3] = o * l * c - h * a * u;
            break;
        case "zyx":
            t[0] = h * l * c - o * a * u,
            t[1] = o * a * c + h * l * u,
            t[2] = o * l * u - h * a * c,
            t[3] = o * l * c + h * a * u;
            break;
        default:
            throw new Error("Unknown angle order " + n)
        }
        return t
    }
    function kn(t) {
        return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }
    var L = Ds
      , B = Fs
      , U = Ls
      , N = Bs
      , j = Us
      , $ = bn
      , z = qs
      , V = nn
      , W = hn
      , H = Zs
      , K = H
      , q = Qs
      , X = q
      , Y = sn
      , J = dn;
    function On(t, i) {
        return Math.abs(nn(t, i)) >= .999999
    }
    var Z = (Mt = Ke(),
    Et = Ye(1, 0, 0),
    Ct = Ye(0, 1, 0),
    function(t, i, e) {
        var s = ws(i, e);
        return s < -.999999 ? (gs(Mt, Et, i),
        E(Mt) < 1e-6 && gs(Mt, Ct, i),
        ms(Mt, Mt),
        wn(t, Mt, Math.PI),
        t) : s > .999999 ? (t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t) : (gs(Mt, i, e),
        t[0] = Mt[0],
        t[1] = Mt[1],
        t[2] = Mt[2],
        t[3] = 1 + s,
        Y(t, t))
    }
    )
      , Q = (St = pn(),
    xt = pn(),
    function(t, i, e, s, n, r) {
        return Tn(St, i, n, r),
        Tn(xt, e, s, r),
        Tn(t, St, xt, 2 * r * (1 - r)),
        t
    }
    )
      , tt = (vt = Mi(),
    function(t, i, e, s) {
        return vt[0] = e[0],
        vt[3] = e[1],
        vt[6] = e[2],
        vt[1] = s[0],
        vt[4] = s[1],
        vt[7] = s[2],
        vt[2] = -i[0],
        vt[5] = -i[1],
        vt[8] = -i[2],
        Y(t, An(t, vt))
    }
    )
      , it = Object.freeze({
        __proto__: null,
        create: pn,
        identity: mn,
        c8t: wn,
        d8t: gn,
        f8t: yn,
        multiply: bn,
        C6t: vn,
        _6t: Sn,
        T6t: xn,
        p8t: Mn,
        exp: En,
        ln: Cn,
        pow: _n,
        t8t: Tn,
        random: In,
        o6t: Pn,
        m8t: Gn,
        w8t: An,
        g8t: Rn,
        d6t: kn,
        clone: L,
        r6t: B,
        Qr: U,
        set: N,
        add: j,
        mul: $,
        scale: z,
        dot: V,
        mi: W,
        length: H,
        l8t: K,
        J6t: q,
        u8t: X,
        normalize: Y,
        w6t: J,
        equals: On,
        y8t: Z,
        b8t: Q,
        v8t: tt
    });
    function Dn() {
        var t = new i(8);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[4] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0),
        t[3] = 1,
        t
    }
    function Fn(t) {
        var e = new i(8);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e
    }
    function Ln(t, e, s, n, r, h, o, a) {
        var l = new i(8);
        return l[0] = t,
        l[1] = e,
        l[2] = s,
        l[3] = n,
        l[4] = r,
        l[5] = h,
        l[6] = o,
        l[7] = a,
        l
    }
    function Bn(t, e, s, n, r, h, o) {
        var a = new i(8);
        a[0] = t,
        a[1] = e,
        a[2] = s,
        a[3] = n;
        var l = .5 * r
          , u = .5 * h
          , c = .5 * o;
        return a[4] = l * n + u * s - c * e,
        a[5] = u * n + c * t - l * s,
        a[6] = c * n + l * e - u * t,
        a[7] = -l * t - u * e - c * s,
        a
    }
    function Un(t, i, e) {
        var s = .5 * e[0]
          , n = .5 * e[1]
          , r = .5 * e[2]
          , h = i[0]
          , o = i[1]
          , a = i[2]
          , l = i[3];
        return t[0] = h,
        t[1] = o,
        t[2] = a,
        t[3] = l,
        t[4] = s * l + n * a - r * o,
        t[5] = n * l + r * h - s * a,
        t[6] = r * l + s * o - n * h,
        t[7] = -s * h - n * o - r * a,
        t
    }
    function Nn(t, i) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = .5 * i[0],
        t[5] = .5 * i[1],
        t[6] = .5 * i[2],
        t[7] = 0,
        t
    }
    function jn(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t
    }
    function $n(t, e) {
        var s = pn();
        _e(s, e);
        var n = new i(3);
        return Ee(n, e),
        Un(t, s, n),
        t
    }
    function zn(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t
    }
    function Vn(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t
    }
    function Wn(t, i, e, s, n, r, h, o, a) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t[6] = o,
        t[7] = a,
        t
    }
    var et = U;
    function Hn(t, i) {
        return t[0] = i[4],
        t[1] = i[5],
        t[2] = i[6],
        t[3] = i[7],
        t
    }
    var st = U;
    function Kn(t, i) {
        return t[4] = i[0],
        t[5] = i[1],
        t[6] = i[2],
        t[7] = i[3],
        t
    }
    function qn(t, i) {
        var e = i[4]
          , s = i[5]
          , n = i[6]
          , r = i[7]
          , h = -i[0]
          , o = -i[1]
          , a = -i[2]
          , l = i[3];
        return t[0] = 2 * (e * l + r * h + s * a - n * o),
        t[1] = 2 * (s * l + r * o + n * h - e * a),
        t[2] = 2 * (n * l + r * a + e * o - s * h),
        t
    }
    function Xn(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = .5 * e[0]
          , a = .5 * e[1]
          , l = .5 * e[2]
          , u = i[4]
          , c = i[5]
          , d = i[6]
          , f = i[7];
        return t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = h * o + n * l - r * a + u,
        t[5] = h * a + r * o - s * l + c,
        t[6] = h * l + s * a - n * o + d,
        t[7] = -s * o - n * a - r * l + f,
        t
    }
    function Yn(t, i, e) {
        var s = -i[0]
          , n = -i[1]
          , r = -i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = o * h + u * s + a * r - l * n
          , d = a * h + u * n + l * s - o * r
          , f = l * h + u * r + o * n - a * s
          , p = u * h - o * s - a * n - l * r;
        return vn(t, i, e),
        s = t[0],
        n = t[1],
        r = t[2],
        h = t[3],
        t[4] = c * h + p * s + d * r - f * n,
        t[5] = d * h + p * n + f * s - c * r,
        t[6] = f * h + p * r + c * n - d * s,
        t[7] = p * h - c * s - d * n - f * r,
        t
    }
    function Jn(t, i, e) {
        var s = -i[0]
          , n = -i[1]
          , r = -i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = o * h + u * s + a * r - l * n
          , d = a * h + u * n + l * s - o * r
          , f = l * h + u * r + o * n - a * s
          , p = u * h - o * s - a * n - l * r;
        return Sn(t, i, e),
        s = t[0],
        n = t[1],
        r = t[2],
        h = t[3],
        t[4] = c * h + p * s + d * r - f * n,
        t[5] = d * h + p * n + f * s - c * r,
        t[6] = f * h + p * r + c * n - d * s,
        t[7] = p * h - c * s - d * n - f * r,
        t
    }
    function Zn(t, i, e) {
        var s = -i[0]
          , n = -i[1]
          , r = -i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = o * h + u * s + a * r - l * n
          , d = a * h + u * n + l * s - o * r
          , f = l * h + u * r + o * n - a * s
          , p = u * h - o * s - a * n - l * r;
        return xn(t, i, e),
        s = t[0],
        n = t[1],
        r = t[2],
        h = t[3],
        t[4] = c * h + p * s + d * r - f * n,
        t[5] = d * h + p * n + f * s - c * r,
        t[6] = f * h + p * r + c * n - d * s,
        t[7] = p * h - c * s - d * n - f * r,
        t
    }
    function Qn(t, i, e) {
        var s = e[0]
          , n = e[1]
          , r = e[2]
          , h = e[3]
          , o = i[0]
          , a = i[1]
          , l = i[2]
          , u = i[3];
        return t[0] = o * h + u * s + a * r - l * n,
        t[1] = a * h + u * n + l * s - o * r,
        t[2] = l * h + u * r + o * n - a * s,
        t[3] = u * h - o * s - a * n - l * r,
        o = i[4],
        a = i[5],
        l = i[6],
        u = i[7],
        t[4] = o * h + u * s + a * r - l * n,
        t[5] = a * h + u * n + l * s - o * r,
        t[6] = l * h + u * r + o * n - a * s,
        t[7] = u * h - o * s - a * n - l * r,
        t
    }
    function tr(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return t[0] = s * u + h * o + n * l - r * a,
        t[1] = n * u + h * a + r * o - s * l,
        t[2] = r * u + h * l + s * a - n * o,
        t[3] = h * u - s * o - n * a - r * l,
        o = e[4],
        a = e[5],
        l = e[6],
        u = e[7],
        t[4] = s * u + h * o + n * l - r * a,
        t[5] = n * u + h * a + r * o - s * l,
        t[6] = r * u + h * l + s * a - n * o,
        t[7] = h * u - s * o - n * a - r * l,
        t
    }
    function ir(i, e, s, n) {
        if (Math.abs(n) < t)
            return zn(i, e);
        var r = Math.hypot(s[0], s[1], s[2]);
        n *= .5;
        var h = Math.sin(n)
          , o = h * s[0] / r
          , a = h * s[1] / r
          , l = h * s[2] / r
          , u = Math.cos(n)
          , c = e[0]
          , d = e[1]
          , f = e[2]
          , p = e[3];
        i[0] = c * u + p * o + d * l - f * a,
        i[1] = d * u + p * a + f * o - c * l,
        i[2] = f * u + p * l + c * a - d * o,
        i[3] = p * u - c * o - d * a - f * l;
        var m = e[4]
          , w = e[5]
          , g = e[6]
          , y = e[7];
        return i[4] = m * u + y * o + w * l - g * a,
        i[5] = w * u + y * a + g * o - m * l,
        i[6] = g * u + y * l + m * a - w * o,
        i[7] = y * u - m * o - w * a - g * l,
        i
    }
    function er(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t[6] = i[6] + e[6],
        t[7] = i[7] + e[7],
        t
    }
    function sr(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , u = e[7]
          , c = i[4]
          , d = i[5]
          , f = i[6]
          , p = i[7]
          , m = e[0]
          , w = e[1]
          , g = e[2]
          , y = e[3];
        return t[0] = s * y + h * m + n * g - r * w,
        t[1] = n * y + h * w + r * m - s * g,
        t[2] = r * y + h * g + s * w - n * m,
        t[3] = h * y - s * m - n * w - r * g,
        t[4] = s * u + h * o + n * l - r * a + c * y + p * m + d * g - f * w,
        t[5] = n * u + h * a + r * o - s * l + d * y + p * w + f * m - c * g,
        t[6] = r * u + h * l + s * a - n * o + f * y + p * g + c * w - d * m,
        t[7] = h * u - s * o - n * a - r * l + p * y - c * m - d * w - f * g,
        t
    }
    var nt = sr;
    function nr(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t[6] = i[6] * e,
        t[7] = i[7] * e,
        t
    }
    var rt = V;
    function rr(t, i, e, s) {
        var n = 1 - s;
        return rt(i, e) < 0 && (s = -s),
        t[0] = i[0] * n + e[0] * s,
        t[1] = i[1] * n + e[1] * s,
        t[2] = i[2] * n + e[2] * s,
        t[3] = i[3] * n + e[3] * s,
        t[4] = i[4] * n + e[4] * s,
        t[5] = i[5] * n + e[5] * s,
        t[6] = i[6] * n + e[6] * s,
        t[7] = i[7] * n + e[7] * s,
        t
    }
    function hr(t, i) {
        var e = at(i);
        return t[0] = -i[0] / e,
        t[1] = -i[1] / e,
        t[2] = -i[2] / e,
        t[3] = i[3] / e,
        t[4] = -i[4] / e,
        t[5] = -i[5] / e,
        t[6] = -i[6] / e,
        t[7] = i[7] / e,
        t
    }
    function or(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = i[3],
        t[4] = -i[4],
        t[5] = -i[5],
        t[6] = -i[6],
        t[7] = i[7],
        t
    }
    var ht = H
      , ot = ht
      , at = q
      , lt = at;
    function ar(t, i) {
        var e = at(i);
        if (e > 0) {
            e = Math.sqrt(e);
            var s = i[0] / e
              , n = i[1] / e
              , r = i[2] / e
              , h = i[3] / e
              , o = i[4]
              , a = i[5]
              , l = i[6]
              , u = i[7]
              , c = s * o + n * a + r * l + h * u;
            t[0] = s,
            t[1] = n,
            t[2] = r,
            t[3] = h,
            t[4] = (o - s * c) / e,
            t[5] = (a - n * c) / e,
            t[6] = (l - r * c) / e,
            t[7] = (u - h * c) / e
        }
        return t
    }
    function lr(t) {
        return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")"
    }
    function ur(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5] && t[6] === i[6] && t[7] === i[7]
    }
    function cr(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = e[0]
          , d = e[1]
          , f = e[2]
          , p = e[3]
          , m = e[4]
          , w = e[5]
          , g = e[6]
          , y = e[7];
        return Math.abs(s - c) <= t * Math.max(1, Math.abs(s), Math.abs(c)) && Math.abs(n - d) <= t * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(r - f) <= t * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(h - p) <= t * Math.max(1, Math.abs(h), Math.abs(p)) && Math.abs(o - m) <= t * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(a - w) <= t * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(l - g) <= t * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u - y) <= t * Math.max(1, Math.abs(u), Math.abs(y))
    }
    var ut = Object.freeze({
        __proto__: null,
        create: Dn,
        clone: Fn,
        r6t: Ln,
        S8t: Bn,
        A6t: Un,
        b6t: Nn,
        u6t: jn,
        v6t: $n,
        Qr: zn,
        identity: Vn,
        set: Wn,
        x8t: et,
        M8t: Hn,
        E8t: st,
        C8t: Kn,
        k6t: qn,
        translate: Xn,
        C6t: Yn,
        _6t: Jn,
        T6t: Zn,
        _8t: Qn,
        T8t: tr,
        I8t: ir,
        add: er,
        multiply: sr,
        mul: nt,
        scale: nr,
        dot: rt,
        mi: rr,
        o6t: hr,
        m8t: or,
        length: ht,
        l8t: ot,
        J6t: at,
        u8t: lt,
        normalize: ar,
        d6t: lr,
        w6t: ur,
        equals: cr
    });
    function dr() {
        var t = new i(2);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0),
        t
    }
    function fr(t) {
        var e = new i(2);
        return e[0] = t[0],
        e[1] = t[1],
        e
    }
    function pr(t, e) {
        var s = new i(2);
        return s[0] = t,
        s[1] = e,
        s
    }
    function mr(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t
    }
    function wr(t, i, e) {
        return t[0] = i,
        t[1] = e,
        t
    }
    function gr(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t
    }
    function yr(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t
    }
    function br(t, i, e) {
        return t[0] = i[0] * e[0],
        t[1] = i[1] * e[1],
        t
    }
    function vr(t, i, e) {
        return t[0] = i[0] / e[0],
        t[1] = i[1] / e[1],
        t
    }
    function Sr(t, i) {
        return t[0] = Math.ceil(i[0]),
        t[1] = Math.ceil(i[1]),
        t
    }
    function xr(t, i) {
        return t[0] = Math.floor(i[0]),
        t[1] = Math.floor(i[1]),
        t
    }
    function Mr(t, i, e) {
        return t[0] = Math.min(i[0], e[0]),
        t[1] = Math.min(i[1], e[1]),
        t
    }
    function Er(t, i, e) {
        return t[0] = Math.max(i[0], e[0]),
        t[1] = Math.max(i[1], e[1]),
        t
    }
    function Cr(t, i) {
        return t[0] = Math.round(i[0]),
        t[1] = Math.round(i[1]),
        t
    }
    function _r(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t
    }
    function Tr(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t
    }
    function Ir(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1];
        return Math.hypot(e, s)
    }
    function Pr(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1];
        return e * e + s * s
    }
    function Gr(t) {
        var i = t[0]
          , e = t[1];
        return Math.hypot(i, e)
    }
    function Ar(t) {
        var i = t[0]
          , e = t[1];
        return i * i + e * e
    }
    function Rr(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t
    }
    function kr(t, i) {
        return t[0] = 1 / i[0],
        t[1] = 1 / i[1],
        t
    }
    function Or(t, i) {
        var e = i[0]
          , s = i[1]
          , n = e * e + s * s;
        return n > 0 && (n = 1 / Math.sqrt(n)),
        t[0] = i[0] * n,
        t[1] = i[1] * n,
        t
    }
    function Dr(t, i) {
        return t[0] * i[0] + t[1] * i[1]
    }
    function Fr(t, i, e) {
        var s = i[0] * e[1] - i[1] * e[0];
        return t[0] = t[1] = 0,
        t[2] = s,
        t
    }
    function Lr(t, i, e, s) {
        var n = i[0]
          , r = i[1];
        return t[0] = n + s * (e[0] - n),
        t[1] = r + s * (e[1] - r),
        t
    }
    function Br(t, i) {
        i = i || 1;
        var s = 2 * e() * Math.PI;
        return t[0] = Math.cos(s) * i,
        t[1] = Math.sin(s) * i,
        t
    }
    function Ur(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[2] * n,
        t[1] = e[1] * s + e[3] * n,
        t
    }
    function Nr(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[2] * n + e[4],
        t[1] = e[1] * s + e[3] * n + e[5],
        t
    }
    function jr(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[3] * n + e[6],
        t[1] = e[1] * s + e[4] * n + e[7],
        t
    }
    function $r(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[4] * n + e[12],
        t[1] = e[1] * s + e[5] * n + e[13],
        t
    }
    function zr(t, i, e, s) {
        var n = i[0] - e[0]
          , r = i[1] - e[1]
          , h = Math.sin(s)
          , o = Math.cos(s);
        return t[0] = n * o - r * h + e[0],
        t[1] = n * h + r * o + e[1],
        t
    }
    function Vr(t, i) {
        var e = t[0]
          , s = t[1]
          , n = i[0]
          , r = i[1]
          , h = Math.sqrt((e * e + s * s) * (n * n + r * r))
          , o = h && (e * n + s * r) / h;
        return Math.acos(Math.min(Math.max(o, -1), 1))
    }
    function Wr(t) {
        return t[0] = 0,
        t[1] = 0,
        t
    }
    function Hr(t) {
        return "vec2(" + t[0] + ", " + t[1] + ")"
    }
    function Kr(t, i) {
        return t[0] === i[0] && t[1] === i[1]
    }
    function qr(i, e) {
        var s = i[0]
          , n = i[1]
          , r = e[0]
          , h = e[1];
        return Math.abs(s - r) <= t * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(n - h) <= t * Math.max(1, Math.abs(n), Math.abs(h))
    }
    var ct = Gr
      , dt = yr
      , ft = br
      , pt = vr
      , mt = Ir
      , wt = Pr
      , gt = Ar
      , yt = function() {
        var t = dr();
        return function(i, e, s, n, r, h) {
            var o, a;
            for (e || (e = 2),
            s || (s = 0),
            a = n ? Math.min(n * e + s, i.length) : i.length,
            o = s; o < a; o += e)
                t[0] = i[o],
                t[1] = i[o + 1],
                r(t, t, h),
                i[o] = t[0],
                i[o + 1] = t[1];
            return i
        }
    }()
      , bt = Object.freeze({
        __proto__: null,
        create: dr,
        clone: fr,
        r6t: pr,
        Qr: mr,
        set: wr,
        add: gr,
        m6t: yr,
        multiply: br,
        xm: vr,
        ceil: Sr,
        floor: xr,
        min: Mr,
        max: Er,
        round: Cr,
        scale: _r,
        q6t: Tr,
        X6t: Ir,
        Y6t: Pr,
        length: Gr,
        J6t: Ar,
        Z6t: Rr,
        inverse: kr,
        normalize: Or,
        dot: Dr,
        Q6t: Fr,
        mi: Lr,
        random: Br,
        P8t: Ur,
        G8t: Nr,
        n8t: jr,
        s8t: $r,
        rotate: zr,
        angle: Vr,
        h8t: Wr,
        d6t: Hr,
        w6t: Kr,
        equals: qr,
        l8t: ct,
        sub: dt,
        mul: ft,
        div: pt,
        o8t: mt,
        a8t: wt,
        u8t: gt,
        forEach: yt
    });
    globalThis.r_ = n,
    globalThis.r_.A8t = o,
    globalThis.r_.R8t = u,
    globalThis.r_.k8t = f,
    globalThis.r_.o_ = y,
    globalThis.r_.O8t = it,
    globalThis.r_.D8t = ut,
    globalThis.r_.F8t = bt,
    globalThis.r_.l_ = T,
    globalThis.r_.L8t = F
}
var vt, St, xt, Mt, Et, Ct, _t;
!function() {
    function t(t) {
        this.mode = e.Pu,
        this.data = t,
        this.Vu = [];
        for (var i = 0, s = this.data.length; i < s; i++) {
            var n = []
              , r = this.data.charCodeAt(i);
            r > 65536 ? (n[0] = 240 | (1835008 & r) >>> 18,
            n[1] = 128 | (258048 & r) >>> 12,
            n[2] = 128 | (4032 & r) >>> 6,
            n[3] = 128 | 63 & r) : r > 2048 ? (n[0] = 224 | (61440 & r) >>> 12,
            n[1] = 128 | (4032 & r) >>> 6,
            n[2] = 128 | 63 & r) : r > 128 ? (n[0] = 192 | (1984 & r) >>> 6,
            n[1] = 128 | 63 & r) : n[0] = r,
            this.Vu.push(n)
        }
        this.Vu = Array.prototype.concat.apply([], this.Vu),
        this.Vu.length != this.data.length && (this.Vu.unshift(191),
        this.Vu.unshift(187),
        this.Vu.unshift(239))
    }
    function i(t, i) {
        this.ku = t,
        this.Ru = i,
        this.Gu = null,
        this._u = 0,
        this.ju = null,
        this.Lu = []
    }
    t.prototype = {
        Du: function(t) {
            return this.Vu.length
        },
        write: function(t) {
            for (var i = 0, e = this.Vu.length; i < e; i++)
                t.put(this.Vu[i], 8)
        }
    },
    i.prototype = {
        Au: function(i) {
            var e = new t(i);
            this.Lu.push(e),
            this.ju = null
        },
        Fu: function(t, i) {
            if (t < 0 || this._u <= t || i < 0 || this._u <= i)
                throw new Error(t + "," + i);
            return this.Gu[t][i]
        },
        Eu: function() {
            return this._u
        },
        zu: function() {
            this.Uu(!1, this.Bu())
        },
        Uu: function(t, e) {
            this._u = 4 * this.ku + 17,
            this.Gu = new Array(this._u);
            for (var s = 0; s < this._u; s++) {
                this.Gu[s] = new Array(this._u);
                for (var n = 0; n < this._u; n++)
                    this.Gu[s][n] = null
            }
            this.Hu(0, 0),
            this.Hu(this._u - 7, 0),
            this.Hu(0, this._u - 7),
            this.Wu(),
            this.Nu(),
            this.$u(t, e),
            this.ku >= 7 && this.Xu(t),
            null == this.ju && (this.ju = i.Yu(this.ku, this.Ru, this.Lu)),
            this.Ju(this.ju, e)
        },
        Hu: function(t, i) {
            for (var e = -1; e <= 7; e++)
                if (!(t + e <= -1 || this._u <= t + e))
                    for (var s = -1; s <= 7; s++)
                        i + s <= -1 || this._u <= i + s || (this.Gu[t + e][i + s] = 0 <= e && e <= 6 && (0 == s || 6 == s) || 0 <= s && s <= 6 && (0 == e || 6 == e) || 2 <= e && e <= 4 && 2 <= s && s <= 4)
        },
        Bu: function() {
            for (var t = 0, i = 0, e = 0; e < 8; e++) {
                this.Uu(!0, e);
                var s = d.qu(this);
                (0 == e || t > s) && (t = s,
                i = e)
            }
            return i
        },
        Ku: function(t, i, e) {
            var s = t.Qu(i, e);
            this.zu();
            for (var n = 0; n < this.Gu.length; n++)
                for (var r = 1 * n, h = 0; h < this.Gu[n].length; h++) {
                    var o = 1 * h;
                    this.Gu[n][h] && (s.Zu(0, 100),
                    s.moveTo(o, r),
                    s.lineTo(o + 1, r),
                    s.lineTo(o + 1, r + 1),
                    s.lineTo(o, r + 1),
                    s.tp())
                }
            return s
        },
        Nu: function() {
            for (var t = 8; t < this._u - 8; t++)
                null == this.Gu[t][6] && (this.Gu[t][6] = t % 2 == 0);
            for (var i = 8; i < this._u - 8; i++)
                null == this.Gu[6][i] && (this.Gu[6][i] = i % 2 == 0)
        },
        Wu: function() {
            for (var t = d.ep(this.ku), i = 0; i < t.length; i++)
                for (var e = 0; e < t.length; e++) {
                    var s = t[i]
                      , n = t[e];
                    if (null == this.Gu[s][n])
                        for (var r = -2; r <= 2; r++)
                            for (var h = -2; h <= 2; h++)
                                this.Gu[s + r][n + h] = -2 == r || 2 == r || -2 == h || 2 == h || 0 == r && 0 == h
                }
        },
        Xu: function(t) {
            for (var i = d.ip(this.ku), e = 0; e < 18; e++) {
                var s = !t && 1 == (i >> e & 1);
                this.Gu[Math.floor(e / 3)][e % 3 + this._u - 8 - 3] = s
            }
            for (e = 0; e < 18; e++) {
                s = !t && 1 == (i >> e & 1);
                this.Gu[e % 3 + this._u - 8 - 3][Math.floor(e / 3)] = s
            }
        },
        $u: function(t, i) {
            for (var e = this.Ru << 3 | i, s = d.sp(e), n = 0; n < 15; n++) {
                var r = !t && 1 == (s >> n & 1);
                n < 6 ? this.Gu[n][8] = r : n < 8 ? this.Gu[n + 1][8] = r : this.Gu[this._u - 15 + n][8] = r
            }
            for (n = 0; n < 15; n++) {
                r = !t && 1 == (s >> n & 1);
                n < 8 ? this.Gu[8][this._u - n - 1] = r : n < 9 ? this.Gu[8][15 - n - 1 + 1] = r : this.Gu[8][15 - n - 1] = r
            }
            this.Gu[this._u - 8][8] = !t
        },
        Ju: function(t, i) {
            for (var e = -1, s = this._u - 1, n = 7, r = 0, h = this._u - 1; h > 0; h -= 2)
                for (6 == h && h--; ; ) {
                    for (var o = 0; o < 2; o++)
                        if (null == this.Gu[s][h - o]) {
                            var a = !1;
                            r < t.length && (a = 1 == (t[r] >>> n & 1)),
                            d.np(i, s, h - o) && (a = !a),
                            this.Gu[s][h - o] = a,
                            -1 == --n && (r++,
                            n = 7)
                        }
                    if ((s += e) < 0 || this._u <= s) {
                        s -= e,
                        e = -e;
                        break
                    }
                }
        }
    },
    i.rp = 236,
    i.ap = 17,
    i.Yu = function(t, e, s) {
        for (var n = w.lp(t, e), r = new g, h = 0; h < s.length; h++) {
            var o = s[h];
            r.put(o.mode, 4),
            r.put(o.Du(), d.hp(o.mode, t)),
            o.write(r)
        }
        var a = 0;
        for (h = 0; h < n.length; h++)
            a += n[h].op;
        if (r.hp() > 8 * a)
            throw new Error("code length overflow. (" + r.hp() + ">" + 8 * a + ")");
        for (r.hp() + 4 <= 8 * a && r.put(0, 4); r.hp() % 8 != 0; )
            r.cp(!1);
        for (; !(r.hp() >= 8 * a || (r.put(i.rp, 8),
        r.hp() >= 8 * a)); )
            r.put(i.ap, 8);
        return i.up(r, n)
    }
    ,
    i.up = function(t, i) {
        for (var e = 0, s = 0, n = 0, r = new Array(i.length), h = new Array(i.length), o = 0; o < i.length; o++) {
            var a = i[o].op
              , l = i[o].pp - a;
            s = Math.max(s, a),
            n = Math.max(n, l),
            r[o] = new Array(a);
            for (var u = 0; u < r[o].length; u++)
                r[o][u] = 255 & t.buffer[u + e];
            e += a;
            var c = d.dp(l)
              , f = new m(r[o],c.Du() - 1).fp(c);
            h[o] = new Array(c.Du() - 1);
            for (u = 0; u < h[o].length; u++) {
                var p = u + f.Du() - h[o].length;
                h[o][u] = p >= 0 ? f.get(p) : 0
            }
        }
        var w = 0;
        for (u = 0; u < i.length; u++)
            w += i[u].pp;
        var g = new Array(w)
          , y = 0;
        for (u = 0; u < s; u++)
            for (o = 0; o < i.length; o++)
                u < r[o].length && (g[y++] = r[o][u]);
        for (u = 0; u < n; u++)
            for (o = 0; o < i.length; o++)
                u < h[o].length && (g[y++] = h[o][u]);
        return g
    }
    ;
    for (var e = {
        mp: 1,
        gp: 2,
        Pu: 4,
        wp: 8
    }, s = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
    }, n = 0, r = 1, h = 2, o = 3, a = 4, l = 5, u = 6, c = 7, d = {
        bp: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
        yp: 1335,
        xp: 7973,
        Sp: 21522,
        sp: function(t) {
            for (var i = t << 10; d.Cp(i) - d.Cp(d.yp) >= 0; )
                i ^= d.yp << d.Cp(i) - d.Cp(d.yp);
            return (t << 10 | i) ^ d.Sp
        },
        ip: function(t) {
            for (var i = t << 12; d.Cp(i) - d.Cp(d.xp) >= 0; )
                i ^= d.xp << d.Cp(i) - d.Cp(d.xp);
            return t << 12 | i
        },
        Cp: function(t) {
            for (var i = 0; 0 != t; )
                i++,
                t >>>= 1;
            return i
        },
        ep: function(t) {
            return d.bp[t - 1]
        },
        np: function(t, i, e) {
            switch (t) {
            case n:
                return (i + e) % 2 == 0;
            case r:
                return i % 2 == 0;
            case h:
                return e % 3 == 0;
            case o:
                return (i + e) % 3 == 0;
            case a:
                return (Math.floor(i / 2) + Math.floor(e / 3)) % 2 == 0;
            case l:
                return i * e % 2 + i * e % 3 == 0;
            case u:
                return (i * e % 2 + i * e % 3) % 2 == 0;
            case c:
                return (i * e % 3 + (i + e) % 2) % 2 == 0;
            default:
                throw new Error("bad maskPattern:" + t)
            }
        },
        dp: function(t) {
            for (var i = new m([1],0), e = 0; e < t; e++)
                i = i.multiply(new m([1, f.vp(e)],0));
            return i
        },
        hp: function(t, i) {
            if (1 <= i && i < 10)
                switch (t) {
                case e.mp:
                    return 10;
                case e.gp:
                    return 9;
                case e.Pu:
                case e.wp:
                    return 8;
                default:
                    throw new Error("mode:" + t)
                }
            else if (i < 27)
                switch (t) {
                case e.mp:
                    return 12;
                case e.gp:
                    return 11;
                case e.Pu:
                    return 16;
                case e.wp:
                    return 10;
                default:
                    throw new Error("mode:" + t)
                }
            else {
                if (!(i < 41))
                    throw new Error("type:" + i);
                switch (t) {
                case e.mp:
                    return 14;
                case e.gp:
                    return 13;
                case e.Pu:
                    return 16;
                case e.wp:
                    return 12;
                default:
                    throw new Error("mode:" + t)
                }
            }
        },
        qu: function(t) {
            for (var i = t.Eu(), e = 0, s = 0; s < i; s++)
                for (var n = 0; n < i; n++) {
                    for (var r = 0, h = t.Fu(s, n), o = -1; o <= 1; o++)
                        if (!(s + o < 0 || i <= s + o))
                            for (var a = -1; a <= 1; a++)
                                n + a < 0 || i <= n + a || 0 == o && 0 == a || h == t.Fu(s + o, n + a) && r++;
                    r > 5 && (e += 3 + r - 5)
                }
            for (s = 0; s < i - 1; s++)
                for (n = 0; n < i - 1; n++) {
                    var l = 0;
                    t.Fu(s, n) && l++,
                    t.Fu(s + 1, n) && l++,
                    t.Fu(s, n + 1) && l++,
                    t.Fu(s + 1, n + 1) && l++,
                    0 != l && 4 != l || (e += 3)
                }
            for (s = 0; s < i; s++)
                for (n = 0; n < i - 6; n++)
                    t.Fu(s, n) && !t.Fu(s, n + 1) && t.Fu(s, n + 2) && t.Fu(s, n + 3) && t.Fu(s, n + 4) && !t.Fu(s, n + 5) && t.Fu(s, n + 6) && (e += 40);
            for (n = 0; n < i; n++)
                for (s = 0; s < i - 6; s++)
                    t.Fu(s, n) && !t.Fu(s + 1, n) && t.Fu(s + 2, n) && t.Fu(s + 3, n) && t.Fu(s + 4, n) && !t.Fu(s + 5, n) && t.Fu(s + 6, n) && (e += 40);
            var u = 0;
            for (n = 0; n < i; n++)
                for (s = 0; s < i; s++)
                    t.Fu(s, n) && u++;
            return e += 10 * (Math.abs(100 * u / i / i - 50) / 5)
        }
    }, f = {
        Ip: function(t) {
            if (t < 1)
                throw new Error("glog(" + t + ")");
            return f.Mp[t]
        },
        vp: function(t) {
            for (; t < 0; )
                t += 255;
            for (; t >= 256; )
                t -= 255;
            return f.Op[t]
        },
        Op: new Array(256),
        Mp: new Array(256)
    }, p = 0; p < 8; p++)
        f.Op[p] = 1 << p;
    for (p = 8; p < 256; p++)
        f.Op[p] = f.Op[p - 4] ^ f.Op[p - 5] ^ f.Op[p - 6] ^ f.Op[p - 8];
    for (p = 0; p < 255; p++)
        f.Mp[f.Op[p]] = p;
    function m(t, i) {
        if (null == t.length)
            throw new Error(t.length + "/" + i);
        for (var e = 0; e < t.length && 0 == t[e]; )
            e++;
        this.Tp = new Array(t.length - e + i);
        for (var s = 0; s < t.length - e; s++)
            this.Tp[s] = t[s + e]
    }
    function w(t, i) {
        this.pp = t,
        this.op = i
    }
    function g() {
        this.buffer = [],
        this.length = 0
    }
    m.prototype = {
        get: function(t) {
            return this.Tp[t]
        },
        Du: function() {
            return this.Tp.length
        },
        multiply: function(t) {
            for (var i = new Array(this.Du() + t.Du() - 1), e = 0; e < this.Du(); e++)
                for (var s = 0; s < t.Du(); s++)
                    i[e + s] ^= f.vp(f.Ip(this.get(e)) + f.Ip(t.get(s)));
            return new m(i,0)
        },
        fp: function(t) {
            if (this.Du() - t.Du() < 0)
                return this;
            for (var i = f.Ip(this.get(0)) - f.Ip(t.get(0)), e = new Array(this.Du()), s = 0; s < this.Du(); s++)
                e[s] = this.get(s);
            for (s = 0; s < t.Du(); s++)
                e[s] ^= f.vp(f.Ip(t.get(s)) + i);
            return new m(e,0).fp(t)
        }
    },
    w.Pp = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]],
    w.lp = function(t, i) {
        var e = w.Vp(t, i);
        if (null == e)
            throw new Error("bad rs block @ typeNumber:" + t + "/errorCorrectLevel:" + i);
        for (var s = e.length / 3, n = [], r = 0; r < s; r++)
            for (var h = e[3 * r + 0], o = e[3 * r + 1], a = e[3 * r + 2], l = 0; l < h; l++)
                n.push(new w(o,a));
        return n
    }
    ,
    w.Vp = function(t, i) {
        switch (i) {
        case s.L:
            return w.Pp[4 * (t - 1) + 0];
        case s.M:
            return w.Pp[4 * (t - 1) + 1];
        case s.Q:
            return w.Pp[4 * (t - 1) + 2];
        case s.H:
            return w.Pp[4 * (t - 1) + 3];
        default:
            return
        }
    }
    ,
    g.prototype = {
        get: function(t) {
            var i = Math.floor(t / 8);
            return 1 == (this.buffer[i] >>> 7 - t % 8 & 1)
        },
        put: function(t, i) {
            for (var e = 0; e < i; e++)
                this.cp(1 == (t >>> i - e - 1 & 1))
        },
        hp: function() {
            return this.length
        },
        cp: function(t) {
            var i = Math.floor(this.length / 8);
            this.buffer.length <= i && this.buffer.push(0),
            t && (this.buffer[i] |= 128 >>> this.length % 8),
            this.length++
        }
    };
    var y = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    var b = function() {
        var t = function(t, i) {
            this._p = t,
            this.Rp = i
        };
        return t.prototype.draw = function(t) {
            var i = this.Rp
              , e = this._p
              , s = t.Eu();
            Math.floor(i.width / s),
            Math.floor(i.height / s);
            function n(t, i) {
                var e = document.createElementNS("http://www.w3.org/2000/svg", t);
                for (var s in i)
                    i.hasOwnProperty(s) && e.setAttribute(s, i[s]);
                return e
            }
            this.clear();
            var r = n("svg", {
                viewBox: "0 0 " + String(s) + " " + String(s),
                width: "100%",
                height: "100%",
                fill: i.Ap
            });
            r.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"),
            e.appendChild(r),
            r.appendChild(n("rect", {
                fill: i.Ap,
                width: "100%",
                height: "100%"
            })),
            r.appendChild(n("rect", {
                fill: i.Dp,
                width: "1",
                height: "1",
                id: "template"
            }));
            for (var h = 0; h < s; h++)
                for (var o = 0; o < s; o++)
                    if (t.Fu(h, o)) {
                        var a = n("use", {
                            x: String(o),
                            y: String(h)
                        });
                        a.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#template"),
                        r.appendChild(a)
                    }
        }
        ,
        t.prototype.clear = function() {
            for (; this._p.hasChildNodes(); )
                this._p.removeChild(this._p.lastChild)
        }
        ,
        t
    }()
      , v = "svg" === document.documentElement.tagName.toLowerCase() ? b : "undefined" == typeof CanvasRenderingContext2D ? function() {
        var t = function(t, i) {
            this._p = t,
            this.Rp = i
        };
        return t.prototype.draw = function(t) {
            for (var i = this.Rp, e = this._p, s = t.Eu(), n = Math.floor(i.width / s), r = Math.floor(i.height / s), h = ['<table style="border:0;border-collapse:collapse;">'], o = 0; o < s; o++) {
                h.push("<tr>");
                for (var a = 0; a < s; a++)
                    h.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + n + "px;height:" + r + "px;background-color:" + (t.Fu(o, a) ? i.Dp : i.Ap) + ';"></td>');
                h.push("</tr>")
            }
            h.push("</table>"),
            e.innerHTML = h.join("");
            var l = e.childNodes[0]
              , u = (i.width - l.offsetWidth) / 2
              , c = (i.height - l.offsetHeight) / 2;
            u > 0 && c > 0 && (l.style.margin = c + "px " + u + "px")
        }
        ,
        t.prototype.clear = function() {
            this._p.innerHTML = ""
        }
        ,
        t
    }() : function() {
        function t() {
            this.B8t.src = this.Gp.toDataURL("image/png"),
            this.B8t.style.display = "block",
            this.Gp.style.display = "none"
        }
        function i(t, i) {
            var e = this;
            if (e.U8t = i,
            e.N8t = t,
            null === e.Lp) {
                var s = document.createElement("img")
                  , n = function() {
                    e.Lp = !1,
                    e.U8t && e.U8t.call(e)
                };
                return s.onabort = n,
                s.onerror = n,
                s.onload = function() {
                    e.Lp = !0,
                    e.N8t && e.N8t.call(e)
                }
                ,
                void (s.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==")
            }
            !0 === e.Lp && e.N8t ? e.N8t.call(e) : !1 === e.Lp && e.U8t && e.U8t.call(e)
        }
        var e = function(t, i) {
            this.kp = !1,
            this.Rp = i,
            this.Gp = document.createElement("canvas"),
            this.Gp.width = i.width,
            this.Gp.height = i.height,
            t.appendChild(this.Gp),
            this._p = t,
            this.jp = this.Gp.getContext("2d"),
            this.kp = !1,
            this.B8t = document.createElement("img"),
            this.B8t.alt = "Scan me!",
            this.B8t.style.display = "none",
            this.Lp = null
        };
        return e.prototype.draw = function(t) {
            var i = this.B8t
              , e = this.jp
              , s = this.Rp
              , n = t.Eu()
              , r = s.width / n
              , h = s.height / n
              , o = Math.round(r)
              , a = Math.round(h);
            i.style.display = "none",
            this.clear();
            for (var l = 0; l < n; l++)
                for (var u = 0; u < n; u++) {
                    var c = t.Fu(l, u)
                      , d = u * r
                      , f = l * h;
                    e.strokeStyle = c ? s.Dp : s.Ap,
                    e.lineWidth = 1,
                    e.fillStyle = c ? s.Dp : s.Ap,
                    e.fillRect(d, f, r, h),
                    e.strokeRect(Math.floor(d) + .5, Math.floor(f) + .5, o, a),
                    e.strokeRect(Math.ceil(d) - .5, Math.ceil(f) - .5, o, a)
                }
            this.kp = !0
        }
        ,
        e.prototype.j8t = function() {
            this.kp && i.call(this, t)
        }
        ,
        e.prototype.Fp = function() {
            return this.kp
        }
        ,
        e.prototype.clear = function() {
            this.jp.clearRect(0, 0, this.Gp.width, this.Gp.height),
            this.kp = !1
        }
        ,
        e.prototype.round = function(t) {
            return t ? Math.floor(1e3 * t) / 1e3 : t
        }
        ,
        e
    }();
    function S(t, i) {
        for (var e = 1, n = function(t) {
            var i = encodeURI(t).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
            return i.length + (i.length != t ? 3 : 0)
        }(t), r = 0, h = y.length; r <= h; r++) {
            var o = 0;
            switch (i) {
            case s.L:
                o = y[r][0];
                break;
            case s.M:
                o = y[r][1];
                break;
            case s.Q:
                o = y[r][2];
                break;
            case s.H:
                o = y[r][3]
            }
            if (n <= o)
                break;
            e++
        }
        if (e > y.length)
            throw new Error("Too long data");
        return e
    }
    self.gu = function(t, i) {
        if (this.Rp = {
            width: 256,
            height: 256,
            ku: 4,
            Dp: "#000000",
            Ap: "#ffffff",
            Iu: s.H
        },
        "string" == typeof i && (i = {
            text: i
        }),
        i)
            for (var e in i)
                this.Rp[e] = i[e];
        "string" == typeof t && (t = document.getElementById(t)),
        this.Rp.$8t && (v = b),
        this._p = t,
        this.Ep = null,
        this.zp = new v(this._p,this.Rp),
        this.Rp.text && this.Up(this.Rp.text)
    }
    ,
    self.gu.prototype.Up = function(t) {
        this.Ep = new i(S(t, this.Rp.Iu),this.Rp.Iu),
        this.Ep.Au(t),
        this.Ep.zu(),
        this.zp.draw(this.Ep)
    }
    ,
    self.gu.prototype.j8t = function() {
        "function" == typeof this.zp.j8t && this.zp.j8t()
    }
    ,
    self.gu.prototype.clear = function() {
        this.zp.clear()
    }
    ,
    self.gu.Tu = s
}();
{
    let Xr = !1
      , Yr = !1
      , Jr = "dev";
    const Zr = []
      , Qr = self.t = class {
        constructor() {
            throw TypeError("static class can't be instantiated")
        }
        static z8t() {
            Xr = !0
        }
        static ev() {
            return Xr
        }
        static V8t() {
            Yr = !0
        }
        static W8t() {
            return Yr
        }
        static H8t(t) {
            Jr = t
        }
        static K8t() {
            return Jr
        }
        static q8t() {
            return "final" === Jr
        }
        static X8t(t) {
            Zr.push(t)
        }
        static Y8t() {
            return Zr
        }
    }
    ;
    Qr.$M = !1,
    Qr.J8t = !1,
    Qr.$5t = !1,
    Qr.hardwareConcurrency = navigator.hardwareConcurrency || 2,
    self.Z8t = {}
}
{
    const th = self.t;
    th.Q8t = class {
        constructor(t) {
            this.f9t = t,
            this.p9t = new Map,
            this.m9t()
        }
        m9t() {
            let t = this.f9t;
            (t.startsWith("?") || t.startsWith("#")) && (t = t.substr(1));
            const i = t.split("&");
            for (const t of i)
                this.w9t(t)
        }
        w9t(t) {
            if (!t)
                return;
            if (!t.includes("="))
                return void this.p9t.set(t, null);
            const i = t.indexOf("=")
              , e = decodeURIComponent(t.substring(0, i))
              , s = decodeURIComponent(t.substring(i + 1));
            this.p9t.set(e, s)
        }
        g9t() {
            for (const t of this.p9t)
                console.log("[QueryParser] Parameter '" + t[0] + "' = " + (null === t[1] ? "null" : "'" + t[1] + "'"))
        }
        y9t(t) {
            return this.p9t.has(t)
        }
        qs(t) {
            const i = this.p9t.get(t);
            return void 0 === i ? null : i
        }
        b9t() {
            history.replaceState("", document.title, location.pathname + location.search)
        }
        v9t(t) {
            this.f9t = t,
            this.p9t.clear(),
            this.m9t()
        }
    }
    ,
    th.S9t = new th.Q8t(location.search),
    th.x9t = new th.Q8t(location.hash),
    th.S9t.y9t("perf") && (th.$5t = !0),
    "dev" !== th.S9t.qs("mode") && th.H8t("final")
}
{
    const ih = self.t
      , eh = "(unknown)";
    ih.kt = {
        OS: eh,
        M9t: eh,
        _r: eh,
        E9t: eh,
        C9t: NaN,
        _9t: eh,
        Mme: "browser",
        FG: !0,
        Y_: !1,
        hyt: !1,
        T9t: !1,
        I9t: async () => {}
    };
    const sh = new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
    function nh(t) {
        const i = parseFloat(t)
          , e = sh.get(i);
        return e || (i >= 13 ? "11" : "NT " + t)
    }
    const rh = navigator.userAgent
      , hh = navigator.userAgentData;
    if (hh && hh.brands.length > 0) {
        ih.kt.OS = hh.platform,
        ih.kt.Y_ = hh.mobile,
        ih.kt.FG = !ih.kt.Y_;
        const oh = new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]])
          , ah = new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
        function lh(t) {
            let i = ""
              , e = ""
              , s = ""
              , n = "";
            for (const r of t) {
                const t = oh.get(r.brand);
                !i && t && (i = t,
                e = r.version);
                const h = ah.get(r.brand);
                !s && h && (s = h,
                n = r.version)
            }
            i || "Chromium" !== s || (ih.kt._r = "Chromium",
            ih.kt.E9t = n),
            ih.kt._r = i || eh,
            ih.kt.E9t = e || eh,
            ih.kt._9t = s || eh
        }
        lh(hh.brands);
        let uh = !1;
        ih.kt.I9t = async () => {
            if (!uh)
                try {
                    const t = await navigator.userAgentData.getHighEntropyValues(["platformVersion", "fullVersionList"]);
                    lh(t.fullVersionList),
                    "Windows" === ih.kt.OS ? ih.kt.M9t = nh(t.platformVersion) : ih.kt.M9t = t.platformVersion,
                    uh = !0
                } catch (t) {
                    (() => {})("Failed to get detailed user agent information: ", t)
                }
        }
    } else {
        function ch(t, i) {
            const e = Array.isArray(t) ? t : [t];
            for (const t of e) {
                const e = t.exec(rh);
                if (e) {
                    i(e);
                    break
                }
            }
        }
        ch(/windows\s+nt\s+([\d\.]+)/i, t => {
            ih.kt.OS = "Windows";
            const i = t[1];
            ih.kt.M9t = nh(i)
        }
        ),
        ch(/mac\s+os\s+x\s+([\d\._]+)/i, t => {
            ih.kt.OS = "macOS",
            ih.kt.M9t = t[1].replace(/_/g, ".")
        }
        ),
        ch(/CrOS/, () => {
            ih.kt.OS = "Chrome OS"
        }
        ),
        ch(/linux|openbsd|freebsd|netbsd/i, () => {
            ih.kt.OS = "Linux"
        }
        ),
        ch(/android/i, () => {
            ih.kt.OS = "Android"
        }
        ),
        ch(/android\s+([\d\.]+)/i, t => {
            ih.kt.OS = "Android",
            ih.kt.M9t = t[1]
        }
        ),
        ih.kt.OS === eh && (ch(/(iphone|ipod|ipad)/i, t => {
            ih.kt.OS = "iOS"
        }
        ),
        ch([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], t => {
            ih.kt.OS = "iOS",
            ih.kt.M9t = t[1].replace(/_/g, ".")
        }
        ));
        const dh = /chrome\//i.test(rh)
          , fh = /chromium\//i.test(rh)
          , ph = /edg\//i.test(rh)
          , mh = /OPR\//.test(rh)
          , wh = /nwjs/i.test(rh)
          , gh = /safari\//i.test(rh)
          , yh = /webkit/i.test(rh);
        ph || mh || ch(/chrome\/([\d\.]+)/i, t => {
            ih.kt._r = "Chrome",
            ih.kt.E9t = t[1],
            ih.kt._9t = "Chromium"
        }
        ),
        ch(/edg\/([\d\.]+)/i, t => {
            ih.kt._r = "Edge",
            ih.kt.E9t = t[1],
            ih.kt._9t = "Chromium"
        }
        ),
        ch(/OPR\/([\d\.]+)/, t => {
            ih.kt._r = "Opera",
            ih.kt.E9t = t[1],
            ih.kt._9t = "Chromium"
        }
        ),
        ch(/chromium\/([\d\.]+)/i, t => {
            ih.kt._r = "Chromium",
            ih.kt.E9t = t[1],
            ih.kt._9t = "Chromium"
        }
        ),
        ch(/nwjs\/[0-9.]+/i, t => {
            ih.kt._r = "NW.js",
            ih.kt.E9t = t[1],
            ih.kt._9t = "Chromium",
            ih.kt.Mme = "nwjs"
        }
        ),
        ch(/firefox\/([\d\.]+)/i, t => {
            ih.kt._r = "Firefox",
            ih.kt.E9t = t[1],
            ih.kt._9t = "Gecko"
        }
        ),
        !gh || dh || fh || ph || mh || wh || (ih.kt._r = "Safari",
        ih.kt._9t = "WebKit",
        ch(/version\/([\d\.]+)/i, t => {
            ih.kt.E9t = t[1]
        }
        ),
        ch(/crios\/([\d\.]+)/i, t => {
            ih.kt._r = "Chrome for iOS",
            ih.kt.E9t = t[1]
        }
        ),
        ch(/fxios\/([\d\.]+)/i, t => {
            ih.kt._r = "Firefox for iOS",
            ih.kt.E9t = t[1]
        }
        ),
        ch(/edgios\/([\d\.]+)/i, t => {
            ih.kt._r = "Edge for iOS",
            ih.kt.E9t = t[1]
        }
        )),
        ih.kt._9t === eh && yh && (ih.kt._9t = "WebKit"),
        "Android" === ih.kt.OS && "Safari" === ih.kt._r && (ih.kt._r = "Stock");
        const bh = new Set(["Windows", "macOS", "Linux", "Chrome OS"]).has(ih.kt.OS) || "nwjs" === ih.kt.Mme;
        ih.kt.FG = bh,
        ih.kt.Y_ = !bh
    }
    "Chrome" === ih.kt._r && "browser" === ih.kt.Mme && /wv\)/.test(rh) && (ih.kt.Mme = "webview"),
    "nwjs" !== ih.kt.Mme && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (ih.kt.Mme = "webapp"),
    ih.kt.C9t = parseFloat(ih.kt.E9t);
    "macOS" === ih.kt.OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && (ih.kt.OS = "iOS",
    ih.kt.M9t = ih.kt.E9t,
    ih.kt.FG = !1,
    ih.kt.Y_ = !0,
    ih.kt.T9t = !0),
    ih.kt.hyt = "macOS" === ih.kt.OS || "iOS" === ih.kt.OS
}
{
    const vh = self.t;
    vh.$M = !vh.q8t() && vh.S9t.y9t("debug"),
    vh.J8t = !vh.q8t() && vh.S9t.y9t("debug-defend"),
    vh.J8t && (vh.$M = !0);
    let Sh = !1;
    function xh(t) {
        let i = vh.P9t()
          , e = "Assertion failure: " + t + "\n\nStack trace:\n" + i;
        if (console.error(e),
        !Sh) {
            Sh = !0,
            vh.Qs.Ks.qs("CrashReport").Xa("assertion failure", {
                stack: i,
                message: t
            }, document.body)
        }
    }
    window.assert = function(t, i) {
        t || xh(i)
    }
}
{
    const Mh = self.t;
    if (!String.prototype.trimStart) {
        const Eh = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
            return this.replace(Eh, "")
        }
    }
    if (!String.prototype.trimEnd) {
        const Ch = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
            return this.replace(Ch, "")
        }
    }
    if (String.prototype.replaceAll || (String.prototype.replaceAll = function(t, i) {
        return this.replace(new RegExp(Mh.G9t(t),"g"), i)
    }
    ),
    Array.prototype.values || (Array.prototype.values = function*() {
        for (const t of this)
            yield t
    }
    ),
    !Array.prototype.flat) {
        function _h(t, i) {
            return t.reduce( (t, e) => i > 0 && Array.isArray(e) ? (Array.prototype.push.apply(t, _h(e, i - 1)),
            t) : (t.push(e),
            t), [])
        }
        Array.prototype.flat = function(t=1) {
            return _h(this, t)
        }
    }
    Array.prototype.at || (Array.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length),
        !(t < 0 || t >= this.length))
            return this[t]
    }
    ),
    String.prototype.at || (String.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length),
        !(t < 0 || t >= this.length))
            return this[t]
    }
    ),
    RegExp.escape || (RegExp.escape = function(t) {
        return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
    }
    ),
    Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {
        if (!(t instanceof Set))
            throw new TypeError("argument must be a Set");
        for (const i of this)
            if (!t.has(i))
                return !1;
        return !0
    }
    ),
    navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
        return new Promise( (t, i) => navigator.webkitTemporaryStorage.queryUsageAndQuota( (i, e) => t({
            usage: i,
            quota: e
        }), i))
    }
    ),
    void 0 === self.isSecureContext && (self.isSecureContext = "https:" === location.protocol),
    void 0 === self.globalThis && (self.globalThis = self)
}
{
    const Th = self.t;
    if (Th.QL = {},
    Th.QL.A9t = ( () => {
        try {
            if ("undefined" == typeof document)
                return !1;
            const t = document.createElement("div");
            if (void 0 === t.animate)
                return !1;
            return void 0 !== t.animate([{
                opacity: "0"
            }, {
                opacity: "1"
            }], 1e3).reverse
        } catch (t) {
            return !1
        }
    }
    )(),
    Th.QL.R9t = "undefined" != typeof HTMLDialogElement,
    Th.QL.k9t = !!self.requestIdleCallback,
    Th.QL.ImageBitmap = !!self.createImageBitmap,
    Th.QL.O9t = !1,
    Th.QL.D9t = !1,
    Th.QL.ImageBitmap) {
        try {
            self.createImageBitmap(new ImageData(32,32), {
                premultiplyAlpha: "none"
            }).then( () => {
                Th.QL.O9t = !0
            }
            ).catch( () => {
                Th.QL.O9t = !1
            }
            )
        } catch (Ih) {
            Th.QL.O9t = !1
        }
        try {
            self.createImageBitmap(new ImageData(32,32), {
                resizeWidth: 10,
                resizeHeight: 10
            }).then(t => {
                Th.QL.D9t = 10 === t.width && 10 === t.height
            }
            ).catch( () => {
                Th.QL.D9t = !1
            }
            )
        } catch (Ph) {
            Th.QL.D9t = !1
        }
    }
    if (Th.QL.F9t = !(!navigator.clipboard || !navigator.clipboard.readText),
    Th.QL.L9t = !(!navigator.permissions || !navigator.permissions.query),
    Th.QL.B9t = !1,
    Th.QL.L9t) {
        const Gh = {
            name: "clipboard-read"
        };
        navigator.permissions.query(Gh).then( () => {
            Th.QL.B9t = !0
        }
        ).catch( () => {
            Th.QL.B9t = !1
        }
        )
    }
    Th.QL.U9t = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem),
    Th.QL.N9t = "undefined" != typeof Proxy,
    Th.QL.j9t = ( () => {
        if ("undefined" == typeof document)
            return !1;
        return void 0 !== document.createElement("a").download
    }
    )(),
    Th.QL.$9t = "function" == typeof fetch,
    Th.QL.z9t = !!(self.isSecureContext && "Opera" !== Th.kt._r && navigator.storage && navigator.storage.persist),
    Th.QL.V9t = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate),
    Th.QL._me = ( () => {
        if ("undefined" == typeof document)
            return !1;
        if ("iOS" === Th.kt.OS)
            return !1;
        const t = document.documentElement;
        return !!(t.requestFullscreen || t.msRequestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullscreen)
    }
    )(),
    Th.QL.ImageDecoder = void 0 !== self.ImageDecoder,
    Th.QL.W9t = !!self.VideoEncoder,
    Th.QL.G2 = !!self.showOpenFilePicker,
    Th.QL.H9t = !!self.queryLocalFonts,
    Th.QL.UserActivation = !!navigator.userActivation,
    Th.QL.K9t = !1,
    (async () => {
        let t;
        "undefined" == typeof document ? t = new OffscreenCanvas(32,32) : (t = document.createElement("canvas"),
        t.width = 32,
        t.height = 32);
        const i = t.getContext("2d");
        i.fillStyle = "blue",
        i.fillRect(0, 0, 32, 32);
        let e = null;
        try {
            t.convertToBlob ? e = await t.convertToBlob({
                type: "image/webp",
                quality: 1
            }) : t.toBlob && (e = await new Promise(i => t.toBlob(i, "image/webp", 1))),
            Th.QL.K9t = e && "image/webp" === e.type
        } catch (t) {
            Th.QL.K9t = !1
        }
    }
    )()
}
{
    const Ah = self.t
      , Rh = self.Z8t;
    Ah.q9t = function(t) {
        return "number" == typeof t
    }
    ,
    Ah.ub = function(t) {
        return Ah.q9t(t) && isFinite(t)
    }
    ,
    Ah.Ck = function(t) {
        if (!Ah.q9t(t))
            throw new TypeError("expected number")
    }
    ,
    Ah.Lj = function(t) {
        Ah.aM(t) || Ah.Ck(t)
    }
    ,
    Ah.X9t = function(t, i, e) {
        if (!Ah.q9t(t) || isNaN(t) || i > t || e < t)
            throw new RangeError("number outside of range")
    }
    ,
    Ah.Y9t = function(...t) {
        for (let i of t)
            Ah.Ck(i)
    }
    ,
    Ah.Ge = function(t) {
        if (!Ah.ub(t))
            throw new TypeError("expected finite number")
    }
    ,
    Ah.iM = function(t) {
        Ah.aM(t) || Ah.Ge(t)
    }
    ,
    Ah.J9t = function(...t) {
        for (let i of t)
            Ah.Ge(i)
    }
    ,
    Ah.K9 = function(t) {
        return "string" == typeof t
    }
    ,
    Ah.zt = function(t) {
        if (!Ah.K9(t))
            throw new TypeError("expected string")
    }
    ,
    Ah.gL = function(t) {
        Ah.aM(t) || Ah.zt(t)
    }
    ,
    Ah.Z9t = function(...t) {
        for (let i of t)
            Ah.zt(i)
    }
    ,
    Ah.Jvt = function(t) {
        if ("object" != typeof t || null === t)
            return !1;
        let i = Object.getPrototypeOf(t);
        return i ? i.constructor === Object : null === i
    }
    ,
    Ah.J1 = function(t) {
        if (!Ah.Jvt(t))
            throw new TypeError("expected simple object")
    }
    ,
    Ah.ML = function(t) {
        if (!Ah.aM(t) && !Ah.Jvt(t))
            throw new TypeError("expected simple object")
    }
    ,
    Ah.Wft = function(t) {
        return "object" == typeof t && null !== t && !Array.isArray(t)
    }
    ,
    Ah.IL = function(t) {
        if (!Ah.Wft(t))
            throw new TypeError("expected object")
    }
    ,
    Ah.kQ = function(t) {
        Ah.aM(t) || Ah.IL(t)
    }
    ,
    Ah.Q9t = function(...t) {
        for (let i of t)
            Ah.IL(i)
    }
    ,
    Ah.ptt = function(t) {
        return Ah.tti(t, Blob) && "string" == typeof t.name
    }
    ,
    Ah.M4 = function(t) {
        if (!Ah.ptt(t))
            throw new TypeError("expected file")
    }
    ,
    Ah.wut = function(t) {
        Ah.aM(t) || Ah.M4(t)
    }
    ,
    Ah.B9 = function(t) {
        return Array.isArray(t)
    }
    ,
    Ah.RH = function(t) {
        if (!Ah.B9(t))
            throw new TypeError("expected array")
    }
    ,
    Ah.D_t = function(t) {
        Ah.aM(t) || Ah.RH(t)
    }
    ,
    Ah.iti = function(...t) {
        for (let i of t)
            Ah.RH(i)
    }
    ,
    Ah.kct = function(t) {
        return !!Ah.B9(t) && (!t.length || !!Ah.B9(t[0]))
    }
    ,
    Ah.eM = function(t) {
        if (!Ah.kct(t))
            throw new TypeError("expected 2d array");
        for (let i of t)
            if (!Ah.B9(i))
                throw new TypeError("expected 2d array")
    }
    ,
    Ah.rM = function(t) {
        Ah.aM(t) || Ah.eM(t)
    }
    ,
    Ah.w9 = function(t) {
        return "function" == typeof t
    }
    ,
    Ah.nu = function(t, i) {
        if (!Ah.w9(t))
            throw new TypeError("expected function");
        if (!Ah.aM(i) && t !== i)
            throw new TypeError("expected same function reference")
    }
    ,
    Ah.tot = function(t) {
        Ah.aM(t) || Ah.nu(t)
    }
    ,
    Ah.eti = function(...t) {
        for (let i of t)
            Ah.nu(i)
    }
    ,
    Ah.sti = function(t, ...i) {
        if (!Ah.w9(t))
            throw new TypeError("expected function");
        if (!i.length)
            throw new Error("missing comparison functions");
        for (let e of i)
            if (!Ah.aM(e) && t === e)
                return;
        throw new TypeError("expected same function reference")
    }
    ,
    Ah.nti = function(...t) {
        if (!Ah.aM(t))
            for (let i of t)
                Ah.tot(i)
    }
    ,
    Ah.Bm = function(t, i) {
        return t instanceof i
    }
    ,
    Ah.MAt = function(t, ...i) {
        for (let e of i)
            if (Ah.Bm(t, e))
                return !0;
        return !1
    }
    ,
    Ah.U = function(t, i) {
        if (!Ah.Bm(t, i))
            throw new TypeError("unexpected type")
    }
    ,
    Ah.Ef = function(t, i) {
        Ah.aM(t) || Ah.U(t, i)
    }
    ,
    Ah.rti = function(t, ...i) {
        for (let e of i)
            Ah.U(e, t)
    }
    ,
    Ah.eI = function(t, ...i) {
        if (!Ah.MAt(t, ...i))
            throw new TypeError("unexpected type")
    }
    ,
    Ah.$fe = function(t, ...i) {
        if (!Ah.aM(t) && !Ah.MAt(t, ...i))
            throw new TypeError("unexpected type")
    }
    ,
    Ah.wtt = function(t, i) {
        Ah.RH(t);
        for (let e of t)
            if (!Ah.Bm(e, i))
                return !1;
        return !0
    }
    ,
    Ah.hti = function(t) {
        Ah.RH(t);
        for (let i of t)
            if (!Ah.ub(i))
                return !1;
        return !0
    }
    ,
    Ah.QH = function(t, i) {
        Ah.RH(t);
        for (let e of t)
            Ah.U(e, i)
    }
    ,
    Ah.PD = function(t, i) {
        if (!Ah.aM(t)) {
            Ah.RH(t);
            for (let e of t)
                Ah.U(e, i)
        }
    }
    ,
    Ah.oti = function(t, i) {
        if (!Ah.aM(t)) {
            Ah.RH(t);
            for (let e of t)
                Ah.nu(e, i)
        }
    }
    ,
    Ah.ati = function(t, ...i) {
        Ah.RH(t);
        for (let e of t)
            Ah.eI(e, ...i)
    }
    ,
    Ah.lti = function(t, ...i) {
        if (!Ah.aM(t)) {
            Ah.RH(t);
            for (let e of t)
                Ah.eI(e, ...i)
        }
    }
    ,
    Ah.uti = function(t, i) {
        return !(Ah.aM(t) || !Ah.K9(t.nodeName)) && (!i || Ah.Kw(t.nodeName, i))
    }
    ,
    Ah.cti = function(t, i) {
        if (Ah.aM(t) || !Ah.K9(t.nodeName))
            throw new TypeError("expected DOM node");
        if (i && !Ah.Kw(t.nodeName, i))
            throw new TypeError(`expected DOM '${i}' node`)
    }
    ,
    Ah.dti = function(t, i) {
        Ah.aM(t) || Ah.cti(t, i)
    }
    ,
    Ah.fti = function(t, i) {
        return !(Ah.aM(t) || !Ah.K9(t.tagName)) && (!i || Ah.Kw(t.tagName, i))
    }
    ,
    Ah.ibt = function(t, i) {
        if (Ah.aM(t) || !Ah.K9(t.tagName))
            throw new TypeError("expected HTML element");
        if (i && !Ah.Kw(t.tagName, i))
            throw new TypeError(`expected HTML '${i}' element`)
    }
    ,
    Ah.mGt = function(t, i) {
        Ah.aM(t) || Ah.ibt(t, i)
    }
    ,
    Ah.pti = function(t) {
        return Ah.fti(t, "img") || Ah.fti(t, "canvas") || Ah.fti(t, "video") || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap
    }
    ,
    Ah.mti = function(t) {
        if (!Ah.pti(t))
            throw new TypeError("expected drawable")
    }
    ,
    Ah.GC = function(t) {
        Ah.aM(t) || Ah.mti(t)
    }
    ,
    Ah.wti = function(t) {
        return t instanceof ImageData || Ah.pti(t)
    }
    ,
    Ah.gti = function(t) {
        if (!Ah.wti(t))
            throw new TypeError("expected drawable or image data")
    }
    ,
    Ah.yti = function(t) {
        if (!Ah.aM(t) && !Ah.wti(t))
            throw new TypeError("expected drawable or image data")
    }
    ,
    Ah.bti = function(t) {
        return "string" == typeof t || Ah.vti && t instanceof Ah.vti || t instanceof Ah.ix
    }
    ,
    Ah.p0 = function(t) {
        if (!Ah.bti(t))
            throw new TypeError("expected string-like")
    }
    ,
    Ah.Sti = function(t) {
        Ah.aM(t) || Ah.p0(t)
    }
    ,
    Ah.xti = function(...t) {
        for (let i of t)
            Ah.p0(i)
    }
    ,
    Ah.kK = function() {
        throw new Error("must be overridden")
    }
    ,
    Ah.Mti = function() {
        throw new Error("not yet implemented")
    }
    ,
    Ah.Eti = function(t) {
        return t.constructor === function*() {}
        .constructor
    }
    ,
    Ah.Cti = function(t) {
        if (!Ah.Eti(t))
            throw new Error("expected generator function")
    }
    ,
    Ah._ti = function(t) {
        return "function" === t[Symbol.iterator]
    }
    ,
    Ah.Tti = function(t) {
        if (!Ah._ti(t))
            throw new Error("expected iterable")
    }
    ,
    Ah.Iti = function(t) {
        return !Ah.aM(t)
    }
    ,
    Ah.aM = function(t) {
        return null == t
    }
    ,
    Ah.dhe = function(t) {
        Ah.RH(t);
        let i = t[0].constructor;
        for (let e of t)
            if (e.constructor !== i)
                return !1;
        return i
    }
    ,
    Ah.IDt = function(t, i) {
        Ah.RH(t);
        for (let e of t)
            if (!(e instanceof i))
                return !1;
        return !0
    }
    ;
    const kh = Object.getPrototypeOf(Uint8Array);
    Ah.Pti = function(t) {
        return Ah.Bm(t, kh)
    }
    ,
    Ah.Gti = function(t) {
        Ah.U(t, kh)
    }
    ,
    Ah.Ati = function(t) {
        Ah.Rti(t, kh)
    }
    ,
    Ah.kti = function(t, ...i) {
        if (!Ah.Oti(t, ...i))
            throw new TypeError("unexpected type")
    }
    ,
    Ah.Oti = function(t, ...i) {
        for (const e of i)
            if (Ah.tti(t, e))
                return !0;
        return !1
    }
    ,
    Ah.Rti = function(t, i) {
        if (!Ah.tti(t, i))
            throw new TypeError("unexpected type")
    }
    ,
    Ah.tti = function(t, i) {
        for (; t = Object.getPrototypeOf(t); )
            if (t.constructor.name === i.name)
                return !0;
        return !1
    }
    ,
    Rh.Ck = Ah.Ck,
    Rh.Lj = Ah.Lj,
    Rh.Ge = Ah.Ge,
    Rh.iM = Ah.iM,
    Rh.zt = Ah.zt,
    Rh.gL = Ah.gL,
    Rh.IL = Ah.IL,
    Rh.kQ = Ah.kQ,
    Rh.RH = Ah.RH,
    Rh.D_t = Ah.D_t,
    Rh.nu = Ah.nu,
    Rh.tot = Ah.tot,
    Rh.U = Ah.U,
    Rh.Ef = Ah.Ef,
    Rh.aM = Ah.aM
}
{
    const Oh = self.t
      , Dh = new Set(["con", "prn", "aux", "nul", "com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9", "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"])
      , Fh = new Set(["\\", "/", ":", "*", "?", '"', "<", ">", "|", "~"])
      , Lh = new Set(["."])
      , Bh = new Set(["."])
      , Uh = 200;
    Oh.Dti = function() {
        return Uh
    }
    ,
    Oh.Fti = function(t) {
        if (Oh.zt(t),
        !t)
            return !1;
        const i = [...t.normalize()];
        return !(i.length >= Uh) && (!i.some(t => Fh.has(t)) && (!Lh.has(i[0]) && !Oh.Lti(i[0]) && (!Bh.has(i.at(-1)) && !Oh.Lti(i.at(-1)) && !Oh.Bti(t))))
    }
    ,
    Oh.Uti = function(t, i=!0) {
        Oh.zt(t);
        const e = [...t.normalize()];
        if (Oh.Pte(e, t => Fh.has(t)),
        i)
            for (; e.length && (Bh.has(e.at(-1)) || Oh.Lti(e.at(-1))); )
                e.pop();
        for (; e.length && (Lh.has(e[0]) || Oh.Lti(e[0])); )
            e.shift();
        return e.length > Uh && Oh.To(e, Uh),
        e.join("")
    }
    ,
    Oh.Nti = function(t, i="file") {
        const e = t.lastIndexOf(".");
        let s = -1 === e ? t : t.substr(0, e);
        const n = -1 === e ? "" : t.substr(e);
        return s = Oh.Uti(s, !1),
        s && !Oh.Bti(s) || (s = i),
        s + n
    }
    ,
    Oh.jti = function(t, i="folder") {
        return !(t = Oh.Uti(t)) || Oh.Bti(t) ? i : t
    }
    ,
    Oh.Bti = function(t) {
        return Oh.zt(t),
        Dh.has(t.toLowerCase())
    }
}
{
    const Nh = self.t;
    let jh = null
      , $h = "";
    if ("undefined" != typeof document) {
        jh = document;
        const qh = document.querySelector("base");
        $h = qh && qh.hasAttribute("href") ? qh.getAttribute("href") : "",
        $h && ($h.startsWith("/") && ($h = $h.substr(1)),
        $h.endsWith("/") || ($h += "/"))
    }
    Nh.$ti = function() {
        return $h
    }
    ,
    Nh.Vgt = function() {
        if (!jh)
            return "";
        const t = jh.location;
        return Nh.IW(t.origin + t.pathname) + $h
    }
    ,
    Nh.IW = function(t) {
        if (Nh.zt(t),
        !t.length)
            return t;
        if (t.endsWith("/") || t.endsWith("\\"))
            return t;
        const i = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === i ? "" : t.substr(0, i + 1)
    }
    ,
    Nh.zti = function(t) {
        if (Nh.zt(t),
        !t.length)
            return t;
        if (t.endsWith("/") || t.endsWith("\\"))
            return "";
        const i = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === i ? t : t.substr(i + 1)
    }
    ,
    Nh.l7 = function(t) {
        Nh.zt(t);
        let i = t.lastIndexOf(".");
        return i < 1 ? "" : t.substr(i)
    }
    ,
    Nh.Vti = function(t, i) {
        Nh.zt(t),
        Nh.zt(i);
        const e = t.lastIndexOf(".");
        return -1 === e ? t + "." + i : t.substr(0, e + 1) + i
    }
    ,
    Nh.w7 = function(t) {
        let i = t.lastIndexOf(".");
        return i < 1 ? t : t.substr(0, i)
    }
    ,
    Nh.Wti = function(t) {
        return t.replace(/\\/g, "/")
    }
    ,
    Nh.Hti = function(t, i) {
        return i === (t ? Nh.l7(t).slice(1) : "")
    }
    ,
    Nh.Kti = function(t, i) {
        let e, s;
        return Nh.ptt(t) && (e = Nh.w7(t.name)),
        Nh.K9(t) && (e = Nh.w7(t)),
        Nh.ptt(i) && (s = Nh.w7(i.name)),
        Nh.K9(i) && (s = Nh.w7(i)),
        e === s
    }
    ,
    Nh.qti = function(t) {
        t = Nh.Wti(t);
        let i = /^\w\:\//.exec(t);
        i ? (i = i[0],
        "/" !== (t = t.slice(3))[0] && (t = "/" + t)) : i = "",
        (t = t.replace(/\/{2,}/g, "/")).length > 1 && "/" === t.slice(-1) && (t = t.slice(0, -1));
        const e = t.lastIndexOf("/") + 1;
        let s, n = "", r = t, h = "";
        e > 0 && (n = t.slice(0, e),
        r = t.slice(e)),
        s = r;
        const o = r.lastIndexOf(".");
        o > 0 && (h = r.slice(o),
        s = r.slice(0, -h.length));
        return {
            dir: n,
            Xti: r,
            name: s,
            root: i,
            ext: h,
            Yti: i + n + r
        }
    }
    ,
    Nh.Jti = function(t, i) {
        return Nh.Ge(t),
        new Promise( (e, s) => {
            self.setTimeout(e, t, i)
        }
        )
    }
    ,
    Nh.Zti = function(t) {
        Nh.nu(t);
        try {
            t()
        } catch (t) {
            Nh.$M && (() => {})("Swallowed exception: ", t)
        }
    }
    ,
    Nh.wS = function() {}
    ,
    Nh.Kw = function(t, i) {
        return Nh.gL(t),
        Nh.gL(i),
        "string" == typeof t && "string" == typeof i && (t === i || t.normalize().toLowerCase() === i.normalize().toLowerCase())
    }
    ,
    Nh.Qti = function(t, i) {
        return Nh.gL(t),
        Nh.gL(i),
        "string" == typeof t && "string" == typeof i && (t === i || t.normalize() === i.normalize())
    }
    ,
    Nh.tii = function(t, i, e) {
        t[e++] = i[0],
        t[e++] = i[1],
        t[e++] = i[2],
        t[e++] = i[3],
        t[e++] = i[4],
        t[e++] = i[5],
        t[e++] = i[6],
        t[e++] = i[7],
        t[e++] = i[8],
        t[e++] = i[9],
        t[e++] = i[10],
        t[e++] = i[11],
        t[e++] = i[12],
        t[e++] = i[13],
        t[e++] = i[14],
        t[e] = i[15]
    }
    ,
    Nh.To = function(t, i) {
        Nh.RH(t),
        Nh.Ge(i),
        t.length = i
    }
    ,
    Nh.Io = function(t) {
        Nh.D_t(t),
        t && 0 !== t.length && Nh.To(t, 0)
    }
    ,
    Nh.Dct = function(t) {
        if (Nh.rM(t),
        t) {
            for (let i = 0; i < t.length; i++) {
                let e = t[i];
                Nh.To(e, 0)
            }
            Nh.To(t, 0)
        }
    }
    ,
    Nh.iii = function(t, i, e) {
        Nh.RH(t),
        Nh.Ge(i),
        i |= 0;
        const s = t.length;
        if (!(i <= s))
            for (let n = s; n < i; ++n)
                t.push(e)
    }
    ,
    Nh.nv = function(t, i, e) {
        Nh.RH(t),
        Nh.Ge(i),
        i |= 0;
        const s = t.length;
        i < s ? Nh.To(t, i) : i > s && Nh.iii(t, i, e)
    }
    ,
    Nh.mf = function(t, i) {
        Nh.RH(t),
        Nh.RH(i),
        Nh.Io(t),
        Nh.Oo(t, i)
    }
    ,
    Nh.Oo = function(t, i) {
        if (Nh.RH(t),
        Nh.RH(i),
        i.length < 1e4)
            t.push(...i);
        else
            for (let e = 0, s = i.length; e < s; ++e)
                t.push(i[e])
    }
    ,
    Nh.eii = function(t, i) {
        if ((i = Math.floor(i)) < 0 || i >= t.length)
            return;
        let e = t.length - 1;
        for (let s = i; s < e; ++s)
            t[s] = t[s + 1];
        Nh.To(t, e)
    }
    ,
    Nh.sii = function(t, i) {
        Nh.RH(t);
        let e = t.indexOf(i);
        e >= 0 && t.splice(e, 1)
    }
    ,
    Nh.Zie = function(t, i) {
        Nh.RH(t),
        Nh.RH(i);
        let e = t.length;
        if (i.length !== e)
            return !1;
        for (let s = 0; s < e; ++s)
            if (t[s] !== i[s])
                return !1;
        return !0
    }
    ,
    Nh.Pte = function(t, i) {
        Nh.RH(t),
        Nh.nu(i);
        let e = []
          , s = 0;
        for (let n = 0, r = t.length; n < r; ++n) {
            let r = t[n];
            i(r) ? e.push(r) : (t[s] = r,
            ++s)
        }
        return Nh.To(t, s),
        e
    }
    ,
    Nh.lAt = function(t, i) {
        Nh.RH(t),
        Nh.U(i, Set);
        const e = t.length;
        let s = 0;
        for (let e = 0, n = t.length; e < n; ++e) {
            let n = t[e];
            i.has(n) || (t[s++] = n)
        }
        return Nh.To(t, s),
        e - s
    }
    ,
    Nh.nii = function(t, i) {
        return t === Math.floor(t) && (t >= 0 && t < i.length)
    }
    ,
    Nh.rii = function(t, i) {
        if (!Nh.nii(t, i))
            throw new RangeError("array index out of bounds")
    }
    ,
    Nh.hx = function(t) {
        return t.slice()
    }
    ,
    Nh.Oct = function(t, i) {
        Nh.RH(t),
        Nh.nu(i);
        let e = [];
        for (let s of t)
            if (Nh.Wft(s)) {
                let t = i(s);
                if (!t)
                    throw new Error("missing clone");
                if (t.constructor !== s.constructor)
                    throw new Error("object is not a clone");
                e.push(t)
            } else
                Nh.B9(s) ? e.push(Nh.Oct(s, i)) : e.push(s);
        return e
    }
    ,
    Nh.Act = function(t) {
        Nh.eM(t);
        let i = [];
        for (let e of t)
            i.push(e.slice());
        return i
    }
    ,
    Nh.hii = function(t, i=" ") {
        return t ? t.split(i).map(t => t.trim()).filter(t => !!t) : []
    }
    ,
    Nh.oii = function(t, i, e) {
        Nh.U(t, Set),
        Nh.nu(i),
        Nh.tot(e);
        const s = new Set;
        for (const n of t.values())
            i(n) && (e ? s.add(e(n)) : s.add(n));
        return s
    }
    ,
    Nh.Kqt = function(t, i) {
        return t.union ? t.union(i) : new Set([...t, ...i])
    }
    ,
    Nh.UD = function(t, i) {
        for (const e of i)
            t.add(e);
        return t
    }
    ,
    Nh.th = function(t) {
        for (let i of t)
            return i;
        return null
    }
    ,
    Nh.xor = function(t, i) {
        return !t != !i
    }
    ,
    Nh.compare = function(t, i, e) {
        switch (i) {
        case 0:
            return t === e;
        case 1:
            return t !== e;
        case 2:
            return t < e;
        case 3:
            return t <= e;
        case 4:
            return t > e;
        case 5:
            return t >= e;
        default:
            return !1
        }
    }
    ,
    Nh.aii = function(t) {
        Nh.IL(t);
        for (let i in t)
            if (t.hasOwnProperty(i))
                return !0;
        return !1
    }
    ,
    Nh.lii = function(t, i) {
        return Nh.QH(t, Promise),
        Nh.nu(i),
        t.length ? new Promise( (e, s) => {
            const n = [];
            let r = 0
              , h = !1;
            for (let o = 0, a = t.length; o < a; ++o)
                n.push(void 0),
                t[o].then(s => {
                    h || (n[o] = s,
                    ++r,
                    r === t.length ? e(n) : i(r, t.length))
                }
                ).catch(t => {
                    h = !0,
                    s(t)
                }
                )
        }
        ) : Promise.resolve([])
    }
    ;
    let zh = [];
    Nh.uii = function(t) {
        Nh.nu(t),
        zh.push(t)
    }
    ,
    Nh.cii = function() {
        let t = 0;
        for (let i of zh) {
            let e = i();
            Nh.Ge(e),
            t += e
        }
        return Math.floor(t)
    }
    ;
    let Vh = 1;
    const Wh = new Map
      , Hh = new MessageChannel;
    Hh.port2.onmessage = function(t) {
        const i = t.data
          , e = Wh.get(i);
        Wh.delete(i),
        e && e(performance.now())
    }
    ,
    Nh.dii = function(t) {
        Nh.nu(t);
        const i = Vh++;
        return Wh.set(i, t),
        Hh.port1.postMessage(i),
        i
    }
    ,
    Nh.fii = function(t) {
        Nh.Ge(t),
        Wh.delete(t)
    }
    ,
    Nh.pii = Nh.dii,
    Nh.mii = function() {
        return new Promise(t => Nh.pii(t))
    }
    ;
    const Kh = new Set;
    Nh.wii = function(t) {
        Nh.nu(t);
        const i = self.requestAnimationFrame(async e => {
            await Nh.mii(),
            Kh.has(i) && (Kh.delete(i),
            t(e))
        }
        );
        return Kh.add(i),
        i
    }
    ,
    Nh.gii = function(t) {
        Nh.Ge(t),
        Kh.has(t) && (self.cancelAnimationFrame(t),
        Kh.delete(t))
    }
}
{
    const Xh = self.t;
    Xh.bW = function(t) {
        let i = window.getImportDocument(t)
          , e = window.c3_releaseMainImportDoc;
        return i === document && e && (i = e),
        i
    }
    ,
    Xh.yii = function(t) {
        return Xh.zt(t),
        /^(?:[a-z\-]+:)?\/\//.test(t) || "data:" === t.substr(0, 5) || "blob:" === t.substr(0, 5)
    }
    ,
    Xh.bii = function(t) {
        return !Xh.yii(t)
    }
    ,
    Xh.FSt = function(t, i) {
        const e = new t.constructor(t.type,t);
        e.Z3t = !0;
        !i.dispatchEvent(e) && t.preventDefault()
    }
    ,
    Xh.vii = function() {
        return "nwjs" === Xh.kt.Mme ? "nwjs" : window.matchMedia("(display-mode: fullscreen)").matches ? "fullscreen" : window.matchMedia("(display-mode: standalone)").matches ? "app-info://platform/microsoft-store" === document.referrer ? "standalone-microsoft-store" : "standalone" : window.matchMedia("(display-mode: minimal-ui)").matches ? "minimal-ui" : navigator.standalone ? "standalone" : "browser"
    }
    ,
    Xh.Sii = function(t, i) {
        for (Xh.cti(t),
        Xh.zt(i),
        i = i.toUpperCase(); t.parentNode; )
            if ((t = t.parentNode).tagName === i)
                return t;
        return null
    }
    ,
    Xh.x3t = function(t, i) {
        for (Xh.mGt(t),
        Xh.RH(i); t; ) {
            for (const e of i)
                if (t.classList.contains(e))
                    return t;
            t = t.parentElement
        }
        return null
    }
    ,
    Xh.HEt = function(t, i) {
        return Xh.mGt(t),
        Xh.RH(i),
        !!Xh.x3t(t, i)
    }
    ,
    Xh.S3t = function(t, i) {
        for (Xh.mGt(t),
        Xh.RH(i); t; ) {
            const e = t.tagName;
            for (const s of i)
                if (Xh.Kw(e, s))
                    return t;
            t = t.parentElement
        }
        return null
    }
    ,
    Xh.Fft = function(t, i) {
        return Xh.mGt(t),
        Xh.RH(i),
        !!Xh.S3t(t, i)
    }
    ,
    Xh.TP = function(t, i) {
        for (Xh.ibt(t),
        Xh.ibt(i); t.parentNode; ) {
            if (t.parentNode === i)
                return !0;
            t = t.parentNode
        }
        return !1
    }
    ,
    Xh.xii = function(t, i) {
        Xh.ibt(t);
        let e = getComputedStyle(t);
        const s = "absolute" === e.position
          , n = i ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
        if ("fixed" === e.position)
            return document.body;
        for (let i = t; i = i.parentElement; )
            if (e = getComputedStyle(i),
            (!s || "static" !== e.position) && n.test(e.overflow + e.overflowY + e.overflowX))
                return i;
        return document.body
    }
    ,
    Xh.Mii = function(t) {
        Xh.ibt(t);
        const i = t.childNodes;
        for (let t = 0, e = i.length; t < e; ++t) {
            let e = i[t];
            if (3 === e.nodeType)
                return e
        }
        return null
    }
    ,
    Xh.aMt = function(t) {
        Xh.cti(t);
        do {
            if (t.parentNode && t.hasAttribute("contenteditable"))
                return !0;
            t = t.parentNode
        } while (t);
        return !1
    }
    ;
    const Yh = new Set(["textarea", "input", "button", "select", "option"]);
    Xh.Eii = function(t) {
        const i = t || document;
        if (i.hasFocus()) {
            const t = i.activeElement
              , e = t.tagName.toLowerCase();
            return !(!t || !t.hasAttribute("contenteditable") || "false" === t.getAttribute("contenteditable")) || Yh.has(e)
        }
        for (const t of Xh.Qs.TO.Cii()) {
            const i = t?.FO();
            if (!i?.hasFocus())
                continue;
            const e = i.activeElement
              , s = e.tagName.toLowerCase();
            return !(!e || !e.hasAttribute("contenteditable") || "false" === e.getAttribute("contenteditable")) || Yh.has(s)
        }
        return !1
    }
    ;
    const Jh = new Set(["email", "number", "password", "search", "tel", "text", "url"]);
    Xh.ddt = function(t, i) {
        const e = t || document;
        if (e.hasFocus()) {
            if (Xh._ii(e.activeElement, i))
                return !0
        } else
            for (const t of Xh.Qs.TO.Cii()) {
                const e = t?.FO();
                if (e?.hasFocus() && Xh._ii(e.activeElement, i))
                    return !0
            }
        return !1
    }
    ,
    Xh._ii = function(t, i) {
        if (!t)
            return !1;
        const e = t.tagName.toLowerCase();
        if ("textarea" === e)
            return !0;
        if ("input" === e) {
            const e = t.getAttribute("type") || "text";
            return i ? (self.assert(Jh.has(i), `"${i}" is not a text editable type`),
            i.toLowerCase() === e.toLowerCase()) : Jh.has(e.toLowerCase())
        }
        return !(!t || !t.hasAttribute("contenteditable") || "false" === t.getAttribute("contenteditable"))
    }
    ,
    Xh.Tii = function t(i, e) {
        Xh.cti(i),
        Xh.nu(e),
        e(i);
        for (let s = 0, n = i.childNodes.length; s < n; ++s)
            t(i.childNodes[s], e)
    }
    ,
    Xh.Sme = function() {
        return !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement)
    }
    ,
    Xh.Ime = function(t) {
        let i;
        t.requestFullscreen ? i = t.requestFullscreen() : t.msRequestFullscreen ? i = t.msRequestFullscreen() : t.mozRequestFullScreen ? i = t.mozRequestFullScreen() : t.webkitRequestFullscreen && (i = t.webkitRequestFullscreen()),
        i instanceof Promise && i.catch(t => console.error("Failed to enter fullscreen mode: ", t))
    }
    ,
    Xh.Ame = function() {
        let t;
        document.exitFullscreen ? t = document.exitFullscreen() : document.msExitFullscreen ? t = document.msExitFullscreen() : document.mozCancelFullScreen ? t = document.mozCancelFullScreen() : document.webkitExitFullscreen && (t = document.webkitExitFullscreen()),
        t instanceof Promise && t.catch(t => console.error("Failed to exit fullscreen mode: ", t))
    }
    ,
    Xh.rat = function(t) {
        Xh.Ge(t);
        const i = self.devicePixelRatio;
        return Math.round(t * i) / i
    }
    ,
    Xh.gLt = function(t, i) {
        return Xh.zt(t),
        Xh.zt(i),
        new Promise( (e, s) => {
            const n = document.createElement("a");
            n.textContent = t,
            n.href = i,
            n.download = t,
            n.setAttribute("target", "_self"),
            document.body.appendChild(n),
            n.click(),
            document.body.removeChild(n),
            window.setTimeout(e, 16)
        }
        )
    }
    ,
    Xh.g7 = function(t, i) {
        Xh.zt(t),
        Xh.U(i, Blob);
        let e = URL.createObjectURL(i);
        return setTimeout( () => URL.revokeObjectURL(e), 6e4),
        Xh.gLt(t, e)
    }
    ,
    Xh.lU = function(t) {
        Xh.$5t && performance.mark(t + "-Start")
    }
    ,
    Xh.OU = function(t) {
        Xh.$5t && (performance.mark(t + "-End"),
        performance.measure(t, t + "-Start", t + "-End"))
    }
    ,
    Xh.Iii = function(t) {
        Xh.$5t && console.log(performance.getEntriesByName(t, "measure"))
    }
    ;
    const Zh = document.createElement("input");
    Zh.setAttribute("type", "color"),
    Zh.className = "hiddenColorPicker",
    Zh.style.left = "-9999px",
    Zh.style.top = "-9999px",
    Zh.style.opacity = "0",
    window.C3_IsPopupWindow || document.body.appendChild(Zh),
    Xh.MA = function(t, i, e=-1, s=-1) {
        if (Xh.zt(t),
        Xh.nu(i),
        e < 0 || s < 0) {
            const [t,i] = Xh.Qs.sk.f4t(document);
            e = t,
            s = i
        }
        Zh.style.left = e + "px",
        Zh.style.top = s + "px",
        Zh.onchange = null,
        Zh.value = t;
        const n = () => {
            i(Zh.value)
        }
        ;
        Zh.onblur = n,
        Zh.onchange = n,
        requestAnimationFrame( () => Zh.click())
    }
    ;
    let Qh = ""
      , to = "";
    function io(t) {
        t.clipboardData.setData("text/plain", Qh),
        t.stopPropagation(),
        t.preventDefault()
    }
    function eo(t) {
        Xh.zt(t);
        const i = document.createElement("textarea");
        let e;
        i.value = "x",
        document.body.appendChild(i),
        i.select(),
        window.addEventListener("copy", io, !0),
        Qh = t;
        try {
            e = document.execCommand("copy")
        } catch (t) {
            e = !1
        }
        return Qh = "",
        window.removeEventListener("copy", io, !0),
        document.body.removeChild(i),
        e
    }
    function so(t, i, e) {
        const s = self.lang
          , n = Xh.Qs.Ks.qs("Confirm");
        let r = null
          , h = null;
        const o = new Promise( (t, i) => {
            r = t,
            h = i
        }
        );
        return n.Pii = () => {
            let n;
            n = "function" == typeof e ? e() : Xh.IT(t, i),
            n.then(t => r(t)).catch( () => {
                Xh.p.u("ui.clipboard-copy-prompt");
                const t = Xh.Qs.Ks.qs("OK");
                t.Wa(s(".caption")),
                t.Xa(s(".failed-message"), i),
                Xh.p.j(),
                h()
            }
            )
        }
        ,
        Xh.p.u("ui.clipboard-copy-prompt"),
        n.Xa({
            caption: s(".caption"),
            message: s(".message"),
            _nt: s(".copy")
        }, i).then(t => {
            null === t && h()
        }
        ),
        Xh.p.j(),
        o
    }
    Xh.IT = function(t, i) {
        if (Xh.mGt(i),
        self.app.uL())
            return Xh.fL(t),
            Promise.resolve();
        if (navigator.clipboard && navigator.clipboard.writeText) {
            const e = i ? i.ownerDocument.defaultView : window;
            return Xh.QL.F9t || Xh.fL(t),
            self.Aii.Gii( () => e.navigator.clipboard.writeText(t))
        }
        return Xh.fL(t),
        eo(t),
        Promise.resolve()
    }
    ,
    Xh.dL = async function() {
        if (self.app.uL())
            return !1;
        if (!Xh.QL.F9t)
            return !1;
        if (!Xh.QL.B9t)
            return !0;
        let t;
        try {
            t = await navigator.permissions.query({
                name: "clipboard-read"
            })
        } catch (t) {
            return !1
        }
        return "prompt" === t.state
    }
    ,
    Xh.cL = async function(t, i) {
        Xh.zt(t);
        try {
            return await Xh.IT(t, i),
            !0
        } catch (e) {
            try {
                return await so(t, i),
                !0
            } catch (t) {
                return !1
            }
        }
    }
    ,
    Xh.Rii = function(t, i) {
        return so("", t, i)
    }
    ,
    Xh.pL = function(t) {
        if (Xh.mGt(t),
        Xh.QL.F9t && !self.app.uL()) {
            return (t ? t.ownerDocument.defaultView : window).navigator.clipboard.readText().catch( () => "")
        }
        return Promise.resolve(Xh.yL())
    }
    ,
    Xh.fL = function(t) {
        Xh.zt(t),
        to = t
    }
    ,
    Xh.yL = function() {
        return to
    }
    ;
    const no = document.createElement
      , ro = document.appendChild
      , ho = MessageChannel
      , oo = MessagePort.prototype.postMessage;
    Xh.kii = function(t) {
        Xh.IL(t),
        Xh.zt(t.src),
        Xh.zt(t.Oii),
        Xh.tot(t.Dii),
        Xh.gL(t.sandbox);
        const i = no.call(document, "iframe")
          , e = new ho
          , s = e.port1
          , n = e.port2;
        t.Dii && (s.onmessage = t.Dii);
        const r = new Promise( (e, r) => {
            i.addEventListener("load", () => {
                try {
                    i.contentWindow.postMessage({
                        type: "init",
                        productType: self.app.bne()
                    }, t.Oii, [n])
                } catch (t) {
                    return void r(t)
                }
                e({
                    Qa: i,
                    Fii: function(t, i) {
                        try {
                            oo.call(s, t, i)
                        } catch (t) {
                            console.error("[Analytics] Failed to post message: ", t)
                        }
                    }
                })
            }
            ),
            i.addEventListener("error", t => {
                r(t)
            }
            )
        }
        );
        return "string" == typeof t.sandbox && i.setAttribute("sandbox", t.sandbox),
        i.style.display = "none",
        i.src = t.src,
        ro.call(t.parent || document.body, i),
        r
    }
    ,
    Xh.Nft = function(t, i, e) {
        if (Xh.Ge(i),
        Xh.Ge(e),
        "function" == typeof t.elementsFromPoint)
            return t.elementsFromPoint(i, e);
        if (t.msElementsFromPoint) {
            const s = t.msElementsFromPoint(i, e);
            return s ? Array.from(s) : []
        }
        throw new Error("no elementsFromPoint method")
    }
    ,
    Xh.edt = function(t, i) {
        Xh.Xzt(t, i, "scrollBy")
    }
    ,
    Xh.Bt = function(t, i) {
        Xh.Xzt(t, i, "scrollTo")
    }
    ,
    Xh.Xzt = function(t, i, e) {
        Xh.ibt(t),
        Xh.IL(i),
        Xh.Ge(i.left),
        Xh.Ge(i.top),
        Xh.gL(i.behavior),
        Xh.zt(e);
        const s = "scrollBehavior"in t.ownerDocument.documentElement.style;
        if ("function" == typeof t[e])
            s ? t[e](i) : t[e](i.left, i.top);
        else
            switch (e) {
            case "scrollTo":
                t.scrollLeft = i.left,
                t.scrollTop = i.top;
                break;
            case "scrollBy":
                t.scrollLeft = t.scrollLeft + i.left,
                t.scrollTop = t.scrollTop + i.top
            }
    }
}
{
    const ao = self.t
      , lo = new Set(["text", "blob", "json", "arraybuffer"])
      , uo = new Set(["text", "blob", "json", "arraybuffer", "document"]);
    function co(t) {
        const i = [];
        for (let e in t)
            t[e] && i.push(e + "=" + encodeURIComponent(t[e]));
        return i.join("&")
    }
    function fo(t, i, e, s, n, r, h, o) {
        return new Promise( (a, l) => {
            const u = new XMLHttpRequest;
            if (u.open(t, i),
            u.responseType = "json" === n ? "text" : n,
            r && u.overrideMimeType(r),
            e)
                for (const [t,i] of Object.entries(e))
                    u.setRequestHeader(t, i);
            u.onload = () => {
                if (u.status < 300 && u.status >= 200)
                    if ("json" === n)
                        try {
                            a(JSON.parse(u.response))
                        } catch (t) {
                            l(t)
                        }
                    else
                        a(u.response);
                else
                    l(new Error(`error fetching ${i} (${u.status} ${u.statusText})`))
            }
            ,
            h && (u.onprogress = h),
            u.onerror = () => l(new Error(`error fetching ${i} (${u.status} ${u.statusText})`)),
            u.onabort = () => {
                l(new DOMException("Aborted","AbortError"))
            }
            ,
            o && (o.aborted ? u.abort() : o.addEventListener("abort", () => u.abort())),
            u.send(s)
        }
        )
    }
    async function po(t, i, e, s, n, r) {
        const h = {
            method: t
        };
        s && (h.body = s),
        e && (h.headers = e),
        r && (h.signal = r);
        let o = null;
        try {
            o = await fetch(i, h)
        } catch (t) {
            throw t && "string" == typeof t.message && "failed to fetch" === t.message.toLowerCase() && (t.message += ` (url: ${i})`),
            t
        }
        if (!o.ok)
            throw new Error(`error fetching ${i} (${o.status} ${o.statusText})`);
        return o[n]()
    }
    ao.$9t = function(t) {
        t = ao.K9(t) ? {
            url: t
        } : t,
        ao.IL(t),
        ao.zt(t.url),
        ao.gL(t.method),
        ao.kQ(t.arguments),
        ao.kQ(t.query),
        ao.gL(t.response),
        ao.kQ(t.headers),
        ao.gL(t.encode),
        ao.gL(t.Lii),
        ao.tot(t.onprogress),
        ao.tot(t.onprogress),
        ao.kQ(t.signal);
        let i = t.url
          , e = t.data;
        const s = t.Lii
          , n = t.onprogress
          , r = t.headers
          , h = t.method || "GET"
          , o = co(t.arguments) || ""
          , a = t.response || "text"
          , l = t.signal;
        o && (i += i.includes("?") ? "&" : "?",
        i += o),
        e && ("json" === t.encode ? e = JSON.stringify(t.data) : "url" === t.encode && (e = co(t.data)));
        const u = ao.QL.$9t && lo.has(a)
          , c = uo.has(a);
        if (u && !n)
            return po(h, i, r, e, a, l);
        if (c)
            return fo(h, i, r, e, a, s, n, l);
        throw new TypeError(`invalid response type '${a}'`)
    }
    ,
    ao.Bii = function(t) {
        return ao.zt(t),
        ao.$9t({
            url: t,
            mimeType: "text/plain; charset=utf-8"
        })
    }
    ,
    ao.Uii = function(t, i) {
        return ao.zt(t),
        ao.gL(i),
        ao.$9t({
            url: t,
            response: "document",
            Lii: i
        })
    }
    ,
    ao.O4 = function(t) {
        return ao.zt(t),
        ao.$9t({
            url: t,
            response: "json"
        })
    }
    ,
    ao._4 = function(t, i, e) {
        ao.zt(t),
        ao.tot(i);
        const s = Object.assign({}, {
            url: t,
            onprogress: i,
            response: "blob"
        }, e);
        return ao.$9t(s)
    }
    ,
    ao.T4 = function(t, i, e) {
        return ao.zt(t),
        ao.zt(i),
        ao.tot(e),
        ao.$9t({
            url: t,
            onprogress: e,
            response: "blob"
        }).then(t => ao.Mct([t], i, {
            type: t.type
        }))
    }
    ,
    ao.Nii = function(t, i=!0) {
        return ao.zt(t),
        window.addImport(t, i)
    }
    ,
    ao.jii = function(t) {
        return ao.zt(t),
        new Promise( (i, e) => {
            let s = document.createElement("link");
            s.onload = function() {
                i(s)
            }
            ,
            s.onerror = function(t) {
                e(t)
            }
            ,
            s.rel = "stylesheet",
            s.href = t,
            document.head.appendChild(s)
        }
        )
    }
    ,
    ao.DYt = function(t, i=!1) {
        return ao.zt(t),
        new Promise( (e, s) => {
            const n = document.createElement("script");
            n.onload = function() {
                e(n)
            }
            ,
            n.onerror = function(t) {
                s(t)
            }
            ,
            n.async = !1,
            i || (n.type = "module"),
            n.src = t,
            document.head.appendChild(n)
        }
        )
    }
    ,
    ao.$ii = function(t) {
        return ao.zt(t),
        new Promise( (i, e) => {
            let s = new Image;
            s.onload = function() {
                i(s)
            }
            ,
            s.onerror = function(t) {
                e(t)
            }
            ,
            s.src = t
        }
        )
    }
}
{
    const mo = self.t;
    async function wo(t) {
        if (t.size < 24)
            return null;
        const i = t.slice(0, 24)
          , e = await mo.zii(i)
          , s = new DataView(e);
        return 2303741511 !== s.getUint32(0) || 218765834 !== s.getUint32(4) || 1229472850 !== s.getUint32(12) ? null : {
            width: s.getUint32(16),
            height: s.getUint32(20)
        }
    }
    async function go(t) {
        const i = await wo(t);
        if (i)
            return i;
        const e = await mo.bS(t);
        return {
            width: e.width,
            height: e.height
        }
    }
    mo.Yvt = function(t) {
        return mo.zt(t),
        mo.lre( () => JSON.parse(t))
    }
    ,
    mo.BLt = async function(t) {
        mo.zt(t);
        const i = await fetch(t);
        return await i.blob()
    }
    ,
    mo.iW = async function(t) {
        if (mo.M4(t),
        self.assert(mo.QL.ImageDecoder, "ImageDecoder is not supported"),
        self.assert(mo.tW(t), "the file is not a multi image container"),
        t.c3Props && t.c3Props.extracted)
            return [t];
        const i = t.type || mo.MimeType.Hst(mo.l7(t.name)).eEt();
        try {
            const e = new self.ImageDecoder({
                data: t.stream(),
                options: {},
                type: i
            });
            if (!(e.completed instanceof Promise))
                return [t];
            await e.completed;
            const s = e.tracks;
            if (!(s.ready instanceof Promise))
                return [t];
            await s.ready;
            const n = s.selectedIndex;
            if ("number" != typeof n)
                return [t];
            const r = s[n].frameCount;
            if (1 === r)
                return [t];
            const h = async (i, s) => {
                const n = await e.decode({
                    frameIndex: i
                })
                  , r = await createImageBitmap(n.image)
                  , h = await mo.Vii(r)
                  , o = `${mo.w7(t.name)}-${i}.png`
                  , a = mo.Mct([h], o, {
                    type: "image/png",
                    Wii: {
                        extracted: !0
                    }
                });
                s[i] = a
            }
              , o = new Array(r)
              , a = [];
            for (let t = 0, i = r; t < i; t++)
                a.push(h(t, o));
            return await Promise.all(a),
            e.close(),
            o
        } catch (i) {
            return (() => {})("Error decoding multi image container: ", i),
            [t]
        }
    }
    ;
    let yo = null;
    mo.Hii = function(t) {
        return yo || (yo = mo.v(mo.o4, 16)),
        yo.WL( () => go(t))
    }
    ,
    mo.aS = async function(t) {
        const i = await mo.bS(t);
        if (i.width > 0 && i.height > 0)
            return [i.width, i.height];
        {
            i.style.position = "absolute",
            i.style.left = "0px",
            i.style.top = "0px",
            i.style.visibility = "hidden",
            document.body.appendChild(i);
            const t = i.getBoundingClientRect();
            return document.body.removeChild(i),
            [t.width, t.height]
        }
    }
    ,
    mo.lL = function(t) {
        return mo.U(t, Blob),
        new Promise( (i, e) => {
            let s = new FileReader;
            s.onload = t => i(t.target.result),
            s.onerror = t => e(t),
            s.readAsDataURL(t)
        }
        )
    }
    ,
    mo.Kii = function(t, i) {
        mo.zt(t),
        mo.gL(i);
        let e, s, n = t.length, r = n >> 2, h = new Uint8Array(n), o = new Uint32Array(h.buffer,0,r);
        for (e = 0,
        s = 0; e < r; ++e)
            o[e] = t.charCodeAt(s++) | t.charCodeAt(s++) << 8 | t.charCodeAt(s++) << 16 | t.charCodeAt(s++) << 24;
        let a = 3 & n;
        for (; a--; )
            h[s] = t.charCodeAt(s),
            ++s;
        return i ? new Blob([h],{
            type: i
        }) : new Blob([h])
    }
    ,
    mo.zii = function(t) {
        return mo.Rti(t, Blob),
        "function" == typeof t.arrayBuffer ? t.arrayBuffer() : new Promise( (i, e) => {
            const s = new FileReader;
            s.onload = () => i(s.result),
            s.onerror = () => e(s.error),
            s.readAsArrayBuffer(t)
        }
        )
    }
    ,
    mo.rW = function(t) {
        return mo.Rti(t, Blob),
        mo.zii(t).then(i => new Blob([i],{
            type: t.type
        }))
    }
    ,
    mo.qii = function(t, i) {
        return mo.M4(t),
        mo.gL(i),
        mo.zii(t).then(e => mo.Mct([e], i ?? t.name, {
            type: t.type,
            lastModified: t.lastModified,
            path: t.path,
            Wii: t.c3Props
        }))
    }
    ,
    mo.Mct = function(t, i="", {type: e="", lastModified: s=Date.now(), path: n="", Wii: r={}}={}) {
        mo.RH(t),
        mo.zt(i),
        mo.zt(e),
        mo.Ge(s),
        mo.zt(n),
        mo.J1(r);
        let h = null;
        if (n ? (h = new Blob(t,{
            type: e
        }),
        h.name = i,
        h.lastModified = s,
        h.path = n) : h = new File(t,i,{
            type: e,
            lastModified: s
        }),
        r) {
            const t = Object.entries(r);
            if (t.length) {
                h.c3Props = {};
                for (const [i,e] of t)
                    h.c3Props[i] = e
            }
        }
        return h
    }
    ,
    mo.Xii = function(t, i={}) {
        mo.M4(t),
        mo.J1(i);
        const e = Object.entries(i);
        if (e.length) {
            t.c3Props = {};
            for (const [i,s] of e)
                t.c3Props[i] = s
        }
        return t
    }
    ,
    mo.Yii = function(t) {
        return mo.kti(t, FileList, Array),
        new Promise( (i, e) => {
            let s = [];
            for (let i = 0; i < t.length; i++) {
                let n = t[i];
                mo.M4(n),
                s.push(mo.qii(n).catch(t => {
                    t.file = n,
                    e(t)
                }
                ))
            }
            return Promise.all(s).then(i)
        }
        )
    }
    ,
    mo.Jdt = function(t, i, e) {
        if (mo.gL(i),
        mo.iM(e),
        "number" != typeof e && (e = 1),
        i = i || "image/png",
        e = mo.Ne(e, 0, 1),
        t.convertToBlob)
            return t.convertToBlob({
                type: i,
                quality: e
            });
        if (t.toBlob)
            return new Promise(s => t.toBlob(s, i, e));
        throw new Error("could not convert canvas to blob")
    }
    ,
    mo.Jii = function(t, i, e, s, n) {
        mo.ibt(t, "canvas");
        let r = mo.sy(t.width, t.height);
        if (mo.ub(i) && mo.ub(e) && mo.ub(s) && mo.ub(n)) {
            let h = s - i
              , o = n - e;
            r.getContext("2d").drawImage(t, i, e, h, o, 0, 0, h, o)
        } else
            r.getContext("2d").drawImage(t, 0, 0);
        return r
    }
    ,
    mo.sy = function(t=1, i=1) {
        if ("undefined" != typeof document && "function" == typeof document.createElement) {
            const e = document.createElement("canvas");
            return e.width = t,
            e.height = i,
            e
        }
        return new OffscreenCanvas(t,i)
    }
    ;
    let bo = null
      , vo = null
      , So = null;
    function xo() {
        So || (So = new mo.m_(Mo,5)),
        So.qd(),
        bo || (bo = document.createElement("canvas"),
        bo.width = 32,
        bo.height = 32,
        vo = bo.getContext("2d", {
            willReadFrequently: !0
        }))
    }
    function Mo() {
        bo.width = 32,
        bo.height = 32
    }
    function Eo(t) {
        mo.mti(t),
        xo(),
        bo.width = t.width,
        bo.height = t.height,
        vo.drawImage(t, 0, 0)
    }
    function Co(t, i, e, s, n) {
        let r, h;
        mo.mti(t),
        mo.Ge(i),
        n = !!n,
        self.assert(i >= 1, "step count must be greater or equal to 1"),
        i % 2 != 0 ? (r = e.canvas,
        h = e) : (r = s.canvas,
        h = s);
        let o = Math.floor(.5 * t.width)
          , a = Math.floor(.5 * t.height);
        return 0 === o && (o = 1),
        0 === a && (a = 1),
        r.width = o,
        r.height = a,
        h.save(),
        h.scale(.5, .5),
        h.imageSmoothingEnabled = n,
        h.drawImage(t, 0, 0),
        h.restore(),
        n && Go(h, o, a, .1),
        r
    }
    mo.uii( () => bo ? bo.width * bo.height * 4 : 0),
    mo.bS = async function(t, i) {
        mo.U(t, Blob);
        let e = URL.createObjectURL(t);
        try {
            const t = await mo.$ii(e);
            return URL.revokeObjectURL(e),
            e = "",
            i && "function" == typeof t.decode && await t.decode(),
            t
        } finally {
            e && URL.revokeObjectURL(e)
        }
    }
    ,
    mo.b4 = function(t) {
        return mo.U(t, Blob),
        mo.QL.O9t ? createImageBitmap(t, {
            premultiplyAlpha: "none"
        }) : mo.QL.ImageBitmap ? createImageBitmap(t) : mo.bS(t, !0)
    }
    ,
    mo.Zii = function(t) {
        mo.mti(t);
        const i = mo.sy(4, 4).getContext("2d", {
            willReadFrequently: !0
        });
        i.drawImage(t, 0, 0);
        try {
            i.getImageData(0, 0, 1, 1)
        } catch (t) {
            return !0
        }
    }
    ,
    mo.Ist = function(t) {
        return mo.U(t, Blob),
        "function" == typeof t.text ? t.text() : new Promise( (i, e) => {
            let s = new FileReader;
            s.onload = t => i(t.target.result),
            s.onerror = t => e(t),
            s.readAsText(t)
        }
        )
    }
    ,
    mo.Qii = function(t) {
        return mo.U(t, Blob),
        mo.Ist(t).then(mo.Yvt)
    }
    ,
    mo.tei = function(t, i) {
        let e = i ? JSON.stringify(t, null, 4) : JSON.stringify(t);
        return new Blob([e],{
            type: "application/json"
        })
    }
    ,
    mo.iei = function(t) {
        return mo.U(t, ImageBitmap),
        Eo(t),
        vo.getImageData(0, 0, t.width, t.height)
    }
    ,
    mo.eei = function(t) {
        mo.mti(t),
        Eo(t);
        let i = vo.getImageData(0, 0, t.width, t.height);
        return bo.width = 1,
        bo.height = 1,
        i
    }
    ,
    mo.Vii = function(t, i, e) {
        return mo.mti(t),
        mo.gL(i),
        mo.iM(e),
        Eo(t),
        mo.Jdt(bo, i, e)
    }
    ,
    mo.sei = function(t, i, e) {
        return mo.mti(t),
        mo.gL(i),
        mo.iM(e),
        Eo(t),
        bo.toDataURL(i || "image/png", e)
    }
    ,
    mo.nei = function(t, i=!1) {
        return mo.U(t, Blob),
        i = !!i,
        mo.QL.O9t && !i ? createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then(mo.iei) : mo.QL.ImageBitmap && !i ? createImageBitmap(t).then(mo.iei) : mo.bS(t, !0).then(t => mo.rei(t))
    }
    ,
    mo.hei = function(t) {
        return mo.U(t, Image),
        Eo(t),
        vo.getImageData(0, 0, t.width, t.height)
    }
    ,
    mo.rei = function(t) {
        return mo.QL.O9t ? (mo.eI(t, Image, ImageBitmap),
        createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then(mo.iei)) : mo.QL.ImageBitmap ? (mo.eI(t, Image, ImageBitmap),
        createImageBitmap(t).then(mo.iei)) : (mo.U(t, Image),
        mo.lre( () => mo.hei(t)))
    }
    ,
    mo.oei = function(t, i, e) {
        return mo.U(t, ImageData),
        mo.gL(i),
        mo.iM(e),
        mo.QL.O9t ? createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then(t => mo.Vii(t, i, e)) : mo.QL.ImageBitmap ? createImageBitmap(t).then(t => mo.Vii(t, i, e)) : mo.lre( () => (xo(),
        bo.width = t.width,
        bo.height = t.height,
        vo.putImageData(t, 0, 0),
        mo.Jdt(bo, i, e)))
    }
    ,
    mo.aei = function(t, i, e) {
        return mo.U(t, ImageData),
        mo.gL(i),
        mo.iM(e),
        "number" != typeof e && (e = 1),
        i = i || "image/png",
        e = mo.Ne(e, 0, 1),
        xo(),
        bo.width = t.width,
        bo.height = t.height,
        vo.putImageData(t, 0, 0),
        bo.toDataURL(i, e)
    }
    ,
    mo.lei = function(t, i, e, s="columns") {
        if (mo.mti(t),
        mo.Ge(i),
        mo.Ge(e),
        mo.gL(s),
        "columns" != s && "rows" != s)
            throw new Error("unexpected slicing mode. Supported values are 'columns' and 'rows'.");
        xo(),
        bo.width = t.width,
        bo.height = t.height,
        vo.drawImage(t, 0, 0);
        let n = Math.floor(t.width / i)
          , r = Math.floor(t.height / e)
          , h = []
          , o = 0
          , a = 0;
        if ("columns" === s)
            for (o = 0; o < i; o++)
                for (a = 0; a < e; a++)
                    h.push(vo.getImageData(o * n, a * r, n, r));
        if ("rows" === s)
            for (a = 0; a < e; a++)
                for (o = 0; o < i; o++)
                    h.push(vo.getImageData(o * n, a * r, n, r));
        return h
    }
    ;
    let _o = null
      , To = null;
    function Io(t, i, e, s) {
        mo.mti(t),
        mo.Ge(i),
        mo.Ge(e),
        s = !!s;
        let n = t;
        const r = n.width
          , h = n.height;
        let o = 1
          , a = r > h ? r : h;
        const l = r > h ? i : e;
        for (; a > l; ) {
            if (.5 * a < l)
                return n;
            a *= .5,
            1 === o ? _o || (_o = mo.sy().getContext("2d")) : 2 === o && (To || (To = mo.sy().getContext("2d"))),
            n = Co(n, o, _o, To, s),
            o++
        }
        return n
    }
    function Po(t, i, e, s, n, r) {
        for (let h = s - 1; h >= 0; --h)
            for (let o = e - 1; o >= 0; --o) {
                let a = h
                  , l = o
                  , u = 4 * (h * e + o)
                  , c = 0
                  , d = 0
                  , f = 0;
                for (let i = 0; i < 3; i++)
                    for (let n = 0; n < 3; n++) {
                        const h = a + i - 1
                          , o = l + n - 1;
                        if (h >= 0 && h < s && o >= 0 && o < e) {
                            const s = 4 * (h * e + o)
                              , a = r[3 * i + n];
                            c += t[s] * a,
                            d += t[s + 1] * a,
                            f += t[s + 2] * a
                        }
                    }
                const p = u + 1
                  , m = u + 2
                  , w = u + 3
                  , g = 1 - n;
                0 === o || o === e - 1 || 0 === h || h === s - 1 ? (i[u] = t[u],
                i[p] = t[p],
                i[m] = t[m],
                i[w] = t[w]) : (i[u] = c * n + t[u] * g,
                i[p] = d * n + t[p] * g,
                i[m] = f * n + t[m] * g,
                i[w] = t[w])
            }
    }
    function Go(t, i, e, s) {
        try {
            const n = [0, -1, 0, -1, 5, -1, 0, -1, 0]
              , r = t.createImageData(i, e)
              , h = r.data;
            Po(t.getImageData(0, 0, i, e).data, h, i, e, s, n),
            t.putImageData(r, 0, 0)
        } catch (t) {
            console.log(t)
        }
    }
    function Ao(t, i, e, s, n, r, h) {
        if (i.width > e || i.height > s)
            if ((i.width / 2 < e || i.height / 2 < s) && (n = "low"),
            "high" === n) {
                const n = Io(i, e, s, r);
                t.save(),
                t.imageSmoothingEnabled = r,
                t.drawImage(n, 0, 0, e, s),
                t.restore(),
                r && Go(t, e, s, .1),
                _o && (_o.canvas.width = 1,
                _o.canvas.height = 1),
                To && (To.canvas.width = 1,
                To.canvas.height = 1)
            } else {
                if ("low" !== n)
                    throw new Error(`unexpected scale quality "${n}". Valid values are "low" and "high"`);
                t.save(),
                t.imageSmoothingEnabled = r,
                t.drawImage(i, 0, 0, e, s),
                t.restore(),
                h.quality && "high" !== h.quality || r && Go(t, e, s, .1)
            }
        else
            t.save(),
            t.imageSmoothingEnabled = r,
            t.drawImage(i, 0, 0, e, s),
            t.restore(),
            "high" === n && r && Go(t, e, s, .1);
        return t.canvas
    }
    function Ro(t, i, e, s, n, r, h) {
        let o = s * i + e
          , a = o + r * i;
        for (let e = o; e < a; e += i)
            t.fill(h, e, e + n)
    }
    function ko(t, i, e, s) {
        return t[s * i + e]
    }
    mo.y4 = function(t, i, e, s={}) {
        if (mo.gti(t),
        mo.Ge(i),
        mo.Ge(e),
        i < 0 || e < 0)
            throw new Error("invalid target size");
        if (mo.Bm(t, ImageData)) {
            const i = mo.sy(t.width, t.height);
            i.getContext("2d").putImageData(t, 0, 0),
            t = i
        }
        const n = s.context ? s.context : mo.sy().getContext("2d")
          , r = !s.hasOwnProperty("smooth") || !!s.smooth
          , h = !!s.hasOwnProperty("async") && !!s.async;
        let o = s.quality ? s.quality : "high";
        return "high" !== o && "medium" !== o && "low" !== o && (o = "high"),
        n.canvas.width = i,
        n.canvas.height = e,
        0 === i || 0 === e ? h ? Promise.resolve(n.canvas) : n.canvas : t.width === i && t.height === e ? (n.drawImage(t, 0, 0),
        h ? Promise.resolve(n.canvas) : n.canvas) : h && mo.QL.ImageBitmap && mo.QL.D9t ? (r || (o = "pixelated"),
        createImageBitmap(t, {
            resizeWidth: i,
            resizeHeight: e,
            resizeQuality: o
        }).then(t => (n.drawImage(t, 0, 0),
        n.canvas))) : h ? mo.lre( () => Ao(n, t, i, e, o, r, s)) : Ao(n, t, i, e, o, r, s)
    }
    ,
    mo.uei = function(t, i, e, s, n, r, h, o, a, l) {
        let u = o * s + h
          , c = u + l * s;
        for (let h = u, o = r * i + n; h < c; h += s,
        o += i)
            e.set(t.subarray(o, o + a), h)
    }
    ,
    mo.cei = function(t, i, e, s, n, r, h, o, a, l) {
        let u = r * i + n;
        const c = u + l * i;
        let d = o * s + h + l - 1;
        for (; u < c; u += i,
        --d) {
            const i = u + a;
            let n = d;
            for (let r = u; r < i; ++r,
            n += s)
                e[n] = t[r]
        }
    }
    ,
    mo.dei = function(t, i, e, s, n, r, h) {
        let o = s * i + e
          , a = r * i + n;
        t.copyWithin(a, o, o + h)
    }
    ,
    mo.fei = function(t, i, e, s, n, r, h) {
        let o = r * i + n
          , a = o + h * i;
        for (let n = o, r = s * i + e; n < a; n += i,
        r += i)
            t[n] = t[r]
    }
    ,
    mo.pei = function(t, i, e, s, n) {
        mo.U(t, ImageData),
        mo.Ge(i),
        mo.Ge(e),
        mo.Ge(s),
        mo.Ge(n),
        i |= 0,
        e |= 0,
        s |= 0,
        n |= 0;
        let r = 0 | t.width
          , h = 0 | t.height;
        if (i < 0 || i >= r || e < 0 || e >= h || i + s > r || e + n > h)
            throw new Error("invalid sub image");
        let o = new ImageData(s,n)
          , a = new Uint32Array(t.data.buffer)
          , l = new Uint32Array(o.data.buffer);
        return mo.uei(a, r, l, s, i, e, 0, 0, s, n),
        o
    }
    ,
    mo.mei = function(t, i, e, s) {
        mo.U(t, ImageData),
        mo.U(i, ImageData),
        mo.Ge(e),
        mo.Ge(s),
        e |= 0,
        s |= 0;
        let n = 0 | t.width
          , r = 0 | t.height
          , h = 0 | i.width
          , o = 0 | i.height;
        if (e < 0 || s < 0 || e > n - h || s > r - o)
            throw new Error("invalid sub image");
        let a = new Uint32Array(i.data.buffer)
          , l = new Uint32Array(t.data.buffer);
        mo.uei(a, h, l, n, 0, 0, e, s, h, o)
    }
    ,
    mo.wei = function(t, i, e, s, n) {
        mo.U(t, ImageData),
        mo.Ge(i),
        mo.Ge(e),
        mo.Ge(s),
        mo.Ge(n),
        i |= 0,
        e |= 0,
        s |= 0,
        n |= 0;
        let r = 0 | t.width
          , h = 0 | t.height;
        if (i < 0 || i >= r || e < 0 || e >= h || i + s > r || e + n > h)
            throw new Error("invalid sub image");
        Ro(new Uint32Array(t.data.buffer), r, i, e, s, n, 0)
    }
    ,
    mo.gei = function(t, i, e, s, n, r, h, o, a, l, u) {
        if (mo.U(t, Uint32Array),
        mo.Ge(i),
        mo.Ge(e),
        mo.Ge(s),
        mo.Ge(n),
        mo.Ge(r),
        mo.Ge(h),
        mo.Ge(o),
        mo.Ge(a),
        mo.Ge(l),
        mo.Ge(u),
        r > i || l > i || h > e || u > e)
            throw new Error("rectangle larger than destination");
        if (r > l || h > u)
            throw new Error("inner size larger than outer size");
        if (s < o || n < a || s + r > o + l || n + h > a + u)
            throw new Error("inner rectange not inside outer rectangle");
        if (r === l && h === u)
            return;
        let c = s + r
          , d = c - 1
          , f = o + l
          , p = n + h
          , m = p - 1
          , w = a + u
          , g = ko(t, i, s, n);
        Ro(t, i, o, a, s - o, n - a, g);
        for (let e = a; e < n; ++e)
            mo.dei(t, i, s, n, s, e, r);
        g = ko(t, i, d, n),
        Ro(t, i, c, a, f - c, n - a, g);
        for (let e = o; e < s; ++e)
            mo.fei(t, i, s, n, e, n, h);
        for (let e = c; e < f; ++e)
            mo.fei(t, i, d, n, e, n, h);
        g = ko(t, i, s, m),
        Ro(t, i, o, p, s - o, w - p, g);
        for (let e = p; e < w; ++e)
            mo.dei(t, i, s, m, s, e, r);
        g = ko(t, i, d, m),
        Ro(t, i, c, p, f - c, w - p, g)
    }
    ,
    mo.yei = function(t, i, e=0, s=-1) {
        mo.U(t, ArrayBuffer),
        mo.gL(i),
        mo.Ge(e),
        mo.Ge(s),
        s < 0 && (s = t.byteLength);
        let n = new Uint8Array(t,e,s);
        return mo.bei(n, i)
    }
    ,
    mo.bei = function(t, i) {
        return mo.Gti(t),
        mo.gL(i),
        new TextDecoder(i || "utf-8").decode(t)
    }
    ,
    mo.vei = function(t) {
        return mo.zt(t),
        new TextEncoder("utf-8").encode(t).buffer
    }
    ,
    mo.Sei = function(t, i, e) {
        mo.U(t, ArrayBuffer),
        mo.nu(i),
        mo.Ck(e);
        let s = 0
          , n = t.byteLength
          , r = [];
        for (; s < n; )
            e = Math.min(n - s, e),
            r.push(new i(t,s,e)),
            s += e;
        return r
    }
    ;
    const Oo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    mo.xei = function(t) {
        const i = i => i < e ? t[i] : (n++,
        0)
          , e = t.length
          , s = [];
        let n = 0
          , r = 0;
        for (; r < e; ) {
            const t = (i(r++) << 16) + (i(r++) << 8) + i(r++);
            s.push(Oo[t >>> 18 & 63], Oo[t >>> 12 & 63], Oo[t >>> 6 & 63], Oo[63 & t])
        }
        for (r = s.length - n; r < s.length; )
            s[r++] = "=";
        return s.join("")
    }
    ,
    mo.Mei = function(t) {
        const i = t.indexOf("=")
          , e = t.length
          , s = e >> 2 << 2
          , n = e - s
          , r = i > -1 ? e - i : 0;
        if (r > 2)
            throw new Error("Invalid padding");
        let h = e;
        s === i ? h = s - r : 0 === n && i > -1 && (h -= r);
        const o = 3 * h >> 2
          , a = new Uint8Array(o);
        let l = 0
          , u = 0;
        const c = () => {
            if (l >= h)
                return 0;
            const i = t.charCodeAt(l++);
            if (i > 64 && i < 91)
                return i - 65;
            if (i > 96 && i < 123)
                return i - 71;
            if (i > 47 && i < 58)
                return i + 4;
            if (43 === i)
                return 62;
            if (47 === i)
                return 63;
            if (61 === i)
                return 0;
            throw new Error("Invalid character at column " + (l - 1))
        }
          , d = t => u < o && (a[u++] = t);
        for (; u < o; ) {
            const t = (c() << 18) + (c() << 12) + (c() << 6) + c();
            d(t >>> 16 & 255),
            d(t >>> 8 & 255),
            d(255 & t)
        }
        return a
    }
}
{
    const Do = self.t
      , Fo = new Map;
    let Lo;
    function Bo(t, i) {
        let e = Do.getType(t)
          , s = Do.getType(i);
        return "null" === e || "null" === s || "undefined" !== e && "undefined" !== s && e === s
    }
    Do.Eei = function(t, i) {
        console.log(`%c${t}`, `font-weight: bold; color:${i}`)
    }
    ,
    Do.Cei = function(t, ...i) {
        Fo.has(t) || Fo.set(t, -1),
        -1 === Fo.get(t) && Fo.set(t, requestAnimationFrame( () => {
            console.log(`%c${t}`, "font-weight: bold", ...i),
            Fo.set(t, -1)
        }
        ))
    }
    ,
    Do._ei = function(t) {
        performance.mark(t),
        Lo || (Lo = new Map),
        Lo.has(t) || Lo.set(t, {
            IV: 0,
            total: 0,
            Tei: 0,
            Iei: 1,
            toString: function() {
                return `${t} :: current => ${this.IV.toPrecision(3)} :: average => ${this.Tei.toPrecision(3)} :: calls => ${this.Iei}`
            }
        })
    }
    ,
    Do.Pei = function(t) {
        performance.measure(`measure-${t}`, t);
        const i = performance.getEntriesByName(`measure-${t}`)[0]
          , e = Lo.get(t);
        e.IV = i.duration,
        e.total += e.IV,
        e.Tei = e.total / e.Iei,
        console.log(e.toString()),
        e.Iei++,
        performance.clearMarks(t),
        performance.clearMeasures(`measure-${t}`)
    }
    ,
    Do.P9t = function() {
        return (new Error).stack
    }
    ,
    Do.Gei = function() {}
    ,
    Do.cast = function(t, i) {
        return t && t instanceof i ? t : null
    }
    ,
    Do.getName = function(t) {
        return void 0 === t ? "undefined" : null === t ? "null" : "boolean" == typeof t ? "<boolean>" : Do.q9t(t) ? "<number>" : Do.K9(t) ? "<string>" : Do.B9(t) ? "<array>" : "symbol" == typeof t ? "<" + t.toString() + ">" : Do.w9(t) ? t.name && "Function" !== t.name ? t.name : "<anonymous function>" : "object" == typeof t ? t.constructor && t.constructor.name && "Object" !== t.constructor.name ? t.constructor.name : "<anonymous object>" : "<unknown>"
    }
    ,
    Do.getType = function(t) {
        return null === t ? "null" : Array.isArray(t) ? "array" : typeof t
    }
    ,
    Do.range = function*(t, i) {
        if (!isFinite(Math.abs(t - i)))
            throw new Error("Invalid parameters");
        if (t > i)
            for (let e = t - 1; e >= i; e--)
                yield e;
        else
            for (let e = t; e < i; e++)
                yield e
    }
    ;
    let Uo = new Map
      , No = new Map
      , jo = new WeakMap
      , $o = new WeakMap;
    Do.Aei = {};
    const zo = new Set(["then", "splice"]);
    function Vo(t) {
        (() => {})("[Defence] " + t + " @", Do.P9t())
    }
    Do.Aei.get = function(t, i) {
        return i in t || "symbol" == typeof i || zo.has(i) || Vo(`Accessed missing property '${i}' from defended object '${Do.getName(t)}', returning undefined`),
        $o.has(t) && "symbol" != typeof i && !zo.has(i) && Vo(`Accessed property '${i}' on a released object '${Do.getName(t)}'\nObject was originally released at: ${$o.get(t)})\nCall stack at access: `),
        t[i]
    }
    ,
    Do.Aei.set = function(t, i, e) {
        return i in t || Uo.has(t) || Vo(`Set non-existent property '${i}' to '${e}' on defended object '${Do.getName(t)}'`),
        Bo(t[i], e) || Uo.has(t) || Vo(`Set '${Do.getType(t[i])}' property '${i}' to type '${Do.getType(e)}' on defended object '${Do.getName(t)}'`),
        $o.has(t) && Vo(`Set property '${i}' on a released object '${Do.getName(t)}'\nObject was originally released at: ${$o.get(t)})\nCall stack at access: `),
        t[i] = e,
        !0
    }
    ,
    Do.Aei.deleteProperty = function(t, i) {
        throw new ReferenceError(`Cannot delete property '${i}' from defended object '${Do.getName(t)}'`)
    }
    ,
    Do.Aei.defineProperty = function(t, i, e) {
        throw new ReferenceError(`Cannot define property '${i}' on defended object '${Do.getName(t)}'`)
    }
    ,
    Do.Aei.enumerate = function(t) {
        throw new ReferenceError(`Cannot enumerate defended object '${Do.getName(t)}'`)
    }
    ;
    let Wo = -1;
    function Ho() {
        if (Wo = -1,
        Uo.size > 0 || No.size > 0) {
            let t = [...new Set([...Uo.keys()].map(t => Do.getName(t)))].join(",");
            (() => {})(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${t}`),
            Uo.clear(),
            No.clear()
        }
    }
    Do.Me = class {
        constructor() {
            if (!Do.J8t || !Do.QL.N9t)
                return;
            let t = new.target
              , i = Object.create(t.prototype)
              , e = new Proxy(i,Do.Aei);
            return Uo.set(i, e),
            No.set(e, i),
            jo.set(e, i),
            -1 === Wo && (Wo = requestAnimationFrame(Ho)),
            e
        }
    }
    ,
    Do.Rei = function(t) {
        if (Do.IL(t),
        Do.J8t && Do.QL.N9t && t instanceof Do.Me) {
            if (!No.has(t))
                return t;
            let i = No.get(t);
            return No.delete(t),
            Uo.delete(i),
            t
        }
        return Do.$M ? Object.seal(t) : t
    }
    ,
    Do.v = function(t, ...i) {
        let e;
        Do.nu(t);
        try {
            e = new t(...i)
        } catch (t) {
            throw No.clear(),
            Uo.clear(),
            t
        }
        return Do.J8t && Xo(t, e),
        Do.Rei(e)
    }
    ,
    Do.he = function(t) {
        let i = jo.get(t);
        i && $o.set(i, Do.P9t())
    }
    ,
    Do.gn = function(t) {
        let i = jo.get(t);
        return !!i && !!$o.get(i)
    }
    ;
    let Ko = new Map;
    function qo(t) {
        let i = new Set;
        for (let e in t)
            i.add(e);
        return i
    }
    function Xo(t, i) {
        let e = qo(i)
          , s = Ko.get(t);
        if (s) {
            let i = [];
            for (let t of s.values())
                e.has(t) ? e.delete(t) : i.push(t);
            Do.Oo(i, [...e]),
            i.length && (() => {})(`[Defence] '${Do.getName(t)}' constructor creates inconsistent properties: ${i.join(", ")}`)
        } else
            Ko.set(t, e)
    }
    Do.kei = class {
        constructor(t) {
            this.Ftt = "",
            t && this.start(t)
        }
        start(t) {
            Do.$5t && (this.Ftt = t,
            performance.mark(this.Ftt + "-Start"))
        }
        end() {
            Do.$5t && (performance.mark(this.Ftt + "-End"),
            performance.measure(this.Ftt, this.Ftt + "-Start", this.Ftt + "-End"))
        }
        next(t) {
            Do.$5t && (this.end(),
            this.Ftt = t,
            performance.mark(this.Ftt + "-Start"))
        }
    }
}
{
    const Yo = self.t;
    Yo.Oei = function(t) {
        Yo.U(t, self.e0);
        const i = self.app.Dei();
        return i && t.jLt() ? Yo.zii(t.lS()).then(t => new Promise(e => {
            i.decodeAudioData(t, t => {
                e(t.duration)
            }
            , t => {
                e(-1)
            }
            )
        }
        )) : Promise.resolve(-1)
    }
}
{
    const Jo = self.t
      , Zo = 2 * Math.PI
      , Qo = Math.PI / 180
      , ta = 180 / Math.PI;
    Jo.wrap = function(t, i, e) {
        t = Math.floor(t),
        i = Math.floor(i);
        const s = (e = Math.floor(e)) - i;
        if (0 === s)
            return e;
        if (t < i) {
            const n = e - (i - t) % s;
            return n === e ? 0 : n
        }
        return i + (t - i) % s
    }
    ,
    Jo.WOt = function(t, i, e, s, n) {
        const r = e - i;
        if (0 === r && 0 === s)
            return t;
        return (t - i) * (n - s) / r + s
    }
    ,
    Jo.normalize = function(t, i, e) {
        return i - e === 0 ? 1 : (t - i) / (e - i)
    }
    ,
    Jo.Ne = function(t, i, e) {
        return t < i ? i : t > e ? e : t
    }
    ,
    Jo.ut = function(t) {
        return (t %= Zo) < 0 && (t += Zo),
        t
    }
    ,
    Jo.ct = function(t) {
        return t * Qo
    }
    ,
    Jo.pi = function(t) {
        return t * ta
    }
    ,
    Jo.Fei = function(t, i) {
        return Math.sqrt(t * t + i * i)
    }
    ,
    Jo.Vf = function(t, i, e) {
        return Math.sqrt(t * t + i * i + e * e)
    }
    ,
    Jo.di = function(t, i, e, s) {
        return Jo.Fei(e - t, s - i)
    }
    ,
    Jo.eK = function(t, i, e, s) {
        const n = e - t
          , r = s - i;
        return n * n + r * r
    }
    ,
    Jo.fi = function(t, i, e, s) {
        return Math.atan2(s - i, e - t)
    }
    ,
    Jo.xi = function(t, i) {
        if (t === i)
            return 0;
        let e = Math.sin(t)
          , s = Math.cos(t)
          , n = e * Math.sin(i) + s * Math.cos(i);
        return n >= 1 ? 0 : n <= -1 ? Math.PI : Math.acos(n)
    }
    ,
    Jo.Ci = function(t, i, e) {
        let s = Math.sin(t)
          , n = Math.cos(t)
          , r = Math.sin(i)
          , h = Math.cos(i);
        return Math.acos(s * r + n * h) > e ? n * r - s * h > 0 ? Jo.ut(t + e) : Jo.ut(t - e) : Jo.ut(i)
    }
    ,
    Jo.Lei = function(t, i) {
        let e = Math.sin(t);
        return Math.cos(t) * Math.sin(i) - e * Math.cos(i) <= 0
    }
    ,
    Jo.Si = function(t, i, e, s=0) {
        let n = Jo.xi(t, i);
        const r = Zo * s;
        return Jo.Lei(i, t) ? Jo.ut(t + (n + r) * e) : Jo.ut(t - (n + r) * e)
    }
    ,
    Jo.Bei = function(t, i, e, s=0) {
        const n = Jo.xi(t, i)
          , r = Zo * s;
        return Jo.Lei(i, t) ? Jo.ut(t + (n + r) * e) : Jo.ut(t + (Zo - n + r) * e)
    }
    ,
    Jo.Uei = function(t, i, e, s=0) {
        const n = Jo.xi(t, i)
          , r = Zo * s;
        return Jo.Lei(i, t) ? Jo.ut(t - (-Zo + n - r) * e) : Jo.ut(t - (n + r) * e)
    }
    ,
    Jo.Nei = function(t, i) {
        const e = Jo.xi(t, i);
        return Jo.Lei(t, i) ? Jo.ut(i - e) : Jo.ut(i + e)
    }
    ,
    Jo.mi = function(t, i, e) {
        return t + e * (i - t)
    }
    ,
    Jo.gi = function(t, i, e) {
        return t === i ? 0 : (e - t) / (i - t)
    }
    ,
    Jo.Em = function(t, i, e, s, n) {
        return Jo.mi(s, n, Jo.gi(t, i, e))
    }
    ,
    Jo.wi = function(t, i, e, s) {
        return Jo.mi(Jo.mi(t, i, s), Jo.mi(i, e, s), s)
    }
    ,
    Jo.bi = function(t, i, e, s, n) {
        return Jo.mi(Jo.wi(t, i, e, n), Jo.wi(i, e, s, n), n)
    }
    ,
    Jo.yi = function(t, i, e) {
        return (t + i + (t - i) * Math.cos(e * Math.PI)) / 2
    }
    ,
    Jo.jei = function(t) {
        return t > 0 && !(t - 1 & t)
    }
    ,
    Jo.na = function(t) {
        --t;
        for (let i = 1; i < 32; i <<= 1)
            t |= t >> i;
        return t + 1
    }
    ,
    Jo.bT = function(t, i) {
        return Math.round(t * i) / i
    }
    ,
    Jo.$ei = function(t, i) {
        return Math.floor(t * i) / i
    }
    ,
    Jo.kz = function(t, i) {
        i = Math.max(Math.floor(i), 0);
        const e = Math.pow(10, i);
        return Math.round(t * e) / e
    }
    ,
    Jo.zei = function(t) {
        return Math.floor(t) !== t && t.toString().split(".")[1].length || 0
    }
    ,
    Jo.toFixed = function(t, i) {
        Jo.Ck(t),
        Jo.Ge(i);
        let e = t.toFixed(i)
          , s = e.length - 1;
        for (; s >= 0 && "0" === e.charAt(s); --s)
            ;
        return s >= 0 && "." === e.charAt(s) && --s,
        s < 0 ? e : e.substr(0, s + 1)
    }
    ,
    Jo.Oi = function(t, i, e) {
        return Jo.Ne(t, 0, 255) | Jo.Ne(i, 0, 255) << 8 | Jo.Ne(e, 0, 255) << 16
    }
    ;
    const ia = 1024
      , ea = 1023
      , sa = 16384
      , na = 8191
      , ra = -8192;
    Jo.Vei = function(t, i, e, s) {
        return t = Jo.Ne(Math.floor(1024 * t), ra, na),
        i = Jo.Ne(Math.floor(1024 * i), ra, na),
        e = Jo.Ne(Math.floor(1024 * e), ra, na),
        s = Jo.Ne(Math.floor(s * ea), 0, ea),
        t < 0 && (t += sa),
        i < 0 && (i += sa),
        e < 0 && (e += sa),
        -(t * sa * sa * ia + i * sa * ia + e * ia + s)
    }
    ,
    Jo.Ti = function(t, i, e) {
        return Jo.Vei(t, i, e, 1)
    }
    ,
    Jo.Wei = function(t) {
        if (t >= 0)
            return (255 & t) / 255;
        {
            let i = Math.floor(-t / (sa * sa * ia));
            return i > na && (i -= sa),
            i / 1024
        }
    }
    ,
    Jo.Hei = function(t) {
        if (t >= 0)
            return ((65280 & t) >> 8) / 255;
        {
            let i = Math.floor(-t % (sa * sa * ia) / (sa * ia));
            return i > na && (i -= sa),
            i / 1024
        }
    }
    ,
    Jo.Kei = function(t) {
        if (t >= 0)
            return ((16711680 & t) >> 16) / 255;
        {
            let i = Math.floor(-t % (sa * ia) / ia);
            return i > na && (i -= sa),
            i / 1024
        }
    }
    ,
    Jo.qei = function(t) {
        if (0 === (i = t) && 1 / i < 0)
            return 0;
        if (t >= 0)
            return 1;
        return Math.floor(-t % ia) / ea;
        var i
    }
    ,
    Jo.Xei = function(t, i) {
        for (Jo.Ge(t),
        Jo.Ge(i),
        t = Math.floor(t),
        i = Math.floor(i); 0 !== i; ) {
            let e = i;
            i = t % i,
            t = e
        }
        return t
    }
    ;
    const ha = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
    Jo.Cse = function(t, i) {
        if (Jo.Ge(t),
        Jo.Ge(i),
        (t = Math.floor(t)) === (i = Math.floor(i)))
            return [1, 1];
        for (let e of ha) {
            let s = t / e[0] * e[1];
            if (Math.abs(i - s) < 1)
                return e.slice(0);
            if (s = t / e[1] * e[0],
            Math.abs(i - s) < 1)
                return [e[1], e[0]]
        }
        let e = Jo.Xei(t, i);
        return [t / e, i / e]
    }
    ,
    Jo.Yei = function(t, i, e, s, n, r, h, o) {
        const a = Math.min(t, e)
          , l = Math.max(t, e)
          , u = Math.min(n, h)
          , c = Math.max(n, h);
        if (l < u || a > c)
            return !1;
        const d = Math.min(i, s)
          , f = Math.max(i, s)
          , p = Math.min(r, o)
          , m = Math.max(r, o);
        if (f < p || d > m)
            return !1;
        const w = n - t + h - e
          , g = r - i + o - s
          , y = e - t
          , b = s - i
          , v = h - n
          , S = o - r
          , x = Math.abs(b * v - S * y)
          , M = v * g - S * w;
        if (Math.abs(M) > x)
            return !1;
        const E = y * g - b * w;
        return Math.abs(E) <= x
    }
    ,
    Jo.Jei = function(t, i, e, s, n, r, h, o, a, l, u, c) {
        const d = Math.min(a, u)
          , f = Math.max(a, u);
        if (r < d || n > f)
            return !1;
        const p = Math.min(l, c)
          , m = Math.max(l, c);
        if (o < p || h > m)
            return !1;
        const w = a - t + u - e
          , g = l - i + c - s
          , y = e - t
          , b = s - i
          , v = u - a
          , S = c - l
          , x = Math.abs(b * v - S * y)
          , M = v * g - S * w;
        if (Math.abs(M) > x)
            return !1;
        const E = y * g - b * w;
        return Math.abs(E) <= x
    }
    ,
    Jo.Zei = function(t, i, e, s, n) {
        const r = Math.min(t, e)
          , h = Math.max(t, e)
          , o = Math.min(i, s)
          , a = Math.max(i, s)
          , l = n.Zn()
          , u = n.tr()
          , c = n.lm()
          , d = n.el()
          , f = n.il()
          , p = n.sl()
          , m = n.Fl()
          , w = n.El();
        return Jo.Jei(t, i, e, s, r, h, o, a, l, u, c, d) || Jo.Jei(t, i, e, s, r, h, o, a, c, d, f, p) || Jo.Jei(t, i, e, s, r, h, o, a, f, p, m, w) || Jo.Jei(t, i, e, s, r, h, o, a, m, w, l, u)
    }
    ,
    Jo.Qei = function(t, i, e, s, n) {
        const r = Math.min(t, e)
          , h = Math.max(t, e)
          , o = Math.min(i, s)
          , a = Math.max(i, s);
        let l = 0;
        for (let u = n.length - 4; l <= u; l += 2)
            if (Jo.Jei(t, i, e, s, r, h, o, a, n[l], n[l + 1], n[l + 2], n[l + 3]))
                return !0;
        return Jo.Jei(t, i, e, s, r, h, o, a, n[l], n[l + 1], n[0], n[1])
    }
    ;
    const oa = 2
      , aa = 1e-6;
    Jo.tsi = function(t, i, e, s, n, r, h, o) {
        const a = e - t
          , l = o - r
          , u = a * l - (s - i) * (h - n);
        if (0 === u)
            return oa;
        const c = ((i - s) * (h - t) + a * (o - i)) / u;
        return 0 < c && c < 1 + aa ? (l * (h - t) + (n - h) * (o - i)) / u : oa
    }
    ,
    Jo.isi = function(t, i, e, s, n, r, h, o, a) {
        const l = (h - n) * a
          , u = (o - r) * a;
        return Jo.tsi(t, i, e, s, n - l, r - u, h + l, o + u)
    }
    ,
    Jo.esi = function(t, i, e, s, n, r, h, o) {
        const a = n - e
          , l = r - s
          , u = h - e
          , c = o - s
          , d = t - e
          , f = i - s
          , p = a * a + l * l
          , m = a * u + l * c
          , w = a * d + l * f
          , g = u * u + c * c
          , y = u * d + c * f
          , b = 1 / (p * g - m * m)
          , v = (g * w - m * y) * b
          , S = (p * y - m * w) * b;
        return v >= 0 && S >= 0 && v + S <= 1
    }
    ,
    Jo.ssi = function(t, i, e, s, n, r, h, o) {
        const a = n - e
          , l = r - s
          , u = h - e
          , c = o - s
          , d = t - e
          , f = i - s
          , p = a * a + l * l
          , m = a * u + l * c
          , w = u * u + c * c
          , g = d * a + f * l
          , y = d * u + f * c
          , b = p * w - m * m
          , v = (w * g - m * y) / b
          , S = (p * y - m * g) / b;
        return [1 - v - S, v, S]
    }
    ,
    Jo.nsi = function(t, i, e, s, n, r, h, o, a, l, u, c) {
        return [t * s + i * h + e * l, t * n + i * o + e * u, t * r + i * a + e * c]
    }
}
{
    const la = self.t;
    la.uX = class {
        constructor(t, i) {
            this.Ec = 0,
            this.zc = 0,
            t instanceof la.uX ? this.Qr(t) : this.set(t || 0, i || 0)
        }
        set(t, i) {
            this.Ec = +t,
            this.zc = +i
        }
        Qr(t) {
            this.Ec = t.Ec,
            this.zc = t.zc
        }
        equals(t) {
            return this.Ec === t.Ec && this.zc === t.zc
        }
        rsi(t, i) {
            return this.Ec === t && this.zc === i
        }
        hsi(t, i) {
            return t[i] === Math.fround(this.Ec) && t[i + 1] === Math.fround(this.zc)
        }
        osi(t) {
            this.Ec = +t
        }
        qX() {
            return this.Ec
        }
        asi(t) {
            this.zc = +t
        }
        QX() {
            return this.zc
        }
        toArray() {
            return [this.Ec, this.zc]
        }
        lsi() {
            return new Float64Array(this.toArray())
        }
        usi(t, i) {
            t[i++] = this.Ec,
            t[i] = this.zc
        }
        offset(t, i) {
            this.Ec += +t,
            this.zc += +i
        }
        scale(t, i) {
            this.Ec *= t,
            this.zc *= i
        }
        xm(t, i) {
            this.Ec /= t,
            this.zc /= i
        }
        round() {
            this.Ec = Math.round(this.Ec),
            this.zc = Math.round(this.zc)
        }
        floor() {
            this.Ec = Math.floor(this.Ec),
            this.zc = Math.floor(this.zc)
        }
        ceil() {
            this.Ec = Math.ceil(this.Ec),
            this.zc = Math.ceil(this.zc)
        }
        angle() {
            return la.fi(0, 0, this.Ec, this.zc)
        }
        dsi() {
            return this.Ec * this.Ec + this.zc * this.zc
        }
        length() {
            return la.Fei(this.Ec, this.zc)
        }
        fsi(t, i) {
            const e = this.Ec * i - this.zc * t;
            this.zc = this.zc * i + this.Ec * t,
            this.Ec = e
        }
        rotate(t) {
            0 !== t && this.fsi(Math.sin(t), Math.cos(t))
        }
        L$(t, i, e) {
            0 === t || i === this.Ec && e === this.zc || (this.Ec -= i,
            this.zc -= e,
            this.fsi(Math.sin(t), Math.cos(t)),
            this.Ec += +i,
            this.zc += +e)
        }
        move(t, i) {
            0 !== i && (this.Ec += Math.cos(t) * i,
            this.zc += Math.sin(t) * i)
        }
        normalize() {
            const t = this.length();
            0 !== t && 1 !== t && (this.Ec /= t,
            this.zc /= t)
        }
        Ne(t, i) {
            this.Ec = la.Ne(this.Ec, t, i),
            this.zc = la.Ne(this.zc, t, i)
        }
        dot(t) {
            return this.Ec * t.Ec + this.zc * t.zc
        }
        reverse() {
            this.Ec = -this.Ec,
            this.zc = -this.zc
        }
        psi() {
            let t = this.Ec;
            return this.Ec = this.zc,
            this.zc = -t,
            this
        }
    }
}
{
    const ua = self.t
      , ca = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i
      , da = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
    function fa(t) {
        return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t
    }
    function pa(t, i, e) {
        return e < 0 && (e += 1),
        e > 1 && (e -= 1),
        e < 1 / 6 ? t + 6 * (i - t) * e : e < .5 ? i : e < 2 / 3 ? t + (i - t) * (2 / 3 - e) * 6 : t
    }
    ua.za = class {
        constructor(t, i, e, s) {
            this._r = NaN,
            this._g = NaN,
            this._b = NaN,
            this._a = NaN,
            this._r = 0,
            this._g = 0,
            this._b = 0,
            this._a = 0,
            t instanceof ua.za ? this.set(t) : this.msi(t || 0, i || 0, e || 0, s || 0)
        }
        wsi(t, i, e) {
            return this._r = +t,
            this._g = +i,
            this._b = +e,
            this.Ne(),
            this
        }
        msi(t, i, e, s) {
            return this._r = +t,
            this._g = +i,
            this._b = +e,
            this._a = +s,
            this.Ne(),
            this
        }
        set(t) {
            return this._r = t._r,
            this._g = t._g,
            this._b = t._b,
            this._a = t._a,
            this
        }
        Qr(t) {
            return this.set(t)
        }
        add(t) {
            this._r += t._r,
            this._g += t._g,
            this._b += t._b,
            this._a += t._a,
            this.Ne()
        }
        gsi(t, i, e, s=0) {
            this._r += +t,
            this._g += +i,
            this._b += +e,
            this._a += +s,
            this.Ne()
        }
        ysi(t) {
            this.bsi(Math.max(this._r, t._r) - Math.min(this._r, t._r)),
            this.vsi(Math.max(this._g, t._g) - Math.min(this._g, t._g)),
            this.Ssi(Math.max(this._b, t._b) - Math.min(this._b, t._b)),
            this.vx(Math.max(this._a, t._a) - Math.min(this._a, t._a)),
            this.Ne()
        }
        Ua(t) {
            this._r = t._r,
            this._g = t._g,
            this._b = t._b
        }
        bsi(t) {
            this._r = ua.Ne(+t, 0, 1)
        }
        xsi() {
            return this._r
        }
        vsi(t) {
            this._g = ua.Ne(+t, 0, 1)
        }
        Msi() {
            return this._g
        }
        Ssi(t) {
            this._b = ua.Ne(+t, 0, 1)
        }
        Esi() {
            return this._b
        }
        vx(t) {
            this._a = ua.Ne(+t, 0, 1)
        }
        Ix() {
            return this._a
        }
        clone() {
            return ua.v(ua.za, this._r, this._g, this._b, this._a)
        }
        toArray() {
            return [this._r, this._g, this._b, this._a]
        }
        lsi() {
            return new Float64Array(this.toArray())
        }
        usi(t, i) {
            t[i++] = this._r,
            t[i++] = this._g,
            t[i++] = this._b,
            t[i] = this._a
        }
        Csi(t, i) {
            const e = this._r
              , s = this._g
              , n = this._b
              , r = this._a;
            for (let h = 0; h < 4; ++h)
                t[i++] = e,
                t[i++] = s,
                t[i++] = n,
                t[i++] = r
        }
        _si(t, i) {
            t[i++] = this._r,
            t[i++] = this._g,
            t[i] = this._b
        }
        equals(t) {
            return this._r === t._r && this._g === t._g && this._b === t._b && this._a === t._a
        }
        wle(t) {
            return this._r === t._r && this._g === t._g && this._b === t._b
        }
        Tsi(t, i, e) {
            return this._r === t && this._g === i && this._b === e
        }
        Isi(t, i, e, s) {
            return this._r === t && this._g === i && this._b === e && this._a === s
        }
        hsi(t, i) {
            return t[i] === Math.fround(this._r) && t[i + 1] === Math.fround(this._g) && t[i + 2] === Math.fround(this._b) && t[i + 3] === Math.fround(this._a)
        }
        Psi(t, i) {
            return t[i] === Math.fround(this._r) && t[i + 1] === Math.fround(this._g) && t[i + 2] === Math.fround(this._b)
        }
        multiply(t) {
            this._r *= t._r,
            this._g *= t._g,
            this._b *= t._b,
            this._a *= t._a
        }
        pu(t) {
            this._r *= t,
            this._g *= t,
            this._b *= t,
            this._a *= t
        }
        Ol() {
            return this._r *= this._a,
            this._g *= this._a,
            this._b *= this._a,
            this
        }
        Gsi() {
            return this._r /= this._a,
            this._g /= this._a,
            this._b /= this._a,
            this
        }
        Ne() {
            return this._r = ua.Ne(this._r, 0, 1),
            this._g = ua.Ne(this._g, 0, 1),
            this._b = ua.Ne(this._b, 0, 1),
            this._a = ua.Ne(this._a, 0, 1),
            this
        }
        Asi(t) {
            this._r = ua.Wei(t),
            this._g = ua.Hei(t),
            this._b = ua.Kei(t),
            this._a = ua.qei(t)
        }
        Rsi(t, i, e) {
            ua.iM(t),
            ua.iM(i),
            ua.iM(e);
            return `rgb(${100 * (ua.ub(t) ? t : this.xsi())}%, ${100 * (ua.ub(i) ? i : this.Msi())}%, ${100 * (ua.ub(e) ? e : this.Esi())}%)`
        }
        ksi(t, i, e, s) {
            ua.iM(t),
            ua.iM(i),
            ua.iM(e),
            ua.iM(s);
            return `rgba(${100 * (ua.ub(t) ? t : this.xsi())}%, ${100 * (ua.ub(i) ? i : this.Msi())}%, ${100 * (ua.ub(e) ? e : this.Esi())}%, ${ua.ub(s) ? s : this.Ix()})`
        }
        GA() {
            const t = Math.round(255 * this.xsi())
              , i = Math.round(255 * this.Msi())
              , e = Math.round(255 * this.Esi());
            return "#" + fa(t.toString(16)) + fa(i.toString(16)) + fa(e.toString(16))
        }
        OA(t) {
            if ("string" != typeof t)
                return !1;
            let i, e, s;
            if ("#" === (t = t.trim()).charAt(0) && (t = t.substr(1)),
            3 === t.length)
                i = parseInt(t[0], 16) / 15,
                e = parseInt(t[1], 16) / 15,
                s = parseInt(t[2], 16) / 15;
            else {
                if (6 !== t.length)
                    return !1;
                i = parseInt(t.substr(0, 2), 16) / 255,
                e = parseInt(t.substr(2, 2), 16) / 255,
                s = parseInt(t.substr(4, 2), 16) / 255
            }
            return isFinite(i) && this.bsi(i),
            isFinite(e) && this.vsi(e),
            isFinite(s) && this.Ssi(s),
            this.vx(1),
            !0
        }
        Osi() {
            return `${Math.round(255 * this.xsi())}, ${Math.round(255 * this.Msi())}, ${Math.round(255 * this.Esi())}`
        }
        Dsi() {
            return [Math.round(255 * this.xsi()), Math.round(255 * this.Msi()), Math.round(255 * this.Esi())]
        }
        Fsi(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (i.length < 3)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 255
              , s = parseInt(i[1].trim(), 10) / 255
              , n = parseInt(i[2].trim(), 10) / 255;
            return isFinite(e) && this.bsi(e),
            isFinite(s) && this.vsi(s),
            isFinite(n) && this.Ssi(n),
            this.vx(1),
            !0
        }
        Lsi(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (i.length < 3)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 100
              , s = parseInt(i[1].trim(), 10) / 100
              , n = parseInt(i[2].trim(), 10) / 100;
            return isFinite(e) && this.bsi(e),
            isFinite(s) && this.vsi(s),
            isFinite(n) && this.Ssi(n),
            this.vx(1),
            !0
        }
        Bsi(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (i.length < 4)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 255
              , s = parseInt(i[1].trim(), 10) / 255
              , n = parseInt(i[2].trim(), 10) / 255
              , r = parseFloat(i[3].trim());
            return isFinite(e) && this.bsi(e),
            isFinite(s) && this.vsi(s),
            isFinite(n) && this.Ssi(n),
            isFinite(r) && this.vx(r),
            !0
        }
        Usi(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (i.length < 4)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 100
              , s = parseInt(i[1].trim(), 10) / 100
              , n = parseInt(i[2].trim(), 10) / 100
              , r = parseFloat(i[3].trim());
            return isFinite(e) && this.bsi(e),
            isFinite(s) && this.vsi(s),
            isFinite(n) && this.Ssi(n),
            isFinite(r) && this.vx(r),
            !0
        }
        Cx(t) {
            if ("string" != typeof t)
                return !1;
            if ((t = t.replace(/\s+/, "")).includes(",")) {
                if (t.startsWith("rgb("))
                    return t.includes("%") ? this.Lsi(t) : this.Fsi(t);
                if (t.startsWith("rgba("))
                    return t.includes("%") ? this.Usi(t) : this.Bsi(t);
                if (t.startsWith("hsl(") || t.startsWith("hsla("))
                    return this.Nsi(t);
                {
                    const i = t.split(",");
                    return t.includes("%") ? 3 === i.length ? this.Lsi(t) : 4 === i.length && this.Usi(t) : 3 === i.length ? this.Fsi(t) : 4 === i.length && this.Bsi(t)
                }
            }
            return this.OA(t)
        }
        toJSON() {
            return [this._r, this._g, this._b, this._a]
        }
        jsi(t, i, e, s) {
            let n, r, h;
            if (t %= 360,
            i = ua.Ne(i, 0, 100),
            e = ua.Ne(e, 0, 100),
            s = ua.Ne(s, 0, 1),
            t /= 360,
            e /= 100,
            0 === (i /= 100))
                n = r = h = e;
            else {
                const s = e < .5 ? e * (1 + i) : e + i - e * i
                  , o = 2 * e - s;
                n = pa(o, s, t + 1 / 3),
                r = pa(o, s, t),
                h = pa(o, s, t - 1 / 3)
            }
            return this.bsi(n),
            this.vsi(r),
            this.Ssi(h),
            this.vx(s),
            this
        }
        Nsi(t) {
            const i = t.replace(/ |hsl|hsla|\(|\)|;/gi, "")
              , e = ca.exec(i)
              , s = da.exec(i);
            return e && 4 === e.length ? (this.jsi(+e[1], +e[2], +e[3], 1),
            !0) : !(!s || 5 !== s.length) && (this.jsi(+e[1], +e[2], +e[3], +e[4]),
            !0)
        }
        $si() {
            const t = this._r
              , i = this._g
              , e = this._b
              , s = this._a;
            return `hsla(${ua.za.zsi(t, i, e)}, ${ua.za.Vsi(t, i, e)}%, ${ua.za.Wsi(t, i, e)}%, ${s})`
        }
        Hsi() {
            const t = this._r
              , i = this._g
              , e = this._b;
            return [ua.za.zsi(t, i, e), ua.za.Vsi(t, i, e), ua.za.Wsi(t, i, e), this._a]
        }
        lu(t) {
            Array.isArray(t) && (t.length < 3 || (this._r = t[0],
            this._g = t[1],
            this._b = t[2],
            t.length >= 4 ? this._a = t[3] : this._a = 1))
        }
        set r(t) {
            this.bsi(t)
        }
        get r() {
            return this.xsi()
        }
        set g(t) {
            this.vsi(t)
        }
        get g() {
            return this.Msi()
        }
        set b(t) {
            this.Ssi(t)
        }
        get b() {
            return this.Esi()
        }
        set a(t) {
            this.vx(t)
        }
        get a() {
            return this.Ix()
        }
        Ksi(t, i) {
            switch (t) {
            case 0:
                this.bsi(i);
                break;
            case 1:
                this.vsi(i);
                break;
            case 2:
                this.Ssi(i);
                break;
            case 3:
                this.vx(i);
                break;
            default:
                throw new RangeError("invalid color index")
            }
        }
        qsi(t) {
            switch (t) {
            case 0:
                return this.xsi();
            case 1:
                return this.Msi();
            case 2:
                return this.Esi();
            case 3:
                return this.Ix();
            default:
                throw new RangeError("invalid color index")
            }
        }
        static Upt(t, i) {
            let e, s;
            if (Array.isArray(t))
                e = new ua.za,
                e.lu(t);
            else {
                if (!(t instanceof ua.za))
                    throw new Error("unexpected type");
                e = t
            }
            if (Array.isArray(i))
                s = new ua.za,
                s.lu(i);
            else {
                if (!(i instanceof ua.za))
                    throw new Error("unexpected type");
                s = i
            }
            return e.equals(s)
        }
        static Xsi(t, i) {
            return ua.Ne(Math.max(t, i) - Math.min(t, i), 0, 1)
        }
        static Ysi(t, i) {
            const e = new ua.za;
            return e.bsi(Math.max(t._r, i._r) - Math.min(t._r, i._r)),
            e.vsi(Math.max(t._g, i._g) - Math.min(t._g, i._g)),
            e.Ssi(Math.max(t._b, i._b) - Math.min(t._b, i._b)),
            e.vx(Math.max(t._a, i._a) - Math.min(t._a, i._a)),
            e
        }
        static Jsi(t, i) {
            const e = new ua.za(0,0,0,1);
            return e.bsi(Math.max(t._r, i._r) - Math.min(t._r, i._r)),
            e.vsi(Math.max(t._g, i._g) - Math.min(t._g, i._g)),
            e.Ssi(Math.max(t._b, i._b) - Math.min(t._b, i._b)),
            e
        }
        static zsi(t, i, e) {
            const s = Math.max(t, i, e)
              , n = Math.min(t, i, e);
            if (s === n)
                return 0;
            let r = 0;
            switch (s) {
            case t:
                r = (i - e) / (s - n) + (i < e ? 6 : 0);
                break;
            case i:
                r = (e - t) / (s - n) + 2;
                break;
            case e:
                r = (t - i) / (s - n) + 4
            }
            return Math.round(r / 6 * 360)
        }
        static Vsi(t, i, e) {
            const s = Math.max(t, i, e)
              , n = Math.min(t, i, e);
            if (s === n)
                return 0;
            const r = s - n
              , h = (s + n) / 2 > .5 ? r / (2 - s - n) : r / (s + n);
            return Math.round(100 * h)
        }
        static Wsi(t, i, e) {
            const s = Math.max(t, i, e)
              , n = (s + Math.min(t, i, e)) / 2;
            return s ? Math.round(100 * n) : 0
        }
    }
    ,
    ua.za.Zsi = Object.freeze(ua.v(ua.za, 1, 1, 1, 1)),
    ua.za.Qsi = Object.freeze(ua.v(ua.za, 0, 0, 0, 1)),
    ua.za.tni = Object.freeze(ua.v(ua.za, 0, 0, 0, 0))
}
{
    const ma = self.t;
    ma.Rect = class {
        constructor(t, i, e, s) {
            this.ini = NaN,
            this.eni = NaN,
            this.sni = NaN,
            this.nni = NaN,
            this.ini = 0,
            this.eni = 0,
            this.sni = 0,
            this.nni = 0,
            t instanceof ma.Rect ? this.Qr(t) : this.set(t || 0, i || 0, e || 0, s || 0)
        }
        set(t, i, e, s) {
            this.ini = +t,
            this.eni = +i,
            this.sni = +e,
            this.nni = +s
        }
        Cu(t, i, e, s) {
            t = +t,
            i = +i,
            this.ini = t,
            this.eni = i,
            this.sni = t + +e,
            this.nni = i + +s
        }
        Qr(t) {
            this.ini = +t.ini,
            this.eni = +t.eni,
            this.sni = +t.sni,
            this.nni = +t.nni
        }
        clone() {
            return new ma.Rect(this.ini,this.eni,this.sni,this.nni)
        }
        static rni(t, i) {
            ma.U(t, ma.Rect),
            ma.U(i, ma.Rect);
            const e = new ma.Rect;
            return e.rY(Math.min(t.ini, i.ini)),
            e.oY(Math.min(t.eni, i.eni)),
            e.Mx(Math.max(t.sni, i.sni)),
            e.lY(Math.max(t.nni, i.nni)),
            e
        }
        static nJt(t) {
            return ma.IL(t),
            new ma.Rect(t.left,t.top,t.right,t.bottom)
        }
        equals(t) {
            return this.ini === t.ini && this.eni === t.eni && this.sni === t.sni && this.nni === t.nni
        }
        hni(t, i, e, s) {
            return this.ini === t && this.eni === i && this.width() === e && this.height() === s
        }
        hsi(t, i) {
            return t[i] === Math.fround(this.ini) && t[i + 1] === Math.fround(this.eni) && t[i + 2] === Math.fround(this.sni) && t[i + 3] === Math.fround(this.nni)
        }
        rY(t) {
            this.ini = +t
        }
        Yr() {
            return this.ini
        }
        oY(t) {
            this.eni = +t
        }
        Jr() {
            return this.eni
        }
        Mx(t) {
            this.sni = +t
        }
        pl() {
            return this.sni
        }
        lY(t) {
            this.nni = +t
        }
        dl() {
            return this.nni
        }
        toArray() {
            return [this.ini, this.eni, this.sni, this.nni]
        }
        lsi() {
            return new Float64Array(this.toArray())
        }
        oni() {
            return new DOMRect(this.ini,this.eni,this.width(),this.height())
        }
        static ani(t) {
            return ma.v(ma.Rect, t.left, t.top, t.right, t.bottom)
        }
        usi(t, i) {
            t[i++] = this.ini,
            t[i++] = this.eni,
            t[i++] = this.sni,
            t[i] = this.nni
        }
        lni(t, i) {
            t[i++] = this.ini,
            t[i++] = this.eni,
            t[i++] = this.sni,
            t[i++] = this.eni,
            t[i++] = this.sni,
            t[i++] = this.nni,
            t[i++] = this.ini,
            t[i] = this.nni
        }
        uni(t, i, e) {
            t[i++] = this.ini,
            t[i++] = this.eni,
            t[i++] = e,
            t[i++] = this.sni,
            t[i++] = this.eni,
            t[i++] = e,
            t[i++] = this.sni,
            t[i++] = this.nni,
            t[i++] = e,
            t[i++] = this.ini,
            t[i++] = this.nni,
            t[i] = e
        }
        width() {
            return this.sni - this.ini
        }
        height() {
            return this.nni - this.eni
        }
        fl() {
            return (this.ini + this.sni) / 2
        }
        ml() {
            return (this.eni + this.nni) / 2
        }
        offset(t, i) {
            t = +t,
            i = +i,
            this.ini += t,
            this.eni += i,
            this.sni += t,
            this.nni += i
        }
        offsetLeft(t) {
            this.ini += +t
        }
        offsetTop(t) {
            this.eni += +t
        }
        gl(t) {
            this.sni += +t
        }
        cni(t) {
            this.nni += +t
        }
        dni(t) {
            if (ma.zt(t),
            "x" !== t)
                throw new Error("invalid axis, only 'x' supported");
            this.eni < this.nni ? this.ini < this.sni ? this.nni = this.eni + this.width() : this.nni = this.eni - this.width() : this.ini < this.sni ? this.nni = this.eni - this.width() : this.nni = this.eni + this.width()
        }
        Kp(t, i) {
            t = +t,
            i = +i,
            this.ini -= t,
            this.eni -= i,
            this.sni += t,
            this.nni += i
        }
        Kr(t, i) {
            t = +t,
            i = +i,
            this.ini += t,
            this.eni += i,
            this.sni -= t,
            this.nni -= i
        }
        multiply(t, i) {
            this.ini *= t,
            this.eni *= i,
            this.sni *= t,
            this.nni *= i
        }
        xm(t, i) {
            this.ini /= t,
            this.eni /= i,
            this.sni /= t,
            this.nni /= i
        }
        fni(t) {
            this.ini = +t - this.ini,
            this.sni = +t - this.sni
        }
        pni(t) {
            this.eni = +t - this.eni,
            this.nni = +t - this.nni
        }
        mni(t, i) {
            const e = this.width()
              , s = this.height()
              , n = this.Yr() + e * t
              , r = this.Jr() + s * i;
            this.Cu(n - s * i, r - e * t, s, e)
        }
        wni() {
            const t = this.ini;
            this.ini = this.sni,
            this.sni = t
        }
        gni() {
            const t = this.eni;
            this.eni = this.nni,
            this.nni = t
        }
        yni(t) {
            const i = this.eni;
            this.eni = +t - this.nni,
            this.nni = +t - i
        }
        round() {
            this.ini = Math.round(this.ini),
            this.eni = Math.round(this.eni),
            this.sni = Math.round(this.sni),
            this.nni = Math.round(this.nni)
        }
        bni() {
            this.ini = Math.ceil(this.ini),
            this.eni = Math.ceil(this.eni),
            this.sni = Math.floor(this.sni),
            this.nni = Math.floor(this.nni)
        }
        vni() {
            this.ini = Math.floor(this.ini),
            this.eni = Math.floor(this.eni),
            this.sni = Math.ceil(this.sni),
            this.nni = Math.ceil(this.nni)
        }
        floor() {
            this.ini = Math.floor(this.ini),
            this.eni = Math.floor(this.eni),
            this.sni = Math.floor(this.sni),
            this.nni = Math.floor(this.nni)
        }
        ceil() {
            this.ini = Math.ceil(this.ini),
            this.eni = Math.ceil(this.eni),
            this.sni = Math.ceil(this.sni),
            this.nni = Math.ceil(this.nni)
        }
        Ne(t, i, e, s) {
            this.ini = Math.max(this.ini, +t),
            this.eni = Math.max(this.eni, +i),
            this.sni = Math.min(this.sni, +e),
            this.nni = Math.min(this.nni, +s)
        }
        Sni(t, i, e, s) {
            t = +t,
            i = +i,
            e = +e,
            s = +s,
            this.ini = ma.Ne(this.ini, t, e),
            this.eni = ma.Ne(this.eni, i, s),
            this.sni = ma.Ne(this.sni, t, e),
            this.nni = ma.Ne(this.nni, i, s)
        }
        normalize() {
            this.ini > this.sni && this.wni(),
            this.eni > this.nni && this.gni()
        }
        nc(t) {
            return !(t.sni < this.ini || t.nni < this.eni || t.ini > this.sni || t.eni > this.nni)
        }
        xni(t, i, e) {
            return !(t.sni + i < this.ini || t.nni + e < this.eni || t.ini + i > this.sni || t.eni + e > this.nni)
        }
        nB(t, i) {
            return t >= this.ini && t <= this.sni && i >= this.eni && i <= this.nni
        }
        RD(t) {
            return t.ini >= this.ini && t.eni >= this.eni && t.sni <= this.sni && t.nni <= this.nni
        }
        ec(t) {
            t.ini < this.ini && (this.ini = +t.ini),
            t.eni < this.eni && (this.eni = +t.eni),
            t.sni > this.sni && (this.sni = +t.sni),
            t.nni > this.nni && (this.nni = +t.nni)
        }
        Zb(t) {
            this.ini = ma.mi(t.ini, t.sni, this.ini),
            this.eni = ma.mi(t.eni, t.nni, this.eni),
            this.sni = ma.mi(t.ini, t.sni, this.sni),
            this.nni = ma.mi(t.eni, t.nni, this.nni)
        }
    }
}
{
    const wa = self.t;
    wa.zn = class {
        constructor(t, i, e, s, n, r, h, o) {
            this.Mni = NaN,
            this.Eni = NaN,
            this.Cni = NaN,
            this._ni = NaN,
            this.Tni = NaN,
            this.Ini = NaN,
            this.Pni = NaN,
            this.Gni = NaN,
            this.Mni = 0,
            this.Eni = 0,
            this.Cni = 0,
            this._ni = 0,
            this.Tni = 0,
            this.Ini = 0,
            this.Pni = 0,
            this.Gni = 0,
            t instanceof wa.zn ? this.Qr(t) : this.set(t || 0, i || 0, e || 0, s || 0, n || 0, r || 0, h || 0, o || 0)
        }
        set(t, i, e, s, n, r, h, o) {
            this.Mni = +t,
            this.Eni = +i,
            this.Cni = +e,
            this._ni = +s,
            this.Tni = +n,
            this.Ini = +r,
            this.Pni = +h,
            this.Gni = +o
        }
        Ll(t, i, e, s) {
            this.set(t, i, e, i, e, s, t, s)
        }
        Qr(t) {
            this.Mni = t.Mni,
            this.Eni = t.Eni,
            this.Cni = t.Cni,
            this._ni = t._ni,
            this.Tni = t.Tni,
            this.Ini = t.Ini,
            this.Pni = t.Pni,
            this.Gni = t.Gni
        }
        equals(t) {
            return this.Mni === t.Mni && this.Eni === t.Eni && this.Cni === t.Cni && this._ni === t._ni && this.Tni === t.Tni && this.Ini === t.Ini && this.Pni === t.Pni && this.Gni === t.Gni
        }
        Om(t) {
            this.Mni = +t
        }
        Zn() {
            return this.Mni
        }
        Tm(t) {
            this.Eni = +t
        }
        tr() {
            return this.Eni
        }
        Ani(t) {
            this.Cni = +t
        }
        lm() {
            return this.Cni
        }
        Rni(t) {
            this._ni = +t
        }
        el() {
            return this._ni
        }
        kni(t) {
            this.Tni = +t
        }
        il() {
            return this.Tni
        }
        Oni(t) {
            this.Ini = +t
        }
        sl() {
            return this.Ini
        }
        Dni(t) {
            this.Pni = +t
        }
        Fl() {
            return this.Pni
        }
        Fni(t) {
            this.Gni = +t
        }
        El() {
            return this.Gni
        }
        Lni() {
            return new DOMQuad(new DOMPoint(this.Mni,this.Eni),new DOMPoint(this.Cni,this._ni),new DOMPoint(this.Tni,this.Ini),new DOMPoint(this.Pni,this.Gni))
        }
        static Bni(t) {
            return wa.v(wa.zn, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y)
        }
        toArray() {
            return [this.Mni, this.Eni, this.Cni, this._ni, this.Tni, this.Ini, this.Pni, this.Gni]
        }
        lsi() {
            return new Float64Array(this.toArray())
        }
        usi(t, i) {
            t[i++] = this.Mni,
            t[i++] = this.Eni,
            t[i++] = this.Cni,
            t[i++] = this._ni,
            t[i++] = this.Tni,
            t[i++] = this.Ini,
            t[i++] = this.Pni,
            t[i] = this.Gni
        }
        Uni(t, i, e) {
            t[i++] = this.Mni,
            t[i++] = this.Eni,
            t[i++] = e,
            t[i++] = this.Cni,
            t[i++] = this._ni,
            t[i++] = e,
            t[i++] = this.Tni,
            t[i++] = this.Ini,
            t[i++] = e,
            t[i++] = this.Pni,
            t[i++] = this.Gni,
            t[i] = e
        }
        offset(t, i) {
            t = +t,
            i = +i,
            this.Mni += t,
            this.Eni += i,
            this.Cni += t,
            this._ni += i,
            this.Tni += t,
            this.Ini += i,
            this.Pni += t,
            this.Gni += i
        }
        round() {
            this.Mni = Math.round(this.Mni),
            this.Eni = Math.round(this.Eni),
            this.Cni = Math.round(this.Cni),
            this._ni = Math.round(this._ni),
            this.Tni = Math.round(this.Tni),
            this.Ini = Math.round(this.Ini),
            this.Pni = Math.round(this.Pni),
            this.Gni = Math.round(this.Gni)
        }
        floor() {
            this.Mni = Math.floor(this.Mni),
            this.Eni = Math.floor(this.Eni),
            this.Cni = Math.floor(this.Cni),
            this._ni = Math.floor(this._ni),
            this.Tni = Math.floor(this.Tni),
            this.Ini = Math.floor(this.Ini),
            this.Pni = Math.floor(this.Pni),
            this.Gni = Math.floor(this.Gni)
        }
        ceil() {
            this.Mni = Math.ceil(this.Mni),
            this.Eni = Math.ceil(this.Eni),
            this.Cni = Math.ceil(this.Cni),
            this._ni = Math.ceil(this._ni),
            this.Tni = Math.ceil(this.Tni),
            this.Ini = Math.ceil(this.Ini),
            this.Pni = Math.ceil(this.Pni),
            this.Gni = Math.ceil(this.Gni)
        }
        Zr(t) {
            this.Mni = t.ini,
            this.Eni = t.eni,
            this.Cni = t.sni,
            this._ni = t.eni,
            this.Tni = t.sni,
            this.Ini = t.nni,
            this.Pni = t.ini,
            this.Gni = t.nni
        }
        cr(t, i) {
            0 === i ? this.Zr(t) : this.Ox(t, Math.sin(i), Math.cos(i))
        }
        Ox(t, i, e) {
            const s = t.ini * i
              , n = t.eni * i
              , r = t.sni * i
              , h = t.nni * i
              , o = t.ini * e
              , a = t.eni * e
              , l = t.sni * e
              , u = t.nni * e;
            this.Mni = o - n,
            this.Eni = a + s,
            this.Cni = l - n,
            this._ni = a + r,
            this.Tni = l - h,
            this.Ini = u + r,
            this.Pni = o - h,
            this.Gni = u + s
        }
        Nni(t) {
            t.set(Math.min(this.Mni, this.Cni, this.Tni, this.Pni), Math.min(this.Eni, this._ni, this.Ini, this.Gni), Math.max(this.Mni, this.Cni, this.Tni, this.Pni), Math.max(this.Eni, this._ni, this.Ini, this.Gni))
        }
        nB(t, i) {
            let e = this.Cni - this.Mni
              , s = this._ni - this.Eni;
            const n = this.Tni - this.Mni
              , r = this.Ini - this.Eni
              , h = t - this.Mni
              , o = i - this.Eni;
            let a = e * e + s * s
              , l = e * n + s * r
              , u = e * h + s * o;
            const c = n * n + r * r
              , d = n * h + r * o;
            let f = 1 / (a * c - l * l)
              , p = (c * u - l * d) * f
              , m = (a * d - l * u) * f;
            return p >= 0 && m > 0 && p + m < 1 || (e = this.Pni - this.Mni,
            s = this.Gni - this.Eni,
            a = e * e + s * s,
            l = e * n + s * r,
            u = e * h + s * o,
            f = 1 / (a * c - l * l),
            p = (c * u - l * d) * f,
            m = (a * d - l * u) * f,
            p >= 0 && m > 0 && p + m < 1)
        }
        fl() {
            return (this.Mni + this.Cni + this.Tni + this.Pni) / 4
        }
        ml() {
            return (this.Eni + this._ni + this.Ini + this.Gni) / 4
        }
        jni(t, i, e, s) {
            return !(!this.nB(t, i) && !this.nB(e, s)) || wa.Zei(t, i, e, s, this)
        }
        $ni(t) {
            let i = t.fl()
              , e = t.ml();
            if (this.nB(i, e))
                return !0;
            if (i = this.fl(),
            e = this.ml(),
            t.nB(i, e))
                return !0;
            const s = this.Mni
              , n = this.Eni
              , r = this.Cni
              , h = this._ni
              , o = this.Tni
              , a = this.Ini
              , l = this.Pni
              , u = this.Gni;
            return wa.Zei(s, n, r, h, t) || wa.Zei(r, h, o, a, t) || wa.Zei(o, a, l, u, t) || wa.Zei(l, u, s, n, t)
        }
        zni() {
            const t = this.Mni
              , i = this.Eni;
            this.Mni = this.Cni,
            this.Eni = this._ni,
            this.Cni = this.Tni,
            this._ni = this.Ini,
            this.Tni = this.Pni,
            this.Ini = this.Gni,
            this.Pni = t,
            this.Gni = i
        }
        Pm() {
            this.Vni(0, 2),
            this.Vni(1, 3),
            this.Vni(6, 4),
            this.Vni(7, 5)
        }
        QI() {
            this.Vni(0, 6),
            this.Vni(1, 7),
            this.Vni(2, 4),
            this.Vni(3, 5)
        }
        KI() {
            this.Vni(2, 6),
            this.Vni(3, 7)
        }
        Vni(t, i) {
            const e = this.Wni(t);
            this.Hni(t, this.Wni(i)),
            this.Hni(i, e)
        }
        Wni(t) {
            switch (t) {
            case 0:
                return this.Mni;
            case 1:
                return this.Eni;
            case 2:
                return this.Cni;
            case 3:
                return this._ni;
            case 4:
                return this.Tni;
            case 5:
                return this.Ini;
            case 6:
                return this.Pni;
            case 7:
                return this.Gni;
            default:
                throw new RangeError("invalid quad point index")
            }
        }
        Hni(t, i) {
            switch (i = +i,
            t) {
            case 0:
                this.Mni = i;
                break;
            case 1:
                this.Eni = i;
                break;
            case 2:
                this.Cni = i;
                break;
            case 3:
                this._ni = i;
                break;
            case 4:
                this.Tni = i;
                break;
            case 5:
                this.Ini = i;
                break;
            case 6:
                this.Pni = i;
                break;
            case 7:
                this.Gni = i;
                break;
            default:
                throw new RangeError("invalid quad point index")
            }
        }
        xm(t, i) {
            this.Mni /= t,
            this.Eni /= i,
            this.Cni /= t,
            this._ni /= i,
            this.Tni /= t,
            this.Ini /= i,
            this.Pni /= t,
            this.Gni /= i
        }
    }
}
{
    const ga = self.t
      , ya = "00";
    ga.Crypto = {},
    ga.Crypto.Kni = function(t) {
        let i = "";
        const e = new DataView(t);
        for (let t = 0; t < e.byteLength; ++t) {
            const s = e.getUint8(t).toString(16);
            i += (ya + s).slice(-ya.length)
        }
        return i
    }
    ,
    ga.Crypto.qni = function(t) {
        return "string" == typeof t && (t = ga.vei(t)),
        ga.Crypto.Xni(t)
    }
    ,
    ga.Crypto.Xni = function(t) {
        return window.isSecureContext ? crypto.subtle.digest("SHA-256", t).then(ga.Crypto.Kni) : Promise.reject(new Error("web crypto only available on secure origins"))
    }
}
{
    const ba = self.t
      , va = new Map
      , Sa = new Map
      , xa = new Map
      , Ma = new Map
      , Ea = new Map
      , Ca = new Map
      , _a = new Map
      , Ta = new Map
      , Ia = new Map;
    Ia.set("linear", "noease"),
    Ia.set("default", "noease");
    const Pa = ["default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce"]
      , Ga = ["default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce"]
      , Aa = new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
    self.Yfe = class t {
        constructor() {}
        static Npe() {
            return "default"
        }
        static $pe() {
            return "noease"
        }
        static Yni(t) {
            return Aa.get(t)
        }
        static Ppe(i, ...e) {
            let s, n;
            this.Jni(),
            i ? (xa.has(i) || xa.set(i, new Map),
            s = xa.get(i),
            n = [...s.keys()].filter(e => !t.Zni(e, i) || t.Zni(e, i).transition.Qni())) : (s = Ea,
            n = [...s.keys()]);
            const r = n.sort();
            return [...Sa.keys()].concat(r).filter(t => !e.includes(t))
        }
        static tri() {
            this.Jni();
            const t = [...Ea.keys()];
            return t.sort(),
            [...Sa.keys()].concat(t)
        }
        static iri() {
            this.Jni();
            const t = [...Ea.keys()];
            return t.sort(),
            t
        }
        static eri(t) {
            ba.zt(t);
            for (const i of Pa) {
                if (self.lang(`ui.bars.timeline.eases.${i}`) === t)
                    return !0
            }
            for (const i of Ga) {
                if (self.lang(`ui.bars.timeline.short-eases.${i}`) === t)
                    return !0
            }
        }
        static jpe(t) {
            return ba.zt(t),
            this.Jni(),
            [...Sa.keys()].includes(t)
        }
        static sri(i) {
            ba.zt(i);
            const e = Ia.get(i);
            return e ? va.get(e) : t.jpe(i) ? va.get(i) : _a.has(i) ? _a.get(i) : void 0
        }
        static zpe(t) {
            return ba.zt(t),
            this.Jni(),
            Ta.get(t)
        }
        static nri(i, e) {
            ba.zt(i),
            ba.Ef(e, self.jw),
            this.Jni();
            const s = t.sri(i);
            if (s)
                return s;
            if (!e)
                throw new Error("missing ease function");
            return xa.get(e).get(i)
        }
        static Zni(t, i) {
            ba.zt(t),
            this.Jni();
            const e = Ma.get(i);
            if (e)
                return e.get(t)
        }
        static rri(i, e) {
            ba.zt(i),
            ba.U(e, self.jw),
            this.Jni();
            return !!t.sri(i) || !!xa.get(e).get(i)
        }
        static hri(i) {
            ba.zt(i),
            this.Jni();
            const e = t.sri(i);
            return e || Ea.get(i)
        }
        static ori(t) {
            return ba.zt(t),
            this.Jni(),
            Ca.get(t)
        }
        static ari(t) {
            ba.Ge(t),
            this.Jni();
            return this.tri()[t]
        }
        static lri(t, i) {
            ba.zt(t),
            this.Jni();
            return this.Ppe(i).indexOf(t)
        }
        static cri(t) {
            return this.lri(t)
        }
        static Jni() {
            0 === va.size && (this.dri("default", () => {}
            ),
            this.dri("noease", [{
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            }], !0),
            this.dri("easeinsine", [{
                x: 0,
                y: 0,
                sax: .485,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutsine", [{
                x: 0,
                y: 0,
                sax: .038,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.485,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutsine", [{
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinelastic", [{
                x: 0,
                y: 0,
                sax: .018,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .116,
                y: .002,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .266,
                y: -.005,
                sax: .024,
                say: 0,
                eax: -.021,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .416,
                y: .016,
                sax: .024,
                say: 0,
                eax: -.026,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .566,
                y: -.045,
                sax: .061,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .716,
                y: .132,
                sax: .072,
                say: -.004,
                eax: -.045,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .866,
                y: -.373,
                sax: .06,
                say: 0,
                eax: -.049,
                eay: -.002,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: -.263,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutelastic", [{
                x: 0,
                y: 0,
                sax: .038,
                say: .263,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .136,
                y: 1.373,
                sax: .049,
                say: .002,
                eax: -.06,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .286,
                y: .868,
                sax: .045,
                say: 0,
                eax: -.072,
                eay: .004,
                se: !0,
                ee: !0
            }, {
                x: .436,
                y: 1.045,
                sax: .025,
                say: 0,
                eax: -.061,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .586,
                y: .984,
                sax: .026,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .736,
                y: 1.005,
                sax: .021,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .886,
                y: .998,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.018,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutelastic", [{
                x: 0,
                y: 0,
                sax: .025,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .067,
                y: .001,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .18,
                y: -.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .292,
                y: .025,
                sax: .053,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .405,
                y: -.118,
                sax: .069,
                say: 0,
                eax: -.027,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .597,
                y: 1.118,
                sax: .027,
                say: 0,
                eax: -.069,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .71,
                y: .975,
                sax: .025,
                say: 0,
                eax: -.053,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .822,
                y: 1.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .935,
                y: .999,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinback", [{
                x: 0,
                y: 0,
                sax: .35,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.34,
                eay: -1.579,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutback", [{
                x: 0,
                y: 0,
                sax: .34,
                say: 1.579,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.35,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutback", [{
                x: 0,
                y: 0,
                sax: .035,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .242,
                y: -.1,
                sax: .258,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .76,
                y: 1.1,
                sax: .025,
                say: 0,
                eax: -.26,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.035,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinbounce", [{
                x: 0,
                y: 0,
                sax: .033,
                say: .025,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .092,
                y: 0,
                sax: .026,
                say: .078,
                eax: -.033,
                eay: .025,
                se: !0,
                ee: !0
            }, {
                x: .274,
                y: 0,
                sax: .097,
                say: .319,
                eax: -.026,
                eay: .078,
                se: !0,
                ee: !0
            }, {
                x: .637,
                y: 0,
                sax: .105,
                say: .625,
                eax: -.097,
                eay: .319,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: -.004,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutbounce", [{
                x: 0,
                y: 0,
                sax: .125,
                say: .004,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .365,
                y: 1,
                sax: .097,
                say: -.319,
                eax: -.105,
                eay: -.625,
                se: !0,
                ee: !0
            }, {
                x: .728,
                y: 1,
                sax: .026,
                say: -.078,
                eax: -.097,
                eay: -.319,
                se: !0,
                ee: !0
            }, {
                x: .91,
                y: 1,
                sax: .033,
                say: -.025,
                eax: -.026,
                eay: -.078,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.033,
                eay: -.025,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutbounce", [{
                x: 0,
                y: 0,
                sax: .01,
                say: .006,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .046,
                y: 0,
                sax: .021,
                say: .038,
                eax: -.01,
                eay: .006,
                se: !0,
                ee: !0
            }, {
                x: .137,
                y: 0,
                sax: .059,
                say: .158,
                eax: -.021,
                eay: .038,
                se: !0,
                ee: !0
            }, {
                x: .319,
                y: 0,
                sax: .117,
                say: .744,
                eax: -.059,
                eay: .158,
                se: !0,
                ee: !0
            }, {
                x: .683,
                y: 1,
                sax: .059,
                say: -.158,
                eax: -.117,
                eay: -.744,
                se: !0,
                ee: !0
            }, {
                x: .865,
                y: 1,
                sax: .021,
                say: -.038,
                eax: -.059,
                eay: -.158,
                se: !0,
                ee: !0
            }, {
                x: .956,
                y: 1,
                sax: .01,
                say: -.006,
                eax: -.021,
                eay: -.038,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.01,
                eay: -.006,
                se: !1,
                ee: !0
            }]),
            this.dri("easeincubic", [{
                x: 0,
                y: 0,
                sax: .75,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.138,
                eay: -.321,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutcubic", [{
                x: 0,
                y: 0,
                sax: .138,
                say: .321,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.75,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutcubic", [{
                x: 0,
                y: 0,
                sax: .285,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .081,
                say: .272,
                eax: -.081,
                eay: -.272,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.285,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinquad", [{
                x: 0,
                y: 0,
                sax: .4,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.178,
                eay: -.392,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutquad", [{
                x: 0,
                y: 0,
                sax: .178,
                say: .392,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.4,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutquad", [{
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .03,
                say: .065,
                eax: -.03,
                eay: -.065,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinquart", [{
                x: 0,
                y: 0,
                sax: .5,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: -1,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutquart", [{
                x: 0,
                y: 0,
                sax: .25,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.5,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutquart", [{
                x: 0,
                y: 0,
                sax: .765,
                say: .03,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.765,
                eay: -.03,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinquint", [{
                x: 0,
                y: 0,
                sax: .6,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.2,
                eay: -1,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutquint", [{
                x: 0,
                y: 0,
                sax: .2,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.6,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutquint", [{
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .84,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.84,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            }]),
            this.dri("easeincirc", [{
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.024,
                eay: -.808,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutcirc", [{
                x: 0,
                y: 0,
                sax: .024,
                say: .808,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutcirc", [{
                x: 0,
                y: 0,
                sax: .125,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .02,
                say: .428,
                eax: -.02,
                eay: -.428,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinexpo", [{
                x: 0,
                y: 0,
                sax: .66,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.14,
                eay: -1,
                se: !1,
                ee: !0
            }]),
            this.dri("easeoutexpo", [{
                x: 0,
                y: 0,
                sax: .14,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.66,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.dri("easeinoutexpo", [{
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .345,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.06,
                eay: -.5,
                ee: !0,
                sax: .06,
                say: .5,
                se: !0,
                x: .5,
                y: .5
            }, {
                eax: -.335,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            }]),
            this.fri("cubicbezier", this.pri),
            this.fri("spline", this.mri))
        }
        static dri(i, e, s=!1) {
            if (ba.zt(i),
            "function" == typeof e)
                t.wri(i, e, "predefined");
            else {
                if (!ba.B9(e))
                    throw new Error("unexpected arguments");
                if (self.gri) {
                    const n = ba.v(self.gri, i, s);
                    n.uM(e),
                    t.wri(i, (t, i, e, s) => n.JV(t, i, e, s), "predefined"),
                    Ta.set(i, n)
                } else {
                    const n = ba.v(ba.fte, [i, e.map(t => [t.x, t.y, t.sax, t.say, t.eax, t.eay, t.se, t.ee])], !1);
                    n.yri(s),
                    t.wri(i, (t, i, e, s) => n.JV(t, i, e, s), "predefined")
                }
            }
        }
        static fri(i, e) {
            ba.zt(i),
            ba.nu(e),
            t.wri(i, e, "private")
        }
        static bri(i, e, s, n) {
            ba.zt(i),
            ba.nu(e),
            ba.Ef(s, self.jw),
            ba.ML(n),
            this.Jni(),
            t.wri(i, e, "custom", s, n)
        }
        static vri(t, i) {
            if (ba.zt(t),
            ba.U(i, self.jw),
            this.jpe(t))
                return;
            if ([..._a.keys()].includes(t))
                return;
            const e = xa.get(i);
            e && e.delete(t);
            const s = Ma.get(i);
            s && s.delete(t)
        }
        static wri(t, i, e, s, n) {
            switch (ba.zt(t),
            ba.nu(i),
            ba.zt(e),
            ba.Ef(s, self.jw),
            ba.ML(n),
            e) {
            case "predefined":
                va.set(t, i),
                Sa.set(t, i);
                break;
            case "custom":
                if (s) {
                    xa.has(s) || xa.set(s, new Map),
                    Ma.has(s) || Ma.set(s, new Map);
                    xa.get(s).set(t, i);
                    Ma.get(s).set(t, n)
                } else
                    Ea.set(t, i),
                    Ca.set(t, n);
                break;
            case "private":
                va.set(t, i),
                _a.set(t, i);
                break;
            default:
                throw new Error("unexpected ease mode")
            }
        }
        static Sri(t, i, e, s) {
            return 0 === s ? i : e * t / s + i
        }
        static pri(t, i, e, s, n) {
            return i + 3 * t * (e - i) + 3 * t ** 2 * (i + s - 2 * e) + t ** 3 * (n - i + 3 * e - 3 * s)
        }
        static mri(t, i, e, s, n, r, h, o, a, l) {
            if (s === n && r === h)
                return t;
            const u = za(t, i, s, r, o, l)
              , c = Ba(e, n, h, a)
              , d = Ua(e, n, h, a)
              , f = Na(e, n, h, a);
            return ja(u, c, d, f)
        }
        static xri(t, i, e, s) {
            const n = []
              , r = Ba(t, i, e, s)
              , h = Ua(t, i, e, s)
              , o = Na(t, i, e, s);
            for (let t = 0; t < Ra; ++t) {
                const i = ja(t * ka, r, h, o);
                n.push(i)
            }
            return n
        }
    }
    ;
    const Ra = 11
      , ka = 1 / (Ra - 1)
      , Oa = 4
      , Da = .01
      , Fa = 1e-7
      , La = 10
      , Ba = (t, i, e, s) => s - 3 * e + 3 * i - t
      , Ua = (t, i, e, s) => 3 * e - 6 * i + 3 * t
      , Na = (t, i, e, s) => 3 * (i - t)
      , ja = (t, i, e, s) => ((i * t + e) * t + s) * t
      , $a = (t, i, e, s) => 3 * i * t * t + 2 * e * t + s
      , za = (t, i, e, s, n, r) => {
        if (1 == t)
            return 1;
        let h = 0
          , o = 1
          , a = r[o]
          , l = Ra - 1;
        r[Ra - 1];
        for (; o != l && a <= t; )
            o++,
            a = r[o],
            h += ka;
        o--,
        a = r[o];
        let u = h + (t - a) / (r[o + 1] - a) * ka;
        const c = Ba(i, e, s, n)
          , d = Ua(i, e, s, n)
          , f = Na(i, e, s, n)
          , p = $a(u, c, d, f);
        if (0 === p)
            return u;
        if (p >= Da) {
            for (let i = 0; i < Oa; ++i) {
                u -= (ja(u, c, d, f) - t) / $a(u, c, d, f)
            }
            return u
        }
        {
            let i, e, s = h, n = h + ka, r = 0;
            do {
                u = s + (n - s) / 2;
                let h = ja(u, c, d, f) - t;
                h > 0 ? n = u : s = u,
                i = Math.abs(h) > Fa,
                e = ++r < La
            } while (i && e);
            return u
        }
    }
}
{
    const Va = self.t;
    function Wa(t) {
        Va.K9(t) || Va.Ck(t)
    }
    Va.rwt = class {
        constructor(t) {
            this.Mri = [],
            this.Ftt = t || "",
            this.Eri = 0
        }
        he() {
            this.Ry(),
            this.Mri = null
        }
        La() {
            return this.Ftt
        }
        Ry() {
            Va.Dct(this.Mri),
            this.Eri = 0
        }
        Cri() {
            return this.Eri
        }
        Awt(t=Math.random() * this.Cri()) {
            Va.X9t(t, 0, this.Eri);
            let i = 0;
            for (const [e,s] of this.Mri)
                if (i += e,
                t < i)
                    return s;
            return 0
        }
        qA() {
            return !!this.Mri.length
        }
        _A(t, i) {
            Va.X9t(t, 0, 1 / 0),
            Wa(i),
            this.Eri += t,
            this.Mri.push([t, i])
        }
        Zxt(t, i) {
            Va.X9t(t, 0, 1 / 0),
            Wa(i);
            const e = 0 === t;
            for (let s = 0; s < this.Mri.length; s++) {
                const n = this.Mri[s]
                  , r = e || n[0] === t
                  , h = n[1] === i;
                if (r && h) {
                    this.Mri.splice(s, 1),
                    this.Eri -= n[0];
                    break
                }
            }
        }
        _ri() {
            return JSON.stringify(this.Mri)
        }
        static Tri(t, i) {
            Va.zt(t);
            const e = new Va.rwt(i)
              , s = JSON.parse(t);
            Va.RH(s);
            for (const t of s) {
                Va.RH(t);
                const i = t[0]
                  , s = t[1];
                e._A(i, s)
            }
            return e
        }
    }
}
{
    const Ha = self.t
      , Ka = ["alphabetical", "numerical", "no-sort"]
      , qa = ["ascending", "descending"]
      , Xa = ["auto", "array", "tree", "array-with-meta-info"]
      , Ya = ["all", "root-only"]
      , Ja = {
        filter: null,
        Ptt: () => !0,
        Iri: null,
        sort: null,
        order: null,
        F9: !1,
        j9: "all",
        result: "auto"
    }
      , Za = []
      , Qa = [];
    Ha.Pri = async function(t, i) {
        Ha.Cti(t),
        bl(i);
        const e = Ha.v(el, "tree", "directories");
        Za.push(e);
        for (const i of t()) {
            Ha.nu(i.La),
            Ha.Cti(i.files);
            const t = Ha.v(il, i.La());
            for (const e of i.files())
                if (e instanceof self.Promise) {
                    const i = await e;
                    Ha.tti(i, Blob) && (i.name = "dummy-name"),
                    t.Gri(i)
                } else
                    Ha.tti(e, Blob) && (e.name = "dummy-name"),
                    t.Gri(e);
            e.Ari(t)
        }
        return rl(e, i)
    }
    ,
    Ha.lct = function(t) {
        if (t.types)
            for (let i = 0; i < t.types.length; i++)
                if ("Files" === t.types[i] || "application/x-c3-file" === t.types[i])
                    return !0;
        return !1
    }
    ,
    Ha.Rri = async function(t, i) {
        Ha.Rti(t, DataTransfer),
        i = bl(i);
        try {
            Ha.kri();
            return await vl(t, i) ? await Cl(t, i) : await El(t, i)
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t
        }
    }
    ,
    Ha.uct = async function(t) {
        return Ha.Rti(t, DataTransfer),
        Ha.Rri(t, {
            filter: t => !0,
            Iri: "",
            sort: "no-sort",
            order: "ascending",
            F9: !1,
            result: "array"
        })
    }
    ,
    Ha.G9 = async function(t, i) {
        Ha.J1(i),
        i = bl(i),
        Ha.kri();
        if (await Sl(t, null, i)) {
            const e = Ha.v(el, null, "files");
            return Za.push(e),
            Ml(t, e, i)
        }
        return xl(t, i)
    }
    ,
    Ha.kri = function() {
        for (const t of Za)
            t.he();
        Ha.Io(Za);
        for (const t of ul)
            t.he();
        Ha.Io(ul);
        for (const t of Qa)
            t.he();
        Ha.Io(Qa)
    }
    ,
    Ha.Ori = async function(t) {
        Ha.RH(t);
        const i = t.map(async t => {
            const i = t.file
              , e = t.Dri;
            if (!e)
                return i;
            const s = await e.Fri("animation.frame-durations")
              , n = await e.Fri("animation.frame-image-points")
              , r = await e.Fri("animation.frame-collision-polys")
              , h = await e.Fri("animation.frame-tags")
              , o = self.zf.Lri({
                duration: s?.[t.index],
                Bri: n?.[t.index],
                Uri: r?.[t.index],
                tag: h?.[t.index]
            });
            return Ha.Xii(i, {
                Nri: o
            }),
            i
        }
        );
        return await Promise.all(i)
    }
    ;
    class tl extends Ha.Me {
        constructor(t) {
            Ha.zt(t),
            super(),
            this.Ftt = t,
            this.jri = [],
            this.$ri = [],
            this.zri = null,
            this.Vri = null,
            this.c8 = null
        }
        he() {
            if (this.jri)
                for (const t of this.jri)
                    Ha.Bm(t, il) && t.he();
            if (this.jri = null,
            this.$ri)
                for (const t of this.$ri)
                    t.he();
            this.$ri = null,
            this.Ftt = null,
            this.zri = null,
            this.Vri = null,
            this.c8 = null
        }
        q5() {
            for (const t of this.Wri()) {
                if (Ha.Bm(t, il) && !t.q5())
                    return !1;
                if (Ha.ptt(t))
                    return !1
            }
            for (const t of this.E9())
                if (!t.q5())
                    return !1;
            return !0
        }
        La() {
            return this.Ftt
        }
        Hri() {
            return this.jri
        }
        Wri() {
            return this.jri
        }
        E9() {
            return this.$ri
        }
        b8(t) {
            Ha.U(t, tl),
            this.c8 = t
        }
        Kri() {
            return !!this.zri
        }
        qri(t) {
            Ha.M4(t),
            this.zri = t
        }
        Xri() {
            return this.zri
        }
        async Yri(t) {
            if (Ha.zt(t),
            this.Vri && this.Vri.hasOwnProperty(t))
                return this.Vri[t];
            if (this.zri) {
                try {
                    const i = await this.zri.text();
                    if (!Ha.Jri(this.zri))
                        throw new Error("unsupported meta info");
                    if (this.Vri = JSON.parse(i),
                    this.Vri.hasOwnProperty(t))
                        return this.Vri[t]
                } catch (t) {
                    throw "unsupported meta info" === t.message ? new gl(this.zri) : new yl(this.zri)
                }
                this.zri = null
            }
            return null
        }
        async Fri(t, i=!0) {
            Ha.zt(t);
            const e = t.split(".");
            let s;
            try {
                for (; e.length; ) {
                    const n = e.shift();
                    if (s = s ? s[n] : await this.Yri(n),
                    Ha.ub(s) || Ha.K9(s) || Ha.B9(s) || !0 === s || !1 === s)
                        return s;
                    if ((!s || "object" != typeof s) && i) {
                        if (this.c8)
                            return await this.c8.Fri(t);
                        if (!this.c8) {
                            const i = this.Wri();
                            for (const e of i) {
                                const i = await e.Fri(t, !1);
                                if (Ha.ub(i) || Ha.K9(i) || Ha.B9(i) || !0 === i || !1 === i)
                                    return i
                            }
                        }
                    }
                }
                return Ha.ub(s) || Ha.K9(s) || Ha.B9(s) || !0 === s || !1 === s ? s : void 0
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
        Ari(t) {
            Ha.Ef(t, il),
            t && (t.b8(this),
            this.jri.push(t))
        }
        Zri(t) {
            Ha.Ef(t, tl),
            t && (t.b8(this),
            this.$ri.push(t))
        }
        rni(t) {
            if (Ha.Ef(t, tl),
            t) {
                this.jri = this.jri.concat(t.Wri()),
                this.$ri = this.$ri.concat(t.E9());
                for (const t of this.jri)
                    t.b8(this);
                for (const t of this.$ri)
                    t.b8(this)
            }
        }
        async R9(t) {
            Ha.J1(t);
            let i = [];
            try {
                for (const e of this.Wri())
                    Ha.Bm(e, il) && (await e.Qri(t),
                    i = i.concat(e.Hri())),
                    Ha.ptt(e) && i.push(e);
                return il.Qri(t, i),
                i
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
        async thi(t) {
            Ha.J1(t);
            let i = [];
            try {
                for (const e of this.Wri())
                    Ha.Bm(e, il) && (await e.Qri(t),
                    i = i.concat(e.Hri())),
                    Ha.ptt(e) && i.push(e);
                for (const e of this.E9()) {
                    const s = await e.thi(t);
                    i = i.concat(s)
                }
                return il.Qri(t, i),
                i
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
        async ihi(t) {
            Ha.J1(t);
            let i = [];
            try {
                for (const e of this.Wri())
                    Ha.Bm(e, il) && (await e.Qri(t),
                    i = i.concat(e.Hri().map( (t, i) => ({
                        file: t,
                        index: i,
                        Dri: e
                    }))));
                for (const e of this.E9()) {
                    const s = await e.ihi(t);
                    i = i.concat(s)
                }
                return i
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
        async ehi() {
            const t = this.$ri;
            try {
                let i = "alphabetical";
                switch (t.every(t => {
                    const i = Number(Ha.w7(t.La()));
                    return Ha.ub(i)
                }
                ) && (i = "numerical"),
                i) {
                case "alphabetical":
                    t.sort( (t, i) => t.La().localeCompare(i.La()));
                    break;
                case "numerical":
                    t.sort( (t, i) => {
                        let e = Number(Ha.w7(t.La()))
                          , s = Number(Ha.w7(i.La()));
                        return Ha.ub(e) || (e = 0),
                        Ha.ub(s) || (s = 0),
                        e - s
                    }
                    )
                }
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
    }
    class il extends Ha.Me {
        constructor(t) {
            Ha.zt(t),
            super(),
            this.Ftt = t,
            this.Ett = [],
            this.zri = null,
            this.Vri = null,
            this.c8 = null
        }
        he() {
            Ha.Io(this.Ett),
            this.Ett = null,
            this.Ftt = null,
            this.zri = null,
            this.Vri = null,
            this.c8 = null
        }
        q5() {
            return !(this.Ett && this.Ett.length)
        }
        La() {
            return this.Ftt
        }
        Hri() {
            return this.Ett
        }
        Gri(t) {
            Ha.wut(t),
            t && this.Ett.push(t)
        }
        b8(t) {
            Ha.U(t, tl),
            this.c8 = t
        }
        Kri() {
            return !!this.zri
        }
        qri(t) {
            Ha.M4(t),
            this.zri = t
        }
        Xri() {
            return this.zri
        }
        static Qri(t, i, e, s) {
            Ha.J1(t),
            Ha.RH(i);
            try {
                let n = e || t.sort
                  , r = s || t.order;
                if (void 0 === t.shi && void 0 === e) {
                    i.every(t => {
                        const i = Number(Ha.w7(t.name));
                        return Ha.ub(i)
                    }
                    ) && (n = "numerical")
                }
                switch (n) {
                case "alphabetical":
                    switch (r) {
                    case "ascending":
                        i.sort( (t, i) => t.name.localeCompare(i.name));
                        break;
                    case "descending":
                        i.sort( (t, i) => t.name.localeCompare(i.name)),
                        i.reverse();
                        break;
                    default:
                        throw new Error(`invalid sort order "${r}", valid orders are "${qa}"`)
                    }
                    break;
                case "numerical":
                    switch (r) {
                    case "ascending":
                        i.sort( (t, i) => {
                            let e = Number(Ha.w7(t.name))
                              , s = Number(Ha.w7(i.name));
                            return Ha.ub(e) || (e = 0),
                            Ha.ub(s) || (s = 0),
                            e - s
                        }
                        );
                        break;
                    case "descending":
                        i.sort( (t, i) => {
                            let e = Number(Ha.w7(t.name))
                              , s = Number(Ha.w7(i.name));
                            return Ha.ub(e) || (e = 0),
                            Ha.ub(s) || (s = 0),
                            s - e
                        }
                        );
                        break;
                    default:
                        throw new Error(`invalid sort order "${r}", valid orders are "${qa}"`)
                    }
                    break;
                case "no-sort":
                    break;
                default:
                    throw new Error(`invalid sort mode "${n}", valid modes are "${Ka}"`)
                }
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
        async Qri(t) {
            Ha.J1(t);
            try {
                const i = await this.Fri("sort")
                  , e = await this.Fri("order");
                il.Qri(t, this.Ett, i, e)
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
        async Yri(t) {
            try {
                return await tl.prototype.Yri.call(this, t)
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
        async Fri(t, i=!0) {
            try {
                return await tl.prototype.Fri.call(this, t, i)
            } catch (t) {
                if (Ha.Bm(t, wl))
                    throw t
            }
        }
    }
    class el extends tl {
        constructor(t, i, e) {
            Ha.gL(t),
            Ha.gL(i),
            Ha.D_t(e),
            super(t || "root"),
            this.aGt = i,
            e && (1 === e.length && (this.aGt = "file"),
            this.jri = e)
        }
        W7() {
            return this.aGt
        }
        igt(t) {
            this.aGt = t
        }
        nhi() {
            if ("file" !== this.aGt)
                throw new Error("wrong type");
            return this.jri[0]
        }
    }
    async function sl(t, i) {
        if (Ha.RH(t),
        Ha.J1(i),
        !Ha.wtt(t, il))
            throw new Error("invalid file collection");
        try {
            for (const e of t)
                await e.Qri(i)
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t
        }
        return t
    }
    async function nl(t) {
        Ha.U(t, tl),
        await t.ehi()
    }
    async function rl(t, i) {
        if ("array" === i.result) {
            if (Ha.Bm(t, el))
                try {
                    return await t.thi(i)
                } catch (t) {
                    if (Ha.Bm(t, wl))
                        throw t
                }
            else if (Ha.B9(t))
                return il.Qri({
                    sort: "numerical",
                    order: "ascending",
                    shi: !0
                }, t),
                t;
            throw new Error("unexpected filter result")
        }
        if ("array-with-meta-info" === i.result) {
            if (Ha.Bm(t, el))
                try {
                    return await t.ihi(i)
                } catch (t) {
                    if (Ha.Bm(t, wl))
                        throw t
                }
            else if (Ha.B9(t))
                return il.Qri({
                    sort: "numerical",
                    order: "ascending",
                    shi: !0
                }, t),
                t.map( (t, i) => ({
                    file: t
                }));
            throw new Error("unexpected filter result")
        }
        if ("tree" === i.result) {
            if (Ha.Bm(t, el))
                return t;
            if (Ha.B9(t)) {
                il.Qri({
                    sort: "numerical",
                    order: "ascending",
                    shi: !0
                }, t);
                const i = Ha.v(el, null, "files", t);
                return Za.push(i),
                i
            }
            throw new Error("unexpected filter result")
        }
        if ("auto" === i.result)
            return t;
        throw new Error("unexpected result mode")
    }
    class hl extends Ha.Me {
        constructor(t) {
            super(),
            this.dmt = t
        }
        he() {
            this.dmt = null
        }
        rhi() {
            return !1
        }
        hhi() {
            return !0
        }
        ohi() {
            return Ha.Hti(this.dmt.name, "zip")
        }
        La() {
            return this.dmt.name
        }
        ahi() {
            return !!this.rhi() && "__MACOSX" === this.La()
        }
        async lhi() {}
        async nhi() {
            return this.dmt
        }
    }
    class ol extends hl {
        constructor(t) {
            super(t)
        }
        rhi() {
            return "directory" === this.dmt.kind
        }
        hhi() {
            return "file" === this.dmt.kind
        }
        ohi() {
            return "file" === this.dmt.kind && Ha.Hti(this.dmt.name, "zip")
        }
        La() {
            return this.dmt.name
        }
        async lhi() {
            try {
                if (this.ahi())
                    return null;
                const t = [];
                for await(const i of this.dmt.values())
                    t.push(i);
                return cl(t, "handles").filter(t => t)
            } catch (t) {
                return console.error(t),
                null
            }
        }
        async nhi() {
            try {
                return await this.dmt.getFile()
            } catch (t) {
                return console.error(t),
                null
            }
        }
    }
    class al extends hl {
        constructor(t) {
            super(t)
        }
        rhi() {
            return this.dmt.isDirectory
        }
        hhi() {
            return this.dmt.isFile
        }
        ohi() {
            return this.dmt.isFile && Ha.Hti(this.dmt.name, "zip")
        }
        La() {
            return this.dmt.name
        }
        async lhi() {
            return new Promise( (t, i) => {
                this.ahi() ? t(null) : this.dmt.createReader().readEntries(i => {
                    t(cl(i, "entries").filter(t => t))
                }
                , i => {
                    t(null)
                }
                )
            }
            )
        }
        async nhi() {
            return new Promise( (t, i) => {
                this.dmt.file(async i => {
                    t(i)
                }
                , i => {
                    t(null)
                }
                )
            }
            )
        }
    }
    class ll extends hl {
        constructor(t, i) {
            super(t),
            this.uhi = i
        }
        rhi() {
            return this.dmt.entry.directory
        }
        hhi() {
            return !this.dmt.entry.directory
        }
        ohi() {
            return !this.dmt.entry.directory && Ha.Hti(this.La(), "zip")
        }
        La() {
            return Ha.qti(this.dmt.entry.filename).Xti
        }
        async lhi() {
            return new Promise( (t, i) => {
                if (this.ahi())
                    t(null);
                else
                    try {
                        t(cl(this.dmt.children, "zip-entries", this.uhi).filter(t => t))
                    } catch (i) {
                        console.error(i),
                        t(null)
                    }
            }
            )
        }
        async nhi() {
            const t = await this.uhi.Gct(this.dmt.entry);
            return Ha.Mct([t], this.La(), {
                type: t.type
            })
        }
        he() {
            this.uhi.he(),
            this.uhi = null,
            super.he()
        }
    }
    const ul = [];
    function cl(t, i, ...e) {
        if (Ha.zt(i),
        t = Array.from(t),
        "handles" === i) {
            const i = t.map(t => Ha.v(ol, t));
            return ul.push(...i),
            i
        }
        if ("entries" === i) {
            const i = t.map(t => Ha.v(al, t));
            return ul.push(...i),
            i
        }
        if ("zip-entries" === i) {
            const i = t.map(t => Ha.v(ll, t, ...e));
            return ul.push(...i),
            i
        }
        if ("files" === i) {
            const i = t.map(t => Ha.v(hl, t));
            return ul.push(...i),
            i
        }
        throw new Error("unexpected filter result type")
    }
    async function dl(t, i, e, s) {
        Ha.QH(t, hl),
        Ha.U(i, tl),
        Ha.J1(e),
        Ha.zt(s);
        try {
            const n = Ha.v(il, s);
            i.Ari(n);
            for (let r = 0; r < t.length; r++) {
                const h = t[r];
                if (e.Iri && Ha.Kti(e.Iri, h.La()) && !n.Kri()) {
                    const t = await fl(h);
                    n.qri(t),
                    i.qri(t)
                } else if (e.F9 && "all" === e.j9 && h.ohi()) {
                    const t = await ml(h, e, i);
                    i.rni(t)
                } else if (e.F9 && "root-only" === e.j9 && "" === s && h.ohi()) {
                    const t = await ml(h, e, i);
                    i.rni(t)
                } else if (h.rhi()) {
                    const t = await pl(h, e, i);
                    i.Zri(t)
                } else if (h.hhi()) {
                    const t = await fl(h, e);
                    n.Gri(t)
                }
            }
            return await nl(i),
            await sl(i.Wri(), e)
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t
        }
    }
    async function fl(t, i) {
        Ha.U(t, hl),
        Ha.ML(i);
        try {
            const e = await t.nhi();
            if (!e)
                return null;
            if (0 === e.size)
                return null;
            if (i && !i.filter(e))
                return null;
            if (i && !await i.Ptt(e))
                return null;
            if (Ha.act(e)) {
                if (!await Ha.e7(e))
                    return null
            } else if (Ha.chi(e)) {
                const t = await Ha.r7(e)
                  , i = await Ha.o7(e);
                if (!t && i)
                    ;
                else if (t && i)
                    ;
                else if (!t || i)
                    return null
            } else if (Ha.dhi(e)) {
                if (!await Ha.o7(e))
                    return null
            } else if (Ha.fhi(e)) {
                if (!await Ha.Ket(e))
                    return null
            } else if (Ha.Jri(e)) {
                if (!await Ha.phi(e))
                    return null
            } else if (Ha.mhi(e)) {
                if (!await Ha.whi(e))
                    return null
            }
            return await Ha.qii(e)
        } catch (t) {
            return console.error(t),
            null
        }
    }
    async function pl(t, i, e) {
        Ha.U(t, hl),
        Ha.J1(i),
        Ha.U(e, tl);
        try {
            const s = Ha.v(tl, t.La());
            s.b8(e);
            const n = await t.lhi();
            return await dl(n, s, i, t.La()),
            s
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t;
            return console.error(t),
            null
        }
    }
    async function ml(t, i, e) {
        Ha.U(t, hl),
        Ha.J1(i),
        Ha.U(e, tl);
        try {
            const s = Ha.v(tl, Ha.w7(t.La()));
            s.b8(e);
            const n = await fl(t)
              , r = new Ha.u7;
            Qa.push(r),
            await r._ct(n);
            const h = cl(r.ghi(), "zip-entries", r);
            return await dl(h, s, i, s.La()),
            s
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t;
            return null
        }
    }
    class wl extends Error {
        constructor(t, i) {
            super(t),
            this.det = i
        }
        get file() {
            return this.det
        }
    }
    class gl extends wl {
        constructor(t) {
            super("config-file-unsupported-format", t)
        }
    }
    class yl extends wl {
        constructor(t) {
            super("config-file-json-parse-error", t)
        }
    }
    function bl(t) {
        if (Ha.ML(t),
        t = Object.assign({}, Ja, t),
        !Ha.w9(t.filter))
            throw new Error('"filter" option must be a function');
        if (!Ha.w9(t.Ptt))
            throw new Error('"asyncFilter" option must be a function');
        if (t.Iri && !Ha.K9(t.Iri))
            throw new Error('"meta_info_file" option must be a string');
        if (!Ka.includes(t.sort))
            throw new Error(`invalid "sort" value, valid values are ${Ka}`);
        if (!qa.includes(t.order))
            throw new Error(`invalid "order" value, valid values are ${qa}`);
        if (!Xa.includes(t.result))
            throw new Error(`invalid "result" value, valid values are ${Xa}`);
        if (!Ya.includes(t.j9))
            throw new Error(`invalid "extractMode" value, valid values are ${Ya}`);
        return t
    }
    async function vl(t, i) {
        return Ha.Rti(t, DataTransfer),
        i = bl(i),
        await Sl(t.items, t, i)
    }
    async function Sl(t, i, e) {
        Ha.J1(e);
        const s = Array.from(t);
        if (!s.length)
            return Promise.resolve(!1);
        const n = s[0];
        if (n.webkitGetAsEntry || n.getAsEntry)
            for (let t = 0; t < s.length; t++) {
                const i = s[t];
                let r;
                if (n.webkitGetAsEntry ? r = i.webkitGetAsEntry() : n.getAsEntry && (r = i.getAsEntry()),
                r) {
                    if (r && r.isDirectory)
                        return Promise.resolve(!0);
                    if (e.F9 && r && r.isFile && Ha.Hti(r.name, "zip"))
                        return Promise.resolve(!0)
                }
            }
        else {
            if (n.getAsFileSystemHandle) {
                const t = [];
                for (let i = 0; i < s.length; i++) {
                    const e = s[i];
                    t.push(e.getAsFileSystemHandle())
                }
                const n = await Promise.all(t);
                return i.c3_filesystem_handles = n,
                n.some(t => {
                    if (t) {
                        if ("directory" === t.kind)
                            return !0;
                        if (e.F9 && "file" === t.kind && Ha.Hti(t.name, "zip"))
                            return !0
                    }
                }
                )
            }
            if (Ha.ptt(n) && e.F9)
                for (const t of s)
                    if (Ha.Hti(t.name, "zip"))
                        return Promise.resolve(!0)
        }
        return Promise.resolve(!1)
    }
    async function xl(t, i) {
        Ha.J1(i),
        i = bl(i);
        try {
            const e = Array.from(t).filter(t => 0 !== t.size).filter(t => i.filter(t)).map(async t => {
                if (!await i.Ptt(t))
                    return null;
                if (Ha.act(t)) {
                    if (!await Ha.e7(t))
                        return null
                } else if (Ha.chi(t)) {
                    const i = await Ha.r7(t)
                      , e = await Ha.o7(t);
                    if (!i && e)
                        ;
                    else if (i && e)
                        ;
                    else if (!i || e)
                        return null
                } else if (Ha.dhi(t)) {
                    if (!await Ha.o7(t))
                        return null
                } else if (Ha.fhi(t)) {
                    if (!await Ha.Ket(t))
                        return null
                } else if (Ha.Jri(t)) {
                    if (!await Ha.phi(t))
                        return null
                } else if (Ha.mhi(t)) {
                    if (!await Ha.whi(t))
                        return null
                }
                try {
                    return await Ha.qii(t)
                } catch (t) {
                    return console.error(t),
                    null
                }
            }
            )
              , s = (await Promise.all(e)).filter(t => t);
            return await rl(s, i)
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t
        }
    }
    async function Ml(t, i, e) {
        Ha.U(i, tl),
        Ha.ML(e),
        e = bl(e);
        const s = cl(t, i.W7());
        try {
            return await dl(s, i, e, ""),
            i.igt("directories"),
            await rl(i, e)
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t
        }
    }
    async function El(t, i) {
        Ha.Rti(t, DataTransfer),
        Ha.ML(i),
        i = bl(i);
        let e = !1;
        if (t.c3_filesystem_handles && (e = t.c3_filesystem_handles.every(t => !t)),
        t.c3_filesystem_handles && !e) {
            const e = t.c3_filesystem_handles.map(t => t.getFile())
              , s = await Promise.all(e);
            return await xl(s, i)
        }
        return await xl(t.files, i)
    }
    async function Cl(t, i) {
        Ha.Rti(t, DataTransfer),
        Ha.ML(i),
        i = bl(i);
        const e = Ha.v(el);
        Za.push(e);
        const s = t.items[0];
        let n = null;
        try {
            if (t.c3_filesystem_handles)
                e.igt("handles"),
                n = await Ml(t.c3_filesystem_handles, e, i);
            else if (s.getAsFileSystemHandle) {
                e.igt("handles");
                const s = Array.from(t.items).map(t => t.getAsFileSystemHandle())
                  , r = await Promise.all(s);
                t.c3_filesystem_handles = r,
                n = await Ml(r, e, i)
            } else if (s.webkitGetAsEntry) {
                e.igt("entries");
                const s = Array.from(t.items).map(t => t.webkitGetAsEntry()).filter(t => !!t);
                n = await Ml(s, e, i)
            }
            if (!e.W7())
                throw new Error("data transfer has no entries");
            return e.igt("directories"),
            await rl(e, i)
        } catch (t) {
            if (Ha.Bm(t, wl))
                throw t
        }
    }
}
{
    const _l = self.t;
    _l.e7 = async function(t) {
        if (_l.M4(t),
        !_l.act(t))
            return !1;
        const i = t.slice(0, 8)
          , e = new DataView(await i.arrayBuffer());
        switch (_l.MimeType.yhi(t)) {
        case "image/png":
        case "image/apng":
            return 2303741511 === e.getUint32(0) && 218765834 === e.getUint32(4);
        case "image/jpeg":
            return 255 === e.getUint8(0) && 216 === e.getUint8(1) && 255 === e.getUint8(2);
        case "image/webp":
            return 1380533830 === e.getUint32(0);
        case "image/gif":
            return 1195984440 === e.getUint32(0);
        case "image/bmp":
            return 16973 === e.getUint16(0);
        case "image/x-icon":
            return 256 === e.getUint32(0);
        case "image/svg+xml":
            try {
                const i = await _l.Ist(t)
                  , e = new self.DOMParser;
                return 0 === e.parseFromString(i, "image/svg+xml").getElementsByTagName("parsererror").length
            } catch (t) {
                return !1
            }
        case "image/avif":
        case "image/tiff":
        case "image/jxl":
            {
                const i = self.URL.createObjectURL(t);
                let e = new Image;
                e.src = i;
                try {
                    return await e.decode(),
                    URL.revokeObjectURL(i),
                    e = null,
                    !0
                } catch (t) {
                    return URL.revokeObjectURL(i),
                    e = null,
                    !1
                }
            }
        default:
            return !1
        }
    }
    ,
    _l.act = function(t) {
        return _l.M4(t),
        t.type ? -1 !== t.type.search(/image\/.*/) : _l.Kst(t.name)
    }
    ,
    _l.Kst = function(t) {
        _l.zt(t);
        return -1 !== _l.MimeType.Hst(_l.l7(t)).eEt().search(/image\/.*/)
    }
    ,
    _l.r7 = async function(t) {
        if (_l.M4(t),
        !_l.chi(t) && !_l.dhi(t))
            return !1;
        const i = t.slice(0, 128)
          , e = new DataView(await i.arrayBuffer());
        switch (_l.MimeType.yhi(t)) {
        case "audio/ogg":
        case "video/ogg":
            if (1332176723 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer()
                      , e = (new TextDecoder).decode(i);
                    if (e.includes("OpusHead") || e.includes("vorbis") && !e.includes("theora"))
                        return !0
                } catch (t) {}
            return !1;
        case "audio/webm":
        case "video/webm":
            if (440786851 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer()
                      , e = (new TextDecoder).decode(i);
                    if (e.includes("A_OPUS") || e.includes("A_VORBIS") && !(e.includes("V_VP8") || e.includes("V_VP9") || e.includes("V_AV1")))
                        return !0
                } catch (t) {}
            return !1;
        case "audio/wav":
        case "audio/x-wav":
            return 1380533830 === e.getUint32(0, !1) && 1463899717 === e.getUint32(8, !1);
        case "audio/flac":
            return 1716281667 === e.getUint32(0, !1);
        case "audio/mpeg":
        case "video/mpeg":
            try {
                const i = await t.slice(0, 65536).arrayBuffer()
                  , e = new DataView(i);
                let s = 0;
                if (73 === e.getUint8(0) && 68 === e.getUint8(1) && 51 === e.getUint8(2)) {
                    s = 10 + ((127 & e.getUint8(6)) << 21 | (127 & e.getUint8(7)) << 14 | (127 & e.getUint8(8)) << 7 | 127 & e.getUint8(9))
                }
                if (s + 1 >= e.byteLength)
                    return !1;
                const n = e.getUint8(s)
                  , r = e.getUint8(s + 1);
                return 255 === n && !(224 & ~r)
            } catch (t) {}
            return !1;
        case "audio/midi":
        case "audio/x-midi":
            return 1297377380 === e.getUint32(0, !1);
        case "audio/mp4":
        case "video/mp4":
            if (1718909296 === !e.getUint32(4, !1))
                return !1;
        default:
            {
                const i = new Promise(i => {
                    const e = document.createElement("audio")
                      , s = URL.createObjectURL(t);
                    e.preload = "metadata";
                    const n = t => {
                        e.removeEventListener("loadedmetadata", r),
                        e.removeEventListener("error", h),
                        URL.revokeObjectURL(s),
                        e.pause(),
                        e.removeAttribute("src"),
                        e.load(),
                        i(t)
                    }
                      , r = () => n(!0)
                      , h = () => n(!1);
                    e.addEventListener("loadedmetadata", r),
                    e.addEventListener("error", h),
                    e.src = s
                }
                )
                  , e = new Promise(i => {
                    const e = document.createElement("video")
                      , s = URL.createObjectURL(t);
                    e.preload = "metadata";
                    const n = t => {
                        const n = e.videoWidth
                          , o = e.videoHeight
                          , a = _l.ub(n) && n > 0 && _l.ub(o) && o > 0;
                        e.removeEventListener("loadedmetadata", r),
                        e.removeEventListener("error", h),
                        URL.revokeObjectURL(s),
                        e.pause(),
                        e.removeAttribute("src"),
                        e.load(),
                        i(a)
                    }
                      , r = () => n()
                      , h = () => n();
                    e.addEventListener("loadedmetadata", r),
                    e.addEventListener("error", h),
                    e.src = s
                }
                )
                  , s = await Promise.all([i, e]);
                return s[0] && !s[1]
            }
        }
    }
    ,
    _l.chi = function(t) {
        return _l.M4(t),
        t.type ? -1 !== t.type.search(/audio\/.*/) || (-1 !== t.type.search(/ogg/) || -1 !== t.type.search(/webm/)) : _l.Jst(t.name)
    }
    ,
    _l.Jst = function(t) {
        _l.zt(t);
        const i = _l.MimeType.Hst(_l.l7(t)).eEt();
        return -1 !== i.search(/audio\/.*/) || (-1 !== i.search(/ogg/) || -1 !== i.search(/webm/))
    }
    ,
    _l.o7 = async function(t) {
        if (_l.M4(t),
        !_l.chi(t) && !_l.dhi(t))
            return !1;
        const i = t.slice(0, 128)
          , e = new DataView(await i.arrayBuffer());
        switch (_l.MimeType.yhi(t)) {
        case "video/webm":
        case "audio/webm":
            if (440786851 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer()
                      , e = (new TextDecoder).decode(i);
                    if (e.includes("V_VP8") || e.includes("V_VP9") || e.includes("V_AV1"))
                        return !0
                } catch (t) {}
            return !1;
        case "video/ogg":
        case "audio/ogg":
            if (1332176723 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer();
                    if ((new TextDecoder).decode(i).includes("theora"))
                        return !0
                } catch (t) {}
            return !1;
        case "video/avi":
        case "video/x-msvideo":
            return 1380533830 === e.getUint32(0, !1) && 1096173856 === e.getUint32(8, !1);
        case "video/mpeg":
        case "audio/mpeg":
            try {
                const i = await t.slice(0, 65536).arrayBuffer()
                  , e = new DataView(i);
                if (442 !== e.getUint32(0, !1))
                    return !1;
                for (let t = 4; t < e.byteLength - 3; t++)
                    if (0 === e.getUint8(t) && 0 === e.getUint8(t + 1) && 1 === e.getUint8(t + 2) && e.getUint8(t + 3) >= 224 && e.getUint8(t + 3) <= 239)
                        return !0
            } catch (t) {}
            return !1;
        case "video/quicktime":
        case "video/mp4":
        case "audio/mp4":
            if (1718909296 !== e.getUint32(4, !1))
                return !1;
        default:
            return new Promise(i => {
                const e = document.createElement("video")
                  , s = URL.createObjectURL(t);
                e.preload = "metadata";
                const n = t => {
                    const n = e.videoWidth
                      , o = e.videoHeight
                      , a = _l.ub(n) && n > 0 && _l.ub(o) && o > 0;
                    e.removeEventListener("loadedmetadata", r),
                    e.removeEventListener("error", h),
                    URL.revokeObjectURL(s),
                    e.pause(),
                    e.removeAttribute("src"),
                    e.load(),
                    i(a)
                }
                  , r = () => n()
                  , h = () => n();
                e.addEventListener("loadedmetadata", r),
                e.addEventListener("error", h),
                e.src = s
            }
            )
        }
    }
    ,
    _l.dhi = function(t) {
        return _l.M4(t),
        t.type ? -1 !== t.type.search(/video\/.*/) || (-1 !== t.type.search(/ogg/) || -1 !== t.type.search(/webm/)) : _l.Wst(t.name)
    }
    ,
    _l.Wst = function(t) {
        _l.zt(t);
        const i = _l.MimeType.Hst(_l.l7(t)).eEt();
        return -1 !== i.search(/video\/.*/) || (-1 !== i.search(/ogg/) || -1 !== i.search(/webm/))
    }
    ;
    const Tl = new Map;
    _l.bhi = async function(t) {
        if (Tl.has(t.name))
            return Tl.get(t.name);
        try {
            if (await _l.Ket(t) && Tl.has(t.name))
                return Tl.get(t.name)
        } catch (t) {}
    }
    ,
    _l.Ket = async function(t) {
        if (_l.M4(t),
        !_l.fhi(t))
            return !1;
        if (Tl.has(t.name))
            return !0;
        const i = t.slice(0, 12)
          , e = new DataView(await i.arrayBuffer());
        let s = !1;
        switch (_l.MimeType.yhi(t)) {
        case "application/font-woff":
            2001684038 === e.getUint32(0, !1) && (s = !0);
            break;
        case "font/woff2":
            2001684018 === e.getUint32(0, !1) && (s = !0);
            break;
        case "application/font-sfnt":
            {
                const t = e.getUint32(0, !1);
                65536 !== t && 1330926671 !== t || (s = !0);
                break
            }
        case "application/vnd.ms-fontobject":
            if (e.byteLength >= 36) {
                const i = t.slice(34, 36)
                  , e = new DataView(await i.arrayBuffer()).getUint16(0, !0);
                1 !== e && 2 !== e || (s = !0);
                break
            }
        }
        if (s) {
            const i = URL.createObjectURL(t);
            try {
                const e = new globalThis.FontFace(t.name,`url(${i})`);
                return await e.load(),
                Tl.set(t.name, e),
                !0
            } catch (t) {
                return !1
            } finally {
                URL.revokeObjectURL(i)
            }
        }
        return !1
    }
    ,
    _l.fhi = function(t) {
        return _l.M4(t),
        t.type ? t.type.includes("font") : _l.Qst(t.name)
    }
    ,
    _l.Qst = function(t) {
        _l.zt(t);
        return _l.MimeType.Hst(_l.l7(t)).DAt()
    }
    ,
    _l.Zet = function(t) {
        if (_l.M4(t),
        t.type) {
            const i = _l.MimeType.qs(t.type);
            return i.vst() || i.Pst()
        }
        return _l.Xst(t.name)
    }
    ,
    _l.Xst = function(t) {
        _l.zt(t);
        const i = _l.MimeType.Hst(_l.l7(t));
        return i.vst() || i.Pst()
    }
    ,
    _l.n7 = function(t) {
        return _l.zt(t),
        _l.MimeType.Hst(_l.l7(t)).vst()
    }
    ,
    _l.a7 = function(t) {
        return _l.zt(t),
        _l.MimeType.Hst(_l.l7(t)).Pst()
    }
    ,
    _l.ret = function(t) {
        _l.zt(t);
        return _l.MimeType.Hst(_l.l7(t)).vhi()
    }
    ,
    _l.Yst = function(t) {
        _l.zt(t);
        const i = _l.l7(t)
          , e = _l.MimeType.Hst(i).eEt();
        return "application/zip" === e && ".c3p" === i || "application/octet-stream" === e && ".c3p" === i
    }
    ,
    _l.tet = function(t) {
        _l.zt(t);
        const i = _l.l7(t)
          , e = _l.MimeType.Hst(i).eEt();
        return "application/zip" === e && ".capx" === i || "application/octet-stream" === e && ".capx" === i
    }
    ,
    _l.eet = function(t) {
        _l.zt(t);
        const i = _l.l7(t)
          , e = _l.MimeType.Hst(i).eEt();
        return "application/x-construct3-addon" === e && ".c3addon" === i || "application/octet-stream" === e && ".c3addon" === i
    }
    ,
    _l.iet = function(t) {
        _l.zt(t);
        const i = _l.l7(t)
          , e = _l.MimeType.Hst(i).eEt();
        return "application/x-construct2-addon" === e && ".c2addon" === i || "application/octet-stream" === e && ".c2addon" === i
    }
    ,
    _l.A9 = async function(t) {
        if (_l.M4(t),
        !_l.Shi(t))
            return !1;
        const i = new Uint8Array(await t.slice(0, 4).arrayBuffer()).join(" ");
        return ["80 75 3 4", "80 75 5 6", "80 75 7 8"].includes(i)
    }
    ,
    _l.Shi = function(t) {
        return _l.M4(t),
        t.type ? !!t.type.match("zip") : _l.met(t.name)
    }
    ,
    _l.met = function(t) {
        _l.zt(t);
        const i = _l.l7(t)
          , e = _l.MimeType.Hst(i).eEt();
        return "application/zip" === e && ".zip" === i || "application/octet-stream" === e && ".zip" === i
    }
    ,
    _l.phi = async function(t) {
        _l.M4(t);
        try {
            const i = await _l.Ist(t);
            return JSON.parse(i)
        } catch (t) {
            return !1
        }
    }
    ,
    _l.Jri = function(t) {
        return _l.M4(t),
        t.type ? !!t.type.match("json") : _l.xhi(t.name)
    }
    ,
    _l.xhi = function(t) {
        _l.zt(t);
        return !!_l.MimeType.Hst(_l.l7(t)).eEt().match("json")
    }
    ,
    _l.whi = async function(t) {
        if (_l.M4(t),
        !_l.mhi(t))
            return !1;
        try {
            const i = await _l.Ist(t);
            return !(new DOMParser).parseFromString(i, "application/xml").querySelector("parsererror")
        } catch (t) {
            return !1
        }
    }
    ,
    _l.mhi = function(t) {
        return _l.M4(t),
        t.type ? !!t.type.match("text/xml") || "text/xml" === t.type : _l.xhi(t.name)
    }
    ,
    _l.Mhi = function(t) {
        _l.zt(t);
        const i = _l.MimeType.Hst(_l.l7(t)).eEt();
        return !!i.match("text/xml") || "text/xml" === i
    }
    ,
    _l.xtt = async function(t) {
        if (_l.M4(t),
        !_l.i7(t))
            return !1;
        try {
            const i = await _l.Ist(t)
              , e = new self.DOMParser;
            return 0 === e.parseFromString(i, "image/svg+xml").getElementsByTagName("parsererror").length
        } catch (t) {
            return !1
        }
    }
    ,
    _l.i7 = function(t) {
        return _l.M4(t),
        t.type ? !!t.type.match("image/svg+xml") || "image/svg+xml" === t.type : _l.vtt(t.name)
    }
    ,
    _l.vtt = function(t) {
        _l.zt(t);
        const i = _l.MimeType.Hst(_l.l7(t)).eEt();
        return !!i.match("image/svg+xml") || "image/svg+xml" === i
    }
    ,
    _l.Ehi = function(t) {
        return _l.M4(t),
        _l.MimeType.Chi(t).fst()
    }
    ,
    _l.tW = async function(t) {
        return _l.M4(t),
        t.type ? _l.MimeType.qs(t.type)._hi() : _l.MimeType.Hst(_l.l7(t.name))._hi()
    }
    ,
    _l.Zst = function(t) {
        _l.zt(t);
        const i = _l.MimeType.Hst(_l.l7(t));
        return i?._hi()
    }
    ,
    _l.s7 = async function(t) {
        if (_l.M4(t),
        !_l.act(t))
            return !1;
        const i = await t.slice(0, 32768).arrayBuffer()
          , e = new DataView(i)
          , s = new TextDecoder("utf-8")
          , n = new Uint8Array(i)
          , r = s.decode(n.subarray(0, 6));
        if ("GIF89a" === r || "GIF87a" === r) {
            let t = 6
              , e = 0;
            for (; t + 1 < i.byteLength; ) {
                if (33 === n[t] && 249 === n[t + 1] && (e++,
                e > 1))
                    return !0;
                t++
            }
            return !1
        }
        if ([137, 80, 78, 71, 13, 10, 26, 10].every( (t, i) => n[i] === t)) {
            let t = 8;
            for (; t + 8 <= i.byteLength && !(t + 8 > i.byteLength); ) {
                const r = e.getUint32(t, !1)
                  , h = s.decode(n.subarray(t + 4, t + 8));
                if (r > i.byteLength - t - 12)
                    break;
                if ("acTL" === h)
                    return !0;
                if ("IDAT" === h || "IEND" === h)
                    break;
                t += 8 + r + 4
            }
            return !1
        }
        const h = s.decode(n.subarray(0, 4))
          , o = s.decode(n.subarray(8, 12));
        if ("RIFF" === h && "WEBP" === o) {
            let t = 12;
            for (; t + 8 <= i.byteLength; ) {
                const r = s.decode(n.subarray(t, t + 4))
                  , h = e.getUint32(t + 4, !0);
                if (h > i.byteLength - t - 8)
                    break;
                if ("ANIM" === r)
                    return !0;
                t += 8 + h + h % 2
            }
            return !1
        }
        return !1
    }
    ,
    _l.wst = async function(t) {
        _l.M4(t);
        const i = await t.slice(0, 1024).arrayBuffer()
          , e = new globalThis.Uint8Array(i);
        try {
            const t = new TextDecoder("utf-8",{
                fatal: !0
            }).decode(e)
              , i = (new TextEncoder).encode(t);
            if (i.length !== e.length)
                return !1;
            for (let t = 0; t < i.length; t++)
                if (i[t] !== e[t])
                    return !1;
            return !0
        } catch (t) {
            return !1
        }
    }
}
{
    const Il = self.t
      , Pl = self.assert
      , Gl = new Map;
    Il.Thi = class {
        static C6(t, i) {
            Gl.set(t, i)
        }
        static Ihi(t, i) {
            Il.zt(t),
            Il.nu(i);
            const e = Gl.get(t);
            return Pl(e, `missing ignore function for user '${t}'`),
            new Promise(async (t, s) => {
                if (!e())
                    return void s("ignore-results");
                const n = await i();
                e() ? t(n) : s("ignore-results")
            }
            )
        }
        static Phi(t, i) {
            if (Il.tot(i),
            Il.Bm(t, Error)) {
                if ("ignore-results" !== t.message) {
                    if (!i)
                        throw t;
                    i(t)
                }
            } else {
                if (!Il.K9(t))
                    throw new Error("missing error argument");
                if ("ignore-results" !== t) {
                    const e = new Error(t);
                    if (!i)
                        throw e;
                    i(e)
                }
            }
        }
    }
}
{
    const Al = self.t
      , Rl = Al.uX;
    function kl(t, i, e, s) {
        return Al.Ge(t),
        Al.Ge(i),
        Al.Ge(e),
        Al.Ge(s),
        !(s < t) && !(i < e)
    }
    function Ol(t, i, e, s, n, r) {
        Al.U(t, Rl),
        Al.U(i, Rl),
        Al.QH(e, Rl),
        Al.QH(s, Rl),
        Al.U(n, Rl),
        Al.Ef(r, Ul);
        const h = [0, 0]
          , o = [0, 0]
          , a = new Rl;
        a.Qr(i),
        a.offset(-t.qX(), -t.QX());
        const l = a.dot(n);
        if (Fl(e, n, h),
        Fl(s, n, o),
        o[0] += l,
        o[1] += l,
        h[0] > o[1] || o[0] > h[1])
            return !0;
        if (!r)
            return !1;
        let u = 0;
        if (h[0] < o[0])
            if (h[1] < o[1])
                u = h[1] - o[0];
            else {
                const t = h[1] - o[0]
                  , i = o[1] - h[0];
                u = t < i ? t : -i
            }
        else if (h[1] > o[1])
            u = h[0] - o[1];
        else {
            const t = h[1] - o[0]
              , i = o[1] - h[0];
            u = t < i ? t : -i
        }
        const c = Math.abs(u);
        return c < r.Ghi() && (r.Ahi(c),
        r.Rhi().Qr(n),
        u < 0 && r.Rhi().reverse()),
        !1
    }
    function Dl(t, i, e) {
        Al.U(t, Ll),
        Al.U(i, Ll),
        Al.Ef(e, Ul);
        const s = t.khi()
          , n = s.length
          , r = i.khi()
          , h = r.length
          , o = t.XFt()
          , a = i.XFt()
          , l = t.Ohi()
          , u = i.Ohi();
        for (let t = 0; t < n; t++)
            if (Ol(o, a, s, r, l[t], e))
                return !1;
        for (let t = 0; t < h; t++)
            if (Ol(o, a, s, r, u[t], e))
                return !1;
        if (e) {
            e.Dhi(t),
            e.Fhi(i);
            const s = e.Lkt();
            s.Qr(e.Rhi()),
            s.scale(e.Ghi(), e.Ghi())
        }
        return !0
    }
    function Fl(t, i, e) {
        Al.QH(t, Rl),
        Al.U(i, Rl),
        Al.RH(e),
        Al.Ge(e[0]),
        Al.Ge(e[1]);
        let s = Number.MAX_VALUE
          , n = -Number.MAX_VALUE;
        const r = t.length;
        for (let e = 0; e < r; e++) {
            const r = t[e].dot(i);
            r < s && (s = r),
            r > n && (n = r)
        }
        e[0] = s,
        e[1] = n
    }
    class Ll {
        constructor(t, i, e) {
            Al.Ge(t),
            Al.Ge(i),
            Al.QH(e, Rl),
            this.Lhi = new Rl(t,i),
            this.Bhi = null,
            this.Uhi = new Rl,
            this.Nhi = new Rl,
            this.jhi = null,
            this.$hi = null,
            this.zhi = null,
            this.Vhi(e)
        }
        he() {
            this.Lhi = null,
            this.Uhi = null,
            this.Nhi = null,
            Al.Io(this.Bhi),
            this.Bhi = null,
            this.Uhi = null,
            Al.Io(this.jhi),
            this.jhi = null,
            Al.Io(this.$hi),
            this.$hi = null,
            Al.Io(this.zhi),
            this.zhi = null
        }
        XFt() {
            return this.Lhi
        }
        Whi() {
            return this.Uhi
        }
        Ohi() {
            return this.zhi
        }
        Hhi() {
            return this.$hi
        }
        khi() {
            return this.jhi
        }
        Vhi(t) {
            if (!this.Bhi || this.Bhi.length !== t.length) {
                var i = this.jhi = []
                  , e = this.$hi = []
                  , s = this.zhi = [];
                for (let n = 0; n < t.length; n++)
                    i.push(new Rl),
                    e.push(new Rl),
                    s.push(new Rl)
            }
            this.Bhi = t,
            this.fh()
        }
        gt() {
            this.Uhi.set(this.Lhi.qX(), this.Lhi.QX())
        }
        $Ft() {
            this.Uhi.set(0, 0)
        }
        brt() {
            this.Nhi.set(this.Lhi.qX(), this.Lhi.QX())
        }
        $Y() {
            this.Lhi.set(this.Nhi.qX(), this.Nhi.QX()),
            this.Nhi.set(0, 0)
        }
        KFt(t, i) {
            Al.Ge(t),
            Al.Ge(i),
            this.Lhi.set(this.Uhi.qX() + t, this.Uhi.QX() + i)
        }
        PSt(t, i) {
            Al.Ge(t),
            Al.Ge(i),
            this.Lhi.offset(t, i)
        }
        fh() {
            const t = this.jhi
              , i = this.$hi
              , e = this.zhi
              , s = this.Bhi
              , n = s.length;
            for (let i = 0; i < n; i++)
                t[i].Qr(s[i]);
            for (let s = 0; s < n; s++) {
                var r = t[s]
                  , h = s < n - 1 ? t[s + 1] : t[0]
                  , o = i[s];
                o.Qr(h),
                o.offset(-r.qX(), -r.QX());
                const a = e[s];
                a.Qr(o),
                a.psi(),
                a.normalize()
            }
        }
    }
    class Bl extends Ll {
        constructor(t, i, e, s) {
            Al.Ge(t),
            Al.Ge(i),
            Al.Ge(e),
            Al.Ge(s),
            super(t, i, [new Rl, new Rl(e,0), new Rl(e,s), new Rl(0,s)]),
            this.$c = null,
            this.Khi = new Rl,
            this.qhi = new Rl,
            this.Xhi = !0
        }
        static zkt(t) {
            return Al.U(t, Al.Rect),
            new Bl(t.Yr(),t.Jr(),t.width(),t.height())
        }
        I2(t) {
            this.Xhi = !!t
        }
        mce() {
            return this.Xhi
        }
        LH() {
            const t = this.Lhi.qX()
              , i = this.Lhi.QX()
              , e = this.$c.qX()
              , s = this.$c.QX()
              , n = new Al.zce.$ce(t,i,e,s);
            return n.Khi = new Rl(this.Khi.qX(),this.Khi.QX()),
            n.qhi = new Rl(this.qhi.qX(),this.qhi.QX()),
            n.Set(t, i, e, s),
            n
        }
        Set(t, i, e, s) {
            this.Lhi.set(t, i),
            this.Bhi[0].set(0, 0),
            this.Bhi[1].set(e, 0),
            this.Bhi[2].set(e, s),
            this.Bhi[3].set(0, s),
            this.$c = this.Bhi[2],
            this.fh()
        }
        USt(t) {
            this.Lhi.set(t.Lhi.qX(), t.Lhi.QX()),
            this.Bhi[0].set(0, 0),
            this.Bhi[1].set(t.$c.qX(), 0),
            this.Bhi[2].set(t.$c.qX(), t.$c.QX()),
            this.Bhi[3].set(0, t.$c.QX()),
            this.$c = this.Bhi[2],
            this.fh()
        }
        zo() {
            return this.$c
        }
        Yhi() {
            return this.Khi
        }
        gt() {
            super.gt(),
            this.Khi.set(this.$c.qX(), this.$c.QX())
        }
        $Ft() {
            super.$Ft(),
            this.Khi.set(0, 0)
        }
        brt() {
            super.brt(),
            this.qhi.set(this.$c.qX(), this.$c.QX())
        }
        $Y() {
            super.$Y(),
            this.Bhi[1].set(this.qhi.qX(), 0),
            this.Bhi[2].set(this.qhi.qX(), this.qhi.QX()),
            this.Bhi[3].set(0, this.qhi.QX()),
            this.qhi.set(0, 0),
            this.fh()
        }
        ySt(t, i) {
            Al.Ge(t),
            Al.Ge(i),
            this.Bhi[1].set(this.Khi.qX() + t, 0),
            this.Bhi[2].set(this.Khi.qX() + t, this.Khi.QX() + i),
            this.Bhi[3].set(0, this.Khi.QX() + i),
            this.fh()
        }
        wI(t, i) {
            Al.Ge(t),
            Al.Ge(i),
            this.Bhi[1].offset(t, 0),
            this.Bhi[2].offset(t, i),
            this.Bhi[3].offset(0, i),
            this.fh()
        }
    }
    class Ul {
        constructor() {
            this.Jhi = null,
            this.Zhi = null,
            this.Qhi = NaN,
            this.toi = new Rl,
            this.ioi = new Rl,
            this.Ry()
        }
        he() {
            this.Jhi = null,
            this.Zhi = null,
            this.toi = null,
            this.ioi = null
        }
        Dhi(t) {
            this.Jhi = t
        }
        Fhi(t) {
            this.Zhi = t
        }
        Ghi() {
            return this.Qhi
        }
        Ahi(t) {
            this.Qhi = t
        }
        Rhi() {
            return this.toi
        }
        Lkt() {
            return this.ioi
        }
        Ry() {
            this.Jhi = null,
            this.Zhi = null,
            this.toi.set(0, 0),
            this.ioi.set(0, 0),
            this.Qhi = Number.MAX_VALUE
        }
    }
    Al.zce = {},
    Al.zce.Kkt = Dl,
    Al.zce.$ce = Bl,
    Al.zce.Response = Ul,
    Al.zce.jkt = kl
}
{
    const Nl = 2
      , jl = "keyvaluepairs"
      , $l = new Map
      , zl = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll
      , Vl = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
    function Wl(t) {
        return new Promise( (i, e) => {
            t.onsuccess = () => i(t.result),
            t.onerror = () => e(t.error)
        }
        )
    }
    function Hl(t) {
        return new Promise( (i, e) => {
            t.oncomplete = () => i(),
            t.onerror = () => e(t.error),
            t.onabort = () => e(t.error)
        }
        )
    }
    function Kl(t, i) {
        return Xl(t, i)
    }
    function ql(t, i) {
        return Xl(t, i, !0)
    }
    async function Xl(t, i, e=!1, s=!0) {
        const n = await Yl(t);
        try {
            return i(n.transaction([jl], e ? "readwrite" : "readonly"))
        } catch (n) {
            if (s && "InvalidStateError" === n.name)
                return $l.delete(t),
                Xl(t, i, e, !1);
            throw n
        }
    }
    function Yl(t) {
        Zl(t);
        let i = $l.get(t);
        return i instanceof Promise || (i = Jl(t),
        $l.set(t, i),
        i.catch(i => $l.delete(t))),
        i
    }
    async function Jl(t) {
        Zl(t);
        const i = indexedDB.open(t, Nl);
        return i.addEventListener("upgradeneeded", i => {
            try {
                i.target.result.createObjectStore(jl)
            } catch (i) {
                console.error(`Failed to create objectstore for database ${t}`, i)
            }
        }
        ),
        Wl(i)
    }
    function Zl(t) {
        if ("string" != typeof t)
            throw new TypeError("expected string")
    }
    function Ql(t, i) {
        const e = t.objectStore(jl).openCursor();
        return new Promise(t => {
            const s = [];
            e.onsuccess = e => {
                const n = e.target.result;
                if (n) {
                    switch (i) {
                    case "entries":
                        s.push([n.key, n.value]);
                        break;
                    case "keys":
                        s.push(n.key);
                        break;
                    case "values":
                        s.push(n.value)
                    }
                    n.continue()
                } else
                    t(s)
            }
        }
        )
    }
    class tu {
        constructor(t) {
            Zl(t),
            this.name = t
        }
        async ready() {
            await Yl(this.name)
        }
        set(t, i) {
            return Zl(t),
            ql(this.name, async e => {
                const s = Wl(e.objectStore(jl).put(i, t))
                  , n = Hl(e);
                await Promise.all([n, s])
            }
            )
        }
        get(t) {
            return Zl(t),
            Kl(this.name, async i => {
                const e = Wl(i.objectStore(jl).get(t))
                  , s = Hl(i)
                  , [n,r] = await Promise.all([s, e]);
                return r
            }
            )
        }
        delete(t) {
            return Zl(t),
            ql(this.name, async i => {
                const e = Wl(i.objectStore(jl).delete(t))
                  , s = Hl(i);
                await Promise.all([s, e])
            }
            )
        }
        clear() {
            return ql(this.name, async t => {
                const i = Wl(t.objectStore(jl).clear())
                  , e = Hl(t);
                await Promise.all([e, i])
            }
            )
        }
        keys() {
            return Kl(this.name, async t => {
                let i;
                if (Vl) {
                    i = Wl(t.objectStore(jl).getAllKeys())
                } else
                    i = Ql(t, "keys");
                const e = Hl(t)
                  , [s,n] = await Promise.all([e, i]);
                return n
            }
            )
        }
        values() {
            return Kl(this.name, async t => {
                let i;
                if (zl) {
                    i = Wl(t.objectStore(jl).getAll())
                } else
                    i = Ql(t, "values");
                const e = Hl(t)
                  , [s,n] = await Promise.all([e, i]);
                return n
            }
            )
        }
        entries() {
            return Kl(this.name, async t => {
                const i = Ql(t, "entries")
                  , e = Hl(t)
                  , [s,n] = await Promise.all([e, i]);
                return n
            }
            )
        }
    }
    self.r4 = tu
}
{
    const iu = self.r4
      , eu = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i];
    new WeakMap;
    function su(t) {
        throw new Error(`"${t}" is not implemented`)
    }
    function nu(t) {
        if ("function" == typeof t)
            throw new Error("localforage callback API is not implemented; please use the promise API instead")
    }
    function ru(t) {
        return "object" == typeof t ? new Promise(i => {
            const {port1: e, port2: s} = new MessageChannel;
            s.onmessage = t => i(t.data),
            e.postMessage(t)
        }
        ) : Promise.resolve(t)
    }
    class hu {
        constructor(t) {
            this.Ie = t,
            this.eoi = !this.Ie,
            this.eoi || "undefined" != typeof indexedDB || (this.eoi = !0,
            (() => {})("Unable to use local storage because IndexedDB API is not available")),
            this.soi = new Map
        }
        noi(t) {
            if (!this.eoi)
                for (const i of eu)
                    if (t && i.test(t.message)) {
                        console.error("Unable to use local storage, reverting to in-memory store: ", t, t.message),
                        this.eoi = !0;
                        break
                    }
        }
        async roi(t) {
            const i = this.soi.get(t)
              , e = await ru(i);
            return void 0 === e ? null : e
        }
        async hoi(t, i) {
            i = await ru(i),
            this.soi.set(t, i)
        }
        ooi(t) {
            this.soi.delete(t)
        }
        aoi() {
            this.soi.clear()
        }
        loi() {
            return Array.from(this.soi.keys())
        }
        uoi() {
            return this.eoi
        }
        coi() {
            return this.soi
        }
        doi(t) {
            this.soi = t
        }
        async getItem(t, i) {
            if (nu(i),
            this.eoi)
                return await this.roi(t);
            let e;
            try {
                e = await this.Ie.get(t)
            } catch (i) {
                return this.noi(i),
                this.eoi ? await this.roi(t) : (console.error(`Error reading '${t}' from storage, returning null: `, i),
                null)
            }
            return void 0 === e ? null : e
        }
        async setItem(t, i, e) {
            if (nu(e),
            void 0 === i && (i = null),
            this.eoi)
                await this.hoi(t, i);
            else
                try {
                    await this.Ie.set(t, i)
                } catch (e) {
                    if (this.noi(e),
                    !this.eoi)
                        throw e;
                    await this.hoi(t, i)
                }
        }
        async removeItem(t, i) {
            if (nu(i),
            this.eoi)
                this.ooi(t);
            else
                try {
                    await this.Ie.delete(t)
                } catch (i) {
                    this.noi(i),
                    this.eoi ? this.ooi(t) : console.error(`Error removing '${t}' from storage: `, i)
                }
        }
        async clear(t) {
            if (nu(t),
            this.eoi)
                this.aoi();
            else
                try {
                    await this.Ie.clear()
                } catch (t) {
                    this.noi(t),
                    this.eoi ? this.aoi() : console.error("Error clearing storage: ", t)
                }
        }
        async keys(t) {
            if (nu(t),
            this.eoi)
                return this.loi();
            let i = [];
            try {
                i = await this.Ie.keys()
            } catch (t) {
                if (this.noi(t),
                this.eoi)
                    return this.loi();
                console.error("Error getting storage keys: ", t)
            }
            return i
        }
        ready(t) {
            return nu(t),
            this.eoi ? Promise.resolve(!0) : this.Ie.ready()
        }
        foi(t) {
            if (t.poi)
                return new hu(null);
            {
                const i = t.name;
                if ("string" != typeof i)
                    throw new TypeError("invalid store name");
                const e = new iu(i);
                return new hu(e)
            }
        }
        length(t) {
            su("localforage.length()")
        }
        key(t, i) {
            su("localforage.key()")
        }
        iterate(t, i) {
            su("localforage.iterate()")
        }
        moi(t) {
            su("localforage.setDriver()")
        }
        config(t) {
            su("localforage.config()")
        }
        woi(t) {
            su("localforage.defineDriver()")
        }
        goi() {
            su("localforage.driver()")
        }
        supports(t) {
            su("localforage.supports()")
        }
        dropInstance() {
            su("localforage.dropInstance()")
        }
    }
    self.localforage = new hu(new iu("localforage"))
}
{
    const ou = self.t;
    let au = !1
      , lu = []
      , uu = null;
    const cu = 800
      , du = 200
      , fu = "26pt"
      , pu = "unknownFontName948958658";
    let mu = null
      , wu = null
      , gu = null;
    function yu(t, i) {
        const e = t.data
          , s = i.data;
        if (e.length !== s.length)
            return !1;
        const n = new Uint8Array(e.buffer)
          , r = new Uint8Array(s.buffer);
        let h = 0;
        for (let t = 0, i = n.length; t < i; ++t)
            if (n[t] !== r[t] && (h += Math.abs(n[t] - r[t]),
            h > 100))
                return !1;
        return !0
    }
    function bu(t) {
        return wu.clearRect(0, 0, cu, du),
        wu.font = fu + " " + t,
        wu.fillText("ABCDEFGHIJKLMNOPQRSTUVWXYZ", 5, 5),
        wu.fillText("abcdefghijklmnopqrstuvwxyz", 5, 55),
        wu.fillText("0123456789", 5, 105),
        wu.getImageData(0, 0, cu, du)
    }
    async function vu() {
        const t = ou.boi.yoi
          , i = t.fontCandidateList
          , e = new Set(t.fontAlwaysShowList)
          , s = [];
        mu = document.createElement("canvas"),
        mu.width = cu,
        mu.height = du,
        wu = mu.getContext("2d"),
        wu.textBaseline = "top",
        wu.fillStyle = "black",
        gu = bu(pu);
        for (const t of i)
            e.has(t) ? lu.push(t) : s.push(ou.lre( () => {
                yu(gu, bu('"' + t + '"')) || lu.push(t)
            }
            ));
        return await Promise.all(s),
        au = !0,
        mu.width = 32,
        mu.height = 32,
        mu = null,
        wu = null,
        gu = null,
        uu = null,
        lu.sort(),
        lu
    }
    async function Su() {
        const t = new Set
          , i = await self.queryLocalFonts();
        for (const e of i)
            t.add(e.family);
        return lu = [...t],
        lu.sort(),
        au = !0,
        uu = null,
        lu
    }
    async function xu() {
        try {
            if (ou.QL.H9t)
                try {
                    return await Su()
                } catch (t) {
                    (() => {})("Failed to get local font list: ", t)
                }
            return await vu()
        } catch (t) {
            return console.error("Failed to get local font list: ", t),
            ou.hx(ou.boi.yoi.fontAlwaysShowList)
        }
    }
    ou.boi = class {
        constructor() {
            throw new Error("static class")
        }
        static voi() {
            return au ? Promise.resolve(lu) : uu || (uu = xu(),
            uu)
        }
    }
}
self.t.boi.yoi = {
    fontCandidateList: ["Algerian", "Andale Mono", "Arial", "Avant Garde", "Baskerville", "Big Caslon", "Bitstream Vera", "Bodoni MT", "Book Antiqua", "Bookman", "Bookman Old Style", "Bradley Hand ITC TT", "Broadway", "Brush Script MT", "Calibri", "Calisto MT", "Candara", "Cambria", "Cardo", "Carrois Gothic SC", "Caslon Roman", "Century Gothic", "Century Schoolbook", "Comic Sans MS", "Consolas", "Copperplate", "Copperplate Gothic", "Courier New", "Cutive Mono", "Dancing Script", "Diavlo", "Didot", "Droid", "Droid Sans", "Droid Sans Mono", "Droid Serif", "Franklin Gothic", "Futura", "Garamond", "Geneva", "Gentium", "Georgia", "Ghostscript", "Gill Sans", "Goudy", "Goudy Old Style", "Haettenschweiler", "Helvetica", "Hoefler Text", "Impact", "ITC Stone Serif", "Junicode", "Latin Modern", "Lucida Bright", "Lucida Calligraphy", "Lucida Console", "Lucida Grande", "Lucida Sans", "Lucida Sans Typewriter", "Lucida Sans Unicode", "Mistral", "Moire", "Monaco", "MS Mincho", "MS Sans Serif", "New Athena Unicode", "New York", "Noto", "Noto Sans", "Noto Serif", "Old Standard TT", "Onyx", "Optima", "Oxygen", "Palatino", "Palatino Linotype", "Papyrus", "Perpetua", "Perpetua Titling MT", "Playbill", "Roboto", "Rockwell", "San Francisco", "Segoe UI", "Snap ITC", "Source Sans Pro", "Source Code Pro", "Stencil", "Symbol", "Symbola", "Tahoma", "Times", "Times New Roman", "Trebuchet MS", "Tw Cen MT", "UniFraktur", "Verdana", "Webdings", "Wide Latin", "Wingdings"],
    fontAlwaysShowList: ["Arial", "Times New Roman"]
};
{
    const Mu = self.t;
    Mu.Soi = "\ufeff";
    const Eu = new Set("0123456789");
    Mu.xoi = function(t) {
        return Mu.zt(t),
        Eu.has(t)
    }
    ;
    const Cu = new Set(" \t\n\r\u2028\u2029");
    Mu.Lti = function(t) {
        return Mu.zt(t),
        Cu.has(t)
    }
    ,
    Mu.Moi = function(t) {
        return [...t].filter(t => !Mu.Lti(t)).join("")
    }
    ,
    Mu.Eoi = function(t) {
        for (const i of t)
            if (!Mu.Lti(i))
                return !1;
        return !0
    }
    ,
    Mu.xx = function(t) {
        for (const i of t)
            if (!Mu.Lti(i))
                return !1;
        return !0
    }
    ,
    Mu.Coi = function(t) {
        return Mu.zt(t),
        1 === t.length && t.charCodeAt(0) < 32
    }
    ,
    Mu._oi = function(t) {
        return [...t].filter(t => !Mu.Coi(t)).join("")
    }
    ;
    let _u = null;
    try {
        _u = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])","u")
    } catch (Bu) {
        (() => {})("Unable to detect CJK punctuation: ", Bu)
    }
    Mu.Toi = function(t) {
        return !Mu.Lti(t) && _u && _u.test(t)
    }
    ;
    const Tu = new Set("0123456789.+-e");
    Mu.Ioi = function(t) {
        if (Mu.zt(t),
        !(t = t.trim()).length)
            return !1;
        let i = t.charAt(0);
        if ("-" !== i && !Eu.has(i))
            return !1;
        for (let i of t)
            if (!Tu.has(i))
                return !1;
        return !0
    }
    ,
    Mu.eW = function(t) {
        Mu.zt(t);
        let i = t.length;
        for (; i > 0; ) {
            let e = t.charAt(i - 1);
            if (!Mu.xoi(e))
                break;
            --i
        }
        return t.substr(0, i)
    }
    ,
    Mu.SUt = function(t) {
        Mu.zt(t);
        let i = Mu.eW(t)
          , e = t.substr(i.length);
        return e = e ? (parseInt(e, 10) + 1).toString() : "2",
        i + e
    }
    ;
    const Iu = new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
    function Pu(t) {
        return Iu.get(t)
    }
    const Gu = /[&<>"']/g;
    Mu.Poi = function(t) {
        return Mu.p0(t),
        t.replace(Gu, Pu)
    }
    ,
    Mu.Goi = function(t) {
        let i = Mu.Aoi(t, "\\", "\\\\");
        return i = Mu.Aoi(i, '"', '\\"'),
        i = Mu.Aoi(i, "\t", "\\t"),
        i = Mu.Aoi(i, "\r", ""),
        Mu.Aoi(i, "\n", "\\n")
    }
    ,
    Mu.Roi = function(t) {
        let i = Mu.Aoi(t, "&", "&amp;");
        return i = Mu.Aoi(i, "<", "&lt;"),
        i = Mu.Aoi(i, ">", "&gt;"),
        Mu.Aoi(i, '"', "&quot;")
    }
    ;
    const Au = /[-[\]{}()*+?.,\\^$|#\s]/g;
    Mu.G9t = function(t) {
        return Mu.p0(t),
        t.replace(Au, "\\$&")
    }
    ,
    Mu.koi = function(t, i) {
        let e = 0;
        for (const s of t)
            s === i && ++e;
        return e
    }
    ,
    Mu.Ooi = function(t, i) {
        let e = 0
          , s = 0;
        for (; e < i; ) {
            if (e = t.indexOf("\n", e),
            -1 === e)
                return s;
            s++,
            e++
        }
        return s
    }
    ,
    Mu.Doi = function(t, i, e=!1) {
        if (Mu.zt(t),
        Mu.zt(i),
        !i)
            return [];
        e || (t = t.toLowerCase(),
        i = i.toLowerCase());
        const s = i.length;
        let n = 0
          , r = 0
          , h = [];
        for (; (r = t.indexOf(i, n)) > -1; )
            h.push(r),
            n = r + s;
        return h
    }
    ,
    Mu.Aoi = function(t, i, e) {
        return Mu.zt(t),
        Mu.zt(i),
        Mu.zt(e),
        t.replaceAll(i, () => e)
    }
    ,
    Mu.Ii = function(t, i, e) {
        return Mu.zt(t),
        Mu.zt(i),
        Mu.zt(e),
        t.replace(new RegExp(Mu.G9t(i),"gi"), () => e)
    }
    ,
    Mu.wQ = function(t, i) {
        Mu.ibt(t),
        Mu.p0(i),
        "string" == typeof i ? t.textContent = i : i.Foi() ? t.textContent = i.toString() : (t.innerHTML = i.FXt(),
        i instanceof Mu.ix && i.Loi(t))
    }
    ,
    Mu.Boi = function(t, i) {
        return t instanceof Mu.vti || t instanceof Mu.ix ? t.equals(i) : i instanceof Mu.vti || i instanceof Mu.ix ? i.equals(t) : t === i
    }
    ,
    Mu.Uoi = function(t, ...i) {
        Mu.zt(t);
        let e = t;
        for (let s = 0, n = i.length; s < n; ++s) {
            const n = `{${s}}`;
            if (!t.includes(n))
                throw new Error(`missing placeholder '${n}' in string substitution`);
            e = e.replace(n, i[s].toString())
        }
        return e
    }
    ,
    Mu.Noi = function(t, ...i) {
        Mu.zt(t);
        let e = t
          , s = -1
          , n = -1;
        for (let r = 0, h = i.length; r < h; ++r) {
            const h = `{${r}}`;
            t.includes(h) ? (n = r,
            e = e.replace(h, i[r].toString())) : -1 === s && (s = r)
        }
        if (s >= 0 && n >= 0 && s < n)
            throw new Error(`missing placeholder '${s}' in string substitution`);
        return e
    }
    ,
    Mu.joi = function(t, i) {
        Mu.zt(t);
        let e = t;
        for (let[t,s] of Object.entries(i))
            Mu.zt(t),
            e = e.replaceAll(t, s.toString());
        return e
    }
    ,
    Mu.$oi = function(t, i) {
        return t > i ? 1 : t < i ? -1 : 0
    }
    ,
    Mu.qL = function(t, i) {
        let e = t.toLowerCase()
          , s = i.toLowerCase();
        return e > s ? 1 : e < s ? -1 : 0
    }
    ;
    const Ru = new self.Intl.Segmenter;
    Mu.Kx = function(t) {
        const i = [];
        for (const e of Ru.segment(t))
            i.push(e.segment);
        return i
    }
    ,
    Mu.zoi = function*(t) {
        for (const i of Ru.segment(t))
            yield i.segment
    }
    ,
    Mu.Voi = function(t) {
        let i = 0;
        for (const e of Ru.segment(t))
            ++i;
        return i
    }
    ;
    const ku = 1024
      , Ou = 1024 * ku
      , Du = 1024 * Ou
      , Fu = 1024 * Du;
    Mu.Woi = function(t, i) {
        let e = "common." + (i ? "dataRates" : "dataSizes") + ".";
        const s = self.h_;
        if (t < ku)
            return s(e + "bytes", t);
        if (t < Ou) {
            let i = t / ku;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "kilobytes", i)
        }
        if (t < Du) {
            let i = t / Ou;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "megabytes", i)
        }
        if (t < Fu) {
            let i = t / Du;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "gigabytes", i)
        }
        {
            let i = t / Fu;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "terabytes", i)
        }
    }
    ;
    const Lu = {
        Hoi: !1,
        Koi: !0,
        qoi: !0,
        Xoi: !0,
        Yoi: !0
    };
    Mu.Joi = function(t, i) {
        i = Object.assign({}, Lu, i),
        Mu.p.u("common.time");
        const e = []
          , s = self.lang
          , n = self.n_;
        if (i.Koi) {
            const i = Math.floor(t / 86400);
            i > 0 && (t -= 24 * i * 3600,
            e.push(n(".days", null, i)))
        }
        if (i.qoi) {
            const i = Math.floor(t / 3600);
            (i > 0 || e.length) && (t -= 3600 * i,
            e.push(n(".hours", null, i)))
        }
        if (i.Xoi) {
            const s = Math.floor(t / 60);
            (s > 0 || e.length || !i.Yoi) && (t -= 60 * s,
            e.push(n(".minutes", null, s)))
        }
        if (i.Yoi) {
            const i = Math.floor(t % 60);
            e.push(n(".seconds", null, i))
        }
        const r = (i.Hoi ? s(".approx-prefix") : "") + e.join(s(".separator"));
        return Mu.p.j(),
        r
    }
    ,
    Mu.Mi = function(t, i) {
        let e = t < 0 ? "-" : ""
          , s = (t = Math.abs(t)).toString()
          , n = i - s.length;
        for (let t = 0; t < n; ++t)
            e += "0";
        return e + s
    }
    ,
    Mu.Zoi = function(t) {
        return t.toLowerCase().replace(/\b\w/g, t => t.toUpperCase())
    }
    ,
    Mu.Qoi = function(t, i) {
        let e = t.split(".").map(t => t.trim())
          , s = i.split(".").map(t => t.trim());
        Mu.nv(e, 4, "0"),
        Mu.nv(s, 4, "0"),
        e = e.map(t => parseInt(t, 10)),
        s = s.map(t => parseInt(t, 10));
        for (let t = 0; t < 4; ++t) {
            const i = e[t] - s[t];
            if (0 !== i)
                return i < 0 ? -1 : 1
        }
        return 0
    }
    ,
    Mu.tai = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
            const i = Math.floor(16 * Math.random());
            return ("x" === t ? i : 3 & i | 8).toString(16)
        }
        )
    }
    ,
    Mu.iai = function(t, i) {
        if (t.length !== i.length)
            throw new Error("strings must be same length");
        let e = 0;
        for (let s = 0, n = t.length; s < n; ++s)
            t.charAt(s) !== i.charAt(s) && ++e;
        return e
    }
    ,
    Mu.eai = function(t, i) {
        if (0 === t.length)
            return i.length;
        if (0 === i.length)
            return t.length;
        let e, s, n, r, h, o;
        for (t.length > i.length && (e = t,
        t = i,
        i = e),
        o = Array(t.length + 1),
        s = 0; s <= t.length; s++)
            o[s] = s;
        for (s = 1; s <= i.length; s++) {
            for (r = s,
            n = 1; n <= t.length; n++)
                h = i[s - 1] === t[n - 1] ? o[n - 1] : Math.min(o[n - 1] + 1, Math.min(r + 1, o[n] + 1)),
                o[n - 1] = r,
                r = h;
            o[t.length] = r
        }
        return o[t.length]
    }
}
{
    const Uu = self.t;
    Uu.vti = class {
        constructor(t) {
            Uu.zt(t),
            this.sai = t,
            this.nai = !this.sai.includes("<") && !this.sai.includes("&")
        }
        toString() {
            return this.sai
        }
        valueOf() {
            return this.sai
        }
        Foi() {
            return this.nai
        }
        FXt() {
            return this.sai
        }
        equals(t) {
            return t instanceof Uu.vti ? this.sai === t.sai : t instanceof Uu.ix ? this.sai === t.FXt() : this.sai === t
        }
    }
}
{
    const Nu = self.t
      , ju = self.assert
      , $u = new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]])
      , zu = new Set(["icon"])
      , Vu = /\[(\/?)([a-zA-Z0-9]+)\]/g
      , Wu = /\[(\/?)([^\[\n]*?)\]/g;
    let Hu = null
      , Ku = null
      , qu = 0;
    function Xu(t, i, e) {
        const s = $u.get(e);
        if (!s)
            return "class" === e ? i ? "</span>" : `<span class="bbclass${qu++}">` : t;
        if ("string" == typeof s) {
            if ("a" === s && 0 === Hu.length || "abbr" === s && 0 === Ku.length)
                return t;
            if ("a" !== s || i) {
                if ("abbr" !== s || i)
                    return "<" + i + s + ">";
                {
                    const t = parseInt(e.substring(3), 10) - 1;
                    if (t < 0 || t >= Ku.length)
                        throw new Error("invalid bbcode tip substitution");
                    const i = Ku[t];
                    let s = "";
                    if ("string" == typeof i ? s = i : "function" == typeof i && (s = i()),
                    "string" != typeof s)
                        throw new TypeError("invalid bbcode tip");
                    return `<abbr title="${Nu.Aoi(s, '"', "&quot;")}">`
                }
            }
            {
                const t = parseInt(e.substring(1), 10) - 1;
                if (t < 0 || t >= Hu.length)
                    throw new Error("invalid bbcode link substitution");
                const i = Hu[t];
                if ("string" == typeof i)
                    return `<a href="${Hu[t]}">`;
                if ("function" == typeof i)
                    return `<a class="bblink${t}">`;
                throw new TypeError("invalid bbcode link action")
            }
        }
        if (Array.isArray(s)) {
            ju(2 === s.length, "invalid bbcode entry");
            let t = s[0]
              , e = s[1];
            return i ? "</" + t + ">" : `<${t} class="${e}">`
        }
        ju(!1, "invalid bbcode entry")
    }
    const Yu = /\n/g;
    Nu.ix = class {
        constructor(t, i) {
            if (Nu.zt(t),
            Nu.kQ(i),
            this.rai = i && i.sx ? t : Nu.Poi(t),
            this.hai = "",
            this.oai = !1,
            this.aai = [],
            this.lai = [],
            i) {
                if (this.oai = !!i.AU,
                i.links) {
                    if (Nu.RH(i.links),
                    i.links.length > 9)
                        throw new Error("too many links");
                    this.aai = i.links
                }
                if (i.uai) {
                    if (Nu.RH(i.uai),
                    i.uai.length > 9)
                        throw new Error("too many tips");
                    this.lai = i.uai
                }
            }
            this.cai = this.rai.includes("["),
            this.dai = this.oai && this.rai.includes("\n"),
            this.nai = !this.cai && !this.dai && !this.rai.includes("&"),
            this.fai = !1,
            this.pai = []
        }
        toString() {
            return this.rai
        }
        valueOf() {
            return this.rai
        }
        Foi() {
            return this.nai
        }
        tjt() {
            return this.cai ? this.rai.replace(Vu, "") : this.rai
        }
        FXt() {
            if (this.nai)
                return this.rai;
            if (!this.hai && this.rai) {
                let t = this.rai;
                this.cai && (qu = 0,
                Hu = this.aai,
                Ku = this.lai,
                t = t.replace(Vu, Xu),
                Hu = null,
                Ku = null),
                this.dai && (t = t.replace(Yu, "<br>")),
                this.hai = t
            }
            return this.hai
        }
        Loi(t) {
            if (this.aai.length)
                for (let i = 0, e = this.aai.length; i < e; ++i) {
                    const e = this.aai[i];
                    if ("function" != typeof e)
                        continue;
                    const s = t.querySelector(".bblink" + i);
                    if (!s)
                        throw new Error("unable to attach BBString link handler");
                    s.onclick = e
                }
        }
        equals(t) {
            return t instanceof Nu.vti ? this.FXt() === t.FXt() : t instanceof Nu.ix ? this.rai === t.rai : this.rai === t
        }
        nx() {
            if (this.fai)
                return this.pai;
            const t = []
              , i = this.rai
              , e = [];
            Wu.lastIndex = 0;
            let s = 0
              , n = null;
            for (; null !== (n = Wu.exec(i)); ) {
                const r = n.index;
                if (r > 0 && "\\" === i.charAt(r - 1))
                    continue;
                const h = n[0]
                  , o = n[1]
                  , a = n[2]
                  , l = i.substring(s, r);
                if (s = r + h.length,
                l && t.push({
                    text: l,
                    mai: e.slice(0)
                }),
                a)
                    if (o) {
                        const t = a.toLowerCase();
                        for (let i = e.length - 1; i >= 0; --i)
                            if (e[i].tag === t) {
                                e.splice(i, 1);
                                break
                            }
                    } else {
                        let i = a
                          , s = null;
                        const n = a.indexOf("=");
                        if (-1 !== n ? (i = a.substring(0, n).toLowerCase(),
                        s = a.substring(n + 1)) : i = i.toLowerCase(),
                        zu.has(i)) {
                            if ("icon" !== i)
                                throw new Error(`unknown self-closing tag ${i}`);
                            t.push({
                                icon: s,
                                mai: e.slice(0)
                            })
                        } else
                            e.push({
                                tag: i,
                                Ly: s
                            })
                    }
            }
            s < i.length && t.push({
                text: i.substring(s),
                mai: e.slice(0)
            });
            for (const i of t)
                i.text && (i.text = this.wai(i.text));
            return this.pai = t.map(t => t.icon ? Nu.v(Nu.gai, {
                icon: t.icon,
                mai: t.mai
            }) : Nu.v(Nu.yai, {
                bai: Nu.Kx(t.text),
                mai: t.mai
            })),
            this.fai = !0,
            this.pai
        }
        wai(t) {
            return t = Nu.Aoi(t, "\\[", "["),
            Nu.Aoi(t, "\\\\", "\\")
        }
        static vai(t) {
            return Nu.v(Nu.ix, t, {
                sx: !0
            }).tjt()
        }
        static Sai(t) {
            return t.replace(Wu, "")
        }
    }
}
self.t.xJt = Object.freeze({
    xai: "",
    EJt: "",
    Mai: "",
    Eai: "",
    Cai: "",
    _ai: "",
    Tai: "",
    Iai: "",
    Pai: "",
    Gai: "",
    Aai: "",
    Rai: "",
    kai: "",
    PI: "",
    Oai: "",
    Dai: "",
    Fai: "",
    Lai: "",
    Bai: "",
    Uai: "",
    Nai: "",
    jai: "",
    $ai: "",
    zai: "",
    Vai: "",
    Wai: "",
    Hai: "",
    Kai: "",
    qai: "",
    Xai: "",
    Yai: "",
    Jai: "",
    Zai: "",
    Qai: "",
    tli: "",
    ili: [".", ""],
    eli: [",", ""],
    sli: ['"', "", ""],
    nli: ["(", ""],
    rli: [")", ""],
    hli: ["?", ""],
    oli: [":", ""]
});
{
    const Ju = self.t;
    function Zu(t) {
        return "" !== t && "" !== t && Ju.Lti(t)
    }
    const Qu = new Set("");
    function tc(t) {
        return Qu.has(t)
    }
    function ic(t) {
        return Ju.Toi(t) && !tc(t)
    }
    function ec(t) {
        for (; t.length > 0 && Zu(t.at(-1)); )
            t.pop()
    }
    function sc(t) {
        return "\n" === t || "\r\n" === t
    }
    Ju.my = class {
        constructor() {
            this.ali = [],
            this.lli = null
        }
        $y() {
            return this.ali
        }
        Lx() {
            return this.ali.length
        }
        KS(t) {
            Ju.Ef(t, Ju.uli),
            this.lli = t
        }
        cli(t, i) {
            let e = 0
              , s = 0
              , n = 0
              , r = 0
              , h = 0;
            for (const o of t) {
                if (-1 === o.ns()) {
                    const t = i(o);
                    o.Ib(t.height),
                    o.dli(t.fontBoundingBoxAscent || 0),
                    o.fli(t.fontBoundingBoxDescent || 0),
                    o.pli(t.mli || 0),
                    o.wli() ? o.Cb(t.width) : o.Gy() && o.gli(this.lli)
                }
                e += o.ns(),
                s = Math.max(s, o.er()),
                n = Math.max(n, o.yli()),
                r = Math.max(r, o.bli()),
                h = Math.max(h, o.vli())
            }
            return {
                width: e,
                height: s,
                fontBoundingBoxAscent: n,
                fontBoundingBoxDescent: r,
                mli: h
            }
        }
        Sli(t, i, e, s, n, r) {
            this.ali.push(Ju.v(Ju.my.Va, {
                Yy: t,
                width: i,
                height: e,
                fontBoundingBoxAscent: s,
                fontBoundingBoxDescent: n,
                mli: r
            }))
        }
        my(t, i, e, s, n) {
            if ("string" == typeof t && (t = [Ju.v(Ju.yai, {
                bai: Ju.Kx(t)
            })]),
            Ju.RH(t),
            Ju.nu(i),
            Ju.Ge(e),
            Ju.zt(s),
            Ju.Io(this.ali),
            !t.length || 1 === t.length && t[0].wli() && t[0].q5() || e < 2)
                return;
            if (1 === t.length) {
                const s = t[0];
                if (s.wli() && s.xli() <= 100 && !s.Mli()) {
                    let {width: t, height: r, fontBoundingBoxAscent: h, fontBoundingBoxDescent: o, mli: a} = i(s);
                    if (t += n,
                    s.Cb(t),
                    s.Ib(r),
                    s.dli(h || 0),
                    s.fli(o || 0),
                    s.pli(a || 0),
                    t <= e)
                        return void this.Sli([s], t, r, h, o, a)
                }
            }
            let r;
            r = "word" === s ? this.Eli(t) : "cjk" === s ? this.Cli(t) : this._li(t),
            this.Tli(r, i, e, n)
        }
        Eli(t) {
            const i = [];
            let e = []
              , s = !1;
            for (const n of t) {
                const t = n.Ili();
                if (n.Gy())
                    e.length > 0 && i.push(e),
                    i.push([n]),
                    e = [];
                else
                    for (const r of n._y())
                        if (sc(r))
                            e.length > 0 && i.push(e),
                            i.push([Ju.v(Ju.yai, {
                                bai: ["\n"],
                                mai: t
                            })]),
                            e = [];
                        else if (0 === e.length)
                            e.push(Ju.v(Ju.yai, {
                                bai: [r],
                                mai: t
                            })),
                            s = Zu(r);
                        else {
                            const n = Zu(r);
                            if (n === s) {
                                const i = e.at(-1);
                                i.Ili() === t ? i.Pli(r) : e.push(Ju.v(Ju.yai, {
                                    bai: [r],
                                    mai: t
                                }))
                            } else
                                i.push(e),
                                e = [Ju.v(Ju.yai, {
                                    bai: [r],
                                    mai: t
                                })],
                                s = n
                        }
            }
            return e.length > 0 && i.push(e),
            i
        }
        Cli(t) {
            const i = [];
            let e = []
              , s = !1;
            for (const n of t) {
                const t = n.Ili();
                if (n.Gy())
                    e.length > 0 && i.push(e),
                    i.push([n]),
                    e = [];
                else
                    for (const r of n._y())
                        if (sc(r))
                            e.length > 0 && i.push(e),
                            i.push([Ju.v(Ju.yai, {
                                bai: ["\n"],
                                mai: t
                            })]),
                            e = [];
                        else if (0 === e.length)
                            e.push(Ju.v(Ju.yai, {
                                bai: [r],
                                mai: t
                            })),
                            s = tc(r);
                        else if (s || ic(r)) {
                            const i = e.at(-1);
                            i.Ili() === t ? i.Pli(r) : e.push(Ju.v(Ju.yai, {
                                bai: [r],
                                mai: t
                            })),
                            s = tc(r)
                        } else
                            i.push(e),
                            e = [Ju.v(Ju.yai, {
                                bai: [r],
                                mai: t
                            })],
                            s = tc(r)
            }
            return e.length > 0 && i.push(e),
            i
        }
        _li(t) {
            const i = [];
            for (const e of t)
                if (e.wli()) {
                    const t = e._y();
                    Ju.Oo(i, t.map(t => [Ju.v(Ju.yai, {
                        bai: [t],
                        mai: e.Ili()
                    })]))
                } else
                    i.push([e]);
            return i
        }
        Gli(t) {
            return t.map(t => t.Ali())
        }
        Rli(t, i) {
            const e = t.length ? t.at(-1) : null;
            let s = 0;
            e && e.wli() && i[0].wli() && i[0].Ili() === e.Ili() && (e.kli(i[0]._y()),
            s = 1);
            for (let e = i.length; s < e; ++s) {
                const e = i[s];
                t.push(e.Ali())
            }
        }
        Tli(t, i, e, s) {
            let n = []
              , r = 0
              , h = 0
              , o = 0
              , a = 0
              , l = 0;
            for (const s of t) {
                if (1 === s.length && s[0].wli() && 1 === s[0].xli() && sc(s[0]._y()[0])) {
                    if (0 === h) {
                        const t = i(Ju.v(Ju.yai, {
                            bai: [" "],
                            mai: s[0].Ili()
                        }));
                        h = t.height,
                        o = t.fontBoundingBoxAscent || 0,
                        a = t.fontBoundingBoxDescent || 0,
                        l = t.mli || 0
                    }
                    this.Sli(n, r, h, o, a, l),
                    n = [],
                    r = 0,
                    h = 0,
                    o = 0,
                    a = 0,
                    l = 0;
                    continue
                }
                const t = this.Gli(n);
                this.Rli(t, s);
                const u = this.cli(t, i)
                  , c = u.width;
                if (c >= e)
                    if (n.length > 0 && this.Sli(n, r, h, o, a, l),
                    n = [],
                    s[0].wli() && Ju.xx(s[0]._y()))
                        r = 0,
                        h = 0,
                        o = 0,
                        a = 0,
                        l = 0;
                    else {
                        this.Rli(n, s);
                        const t = this.cli(n, i);
                        r = t.width,
                        h = t.height,
                        o = t.fontBoundingBoxAscent,
                        a = t.fontBoundingBoxDescent,
                        l = t.mli
                    }
                else
                    n = t,
                    r = c,
                    h = u.height,
                    o = u.fontBoundingBoxAscent,
                    a = u.fontBoundingBoxDescent,
                    l = u.mli
            }
            n.length > 0 && this.Sli(n, r, h, o, a, l),
            this.Oli(i, s)
        }
        Oli(t, i) {
            for (const e of this.ali) {
                const s = e.Dli();
                if (!s.length)
                    continue;
                let n = s.at(-1);
                if (n.wli()) {
                    const r = n._y()
                      , h = r.slice(0);
                    if (ec(h),
                    0 === h.length)
                        e.Fli(-n.ns()),
                        s.pop();
                    else if (h.length < r.length) {
                        n.Lli(h);
                        const i = t(n).width
                          , s = n.ns() - i;
                        n.Cb(i),
                        e.Fli(-s)
                    }
                    0 !== i && s.length > 0 && (n = s.at(-1),
                    n.Fli(i),
                    e.Fli(i))
                }
            }
        }
        Ry() {
            Ju.Io(this.ali)
        }
        _x() {
            return this.ali.reduce( (t, i) => Math.max(t, i.ns()), 0)
        }
        Bli() {
            return this.ali.reduce( (t, i) => t + i.er(), 0)
        }
    }
}
self.t.my.Va = class {
    constructor(t) {
        this.pai = t.Yy || [],
        this.Fx = t.width || -1,
        this.Ex = t.height || -1,
        this.Uli = t.fontBoundingBoxAscent || -1,
        this.Nli = t.fontBoundingBoxDescent || -1,
        this.jli = t.mli || -1,
        this.$li = 0,
        this.zli = 0
    }
    Yy() {
        return this.pai.values()
    }
    *Vli() {
        const t = this.pai;
        for (let i = t.length - 1; i >= 0; --i)
            yield t[i]
    }
    Dli() {
        return this.pai
    }
    Fli(t) {
        this.Fx += t
    }
    ns() {
        return this.Fx
    }
    er() {
        return this.Ex
    }
    Wli() {
        return this.Uli
    }
    bli() {
        return this.Nli
    }
    vli() {
        return this.jli
    }
    ox(t) {
        this.$li = t
    }
    Jy() {
        return this.$li
    }
    ux(t) {
        this.zli = t
    }
    Xy() {
        return this.zli
    }
}
;
self.t.Hli = class {
    constructor(t) {
        this.Kli = t.mai || [],
        this.Fx = t.width || -1,
        this.Ex = t.height || -1,
        this.Uli = t.fontBoundingBoxAscent || -1,
        this.Nli = t.fontBoundingBoxDescent || -1,
        this.jli = t.mli || -1,
        this.$li = 0,
        this.zli = 0
    }
    wli() {
        return !1
    }
    Gy() {
        return !1
    }
    Ili() {
        return this.Kli
    }
    jy(t) {
        const i = this.Kli;
        for (let e = i.length - 1; e >= 0; --e) {
            const s = i[e];
            if (s.tag === t)
                return s
        }
        return null
    }
    Sx(t) {
        return !!this.jy(t)
    }
    qli() {
        const t = new Map;
        for (const i of this.Kli)
            t.set(i.tag, i.Ly);
        return t
    }
    Fli(t) {
        this.Fx += t
    }
    Cb(t) {
        this.Fx = t
    }
    ns() {
        return this.Fx
    }
    Ib(t) {
        this.Ex = t
    }
    er() {
        return this.Ex
    }
    dli(t) {
        this.Uli = t
    }
    yli() {
        return this.Uli
    }
    fli(t) {
        this.Nli = t
    }
    bli() {
        return this.Nli
    }
    pli(t) {
        this.jli = t
    }
    vli() {
        return this.jli
    }
    ox(t) {
        this.$li = t
    }
    Jy() {
        return this.$li
    }
    ux(t) {
        this.zli = t
    }
    Xy() {
        return this.zli
    }
}
;
{
    const nc = self.t;
    nc.yai = class extends nc.Hli {
        constructor(t) {
            super(t),
            this.Xli = t.bai
        }
        wli() {
            return !0
        }
        kli(t) {
            nc.Oo(this.Xli, t),
            this.Fx = -1,
            this.Ex = -1,
            this.Uli = -1,
            this.Nli = -1,
            this.jli = -1
        }
        Pli(t) {
            this.Xli.push(t)
        }
        Ali() {
            return nc.v(nc.yai, {
                bai: this.Xli.slice(0),
                mai: this.Kli,
                width: this.Fx,
                height: this.Ex,
                fontBoundingBoxAscent: this.Uli,
                fontBoundingBoxDescent: this.Nli,
                mli: this.jli
            })
        }
        _y() {
            return this.Xli
        }
        Lli(t) {
            this.Xli = t
        }
        xli() {
            return this.Xli.length
        }
        q5() {
            return 0 === this.Xli.length
        }
        Mli() {
            return this.Xli.includes("\n")
        }
    }
}
{
    const rc = self.t;
    rc.gai = class extends rc.Hli {
        constructor(t) {
            super(t),
            this.G4 = t.icon
        }
        Gy() {
            return !0
        }
        Yli() {
            return this.G4
        }
        Ali() {
            return rc.v(rc.gai, {
                icon: this.G4,
                mai: this.Kli,
                width: this.Fx,
                height: this.Ex,
                fontBoundingBoxAscent: this.Uli,
                fontBoundingBoxDescent: this.Nli,
                mli: this.jli
            })
        }
        g_t(t) {
            if (!t)
                return null;
            let i = Number(this.G4);
            return String(i) === this.G4 ? (i = Math.floor(i),
            t.Jli(i)) : t.Zli(this.G4)
        }
        gli(t) {
            const i = this.g_t(t);
            this.Fx = i ? this.Ex * i.ns() / i.er() : 0
        }
        yn(t) {
            const i = this.g_t(t);
            return i ? i.yn() : null
        }
        xli() {
            return 1
        }
    }
}
{
    const hc = self.t;
    hc.Qli = class {
        constructor(t) {
            hc.nu(t.tui),
            hc.nu(t.iui),
            this.eui = new Map,
            this.sui = t.tui,
            this.nui = t.iui
        }
        he() {
            for (const t of this.eui.values())
                t.he();
            this.eui.clear()
        }
        rui(t) {
            let i = this.eui.get(t);
            if (i)
                return i;
            const e = this.sui(t);
            return i = hc.v(hc.uli, this, {
                source: t,
                hui: e
            }),
            this.eui.set(t, i),
            i
        }
        oui(t) {
            return this.eui.has(t)
        }
        aui(t) {
            const i = this.eui.get(t);
            i && i.he(),
            this.eui.delete(t)
        }
        async lui(t) {
            return await this.nui(t)
        }
    }
}
{
    const oc = self.t;
    oc.uli = class {
        constructor(t, i) {
            oc.IL(i),
            this.uui = t,
            this.dmt = i.source,
            this.cui = [],
            this.dui = new Map,
            this.fui = !1,
            this.pn = !1,
            this.pui = null;
            const e = i.hui.mui;
            for (let t = 0, i = e.length; t < i; ++t) {
                const i = e[t]
                  , s = oc.v(oc.wui, this, {
                    index: t,
                    tag: i.tag,
                    source: i.source,
                    width: i.width,
                    height: i.height
                });
                this.cui.push(s),
                i.tag && this.dui.set(i.tag.toLowerCase(), s)
            }
        }
        he() {
            for (const t of this.cui)
                t.he();
            oc.Io(this.cui),
            this.dui.clear(),
            this.uui = null,
            this.dmt = null
        }
        gui() {
            return this.fui
        }
        Xw() {
            return this.pn
        }
        yui() {
            return this.pui || (this.pui = this.bui()),
            this.pui
        }
        async bui() {
            if (this.fui)
                return;
            this.fui = !0,
            this.pn = !0;
            const t = await this.uui.lui(this.dmt);
            if (!this.uui)
                return;
            const i = t.mui;
            oc.RH(i);
            for (let t = 0, e = Math.min(i.length, this.cui.length); t < e; ++t) {
                const e = i[t].vui;
                this.cui[t].Sui(e)
            }
            this.pn = !1
        }
        Jli(t) {
            return oc.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.cui.length ? null : this.cui[t]
        }
        Zli(t) {
            return oc.zt(t),
            this.dui.get(t.toLowerCase()) || null
        }
    }
}
self.t.wui = class {
    constructor(t, i) {
        this.xui = t,
        this.dmt = i.source || null,
        this.oGt = i.index,
        this.Rd = i.tag,
        this.Fx = i.width,
        this.Ex = i.height,
        this.Mui = null
    }
    he() {
        this.Fx = 0,
        this.Ex = 0,
        this.xui = null
    }
    Hot() {
        return this.dmt
    }
    ns() {
        return this.Fx
    }
    er() {
        return this.Ex
    }
    Sui(t) {
        this.Mui = t
    }
    yn() {
        return this.Mui
    }
}
;
{
    const ac = self.t
      , lc = self.assert;
    let uc = null
      , cc = null
      , dc = ""
      , fc = !1
      , pc = []
      , mc = [];
    const wc = "[???]";
    let gc = 0;
    const yc = {
        useGrouping: !1
    };
    ac.p = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static Eui() {
            return ac.q8t() || dc && "en-US" !== dc && !dc.startsWith("synthetic-")
        }
        static Ro(t) {
            if (ac.zt(t),
            dc = t,
            cc = ac.v(ac.p.Cui),
            ac.p.Eui() ? cc._ui("loader/lang/precompiled-en-US.json", !0) : cc._ui("lang/en-US.json"),
            "en-US" !== dc)
                if (dc.startsWith("synthetic-")) {
                    let t = ac.p.Tui(dc);
                    if (!t)
                        throw new Error(`invalid synthetic language '${dc}'`);
                    uc = ac.v(ac.p.Iui, cc, t)
                } else
                    uc = ac.v(ac.p.Cui),
                    ac.p.Eui() ? uc._ui(`loader/lang/precompiled-${dc}.json`, !0) : uc._ui(`lang/${dc}.json`);
            fc = !0;
            for (let t of pc)
                ac.p.MW(t);
            return ac.Io(pc),
            ac.p.yrt()
        }
        static MW(t, i) {
            if (ac.zt(t),
            ac.p.Eui()) {
                if (!i)
                    return
            } else if (i)
                throw new Error("do not specify the 'includeWhenPrecompiled' flag on AddPath when not using a pre-compiled language file");
            fc ? (cc._ui(`${t}/en-US.json`),
            "en-US" === dc || dc.startsWith("synthetic-") || uc._ui(`${t}/${dc}.json`)) : pc.push(t)
        }
        static Pui(t) {
            ac.zt(t),
            cc._ui(t)
        }
        static Gui(t) {
            ac.zt(t),
            "en-US" === dc || dc.startsWith("synthetic-") || uc._ui(t)
        }
        static yrt(t) {
            return "en-US" === dc || dc.startsWith("synthetic-") ? cc.yrt(t) : Promise.all([cc.yrt(t), uc.yrt(t)]).then( () => ac.Qs.Aui(uc.Rui()))
        }
        static kui(t, i) {
            return i ? i.startsWith("http:") || i.startsWith("https:") || t.endsWith(".help-url") ? i : (0 === gc && (() => {})(`[LANG] Failed to find '${dc}' string ${ac.p.rot() + t}'`),
            `[${i}]`) : i
        }
        static qs(t) {
            if (ac.zt(t),
            lc(cc, "English language not initialised"),
            uc) {
                let i = uc.Oui(t);
                return i === wc ? (i = cc.Oui(t),
                i === wc ? i : ac.p.kui(t, i)) : i
            }
            return cc.Oui(t)
        }
        static Dui(t, i) {
            return ac.zt(t),
            ac.Ge(i),
            uc ? uc.Fui(i) : cc.Fui(i)
        }
        static Lui(t) {
            return ac.zt(t),
            new ac.ix(ac.p.qs(t))
        }
        static Bui(t) {
            return !!ac.p.qs(t).match(/{\d+}|\{{1}.+\}{1}/g)
        }
        static Uui(t) {
            ac.RH(t);
            const i = [];
            for (const e of t)
                "number" == typeof e ? i.push(ac.p.UE(e)) : i.push(e);
            return i
        }
        static UE(t, i) {
            return ac.Ck(t),
            i = Object.assign({}, yc, i),
            t.toLocaleString((uc || cc).if(), i)
        }
        static Nui(t, ...i) {
            return ac.zt(t),
            1 === i.length && ac.Jvt(i[0]) ? ac.joi(ac.p.qs(t), i[0]) : ac.Uoi(ac.p.qs(t), ...ac.p.Uui(i))
        }
        static jui(t, ...i) {
            return ac.zt(t),
            new ac.ix(ac.Uoi(ac.p.qs(t), ...ac.p.Uui(i)))
        }
        static $ui(t, i, ...e) {
            let s;
            if (ac.zt(t),
            ac.kQ(i),
            i && "number" == typeof i.zui)
                s = i.zui;
            else {
                const t = i && "number" == typeof i.Vui ? Math.floor(i.Vui) : 0;
                if (t < 0 || t >= e.length)
                    throw new RangeError("invalid plural index");
                if (s = e[t],
                "number" != typeof s)
                    throw new TypeError("expected number for pluralising string")
            }
            const n = ac.p.Dui(t, s)
              , r = ac.Noi(ac.p.qs(t + "." + n), ...ac.p.Uui(e));
            return i && i.LHt ? new ac.ix(r) : r
        }
        static rot() {
            let t = mc.length
              , i = t - 1;
            for (; i >= 0 && "." === mc[i][0]; --i)
                ;
            i < 0 && (i = 0);
            let e = "";
            for (; i < t; ++i)
                e += mc[i];
            return e
        }
        static Wui() {
            let t = ac.p.rot();
            uc && uc.Hui(t),
            cc && cc.Hui(t)
        }
        static Yue(t) {
            ac.zt(t),
            lc("." !== t[0], "context cannot be relative."),
            lc("." !== t.slice(-1), "context cannot finish with a '.'.");
            const i = i => i.startsWith(".") ? t + i : t + "." + i
              , e = t => self.lang(i(t));
            return e.dme = (t, ...e) => self.h_(i(t), ...e),
            e.BB = t => self.Iet(i(t)),
            e.e4t = (t, ...e) => self.e_(i(t), ...e),
            e.UHt = (t, e, ...s) => self.n_(i(t), e, ...s),
            e
        }
        static u(t) {
            ac.zt(t),
            lc(mc.length || "." !== t[0], "first pushed language context cannot be relative"),
            mc.push(t),
            lc(mc.length < 100, `language context stack reached 100 items - is this right? Stack is: ${mc.join(";")}`),
            ac.p.Wui()
        }
        static j() {
            lc(mc.length > 0, "popping language context stack when it's empty - check PushContext/PopContext calls paired correctly"),
            mc.pop(),
            ac.p.Wui()
        }
        static Kui() {
            return "en-US" === dc
        }
        static qui() {
            return dc
        }
        static Xui() {
            return (uc || cc).Yui()
        }
        static Rui() {
            return !!uc && uc.Rui()
        }
        static Jui(t) {
            return `${t}${!ac.p.Rui() ? ac.xJt.Qai : ac.xJt.tli}`
        }
        static Zui(t) {
            return uc ? uc.Qui(t) : cc.Qui(t)
        }
        static Mr(t) {
            t ? --gc : ++gc,
            lc(gc >= 0, "disabled missing string logging too many times")
        }
    }
    ,
    ac.p.tci = wc,
    window.lang = ac.p.qs,
    window.Iet = ac.p.Lui,
    window.h_ = ac.p.Nui,
    window.e_ = ac.p.jui,
    window.n_ = ac.p.$ui,
    window.syt = ac.p.Bui
}
{
    const bc = self.t;
    bc.p.Cui = class extends bc.Me {
        constructor() {
            super(),
            this.ici = [],
            this.eci = !1,
            this.sci = "",
            this.nci = "",
            this.rci = "",
            this.hci = !1,
            this.oci = new Map,
            this.Ght = "",
            this.aci = null
        }
        if() {
            return this.rci
        }
        Yui() {
            return this.nci
        }
        _ui(t) {
            if (bc.zt(t),
            this.ici.includes(t))
                throw new Error("same language URL added twice");
            this.ici.push(t)
        }
        async yrt(t) {
            if (!this.ici.length)
                return Promise.resolve(this);
            const i = [];
            return bc.mf(i, this.ici),
            bc.Io(this.ici),
            await Promise.all(i.map(async i => {
                const e = await bc.O4(i);
                this.m9t(e, t)
            }
            )),
            this
        }
        m9t(t, i) {
            bc.IL(t);
            let e = t.languageTag;
            if (this.rci) {
                if (this.rci !== e)
                    throw new Error(`language file has wrong language tag (has '${e}', expected '${this.rci}')`)
            } else
                this.rci = e,
                void 0 !== Intl.PluralRules && (this.aci = new Intl.PluralRules(this.rci));
            if (t.main) {
                this.sci = t.englishName,
                this.nci = t.nativeName;
                const i = t.rightToLeft;
                this.hci = "string" == typeof i ? "true" === i : !!i,
                this.eci = !0
            }
            this.lci(t.text, "", i)
        }
        lci(t, i, e) {
            bc.IL(t),
            bc.zt(i),
            i && (i += ".");
            for (let[s,n] of Object.entries(t)) {
                let t = i + s;
                if ("object" == typeof n)
                    this.lci(n, t, e);
                else if ("string" == typeof n) {
                    if (!e && this.oci.has(t))
                        throw new Error(`key name '${t}' already exists in language string map`);
                    this.oci.set(t, n)
                }
            }
        }
        Hui(t) {
            bc.zt(t),
            this.Ght = t
        }
        Oui(t) {
            if (bc.zt(t),
            !this.eci)
                throw new Error("language not loaded");
            if (!t)
                throw new Error("cannot lookup empty key");
            if (t.startsWith(".")) {
                if (!this.Ght)
                    throw new Error("relative language string used with no context set");
                t = this.Ght + t
            }
            let i = this.oci.get(t);
            return void 0 === i ? bc.p.tci : i
        }
        Fui(t) {
            return bc.Ge(t),
            this.aci ? this.aci.select(t) : "other"
        }
        Rui() {
            if (!this.eci)
                throw new Error("language not loaded");
            return this.hci
        }
        Qui(t) {
            const i = "exporters.preview.debugger."
              , e = /^(plugins|behaviors)\.\w+\.name$/
              , s = /^(plugins|behaviors)\.\w+\.debugger\./
              , n = /^(plugins|behaviors)\.\w+\.properties\.[\w-]+\.name$/
              , r = /^(plugins|behaviors)\.\w+\.properties\.[\w-]+\.items/
              , h = [];
            for (const t of this.oci.keys())
                t.startsWith(i) ? h.push({
                    uci: t,
                    key: t.substr(27)
                }) : (e.test(t) || s.test(t) || n.test(t) || r.test(t)) && h.push({
                    uci: t,
                    key: t
                });
            return h
        }
    }
}
{
    const vc = self.t;
    function Sc(t, i) {
        if (!i)
            return t;
        let e = ""
          , s = !1
          , n = !1;
        for (let r = 0, h = t.length; r < h; ++r) {
            let h = t.charAt(r);
            "[" === h ? (s = !0,
            e += h) : "]" === h ? (s = !1,
            e += h) : "{" === h ? (n = !0,
            e += h) : "}" === h ? (n = !1,
            e += h) : e += s || n ? h : i(h)
        }
        return e
    }
    function xc(t) {
        return t.toUpperCase()
    }
    function Mc(t) {
        return t.toLowerCase()
    }
    let Ec = new Set([" ", "\n", "\t", "-", ".", ":", ";", "'", '"', "(", ")", "+", "=", "[", "]", "{", "}", "!", "?", "|", "\\", "/", "<", ">", "@", "#", "~", "%", "&", "*"]);
    function Cc(t, i) {
        if (Ec.has(t))
            return t;
        {
            let e = "";
            for (let s = 0; s < i; ++s)
                e += t;
            return e
        }
    }
    function _c(t) {
        return function(i) {
            return Cc(i, t)
        }
    }
    let Tc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
      , Ic = "jqJQ"
      , Pc = new Map;
    for (let Dc = 0, Fc = Tc.length; Dc < Fc; ++Dc)
        Pc.set(Tc.charAt(Dc), Ic.charAt(Dc));
    function Gc(t) {
        return Pc.get(t) || t
    }
    let Ac = new Map([["a", "4"], ["A", "4"], ["B", "|3"], ["c", "<"], ["C", "("], ["D", "[)"], ["e", "3"], ["E", "3"], ["g", "9"], ["G", "9"], ["H", "|-|"], ["i", "1"], ["I", "1"], ["K", "|<"], ["l", "L"], ["L", "|_"], ["M", "(\\/)"], ["N", "(\\)"], ["o", "0"], ["O", "0"], ["R", "|2"], ["s", "5"], ["S", "5"], ["t", "7"], ["T", "7"], ["U", "|_|"], ["V", "\\/"], ["W", "(/\\)"]]);
    function Rc(t) {
        return Ac.get(t) || t
    }
    function kc(t) {
        switch (t) {
        case "synthetic-uppercase":
            return xc;
        case "synthetic-lowercase":
            return Mc;
        case "synthetic-repeat-2":
            return _c(2);
        case "synthetic-repeat-3":
            return _c(3);
        case "synthetic-repeat-4":
            return _c(4);
        case "synthetic-rockdots":
            return Gc;
        case "synthetic-leet":
            return Rc;
        default:
            return null
        }
    }
    function Oc(t) {
        let i = kc(t);
        return t => Sc(t, i)
    }
    vc.p.Tui = function(t) {
        return Oc(t)
    }
    ,
    vc.p.Iui = class extends vc.Me {
        constructor(t, i) {
            super(),
            this.cci = t,
            this.dci = i
        }
        if() {
            return this.cci.if()
        }
        Fui(t) {
            return this.cci.Fui(t)
        }
        Qui(t) {
            return this.cci.Qui(t)
        }
        yrt() {
            return self
        }
        Hui(t) {}
        Oui(t) {
            vc.zt(t);
            let i = this.cci.Oui(t);
            return (e = i) === vc.p.tci || e.startsWith("http:") || e.startsWith("https:") ? i : this.dci(i);
            var e
        }
        Rui() {
            return this.cci.Rui()
        }
    }
}
{
    const Lc = self.t;
    let Bc = new Map
      , Uc = new Map
      , Nc = new Map;
    const jc = "unknown";
    function $c(t, i, e) {
        if (Lc.Ge(t),
        t = Math.floor(t),
        Lc.zt(i),
        Lc.gL(e),
        Bc.has(t))
            throw new Error("duplicate key code");
        if (Uc.has(i))
            throw new Error("duplicate key id");
        return Bc.set(t, i),
        Uc.set(i, t),
        e && Nc.set(i, e),
        t
    }
    class zc extends Lc.Me {
        constructor() {
            super(),
            this.fci = $c(8, "backspace"),
            this.Ik = $c(9, "tab"),
            this.pci = $c(12, "clear"),
            this.aY = $c(13, "enter"),
            this.YX = $c(16, "shift", ""),
            this.mci = $c(17, "control", "Ctrl"),
            this.wE = $c(18, "alt", Lc.kt.hyt ? "" : "Alt"),
            this.wci = $c(19, "pause"),
            this.gci = $c(20, "caps-lock"),
            this.VJ = $c(27, "escape"),
            this.yci = $c(33, "page-up"),
            this.OF = $c(32, "space"),
            this.bci = $c(34, "page-down"),
            this.vci = $c(35, "end"),
            this.Sci = $c(36, "home"),
            this.zZ = $c(37, "left-arrow", ""),
            this.UZ = $c(38, "up-arrow", ""),
            this.WZ = $c(39, "right-arrow", ""),
            this.FZ = $c(40, "down-arrow", ""),
            this.xci = $c(45, "insert"),
            this.JRt = $c(46, "delete"),
            this.Mci = $c(48, "0"),
            this.Eci = $c(49, "1"),
            this.Cci = $c(50, "2"),
            this._ci = $c(51, "3"),
            this.Tci = $c(52, "4"),
            this.Ici = $c(53, "5"),
            this.Pci = $c(54, "6"),
            this.Gci = $c(55, "7"),
            this.Aci = $c(56, "8"),
            this.Rci = $c(57, "9"),
            this.A = $c(65, "a"),
            this.B = $c(66, "b"),
            this.C = $c(67, "c"),
            this.D = $c(68, "d"),
            this.E = $c(69, "e"),
            this.F = $c(70, "f"),
            this.G = $c(71, "g"),
            this.H = $c(72, "h"),
            this.I = $c(73, "i"),
            this.J = $c(74, "j"),
            this.K = $c(75, "k"),
            this.L = $c(76, "l"),
            this.M = $c(77, "m"),
            this.N = $c(78, "n"),
            this.O = $c(79, "o"),
            this.P = $c(80, "p"),
            this.Q = $c(81, "q"),
            this.R = $c(82, "r"),
            this.S = $c(83, "s"),
            this.T = $c(84, "t"),
            this.U = $c(85, "u"),
            this.V = $c(86, "v"),
            this.W = $c(87, "w"),
            this.X = $c(88, "x"),
            this.Y = $c(89, "y"),
            this.Z = $c(90, "z"),
            this.kci = $c((Lc.kt.hyt,
            91), "left-meta", Lc.kt.hyt ? "" : ""),
            this.Oci = $c(Lc.kt.hyt ? 93 : 92, "right-meta", Lc.kt.hyt ? "" : ""),
            this.Dci = $c(224, "firefox-meta", ""),
            this.Fci = $c(96, "numpad-0"),
            this.Lci = $c(97, "numpad-1"),
            this.Bci = $c(98, "numpad-2"),
            this.Uci = $c(99, "numpad-3"),
            this.Nci = $c(100, "numpad-4"),
            this.jci = $c(101, "numpad-5"),
            this.$ci = $c(102, "numpad-6"),
            this.zci = $c(103, "numpad-7"),
            this.Vci = $c(104, "numpad-8"),
            this.Wci = $c(105, "numpad-9"),
            this.Hci = $c(106, "numpad-multiply"),
            this.Kci = $c(107, "numpad-add"),
            this.qci = $c(109, "numpad-subtract"),
            this.Xci = $c(110, "numpad-decimal"),
            this.Yci = $c(111, "numpad-divide"),
            this.F1 = $c(112, "f1"),
            this.F2 = $c(113, "f2"),
            this.F3 = $c(114, "f3"),
            this.F4 = $c(115, "f4"),
            this.F5 = $c(116, "f5"),
            this.F6 = $c(117, "f6"),
            this.F7 = $c(118, "f7"),
            this.F8 = $c(119, "f8"),
            this.F9 = $c(120, "f9"),
            this.n7t = $c(121, "f10"),
            this.Jci = $c(122, "f11"),
            this.Zci = $c(123, "f12"),
            this.Qci = $c(144, "num-lock"),
            this.tdi = $c(145, "scroll-lock"),
            this.idi = $c(180, "launch-mail"),
            this.edi = $c(183, "launch-calculator"),
            this.sdi = $c(186, "semicolon", ";"),
            this.ndi = $c(187, "equals", "="),
            this.rdi = $c(188, "comma", ","),
            this.hdi = $c(189, "subtract", "-"),
            this.odi = $c(190, "period", "."),
            this.adi = $c(191, "slash", "/"),
            this.ldi = $c(192, "apostrophe", "'"),
            this.udi = $c(219, "open-square-bracket", "["),
            this.cdi = $c(221, "close-square-bracket", "]"),
            this.ddi = $c(220, "backslash", "\\"),
            this.fdi = $c(222, "hash", "#"),
            this.pdi = $c(223, "backtick", "`"),
            this.Lmt = 1e4,
            this.xdt = 10001,
            this.Gdt = 10002,
            this.vdt = 10003,
            this.Tdt = 10004,
            this.Idt = 10005,
            this.Sdt = 10006,
            this.Mdt = 10007,
            this.mdi = 10008,
            this.wdi = 10009,
            this.CDt = 10010,
            this.gdi = 10011,
            this.ydi = 10012,
            this.bdi = 10013,
            this.vdi = 10014,
            this.Sdi = 10015,
            this.zmt = 10016,
            this.Nmt = 10017
        }
        xdi(t) {
            return t >= 1e4
        }
        cdt(t, i) {
            if (this.xdi(t)) {
                if (this.xdi(i))
                    return t === i
            } else {
                if (!this.xdi(i))
                    return t === i;
                {
                    let e = t;
                    t = i,
                    i = e
                }
            }
            return this.Mdi(t).includes(i)
        }
        Edi(t) {
            return [this.Lmt, this.xdt, this.Gdt, this.vdt, this.Tdt, this.Idt, this.Sdt, this.Mdt, this.mdi, this.wdi].some(i => this.Mdi(i).includes(t))
        }
        Mdi(t) {
            if (!this.xdi(t))
                return [t];
            switch (t) {
            case this.Lmt:
                return [this.Mci, this.Fci, this.xci];
            case this.xdt:
                return [this.Eci, this.Lci, this.vci];
            case this.Gdt:
                return [this.Cci, this.Bci];
            case this.vdt:
                return [this._ci, this.Uci, this.bci];
            case this.Tdt:
                return [this.Tci, this.Nci];
            case this.Idt:
                return [this.Ici, this.jci, this.pci];
            case this.Sdt:
                return [this.Pci, this.$ci];
            case this.Mdt:
                return [this.Gci, this.zci, this.Sci];
            case this.mdi:
                return [this.Aci, this.Vci];
            case this.wdi:
                return [this.Rci, this.Wci, this.yci];
            case this.CDt:
                return [this.JRt, this.Xci, this.fci];
            case this.gdi:
                return [this.zZ, this.Nci];
            case this.ydi:
                return [this.WZ, this.$ci];
            case this.bdi:
                return [this.FZ, this.Bci];
            case this.vdi:
                return [this.UZ, this.Vci];
            case this.Sdi:
                return [this.kci, this.Oci, this.Dci];
            case this.zmt:
                return [this.ndi, this.Kci];
            case this.Nmt:
                return [this.hdi, this.qci];
            default:
                throw new RangeError("invalid virtual key code")
            }
        }
        Cdi(t) {
            return Lc.Ge(t),
            t = Math.floor(t),
            Bc.get(t) || jc
        }
        _di(t) {
            return Lc.zt(t),
            Uc.get(t) || 0
        }
        La(t) {
            if ("string" == typeof t)
                return this.Tdi(t);
            if ("number" == typeof t)
                return this.Idi(t);
            throw new TypeError("expected string or number")
        }
        Idi(t) {
            return Lc.Ge(t),
            t = Math.floor(t),
            Bc.has(t) ? this.Tdi(this.Cdi(t)) : self.h_("ui.keyboard.keyNames.codeNumber", t)
        }
        Tdi(t) {
            return Lc.zt(t),
            self.lang("ui.keyboard.keyNames." + t)
        }
        eyt(t) {
            if ("string" == typeof t)
                return this.Pdi(t);
            if ("number" == typeof t)
                return this.Gdi(t);
            throw new TypeError("expected string or number")
        }
        Gdi(t) {
            return Lc.Ge(t),
            t = Math.floor(t),
            Nc.get(this.Cdi(t)) || null
        }
        Pdi(t) {
            return Lc.zt(t),
            Nc.get(t) || null
        }
        $1t(t) {
            return this.eyt(t) || this.La(t)
        }
    }
    Lc.Mk = Lc.v(zc)
}
self.t.gF = Object.freeze({
    sV: 0,
    vF: 1,
    mat: 2
});
{
    const Vc = self.t
      , Wc = 333
      , Hc = 25
      , Kc = 333
      , qc = 33
      , Xc = 20
      , Yc = 500;
    let Jc = 0
      , Zc = 0
      , Qc = 0;
    Vc.Adi = class extends Vc.Me {
        constructor(t, i) {
            super(),
            this.Rdi = t.id,
            this.kdi = i,
            this.wY = t.clientX,
            this.mY = t.clientY,
            this.Odi = Date.now(),
            this.Ddi = this.wY,
            this.Fdi = this.mY,
            this.Ldi = !1,
            this.Bdi = !1,
            this.Udi = !1,
            this.Ndi = null,
            this.jdi = null
        }
        $di(t) {
            this.Ndi = t
        }
        zdi(t) {
            this.jdi = t
        }
        PF(t) {
            this.Ddi = t.clientX,
            this.Fdi = t.clientY;
            const i = Vc.di(this.wY, this.mY, this.Ddi, this.Fdi);
            i > Hc && (this.Ldi = !0),
            i > Xc && (this.Bdi = !0)
        }
        Vdi() {
            return !!this.kdi.ownerDocument.defaultView
        }
        Wdi() {
            if (this.Udi)
                return;
            if (Date.now() - this.Odi >= Yc && !this.Bdi && Vc.di(this.wY, this.mY, this.Ddi, this.Fdi) < Xc) {
                this.Udi = !0;
                const t = new MouseEvent("contextmenu",{
                    bubbles: !0,
                    cancelable: !0,
                    screenX: this.wY,
                    screenY: this.mY,
                    clientX: this.wY,
                    clientY: this.mY,
                    button: 2,
                    buttons: 2
                });
                this.kdi.dispatchEvent(t)
            }
        }
        Hdi(t) {
            this.Ddi = t.clientX,
            this.Fdi = t.clientY;
            const i = Date.now();
            let e = !1;
            if (!this.Ldi && i - this.Odi < Wc && Vc.di(this.wY, this.mY, this.Ddi, this.Fdi) <= Hc) {
                let s = null;
                const n = {
                    fk: Vc.gF.sV,
                    uk: "touch" === t.pointerType,
                    screenX: t.screenX,
                    screenY: t.screenY,
                    clientX: t.clientX,
                    clientY: t.clientY,
                    pageX: t.pageX,
                    pageY: t.pageY,
                    pointerType: t.pointerType
                };
                i - Qc <= Wc + Kc && Vc.di(this.wY, this.mY, Jc, Zc) <= qc ? (s = new CustomEvent("UIDoubleTap",{
                    bubbles: !0,
                    cancelable: !0,
                    detail: n
                }),
                Qc = 0,
                e = !0,
                this.jdi && this.jdi()) : (s = new CustomEvent("UITap",{
                    bubbles: !0,
                    cancelable: !0,
                    detail: n
                }),
                Jc = this.Ddi,
                Zc = this.Fdi,
                Qc = i,
                this.Ndi && this.Ndi()),
                e = !this.kdi.dispatchEvent(s)
            }
            return this.kdi = null,
            e
        }
    }
    ;
    const td = new Map;
    let id = -1;
    function ed() {
        id = -1;
        for (const [t,i] of td.entries())
            i.Vdi() ? i.Wdi() : td.delete(t);
        td.size && (id = requestAnimationFrame(ed))
    }
    Vc.Kdi = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static qdi(t, i) {
            const e = td.get(t.id);
            e && e.$di(i)
        }
        static Xdi(t, i) {
            const e = td.get(t.id);
            e && e.zdi(i)
        }
        static Ydi(t, i, e) {
            let s = !1;
            if ("CustomPointerDown" === t)
                td.set(i.id, Vc.v(Vc.Adi, i, e)),
                -1 === id && "iOS" === Vc.kt.OS && (id = requestAnimationFrame(ed));
            else if ("CustomPointerMove" === t) {
                const t = td.get(i.id);
                t && t.PF(i)
            } else if ("CustomPointerUp" === t) {
                const t = td.get(i.id);
                t && (s = t.Hdi(i)),
                td.delete(i.id)
            }
            return s
        }
    }
}
{
    const sd = self.t
      , nd = {
        capture: !0,
        passive: !1
    }
      , rd = {
        capture: !0,
        passive: !0
    };
    let hd = !1
      , od = !1;
    function ad(t) {
        return function(i) {
            if (!sd.ev())
                return;
            if (i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)
                return;
            if (hd && "click" === i.type)
                return void (hd = !1);
            if (od && "dblclick" === i.type)
                return void (od = !1);
            const e = new CustomEvent(t,{
                bubbles: !0,
                cancelable: !0,
                detail: {
                    id: -1,
                    fk: i.button,
                    uk: !1,
                    screenX: i.screenX,
                    screenY: i.screenY,
                    clientX: i.clientX,
                    clientY: i.clientY,
                    pageX: i.pageX,
                    pageY: i.pageY,
                    ctrlKey: i.ctrlKey,
                    shiftKey: i.shiftKey,
                    altKey: i.altKey,
                    metaKey: i.metaKey,
                    pointerType: "mouse"
                }
            });
            i.target.dispatchEvent(e) || i.preventDefault()
        }
    }
    function ld(t) {
        return function(i) {
            if (!sd.ev())
                return;
            if ("mouse" === i.pointerType)
                return;
            const e = {
                id: i.pointerId,
                fk: sd.gF.sV,
                uk: "touch" === i.pointerType,
                screenX: i.screenX,
                screenY: i.screenY,
                clientX: i.clientX,
                clientY: i.clientY,
                pageX: i.pageX,
                pageY: i.pageY,
                ctrlKey: !1,
                shiftKey: !1,
                altKey: !1,
                metaKey: !1,
                pointerType: i.pointerType
            };
            sd.Kdi.qdi(e, () => hd = !0),
            sd.Kdi.Xdi(e, () => od = !0);
            const s = sd.Kdi.Ydi(t, e, i.target);
            sd.Kdi.qdi(e, null),
            sd.Kdi.Xdi(e, null),
            s && i.preventDefault()
        }
    }
    let ud = -1;
    function cd(t) {
        const i = t.touches;
        if (0 === t.touches.length)
            return;
        const e = window.innerWidth <= 600 ? 30 : 50
          , s = i[0].pageX;
        (s < e || s > window.innerWidth - 15) && t.preventDefault()
    }
    window.addEventListener("pointermove", t => {
        "mouse" === t.pointerType && (ud = t.pointerId)
    }
    , rd),
    sd.jJ = function() {
        return ud
    }
    ,
    "Safari" === sd.kt._r && document.addEventListener("touchstart", cd, nd),
    document.addEventListener("click", ad("UITap"), nd),
    document.addEventListener("dblclick", ad("UIDoubleTap"), nd),
    document.addEventListener("pointerdown", ld("CustomPointerDown"), nd),
    document.addEventListener("pointermove", ld("CustomPointerMove"), rd),
    document.addEventListener("pointerup", ld("CustomPointerUp"), nd)
}
{
    const dd = self.t;
    dd.Event = class {
        constructor(t, i) {
            dd.zt(t),
            this.type = t,
            this.cancelable = !!i,
            this.defaultPrevented = !1,
            this.Jdi = !1,
            this.TZt = !1
        }
        preventDefault() {
            if (!this.cancelable)
                throw new Error(`event '${this.type}' is not cancelable`);
            this.defaultPrevented = !0
        }
        stopPropagation() {
            if (!this.cancelable)
                throw new Error(`event '${this.type}' cannot be stopped`);
            if (this.TZt)
                throw new Error(`cannot stop async event '${this.type}' propagation`);
            this.Jdi = !0
        }
    }
}
{
    const fd = self.t;
    fd.Event.v_ = class extends fd.Me {
        constructor() {
            super(),
            this.Zdi = new Map,
            this.Qdi = !1
        }
        he() {
            if (this.Qdi)
                throw new Error("already released");
            this.fbt(),
            this.Qdi = !0,
            fd.he(this)
        }
        gn() {
            return this.Qdi
        }
        fbt() {
            if (this.Zdi) {
                for (let t of this.Zdi.values())
                    t.he();
                this.Zdi.clear()
            }
        }
        tfi(t, i) {
            fd.zt(t);
            let e = this.Zdi.get(t);
            return e || (i ? (e = fd.v(fd.Event.ifi, t),
            this.Zdi.set(t, e),
            e) : null)
        }
        efi(t) {
            return this.Zdi.has(t)
        }
        addEventListener(t, i, e) {
            fd.zt(t),
            fd.nu(i),
            this.tfi(t, !0).sfi(i, !!e)
        }
        removeEventListener(t, i, e) {
            fd.zt(t),
            fd.nu(i);
            let s = this.tfi(t, !1);
            s && (s.nfi(i, !!e),
            s.rfi() && this.Zdi.delete(t))
        }
        dispatchEvent(t) {
            fd.U(t, fd.Event),
            fd.zt(t.type);
            const i = this.tfi(t.type, !1);
            return !i || (t.cancelable ? i.hfi(t) : i.ofi(t))
        }
        afi(t) {
            fd.U(t, fd.Event),
            fd.zt(t.type);
            const i = this.tfi(t.type, !1);
            return i ? (t.TZt = !0,
            i.lfi(t)) : Promise.resolve(!0)
        }
        async ufi(t) {
            fd.U(t, fd.Event),
            fd.zt(t.type);
            const i = this.tfi(t.type, !1);
            if (!i)
                return !0;
            this.Zdi.delete(t.type),
            t.TZt = !0;
            const e = await i.lfi(t);
            return i.he(),
            e
        }
        async cfi(t) {
            fd.U(t, fd.Event),
            fd.zt(t.type);
            const i = this.tfi(t.type, !1);
            return !i || await i.dfi(t)
        }
        ffi(t) {
            fd.U(t, fd.Event),
            fd.zt(t.type);
            const i = this.tfi(t.type, !1);
            return !i || i.pfi(t)
        }
        async Xmt(t) {
            fd.U(t, fd.Event),
            fd.zt(t.type);
            const i = this.tfi(t.type, !1);
            return !i || await i.mfi(t)
        }
        wfi(t) {
            fd.U(t, fd.Event),
            fd.zt(t.type);
            const i = this.tfi(t.type, !1);
            if (!i)
                return null;
            if (t.cancelable)
                throw new Error("not supported");
            return i.gfi(t)
        }
        yfi(t) {
            for (const i of this.Zdi.values())
                i.yfi(t)
        }
    }
}
{
    const pd = self.t
      , md = self.assert;
    pd.Event.ifi = class extends pd.Me {
        constructor(t) {
            super(),
            this.aGt = t,
            this.bfi = [],
            this.vfi = new Set,
            this.Sfi = [],
            this.xfi = new Set,
            this.Mfi = 0,
            this.Efi = []
        }
        he() {
            this.Mfi > 0 || (pd.Io(this.bfi),
            this.vfi.clear(),
            pd.Io(this.Sfi),
            this.xfi.clear(),
            pd.Io(this.Efi),
            pd.he(this))
        }
        sfi(t, i) {
            if (pd.nu(t),
            this.Cfi())
                this.Efi.push({
                    op: "add",
                    _fi: t,
                    capture: i
                });
            else if (i) {
                if (this.vfi.has(t))
                    return;
                this.bfi.push(t),
                this.vfi.add(t)
            } else {
                if (this.xfi.has(t))
                    return;
                this.Sfi.push(t),
                this.xfi.add(t)
            }
        }
        nfi(t, i) {
            pd.nu(t),
            this.Cfi() ? this.Efi.push({
                op: "remove",
                _fi: t,
                capture: i
            }) : i ? this.vfi.has(t) && (this.vfi.delete(t),
            pd.sii(this.bfi, t)) : this.xfi.has(t) && (this.xfi.delete(t),
            pd.sii(this.Sfi, t))
        }
        rfi() {
            return !this.bfi.length && !this.Sfi.length
        }
        Cfi() {
            return this.Mfi > 0
        }
        Tfi() {
            const t = new Set
              , i = new Set;
            for (const e of this.Efi)
                if ("add" === e.op)
                    this.sfi(e._fi, e.capture),
                    e.capture ? i.delete(e._fi) : t.delete(e._fi);
                else {
                    if ("remove" !== e.op)
                        throw new Error("invalid op");
                    e.capture ? (this.vfi.delete(e._fi),
                    i.add(e._fi)) : (this.xfi.delete(e._fi),
                    t.add(e._fi))
                }
            pd.lAt(this.Sfi, t),
            pd.lAt(this.bfi, i),
            pd.Io(this.Efi)
        }
        hfi(t) {
            md(t instanceof pd.Event, "invalid event"),
            md(t.type === this.aGt, "event type does not match handler"),
            this.Ifi();
            let i = !1;
            for (let e = 0, s = this.bfi.length; e < s; ++e)
                if (this.bfi[e](t),
                t.Jdi) {
                    i = !0;
                    break
                }
            if (!i)
                for (let i = 0, e = this.Sfi.length; i < e && (this.Sfi[i](t),
                !t.Jdi); ++i)
                    ;
            return this.Pfi(),
            !t.defaultPrevented
        }
        ofi(t) {
            this.Ifi();
            for (let i = 0, e = this.bfi.length; i < e; ++i)
                this.bfi[i](t);
            for (let i = 0, e = this.Sfi.length; i < e; ++i)
                this.Sfi[i](t);
            return this.Pfi(),
            !0
        }
        Ifi() {
            this.Mfi++
        }
        Pfi() {
            this.Mfi--,
            0 === this.Mfi && this.Efi.length > 0 && this.Tfi()
        }
        yfi(t) {
            t ? this.Ifi() : this.Pfi()
        }
        lfi(t) {
            md(t instanceof pd.Event, "invalid event"),
            md(t.type === this.aGt, "event type does not match handler");
            let i = [];
            for (let e = 0, s = this.bfi.length; e < s; ++e) {
                let s = this.bfi[e];
                i.push(pd.lre( () => s(t)))
            }
            for (let e = 0, s = this.Sfi.length; e < s; ++e) {
                let s = this.Sfi[e];
                i.push(pd.lre( () => s(t)))
            }
            return Promise.all(i).then( () => !t.defaultPrevented)
        }
        pfi(t) {
            md(t instanceof pd.Event, "invalid event"),
            md(t.type === this.aGt, "event type does not match handler");
            const i = [];
            this.Ifi();
            for (let e = 0, s = this.bfi.length; e < s; ++e) {
                const s = this.bfi[e](t);
                s instanceof Promise && i.push(s)
            }
            for (let e = 0, s = this.Sfi.length; e < s; ++e) {
                const s = this.Sfi[e](t);
                s instanceof Promise && i.push(s)
            }
            return this.Pfi(),
            i.length ? Promise.all(i).then( () => !t.defaultPrevented) : !t.defaultPrevented
        }
        async dfi(t) {
            return await this.pfi(t)
        }
        async mfi(t) {
            md(t instanceof pd.Event, "invalid event"),
            md(t.type === this.aGt, "event type does not match handler"),
            this.Ifi();
            for (let i = 0, e = this.bfi.length; i < e; ++i) {
                const e = this.bfi[i](t);
                e instanceof Promise && await e
            }
            for (let i = 0, e = this.Sfi.length; i < e; ++i) {
                const e = this.Sfi[i](t);
                e instanceof Promise && await e
            }
            return this.Pfi(),
            !t.defaultPrevented
        }
        *gfi(t) {
            this.Ifi();
            for (let i = 0, e = this.bfi.length; i < e; ++i) {
                const e = this.bfi[i](t);
                pd.Gfi(e) && (yield*e)
            }
            for (let i = 0, e = this.Sfi.length; i < e; ++i) {
                const e = this.Sfi[i](t);
                pd.Gfi(e) && (yield*e)
            }
            this.Pfi()
        }
    }
}
{
    const wd = self.t
      , gd = self.assert;
    let yd = [];
    wd.bk = class {
        constructor() {
            throw new TypeError("static class")
        }
        static wG(t) {
            let i = t.which;
            for (; yd.length <= i; )
                yd.push(!1);
            i === wd.Mk.Ik && yd[i] && t.preventDefault(),
            yd[i] = !0
        }
        static yG(t) {
            let i = t.which;
            i < 0 || i >= yd.length || (yd[i] = !1)
        }
        static Afi() {
            for (let t = 0, i = yd.length; t < i; ++t)
                yd[t] = !1
        }
        static Sk(t) {
            if (wd.Mk.xdi(t)) {
                let i = wd.Mk.Mdi(t);
                for (let t of i)
                    if (wd.bk.Rfi(t))
                        return !0;
                return !1
            }
            return wd.bk.Rfi(t)
        }
        static $F(t) {
            if (t) {
                if (wd.Wft(t)) {
                    let i = t;
                    return wd.Wft(i.detail) && (i = i.detail),
                    wd.kt.hyt ? !!i.metaKey : !!i.ctrlKey
                }
                throw new TypeError("invalid argument")
            }
            return wd.kt.hyt ? this.Sk(wd.Mk.Sdi) : this.Sk(wd.Mk.mci)
        }
        static eDt(t) {
            if (t) {
                if (wd.Wft(t)) {
                    let i = t;
                    return wd.Wft(i.detail) && (i = i.detail),
                    !!i.shiftKey
                }
                throw new TypeError("invalid argument")
            }
            return this.Sk(wd.Mk.YX)
        }
        static Fwt(t) {
            if (t) {
                if (wd.Wft(t)) {
                    let i = t;
                    return wd.Wft(i.detail) && (i = i.detail),
                    !!i.altKey
                }
                throw new TypeError("invalid argument")
            }
            return this.Sk(wd.Mk.wE)
        }
        static _dt(t) {
            if (wd.MAt(t, wd.Event, Event, CustomEvent, KeyboardEvent)) {
                let i = t;
                if (wd.Wft(i.detail)) {
                    let t = i.detail;
                    return gd("ctrlKey"in t),
                    gd("metaKey"in t),
                    gd("shiftKey"in t),
                    gd("altKey"in t),
                    t.ctrlKey || t.metaKey || t.shiftKey || t.altKey
                }
                return gd("ctrlKey"in i),
                gd("metaKey"in i),
                gd("shiftKey"in i),
                gd("altKey"in i),
                i.ctrlKey || i.metaKey || i.shiftKey || i.altKey
            }
            if (wd.Jvt(t)) {
                let i = t;
                return gd("ctrlKey"in i),
                gd("metaKey"in i),
                gd("shiftKey"in i),
                gd("altKey"in i),
                i.ctrlKey || i.metaKey || i.shiftKey || i.altKey
            }
            if (wd.aM(t))
                return wd.bk.Sk(wd.Mk.mci) || wd.bk.Sk(wd.Mk.YX) || wd.bk.Sk(wd.Mk.wE) || wd.bk.Sk(wd.Mk.Sdi);
            throw new Error("unexpected argument")
        }
        static kfi(t) {
            if (wd.MAt(t, wd.Event, Event, CustomEvent, KeyboardEvent)) {
                let i = t;
                if (wd.Wft(i.detail)) {
                    let t = i.detail;
                    return gd("ctrlKey"in t),
                    gd("metaKey"in t),
                    gd("shiftKey"in t),
                    gd("altKey"in t),
                    !(t.ctrlKey || t.metaKey || t.shiftKey || t.altKey)
                }
                return gd("ctrlKey"in i),
                gd("metaKey"in i),
                gd("shiftKey"in i),
                gd("altKey"in i),
                !(i.ctrlKey || i.metaKey || i.shiftKey || i.altKey)
            }
            if (wd.Jvt(t)) {
                let i = t;
                return gd("ctrlKey"in i),
                gd("metaKey"in i),
                gd("shiftKey"in i),
                gd("altKey"in i),
                !(i.ctrlKey || i.metaKey || i.shiftKey || i.altKey)
            }
            if (wd.aM(t))
                return !(wd.bk.Sk(wd.Mk.mci) || wd.bk.Sk(wd.Mk.YX) || wd.bk.Sk(wd.Mk.wE) || wd.bk.Sk(wd.Mk.Sdi));
            throw new Error("unexpected argument")
        }
        static Rfi(t) {
            return gd(!wd.Mk.xdi(t), "should not be virtual key code"),
            !((t = Math.floor(t)) < 0 || t >= yd.length) && yd[t]
        }
    }
    ,
    window.addEventListener("keydown", wd.bk.wG),
    window.addEventListener("keyup", wd.bk.yG),
    window.addEventListener("blur", wd.bk.Afi),
    window.addEventListener("external-keydown", wd.bk.wG),
    window.addEventListener("external-keyup", wd.bk.yG)
}
{
    const bd = self.t;
    let vd = new Set;
    bd.IF = class {
        constructor() {
            throw new TypeError("static class")
        }
        static bF(t) {
            if (bd.Ge(t),
            vd.has(t))
                throw new Error("pointer already captured");
            vd.add(t)
        }
        static he(t) {
            if (bd.Ge(t),
            !vd.has(t))
                throw new Error("pointer not captured");
            vd.delete(t)
        }
        static Ofi(t) {
            return bd.Ge(t),
            vd.has(t)
        }
    }
}
{
    const Sd = self.t
      , xd = 12
      , Md = 16
      , Ed = 35
      , Cd = "undefined" != typeof requestIdleCallback;
    let _d = []
      , Td = -1
      , Id = 0;
    function Pd(t) {
        Td = Cd && 0 === Id ? requestIdleCallback(Gd, {
            timeout: Ed
        }) : setTimeout(Gd, Id > 0 ? 1 : t)
    }
    function Gd(t) {
        if (Td = -1,
        !_d.length)
            return;
        let i = performance.now()
          , e = i
          , s = 0
          , n = 0;
        do {
            Ad(_d.shift()),
            e = performance.now(),
            ++s,
            n = (e - i) / s * 1.1
        } while (_d.length && (Cd && 0 === Id && void 0 !== t ? n < t.timeRemaining() : e - i + n < xd));
        if (-1 === Td && _d.length) {
            let t = e - i;
            Pd(Math.max(Md - t, 4))
        }
    }
    function Ad(t) {
        let i;
        try {
            i = t._fi()
        } catch (i) {
            return void t.reject(i)
        }
        t.resolve(i)
    }
    let Rd = Sd.S9t.y9t("disable-asyncify");
    Rd && (() => {})("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."),
    Sd.lre = function(t) {
        let i = null;
        return Sd.$M && (i = Sd.P9t()),
        new Promise( (e, s) => {
            _d.push({
                _fi: t,
                resolve: e,
                reject: s,
                stack: i
            }),
            Rd ? Ad(_d.pop()) : -1 === Td && Pd(Md)
        }
        )
    }
    ,
    Sd.lre.P2t = function(t) {
        if (t)
            ++Id;
        else if (--Id,
        Id < 0)
            throw new Error("already turned off high throughput mode")
    }
}
{
    const kd = self.t;
    let Od = null
      , Dd = !1;
    function Fd() {
        Od && (Dd = !Od.charging)
    }
    navigator.getBattery && navigator.getBattery().then(t => {
        Od = t,
        Fd(),
        t.addEventListener("chargingchange", Fd)
    }
    ),
    kd.Dfi = class {
        constructor() {
            throw new Error("static class")
        }
        static Ffi() {
            return Dd
        }
    }
}
{
    const Ld = self.t;
    Ld._f = class t {
        constructor(t) {
            Ld.tot(t),
            this.Lfi = !1,
            this.Bfi = t
        }
        Ff() {
            this.Lfi || (this.Lfi = !0,
            this.Bfi && (this.Bfi(),
            this.Bfi = null))
        }
        Ufi() {
            return this.Lfi
        }
        he() {
            this.Ff()
        }
        static he(i) {
            return new t( () => i.he())
        }
        static Gf(t, i, e, s, n) {
            if ("string" != typeof i && !Array.isArray(i))
                throw new TypeError("expected string or array");
            if (Ld.nu(e),
            null == s)
                s = !1;
            else if ("boolean" != typeof s && "object" != typeof s)
                throw new TypeError("invalid event listener options");
            if (n && (e = e.bind(n)),
            Array.isArray(i) || i.includes(" ")) {
                "string" == typeof i && (i = i.split(" "));
                const n = new Ld.Rf;
                for (const r of i)
                    Ld.zt(r),
                    t.addEventListener(r, e, s),
                    n.WL(Ld.v(Ld._f, () => t.removeEventListener(r, e, s)));
                return n
            }
            return t.addEventListener(i, e, s),
            Ld.v(Ld._f, () => t.removeEventListener(i, e, s))
        }
    }
    ,
    Ld.Nfi = class extends Ld._f {
        jfi(t) {
            Ld.nu(t),
            this.Bfi = t
        }
    }
    ,
    Ld.Rf = class extends Ld._f {
        constructor(...t) {
            super(),
            this.kf = new Set;
            for (let i of t)
                this.WL(i)
        }
        WL(...t) {
            if (Ld.QH(t, Ld._f),
            this.Lfi)
                throw new Error("already disposed");
            for (let i of t)
                this.kf.add(i)
        }
        Lw(t) {
            if (Ld.U(t, Ld._f),
            this.Lfi)
                throw new Error("already disposed");
            this.kf.delete(t)
        }
        M0() {
            if (this.Lfi)
                throw new Error("already disposed");
            if (this.kf) {
                for (let t of this.kf)
                    t.Ff();
                this.kf.clear()
            }
        }
        Ufi() {
            return this.Lfi
        }
        Ff() {
            if (this.Lfi)
                throw new Error("already disposed");
            this.Lfi = !0;
            for (let t of this.kf)
                t.Ff();
            this.kf.clear(),
            this.kf = null
        }
        he() {
            this.Ff()
        }
    }
}
{
    const Bd = Symbol("OK")
      , Ud = Symbol("ERR");
    class Nd {
        constructor(t, i) {
            if (t !== Bd && t !== Ud)
                throw new Error("Invalid result type");
            this.aGt = t,
            this.$fi = i
        }
        zfi() {
            return this.aGt === Bd
        }
        Vfi() {
            return this.aGt === Ud
        }
        Wfi() {
            if (this.Vfi())
                throw new Error(this.$fi);
            return this.$fi
        }
        Hfi() {
            if (this.zfi())
                throw new Error(this.$fi);
            return this.$fi
        }
        static Kfi(t) {
            const i = t.filter(t => t.Vfi());
            return 0 === i.length ? Nd.Ok(t.map(t => t.$fi)) : Nd.qfi(i.map(t => t.$fi))
        }
        static Xfi(t, i) {
            return t ? Nd.Ok(t) : Nd.qfi(i)
        }
        static Ok(t) {
            return new Nd(Bd,t)
        }
        static qfi(t) {
            return new Nd(Ud,t)
        }
    }
    self.Yfi = Nd
}
{
    const jd = self.t
      , $d = 1e3
      , zd = 100;
    let Vd = -1;
    function Wd() {
        Vd = -1
    }
    jd.Jfi = function() {
        return -1 === Vd && (Vd = Date.now(),
        self.setTimeout(Wd, 16)),
        Vd
    }
    ;
    let Hd = -1
      , Kd = -1
      , qd = new Set;
    function Xd() {
        Hd = -1,
        Kd = -1;
        let t = Date.now();
        for (let i of qd)
            if (i.Zfi(t)) {
                let t = i.Qfi();
                (-1 === Kd || t < Kd) && (Kd = t)
            } else
                qd.delete(i);
        if (-1 !== Kd) {
            let i = Math.max(Kd - t + zd, $d);
            Hd = self.setTimeout(Xd, i)
        }
    }
    jd.m_ = class {
        constructor(t, i) {
            jd.nu(t),
            jd.Ge(i),
            this.tpi = t,
            this.mo = 1e3 * i,
            this.ipi = 0,
            this.Fc = !1
        }
        qd() {
            let t = jd.Jfi();
            this.ipi = t + this.mo,
            this.Fc || (qd.add(this),
            this.Fc = !0),
            -1 === Hd ? (Kd = this.ipi,
            Hd = self.setTimeout(Xd, this.mo + zd)) : this.ipi < Kd && Kd > t + $d && (self.clearTimeout(Hd),
            Kd = this.ipi,
            Hd = self.setTimeout(Xd, this.mo + zd))
        }
        Zfi(t) {
            return !(t >= this.ipi) || (this.tpi() ? (this.ipi = t + this.mo,
            !0) : (this.Fc = !1,
            !1))
        }
        Qfi() {
            return this.ipi
        }
        ph() {
            this.Fc && (qd.delete(this),
            this.Fc = !1,
            0 === qd.size && -1 !== Hd && (self.clearTimeout(Hd),
            Hd = -1,
            Kd = -1))
        }
        he() {
            this.ph(),
            this.tpi = null
        }
    }
}
{
    const Yd = self.t;
    let Jd = new Map
      , Zd = 0
      , Qd = -1;
    function tf() {
        Qd = -1;
        let t = performance.now() - Zd;
        for (let i of Jd.values())
            i.frameCount++,
            i.epi.push(t);
        Jd.size > 0 && ef()
    }
    function ef() {
        -1 === Qd && (Qd = requestAnimationFrame(tf),
        Zd = performance.now())
    }
    Yd.spi = class {
        constructor(t) {
            if (Yd.zt(t),
            Jd.has(t))
                throw new Error("label in use");
            this.LGt = t,
            Jd.set(t, {
                startTime: performance.now(),
                frameCount: 0,
                epi: []
            }),
            ef()
        }
        Hdi() {
            let t = Jd.get(this.LGt);
            Jd.delete(this.LGt);
            let i = performance.now() - t.startTime
              , e = -1
              , s = -1;
            for (let i of t.epi)
                i > e && (e = i);
            if (t.epi.length >= 3) {
                t.epi.pop(),
                t.epi.shift();
                for (let i of t.epi)
                    i > s && (s = i)
            }
            console.log(`[JankMeasurement] '${this.LGt}' ended. Duration: ${Math.round(10 * i) / 10} ms, frame count: ${t.frameCount}, max dt: ${Math.round(10 * e) / 10}ms, max dt exclusive: ${Math.round(10 * s) / 10}ms`)
        }
    }
}
{
    const sf = self.t
      , nf = 1
      , rf = 2
      , hf = 4
      , of = 8
      , af = 16
      , lf = 32;
    let uf = null
      , cf = new Map;
    function df() {
        return uf
    }
    function ff(t, i, e, s) {
        let n = new sf.MimeType(t,i,e,s);
        cf.set(t, n)
    }
    sf.MimeType = class {
        constructor(t, i, e, s) {
            if (sf.zt(t),
            sf.gL(e),
            sf.iM(s),
            !t)
                throw new Error("invalid MIME type");
            if (this.npi = t,
            this.rpi = t.split("/")[0],
            this.hpi = [],
            this.opi = e || t,
            this.api = !1,
            this.lpi = !1,
            this.upi = !1,
            this.cpi = !1,
            this.fpi = !1,
            this.ppi = !1,
            "string" == typeof i)
                this.hpi.push(i);
            else {
                if (!Array.isArray(i))
                    throw new TypeError("expected string or array");
                this.hpi = i
            }
            "number" == typeof s && (this.api = !!(s & nf),
            this.lpi = !!(s & rf),
            this.upi = !!(s & hf),
            this.cpi = !!(s & of),
            this.fpi = !!(s & af),
            this.ppi = !!(s & lf))
        }
        eEt() {
            return this.npi
        }
        mpi() {
            return this.rpi
        }
        wpi() {
            return this.hpi
        }
        gpi() {
            return this.opi
        }
        gst() {
            return this.api
        }
        fst() {
            return this.lpi || "text" === this.mpi()
        }
        _hi() {
            return this.cpi
        }
        DAt() {
            return this.upi
        }
        xst() {
            return "text/html" === this.npi
        }
        _st() {
            return "text/css" === this.npi
        }
        Tst() {
            return "image/svg+xml" === this.npi
        }
        Sst() {
            return "text/csv" === this.npi || "text/tab-separated-values" === this.npi
        }
        Ost() {
            return "text/xml" === this.npi
        }
        Ast() {
            return "application/json" === this.npi
        }
        Gst() {
            return "application/pdf" === this.npi
        }
        vst() {
            return "application/javascript" === this.npi || "text/javascript" === this.npi
        }
        Pst() {
            return "application/typescript" === this.npi || "text/typescript" === this.npi
        }
        vhi() {
            return this.fpi
        }
        ypi() {
            this.ppi
        }
        static qs(t) {
            return sf.zt(t),
            cf.get(t) || df()
        }
        static Chi(t) {
            sf.U(t, Blob);
            const i = t.name ? sf.l7(t.name).slice(1) : ""
              , e = t.type;
            if (!i)
                return e ? sf.MimeType.qs(e) : df();
            if (!e)
                return sf.MimeType.Hst(i);
            for (let t of cf.values())
                if (t.eEt() === e)
                    for (let e of t.wpi())
                        if (e === i)
                            return t;
            return sf.MimeType.Hst(i)
        }
        static p7(t) {
            return sf.MimeType.Hst(t).eEt()
        }
        static Hst(t, i) {
            sf.zt(t),
            sf.gL(i),
            t.length && "." === t[0] && (t = t.substr(1)),
            t = t.toLowerCase();
            const e = [];
            for (const i of cf.values())
                for (const s of i.wpi())
                    s === t && e.push(i);
            if (!e.length)
                return df();
            if (1 === e.length || !i)
                return e[0];
            for (const t of e)
                if (t.eEt().toLowerCase().includes(i.toLowerCase()))
                    return t;
            return e[0]
        }
        static yhi(t, i) {
            return sf.M4(t),
            sf.gL(i),
            t.type && sf.K9(t.type) ? t.type.split(";")[0].trim() : sf.MimeType.Hst(sf.l7(t.name), i).eEt()
        }
    }
    ,
    uf = new sf.MimeType("application/octet-stream",[],"Binary"),
    ff("text/html", ["html", "htm"], "HTML", af),
    ff("application/javascript", "js", "JavaScript", rf),
    ff("text/javascript", "js", "JavaScript", rf),
    ff("application/typescript", "ts", "TypeScript", rf),
    ff("text/typescript", "ts", "TypeScript", rf),
    ff("text/css", "css", "CSS", af),
    ff("application/json", ["json", "scon"], "JSON", rf | af),
    ff("text/xml", ["xml", "scml"], "XML", af),
    ff("text/csv", "csv", "CSV", af),
    ff("text/tab-separated-values", "tsv", "Tab-separated values", af),
    ff("text/plain", "txt", "Text", af),
    ff("text/markdown", "md", "Markdown", af),
    ff("text/x-ini", "ini", "INI configuration file", af),
    ff("image/png", "png", "PNG", nf | of),
    ff("image/apng", "apng", "APNG", nf | of),
    ff("image/jpeg", ["jpg", "jpeg"], "JPEG", nf),
    ff("image/jxl", "jxl", "JPEG XL", nf),
    ff("image/svg+xml", "svg", "SVG", rf | af),
    ff("image/webp", "webp", "WebP", nf | of),
    ff("image/gif", "gif", "GIF", nf | of),
    ff("image/tiff", ["tif", "tiff"], "TIFF"),
    ff("image/bmp", "bmp", "Bitmap"),
    ff("image/x-icon", "ico", "Icon"),
    ff("image/avif", ["avif", "avifs"], "AVIF", nf | of),
    ff("audio/ogg; codecs=opus", "opus", "Ogg Opus", nf),
    ff("audio/ogg; codecs=vorbis", "ogg", "Ogg Vorbis", nf),
    ff("audio/webm; codecs=opus", "webm", "WebM Opus", nf),
    ff("audio/mp4", "m4a", "MPEG-4 AAC", nf),
    ff("audio/wav", "wav", "WAV"),
    ff("audio/flac", "flac", "FLAC", nf),
    ff("audio/mpeg", "mp3", "MP3", nf),
    ff("audio/midi", ["mid", "midi", "kar"], "MIDI"),
    ff("video/webm", "webm", "WebM", nf),
    ff("video/ogg", "ogv", "Ogg video", nf),
    ff("video/mp4", "mp4", "MPEG-4 video", nf),
    ff("video/mpeg", ["mpg", "mpeg"], "MPEG video", nf),
    ff("video/quicktime", ["mov", "qt"], "Quicktime movie", nf),
    ff("video/avi", "avi", "AVI"),
    ff("application/font-woff", "woff", "Web font", hf | nf),
    ff("font/woff2", "woff2", "Web font", hf | nf),
    ff("application/font-sfnt", ["ttf", "otf"], "TrueType/OpenType font", hf),
    ff("application/vnd.ms-fontobject", "eot", "Embedded OpenType", hf),
    ff("application/pdf", "pdf", "PDF", af),
    ff("application/zip", ["zip", "c3p", "nw", "capx"], "ZIP", nf | af),
    ff("application/wasm", "wasm", "WebAssembly", af),
    ff("application/wast", "wast", "WebAssembly Text format", rf | af),
    ff("application/octet-stream", "mem", "asm.js memory", af),
    ff("application/x-construct3-addon", "c3addon", "Construct addon", nf | lf),
    ff("application/x-construct2-addon", "c2addon", "Construct 2 addon", nf | lf)
}
{
    const pf = self.t;
    pf.o4 = class {
        constructor(t=pf.hardwareConcurrency) {
            pf.Ge(t),
            this.bpi = t,
            this.vpi = [],
            this.Spi = 0
        }
        WL(t, i) {
            return pf.nu(t),
            new Promise( (e, s) => {
                const n = {
                    _fi: t,
                    resolve: e,
                    reject: s,
                    xpi: i
                };
                i?.signal && i.signal.aborted ? s(new Error("abort")) : (i?.signal && (n.onabort = () => {
                    const t = this.vpi.indexOf(n);
                    -1 !== t && (this.vpi.splice(t, 1),
                    s(new Error("abort")))
                }
                ,
                i.signal.addEventListener("abort", n.onabort)),
                this.vpi.push(n),
                this.Mpi())
            }
            )
        }
        Epi(t) {
            pf.nu(t);
            for (let i = 0, e = this.vpi.length; i < e; ++i)
                if (this.vpi[i]._fi === t)
                    return i;
            return -1
        }
        Cpi(t, i) {
            pf.nu(t);
            const e = this.Epi(t);
            if (-1 === e)
                throw new Error("cannot find promise to resolve");
            this.vpi[e].resolve(i),
            this.vpi.splice(e, 1)
        }
        _pi(t, i) {
            pf.nu(t);
            const e = this.Epi(t);
            if (-1 === e)
                throw new Error("cannot find promise to reject");
            this.vpi[e].reject(i),
            this.vpi.splice(e, 1)
        }
        async Mpi() {
            if (!this.vpi.length)
                return;
            if (this.Spi >= this.bpi)
                return;
            this.Spi++;
            const t = this.vpi.shift();
            t.xpi?.signal && t.onabort && t.xpi.signal.removeEventListener("abort", t.onabort);
            try {
                const i = await t._fi();
                t.resolve(i)
            } catch (i) {
                t.reject(i)
            }
            this.Spi--,
            this.Mpi()
        }
    }
}
{
    const mf = self.t;
    mf.ZG = class {
        constructor(t, i, e) {
            mf.nu(t),
            mf.Ge(i),
            mf.iM(e),
            this.tpi = t,
            this.Tpi = i,
            this.Ipi = e || 2 * i,
            this.Ppi = -1,
            this.Gpi = -1 / 0,
            this.Api = () => this.Rpi(),
            this.kpi = !1,
            this.Opi = !1,
            this.Dpi = null
        }
        JG(t) {
            this.Opi = !!t
        }
        Fpi() {
            return void 0 !== mf.Dfi && mf.Dfi.Ffi() ? this.Ipi : this.Tpi
        }
        FE(...t) {
            if (-1 !== this.Ppi)
                return;
            this.Dpi = t;
            let i = mf.Jfi()
              , e = i - this.Gpi
              , s = this.Fpi();
            e >= s && this.Opi ? (this.Gpi = i,
            this.Lpi()) : this.Ppi = self.setTimeout(this.Api, Math.max(s - e, 4))
        }
        Lpi() {
            this.kpi = !0;
            const t = this.Dpi;
            this.Dpi = null,
            t ? this.tpi(...t) : this.tpi(),
            this.kpi = !1
        }
        qd() {
            this.kpi || (this.Bpi(),
            this.Dpi = null,
            this.Gpi = mf.Jfi())
        }
        Rpi() {
            this.Ppi = -1,
            this.Gpi = mf.Jfi(),
            this.Lpi()
        }
        Bpi() {
            -1 !== this.Ppi && (self.clearTimeout(this.Ppi),
            this.Ppi = -1)
        }
        he() {
            this.Bpi(),
            this.tpi = null,
            this.Dpi = null,
            this.Api = null
        }
    }
}
{
    const wf = self.t;
    wf.tI = {},
    wf.tI.Document = class {
        constructor() {
            this.Upi = null,
            this.Ott = null
        }
        static hmt(t) {
            return wf.zt(t),
            (new wf.tI.Document).Npi(t)
        }
        static vct(t) {
            return new Promise( (i, e) => {
                let s = new FileReader;
                s.onload = t => wf.tI.Document.hmt(t.target.result).then(i),
                s.readAsText(t)
            }
            )
        }
        Npi(t, i) {
            return wf.zt(t),
            wf.gL(i),
            wf.lre( () => {
                const e = new DOMParser;
                return this.Upi = e.parseFromString(t, i || "text/xml"),
                this.Ott = new wf.tI.Element(this.Upi.documentElement,this.Upi),
                this
            }
            )
        }
        FO() {
            return this.Upi
        }
        aI() {
            return this.Ott
        }
        rmt() {
            return new Blob([this.jpi(!0)],{
                type: "text/xml"
            })
        }
        $pi() {
            return (new XMLSerializer).serializeToString(this.Upi)
        }
        jpi(t) {
            t = !!t;
            let i = ""
              , e = 0
              , s = this.$pi().replace(/(>)(<)(\/*)/g, "$1\r\n$2$3");
            for (let t of s.split("\r\n")) {
                let s = 0;
                t.match(/.+<\/\w[^>]*>$/) ? s = 0 : t.match(/^<\/\w/) ? 0 !== e && (e -= 1) : s = t.match(/^<\w[^>]*[^\/]>.*$/) ? 1 : 0;
                let n = "";
                for (let t = 0; t < e; t++)
                    n += "\t";
                i += n + t + "\r\n",
                e += s
            }
            if (t) {
                let t = '<?xml version="1.0" encoding="utf-8" ?>\n';
                t += i
            }
            return i
        }
        zpi(t, i, e) {
            if (wf.ibt(t),
            wf.ibt(i),
            e || (e = this.Upi),
            this.Vpi(e, i))
                e.replaceChild(t, i),
                this.Ott.Wpi(),
                this.Ott.Hpi();
            else
                for (const s of e.children)
                    this.zpi(t, i, s)
        }
        Vpi(t, i) {
            wf.ibt(i);
            for (const e of t.children)
                if (e === i)
                    return !0;
            return !1
        }
    }
    ,
    wf.tI.Element = class {
        constructor(t, i) {
            this.ght = t,
            this.Kpi = null,
            this.Upi = i
        }
        qpi() {
            return this.ght
        }
        Wpi() {
            this.Kpi = null
        }
        Hpi() {
            if (!this.Kpi) {
                this.Kpi = new Map;
                for (let t = 0, i = this.ght.children.length; t < i; ++t)
                    this.Xpi(this.ght.children[t])
            }
        }
        Xpi(t) {
            self.assert(this.Kpi, "missing child cache");
            let i = t.tagName.toLowerCase()
              , e = this.Kpi.get(i);
            e ? -1 === e.indexOf(t) && e.push(t) : this.Kpi.set(i, [t])
        }
        Ypi() {
            return this.ght.tagName
        }
        *children(t) {
            if (wf.gL(t),
            t) {
                this.Hpi();
                let i = this.Kpi.get(t.toLowerCase());
                if (!i)
                    return;
                for (let t = 0, e = i.length; t < e; ++t)
                    yield new wf.tI.Element(i[t],this.Upi)
            } else
                for (let t of this.ght.children)
                    yield new wf.tI.Element(t,this.Upi)
        }
        ha(t) {
            wf.zt(t),
            this.ght.textContent = t
        }
        iSt(t) {
            return wf.gL(t),
            t ? this.lI(t).iSt() : this.ght.textContent
        }
        Jpi(t, i) {
            wf.zt(t),
            wf.gL(i);
            let e = this.Zpi(t);
            return e ? e.iSt() : i || ""
        }
        Qpi(t) {
            return wf.gL(t),
            t ? this.lI(t).Qpi() : parseInt(this.iSt(), 10)
        }
        tmi(t, i) {
            wf.zt(t),
            wf.iM(i);
            let e = this.Zpi(t);
            return e ? e.Qpi() : Math.floor(i || 0)
        }
        imi(t) {
            return wf.gL(t),
            t ? this.lI(t).imi() : parseFloat(this.iSt())
        }
        emi(t, i) {
            wf.zt(t),
            wf.Lj(i);
            let e = this.Zpi(t);
            return e ? e.imi() : i || 0
        }
        smi(t) {
            if (wf.gL(t),
            t)
                return this.lI(t).smi();
            {
                let t = this.iSt().toLowerCase();
                return !("false" === t || "no" === t || "0" === t)
            }
        }
        nmi(t, i) {
            wf.zt(t);
            let e = this.Zpi(t);
            return e ? e.smi() : !!i
        }
        rmi(t) {
            return wf.zt(t),
            this.ght.hasAttribute(t)
        }
        emt(t, i) {
            return wf.zt(t),
            wf.zt(i),
            this.ght.setAttribute(t, i)
        }
        Tct(t) {
            return wf.zt(t),
            this.ght.getAttribute(t) || ""
        }
        rI(t) {
            return wf.zt(t),
            parseInt(this.Tct(t), 10)
        }
        hmi(t) {
            return wf.zt(t),
            parseFloat(this.Tct(t))
        }
        omi(t) {
            wf.zt(t);
            let i = this.Tct(t).toLowerCase();
            return !("false" === i || "no" === i || "0" === i || "" === i)
        }
        WH(t) {
            wf.zt(t);
            let i = this.Upi.createElement(t);
            return this.ght.appendChild(i),
            this.Kpi ? this.Xpi(i) : this.Hpi(),
            this.lI(t)
        }
        lI(t) {
            wf.zt(t),
            this.Hpi();
            let i = this.Kpi.get(t.toLowerCase());
            if (!i || !i.length)
                throw new Error(`expected a child with tag name '${t}'`);
            if (i.length > 1)
                throw new Error(`expected only one child with tag name '${t}'`);
            return new wf.tI.Element(i[0],this.Upi)
        }
        Zpi(t) {
            wf.zt(t),
            this.Hpi();
            let i = this.Kpi.get(t.toLowerCase());
            return i && 1 === i.length ? new wf.tI.Element(i[0],this.Upi) : null
        }
        Vpi(t) {
            wf.zt(t),
            this.Hpi();
            let i = this.Kpi.get(t.toLowerCase());
            return i && 1 === i.length
        }
    }
}
{
    const gf = self.t;
    let yf = class {
        constructor(t, i, e, s) {
            if (gf.zt(t),
            gf.Ge(i),
            !gf.ub(e) && !gf.MAt(e, ArrayBuffer))
                throw new Error("unsupported data");
            this.ami = t,
            this.lmi = i,
            this.Jxt = e,
            this.umi = !!s
        }
        cmi() {
            return this.ami
        }
        dmi() {
            return this.lmi
        }
        pwt() {
            return this.Jxt
        }
        fmi() {
            return this.umi
        }
    }
    ;
    gf.DataView = class {
        constructor(t) {
            gf.Ef(t, ArrayBuffer),
            this.pmi = null,
            this.mmi = [],
            t && (this.pmi = new DataView(t)),
            this.wmi = 0,
            this.gmi = 0
        }
        rmt() {
            return new Blob([this.ymi()])
        }
        bmi() {
            if (!this.pmi)
                throw new Error("missing DataView");
            return this.pmi
        }
        ymi() {
            if (!this.pmi)
                throw new Error("missing DataView");
            return this.pmi.buffer
        }
        vmi() {
            this.gmi = 0
        }
        he() {
            this.pmi = null,
            this.mmi = null
        }
        Smi() {
            if (this.pmi)
                throw new Error("data already commited");
            let t = 0;
            for (let i of this.mmi)
                t += i.dmi();
            this.pmi = new DataView(new ArrayBuffer(t));
            for (let t of this.mmi) {
                switch (t.cmi()) {
                case "setInt8":
                    this.pmi.setInt8(this.wmi, t.pwt());
                    break;
                case "setUint8":
                    this.pmi.setUint8(this.wmi, t.pwt());
                    break;
                case "setInt16":
                    this.pmi.setInt16(this.wmi, t.pwt(), t.fmi());
                    break;
                case "setUint16":
                    this.pmi.setUint16(this.wmi, t.pwt(), t.fmi());
                    break;
                case "setInt32":
                    this.pmi.setInt32(this.wmi, t.pwt(), t.fmi());
                    break;
                case "setUint32":
                    this.pmi.setUint32(this.wmi, t.pwt(), t.fmi());
                    break;
                case "setFloat32":
                    this.pmi.setFloat32(this.wmi, t.pwt(), t.fmi());
                    break;
                case "setFloat64":
                    this.pmi.setFloat64(this.wmi, t.pwt(), t.fmi());
                    break;
                case "setArrayBuffer":
                    let i = new Uint8Array(this.pmi.buffer)
                      , e = new Uint8Array(t.pwt());
                    i.set(e, this.wmi),
                    this.pmi = new DataView(i.buffer)
                }
                this.wmi += t.dmi()
            }
            this.mmi = null
        }
        Gct(t) {
            let i = this.xmi("raw");
            return t || (t = {}),
            t.type || (t.type = "application/octet-stream"),
            new Blob([i],t)
        }
        Mmi(t) {
            gf.U(t, ArrayBuffer),
            this.Emi(t.byteLength),
            this.mmi.push(new yf("setArrayBuffer",t.byteLength,t))
        }
        xmi(t) {
            switch (gf.zt(t),
            t) {
            case "int8":
                return this.Cmi();
            case "uint8":
                return this._mi();
            case "clampedUint8":
                return this.Tmi();
            case "int16":
                return this.Imi();
            case "uint16":
                return this.Pmi();
            case "int32":
                return this.Gmi();
            case "uint32":
                return this.Ami();
            case "float32":
                return this.Rmi();
            case "float64":
                return this.kmi();
            case "raw":
                return this._mi().buffer;
            default:
                throw new Error("unsupported return type. supported types are 'int8, uint8, clampedUint8, int16, uint16, int32, uint32, float32, float64, raw'")
            }
        }
        Omi(t, i) {
            this.Dmi(JSON.stringify(t))
        }
        Fmi(t) {
            return JSON.parse(this.Lmi(t))
        }
        Dmi(t, i) {
            gf.zt(t);
            let e = Array.prototype.map.call(t, (i, e) => t.charCodeAt(e));
            this.Bmi(e, i)
        }
        Lmi(t) {
            return Array.prototype.map.call(this.Pmi(t), t => String.fromCharCode(t)).join("")
        }
        Umi(t) {
            this.Nmi(t ? 1 : 0)
        }
        jmi() {
            return !!this.$mi()
        }
        zmi(t) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setInt8",Int8Array.BYTES_PER_ELEMENT,t))
        }
        Nmi(t) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setUint8",Uint8Array.BYTES_PER_ELEMENT,t))
        }
        Vmi(t, i) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setInt16",Int16Array.BYTES_PER_ELEMENT,t,!!i))
        }
        Wmi(t, i) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setUint16",Uint16Array.BYTES_PER_ELEMENT,t,!!i))
        }
        Hmi(t, i) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setInt32",Int32Array.BYTES_PER_ELEMENT,t,!!i))
        }
        Emi(t, i) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setUint32",Uint32Array.BYTES_PER_ELEMENT,t,!!i))
        }
        Kmi(t, i) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setFloat32",Float32Array.BYTES_PER_ELEMENT,t,!!i))
        }
        qmi(t, i) {
            if (this.pmi)
                throw new Error("data already commited");
            this.mmi.push(new yf("setFloat64",Float64Array.BYTES_PER_ELEMENT,t,!!i))
        }
        Xmi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setInt8")
        }
        Jmi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setUint8")
        }
        Zmi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setInt16", !!i)
        }
        Bmi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setUint16", !!i)
        }
        Qmi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setInt32", !!i)
        }
        twi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setUint32", !!i)
        }
        iwi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setFloat32", !!i)
        }
        ewi(t, i) {
            this.Emi(t.length, !!i),
            this.Ymi(t, "setFloat64", !!i)
        }
        swi() {
            let t = this.pmi.getInt8(this.gmi);
            return this.gmi += Int8Array.BYTES_PER_ELEMENT,
            t
        }
        $mi() {
            let t = this.pmi.getUint8(this.gmi);
            return this.gmi += Uint8Array.BYTES_PER_ELEMENT,
            t
        }
        nwi(t) {
            let i = this.pmi.getInt16(this.gmi, !!t);
            return this.gmi += Int16Array.BYTES_PER_ELEMENT,
            i
        }
        rwi(t) {
            let i = this.pmi.getUint16(this.gmi, !!t);
            return this.gmi += Uint16Array.BYTES_PER_ELEMENT,
            i
        }
        hwi(t) {
            let i = this.pmi.getInt32(this.gmi, !!t);
            return this.gmi += Int32Array.BYTES_PER_ELEMENT,
            i
        }
        owi(t) {
            let i = this.pmi.getUint32(this.gmi, !!t);
            return this.gmi += Uint32Array.BYTES_PER_ELEMENT,
            i
        }
        awi(t) {
            let i = this.pmi.getFloat32(this.gmi, !!t);
            return this.gmi += Float32Array.BYTES_PER_ELEMENT,
            i
        }
        lwi(t) {
            let i = this.pmi.getFloat64(this.gmi, !!t);
            return this.gmi += Float64Array.BYTES_PER_ELEMENT,
            i
        }
        Cmi(t) {
            return this.uwi(this.owi(!!t), "getInt8", Int8Array)
        }
        _mi(t) {
            return this.uwi(this.owi(!!t), "getUint8", Uint8Array)
        }
        Tmi(t) {
            return this.uwi(this.owi(!!t), "getUint8", Uint8ClampedArray)
        }
        Imi(t) {
            return this.uwi(this.owi(!!t), "getInt16", Int16Array, !!t)
        }
        Pmi(t) {
            return this.uwi(this.owi(!!t), "getUint16", Uint16Array, !!t)
        }
        Gmi(t) {
            return this.uwi(this.owi(!!t), "getInt32", Int32Array, !!t)
        }
        Ami(t) {
            return this.uwi(this.owi(!!t), "getUint32", Uint32Array, !!t)
        }
        Rmi(t) {
            return this.uwi(this.owi(!!t), "getFloat32", Float32Array, !!t)
        }
        kmi(t) {
            return this.uwi(this.owi(!!t), "getFloat64", Float64Array, !!t)
        }
        Ymi(t, i, e) {
            let s = t.length;
            for (let n = 0; n < s; n++)
                "setInt8" !== i ? "setUint8" !== i ? "setInt16" !== i ? "setUint16" !== i ? "setInt32" !== i ? "setUint32" !== i ? "setFloat32" !== i ? "setFloat64" !== i || this.mmi.push(new yf(i,Float64Array.BYTES_PER_ELEMENT,t[n],e)) : this.mmi.push(new yf(i,Float32Array.BYTES_PER_ELEMENT,t[n],e)) : this.mmi.push(new yf(i,Uint32Array.BYTES_PER_ELEMENT,t[n],e)) : this.mmi.push(new yf(i,Int32Array.BYTES_PER_ELEMENT,t[n],e)) : this.mmi.push(new yf(i,Uint16Array.BYTES_PER_ELEMENT,t[n],e)) : this.mmi.push(new yf(i,Int16Array.BYTES_PER_ELEMENT,t[n],e)) : this.mmi.push(new yf(i,Uint8Array.BYTES_PER_ELEMENT,t[n],e)) : this.mmi.push(new yf(i,Int8Array.BYTES_PER_ELEMENT,t[n],e))
        }
        uwi(t, i, e, s) {
            let n = new e(t)
              , r = e.BYTES_PER_ELEMENT;
            for (let e = 0; e < t; e++)
                "getInt8" !== i ? "getUint8" !== i ? "getInt16" !== i ? "getUint16" !== i ? "getInt32" !== i ? "getUint32" !== i ? "getFloat32" !== i ? "getFloat64" !== i || (n[e] = this.pmi.getFloat64(this.gmi + e * r, s)) : n[e] = this.pmi.getFloat32(this.gmi + e * r, s) : n[e] = this.pmi.getUint32(this.gmi + e * r, s) : n[e] = this.pmi.getInt32(this.gmi + e * r, s) : n[e] = this.pmi.getUint16(this.gmi + e * r, s) : n[e] = this.pmi.getInt16(this.gmi + e * r, s) : n[e] = this.pmi.getUint8(this.gmi + e * r, s) : n[e] = this.pmi.getInt8(this.gmi + e * r, s);
            return this.gmi += t * r,
            n
        }
    }
}
{
    const bf = self.t
      , vf = 60;
    bf.cwi = function(t, i, e) {
        if (bf.ibt(t, "input"),
        bf.tot(i),
        "number" !== t.type && "text" !== t.type)
            throw new TypeError(`unable to bind drag scroller to input, unsupported type ${t.type}`);
        let s = null
          , n = null
          , r = null
          , h = 0
          , o = !1
          , a = bf.v(bf.Rf)
          , l = null
          , u = null
          , c = null
          , d = null;
        const f = i => {
            if (!o)
                return;
            const s = parseFloat(t.value);
            if (!bf.ub(s))
                return;
            if (s !== r)
                return p();
            const a = Math.round(h - i.clientY)
              , l = t.min ? parseFloat(t.min) : -1 / 0
              , u = t.max ? parseFloat(t.max) : 1 / 0
              , c = t.step ? parseFloat(t.step) : 1;
            i.preventDefault();
            let f = a * c;
            f = e ? n - f : n + f,
            r = bf.Ne(f, l, u),
            t.value = r,
            t.select(),
            d.FE()
        }
          , p = () => {
            o = !1,
            n = null,
            h = 0,
            bf.Qs.sk.hk(s),
            s = null,
            l && (l.Ff(),
            a.Lw(l)),
            l = null,
            u && (u.Ff(),
            a.Lw(u)),
            u = null,
            c && (c.Ff(),
            a.Lw(c)),
            c = null
        }
          , m = e => {
            e.target !== t && e.preventDefault(),
            e.stopPropagation(),
            p();
            let s = new Event("change");
            t.dispatchEvent(s),
            i && i()
        }
          , w = t => {
            p()
        }
        ;
        return d = bf.v(bf.ZG, () => {
            let i = new Event("input");
            t.dispatchEvent(i)
        }
        , vf),
        a.WL(bf._f.Gf(t, "dragstart", i => {
            o || bf.ub(parseFloat(t.value)) && (i.preventDefault(),
            o = !0,
            h = i.clientY,
            n = parseFloat(t.value),
            r = n,
            s = bf.Qs.sk.ik("ns-resize", t.ownerDocument, i.clientX, i.clientY),
            l = bf._f.Gf(t.ownerDocument, "pointermove", f),
            u = bf._f.Gf(t.ownerDocument, "pointerup", m),
            c = bf._f.Gf(t.ownerDocument, "pointercancel", w),
            a.WL(l),
            a.WL(u),
            a.WL(c))
        }
        )),
        a.WL(bf._f.Gf(t, "focus", () => t.select())),
        a.WL(bf.v(bf._f, () => {
            t = null,
            i = null,
            l = null,
            u = null,
            c = null,
            a = null,
            bf.Qs.sk.hk(s),
            s = null,
            d.he()
        }
        )),
        a
    }
}
{
    const Sf = self.t
      , xf = {
        enabled: !0,
        dwi: !1
    };
    Sf.fwi = class {
        constructor(t, i, e) {
            Sf.nu(t),
            Sf.Ge(i),
            Sf.kQ(e),
            e = Object.assign({}, xf, e),
            this.Ppi = -1,
            this.pwi = "stopped",
            this.mwi = i,
            this.wwi = t,
            this.gwi = () => this.Lpi(),
            this.ywi = !1,
            this.bwi = 0,
            this.vwi = 0,
            this.Swi = () => this.xwi(),
            this.Mwi = !!e.dwi,
            e.enabled && this.ke()
        }
        he() {
            this.Ewi(),
            this.wwi = null,
            this.gwi = null,
            this.Swi = null
        }
        Cwi() {
            return "stopped" !== this.pwi
        }
        _wi() {
            return "paused" === this.pwi
        }
        Twi(t) {
            this.Ppi = self.setTimeout(this.gwi, t),
            this.bwi = Date.now()
        }
        Iwi() {
            -1 !== this.Ppi && (self.clearTimeout(this.Ppi),
            this.Ppi = -1)
        }
        ke() {
            if (!this.Cwi()) {
                if (this.Mwi && (document.addEventListener("visibilitychange", this.Swi),
                "hidden" === document.visibilityState))
                    return this.pwi = "paused",
                    void (this.vwi = 0);
                this.pwi = "running",
                this.ywi || (this.vwi = 0,
                this.Twi(this.mwi))
            }
        }
        Ewi() {
            this.Cwi() && (this.Mwi && document.removeEventListener("visibilitychange", this.Swi),
            this.Iwi(),
            this.pwi = "stopped")
        }
        Pwi() {
            this.Cwi() && !this._wi() && (this.pwi = "paused",
            this.ywi ? this.vwi = 0 : (this.vwi += Date.now() - this.bwi,
            this.Iwi()))
        }
        Gwi() {
            this.Cwi() && this._wi() && (this.pwi = "running",
            this.ywi || this.Twi(Sf.Ne(this.mwi - this.vwi, 1, this.mwi)))
        }
        async Lpi() {
            this.Ppi = -1,
            this.vwi = 0,
            this.ywi = !0,
            await this.wwi(),
            this.ywi = !1,
            "running" === this.pwi && this.Twi(this.mwi)
        }
        Awi(t) {
            Sf.Ge(t),
            this.mwi !== t && (this.mwi = t,
            "running" !== this.pwi || this.ywi || (this.Ewi(),
            this.ke()))
        }
        xwi() {
            "hidden" === document.visibilityState ? this.Pwi() : this.Gwi()
        }
    }
}
{
    const Mf = self.t;
    Mf.sVt = function(t, i, e, s=null) {
        Mf.ibt(t),
        Mf.ibt(i),
        Mf.nu(e);
        let n = null
          , r = null
          , h = null
          , o = null
          , a = null
          , l = null
          , u = e => function() {
            const e = i.getBoundingClientRect()
              , s = t.getBoundingClientRect();
            n.style.left = `${s.left - e.left + i.scrollLeft}px`,
            n.style.top = `${s.top - e.top + i.scrollTop}px`;
            const r = n.getBoundingClientRect();
            (r.bottom > e.bottom + 1 || r.top < e.top - 1) && p()
        }();
        function c() {
            if (n)
                return Promise.resolve("");
            const c = s && s.eVt ? s.eVt : "tree-edit-text";
            if (n = Mf.Qs.W_("input", i, null, c),
            n.type = "text",
            n.setAttribute("spellcheck", "false"),
            s && s.position)
                n.style.left = `${s.position.x ?? 0}px`,
                n.style.top = `${s.position.y ?? 0}px`;
            else {
                const e = i.getBoundingClientRect()
                  , s = t.getBoundingClientRect()
                  , r = s.left - e.left
                  , h = s.top - e.top + i.scrollTop;
                n.type = "text",
                n.style.left = `${r}px`,
                n.style.top = `${h}px`,
                n.style.width = `${Math.max(s.right - s.left, 30)}px`,
                n.style.maxWidth = `${Math.max(s.right - s.left, 30)}px`,
                n.style.height = s.bottom - s.top + "px"
            }
            return o = t => d(),
            n.addEventListener("blur", o),
            a = i => function() {
                if (t.textContent = n.value,
                !s?.position) {
                    const i = t.getBoundingClientRect();
                    n.style.width = `${Math.max(i.right - i.left, 30)}px`
                }
                t.textContent = "."
            }(),
            n.addEventListener("input", a),
            l = t => function(t) {
                t.which === Mf.Mk.aY ? (t.preventDefault(),
                t.stopPropagation(),
                d()) : t.which === Mf.Mk.VJ && (t.preventDefault(),
                t.stopPropagation(),
                p())
            }(t),
            n.addEventListener("keydown", l, !0),
            i.addEventListener("scroll", u),
            n.value = e(),
            n.focus(),
            t.textContent = ".",
            new Promise( (t, i) => {
                r = t,
                h = i
            }
            )
        }
        function d() {
            if (!n)
                return;
            let t = n.value;
            f(t),
            r && r(t),
            r = null,
            h = null
        }
        function f(s=null) {
            n && (t.textContent = s || e(),
            i.removeEventListener("scroll", u, {
                passive: !0
            }),
            n.removeEventListener("keydown", l, !0),
            l = null,
            n.removeEventListener("input", a),
            a = null,
            n.removeEventListener("blur", o),
            o = null,
            Mf.Qs.UO(n),
            n = null)
        }
        function p() {
            n && (f(),
            r && r(null),
            r = null,
            h = null)
        }
        return {
            zFt: () => c(),
            Rwi: () => {
                d()
            }
            ,
            he: () => {
                f(),
                r = null,
                h = null
            }
        }
    }
}
{
    const Ef = self.t;
    self.lang;
    Ef.Y0 = function(t, i, e=null) {
        Ef.ibt(t),
        Ef.RH(i),
        Ef.ML(e);
        let s = Ef.Qs.W_("div", t, null, "progressBarContainer")
          , n = Ef.Qs.W_("progress", s, null, "progressBarElement")
          , r = Ef.Qs.W_("div", s, null, "progressBarLabel");
        return r.textContent = e?.label ?? self.lang("common.loading-with-ellipsis"),
        {
            j0: () => function() {
                for (const t of i)
                    t.style.opacity = "",
                    t.style.pointerEvents = "";
                s.style.display = "none",
                e?.kwi && e?.kwi()
            }(),
            lQ: () => function() {
                for (const t of i)
                    t.style.opacity = "0.2",
                    t.style.pointerEvents = "none";
                s.style.display = "",
                e?.Owi && e?.Owi()
            }(),
            s2: () => {
                t.appendChild(s)
            }
            ,
            he: () => (Ef.Qs.UO(r),
            r = null,
            Ef.Qs.UO(n),
            n = null,
            Ef.Qs.UO(s),
            void (s = null))
        }
    }
}
{
    const Cf = self.t
      , _f = new Map;
    function Tf(t, i) {
        if (!Array.isArray(t))
            throw new TypeError("unexpected type");
        for (const e of t)
            Cf.Rti(e, i)
    }
    Cf.QRt = class {
        static Dwi(t) {
            Cf.Rti(t, Element);
            const i = t.ownerDocument.createRange();
            return i.selectNodeContents(t),
            i
        }
        static hMt(t) {
            Cf.Rti(t, Element);
            const i = this.Fwi(t)
              , e = this.Dwi(t);
            return this.Lwi(e, i),
            e
        }
        static Bwi(t, i, e) {
            Cf.Rti(t, Element),
            Cf.Ge(i),
            Cf.Ge(e);
            const s = t.ownerDocument.createRange();
            let n = 0
              , r = null
              , h = !1;
            -1 == i && (i = 0),
            -1 == e && (e = 0);
            for (const o of this.Uwi(t)) {
                const t = n;
                if (n += o.textContent.length,
                n > i && !1 === h && (s.setStart(o, i - t),
                h = !0),
                n >= e)
                    return i === e && !1 === h && (s.setStart(o, e - t),
                    h = !0),
                    s.setEnd(o, e - t),
                    s;
                r = o
            }
            if (r) {
                const t = r.length;
                s.setStart(r, t),
                s.setEnd(r, t)
            } else
                s.setStart(t, 0),
                s.setEnd(t, 0);
            return s
        }
        static YRt(t, i, e) {
            Cf.Rti(t, Element),
            Cf.Ge(i),
            Cf.Ge(e);
            const s = this.Fwi(t)
              , n = this.Bwi(t, i, e);
            return this.Lwi(n, s),
            n
        }
        static Lwi(t, i) {
            Cf.Rti(i, Window),
            Cf.Rti(t, Range);
            const e = i.getSelection();
            e.removeAllRanges(),
            e.addRange(t)
        }
        static NNt(t) {
            Cf.Rti(t, Window);
            t.getSelection().removeAllRanges()
        }
        static Nwi(t, i) {
            Cf.Rti(i, Window),
            Cf.Rti(t, Range);
            i.getSelection().addRange(t)
        }
        static jwi(t, i) {
            Cf.Rti(i, Window),
            Cf.Rti(t, Range);
            i.getSelection().removeRange(t)
        }
        static $wi(t) {
            Cf.Rti(t, Window);
            return t.getSelection().rangeCount
        }
        static _F(t) {
            Cf.Rti(t, Window);
            const i = t.getSelection()
              , e = i.rangeCount > 0 && i.getRangeAt(0);
            return e && !1 === e.collapsed
        }
        static zwi(t) {
            Cf.Rti(t, Window);
            const i = t.getSelection();
            return 1 === i.rangeCount ? i.getRangeAt(0) : null
        }
        static Vwi(t) {
            Cf.Rti(t, Window);
            const i = this.zwi(t);
            return i ? i.getBoundingClientRect() : null
        }
        static Wwi(t) {
            Cf.Rti(t, Element);
            const i = this.Fwi(t)
              , e = this.zwi(i);
            return e ? this.Hwi(t, e) : null
        }
        static Hwi(t, i) {
            Cf.Rti(t, Element),
            Cf.Rti(i, Range);
            const e = {
                start: -1,
                end: -1
            };
            let s = 0;
            for (const n of this.Kwi(t)) {
                if (n === i.startContainer && (e.start = s + this.qwi(n, i.startOffset)),
                n === i.endContainer) {
                    e.end = s + this.qwi(n, i.endOffset);
                    break
                }
                if (n.nodeType === Node.TEXT_NODE) {
                    s += n.textContent.length
                }
            }
            return e
        }
        static Xwi(t, i) {
            Cf.Rti(t, Element),
            Cf.Rti(i, Range);
            let e = i.commonAncestorContainer;
            do {
                if (t == e)
                    return !0
            } while (e = e.parentNode);
            return !1
        }
        static Ywi(t) {
            Cf.Rti(t, Element);
            const i = this.Fwi(t).getSelection()
              , e = i.rangeCount;
            if (0 === e)
                return null;
            const s = [];
            for (let n = 0; n < e; n++) {
                const e = i.getRangeAt(n);
                this.Xwi(t, e) && s.push(this.Hwi(t, e))
            }
            return {
                wW: t,
                Jwi: s
            }
        }
        static Zwi(t, i) {
            Cf.Rti(t, Element),
            Cf.Rti(i, Object);
            const e = this.Fwi(t);
            if (null === i)
                return;
            const s = e.getSelection()
              , n = i.Jwi;
            s.removeAllRanges();
            for (const i of n) {
                const {start: e, end: n} = i
                  , r = this.Bwi(t, e, n);
                s.addRange(r)
            }
        }
        static*Uwi(t) {
            Cf.Rti(t, Element);
            for (const i of t.childNodes)
                switch (i.nodeType) {
                case Node.TEXT_NODE:
                    yield i;
                    break;
                case Node.ELEMENT_NODE:
                    yield*this.Uwi(i)
                }
        }
        static*Kwi(t) {
            Cf.Rti(t, Element),
            yield t;
            for (const i of t.childNodes)
                switch (i.nodeType) {
                case Node.TEXT_NODE:
                    yield i;
                    break;
                case Node.ELEMENT_NODE:
                    yield*this.Kwi(i)
                }
        }
        static qwi(t, i=1 / 0) {
            if (Cf.Rti(t, Node),
            Cf.Ck(i),
            t.nodeType === Node.TEXT_NODE)
                return Math.min(i, t.textContent.length);
            let e = 0;
            for (const s of this.Uwi(t)) {
                if (i-- < 1)
                    break;
                e += this.qwi(s)
            }
            return e
        }
        static Qwi(t, i) {
            Cf.Rti(t, Element),
            Cf.Ge(i);
            let e = 0
              , s = 0
              , n = null;
            for (const r of this.Uwi(t))
                if (s = e,
                n = r,
                e += r.textContent.length,
                e > i)
                    return [r, i - s];
            return e === i ? [n, i - s] : null
        }
        static tgi(t) {
            Tf(t, Node);
            for (const i of t) {
                const t = i.parentNode
                  , e = t && t.parentNode;
                if (!e)
                    continue;
                const s = i.ownerDocument.createDocumentFragment();
                for (const i of Array.from(t.childNodes))
                    s.appendChild(i);
                e.replaceChild(s, t),
                e.normalize()
            }
        }
        static igi(t, i) {
            Cf.Rti(t, Range),
            Cf.zt(i);
            const e = this.egi(t)
              , s = new Set
              , n = t.commonAncestorContainer;
            if (n.nodeType === Node.TEXT_NODE) {
                let i = n;
                t.startOffset > 0 && (i = i.splitText(t.startOffset)),
                t.endOffset < i.textContent.length && i.splitText(t.endOffset),
                s.add(i)
            } else {
                const {start: i, end: r} = this.Hwi(n, t, e);
                let h = 0
                  , o = 0;
                const a = Array.from(this.Uwi(n));
                for (const t of a) {
                    const e = h + t.textContent.length;
                    if (0 === o && e > i) {
                        if (i > h) {
                            const e = t.splitText(i - h);
                            s.add(e)
                        } else
                            s.add(t);
                        o = 1
                    }
                    if (1 === o && e >= r) {
                        if (e > r) {
                            t.splitText(r - h);
                            s.add(t)
                        } else
                            s.add(t);
                        break
                    }
                    h = e
                }
            }
            for (const t of s) {
                const e = document.createElement("span");
                e.className = i,
                t.parentNode.replaceChild(e, t),
                e.appendChild(t)
            }
            return Array.from(s)
        }
        static sgi(t) {
            Cf.zt(t);
            let i = _f.get(t);
            return i || (i = new If(t),
            _f.set(t, i)),
            i
        }
        static egi(t) {
            Cf.Rti(t, Range);
            const i = t.commonAncestorContainer;
            return (i.nodeType === Node.DOCUMENT_NODE ? i : i.ownerDocument).defaultView
        }
        static Fwi(t) {
            return Cf.Rti(t, Element),
            t.ownerDocument.defaultView
        }
    }
    ;
    class If {
        constructor(t) {
            Cf.zt(t),
            this.ngi = new Map,
            this.rgi = new Map,
            this.className = t
        }
        WL(t) {
            if (Cf.Rti(t, Range),
            this.ngi.has(t))
                return;
            const i = Cf.QRt.igi(t, this.className);
            this.ngi.set(t, i)
        }
        Lw(t) {
            Cf.Rti(t, Range);
            const i = this.ngi.get(t);
            i && (Cf.QRt.tgi(i),
            this.ngi.delete(t))
        }
        Ry() {
            for (const t of this.ngi.keys())
                this.Lw(t)
        }
    }
}
{
    const Pf = self.t
      , Gf = t => {
        const i = t.target;
        if (!Rf.has(i))
            return;
        const e = t.keyCode
          , s = i.min ? self.parseFloat(i.min) : -1 / 0
          , n = i.max ? self.parseFloat(i.max) : 1 / 0
          , r = i.step ? self.parseFloat(i.step) : 1;
        if (Pf.Mk.cdt(Pf.Mk.UZ, e)) {
            let e = self.parseFloat(i.value);
            Pf.ub(e) && (e += r,
            i.value = Pf.Ne(e, s, n),
            i.dispatchEvent(new Event("input")),
            t.preventDefault(),
            kf.get(i).hgi || (kf.get(i).ogi = i.value),
            kf.get(i).hgi = !0)
        } else if (Pf.Mk.cdt(Pf.Mk.FZ, e)) {
            let e = self.parseFloat(i.value);
            Pf.ub(e) && (e -= r,
            i.value = Pf.Ne(e, s, n),
            i.dispatchEvent(new Event("input")),
            t.preventDefault(),
            kf.get(i).hgi || (kf.get(i).ogi = i.value),
            kf.get(i).hgi = !0)
        }
    }
      , Af = t => {
        const i = t.target;
        if (!Rf.has(i))
            return;
        const e = t.keyCode;
        i.min && self.parseFloat(i.min),
        i.max && self.parseFloat(i.max),
        i.step && self.parseFloat(i.step);
        if (Pf.Mk.cdt(Pf.Mk.UZ, e)) {
            const t = self.parseFloat(i.value);
            kf.get(i).hgi && kf.get(i).ogi !== t && i.dispatchEvent(new Event("change")),
            kf.get(i).hgi = !1,
            kf.get(i).ogi = NaN
        } else if (Pf.Mk.cdt(Pf.Mk.FZ, e)) {
            const t = self.parseFloat(i.value);
            kf.get(i).hgi && kf.get(i).ogi !== t && i.dispatchEvent(new Event("change")),
            kf.get(i).hgi = !1,
            kf.get(i).ogi = NaN
        }
    }
      , Rf = new Set
      , kf = new Map
      , Of = new Set;
    Pf.agi = function(t) {
        if (Pf.ibt(t, "input"),
        "text" !== t.type)
            throw new TypeError(`unable to bind keyboard handlers to input, unsupported type ${t.type}`);
        const i = t.ownerDocument;
        return Of.has(i) || (i.addEventListener("keydown", Gf, !0),
        i.addEventListener("keyup", Af, !0),
        Of.add(i)),
        Rf.add(t),
        kf.set(t, {
            hgi: !1,
            ogi: NaN
        }),
        {
            Ff: () => {
                Rf.delete(t),
                kf.delete(t)
            }
            ,
            lgi() {
                const i = t.ownerDocument;
                Of.has(i) || (i.addEventListener("keydown", Gf, !0),
                i.addEventListener("keyup", Af, !0),
                Of.add(i))
            }
        }
    }
}
{
    const Df = self.t
      , Ff = new Set([16, 32, 64, 128, 256, 512])
      , Lf = new Map([[16, [1768124468, 0]], [32, [1768124469, 1768108337]], [64, [1768124470, 1768108338]], [128, [1768108087, 0]], [256, [1768108088, 1768108339]], [512, [1768108089, 1768108340]]]);
    Df.ugi = async function(t) {
        let i = t.filter(t => Ff.has(t.width) && t.width === t.height);
        if (i = await Promise.all(i.map(async t => ({
            arrayBuffer: await Df.zii(t.blob),
            cgi: t.width
        }))),
        0 === i.length)
            return null;
        let e = 8;
        for (const t of i) {
            e += (8 + t.arrayBuffer.byteLength) * (0 !== Lf.get(t.cgi)[1] ? 2 : 1)
        }
        const s = new ArrayBuffer(e)
          , n = new DataView(s)
          , r = new Uint8Array(s);
        n.setUint32(0, 1768124019, !1),
        n.setUint32(4, e, !1);
        let h = 8;
        for (const t of i) {
            const i = Lf.get(t.cgi)
              , e = i[0]
              , s = i[1];
            n.setUint32(h, e, !1),
            h += 4,
            n.setUint32(h, t.arrayBuffer.byteLength + 8, !1),
            h += 4,
            r.set(new Uint8Array(t.arrayBuffer), h),
            h += t.arrayBuffer.byteLength,
            0 !== s && (n.setUint32(h, s, !1),
            h += 4,
            n.setUint32(h, t.arrayBuffer.byteLength + 8, !1),
            h += 4,
            r.set(new Uint8Array(t.arrayBuffer), h),
            h += t.arrayBuffer.byteLength)
        }
        return new Blob([s],{
            type: "application/octet-stream"
        })
    }
}
{
    const Bf = 1e3
      , Uf = 50;
    self.dgi = class {
        constructor() {
            this.fgi = !1,
            this.Ppi = -1,
            this.pgi = [],
            this.mgi = -1
        }
        wgi() {
            if (this.fgi || navigator.userActivation)
                return;
            const t = {
                capture: !0,
                passive: !0
            };
            window.addEventListener("pointerdown", () => this.ggi(), t),
            window.addEventListener("pointerup", () => this.ggi(), t),
            window.addEventListener("keydown", () => this.ggi(), t),
            window.addEventListener("keyup", () => this.ggi(), t),
            this.fgi = !0
        }
        ggi() {
            -1 !== this.Ppi && self.clearTimeout(this.Ppi),
            this.mgi = Date.now(),
            this.ygi()
        }
        ygi() {
            this.Ppi = self.setTimeout( () => this.Rpi(), Uf)
        }
        Rpi() {
            if (this.Ppi = -1,
            this.pgi.length > 0) {
                const t = this.pgi;
                this.pgi = [];
                for (const i of t)
                    i()
            } else
                Date.now() < this.mgi + Bf && this.ygi()
        }
        qs(t) {
            -1 === this.Ppi ? t() : this.pgi.push(t)
        }
        Gii(t) {
            return new Promise(i => {
                this.qs( () => {
                    i(t())
                }
                )
            }
            )
        }
    }
}
{
    const Nf = self.t
      , jf = 1664311650
      , $f = 1717856626
      , zf = 1651273570
      , Vf = Nf.v(Nf.o4, 16);
    async function Wf(t, i, e) {
        let s = null;
        if (i instanceof Blob)
            s = i;
        else {
            if ("string" != typeof i)
                throw new TypeError("unexpected file data");
            s = new Blob([i])
        }
        let n = !1
          , r = s.size;
        if (e.bgi) {
            Nf.MimeType.Hst(Nf.l7(t)).gst() || (n = !0,
            await Vf.WL(async () => {
                const t = new CompressionStream("deflate")
                  , i = s.stream().pipeThrough(t)
                  , e = await new Response(i).blob();
                s = e
            }
            ))
        }
        return {
            blob: s,
            vgi: r,
            Sgi: n
        }
    }
    const Hf = new Map([[".js", 1], [".json", 2], [".html", 3], [".css", 4]]);
    function Kf(t, i) {
        const e = Nf.l7(t).toLowerCase()
          , s = Nf.l7(i).toLowerCase()
          , n = Hf.get(e) ?? 999
          , r = Hf.get(s) ?? 999;
        if (n < r)
            return -1;
        if (n > r)
            return 1;
        const h = Nf.MimeType.Hst(e)
          , o = Nf.MimeType.Hst(s);
        return h.fst() && !o.fst() ? -1 : !h.fst() && o.fst() ? 1 : "image" === h.mpi() && "image" !== o.mpi() ? -1 : "image" !== h.mpi() && "image" === o.mpi() ? 1 : 0
    }
    const qf = {
        bgi: !1
    };
    Nf.xgi = async function(t, i) {
        i = Object.assign({}, qf, i);
        const e = new Map
          , s = [];
        for (const [n,r] of t)
            s.push((async () => {
                const t = await Wf(n, r, i);
                e.set(n, t)
            }
            )());
        await Promise.all(s);
        const n = [...e.entries()];
        n.sort( (t, i) => {
            const e = Kf(t[0], i[0]);
            return 0 !== e ? e : t[1].blob.size - i[1].blob.size
        }
        );
        const r = new ArrayBuffer(16)
          , h = new DataView(r);
        h.setUint32(0, jf),
        h.setUint32(4, 0),
        h.setUint32(8, 16),
        h.setUint32(12, 0);
        let o = 0
          , a = 0;
        const l = []
          , u = []
          , c = new TextEncoder;
        for (const [t,i] of n) {
            Nf.zt(t);
            const {blob: e, vgi: s, Sgi: n} = i
              , r = c.encode(t.normalize())
              , h = new ArrayBuffer(37 + r.length)
              , d = new DataView(h);
            d.setUint32(0, 0),
            d.setUint32(4, 0);
            const f = e.size;
            d.setBigUint64(8, BigInt(o)),
            o += f,
            d.setBigUint64(16, BigInt(f)),
            d.setBigUint64(24, BigInt(s)),
            d.setUint8(32, n ? 1 : 0),
            d.setUint32(33, r.length),
            new Uint8Array(h).set(r, 37),
            l.push(h),
            a += h.byteLength,
            u.push(e)
        }
        const d = new ArrayBuffer(16)
          , f = new DataView(d);
        f.setUint32(0, $f),
        f.setBigUint64(4, BigInt(a + 4)),
        f.setUint32(12, l.length);
        const p = new ArrayBuffer(12)
          , m = new DataView(p);
        return m.setUint32(0, zf),
        m.setBigUint64(4, BigInt(o)),
        new Blob([r, d, ...l, p, ...u])
    }
}
{
    const Xf = self.t;
    Xf.Mgi = class {
        constructor(t, i, e, s) {
            Xf.Ge(i),
            Xf.nu(s),
            Xf.gL(e),
            this.Egi = t,
            this.Cgi = i,
            this._gi = e || null,
            this.tpi = s,
            this.Tgi = !1
        }
        Ry() {
            this.Egi = null,
            this.tpi = null
        }
        he() {
            this.Egi && !this.Tgi && this.Egi.Igi(this)
        }
        Pgi() {
            return this.Cgi
        }
        MBt() {
            return this._gi
        }
        Ggi() {
            this.tpi && (this.Tgi = !0,
            this.tpi(),
            this.Tgi = !1)
        }
    }
}
{
    const Yf = self.t;
    class Jf {
        constructor() {
            this.DF = !1,
            this.Agi = [],
            this.Rgi = 0,
            this.Cgi = 0,
            this.kgi = 0,
            this.Ogi = [],
            this.Dgi = !1
        }
        zlt() {
            if (this.DF)
                throw new Error("already enabled");
            this.DF = !0,
            window.addEventListener("popstate", t => this.Fgi(t));
            for (const t of this.Agi)
                history.pushState({
                    sequence: t.Pgi()
                }, t.MBt(), location.toString())
        }
        Fgi(t) {
            if (this.Rgi > 0)
                return this.Rgi--,
                void (0 === this.Rgi && this.Ogi.length && Yf.pii( () => this.Lgi()));
            if (!this.Agi.length || !this.DF)
                return;
            if (this.Dgi = !0,
            t.state) {
                const i = t.state.sequence;
                this.kgi = i
            }
            const i = this.Agi.pop();
            i.Ggi(),
            i.Ry(),
            this.Dgi = !1
        }
        Lgi() {
            for (const t of this.Ogi)
                t();
            Yf.Io(this.Ogi)
        }
        WL(t, i) {
            Yf.nu(t),
            Yf.gL(i);
            const e = this.Cgi++;
            if (this.kgi = e,
            this.DF) {
                const t = () => history.pushState({
                    sequence: e
                }, i || null, location.toString());
                this.Rgi > 0 ? this.Ogi.push(t) : this.Dgi ? Yf.pii(t) : t()
            }
            const s = Yf.v(Yf.Mgi, this, e, i, t);
            return this.Agi.push(s),
            s
        }
        Igi(t) {
            const i = this.Agi.indexOf(t);
            if (self.assert(-1 !== i, "cannot find back stack entry"),
            this.Agi.splice(i, 1),
            t.Ry(),
            this.Agi.length) {
                const t = this.Agi.at(-1);
                this.kgi = t.Pgi()
            }
            this.DF && (this.Rgi++,
            this.Bgi())
        }
        Bgi() {
            this.DF && (this.Rgi > 0 || this.Dgi ? Yf.pii( () => history.back()) : history.back())
        }
    }
    Yf.Ugi = Yf.v(Jf)
}
{
    const Zf = self.t
      , Qf = "undefined" != typeof TextEncoder ? new TextEncoder("utf8") : null
      , tp = 3;
    Zf.WebSocket = class extends Zf.Event.v_ {
        constructor(t) {
            Zf.zt(t),
            super(),
            this.Ngi = new WebSocket(t),
            this.Ngi.binaryType = "arraybuffer",
            this.jgi = t,
            this.$gi = !1,
            this.zgi = new Zf.fwi( () => this.Vgi(),10,{
                enabled: !1
            }),
            this.Wgi = new Zf.Rf(Zf._f.Gf(this.Ngi, "open", t => this.Hgi(t)),Zf._f.Gf(this.Ngi, "close", t => this.Kgi(t)),Zf._f.Gf(this.Ngi, "message", t => this.qgi(t)),Zf._f.Gf(this.Ngi, "error", t => this.Xgi(t)),Zf._f.he(this.zgi)),
            this.Ygi = null,
            this.Jgi = [],
            this.Zgi = new Map,
            this.Qgi = null,
            this.tyi = null
        }
        he() {
            this.Ggt(),
            this.Ygi = null,
            this.Wgi.Ff(),
            this.Jgi.length = 0,
            this.Zgi.forEach(t => t.he()),
            this.Zgi.clear()
        }
        iyi() {
            if (this.Ngi.readyState !== WebSocket.CLOSED)
                throw new Error("Websocket is not closed");
            return this.Wgi.Ff(),
            this.Ngi = new WebSocket(this.jgi),
            this.Ngi.binaryType = "arraybuffer",
            this.zgi = new Zf.fwi( () => this.Vgi(),10,{
                enabled: !1
            }),
            this.Wgi = new Zf.Rf(Zf._f.Gf(this.Ngi, "open", t => this.Hgi(t)),Zf._f.Gf(this.Ngi, "close", t => this.Kgi(t)),Zf._f.Gf(this.Ngi, "message", t => this.qgi(t)),Zf._f.Gf(this.Ngi, "error", t => this.Xgi(t)),Zf._f.he(this.zgi)),
            new Promise( (t, i) => {
                this.Qgi = t,
                this.tyi = i
            }
            )
        }
        ev() {
            return this.$gi
        }
        eyi(t, i, e=Zf.WebSocket.eyi.syi) {
            Zf.zt(t),
            Zf.zt(e),
            Zf.tot(i);
            let s = this.Zgi.get(t);
            if (s || (s = new Zf.WebSocket.eyi(this,t,e),
            this.Zgi.set(t, s)),
            !s.nyi(e))
                throw new Error(`Requested channel is not requested type "${e}"`);
            return i ? s.ryi(i) : s
        }
        hyi(t, i) {
            return this.eyi(t, i, Zf.WebSocket.eyi.oyi)
        }
        ayi(t, i) {
            return this.eyi(t, i, Zf.WebSocket.eyi.JSON)
        }
        lyi(t) {
            Zf.zt(t);
            let i = this.Zgi.get(t);
            i && i.he()
        }
        uyi(t) {
            this.Zgi.delete(t)
        }
        Ggt(t, i) {
            const e = this.Ngi.readyState;
            e != WebSocket.OPEN && e != WebSocket.CONNECTING || this.Ngi.close(t, i)
        }
        cyi(t, i=Zf.WebSocket.eyi.syi) {
            return new Promise( (e, s) => {
                const n = this.eyi(t, t => {
                    n.he(),
                    r.Ff(),
                    e(t)
                }
                , i)
                  , r = Zf._f.Gf(this, "close", t => {
                    n.he(),
                    r.Ff(),
                    s(t)
                }
                )
            }
            )
        }
        dyi(t) {
            return this.cyi(t, Zf.WebSocket.eyi.JSON)
        }
        fyi(t) {
            return this.cyi(t, Zf.WebSocket.eyi.oyi)
        }
        pyi(t, i, e) {
            Zf.U(i, Uint8Array);
            const s = new Uint8Array(i.length + tp);
            for (let i = 0; i < tp; i++)
                s[i] = 255 & t.charCodeAt(i);
            return s.set(i, tp),
            this.myi(s, e)
        }
        wyi(t, i, e) {
            return i ? this.gyi(t, i, e) : this.yyi(t, e)
        }
        yyi(t, i) {
            return this.pyi(t, i)
        }
        gyi(t, i, e) {
            return Zf.zt(i),
            this.pyi(t, Qf.encode(i), e)
        }
        byi(t, i, e) {
            Zf.J1(i);
            let s = JSON.stringify(i);
            return this.gyi(t, s, e)
        }
        myi(t, i) {
            return Zf.U(t, Uint8Array),
            new Promise( (e, s) => {
                let n = {
                    data: t,
                    resolve: e,
                    reject: s
                };
                i ? this.Jgi.unshift(n) : this.Jgi.push(n),
                this.ev() && !this.zgi.Cwi() && (this.Vgi(),
                this.zgi.ke())
            }
            )
        }
        qgi({data: t}) {
            let i = new Uint8Array(t,0,tp)
              , e = Array(tp);
            for (let t = 0; t < tp; t++)
                e[t] = String.fromCharCode(i[t]);
            e = e.join("");
            let s = new Uint8Array(t,tp)
              , n = this.Zgi.get(e);
            n && n.vyi(s)
        }
        Hgi() {
            this.$gi = !0,
            this.Qgi && this.Qgi(),
            this.Qgi = null,
            this.tyi = null,
            this.Vgi(),
            this.zgi.ke();
            let t = Zf.v(Zf.Event, "open");
            this.dispatchEvent(t)
        }
        Kgi() {
            const t = Zf.v(Zf.Event, "close");
            this.Ygi && this.Ygi.reject(t),
            this.Ygi = null,
            this.zgi.Ewi(),
            this.tyi && this.tyi(t),
            this.Qgi = null,
            this.tyi = null,
            this.dispatchEvent(t)
        }
        Xgi(t) {
            this.Ygi && this.Ygi.reject(t),
            this.Ygi = null
        }
        Vgi() {
            const t = this.Ngi
              , i = this.Jgi;
            if (t.readyState !== WebSocket.OPEN)
                return;
            if (!(t.bufferedAmount > 0)) {
                if (this.Ygi && (this.Ygi.resolve(),
                this.Ygi = null),
                i.length > 0) {
                    let e = i.shift();
                    this.Ygi = e,
                    t.send(e.data)
                }
                this.Ygi || 0 !== i.length || this.zgi.Ewi()
            }
        }
        static async Syi(t) {
            const i = Zf.v(Zf.WebSocket, t);
            try {
                return await new Promise( (t, e) => {
                    const s = Zf._f.Gf(i, "open", () => {
                        s.Ff(),
                        n.Ff(),
                        t()
                    }
                    )
                      , n = Zf._f.Gf(i, "close", t => {
                        s.Ff(),
                        n.Ff(),
                        e(t)
                    }
                    )
                }
                ),
                i
            } catch (t) {
                throw i.he(),
                t
            }
        }
    }
}
{
    const ip = self.t
      , ep = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : null;
    ip.WebSocket.eyi = class t {
        constructor(i, e, s) {
            if (s !== t.syi && s !== t.oyi && s !== t.JSON)
                throw new Error(`Invalid channel type ${s}`);
            ip.U(i, ip.WebSocket),
            ip.zt(e),
            this.Ftt = e,
            this.aGt = s,
            this.xyi = i,
            this.Sfi = new Set
        }
        he() {
            this.xyi.uyi(this.Ftt),
            this.Sfi.clear()
        }
        nyi(t) {
            return t === this.aGt
        }
        wyi(i, e) {
            switch (this.aGt) {
            case t.JSON:
                return this.xyi.byi(this.Ftt, i, e);
            case t.syi:
                return this.xyi.gyi(this.Ftt, i, e);
            case t.oyi:
                return this.xyi.pyi(this.Ftt, i, e)
            }
        }
        ryi(t) {
            return ip.nu(t),
            this.Sfi.add(t),
            new ip._f( () => this.Sfi.delete(t))
        }
        vyi(i) {
            let e;
            switch (this.aGt) {
            case t.syi:
                e = ep.decode(i);
                break;
            case t.JSON:
                e = JSON.parse(ep.decode(i));
                break;
            case t.oyi:
                e = i
            }
            for (let t of this.Sfi)
                t(e)
        }
    }
    ,
    ip.WebSocket.eyi.oyi = "binary",
    ip.WebSocket.eyi.JSON = "json",
    ip.WebSocket.eyi.syi = "text"
}
{
    const sp = self.t;
    sp.nS = class {
        constructor() {
            this.Myi = new Map,
            this.Eyi = !1,
            this.Cyi = null,
            this._yi = null,
            this.Tyi = null,
            this.Iyi = null
        }
        mS(t) {
            this.Eyi = !!t
        }
        Pyi() {
            return this.Eyi
        }
        rS(t) {
            sp.nu(t),
            this.Cyi = t
        }
        Gyi(t) {
            if (!this.Cyi)
                throw new Error("no get base size callback set");
            return this.Cyi(t)
        }
        hS(t) {
            sp.nu(t),
            this._yi = t
        }
        Ayi(t, i, e, s, n, r) {
            if (!this._yi)
                throw new Error("no raster at size callback set");
            return this._yi(t, i, e, s, n, r)
        }
        cS(t) {
            sp.nu(t),
            this.Tyi = t
        }
        Ryi(t) {
            if (!this.Tyi)
                throw new Error("no release result callback set");
            this.Tyi(t)
        }
        pS(t) {
            sp.nu(t),
            this.Iyi = t
        }
        qut() {
            if (!this.Iyi)
                throw new Error("no redraw callback set");
            this.Iyi()
        }
        RS(t) {
            let i = this.Myi.get(t);
            return i || (i = sp.v(sp.kyi, this, t),
            this.Myi.set(t, i)),
            i.Oyi(),
            i
        }
        Dyi(t) {
            this.Myi.delete(t.kS())
        }
        CS() {
            for (const t of this.Myi.values())
                t.Fyi(),
                t._S()
        }
    }
}
{
    const np = self.t
      , rp = 4096;
    np.kyi = class {
        constructor(t, i) {
            this.xyi = t,
            this.Lyi = i,
            this.Byi = 0,
            this.Uyi = 0,
            this.Nyi = 0,
            this.jyi = this.xyi.Gyi(i).then(t => {
                this.xyi && (this.Uyi = t[0],
                this.Nyi = t[1],
                this.xyi.qut())
            }
            ).catch(t => {
                console.error("[SVG] Error loading SVG: ", t),
                this.Hn = !0,
                this.xyi && this.xyi.qut()
            }
            ),
            this.$yi = 0,
            this.zyi = 0,
            this.Vyi = 0,
            this.Wyi = 0,
            this.Hyi = !1,
            this.Kyi = null,
            this.qyi = !1,
            this.Hn = !1
        }
        he() {
            if (this.Byi <= 0)
                throw new Error("already released");
            this.Byi--,
            0 === this.Byi && this.S0()
        }
        Fyi() {
            this.Kyi && (this.xyi.Ryi(this.Kyi),
            this.Kyi = null)
        }
        S0() {
            this.Fyi(),
            this.xyi.Dyi(this),
            this.xyi = null
        }
        kS() {
            return this.Lyi
        }
        Oyi() {
            this.Byi++
        }
        Xyi() {
            return this.Byi > 0
        }
        ES() {
            return this.Kyi
        }
        _S() {
            this.qyi = !0
        }
        async FS(t, i, e) {
            if (0 === i || 0 === e || this.Hn)
                return;
            if (this.Hyi)
                return;
            let s = np.na(Math.ceil(i))
              , n = np.na(Math.ceil(e));
            const r = Math.max(s, n);
            if (r > rp) {
                const t = rp / r;
                i *= t,
                e *= t,
                s = Math.min(Math.ceil(s * t), rp),
                n = Math.min(Math.ceil(n * t), rp)
            }
            if (i < s && e < n) {
                const t = i / e;
                s / n > t ? (i = n * t,
                e = n) : (i = s,
                e = s / t)
            }
            if (this.xyi.Pyi() && (s = Math.ceil(i),
            n = Math.ceil(e)),
            s <= this.$yi && n <= this.zyi && !this.qyi)
                return;
            this.Hyi = !0,
            this.$yi = s,
            this.zyi = n;
            const h = await this.xyi.Ayi(this.Lyi, t, this.$yi, this.zyi, i, e);
            this.xyi && (this.Fyi(),
            this.Kyi = h,
            this.Vyi = i,
            this.Wyi = e,
            this.Hyi = !1,
            this.qyi = !1,
            this.xyi.qut())
        }
        Yyi() {
            return this.jyi
        }
        DS() {
            return this.Uyi
        }
        AS() {
            return this.Nyi
        }
        US() {
            return this.Vyi
        }
        BS() {
            return this.Wyi
        }
        LS() {
            return this.Hn
        }
    }
}
{
    const hp = self.t;
    let op = null;
    const ap = /\\/g;
    function lp(t) {
        return t.normalize().toLowerCase().replace(ap, "/")
    }
    let up = null
      , cp = !1;
    async function dp() {
        if (cp)
            return;
        cp = !0;
        const t = hp.Vgt() + "3rdparty/zipjs/zip.js";
        await hp.DYt(t),
        op = self.zip,
        up = hp.u7.Jyi()
    }
    hp.u7 = class {
        constructor() {
            this.Zyi = null,
            this.Qyi = new Map,
            this.tbi = 0,
            this.ibi = 0,
            this.ebi = new Set,
            this.sbi = 0,
            this.nbi = 0,
            this.rbi = -1,
            this.hbi = hp.v(hp.o4, 16)
        }
        he() {
            this.Sct(),
            this.Qyi && this.Qyi.clear(),
            this.Qyi = null,
            this.ebi && this.ebi.clear(),
            this.ebi = null
        }
        Sct() {
            this.Zyi && (this.Zyi.close(),
            this.Zyi = null)
        }
        static yrt() {
            return dp()
        }
        async _ct(t) {
            let i;
            if (hp.U(t, Blob),
            await dp(),
            this.Sct(),
            this.Qyi.clear(),
            this.ebi.clear(),
            this.tbi = 0,
            this.ibi = 0,
            t.size < 209715200) {
                const e = await hp.zii(t);
                i = new op.Uint8ArrayReader(new Uint8Array(e))
            } else
                i = new op.BlobReader(t);
            this.Zyi = new op.ZipReader(i);
            let e = 0;
            for await(const t of this.Zyi.getEntriesGenerator())
                this.Qyi.set(lp(t.filename), t),
                this.tbi += t.compressedSize,
                e++,
                e >= 1e3 && (await hp.mii(),
                e = 0);
            return this
        }
        obi(t) {
            return hp.zt(t),
            this.Qyi.has(lp(t))
        }
        Ict(t) {
            return hp.zt(t),
            this.Qyi.get(lp(t)) || null
        }
        abi() {
            return this.Qyi.values()
        }
        lbi() {
            return this.Qyi.keys()
        }
        ghi() {
            const t = (i, e, s) => {
                for (let t = s.length - 1; t >= 0; t--) {
                    const n = s[t]
                      , r = n.filename.replace(i, "");
                    !n.directory && r.includes("/") || (n.directory && 1 !== (r.match(/\//g) || []).length || (s.splice(t, 1),
                    n.directory ? e.push({
                        entry: n,
                        children: []
                    }) : e.push({
                        entry: n
                    })))
                }
                for (const i of e) {
                    const e = i.entry;
                    e.directory && t(e.filename, i.children, s)
                }
                return e.reverse()
            }
            ;
            let i = [...this.abi()];
            for (const t of i)
                t.filename = t.filename.replace(/\\/g, "/");
            for (const t of i) {
                if (t.directory)
                    continue;
                const e = t.filename.split("/");
                e.pop();
                let s = "";
                for (const t of e)
                    s += `${t}/`,
                    i.some(t => t.filename === s) || i.push({
                        filename: s,
                        directory: !0
                    })
            }
            return t("", [], i)
        }
        xct(t) {
            hp.zt(t);
            const i = t.toLowerCase();
            for (const t of this.Qyi.values())
                if (t.filename.toLowerCase().endsWith(i))
                    return t;
            return null
        }
        ubi(t) {
            return this.hbi.WL( () => this.cbi(t))
        }
        async cbi(t) {
            hp.IL(t);
            const i = {
                dbi: 0
            };
            this.ebi.add(i);
            const e = new op.TextWriter
              , s = await t.getData(e, {
                onprogress: t => i.dbi = t
            });
            return this.ebi.delete(i),
            this.ibi += t.compressedSize,
            s
        }
        async fbi(t) {
            hp.IL(t);
            const i = await this.ubi(t);
            return await hp.Yvt(i)
        }
        Gct(t, i) {
            return this.hbi.WL( () => this.pbi(t, i))
        }
        async pbi(t, i) {
            hp.IL(t),
            hp.gL(i);
            const e = i || hp.MimeType.Hst(hp.l7(t.filename)).eEt()
              , s = {
                dbi: 0
            };
            this.ebi.add(s);
            const n = new op.BlobWriter(e)
              , r = await t.getData(n, {
                onprogress: t => s.dbi = t
            });
            return this.ebi.delete(s),
            this.ibi += t.compressedSize,
            r.name = t.filename,
            t.lastModDate && (r.lastModified = +t.lastModDate),
            r
        }
        yct() {
            return this.tbi
        }
        gct() {
            return this.ibi + this.mbi()
        }
        mbi() {
            let t = 0;
            for (const i of this.ebi)
                t += i.dbi || 0;
            return t
        }
        wbi(t) {
            if (hp.Ge(t),
            t < -1 || t > 9)
                throw new RangeError("invalid compression level");
            this.rbi = t
        }
        gbi(t) {
            if (hp.Ge(t),
            -1 !== this.rbi)
                return this.rbi;
            const i = 1048576;
            return t > 5 * i ? 1 : t > 2 * i ? 2 : t > 1 * i ? 3 : t > 524288 ? 4 : 5
        }
        ybi(t) {
            let i = 0;
            for (const e of t.values()) {
                let t = null;
                t = hp.Jvt(e) ? e.data : e,
                i += t.byteLength || t.size || t.length || 0
            }
            return i
        }
        async f7(t, i) {
            let e;
            hp.Ef(i, Map),
            await dp(),
            this.sbi = 0,
            this.nbi = 0,
            this.ebi.clear(),
            e = this.ybi(t) < 262144e3 ? new up : new op.BlobWriter("application/zip");
            const s = new op.ZipWriter(e,{
                zip64: !0,
                supportZip64SplitFile: !1
            });
            await this.bbi(s, t, i);
            const n = await s.close();
            return n instanceof Blob ? n : new Blob([n],{
                type: "application/zip"
            })
        }
        async bbi(t, i, e) {
            const s = [];
            for (const [n,r] of i) {
                let i = null;
                if (i = hp.Jvt(r) ? r.data : r,
                "string" == typeof i)
                    this.sbi += i.length;
                else {
                    if (!hp.Bm(i, Blob))
                        throw new Error("unknown file content");
                    this.sbi += i.size
                }
                s.push(this.hbi.WL( () => this.vbi(t, n, r, e)))
            }
            await Promise.all(s)
        }
        async vbi(t, i, e, s) {
            let n, r = null, h = 0, o = null, a = null;
            hp.Jvt(e) ? (r = e.data,
            h = e.Sbi || 0,
            o = e.xbi || null,
            a = "number" == typeof e.Mbi ? e.Mbi : null) : r = e;
            let l = 5
              , u = 0;
            if ("string" == typeof r)
                n = new op.TextReader(r),
                u = r.length,
                l = this.gbi(u);
            else {
                if (!hp.Bm(r, Blob))
                    throw new Error("unknown file content");
                {
                    n = new op.BlobReader(r),
                    u = r.size,
                    l = this.gbi(u);
                    let t = r.type;
                    t || (t = hp.MimeType.Hst(hp.l7(i)).eEt()),
                    hp.MimeType.qs(t).gst() && (l = 0)
                }
            }
            const c = {
                bytesWritten: 0
            };
            this.ebi.add(c);
            const d = {
                level: l,
                externalFileAttribute: h,
                extraField: o,
                zip64: !0,
                supportZip64SplitFile: !1,
                onprogress: t => c.bytesWritten = t
            };
            null !== a && (d.versionMadeBy = a);
            const f = await t.add(i, n, d);
            this.ebi.delete(c),
            this.nbi += u,
            s && s.set(i, f.compressedSize)
        }
        Ebi() {
            return this.sbi
        }
        Cbi() {
            let t = 0;
            for (const i of this.ebi)
                t += i.bytesWritten || 0;
            return t
        }
        _bi() {
            return this.nbi + this.Cbi()
        }
    }
}
self.t.u7.Jyi = function() {
    return class extends self.zip.Writer {
        init(t=0) {
            super.init(),
            Object.assign(this, {
                offset: 0,
                arrayParts: [],
                totalSize: 0
            })
        }
        writeUint8Array(t) {
            this.arrayParts.push(t),
            this.totalSize += t.length
        }
        getData() {
            const t = new ArrayBuffer(this.totalSize)
              , i = new Uint8Array(t);
            let e = 0;
            for (const t of this.arrayParts)
                i.set(t, e),
                e += t.length;
            return i
        }
    }
}
;
{
    const fp = globalThis.t
      , pp = globalThis.lang
      , mp = globalThis.n_;
    let wp = null
      , gp = !1
      , yp = !1
      , bp = !1
      , vp = null
      , Sp = null
      , xp = null;
    const Mp = new Map
      , Ep = new WeakMap
      , Cp = new Map;
    let _p = null
      , Tp = !1;
    const Ip = new Map([["application/javascript", "javascript"], ["text/javascript", "javascript"], ["application/typescript", "typescript"], ["text/typescript", "typescript"], ["text/css", "css"], ["text/markdown", "markdown"], ["text/html", "html"], ["application/json", "json"], ["text/xml", "xml"], ["image/svg+xml", "xml"]])
      , Pp = ["de", "es", "fr", "it", "ja", "ko", "ru", "zh-cn", "zh-tw"];
    let Gp = null;
    const Ap = {
        textContent: null,
        mimeType: "text/plain",
        fontSize: null
    };
    async function Rp() {
        gp = !0,
        await fp.DYt(fp.Vgt() + "3rdparty/monaco/vs/loader.js", !0);
        const t = globalThis.require
          , i = {
            baseUrl: fp.Vgt() + "3rdparty/monaco",
            paths: {
                vs: fp.Vgt() + "3rdparty/monaco/vs"
            }
        }
          , e = globalThis.app.X7().toLowerCase();
        for (const t of Pp)
            if (e.startsWith(t)) {
                Gp = t,
                i["vs/nls"] = {
                    availableLanguages: {
                        "*": t
                    }
                };
                break
            }
        t.config(i),
        await new Promise(i => t(["vs/editor/editor.main"], i)),
        Sp = globalThis.monaco
    }
    async function kp() {
        if (xp)
            return;
        const t = await fetch("media/autocomplete-data.json");
        xp = await t.json()
    }
    fp.nEt = class t extends fp.Event.v_ {
        #t;
        #i;
        #e;
        #s;
        #n;
        #r = null;
        #h = !1;
        #o = !1;
        #a = null;
        #l = null;
        #u = 0;
        #c = !1;
        #d = null;
        #f = [];
        #p = null;
        #m = !1;
        #w = !1;
        #g = -1;
        #y = "";
        #b = 0;
        #v = !1;
        constructor(t, i) {
            fp.ibt(t),
            fp.kQ(i),
            super();
            const e = i.lEt
              , s = i.Iw
              , n = i.GS
              , r = i.vXt
              , h = i.gXt;
            fp.Ef(e, globalThis.Tbi),
            fp.Ef(s, globalThis.jw),
            fp.Ef(n, globalThis.e0),
            fp.kQ(r),
            fp.Ef(h, globalThis.aWt),
            this.#t = t,
            this.#i = e,
            this.#e = s,
            this.#s = n,
            this.#n = r,
            this.#r = h,
            this.#d = fp.v(fp.Rf, fp._f.Gf(globalThis.app, "settingschange", () => this.#S())),
            this.#r && this.#d.WL(fp._f.Gf(this.#r.jO(), "resize", () => this.FEt()), fp._f.Gf(this.#r.jO(), "move", () => this.FEt()), fp._f.Gf(this.#r, "scroll", () => this.FEt()))
        }
        static rXt() {
            return fp.Qs.wP.Ibi() ? "vs-dark" : "vs"
        }
        static async oEt() {
            return wp && !yp || (wp = t.#x()),
            wp
        }
        static async #x() {
            const t = globalThis.app;
            let i = null;
            yp = !1;
            try {
                i = t.Pbi(globalThis.lang("ui.bars.textEditor.loading-status")),
                i.lQ();
                const [e] = await Promise.all([import(fp.Vgt() + "3rdparty/monaco-ts-locales/index.js"), Rp(), kp()]);
                Gp && e.register(Sp)
            } catch (t) {
                throw i.he(),
                yp = !0,
                t
            }
            try {
                bp = !0;
                const i = Sp.languages.typescript;
                console.log("Loaded Monaco editor, using TypeScript v" + i.typescriptVersion),
                i.javascriptDefaults.setEagerModelSync(!0),
                i.typescriptDefaults.setEagerModelSync(!0),
                this.#M(!1, !0);
                const e = await fp.Abi.Gbi()
                  , s = [];
                for (const [t,i] of e)
                    t.endsWith("AddonSDK.d.ts") || s.push({
                        content: i,
                        filePath: "file:///ts-defs/runtime/" + fp.zti(t)
                    });
                i.javascriptDefaults.setExtraLibs(s),
                i.typescriptDefaults.setExtraLibs(s),
                Sp.editor.registerEditorOpener({
                    openCodeEditor: (t, i, e) => fp.nEt.Rbi(t, i, e)
                }),
                Sp.languages.registerCompletionItemProvider("typescript", {
                    triggerCharacters: ".",
                    provideCompletionItems: (t, i, e, s) => t.uri.toString().toLowerCase().endsWith(".js") ? fp.nEt.kbi(t, i, e) : null,
                    resolveCompletionItem: (t, i) => null
                }),
                Sp.editor.setTheme(fp.nEt.rXt()),
                vp = Sp.editor.createModel("/* dummy js model */", "javascript", Sp.Uri.parse("file:///construct-internal/__dummy_js_model__.js")),
                await t.Obi("monacoeditorloaded")
            } finally {
                i.he()
            }
        }
        static #M(t, i) {
            if (t = !!t,
            !i && Tp === t)
                return;
            Tp = t;
            const e = Sp.languages.typescript
              , s = ["lib.es2023.d.ts"];
            t ? s.push("lib.webworker.d.ts") : s.push("lib.dom.d.ts");
            const n = {
                target: e.ScriptTarget.ESNext,
                module: e.ModuleKind.ESNext,
                esModuleInterop: !1,
                forceConsistentCasingInFileNames: !0,
                strict: !0,
                skipLibCheck: !0,
                lib: s,
                allowJs: !0,
                moduleDetection: 3
            };
            Gp && (n.locale = Gp),
            e.typescriptDefaults.setCompilerOptions(n)
        }
        static async Rbi(t, i, e) {
            const s = globalThis.app
              , n = i.path;
            let r = null;
            if (n.toLowerCase().endsWith(".d.ts")) {
                const i = Ep.get(t);
                return void i?.Dbi()
            }
            const h = globalThis.Lbi.Fbi(n);
            if (h) {
                let t = -1;
                if ("number" == typeof e.lineNumber)
                    t = e.lineNumber;
                else {
                    if ("number" != typeof e.startLineNumber)
                        return !1;
                    t = e.startLineNumber
                }
                if (r = h.Bbi(t)?.Dee,
                !r)
                    return !1
            } else {
                const t = globalThis.Tbi.Fbi(n);
                if (!t)
                    return !1;
                r = t._te()
            }
            if (r instanceof globalThis.e0) {
                const t = s.Iwe()
                  , i = await t.MEt(r);
                e && (await i.bEt(),
                "number" == typeof e.column ? i.mEt(e.lineNumber, e.column) : i.jEt(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn))
            } else {
                const t = s.CT().OT(r.GT());
                await t.OBt(),
                t.jYt(r, {
                    t1t: !0
                }),
                fp.Qs.TO.Pz(t.jO())
            }
            return !0
        }
        static Ubi() {
            return gp
        }
        static oXt() {
            return bp
        }
        static lXt() {
            return Sp
        }
        async hP(t) {
            if (!Sp)
                throw new Error("monaco not loaded");
            const i = (t = Object.assign({}, Ap, t)).textContent
              , e = t.mimeType;
            fp.gL(i),
            fp.zt(e);
            const s = globalThis.app.aU();
            this.#p = fp.Qs.W_("div", document.body, null, "construct-monaco-overlay monaco-editor"),
            this.#p.style.display = "none",
            this.#m = !1;
            const n = {
                dropIntoEditor: {
                    enabled: !1
                },
                overflowWidgetsDomNode: this.#p,
                contextmenu: !1,
                theme: fp.nEt.rXt(),
                fontSize: t.fontSize || s.textEditorFontSize || 12,
                autoIndent: s.textEditorAutoIndent ? "advanced" : "keep",
                wordWrap: s.textEditorEnableWordWrap ? "on" : "off",
                minimap: {
                    enabled: s.textEditorEnableMinimap,
                    scale: s.textEditorMinimapScale
                },
                stickyScroll: {
                    enabled: s.textEditorEnableStickyScrolling
                },
                folding: s.textEditorEnableCodeFolding
            };
            this.#l = Ip.get(e),
            this.#l && (n.language = this.#l);
            let r = -1
              , h = -1
              , o = -1;
            if (this.#i)
                if (this.#i._te()instanceof globalThis.e0) {
                    if (n.model = await this.#i.Nbi(),
                    this.#o)
                        return
                } else {
                    if (this.#h = !0,
                    n.model = await this.#e.nXt(this.#l).Nbi(),
                    this.#o)
                        return;
                    n.minimap.enabled = !1,
                    n.stickyScroll.enabled = !1,
                    n.scrollbar = {
                        horizontal: "hidden",
                        vertical: "hidden"
                    },
                    n.overviewRulerBorder = !1,
                    n.overviewRulerLanes = 0,
                    n.hideCursorInOverviewRuler = !0,
                    n.scrollBeyondLastLine = !1,
                    n.lineNumbersMinChars = 3,
                    n.multiCursorLimit = 1,
                    n.folding = !1;
                    const t = n.model.getValue()
                      , i = this.#i._te().zL()
                      , e = t.indexOf("//construct-start-block:" + i)
                      , s = t.indexOf("//construct-end-block:" + i);
                    r = fp.Ooi(t, e) + 2,
                    h = fp.Ooi(t, s),
                    o = n.model.getLineCount(),
                    n.lineNumbers = t => String(t - r),
                    this.#g = r + 1,
                    this.#y = "//construct-end-block:" + i,
                    this.#d.WL(fp._f.Gf(this.#t, "keydown", t => this.#E(t), !0), fp._f.Gf(this.#t, "wheel", t => this.#C(t), !0))
                }
            else
                n.value = i;
            n.model && (Mp.set(n.model.uri.path, this),
            this.#u = n.model.getValueLength()),
            this.#a = Sp.editor.create(this.#t, n);
            const a = this.#f;
            this.#h && (this.#a.setHiddenAreas([new Sp.Range(0,0,r,0), new Sp.Range(h,0,o,0)]),
            this.mEt(r + 1, 0),
            this.#w = !0,
            a.push(this.#a.onDidChangeCursorPosition(t => this.#_(t))),
            a.push(this.#a.onDidChangeCursorSelection(t => this.#T(t)))),
            a.push(this.#a.onDidChangeModelContent( () => this.#I())),
            a.push(this.#a.onDidContentSizeChange( () => this.#P())),
            a.push(this.#a.onContextMenu(t => this.#G(t))),
            a.push(this.#a.onDidFocusEditorText( () => this.#A())),
            a.push(this.#a.onDidFocusEditorWidget( () => this.#A())),
            a.push(this.#a.onDidBlurEditorText( () => this.#R())),
            a.push(this.#a.onDidBlurEditorWidget( () => this.#R())),
            this.#d.WL(fp._f.Gf(this.#p, "keydown", t => this.#k(t))),
            this.#s && !this.#i && this.#d.WL(fp._f.Gf(this.#s, "projectfileblobchange", t => this.#O(t))),
            Ep.set(this.#a, this)
        }
        he() {
            Mp.delete(this.#a.getModel().uri.path),
            this.#D(),
            this.#o = !0,
            this.#d.Ff(),
            this.#d = null;
            for (const t of this.#f)
                t.dispose();
            fp.Io(this.#f),
            this.#a && (Ep.delete(this.#a),
            this.#a.dispose(),
            this.#a = null),
            this.#p && (this.#p.remove(),
            this.#p = null),
            this.#t = null,
            this.#i = null,
            this.#e = null,
            this.#n = null,
            super.he()
        }
        #F() {
            let t = 1 / 0;
            if (this.#y) {
                const i = this.#a.getValue()
                  , e = i.indexOf(this.#y);
                -1 !== e && (t = fp.Ooi(i, e) - 1)
            }
            return [this.#g, t]
        }
        #_(t) {
            if (!this.#w || this.#v)
                return;
            const [i,e] = this.#F()
              , s = t.position;
            let n = s.lineNumber
              , r = s.column
              , h = !1;
            n < i ? (n = this.#g,
            r = this.#b,
            h = !0) : s.lineNumber > e ? (n = e,
            r = this.#b,
            h = !0) : this.#b = r,
            h && (this.#v = !0,
            this.#a.setPosition({
                lineNumber: n,
                column: r
            }),
            this.#v = !1)
        }
        #T(t) {
            if (!this.#w || this.#v)
                return;
            const i = t.selection
              , [e,s] = this.#F();
            let n = i.selectionStartLineNumber
              , r = i.selectionStartColumn
              , h = i.positionLineNumber
              , o = i.positionColumn
              , a = !1
              , l = !1;
            h < e ? (h = this.#g,
            o = this.#b,
            a = !0) : h > s ? (h = s,
            o = this.#b,
            l = !0,
            a = !0) : this.#b = o,
            n < e ? (n = this.#g,
            r = this.#b,
            a = !0,
            l && (r = 1,
            o = 1 / 0)) : n > s && (n = s,
            r = this.#b,
            a = !0),
            a && (this.#v = !0,
            this.#a.setSelection(new Sp.Selection(n,r,h,o)),
            this.#v = !1)
        }
        #E(t) {
            if (this.#w) {
                if ("Delete" === t.key || "Backspace" === t.key) {
                    if (this.XA())
                        return;
                    const [i,e] = this.#F()
                      , s = this.#a.getPosition()
                      , n = s.lineNumber
                      , r = s.column;
                    let h = !1;
                    if (n === i && 1 === r && "Backspace" === t.key)
                        h = !0;
                    else if (n === e && "Delete" === t.key) {
                        r > this.#a.getModel().getLineLength(e) && (h = !0)
                    }
                    h && (t.preventDefault(),
                    t.stopPropagation())
                }
                "F1" === t.key && this.#h && (t.preventDefault(),
                t.stopPropagation())
            }
        }
        #C(t) {
            t.stopPropagation()
        }
        CEt() {
            this.#a && this.#a.focus()
        }
        PEt() {
            return !!this.#a && this.#a.hasTextFocus()
        }
        wEt() {
            return !!this.#a && this.#a.hasWidgetFocus()
        }
        jbi() {
            return this.PEt() || this.wEt()
        }
        #A() {
            this.#p && this.#L()
        }
        #R() {
            this.#p && !this.jbi() && this.#D()
        }
        #L() {
            this.#m || (this.#m = !0,
            document.body.appendChild(this.#p),
            this.#p.style.display = "",
            this.FEt(),
            globalThis.app.mdt() && (this.#p.style.zIndex = 99999))
        }
        #D() {
            this.#m && (this.#m = !1,
            this.#p.style.display = "none")
        }
        FEt() {
            if (!this.#m)
                return;
            const t = this.#t.getBoundingClientRect()
              , i = this.#t.ownerDocument.defaultView;
            this.#p.style.left = t.left + "px",
            this.#p.style.top = t.top + "px",
            this.#p.style.width = i.innerWidth - t.left + "px",
            this.#p.style.height = t.height + "px"
        }
        #k(t) {
            "Enter" === t.key ? (t.stopPropagation(),
            t.preventDefault(),
            this.#B("acceptRenameInput")) : "Escape" === t.key && (t.stopPropagation(),
            t.preventDefault(),
            this.#B("cancelRenameInput"))
        }
        async fEt() {
            if (this.#i && this.#a) {
                const t = await this.#i.Nbi();
                if (this.#o)
                    return;
                this.#a.setModel(t)
            }
        }
        #S() {
            if (!this.#a || this.#h)
                return;
            const t = globalThis.app.aU();
            this.#a.updateOptions({
                fontSize: t.textEditorFontSize || 12,
                autoIndent: t.textEditorAutoIndent ? "advanced" : "keep",
                wordWrap: t.textEditorEnableWordWrap ? "on" : "off",
                minimap: {
                    enabled: t.textEditorEnableMinimap,
                    scale: t.textEditorMinimapScale
                },
                stickyScroll: {
                    enabled: t.textEditorEnableStickyScrolling
                },
                folding: t.textEditorEnableCodeFolding
            })
        }
        CXt() {
            return this.#t
        }
        wXt() {
            return this.#n
        }
        g_() {
            this.#a && this.#a.layout()
        }
        SXt() {
            return this.#a ? this.#a.getContentHeight() : 0
        }
        #I() {
            const t = globalThis.app
              , i = this.#u
              , e = this.#a.getModel().getValueLength();
            if (this.#u = e,
            this.#i && !t.TEt()) {
                if (this.#i._te()instanceof globalThis.e0)
                    this.#i.$bi(this.#a.getModel().getLineCount());
                else if (this.#w) {
                    const [t,i] = this.#F();
                    this.#i.$bi(i - t)
                }
                if (e > i && this.#i.Cn().zbi() > t.Vbi())
                    return this.ext(),
                    void t.Q7(this.#i.Cn(), 2)
            }
            if (this.dispatchEvent(new fp.Event("change")),
            this.#s && !this.#i) {
                if (this.#c)
                    return;
                const t = this.#a.getValue();
                this.#s.Wbi(t)
            }
        }
        #P() {
            this.dispatchEvent(new fp.Event("contentsizechange"))
        }
        Hbi() {
            return this.#a ? this.#a.getModel().getVersionId() : 0
        }
        iSt() {
            return this.#a ? this.#a.getValue() : ""
        }
        ha(t) {
            this.#a && this.#a.setValue(t)
        }
        i_t() {
            if (this.#a)
                return this.#a.getModel().canUndo()
        }
        ext() {
            this.#B("undo")
        }
        s_t() {
            if (this.#a)
                return this.#a.getModel().canRedo()
        }
        nxt() {
            this.#B("redo")
        }
        Cut() {
            this.#B("editor.action.clipboardCutAction")
        }
        Kbi() {
            this.#B("editor.action.clipboardCopyAction")
        }
        mL() {
            this.#B("editor.action.clipboardPasteAction")
        }
        XT() {
            this.#B("deleteAllRight")
        }
        XA() {
            if (!this.#a)
                return !1;
            const t = this.#a.getSelection();
            return !!t && (t.selectionStartLineNumber !== t.positionLineNumber || t.selectionStartColumn !== t.positionColumn)
        }
        mEt(t, i) {
            this.#a && this.#a.setPosition({
                column: i,
                lineNumber: t
            })
        }
        jEt(t, i, e, s) {
            this.#a && this.#a.setSelection({
                startLineNumber: t,
                startColumn: i,
                endLineNumber: e,
                endColumn: s
            })
        }
        pXt(t, i) {
            if (!this.#a)
                return;
            const e = this.#a.getTargetAtClientPoint(t, i);
            e && e.position && this.#a.setPosition(e.position)
        }
        EEt() {
            this.#a && this.#a.revealRangeInCenter(this.#a.getSelection(), 0)
        }
        #G(t) {
            t.event.browserEvent.stopPropagation();
            const i = fp.p.Yue("ui.bars.textEditor.context-menu");
            t.event.preventDefault();
            const e = t.event.posx
              , s = t.event.posy
              , n = fp.v(fp.Qs.EA, this.#t);
            "javascript" !== this.#l && "typescript" !== this.#l || (n._A(null, i(".go-to-definition"), () => this.qbi()),
            n._A(null, i(".peek-definition"), () => this.Dbi()),
            n._A(null, i(".find-references"), () => this.Xbi()),
            n._A(null, i(".go-to-symbol"), () => this.Ybi()),
            n._A("edit", i(".rename"), () => this.wnt()),
            this.#h || (n._A(null, i(".change-all-occurrences"), () => this.Jbi()),
            n._A(null, i(".format-document"), () => this.Zbi())),
            n.YA()),
            "json" === this.#l && (n._A("json", pp("ui.bars.textEditor.beautify"), () => this.Zbi()),
            n._A("json", pp("ui.bars.textEditor.minify"), () => this.#U()),
            n.YA()),
            "html" !== this.#l && "css" !== this.#l || (n._A(null, i(".format-document"), () => this.Zbi()),
            n.YA());
            const r = this.i_t()
              , h = this.s_t();
            (r || h) && (n.RT(),
            r && n._A("undo", pp("main-menu.undo"), () => this.ext()),
            h && n._A("redo", pp("main-menu.redo"), () => this.nxt()),
            n.ET(),
            n.YA());
            let o = !1;
            this.XA() && (n._A("delete", pp("common.delete"), () => this.XT()),
            n.YA(),
            n.RT(),
            o = !0,
            n._A("cut", pp("common.cut"), () => this.Cut(), {
                MT: !0
            }),
            n._A("copy", pp("common.copy"), () => this.Kbi(), {
                MT: !0
            })),
            n._A("paste", pp("common.paste"), () => this.mL(), {
                MT: !0
            }),
            o && n.ET(),
            this.#h || (n.YA(),
            n._A(null, i(".command-palette"), () => this.Qbi())),
            n.NT(e, s)
        }
        qbi() {
            this.#B("editor.action.revealDefinition")
        }
        Xbi() {
            this.#B("editor.action.goToReferences")
        }
        Ybi() {
            this.#B("editor.action.quickOutline")
        }
        Dbi() {
            this.#B("editor.action.peekDefinition")
        }
        tvi() {
            this.#B("editor.action.peekReferences")
        }
        wnt() {
            this.#B("editor.action.rename")
        }
        Jbi() {
            this.#B("editor.action.changeAll")
        }
        Zbi() {
            this.#B("editor.action.formatDocument")
        }
        #U() {
            if (!this.#a)
                return;
            const t = this.#a.getValue();
            let i = null;
            try {
                i = JSON.parse(t)
            } catch (t) {
                (() => {})("Error parsing JSON: ", t);
                return void fp.Qs.Ks.qs("OK").Xa(pp("ui.bars.textEditor.validation-error"))
            }
            this.#a.setValue(JSON.stringify(i))
        }
        Qbi() {
            this.#B("editor.action.quickCommand")
        }
        AXt() {
            this.#B("hideSuggestWidget")
        }
        #B(t) {
            this.#a && this.#a.trigger("construct", t)
        }
        _Xt() {
            if (!this.#a)
                return !1;
            const t = this.#p.querySelector(".suggest-widget");
            if (!t)
                return !1;
            return "none" !== globalThis.getComputedStyle(t).getPropertyValue("display")
        }
        async #O(t) {
            if (t.ivi)
                return;
            const i = await fp.Ist(this.#s.lS());
            this.#o || (this.#c = !0,
            this.#a.setValue(i),
            this.#c = !1)
        }
        uEt() {
            return this.#c
        }
        static #N(t) {
            return "file://" + encodeURI(t).replace(/[^A-Za-z0-9%_\-\.\\/]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`)
        }
        static async evi(i) {
            const e = await t.#j(i, "javascript");
            return e || await t.#j(i, "typescript")
        }
        static async #j(i, e) {
            if (!i.mLt(e, !0))
                return null;
            try {
                await fp.nEt.oEt()
            } catch (t) {
                return console.error("Failed to load code editor: ", t),
                null
            }
            const s = [...i.nvi(e)].map(t => t.sEt())
              , [n,r] = await Promise.all([Promise.all(s.map(t => t.Nbi())), i.nXt(e).Nbi()])
              , h = [...n, r];
            s.push(i.nXt(e));
            const o = await Sp.languages.typescript["javascript" === e ? "getJavaScriptWorker" : "getTypeScriptWorker"]()
              , a = h.map(t => t.uri)
              , l = await o(...a)
              , u = Promise.all(a.map(i => l.getSyntacticDiagnostics(t.#N(i.path))));
            let c = Promise.resolve([]);
            "typescript" === e && (c = Promise.all(a.map(i => l.getSemanticDiagnostics(t.#N(i.path)))));
            const [d,f] = await Promise.all([u, c])
              , p = t.#$(d, f, s, h);
            return p || null
        }
        static #$(t, i, e, s) {
            for (let n = 0, r = t.length; n < r; ++n) {
                const r = t[n]
                  , h = i[n]
                  , o = r.slice(0);
                Array.isArray(h) && fp.Oo(o, h);
                const a = e[n]
                  , l = s[n];
                for (const t of o)
                    if (1 === t.category) {
                        const i = "string" == typeof t.messageText ? t.messageText : t.messageText.messageText
                          , e = l.getPositionAt(t.start).lineNumber;
                        if (a instanceof globalThis.Lbi) {
                            const t = a.Bbi(e);
                            if (!t) {
                                (() => {})("Failed to identify event sheet script for script error; ignoring");
                                continue
                            }
                            const s = t.Dee;
                            if (s instanceof globalThis.e0)
                                return {
                                    rvi: s,
                                    hvi: {
                                        line: e - 1,
                                        message: i
                                    }
                                };
                            if (!s.cXt())
                                continue;
                            const n = Math.min(e - t.ovi - 1, fp.koi(s.aXt(), "\n"));
                            return {
                                rvi: s,
                                hvi: {
                                    line: n,
                                    message: i
                                }
                            }
                        }
                        return {
                            rvi: a._te(),
                            hvi: {
                                line: e - 1,
                                message: i
                            }
                        }
                    }
            }
            return null
        }
        static avi() {
            _p && _p.dispose(),
            _p = Sp.languages.typescript.typescriptDefaults.addExtraLib(`/* dummy lib ${Math.floor(1e6 * Math.random())} */`, "construct-internal/__dummy_lib__.js")
        }
        static async uvi(i, e) {
            if (!fp.nEt.oXt())
                return;
            const s = new Set([...Cp.keys()]);
            for (const [t,e] of i)
                if (s.delete(t),
                Cp.has(t)) {
                    const i = Cp.get(t);
                    i.model.getValue() !== e && (i.model.setValue(e),
                    i.cvi.dispose(),
                    i.cvi = Sp.languages.typescript.typescriptDefaults.addExtraLib(e, t))
                } else {
                    const i = Sp.editor.createModel(e, "typescript", Sp.Uri.parse(t))
                      , s = Sp.languages.typescript.typescriptDefaults.addExtraLib(e, t);
                    Cp.set(t, {
                        model: i,
                        cvi: s
                    })
                }
            for (const t of s) {
                const {model: i, cvi: e} = Cp.get(t);
                e.dispose(),
                i.dispose(),
                Cp.delete(t)
            }
            t.#M(e)
        }
        static async fvi(i) {
            if (!i.mLt("typescript"))
                return null;
            try {
                await fp.nEt.oEt()
            } catch (t) {
                return console.error("Failed to load code editor: ", t),
                null
            }
            const e = globalThis.app.Pbi(globalThis.lang("ui.bars.textEditor.compiling-typescript"));
            e.lQ();
            try {
                const e = [...i.nvi("typescript")].filter(t => "imports-for-events" !== t.Xle())
                  , s = e.map(t => t.sEt())
                  , n = await Promise.all(s.map(t => t.Nbi()));
                let r = null;
                if (i.pvi("typescript")) {
                    const t = i.nXt("typescript")
                      , e = await t.mvi(!0);
                    r = Sp.editor.createModel(e, "typescript", Sp.Uri.parse("/" + fp.Abi.wvi() + `project/__c3_tsInEvents_temp${Math.floor(1e6 * Math.random())}__.ts`)),
                    n.push(r)
                }
                const h = await Sp.languages.typescript.getTypeScriptWorker()
                  , o = n.map(t => t.uri)
                  , a = await h(...o)
                  , l = await Promise.all(o.map(i => a.getEmitOutput(t.#N(i.path))))
                  , u = {
                    gvi: null,
                    yvi: []
                };
                let c = 0;
                for (const t of l) {
                    const i = n[c]
                      , s = e[c];
                    ++c;
                    const h = t.outputFiles.filter(t => t.name.toLowerCase().endsWith(".js"));
                    if (0 === h.length)
                        continue;
                    if (h.length > 1)
                        throw console.error("Unexpected TypeScript compiler output - got multiple output files: ", h),
                        new Error("typescript compile error");
                    const o = h[0];
                    i === r ? u.gvi = o.text : u.yvi.push([s, o.text])
                }
                return r && r.dispose(),
                u
            } finally {
                e.he()
            }
        }
        static kbi(t, i, e) {
            const s = Sp.languages.CompletionItemKind
              , n = e.triggerCharacter;
            if (!xp)
                return null;
            let r = null;
            const h = t.uri.path
              , o = globalThis.Lbi.Fbi(h);
            if (o)
                r = o.Cn();
            else {
                const t = globalThis.Tbi.Fbi(h);
                t && (r = t.Cn())
            }
            const a = Mp.get(h)
              , l = t.getValueInRange({
                startLineNumber: i.lineNumber,
                startColumn: 0,
                endLineNumber: i.lineNumber,
                endColumn: i.column
            })
              , u = globalThis.vvi.bvi(l);
            if (0 === u.length)
                return;
            if (u.reverse(),
            fp.xoi(fp.th(u[0])))
                return;
            const c = new Map
              , d = [];
            function f(t) {
                let i = c.get(t.name);
                i ? t.interfaceName && i.Svi.add(t.interfaceName) : (t.Svi = new Set(t.interfaceName ? [t.interfaceName] : []),
                c.set(t.name, t),
                d.push(t))
            }
            let p = !0;
            if ("runtime" === u[0] || "#runtime" === u[0])
                for (const t of xp.properties.IRuntime)
                    f({
                        name: t,
                        kind: "Property",
                        interfaceName: "IRuntime"
                    });
            else if ("behaviors" === u[0]) {
                if (r)
                    for (const t of r.R4t())
                        if (t.$a().WA())
                            for (const i of t.xvi())
                                f({
                                    name: i.La(),
                                    kind: "Field",
                                    description: i.wre().La()
                                })
            } else if ("localVars" === u[0]) {
                if (r && a && a.wXt())
                    for (const t of r.Mvi(a.wXt()))
                        t.IP() || f({
                            name: t.EBt(),
                            kind: "Variable",
                            description: t.Sce() || " "
                        })
            } else if (u.length >= 2 && ("runtime" === u[1] || "#runtime" === u[1])) {
                const t = u[0]
                  , i = new Map([["mouse", "IMouseObjectType"], ["keyboard", "IKeyboardObjectType"], ["touch", "ITouchObjectType"], ["layout", "ILayout"], ["assets", "IAssetManager"], ["collisions", "ICollisionEngine"], ["storage", "IStorage"], ["platformInfo", "IPlatformInfo"]]);
                if ("objects" === t) {
                    if (r)
                        for (const t of r.R4t())
                            f({
                                name: t.La(),
                                kind: "Field",
                                description: t.$a().La()
                            })
                } else if ("globalVars" === t) {
                    if (r)
                        for (const t of r.Evi())
                            f({
                                name: t.EBt(),
                                kind: "Variable",
                                description: t.Sce() || " "
                            })
                } else if (i.has(t)) {
                    const e = i.get(t);
                    for (const t of xp.properties[e])
                        f({
                            name: t,
                            kind: "Property",
                            interfaceName: e
                        })
                }
            } else if ("." === n) {
                p = !1;
                for (const [t,i] of Object.entries(xp.properties))
                    if ("global" !== t)
                        for (const e of i)
                            f({
                                name: e,
                                kind: "Property",
                                interfaceName: t
                            })
            }
            d.sort( (t, i) => fp.$oi(t.name, i.name));
            const m = new Intl.ListFormat(globalThis.app.X7(),{
                style: "long",
                type: "conjunction"
            });
            return {
                suggestions: d.map(t => {
                    let i = t.description
                      , e = null;
                    if (!i) {
                        const s = t.Svi;
                        1 === s.size ? i = fp.th(s) : (i = mp("ui.bars.textEditor.autocomplete.multiple-interfaces-description", null, s.size),
                        e = m.format([...s].sort(fp.$oi)))
                    }
                    const n = {
                        insertText: t.name,
                        documentation: e,
                        kind: s[t.kind],
                        label: {
                            description: i,
                            label: t.name
                        }
                    };
                    return p && (n.sortText = " " + t.name),
                    n
                }
                )
            }
        }
    }
}
{
    const Op = self.t
      , Dp = self.assert;
    Op.y7 = {},
    Op.y7.Cvi = function(t) {
        return Op.Aoi((((i = t).startsWith("/") || i.startsWith("\\")) && (i = i.substring(1)),
        (i.endsWith("/") || i.endsWith("\\")) && (i = i.substring(0, i.length - 1)),
        i), "\\", "/");
        var i
    }
    ;
    const Fp = Op.v(Op.o4, 8);
    async function Lp(t, i) {
        const e = await t.createWritable();
        await e.write(i),
        await e.close()
    }
    Op.y7.b7 = function(t, i) {
        return Op.U(t, FileSystemFileHandle),
        Fp.WL( () => Lp(t, i))
    }
    ,
    Op.y7._vi = async function(t, i, e) {
        Op.U(t, FileSystemDirectoryHandle),
        Op.zt(i);
        const s = await t.getFileHandle(i, {
            create: !0
        });
        await Op.y7.b7(s, e)
    }
    ;
    const Bp = Op.v(Op.o4, 8);
    async function Up(t) {
        const i = await Op.zii(t);
        return await Op.Crypto.Xni(i)
    }
    async function Np(t, i) {
        try {
            const e = await t.getFile();
            if ("string" == typeof i) {
                let t = await Op.Ist(e);
                if (t = Op.Aoi(t, "\r\n", "\n"),
                i === t)
                    return
            } else if (e.size === i.size) {
                const t = await Up(e);
                if (t === await Up(i))
                    return
            }
        } catch (i) {
            (() => {})(`Error reading file '${t.name}' to check for changes; proceeding to overwrite file: `, i)
        }
        await Op.y7.b7(t, i)
    }
    function jp(t) {
        const i = Op.Qs.Ks.qs("Confirm");
        return new Promise( (e, s) => {
            i.Pii = async () => {
                Op.Qs.Tvi.lQ();
                try {
                    "granted" === await t.requestPermission({
                        mode: "readwrite"
                    }) ? e() : s(new Error("folder write permission denied"))
                } catch (t) {
                    s(t)
                } finally {
                    Op.Qs.Tvi.j0()
                }
            }
            ;
            const n = "ui.folder-write-access-prompt";
            i.Xa({
                caption: self.lang(n + ".caption"),
                message: self.lang(n + ".message"),
                _nt: self.lang(n + ".confirm-text")
            }).then(t => {
                null === t && s(new Error("folder write permission denied"))
            }
            )
        }
        )
    }
    Op.y7.Ivi = async function(t, i, e) {
        Op.U(t, FileSystemDirectoryHandle),
        Op.zt(i);
        const s = await t.getFileHandle(i, {
            create: !0
        });
        await Bp.WL( () => Np(s, e))
    }
    ,
    Op.y7.Pvi = async function(t, i, e) {
        if (Op.U(t, FileSystemDirectoryHandle),
        Op.zt(i),
        e = !!e,
        !(i = Op.y7.Cvi(i)))
            return t;
        const s = i.split("/");
        let n = t;
        for (const t of s)
            n = await n.getDirectoryHandle(t, {
                create: e
            });
        return n
    }
    ,
    Op.y7.Gvi = async function(t, i) {
        if (Op.U(t, FileSystemDirectoryHandle),
        Op.zt(i),
        !(i = Op.y7.Cvi(i)))
            throw new Error("empty path");
        const e = i.split("/");
        let s = t;
        for (let t = 0, i = e.length - 1; t < i; ++t) {
            const i = e[t];
            s = await s.getDirectoryHandle(i, {
                create: !1
            })
        }
        return s.getFileHandle(e.at(-1), {
            create: !1
        })
    }
    ,
    Op.y7.Avi = async function(t, i) {
        return Op.y7.Pvi(t, i, !0)
    }
    ,
    Op.y7.Rvi = async function(t) {
        if (Op.U(t, FileSystemDirectoryHandle),
        navigator.userActivation && navigator.userActivation.isActive)
            return;
        const i = await t.queryPermission({
            mode: "readwrite"
        });
        if ("granted" !== i) {
            if ("denied" === i)
                throw new Error("folder write permission denied");
            "prompt" === i && await jp(t)
        }
    }
    ,
    Op.y7.kvi = async function(t, i, e, s=!1) {
        Op.U(t, FileSystemDirectoryHandle),
        Op.U(i, Map),
        Op.tot(e);
        const n = new Map;
        for (const t of i.keys())
            n.set(Op.IW(t), null);
        for (const i of n.keys()) {
            const e = await Op.y7.Avi(t, i);
            n.set(i, e)
        }
        const r = [];
        for (const [t,e] of i) {
            const i = Op.zti(t)
              , h = n.get(Op.IW(t));
            Dp(void 0 !== h, "cannot find folder handle"),
            s ? r.push(Op.y7.Ivi(h, i, e)) : r.push(Op.y7._vi(h, i, e))
        }
        return e ? Op.lii(r, e) : Promise.all(r)
    }
    ,
    Op.y7.Ovi = async function(t, i) {
        Op.U(t, FileSystemDirectoryHandle);
        const e = new Map;
        for (const t of i)
            e.set(Op.IW(t), null);
        for (const i of e.keys()) {
            const s = await Op.y7.Pvi(t, i, !1);
            e.set(i, s)
        }
        const s = [];
        for (const t of i) {
            const i = Op.zti(t)
              , n = e.get(Op.IW(t));
            Dp(void 0 !== n, "cannot find folder handle"),
            s.push((async () => {
                try {
                    await n.removeEntry(i, {
                        recursive: !1
                    })
                } catch (t) {
                    if ("NotFoundError" !== t.name)
                        throw t
                }
            }
            )())
        }
        return Promise.all(s)
    }
    ,
    Op.y7.Dvi = async function(t, i) {
        Op.U(t, FileSystemDirectoryHandle);
        for (let e of i) {
            (e.endsWith("\\") || e.endsWith("/")) && (e = e.substr(0, e.length - 1));
            const i = Op.zti(e)
              , s = Op.IW(e)
              , n = await Op.y7.Pvi(t, s, !1);
            try {
                await n.removeEntry(i, {
                    recursive: !1
                })
            } catch (t) {
                if ("NotFoundError" !== t.name)
                    throw t
            }
        }
    }
    ,
    Op.y7.Fvi = async function(t, i) {
        Op.U(t, FileSystemDirectoryHandle),
        Op.zt(i),
        i = i.toLowerCase();
        for await(const e of t.values())
            if ("file" === e.kind && e.name.toLowerCase().endsWith(i))
                return e;
        return null
    }
    ,
    Op.y7.Lvi = async function(t, i) {
        Op.U(t, FileSystemDirectoryHandle),
        Op.zt(i);
        try {
            return !!await Op.y7.Gvi(t, i)
        } catch (t) {
            return !1
        }
    }
    ,
    Op.y7.nhi = async function(t, i) {
        Op.U(t, FileSystemDirectoryHandle),
        Op.zt(i);
        const e = await Op.y7.Gvi(t, i);
        if (e)
            return await e.getFile()
    }
}
{
    const $p = self.t;
    $p.p.MW("lib/ui/lang");
    const zp = ["fr", "px", "mm", "cm", "in", "pt", "pc", "vh", "vw", "vmin", "vmax", "em", "ex", "ch", "rem"]
      , Vp = ["auto", "top", "bottom", "options"];
    let Wp = !1
      , Hp = null
      , Kp = window.innerWidth
      , qp = window.innerHeight;
    window.addEventListener("resize", () => {
        Kp = window.innerWidth,
        qp = window.innerHeight,
        document.scrollingElement.scrollTop = 0,
        setTimeout( () => {
            Kp = window.innerWidth,
            qp = window.innerHeight,
            document.scrollingElement.scrollTop = 0;
            const t = new CustomEvent("after-resize",{
                bubbles: !0,
                cancelable: !0,
                detail: {}
            });
            window.dispatchEvent(t)
        }
        , 250)
    }
    , !0);
    let Xp = NaN
      , Yp = NaN
      , Jp = NaN;
    if ($p.Qs = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static Bvi() {
            return Wp
        }
        static Aui(t) {
            (t = !!t) !== Wp && (Wp = t,
            document.getElementsByTagName("body")[0].dir = t ? "rtl" : "ltr")
        }
        static UO(t) {
            $p.mGt(t),
            t && t.parentElement && t.parentElement.removeChild(t)
        }
        static Uvi(t) {
            $p.zt(t),
            $p.Qs.UO(document.getElementById(t))
        }
        static Nvi(t) {
            $p.zt(t);
            let i = document.querySelectorAll(t);
            for (let t = 0, e = i.length; t < e; ++t)
                $p.Qs.UO(i[t])
        }
        static W_(t, i, e, s, n, r) {
            $p.zt(t),
            $p.mGt(i),
            $p.gL(e),
            $p.kQ(n),
            $p.iM(r);
            let h = document;
            i && (h = i.ownerDocument);
            let o = h.createElement(t);
            if (e && (o.id = e),
            s && (o.className = s),
            n)
                for (let[t,i] of Object.entries(n))
                    "string" == typeof i ? o.setAttribute(t, i) : o.setAttribute(t, "");
            return i ? ($p.Qs.xgt(o, i, r),
            o) : o
        }
        static xgt(t, i, e) {
            if ($p.ibt(t),
            $p.ibt(i),
            $p.iM(e),
            $p.ub(e)) {
                const s = i.children;
                s.length > 0 ? e <= 0 ? i.insertBefore(t, s[0]) : e > 0 && e < s.length ? i.insertBefore(t, s[e]) : i.appendChild(t) : i.appendChild(t)
            } else
                i.appendChild(t)
        }
        static L6(t) {
            $p.mGt(t),
            t && (t.replaceChildren ? t.replaceChildren() : t.innerHTML = "")
        }
        static jvi(t) {
            $p.ibt(t),
            t.offsetHeight
        }
        static eit(t, i, e) {
            $p.ibt(t),
            $p.zt(i),
            e ? t.setAttribute(i, "") : t.removeAttribute(i)
        }
        static $vi(t, i) {
            $p.ibt(t),
            $p.zt(i),
            $p.Qs.eit(t, i, !t.hasAttribute(i))
        }
        static zvi(t) {
            Hp = t
        }
        static Vvi() {
            return Hp
        }
        static Wvi(t) {
            return t === Hp
        }
        static Hvi() {
            return Kp
        }
        static Kvi() {
            return qp
        }
        static qvi() {
            let t = $p.Qs.Vvi();
            t && t.Xvi(),
            $p.Qs._O.Yvi(!0)
        }
        static Jvi(t) {
            $p.zt(t);
            let i = parseFloat(t);
            if (i < 0)
                return !1;
            if (0 === i)
                return !0;
            let e = t.toLowerCase();
            for (let t = 0, i = zp.length; t < i; ++t)
                if (e.endsWith(zp[t]))
                    return !0;
            return !1
        }
        static x5(t, i, e="auto", s={}) {
            if ($p.ibt(t),
            $p.mGt(i),
            $p.zt(e),
            $p.ML(s),
            !Vp.includes(e))
                throw new Error(`"${e}" is not a supported value. Use any of: ${Vp.toString()}`);
            i || (i = $p.xii(t));
            const n = t.getBoundingClientRect()
              , r = i.getBoundingClientRect();
            switch (e) {
            case "auto":
                n.top < r.top ? (t.scrollIntoView(!0),
                i.scrollTop -= 5) : n.bottom > r.bottom && (t.scrollIntoView(!1),
                i.scrollTop += 5);
                break;
            case "top":
                t.scrollIntoView(!0),
                i.scrollTop -= 5;
                break;
            case "bottom":
                t.scrollIntoView(!1),
                i.scrollTop += 5;
                break;
            case "options":
                t.scrollIntoView(s)
            }
        }
        static pW(t, i) {
            if ($p.kQ(i),
            i || (i = {}),
            !$p.K9(t) && !$p.B9(t))
                throw new Error("unexpected argument");
            let e = i.parent || document.body
              , s = i.tag || "div"
              , n = i.wW || null
              , r = i.Zvi
              , h = i.className
              , o = i.id
              , a = !1;
            n || (n = document.createElement(s),
            a = !0),
            r && n.setAttribute(r, ""),
            h && (n.className = h),
            o && (n.id = o),
            a && e.appendChild(n);
            let l, u = window.getComputedStyle(n);
            if ($p.K9(t))
                l = u.getPropertyValue(t);
            else if ($p.B9(t))
                for (let i of t)
                    if (l = u.getPropertyValue(i),
                    l)
                        break;
            return a && e.removeChild(n),
            l
        }
        static vwe() {
            if (isNaN(Xp)) {
                let t = $p.Qs.pW("width", {
                    className: "width100em"
                });
                if (!t.endsWith("px"))
                    throw new Error("expected em size in px");
                Xp = parseFloat(t) / 100
            }
            return Xp
        }
        static f7t() {
            if (isNaN(Yp)) {
                const t = $p.Qs.pW("--window-border-size");
                if (!t.endsWith("px"))
                    throw new Error("--window-border-size must specify size in units of 'px'");
                Yp = parseFloat(t) || 7
            }
            return Yp
        }
        static Qvi() {
            if (isNaN(Jp)) {
                let t = $p.Qs.pW("--window-thin-border-size");
                if (!t.endsWith("px"))
                    throw new Error("--window-border-size must specify size in units of 'px'");
                Jp = parseFloat(t) || 1
            }
            return Jp
        }
        static tSi() {
            return $p.Qs.f7t()
        }
        static Pdt(t) {
            t.preventDefault()
        }
        static DVt(t) {
            t.stopPropagation()
        }
        static gdt(t) {
            t.preventDefault(),
            t.stopPropagation()
        }
        static nk(t, i, e, s) {
            return $p.Ge(t),
            $p.Ge(i),
            $p.Ef(e, $p.Qs.g_.SQ),
            e && !s && (s = e.LO()),
            $p.Qs.EA.iSi(t, i, s) || $p.Qs.mk.iSi(t, i, s) || $p.Qs._O.eSi(t, i, e)
        }
        static sSi() {
            const t = document.body.parentElement;
            if (t.removeAttribute("mobile"),
            t.removeAttribute("desktop"),
            $p.kt && $p.kt.Y_ ? t.setAttribute("mobile", "") : t.setAttribute("desktop", ""),
            $p.kt.T9t) {
                const t = document.createElement("link");
                t.rel = "stylesheet",
                t.href = "loader/iosOnlyStyles.css",
                document.head.appendChild(t)
            }
        }
        static nSi() {
            return "function" == typeof window.getScreenDetails
        }
        static async rSi() {
            if ($p.Qs.nSi())
                try {
                    await window.getScreenDetails()
                } catch (t) {
                    (() => {})("Failed to get window management permission: ", t)
                }
        }
    }
    ,
    "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", $p.Qs.sSi) : ($p.Qs.sSi(),
    CSS.supports("contain", "content") || document.body.parentElement.setAttribute("no-containment", "")),
    !$p.$M) {
        let Zp = new Set(["input", "textarea", "datalist"]);
        document.addEventListener("contextmenu", t => {
            let i = t.target
              , e = i.tagName.toLowerCase();
            Zp.has(e) || $p.aMt(i) || t.preventDefault()
        }
        ),
        document.addEventListener("mousewheel", t => {
            ($p.bk.$F(t) || t.ctrlKey) && t.preventDefault()
        }
        , {
            passive: !1
        }),
        document.addEventListener("wheel", t => {
            ($p.bk.$F(t) || t.ctrlKey) && t.preventDefault()
        }
        , {
            passive: !1
        })
    }
}
{
    const Qp = self.t
      , tm = new WeakMap;
    function im(t) {
        let i = tm.get(t);
        return i || (i = Qp.v(Qp.Qs.sk.Document, t),
        tm.set(t, i)),
        i
    }
    class em {
        constructor() {
            throw new Error("static class")
        }
        static u(t, i) {
            Qp.cti(t, "#document"),
            Qp.Ef(i, Qp.Qs.Ks),
            im(t).u(i)
        }
        static j(t) {
            im(t).j()
        }
        static E3t(t, i, e) {
            return im(t).hSi().E3t(i, e)
        }
        static ik(t, i, e, s, n) {
            return im(i).hSi().oSi(t, e, s, n)
        }
        static hk(t) {
            Qp.Ef(t, Qp.Qs.sk.aSi),
            t && t.rot().lSi(t)
        }
        static f4t(t) {
            const i = im(t);
            return [i.TF(), i.kF()]
        }
    }
    Qp.Qs.sk = em
}
{
    const sm = self.t;
    class nm {
        constructor(t) {
            sm.cti(t, "#document"),
            this.uSi = t,
            this.cSi = [],
            this.IX = 0,
            this.MX = 0,
            this.uSi.addEventListener("pointermove", t => {
                this.IX = t.clientX,
                this.MX = t.clientY
            }
            , !0),
            this.u()
        }
        FO() {
            return this.uSi
        }
        hSi() {
            return this.cSi.at(-1)
        }
        TF() {
            return this.IX
        }
        kF() {
            return this.MX
        }
        u(t) {
            this.cSi.length > 0 && this.cSi.at(-1).dSi(),
            this.cSi.push(sm.v(sm.Qs.sk.Mme, this, t))
        }
        j() {
            if (this.cSi.length <= 1)
                throw new Error("cannot pop last context");
            this.cSi.pop().he(),
            this.cSi.at(-1).wgi()
        }
    }
    sm.Qs.sk.Document = nm
}
{
    const rm = self.t
      , hm = 128
      , om = "default"
      , am = new Map([["progress", "cursorBackgroundWait"], ["wait", "cursorWait"], ["crosshair", "cursorCrosshair"], ["move", "cursorMove"], ["not-allowed", "cursorNotAllowed"], ["col-resize", "cursorResizeCol"], ["row-resize", "cursorResizeRow"], ["ns-resize", "cursorResizeNS"], ["ew-resize", "cursorResizeEW"], ["nwse-resize", "cursorResizeNWSE"], ["nesw-resize", "cursorResizeNESW"], ["grab", "cursorGrab"], ["grabbing", "cursorGrabbing"], ["rotate-topleft", "cursorRotateTL"], ["rotate-top", "cursorRotateTop"], ["rotate-topright", "cursorRotateTR"], ["rotate-right", "cursorRotateRight"], ["rotate-bottomright", "cursorRotateBR"], ["rotate-bottom", "cursorRotateBottom"], ["rotate-bottomleft", "cursorRotateBL"], ["rotate-left", "cursorRotateLeft"], ["pointer", "cursorPointer"]]);
    class lm {
        constructor(t, i) {
            rm.U(t, rm.Qs.sk.Document),
            this.fSi = t,
            this.nbt = i,
            this.pSi = i ? i.k_() : t.FO().body,
            this.Fc = !0,
            this.mSi = [],
            this.wSi = null,
            this.gSi = "",
            this.ySi = t => {
                this.bSi(t.clientX - hm / 2, t.clientY - hm / 2)
            }
            ,
            this.wSi = rm.Qs.W_("div", this.pSi, null, "docCursorOverlayElem"),
            this.vSi()
        }
        he() {
            this.Fc && this.dSi(),
            rm.Io(this.mSi),
            rm.Qs.UO(this.wSi),
            this.wSi = null,
            this.ySi = null,
            this.pSi = null,
            this.fSi = null
        }
        FO() {
            return this.fSi.FO()
        }
        LO() {
            return this.FO().defaultView
        }
        SSi() {
            return this.wSi
        }
        xSi() {
            return this.gSi
        }
        MSi(t) {
            rm.zt(t),
            this.gSi = t
        }
        bSi(t, i) {
            rm.Ge(t),
            rm.Ge(i);
            let e = 0
              , s = 0;
            this.nbt && (e = this.nbt.ESi(),
            s = this.nbt.CSi()),
            this.wSi.style.transform = `translate(${t - e}px,${i - s}px)`
        }
        vSi() {
            this.bSi(2 * -hm, 2 * -hm)
        }
        wgi() {
            if (this.Fc)
                throw new Error("already active");
            const t = this.mSi;
            t.length > 0 && (this.LO().addEventListener("pointermove", this.ySi, !0),
            t.at(-1)._Si()),
            this.Fc = !0
        }
        dSi() {
            if (!this.Fc)
                throw new Error("already inactive");
            const t = this.mSi;
            t.length > 0 && (t.at(-1).Lw(),
            this.LO().removeEventListener("pointermove", this.ySi, !0),
            this.vSi()),
            this.Fc = !1
        }
        TSi(t) {
            rm.U(t, rm.Qs.sk.aSi);
            const i = this.mSi
              , e = i.length;
            return e > 0 && i[e - 1] === t
        }
        oSi(t, i, e, s) {
            if (rm.zt(t),
            t !== om && !am.has(t))
                throw new RangeError(`invalid mouse cursor name '${t}'`);
            rm.ub(i) && rm.ub(e) || (i = this.fSi.TF(),
            e = this.fSi.kF());
            const n = this.mSi;
            if (n.length >= 100)
                throw new Error("pushed too many mouse cursors");
            const r = rm.v(rm.Qs.sk.aSi, this, t, s);
            return this.Fc && (0 === n.length ? this.LO().addEventListener("pointermove", this.ySi, !0) : n.at(-1).Lw(),
            r._Si(),
            this.bSi(i - hm / 2, e - hm / 2)),
            n.push(r),
            r
        }
        lSi(t) {
            if (rm.Ef(t, rm.Qs.sk.aSi),
            !t)
                return;
            if (t.rot() !== this)
                throw new Error("popping cursor in wrong context");
            const i = this.mSi
              , e = i.indexOf(t);
            if (e < 0)
                return;
            const s = e === i.length - 1;
            i.splice(e, 1),
            t.he(),
            this.Fc && (0 === i.length ? (this.LO().removeEventListener("pointermove", this.ySi, !0),
            this.vSi()) : s && i.at(-1)._Si())
        }
        E3t(t, i) {
            rm.Ge(t),
            rm.Ge(i);
            const e = this.FO()
              , s = rm.Nft(e, t, i);
            return s.length > 0 && s[0] === this.wSi && s.shift(),
            s.length > 0 ? s[0] : null
        }
        static ISi() {
            return om
        }
        static PSi() {
            return am
        }
    }
    rm.Qs.sk.Mme = lm
}
{
    const um = self.t;
    class cm {
        constructor(t, i, e) {
            um.U(t, um.Qs.sk.Mme),
            um.zt(i),
            um.kQ(e),
            this.Ght = t,
            this.GSi = i,
            this.bht = e,
            this.ASi = null
        }
        rot() {
            return this.Ght
        }
        FO() {
            return this.rot().FO()
        }
        SSi() {
            return this.rot().SSi()
        }
        xSi() {
            return this.Ght.xSi()
        }
        MSi(t) {
            this.Ght.MSi(t)
        }
        Set(t) {
            um.zt(t),
            this.GSi !== t && (this.GSi = t,
            this.Ght.TSi(this) && this.RSi())
        }
        _Si() {
            this.RSi(),
            this.kSi()
        }
        Lw() {
            this.J6(),
            this.OSi()
        }
        RSi() {
            if (this.GSi === um.Qs.sk.Mme.ISi())
                return void this.J6();
            const t = um.Qs.sk.Mme.PSi().get(this.GSi);
            self.assert(t, "invalid cursor class"),
            this.xSi() !== t && (this.J6(),
            this.SSi().classList.add(t),
            this.MSi(t))
        }
        J6() {
            const t = this.xSi();
            t && this.SSi().classList.remove(t),
            this.MSi("")
        }
        kSi() {
            const t = this.SSi()
              , i = this.bht;
            if (!i)
                return;
            const e = i.A5t;
            e ? (this.ASi = t => um.FSt(t, e),
            t.addEventListener("pointerdown", this.ASi),
            t.addEventListener("mousewheel", this.ASi, {
                passive: !1
            })) : (i.onpointerdown && t.addEventListener("pointerdown", i.onpointerdown),
            i.onpointermove && t.addEventListener("pointermove", i.onpointermove),
            i.onpointerup && t.addEventListener("pointerup", i.onpointerup),
            i.onpointercancel && t.addEventListener("pointercancel", i.onpointercancel),
            i.onwheel && t.addEventListener("wheel", i.onwheel),
            i.contextmenu && t.addEventListener("contextmenu", i.contextmenu))
        }
        OSi() {
            const t = this.SSi()
              , i = this.bht;
            this.ASi ? (t.removeEventListener("pointerdown", this.ASi),
            t.removeEventListener("mousewheel", this.ASi, {
                passive: !1
            }),
            this.ASi = null) : i && (i.onpointerdown && t.removeEventListener("pointerdown", i.onpointerdown),
            i.onpointermove && t.removeEventListener("pointermove", i.onpointermove),
            i.onpointerup && t.removeEventListener("pointerup", i.onpointerup),
            i.onpointercancel && t.removeEventListener("pointercancel", i.onpointercancel),
            i.onwheel && t.removeEventListener("wheel", i.onwheel),
            i.contextmenu && t.removeEventListener("contextmenu", i.contextmenu))
        }
        he() {
            this.Lw(),
            this.Ght = null,
            this.bht = null
        }
    }
    um.Qs.sk.aSi = cm
}
{
    const dm = self.t;
    let fm = ""
      , pm = !1
      , mm = null
      , wm = null;
    const gm = new Map;
    dm.Qs.wP = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static yrt(t) {
            dm.zt(t);
            const i = `theme/${t}/import.html`;
            return window.addImport(i, !0).then(t => {
                if (pm)
                    throw new Error("can't change theme at runtime yet");
                fm = dm.IW(t.URL),
                pm = !0
            }
            )
        }
        static JOt() {
            if (!pm)
                throw new Error("theme not loaded yet");
            return fm
        }
        static DSi() {
            if (!pm)
                throw new Error("theme not loaded yet");
            return fm + "icons/"
        }
        static FSi() {
            return wm ? Promise.resolve(wm) : mm || (mm = dm.O4(dm.Qs.wP.DSi() + "precompiled-icons.json").then(t => (wm = t,
            mm = null,
            wm)),
            mm)
        }
        static LSi() {
            return dm.Qs.wP.pP("--default-icon-color")
        }
        static pP(t, i) {
            dm.zt(t),
            dm.mGt(i);
            let e = gm.get(t);
            return e || (e = dm.Qs.pW(t, i ? {
                wW: i
            } : null),
            gm.set(t, e),
            e)
        }
        static async BSi() {
            const t = [];
            for (const i of self.app.USi())
                t.push(i.NSi());
            await Promise.all(t)
        }
        static jSi() {
            gm.clear(),
            dm.Qs.wP.BSi()
        }
        static Ibi() {
            return "dark" === dm.Qs.wP.pP("--c3logo-type").trim()
        }
    }
}
{
    const ym = self.t
      , bm = self.assert
      , vm = new Map
      , Sm = "PersistantMap"
      , xm = localforage.foi({
        name: Sm
    });
    function Mm() {
        Am || xm.setItem(Tm, [...Cm]).catch(t => self.app._we(t))
    }
    function Em() {
        Rm || xm.setItem(Im, [..._m]).catch(t => self.app._we(t))
    }
    let Cm = new Map
      , _m = new Map;
    const Tm = "UI_STATE"
      , Im = "UI_USERDATA"
      , Pm = ym.v(ym.ZG, Mm, 1e3)
      , Gm = ym.v(ym.ZG, Em, 1e3);
    let Am = !1
      , Rm = !1;
    async function km() {
        try {
            const t = await Promise.all([xm.getItem(Tm), xm.getItem(Im)]);
            Cm = new Map(t[0]),
            _m = new Map(t[1])
        } catch (t) {
            Cm = new Map,
            _m = new Map,
            console.error("[Construct] Error loading persistance data: ", t)
        }
    }
    ym.S9t.y9t("default-layout") || ym.X8t(km());
    let Om = -1
      , Dm = null;
    ym.Qs.Window = class extends ym.Event.v_ {
        constructor(t, i) {
            ym.ibt(t),
            ym.gL(i),
            super(),
            this.ght = t,
            this.ght.addEventListener("focusin", t => {
                this.tc() && (t.stopPropagation(),
                -1 !== Om && window.clearTimeout(Om),
                Dm = this,
                Om = window.setTimeout( () => {
                    Om = -1,
                    Dm = null,
                    ym.Qs.TO.Pz(this)
                }
                , 50))
            }
            ),
            this.Ftt = i || "",
            this.$Si = null,
            this.zSi = !1,
            this.VSi = -1,
            this.WSi = null,
            this.HSi = !1,
            this.EY = 0,
            this.DY = 0,
            this.KSi = 0,
            this.qSi = 0,
            this.XSi = "",
            this.YZ = 0,
            this.ZZ = 0,
            this.$Z = 0,
            this.JZ = 0,
            this.YSi = !1,
            ym.Qs.TO.JSi(this)
        }
        ZSi() {
            Dm === this && (window.clearTimeout(Om),
            Om = -1,
            Dm = null)
        }
        Lw() {
            bm(!this.YSi, "window already removed"),
            this.ZSi(),
            ym.Qs.TO.xO(this),
            ym.Qs.UO(this.ght),
            this.ght = null,
            this.YSi = !0,
            this.$Si && vm.delete(this.$Si),
            this.$Si = null,
            super.he()
        }
        QSi() {
            return this.YSi
        }
        k_() {
            return bm(!this.YSi, "using removed window"),
            this.ght
        }
        FO() {
            return this.ght.ownerDocument
        }
        LO() {
            const t = this.FO();
            return t ? t.defaultView : null
        }
        La() {
            return this.Ftt
        }
        I(t) {
            ym.zt(t),
            this.Ftt = t
        }
        txi(t) {
            if (ym.zt(t),
            vm.has(t))
                throw new Error("Identifier already in use");
            vm.set(t, this),
            this.$Si = t
        }
        ixi() {
            return this.$Si
        }
        exi(t) {
            _m.set(this.$Si, t),
            Gm.FE()
        }
        sxi() {
            _m.clear(),
            Em(),
            Rm = !0
        }
        nxi() {
            return _m.get(this.$Si)
        }
        rxi() {
            return _m.has(this.$Si)
        }
        hxi(t) {
            Cm.set(this.$Si, t),
            Pm.FE()
        }
        oxi() {
            Cm.clear(),
            Mm(),
            Am = !0
        }
        Kmt() {
            return Cm.get(this.$Si)
        }
        axi() {
            return Cm.has(this.$Si)
        }
        lxi() {
            throw new Error("derived class must override")
        }
        mP() {
            this.lxi() && ym.Qs.TO.mP(this)
        }
        uxi(t) {
            ym.Ge(t);
            let i = this.k_();
            i.style.zIndex = t < 0 ? "" : t,
            this.VSi = t
        }
        cxi() {
            return this.VSi
        }
        static BD(t, i) {
            return t.cxi() - i.cxi()
        }
        XO() {
            ym.kK()
        }
        tc() {
            return !0
        }
        LQ() {
            return this.zSi
        }
        dxi(t) {
            t = !!t,
            this.zSi !== t && (this.zSi = t,
            ym.Qs.eit(this.ght, "active", this.zSi))
        }
        _0() {
            this.WSi = null
        }
        fxi() {
            this.WSi = this.k_().getBoundingClientRect()
        }
        KWt() {
            return bm(!this.YSi, "using removed window"),
            this.WSi || this.fxi(),
            this.WSi
        }
        gz(t, i) {
            ym.Ge(t),
            ym.Ge(i);
            let e = this.KWt();
            return t >= e.left && t < e.right && i >= e.top && i < e.bottom
        }
        pxi() {
            return this
        }
        wG(t) {
            let i = new ym.Event("keydown",!0);
            i.which = t.which,
            i.altKey = t.altKey,
            i.ctrlKey = t.ctrlKey,
            i.shiftKey = t.shiftKey,
            i.metaKey = t.metaKey,
            this.dispatchEvent(i) || t.preventDefault()
        }
        yG(t) {
            let i = new ym.Event("keyup",!0);
            i.which = t.which,
            i.altKey = t.altKey,
            i.ctrlKey = t.ctrlKey,
            i.shiftKey = t.shiftKey,
            i.metaKey = t.metaKey,
            this.dispatchEvent(i) || t.preventDefault()
        }
        $ft(t) {
            let i = new ym.Event("keypress",!0);
            i.which = t.which,
            i.altKey = t.altKey,
            i.ctrlKey = t.ctrlKey,
            i.shiftKey = t.shiftKey,
            i.metaKey = t.metaKey,
            i.key = t.key,
            this.dispatchEvent(i) || t.preventDefault()
        }
        cO(t) {
            let i = new ym.Event("cut",!0);
            i.clipboardData = t.clipboardData,
            this.dispatchEvent(i) || t.preventDefault()
        }
        fO(t) {
            let i = new ym.Event("copy",!0);
            i.clipboardData = t.clipboardData,
            this.dispatchEvent(i) || t.preventDefault()
        }
        uO(t) {
            let i = new ym.Event("paste",!0);
            i.clipboardData = t.clipboardData,
            i.wL = t.wL,
            this.dispatchEvent(i) || t.preventDefault()
        }
        aO(t) {
            let i = new ym.Event("keyboardshortcut",!0);
            return i.label = t,
            this.dispatchEvent(i),
            i.defaultPrevented
        }
        mxi(t, i) {
            ym.Ge(t),
            ym.Ge(i),
            this.EY = t,
            this.DY = i
        }
        wxi() {
            return this.EY
        }
        gxi() {
            return this.DY
        }
        yxi(t, i) {
            ym.Ge(t),
            ym.Ge(i),
            this.KSi = t,
            this.qSi = i
        }
        bxi() {
            return this.KSi
        }
        vxi() {
            return this.qSi
        }
        Sxi(t) {
            this.XSi = t
        }
        xxi() {
            return this.XSi
        }
        Mxi(t, i) {
            ym.Ge(t),
            ym.Ge(i),
            this.YZ = t,
            this.ZZ = i
        }
        Exi() {
            return this.YZ
        }
        Cxi() {
            return this.ZZ
        }
        _xi(t, i) {
            ym.Ge(t),
            ym.Ge(i),
            this.$Z = t,
            this.JZ = i
        }
        Txi() {
            return this.$Z
        }
        Ixi() {
            return this.JZ
        }
        T_(t) {
            this.HSi = !!t
        }
        Pxi() {
            return !self.app.mdt() && this.HSi
        }
        yk() {
            return !1
        }
    }
}
{
    const Fm = self.t
      , Lm = self.assert;
    let Bm = []
      , Um = null
      , Nm = null;
    const jm = []
      , $m = 8;
    function zm(t) {
        t && (Vm(t),
        jm.push(t),
        jm.length > $m && jm.shift())
    }
    function Vm(t) {
        Fm.sii(jm, t)
    }
    let Wm = 0
      , Hm = ""
      , Km = -1;
    const qm = 1e3;
    function Xm() {
        Hm = "",
        Km = -1
    }
    function Ym(t) {
        t.document.addEventListener("pointerdown", i => {
            Fm.ev() && Fm.Qs.TO.Gxi() && Fm.Qs.TO.Axi(t, i.clientX, i.clientY, i.pointerId, i.button) && (i.preventDefault(),
            i.stopPropagation())
        }
        ),
        t.document.addEventListener("keydown", t => {
            Fm.Qs.TO.wG(t)
        }
        ),
        t.document.addEventListener("keypress", t => {
            Fm.Qs.TO.$ft(t)
        }
        ),
        t.document.addEventListener("keyup", t => {
            Fm.Qs.TO.yG(t)
        }
        ),
        t.document.addEventListener("cut", t => {
            Fm.Qs.TO.cO(t)
        }
        ),
        t.document.addEventListener("copy", t => {
            Fm.Qs.TO.fO(t)
        }
        ),
        t.document.addEventListener("paste", t => {
            Fm.Qs.TO.uO(t)
        }
        ),
        t.addEventListener("blur", t => {
            Nm = Um,
            Fm.Qs.TO.Pz(null)
        }
        ),
        t.addEventListener("focus", t => {
            !Um && Nm && Fm.Qs.TO.Pz(Nm),
            Nm = null
        }
        )
    }
    window.C3_IsPopupWindow || Ym(window);
    class Jm extends Fm.Event.v_ {
        constructor() {
            super()
        }
        w0(t) {
            Fm.ibt(t);
            for (const i of Bm)
                if (i.k_() === t)
                    return i;
            return null
        }
        JSi(t) {
            Fm.U(t, Fm.Qs.Window),
            Bm.push(t)
        }
        xO(t) {
            Fm.U(t, Fm.Qs.Window),
            this.Rxi(t),
            Nm === t && (Nm = null);
            let i = Bm.indexOf(t);
            Lm(i >= 0, "cannot find window"),
            Bm.splice(i, 1),
            this.kxi()
        }
        *g0(t) {
            for (let i = Bm.length - 1; i >= 0; --i) {
                const e = Bm[i];
                t && e.LO() !== t || (yield e)
            }
        }
        *Cii(t) {
            for (let i of Bm)
                t && i.LO() !== t || (yield i)
        }
        Axi(t, i, e, s, n) {
            Fm.Ge(i),
            Fm.Ge(e),
            Fm.Ge(s);
            let r = Fm.Qs.mk.Oxi();
            if (r && r.kP()) {
                for (let t of r.Dxi())
                    if (t.gz(i, e))
                        return this.Pz(t.pxi()),
                        !1;
                if (r.gz(i, e))
                    return this.Pz(r.pxi()),
                    !1
            } else
                for (let s of this.g0(t))
                    if (s.gz(i, e) && (!r || s === r) && (!(s instanceof Fm.Qs.Ks) || !s.Fxi()))
                        return this.Pz(s.pxi()),
                        !1
        }
        mP(t) {
            Fm.U(t, Fm.Qs.Window);
            let i = Bm.indexOf(t);
            i < 0 || (Bm.splice(i, 1),
            Bm.push(t),
            this.kxi())
        }
        kxi() {
            let t = [];
            for (let i of Bm)
                i.lxi() || (i.uxi(-1),
                t.push(i));
            let i = Fm.QL.R9t ? 1 : 100;
            for (let e of Bm)
                e.lxi() && (e.uxi(i++),
                t.push(e));
            if (!Fm.Zie(t, Bm)) {
                Fm.mf(Bm, t);
                let i = new Fm.Event("zindexchanged");
                this.dispatchEvent(i)
            }
        }
        Lxi(t) {
            return t instanceof Fm.Qs.Ks && t.Bxi()
        }
        Pz(t, i) {
            if (Fm.Ef(t, Fm.Qs.Window),
            Um === t)
                return;
            const e = Fm.Qs.mk.Oxi();
            if (e && e.tc() && e !== t && !e.EH().includes(t) && !this.Lxi(t))
                return;
            Hm = "",
            -1 !== Km && (window.clearTimeout(Km),
            Km = -1),
            Um && Um.dxi(!1),
            Um = t,
            Um && (i || this.mP(Um),
            Um.dxi(!0)),
            zm(t);
            let s = new Fm.Event("activewindowchange");
            this.dispatchEvent(s)
        }
        QU() {
            return Um
        }
        wG(t) {
            t.which === Fm.Mk.VJ && Fm.Qs.mk.Uxi() ? t.preventDefault() : Um && Um.wG(t)
        }
        yG(t) {
            Um && Um.yG(t)
        }
        $ft(t) {
            if (!t.key || !Um)
                return;
            const i = Um.k_().ownerDocument;
            if (Um && Um.$ft(t),
            Fm.ddt(i))
                return;
            Hm += t.key,
            -1 !== Km && window.clearTimeout(Km),
            Km = window.setTimeout(Xm, qm);
            const e = new Fm.Event("searchinput");
            e.Nxi = Hm,
            Um.dispatchEvent(e)
        }
        cO(t) {
            self.app.QHt() || Um && Um.cO(t)
        }
        fO(t) {
            self.app.QHt() || Um && Um.fO(t)
        }
        uO(t) {
            self.app.QHt() || Um && Um.uO(t)
        }
        Rxi(t) {
            if (Fm.U(t, Fm.Qs.Window),
            Vm(t),
            t === Um) {
                for (let t = jm.length - 1; t >= 0; --t) {
                    const i = jm[t];
                    if (i.tc() && i.XO() && !i.yk())
                        return void this.Pz(i, !0)
                }
                for (let i = Bm.length - 1; i >= 0; --i) {
                    const e = Bm[i];
                    if (e !== t && e.tc() && e.XO() && !e.yk())
                        return void this.Pz(e, !0)
                }
                this.Pz(null)
            }
        }
        iSi(t, i, e, s) {
            Fm.Ge(t),
            Fm.Ge(i),
            Fm.Ef(e, Fm.Qs.Window);
            let n = Fm.Qs.mk.Oxi();
            if (n && n.kP()) {
                for (let s of n.Dxi())
                    if (s !== e && s.gz(t, i))
                        return !0;
                if (n === e)
                    return !1;
                if (n.gz(t, i))
                    return !0
            } else
                for (let n of this.g0(s))
                    if (n !== e && n.gz(t, i))
                        return !0;
            return !1
        }
        jxi(t, i, e, s) {
            Fm.Ge(t),
            Fm.Ge(i),
            Fm.U(e, Fm.Qs.Window);
            let n = Fm.Qs.mk.Oxi();
            if (n && n.kP()) {
                for (let s of n.Dxi()) {
                    if (s === e)
                        return !1;
                    if (s.gz(t, i))
                        return !0
                }
                if (n === e)
                    return !1;
                if (n.gz(t, i))
                    return !0
            } else
                for (let n of this.g0(s)) {
                    if (n === e)
                        return !1;
                    if (n.gz(t, i))
                        return !0
                }
            throw new Error("couldn't find window")
        }
        $xi(t) {
            t ? --Wm : ++Wm,
            Lm(Wm >= 0, "disabled window sizing too many times")
        }
        Gxi() {
            return 0 === Wm
        }
    }
    Fm.Qs.TO = Fm.v(Jm)
}
{
    const Zm = self.t;
    !!window.C3_IsPopupWindow ? (window.addEventListener("cut", () => {
        window.opener.postMessage({
            type: "clipboard",
            event: "cut"
        }, location.origin)
    }
    ),
    window.addEventListener("copy", () => {
        window.opener.postMessage({
            type: "clipboard",
            event: "copy"
        }, location.origin)
    }
    ),
    window.addEventListener("paste", t => {
        window.opener.postMessage({
            type: "clipboard",
            event: "paste",
            clipboardDataString: t.clipboardData.getData("text/plain")
        }, location.origin)
    }
    )) : window.addEventListener("message", t => {
        t.origin === location.origin && Zm.Qs.zxi.qgi(t.source, t.data)
    }
    );
    let Qm = new Set
      , tw = new Map;
    const iw = {
        features: "",
        name: null,
        _Et: null,
        Vxi: !0
    };
    Zm.Qs.zxi = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static Wxi(t, i, e, s, n, r) {
            let h, o;
            Zm.zt(t),
            Zm.zt(i),
            Zm.Ge(e),
            Zm.Ge(s),
            Zm.iM(n),
            Zm.iM(r),
            h = "number" == typeof n ? n : window.screenX + window.outerWidth / 2 - e / 2,
            o = "number" == typeof r ? r : window.screenY + window.outerHeight / 2 - s / 2;
            let a = `width=${e},height=${s},left=${h},top=${o},menubar=no,toolbar=no,location=no,personalbar=no,status=no,dependent=yes,dialog=yes,resizable=yes,scrollbars=no`
              , l = window.open(t, i, a);
            return new Promise( (t, i) => {
                l ? tw.set(l, {
                    resolve: t,
                    reject: i
                }) : i()
            }
            )
        }
        static qgi(t, i) {
            if (i && "object" == typeof i && "string" == typeof i.type)
                switch (i.type) {
                case "ready":
                    Zm.Qs.zxi.Hxi(t);
                    break;
                case "popup-keyboard-shortcut":
                    Zm.Qs.zxi.Kxi(i.event);
                    break;
                case "popup-keydown":
                    Zm.Qs.zxi.qxi(i.event);
                    break;
                case "popup-keyup":
                    Zm.Qs.zxi.Xxi(i.event);
                    break;
                case "popup-keypress":
                    Zm.Qs.zxi.Yxi(i.event);
                    break;
                case "clipboard":
                    Zm.Qs.zxi.Jxi(i);
                    break;
                case "closed":
                    Zm.Qs.zxi.Zxi(t)
                }
        }
        static Hxi(t) {
            Qm.add(t);
            let i = tw.get(t);
            i || 1 !== tw.size || (i = Zm.th(tw.values())),
            i && i.resolve({
                window: t
            }),
            tw.delete(t);
            let e = [];
            const s = Zm.bme.Qxi();
            s && (e = s.tMi()),
            Zm.Qs.zxi.iMi(t, "init-settings", {
                uiEffectsEnabled: self.app.iN(),
                themeStyles: e
            }),
            Zm.Qs.mk.eMi(t)
        }
        static Zxi(t) {
            Qm.delete(t);
            let i = tw.get(t);
            i && i.reject(t),
            tw.delete(t)
        }
        static iMi(t, i, e) {
            t.postMessage({
                type: i,
                param: e
            }, location.origin)
        }
        static Kxi(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ,
            t.sMi = !1;
            const i = new Zm.Event("external-keyboard-shortcut");
            if (i.adt = t,
            self.app.dispatchEvent(i),
            !t.sMi) {
                const i = Zm.Qs.TO.QU();
                i && i.wG(t)
            }
        }
        static qxi(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ;
            const i = new Zm.Event("external-keydown");
            i.adt = t,
            self.app.dispatchEvent(i),
            window.dispatchEvent(new KeyboardEvent("external-keydown",t));
            const e = Zm.Qs.TO.QU();
            e && e.wG(t)
        }
        static Xxi(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ;
            const i = new Zm.Event("external-keyup");
            i.adt = t,
            self.app.dispatchEvent(i),
            window.dispatchEvent(new KeyboardEvent("external-keyup",t));
            const e = Zm.Qs.TO.QU();
            e && e.yG(t)
        }
        static Yxi(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ;
            const i = new Zm.Event("external-keypress");
            i.adt = t,
            self.app.dispatchEvent(i),
            window.dispatchEvent(new KeyboardEvent("external-keypress",t));
            const e = Zm.Qs.TO.QU();
            e && e.$ft(t)
        }
        static Jxi(t) {
            const i = t.event
              , e = {
                clipboardData: null,
                preventDefault() {},
                stopPropagation() {}
            }
              , s = Zm.Qs.TO.QU();
            s && ("cut" === i ? s.cO(e) : "copy" === i ? s.fO(e) : (e.wL = t.clipboardDataString,
            s.uO(e)))
        }
        static nMi(t) {
            t = !!t;
            for (let i of Qm)
                Zm.Qs.zxi.iMi(i, "show-dimmer", t)
        }
        static rMi() {
            return Qm.size > 0
        }
        static hMi(t, i) {
            Zm.zt(t),
            Zm.kQ(i),
            i = Object.assign({}, iw, i),
            Zm.zt(i.features),
            Zm.gL(i.name),
            Zm.mGt(i._Et);
            const e = !!i.Vxi;
            return self.Aii.Gii( () => {
                const s = window.open(t, i.name, i.features);
                if (s)
                    return {
                        window: s
                    };
                if (e) {
                    return Zm.Qs.Ks.qs("OpenPopupWindow").Xa(t, i)
                }
                return null
            }
            )
        }
    }
}
{
    const ew = self.t;
    let sw = new Map
      , nw = new Set
      , rw = new Set
      , hw = new Map
      , ow = new Map
      , aw = new Map
      , lw = new Map
      , uw = !1
      , cw = null;
    const dw = new Set
      , fw = new Set
      , pw = Symbol()
      , mw = Symbol()
      , ww = Symbol()
      , gw = Symbol();
    function yw(t) {
        const i = i => {
            ew.ev() && ew.Qs.mk.Axi(t, i.clientX, i.clientY, i.pointerId, i.button) && (i.preventDefault(),
            i.stopPropagation())
        }
        ;
        t.document.addEventListener("pointerdown", i),
        t.document[pw] = i;
        const e = i => {
            ew.ev() && ew.Qs.mk.oMi(t, i.clientX, i.clientY, i.pointerId) && (i.preventDefault(),
            i.stopPropagation())
        }
        ;
        t.document.addEventListener("pointermove", e),
        t.document[mw] = e;
        const s = i => {
            ew.ev() && ew.Qs.mk.aMi(t, i.clientX, i.clientY, i.screenX, i.screenY, i.pointerId) && (i.preventDefault(),
            i.stopPropagation())
        }
        ;
        t.document.addEventListener("pointerup", s),
        t.document[ww] = s;
        const n = i => {
            ew.Qs.mk.aMi(t, i.clientX, i.clientY, i.screenX, i.screenY, i.pointerId)
        }
        ;
        t.document.addEventListener("pointercancel", n),
        t.document[gw] = n
    }
    window.C3_IsPopupWindow || yw(window),
    window.addEventListener("focus", t => {
        let i = ew.Qs.mk.Oxi();
        i && ew.Qs.TO.Pz(i)
    }
    );
    let bw = null
      , vw = ew.v(ew.Event.v_);
    ew.Qs.mk = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static lMi(t, i) {
            if (ew.zt(t),
            ew.nu(i),
            sw.has(t))
                throw new Error(`dialog name '${t}' already in use`);
            sw.set(t, {
                uMi: i,
                Ls: []
            })
        }
        static cMi(t, i) {
            ew.zt(t);
            let e = sw.get(t);
            if (!e)
                throw new Error(`dialog name '${t}' not found`);
            let s = null;
            if (i) {
                for (let t of e.Ls)
                    if (!t.XO()) {
                        s = t;
                        break
                    }
            } else
                e.Ls.length && (s = e.Ls[0]);
            return s || (uw = i,
            s = ew.v(e.uMi, i),
            e.Ls.push(s),
            s.I(t),
            s.txi("DIALOG_" + t + e.Ls.length),
            s.dMi(),
            uw = !1),
            s
        }
        static fMi() {
            return uw
        }
        static pMi() {
            return !!this.Oxi()
        }
        static Oxi() {
            const t = [...rw];
            return t.length ? t.at(-1) : null
        }
        static*wdt() {
            yield*nw,
            yield*rw
        }
        static mMi(t) {
            ew.tot(t);
            const i = [...nw];
            return i.reverse(),
            t ? i.filter(t) : i
        }
        static wMi(t) {
            const i = [];
            for (const e of nw)
                t === e.FO() && i.push(e);
            return i
        }
        static gMi(t) {
            const i = [];
            for (const e of nw)
                t && t !== e.LO() || i.push(e);
            return i
        }
        static yMi(t) {
            let i = ew.Qs.mk.Oxi()
              , e = ew.Qs.mk.mMi();
            return i ? (ew.Pte(e, e => !e.bMi() || !e.dD() === i || t && e.LO() !== t),
            t && i.LO() !== t || e.push(i)) : ew.Pte(e, i => i.vMi() || t && i.LO() !== t),
            e
        }
        static SMi() {
            let t = ew.Qs.TO.QU();
            return t instanceof ew.Qs.Ks ? t : null
        }
        static eMi(t) {
            yw(t)
        }
        static xMi(t, i) {
            ew.U(t, ew.Qs.Ks),
            i ? (nw.add(t),
            t.Bxi() && (rw.add(t),
            this.MMi("showmodal", t)),
            ew.Qs.TO.Pz(t)) : (nw.delete(t),
            t.Bxi() && (rw.delete(t),
            this.MMi("hidemodal", t)))
        }
        static iSi(t, i, e) {
            ew.Ge(t),
            ew.Ge(i);
            for (const s of ew.Qs.mk.gMi(e))
                if (s.gz(t, i))
                    return !0;
            return !1
        }
        static EMi(t) {
            ew.U(t, ew.Qs.Ks);
            const i = t.ka()
              , e = t.Ra();
            for (const s of ew.Qs.mk.gMi(t.LO()))
                if (t !== s && s.ka() === i && s.Ra() === e)
                    return !0;
            return !1
        }
        static JF() {
            return nw.size > 0
        }
        static CMi(t) {
            return nw.size >= 2 || 1 === nw.size && ew.th(nw) !== t
        }
        static Uxi() {
            for (const t of nw)
                if (t.Fxi())
                    return !0;
            return !1
        }
        static wk() {
            return rw.size > 0
        }
        static _Mi() {
            return [...rw].filter(t => "Progress" !== t.La()).length > 0
        }
        static TMi(t) {
            return ew.Qs.mk.IMi(t, "dialogshow")
        }
        static PMi() {
            return Promise.all([...nw].filter(t => t.Fxi()).map(t => t.xUt()))
        }
        static GMi(t) {
            return ew.Qs.mk.IMi(t, "dialogok")
        }
        static AMi(t) {
            return ew.Qs.mk.IMi(t, "dialogcancel")
        }
        static RMi(t) {
            return ew.Qs.mk.IMi(t, "dialogclose")
        }
        static kMi() {
            return ew.Qs.mk.pMi() ? new Promise(t => {
                const i = () => {
                    ew.Qs.mk.pMi() ? self.setTimeout(i, 250) : t()
                }
                ;
                self.setTimeout(i, 250)
            }
            ) : Promise.resolve()
        }
        static IMi(t, i) {
            return ew.zt(t),
            ew.zt(i),
            new Promise(e => {
                const s = n => {
                    n.jmt.La() === t && (ew.Qs.mk.removeEventListener(i, s),
                    e(n))
                }
                ;
                ew.Qs.mk.addEventListener(i, s)
            }
            )
        }
        static OMi(t) {
            if (fw.clear(),
            !t)
                for (const t of ew.Qs.mk.wdt())
                    fw.add(t)
        }
        static DMi(t) {
            return !fw.has(t) && ew.Qs.mk.FMi(t)
        }
        static LMi(t) {
            if (dw.clear(),
            !t)
                for (const t of ew.Qs.mk.wdt())
                    dw.add(t)
        }
        static FMi(t) {
            return !dw.has(t)
        }
        static Pit(t) {
            return ew.U(t, ew.Qs.Ks),
            !!ow.get(t)
        }
        static J$(t) {
            return ew.U(t, ew.Qs.Ks),
            !!lw.get(t)
        }
        static BMi(t) {
            return ew.U(t, ew.UMi),
            cw = t,
            ew.Qs.mk.NMi()
        }
        static NMi() {
            const t = new ew.Event("load");
            return t.app = cw,
            ew.Qs.mk.iit.ufi(t)
        }
        static jMi(t, i, e, s) {
            ew.U(t, ew.Qs.Ks),
            ew.Ge(i),
            ew.Ge(e),
            ew.Ge(s),
            ow.has(t) || lw.has(t) || ew.Qs.EA.iSi(i, e, t.LO()) || (ew.Qs.mk.Axi(t.LO(), i, e, s),
            lw.has(t) || (hw.set(s, t),
            ow.set(t, s),
            t.mxi(i, e),
            t.yxi(t.ka() - i, t.Ra() - e),
            t.Amt("startdragging"),
            t.$Mi()))
        }
        static Axi(t, i, e, s, n) {
            if (ew.Ge(i),
            ew.Ge(e),
            ew.Ge(s),
            hw.has(s) || aw.has(s) || ew.Qs.EA.iSi(i, e, t))
                return !1;
            for (const r of ew.Qs.mk.yMi(t)) {
                const h = r.zMi(i, e);
                if ("m" === h)
                    return !1;
                if (h && n === ew.gF.sV) {
                    if (ow.has(r))
                        return !1;
                    if (ew.Qs.TO.jxi(i, e, r, t))
                        break;
                    return aw.set(s, r),
                    lw.set(r, s),
                    r.Amt("startresizing"),
                    r.Sxi(h),
                    r.mxi(i, e),
                    r.Mxi(r.ka(), r.Ra()),
                    r._xi(r.ns(), r.er()),
                    r.VMi(),
                    !0
                }
            }
            return !1
        }
        static oMi(t, i, e, s) {
            if (ew.Ge(i),
            ew.Ge(e),
            ew.Ge(s),
            ew.IF.Ofi(s))
                return !1;
            if (hw.has(s))
                return ew.Qs.mk.WMi(i, e, s, hw.get(s)),
                !0;
            if (aw.has(s))
                return ew.Qs.mk.HMi(i, e, s, aw.get(s)),
                !0;
            if (ew.Qs.EA.iSi(i, e, t))
                return bw && bw.Set("default"),
                !1;
            for (const s of ew.Qs.mk.yMi(t)) {
                const n = s.zMi(i, e);
                if (n) {
                    if (ew.Qs.TO.jxi(i, e, s, t))
                        break;
                    if (bw)
                        "e" === n || "w" === n ? bw.Set("ew-resize") : "n" === n || "s" === n ? bw.Set("ns-resize") : "nw" === n || "se" === n ? bw.Set("nwse-resize") : "ne" === n || "sw" === n ? bw.Set("nesw-resize") : "m" === n && (ew.Qs.sk.hk(bw),
                        bw = null);
                    else {
                        const t = s.FO()
                          , r = {
                            onpointerdown: t[pw],
                            onpointermove: t[mw],
                            onpointerup: t[ww],
                            onpointercancel: t[gw]
                        };
                        "e" === n || "w" === n ? bw = ew.Qs.sk.ik("ew-resize", t, i, e, r) : "n" === n || "s" === n ? bw = ew.Qs.sk.ik("ns-resize", t, i, e, r) : "nw" === n || "se" === n ? bw = ew.Qs.sk.ik("nwse-resize", t, i, e, r) : "ne" !== n && "sw" !== n || (bw = ew.Qs.sk.ik("nesw-resize", t, i, e, r))
                    }
                    return !!bw
                }
            }
            return ew.Qs.sk.hk(bw),
            bw = null,
            !1
        }
        static WMi(t, i, e, s) {
            ew.Ge(t),
            ew.Ge(i),
            ew.Ge(e),
            ew.U(s, ew.Qs.Ks),
            s.Fo(t + s.bxi()),
            s.Eo(i + s.vxi())
        }
        static HMi(t, i, e, s) {
            ew.Ge(t),
            ew.Ge(i),
            ew.Ge(e),
            ew.U(s, ew.Qs.Ks);
            let n = t - s.wxi()
              , r = i - s.gxi()
              , h = s.Exi()
              , o = s.Cxi()
              , a = s.Txi()
              , l = s.Ixi()
              , u = s.xxi();
            if ("e" === u || "se" === u || "ne" === u)
                s.Cb(a + n);
            else if ("w" === u || "sw" === u || "nw" === u) {
                let t = h + a - s.GSt();
                s.Fo(Math.min(h + n, t)),
                s.Cb(a - n)
            }
            if ("s" === u || "sw" === u || "se" === u)
                s.Ib(l + r);
            else if ("n" === u || "nw" === u || "ne" === u) {
                let t = o + l - s.MSt();
                s.Eo(Math.min(o + r, t)),
                s.Ib(l - r)
            }
        }
        static aMi(t, i, e, s, n, r) {
            if (ew.Ge(i),
            ew.Ge(e),
            ew.Ge(r),
            hw.has(r)) {
                let t = hw.get(r);
                if (ew.Qs.mk.WMi(i, e, r, t),
                (i < 0 || e < 0 || i > window.innerWidth || e > window.innerHeight) && t.KMi()) {
                    const i = self.devicePixelRatio;
                    t.Z5t(s / i + t.bxi(), n / i + t.vxi()).catch(i => t.qMi())
                } else
                    t.qMi();
                return hw.delete(r),
                ow.delete(t),
                t.Ymt(),
                t.Amt("finishdragging"),
                t.XMi(),
                !0
            }
            if (aw.has(r)) {
                let t = aw.get(r);
                ew.Qs.mk.HMi(i, e, r, t),
                t.qMi(),
                aw.delete(r),
                lw.delete(t),
                t.YMi(),
                t.Ymt(),
                t.Amt("finishresizing")
            }
            return !1
        }
        static MMi(t, i, e) {
            ew.zt(t),
            ew.Ef(i, ew.Qs.Ks);
            let s = new ew.Event(t);
            s.jmt = i,
            void 0 !== e && (s.JMi = e),
            this.dispatchEvent(s)
        }
        static addEventListener(t, i, e) {
            vw.addEventListener(t, i, e)
        }
        static removeEventListener(t, i, e) {
            vw.removeEventListener(t, i, e)
        }
        static dispatchEvent(t) {
            return vw.dispatchEvent(t)
        }
    }
    ,
    ew.Qs.mk.iit = ew.v(ew.Event.v_)
}
{
    const Sw = self.t
      , xw = self.assert
      , Mw = {
        duration: Sw.S9t.y9t("slow-animations") ? 3e3 : 200,
        easing: "ease-out"
    }
      , Ew = 125
      , Cw = 300
      , _w = 50
      , Tw = 200
      , Iw = 30
      , Pw = 200
      , Gw = Sw.v(Sw.o4, 1);
    let Aw = new Map;
    Sw.Qs.Ks = class extends Sw.Qs.Window {
        constructor(t) {
            if (Sw.ibt(t, "dialog"),
            Sw.Qs.mk.fMi() && (t = t.cloneNode(!0)),
            super(t),
            Aw.has(t))
                throw new Error("dialog class already created");
            Aw.set(t, this),
            this.ZMi = t.querySelector("ui-dialog-caption"),
            this.QMi = t.querySelector("ui-dialog-contents"),
            this.tEi = t.querySelector("ui-dialog-footer"),
            this.iEi = this.ght.ownerDocument,
            this.eEi = null,
            this.ght.hasAttribute("role") || this.ght.setAttribute("role", "dialog"),
            this.sEi = this.ght.hasAttribute("resizable") && !Sw.kt.Y_,
            this.nEi = !0,
            this.rEi = !1,
            this.hEi = !1,
            this.oEi = null,
            this.aEi = null,
            this.lEi = null,
            this.uEi = null,
            this.cEi = this.ght.querySelector("ui-dialog-caption"),
            this.dEi = null,
            this.lbt = !1,
            this.fEi = null,
            this.pEi = !1,
            this.mEi = !1,
            this.wEi = !1,
            this.gEi = !0,
            this.yEi = !1,
            this.bEi = "",
            this.Ec = 0,
            this.zc = 0,
            this.Fx = 0,
            this.Ex = 0,
            this.vEi = 0,
            this.SEi = 0,
            this.xEi = t => this.qMi(),
            this.mF = null,
            this.MEi = null,
            this.EEi = !0,
            this.CEi = !1,
            this._Ei = !1,
            this.TEi = null,
            this.IEi = t => this.R5t(),
            this.PEi = null,
            this.GEi = null,
            this.AEi = null,
            this.REi = null,
            this.kEi = !0,
            this.cEi && (this.bEi = this.cEi.textContent,
            Sw.Qs.L6(this.cEi),
            this.dEi = Sw.Qs.W_("span", this.cEi, null, "dialog-caption-text"),
            this.dEi.textContent = this.bEi,
            this.mF = t => {
                t.button === Sw.gF.sV && t.isPrimary && this.bVt(t.clientX, t.clientY, t.pointerId)
            }
            ,
            this.MEi = t => this.OEi(t),
            this.cEi.addEventListener("contextmenu", this.MEi),
            this.ght.hasAttribute("closebutton") && (this.PEi = Sw.v(Sw.Qs.Fk.Eq, this.cEi),
            this.PEi.onclick = () => this._et()),
            this.ght.hasAttribute("menudotsbutton") && (this.AEi = Sw.v(Sw.Qs.Fk.DEi, this.cEi)),
            this.ght.hasAttribute("backbutton") && (this.GEi = Sw.v(Sw.Qs.Fk.FEi, this.cEi),
            this.GEi.onclick = () => this.LEi())),
            this.BEi = null,
            this.UEi = -1,
            this.NEi = window.orientation,
            Sw.kt.Y_ && (this.BEi = t => this.jEi(t)),
            this.c8 = null,
            this.$Ei = [],
            this.zEi = [],
            this.VEi = 0,
            this.WEi = 0,
            this.HEi = null,
            this.KEi = null,
            this.qEi = t => this.XEi(t),
            this.YEi = t => this.JEi(t),
            this.ZEi = t => this.QEi(t),
            this.tCi = !1
        }
        dMi() {}
        axi() {
            if (super.axi()) {
                return this.Kmt().devicePixelRatio === window.devicePixelRatio
            }
            return !1
        }
        Ymt(...t) {
            if (this.Pit() || this.J$())
                return;
            if (!self.app.Mmt())
                return;
            if (this.tCi)
                return;
            if (!this.Ftt)
                return;
            if (!this.nEi)
                return;
            if (Sw.Qs.Ks.qs(this.Ftt) !== this)
                return;
            let i = this.eEi && this.eEi.defaultView
              , e = {
                popup: this.iCi(),
                nested: this.bMi(),
                width: this.Fx,
                height: this.Ex,
                resizable: this.sEi,
                devicePixelRatio: window.devicePixelRatio,
                xRatio: i && this.Ec / i.innerWidth,
                yRatio: i && this.zc / i.innerHeight,
                xParentRatio: i && this.eCi() / i.innerWidth,
                yParentRatio: i && this.sCi() / i.innerHeight
            };
            Object.assign(e, ...t),
            this.hxi(e)
        }
        kmt() {
            if (!self.app.Mmt())
                return;
            this.tCi = !0;
            let t = this.Kmt();
            if ((this._Ei || this.TEi) && (t = null),
            this.nEi && t)
                if (t.popup)
                    this.Z5t(screen.width / 2, screen.height / 2);
                else {
                    const i = this.eEi ? this.eEi.defaultView : null
                      , e = t.xRatio
                      , s = t.yRatio
                      , n = t.xParentRatio
                      , r = t.yParentRatio
                      , h = t.nested;
                    if (i && Number.isFinite(e) && Number.isFinite(s))
                        if (h && Number.isFinite(n) && Number.isFinite(r)) {
                            let t = this.eCi()
                              , h = this.sCi()
                              , o = t - n * i.innerWidth
                              , a = h - r * i.innerHeight;
                            this.nCi(e * i.innerWidth - o, s * i.innerHeight - a)
                        } else
                            this.nCi(e * i.innerWidth, s * i.innerHeight);
                    t.resizable && (this.Cb(t.width),
                    this.Ib(t.height)),
                    this.qMi()
                }
            this.tCi = !1
        }
        static rit(t, i) {
            Sw.Qs.mk.lMi(t, i)
        }
        static qs(t, i) {
            return Sw.Qs.mk.cMi(t, i)
        }
        static rCi(t) {
            return Aw.get(t) || null
        }
        Wa(t) {
            if (Sw.gL(t),
            this.dEi) {
                let i = t || window.app.La();
                this.bEi !== i && (this.dEi.textContent = i,
                this.bEi = i)
            }
        }
        Tmt() {
            return !0
        }
        Imt() {
            return !1
        }
        lxi() {
            return this.XO()
        }
        XO() {
            return !!(this.pEi || this.mEi || this.fEi) || this.lbt
        }
        tc() {
            return this.lbt && !this.mEi
        }
        hCi() {
            return !!(this.pEi || this.mEi || this.fEi)
        }
        oCi() {
            return this.pEi
        }
        Fxi() {
            return this.mEi
        }
        iCi() {
            return !!this.TEi
        }
        yk() {
            return this.iCi()
        }
        aCi() {
            return this.eEi === document
        }
        pxt() {
            return Sw.Qs.mk.Oxi() === this
        }
        Pit() {
            return Sw.Qs.mk.Pit(this)
        }
        J$() {
            return Sw.Qs.mk.J$(this)
        }
        vmt() {
            return !this.Bxi()
        }
        dD() {
            return this.c8 || this.HEi
        }
        bMi() {
            return !!this.c8 || !!this.HEi
        }
        lCi() {
            return !!this.bMi() && -1 !== this.dD().EH().indexOf(this)
        }
        uCi() {
            return !!this.bMi() && -1 !== this.dD().cCi().indexOf(this)
        }
        jKt() {
            return self.app.jKt()
        }
        dCi() {
            return this.ZMi
        }
        Oet() {
            return this.QMi
        }
        fCi() {
            return this.tEi
        }
        pCi() {
            return this.PEi
        }
        mCi() {
            return this.AEi
        }
        Pet(t) {
            Sw.zt(t);
            let i = this.ght.querySelector("." + t);
            if (!i)
                throw new Error(`missing dialog element with class name: ${t}`);
            return i
        }
        oyt(t) {
            Sw.zt(t);
            let i = this.ght.querySelector("#" + t);
            if (!i)
                throw new Error(`missing dialog element with id: ${t}`);
            return i
        }
        Ext(t) {
            Sw.zt(t);
            let i = this.ght.getElementsByTagName(t);
            if (!i)
                throw new Error(`tag '${t}' does not match any element`);
            return i
        }
        wCi(t, i=!1) {
            let e;
            if (Sw.zt(t),
            i = !!i) {
                if (e = this.ght.querySelectorAll(t),
                !e)
                    throw new Error(`CSS selector '${t}' does not match any element`);
                if (!e.length)
                    throw new Error(`CSS selector '${t}' does not match any element`)
            } else if (e = this.ght.querySelector(t),
            !e)
                throw new Error(`CSS selector '${t}' does not match any element`);
            return e
        }
        T5t() {
            return this.TEi
        }
        gCi(t) {
            t ? this.eEi = t.ownerDocument : this.TEi ? this.eEi = this.TEi.document : this.eEi = document,
            xw(this.eEi, "no display document for dialog")
        }
        yCi(t) {
            Sw.U(t, Sw.Qs.Ks);
            let i = this.zEi.indexOf(t);
            xw(-1 === i, "child popup window is already part of parent dialog"),
            this.zEi.push(t),
            t.addEventListener("afterpopupclose", this.ZEi)
        }
        bCi(t) {
            Sw.U(t, Sw.Qs.Ks);
            let i = this.zEi.indexOf(t);
            xw(-1 !== i, "child popup window is not part of parent dialog"),
            this.zEi.splice(i, 1),
            t.removeEventListener("afterpopupclose", this.ZEi)
        }
        QEi(t) {
            let i = t.jmt
              , e = i.dD();
            xw(e, "parent can not be null when a child popup is closed"),
            e.bCi(i)
        }
        vCi(t) {
            Sw.U(t, Sw.Qs.Ks);
            let i = this.$Ei.indexOf(t);
            xw(-1 === i, "child dialog is already part of parent dialog"),
            t.c8 = this,
            this.$Ei.length || (this.addEventListener("positionchange", this.YEi),
            this.addEventListener("widthchange", this.YEi),
            this.addEventListener("heightchange", this.YEi),
            this.addEventListener("startdragging", this.qEi),
            this.addEventListener("startresizing", this.qEi)),
            this.$Ei.push(t)
        }
        SCi(t) {
            Sw.U(t, Sw.Qs.Ks);
            let i = this.$Ei.indexOf(t);
            xw(-1 !== i, "child dialog is not part of parent dialog"),
            this.$Ei.splice(i, 1),
            t.c8 = null,
            this.$Ei.length || (this.removeEventListener("positionchange", this.YEi),
            this.removeEventListener("widthchange", this.YEi),
            this.removeEventListener("heightchange", this.YEi),
            this.removeEventListener("startdragging", this.qEi),
            this.removeEventListener("startresizing", this.qEi))
        }
        xCi() {
            for (let t of this.$Ei)
                if (t._Ei || t.Pct(),
                t.c8) {
                    let i = t.c8.$Ei.indexOf(t);
                    t.c8.$Ei.splice(i, 1),
                    t.c8 = null
                }
            if (Sw.Io(this.$Ei),
            !this._Ei) {
                for (let t of this.zEi)
                    t._Ei || t.Pct(),
                    t.removeEventListener("afterpopupclose", this.ZEi),
                    t.HEi = null;
                Sw.Io(this.zEi)
            }
            this.removeEventListener("positionchange", this.YEi),
            this.removeEventListener("widthchange", this.YEi),
            this.removeEventListener("heightchange", this.YEi),
            this.removeEventListener("startdragging", this.qEi),
            this.removeEventListener("startresizing", this.qEi)
        }
        kP() {
            return !!this.$Ei.length
        }
        MCi() {
            return !!this.zEi.length
        }
        EH() {
            return this.$Ei
        }
        cCi() {
            return this.zEi
        }
        *Dxi() {
            for (let t = this.$Ei.length - 1; t >= 0; --t)
                yield this.$Ei[t]
        }
        eCi() {
            let t = this.c8;
            return t ? t.Ec + t.ECi() : 0
        }
        sCi() {
            let t = this.c8;
            return t ? t.zc + t.ECi() : 0
        }
        JEi(t) {
            let i = this.ka() - this.VEi
              , e = this.Ra() - this.WEi;
            for (let t of this.$Ei)
                t.nCi(t.VEi - i, t.WEi - e)
        }
        XEi(t) {
            this.VEi = this.ka(),
            this.WEi = this.Ra();
            for (let t of this.$Ei)
                t.VEi = t.ka(),
                t.WEi = t.Ra()
        }
        Xa(t) {
            return this.CCi(),
            this._Ci(!0, t)
        }
        lQ(t) {
            return this.CCi(),
            this._Ci(!1, t)
        }
        CCi() {
            xw(!1 === this._Ei, "_isPopupTransfer must be false"),
            xw(null === this.c8, "_parent must be null"),
            xw(null === this.HEi, "_parentBeforeDetach must be null")
        }
        _Ci(t, i) {
            if (t = !!t,
            Sw.mGt(i),
            this.lEi = null,
            Sw.kt.Y_ && (t = !0),
            this.XO() && this.Bxi() !== t)
                throw new Error("dialog already showing with different modal setting");
            this.rEi = t;
            let e = this.TCi();
            if (e)
                return e;
            if (this.mEi && (this.fEi.cancel(),
            this.fEi = null,
            this.ICi()),
            this.uEi = null,
            this.gCi(i),
            this.XO())
                return this.KEi;
            if (Sw.Qs.eit(this.ght, "modal", this.rEi),
            Sw.Qs.eit(this.ght, "non-modal", !this.rEi),
            this.gEi && this.PCi(),
            this.rEi && (Sw.Qs.Tvi.lQ(i),
            this.wEi = !0,
            this.kEi && (this.REi = Sw.Ugi.WL( () => {
                this.GEi ? this.LEi() : this.PEi ? this._et() : this.xet()
            }
            , this.bEi))),
            this.hEi ? this.ght.style.display = "" : this.iEi !== this.eEi && (Sw.Qs.UO(this.ght),
            this.eEi.body.appendChild(this.ght)),
            Sw.QL.R9t ? this.rEi ? this.ght.showModal() : this.ght.show() : this.ght.setAttribute("polyfill", ""),
            this.lbt = !0,
            this.GCi(),
            Sw.Qs.mk.xMi(this, !0),
            this.gEi ? (this.ACi(),
            this.RCi()) : this.yEi ? (this.ght.style.width = `${this.Fx}px`,
            this.ght.style.height = `${this.Ex}px`,
            this.ACi()) : !Sw.kt.Y_ && (this.sEi || this.nEi) && self.app.Mmt() || this.kCi(),
            !this.yEi && this.axi() && this.kmt(),
            this.rEi && Sw.Qs.sk.u(this.eEi, this),
            this.gEi = !1,
            this.yEi = !1,
            this.OCi(),
            this.vMi() || this.DCi(),
            this.vMi() || this.eEi.defaultView.addEventListener("resize", this.xEi),
            this.cEi && !Sw.kt.Y_ && (this.vMi() || this.cEi.addEventListener("pointerdown", this.mF)),
            Sw.kt.Y_ && window.addEventListener("orientationchange", this.BEi),
            this.pEi = !this.vMi(),
            !this.jKt() || this._Ei || this.vMi())
                this.ICi();
            else {
                let t = this.KWt()
                  , i = t.left + t.width / 2 - this.eCi()
                  , e = t.top + t.height / 2 - this.sCi()
                  , s = [{
                    transform: `perspective(600px) translate3d(${this.Ec}px, ${this.zc}px, -20px)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "0"
                }, {
                    transform: `perspective(600px) translate3d(${this.Ec}px, ${this.zc}px, 0)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "1"
                }];
                this.ght.style.transform = "",
                this.fEi = this.ght.animate(s, Mw),
                this.fEi.onfinish = t => this.ICi()
            }
            return this._Ei ? this.KEi : (this.QMi && (this.QMi.scrollTop = 0),
            Promise.resolve().then( () => {
                this.vMi() || Sw.Qs.mk.MMi("dialogshow", this)
            }
            ),
            this.vMi() || this.Ymt(),
            this.KEi ? this.KEi : this.FCi())
        }
        GCi() {
            if (!this.rEi && !this.iCi()) {
                let t = Sw.Qs.mk.Oxi();
                if (t && !t.iCi() && t.tc()) {
                    if (this.hEi)
                        throw new Error("not supported");
                    Sw.Qs.UO(this.ght),
                    t.k_().appendChild(this.ght),
                    t.vCi(this)
                }
            }
        }
        TCi() {
            if (!this.rEi && !this.iCi()) {
                let t = Sw.Qs.mk.Oxi();
                if (t && t.iCi()) {
                    if (this.HEi = t,
                    this.axi()) {
                        let t = this.Kmt();
                        this.Cb(t.width),
                        this.Ib(t.height)
                    } else
                        this.RCi();
                    return this.Z5t().then( () => this.FCi())
                }
            }
        }
        FCi() {
            return this.KEi = new Promise( (t, i) => {
                this.oEi = t,
                this.aEi = i
            }
            ),
            this.KEi
        }
        PCi() {
            this.bEi || this.Wa(null),
            this.$et()
        }
        $et() {}
        LCi(t=!1) {
            if (this.wEi && (Sw.Qs.Tvi.j0(),
            this.wEi = !1),
            !this.XO())
                return this.lEi ? void (this.lEi = null) : void (() => {})(`[Dialog] Closing dialog '${this.bEi}' which is not currently open`);
            if (this.lEi = null,
            Sw.Qs.EA.BCi(),
            Sw.Qs.Fk.Uk.UCi(this),
            !this.bMi() && this.iCi() && Sw.Qs.mk.wMi(this.FO()).forEach(t => {
                t !== this && t.Pct(!0)
            }
            ),
            this.rEi && Sw.Qs.sk.j(this.eEi),
            this.eEi.defaultView.removeEventListener("resize", this.xEi),
            Sw.kt.Y_ && (clearTimeout(this.UEi),
            window.removeEventListener("orientationchange", this.BEi)),
            this.cEi && this.cEi.removeEventListener("pointerdown", this.mF),
            this.ZSi(),
            this.fEi) {
                if (!t)
                    return this.pEi && (this.pEi = !1,
                    this.mEi = !0,
                    this.fEi.playbackRate *= -1),
                    Sw.Qs.TO.Rxi(this),
                    (this.kP() || this.MCi()) && this.xCi(),
                    void (this.lCi() && this.dD().SCi(this));
                this.fEi = null
            }
            if (this.mEi = !0,
            Sw.Qs.TO.Rxi(this),
            (this.kP() || this.MCi()) && this.xCi(),
            this.Ymt(),
            this.lCi() && this.dD().SCi(this),
            !this.jKt() || this._Ei || this.TEi || t)
                this.ICi();
            else {
                let t = this.KWt()
                  , i = t.left + t.width / 2 - this.eCi()
                  , e = t.top + t.height / 2 - this.sCi()
                  , s = [{
                    transform: `perspective(600px) translate3d(${this.Ec}px, ${this.zc}px, 0)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "1"
                }, {
                    transform: `perspective(600px) translate3d(${this.Ec}px, ${this.zc}px, -20px)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "0"
                }];
                this.ght.style.transform = "",
                this.fEi = this.ght.animate(s, Mw),
                this.fEi.onfinish = t => this.ICi()
            }
            Sw.Qs.mk.MMi("dialogclose", this)
        }
        vMi() {
            return this.mEi || !this.XO()
        }
        xet() {
            this.sW(!0)
        }
        _et() {
            this.Pct()
        }
        LEi() {
            this._et()
        }
        sW(t) {
            this.mEi || Sw.Qs.mk.FMi(this) && (this.NCi(t),
            this.LCi(),
            Sw.Qs.mk.MMi("dialogok", this, t))
        }
        NCi(t) {
            this.lEi ? Gw.Cpi(this.lEi, t) : (this.oEi && this.oEi(t),
            this.KEi = null)
        }
        Pct(t=!1) {
            t = !!t,
            this.mEi || Sw.Qs.mk.DMi(this) && (this.jCi(),
            this.LCi(t),
            Sw.Qs.mk.MMi("dialogcancel", this, null))
        }
        jCi() {
            this.lEi ? Gw.Cpi(this.lEi, null) : (this.oEi && this.oEi(null),
            this.KEi = null)
        }
        $Ci(t) {
            this.mEi || (this.zCi(t),
            this.LCi())
        }
        zCi(t) {
            this.lEi ? Gw._pi(this.lEi, t) : (this.aEi && this.aEi(t),
            this.KEi = null)
        }
        Omt() {}
        Rmt() {}
        VCi() {
            Sw.Qs.mk.MMi("dialogpositioningchange", this)
        }
        ICi() {
            if (this.fEi && this.fEi.cancel(),
            this.mEi) {
                if (this._Ei || (this.xO(),
                Sw.Qs.mk.xMi(this, !1),
                this.REi && (this.REi.he(),
                this.REi = null)),
                Sw.QL.R9t) {
                    const t = document.activeElement;
                    this.ght.close(),
                    t && t !== document.activeElement && Sw.Qs.mk.CMi(this) && Sw.Sii(t, "dialog") !== this.k_() && t.focus()
                }
                this.lbt = !1,
                !this._Ei && this.TEi && (this.R5t(),
                this.yEi = !0),
                this.hEi ? this.ght.style.display = "none" : this.iEi !== this.eEi && (Sw.Qs.UO(this.ght),
                this.iEi.body.appendChild(this.ght)),
                this.eEi = null,
                this.uEi && (this.uEi(),
                this.uEi = null),
                this.Rmt()
            }
            this.pEi && this.Omt();
            let t = this.pEi;
            this.pEi = !1,
            this.mEi = !1,
            this.fEi = null,
            t && !this._Ei && (Sw.kt.Y_ ? this.kCi() : (this.WCi(),
            this.qMi())),
            this._0(),
            t && this.VCi()
        }
        xO() {}
        xUt() {
            return new Promise( (t, i) => {
                this.uEi = t
            }
            )
        }
        FO() {
            return this.eEi
        }
        Bxi() {
            return this.rEi
        }
        KMi() {
            return this.Q$() && this.Pxi()
        }
        HCi(t) {
            this.EEi = !!t
        }
        OEi(t) {
            if (t.preventDefault(),
            !this.EEi || this.CEi)
                return;
            if (this.Fxi())
                return;
            Sw.p.u("ui.dialogs.caption-menu");
            let i = Sw.v(Sw.Qs.EA, this.cEi);
            this.KMi() && i._A("open-popup", self.lang(".open-to-popup-window"), () => this.Z5t(), {
                MT: !0
            }),
            i._A("close", self.lang(".close"), () => this._et()),
            i.NT(t.clientX, t.clientY),
            Sw.p.j()
        }
        Z5t(t, i) {
            if (Sw.iM(t),
            Sw.iM(i),
            this.CEi)
                throw new Error("already awaiting popup window");
            if (this.TEi)
                throw new Error("already in popup window");
            if (!this.KMi())
                return;
            this.CEi = !0,
            this.Amt("beforepopupopen");
            let e = "window.html";
            return Sw.q8t() || (e += "?mode=dev"),
            Sw.Qs.zxi.Wxi(e, this.Ftt, this.ns(), this.er(), t, i).then(t => {
                const i = t.window;
                return i.addEventListener("unload", t => this.KCi(i)),
                this.qCi(i)
            }
            ).catch(t => {
                this.CEi = !1,
                this.Ymt(),
                Sw.Qs.Ks.qs("OK").Xa(self.lang("ui.cannot-open-popup")),
                this.Amt("afterpopupclose")
            }
            )
        }
        XCi() {
            return this.kP() ? Promise.resolve().then( () => Promise.all(this.EH().map(t => (this.yCi(t),
            t.Z5t())))) : Promise.resolve()
        }
        qCi(t) {
            return Promise.resolve().then( () => this.XCi()).then( () => {
                if (this._Ei = !0,
                this.HEi = this.dD(),
                this.bMi() && !this.uCi() && this.HEi.yCi(this),
                this.XO())
                    return this.LCi()
            }
            ).then( () => (this.CEi = !1,
            this.TEi = t,
            window.addEventListener("unload", this.IEi),
            this.ght.setAttribute("inPopupWindow", ""),
            this.ght.style.transform = "",
            this.ght.style.width = "",
            this.ght.style.height = "",
            this._Ci(this.rEi),
            this._Ei = !1,
            t.document.title = this.bEi,
            this.Amt("afterpopupopen"),
            Sw.Qs.zxi.iMi(t, "dialog-transferred", null),
            this.Ymt(),
            t))
        }
        KCi(t) {
            this.TEi && (Sw.Qs.mk.gMi(t).forEach(t => {
                t !== this && t.Pct(!0)
            }
            ),
            this.Amt("beforepopupclose"),
            this._Ei = !0,
            this.Fx = Sw.Ne(this.TEi.innerWidth, this.vEi, Sw.rat(.9 * window.innerWidth)),
            this.Ex = Sw.Ne(this.TEi.innerHeight, this.SEi, Sw.rat(.9 * window.innerHeight)),
            window.removeEventListener("unload", this.IEi),
            this.LCi(),
            this.TEi = null,
            this.ght.removeAttribute("inPopupWindow"),
            this.yEi = !0,
            !this.bMi() || this.bMi() && !this.dD().iCi() ? this._Ci(this.rEi) : this.jCi(),
            this.Amt("afterpopupclose"),
            this._Ei = !1,
            this.HEi = null,
            this.Ymt())
        }
        R5t() {
            if (this.TEi) {
                this.Fx = Sw.Ne(this.TEi.innerWidth, this.vEi, Sw.rat(.9 * window.innerWidth)),
                this.Ex = Sw.Ne(this.TEi.innerHeight, this.SEi, Sw.rat(.9 * window.innerHeight));
                let t = this.TEi;
                this.TEi = null,
                t.close(),
                this.ght.removeAttribute("inPopupWindow"),
                this.CEi = !1
            }
        }
        fxi() {
            if (!this.XO())
                return;
            super.fxi(),
            this.Ec = Sw.rat(this.WSi.left),
            this.zc = Sw.rat(this.WSi.top);
            let t = 2 * this.ECi();
            this.Fx = this.WSi.right - this.WSi.left - t,
            this.Ex = this.WSi.bottom - this.WSi.top - t
        }
        ACi() {
            this.kCi(),
            this.ght.style.margin = "0",
            this.ght.style.position = "absolute",
            this.ght.style.left = "0px",
            this.ght.style.top = "0px",
            this._0()
        }
        OCi() {}
        kCi() {
            if (!this.eEi || !this.eEi.defaultView)
                return;
            this._0(),
            super.KWt();
            let t = 2 * this.ECi()
              , i = (this.Fx + t) / 2
              , e = (this.Ex + t) / 2
              , s = this.eEi.defaultView.innerWidth / 2
              , n = this.eEi.defaultView.innerHeight / 2;
            this.Ec = Sw.rat(s - i - this.eCi()),
            this.zc = Sw.rat(n - e - this.sCi()),
            this.WCi()
        }
        RCi() {
            let t = Sw.Qs.pW("min-width", {
                wW: this.ght
            });
            if ("auto" === t && (t = "0px"),
            !t.endsWith("px"))
                throw new Error("CSS style for dialog min-width must specify the size in units of 'px'");
            let i = parseInt(t, 10);
            isFinite(i) || (i = this.Q$() ? Cw : Ew),
            this.vEi = i;
            let e = Sw.Qs.pW("min-height", {
                wW: this.ght
            });
            if ("auto" === e && (e = "0px"),
            !e.endsWith("px"))
                throw new Error("CSS style for dialog min-height must specify the size in units of 'px'");
            let s = parseInt(e, 10);
            isFinite(s) || (s = this.Q$() ? Tw : _w),
            this.SEi = s
        }
        KWt() {
            if (!this.gEi || this.bMi()) {
                let t = 2 * this.ECi()
                  , i = this.eCi()
                  , e = this.sCi();
                return {
                    left: this.Ec + i,
                    top: this.zc + e,
                    right: this.Ec + this.Fx + t + i,
                    bottom: this.zc + this.Ex + t + e,
                    width: this.Fx + t,
                    height: this.Ex + t
                }
            }
            return super.KWt()
        }
        WCi() {
            this.pEi || this.mEi || (this.iCi() ? this.ght.style.transform = "" : this.ght.style.transform = `translate(${this.Ec}px,${this.zc}px)`)
        }
        nCi(t, i) {
            Sw.Ge(t),
            Sw.Ge(i),
            t = Sw.rat(t),
            i = Sw.rat(i),
            this.Ec === t && this.zc === i || this.TEi || (this.Ec = t,
            this.zc = i,
            this.WCi(),
            this._0(),
            this.Amt("positionchange"),
            this.Ymt())
        }
        Fo(t) {
            Sw.Ge(t),
            t = Sw.rat(t),
            this.Ec === t || this.TEi || (this.Ec = t,
            this.WCi(),
            this._0(),
            this.Amt("positionchange"),
            this.Ymt())
        }
        ka() {
            return this.KWt(),
            this.Ec
        }
        ESi() {
            return this.ka() + this.ECi() + this.eCi()
        }
        Eo(t) {
            Sw.Ge(t),
            t = Sw.rat(t),
            this.zc === t || this.TEi || (this.zc = t,
            this.WCi(),
            this._0(),
            this.Amt("positionchange"),
            this.Ymt())
        }
        Ra() {
            return this.KWt(),
            this.zc
        }
        CSi() {
            return this.Ra() + this.ECi() + this.sCi()
        }
        Cb(t) {
            Sw.Ge(t),
            (t = Sw.rat(t)) < this.vEi && (t = this.vEi),
            this.Fx !== t && (this.Fx = t,
            this.ght.style.width = `${this.Fx}px`,
            this._0(),
            this.Amt("widthchange"),
            this.Ymt())
        }
        ns() {
            return this.KWt(),
            this.Fx
        }
        GSt() {
            return this.vEi
        }
        Ib(t) {
            Sw.Ge(t),
            (t = Sw.rat(t)) < this.SEi && (t = this.SEi),
            this.Ex !== t && (this.Ex = t,
            this.ght.style.height = `${this.Ex}px`,
            this._0(),
            this.Amt("heightchange"),
            this.Ymt())
        }
        er() {
            return this.KWt(),
            this.Ex
        }
        MSt() {
            return this.SEi
        }
        Q$() {
            return this.sEi
        }
        qMi() {
            if (-1 === this.UEi && !this.TEi) {
                if (this.KWt(),
                Sw.kt.Y_)
                    this.kCi();
                else {
                    if (!this.eEi)
                        return;
                    const t = this.eEi.defaultView.innerWidth
                      , i = this.eEi.defaultView.innerHeight
                      , e = 2 * this.ECi()
                      , s = -this.eCi()
                      , n = -this.sCi();
                    this.sEi ? (this.Fx + e > t && this.Cb(t - e),
                    this.Ex + e > i && this.Ib(i - e),
                    this.Ec < s ? this.Fo(s) : this.Ec - s + this.Fx + e > t && this.Fo(t - this.Fx - e + s),
                    this.zc < n ? this.Eo(n) : this.zc - n + this.Ex + e > i && this.Eo(i - this.Ex - e + n)) : (this.Ec < s || this.Ec - s + this.Fx + e > t || this.zc < n || this.zc - n + this.Ex + e > i) && this.kCi()
                }
                this.Amt("resize")
            }
        }
        jEi(t) {
            Sw.kt.FG || -1 === this.UEi && this.NEi !== window.orientation && (this.NEi = window.orientation,
            this.UEi = setTimeout( () => {
                this.UEi = -1,
                this.xEi()
            }
            , Pw))
        }
        DCi() {
            if (!Sw.kt.Y_ && !this.iCi())
                for (; Sw.Qs.mk.EMi(this); )
                    this.nCi(this.ka() + Iw, this.Ra() + Iw)
        }
        gz(t, i) {
            return Sw.Ge(t),
            Sw.Ge(i),
            !!this.XO() && super.gz(t, i)
        }
        bVt(t, i, e) {
            Sw.Ge(t),
            Sw.Ge(i),
            Sw.iM(e),
            Sw.Qs.mk.jMi(this, t, i, e)
        }
        wG(t) {
            const i = t.which;
            if (this.mEi)
                return t.preventDefault(),
                void t.stopPropagation();
            i === Sw.Mk.VJ ? (t.preventDefault(),
            t.stopPropagation(),
            this._et()) : i !== Sw.Mk.aY || t.shiftKey || (t.preventDefault(),
            t.stopPropagation(),
            this.xet())
        }
        VMi() {}
        YMi() {}
        $Mi() {}
        XMi() {}
        ECi() {
            return this.iCi() ? 0 : this.Q$() ? Sw.Qs.tSi() : Sw.Qs.Qvi()
        }
        zMi(t, i) {
            if (Sw.Ge(t),
            Sw.Ge(i),
            !this.Q$())
                return "";
            if (Sw.kt.Y_)
                return "";
            let e = this.KWt()
              , s = this.ECi()
              , n = 2 * s
              , r = "";
            return t > e.left + s && t < e.right - s && i > e.top + s && i < e.bottom - s ? r = "m" : Sw.Qs.TO.Gxi() ? t >= e.left && t <= e.left + n ? i >= e.top && i <= e.top + n ? r = "nw" : i <= e.bottom && i >= e.bottom - n ? r = "sw" : i > e.top + n && i < e.bottom - n && t <= e.left + s && (r = "w") : t <= e.right && t >= e.right - n ? i >= e.top && i <= e.top + n ? r = "ne" : i <= e.bottom && i >= e.bottom - n ? r = "se" : i > e.top + n && i < e.bottom - n && t >= e.right - s && (r = "e") : t > e.left + n && t < e.right - n && (i >= e.top && i <= e.top + s ? r = "n" : i <= e.bottom && i >= e.bottom - s && (r = "s")) : r = "",
            r
        }
        Amt(t, i) {
            Sw.zt(t),
            Sw.ML(i);
            let e = new Sw.Event(t);
            e.jmt = this,
            i && Object.assign(e, i),
            this.dispatchEvent(e)
        }
        YCi() {
            if (this.hEi)
                throw new Error("already keeping in main document");
            this.hEi = !0,
            this.iEi = document,
            document.body.appendChild(this.ght),
            this.ght.style.display = "none"
        }
        JCi(t) {
            this.GEi && this.GEi.eP(t)
        }
    }
}
{
    const Rw = self.t;
    Rw.Qs.ZCi = class {
        constructor() {
            this.Upi = null,
            this.uVt = null,
            this.QCi = !1,
            this.t_i = null
        }
        Xa(t, i, e, s) {
            return Rw.gL(t),
            Rw.mGt(i),
            e = !!e,
            s = !!s,
            this.Upi = i ? i.ownerDocument : document,
            this.uVt = Rw.Qs.W_("input", this.Upi.body),
            this.uVt.setAttribute("hidden", ""),
            this.uVt.setAttribute("type", "file"),
            t && this.uVt.setAttribute("accept", t),
            e && this.uVt.setAttribute("multiple", ""),
            s && (this.uVt.setAttribute("webkitdirectory", ""),
            this.uVt.setAttribute("mozdirectory", "")),
            new Promise( (t, i) => {
                this.t_i = i => {
                    if (this.QCi = !0,
                    this.uVt.files.length)
                        if (e)
                            t(this.uVt.files);
                        else {
                            const i = this.uVt.files[0];
                            t(i)
                        }
                    else
                        t(null);
                    this.xO()
                }
                ,
                this.uVt.addEventListener("change", this.t_i),
                this.uVt.click()
            }
            )
        }
        xO() {
            this.uVt.removeEventListener("change", this.t_i),
            this.t_i = null,
            Rw.Qs.UO(this.uVt),
            this.uVt = null,
            this.Upi = null
        }
        static async i_i(t, i, e, s, n) {
            const r = new Rw.Qs.ZCi;
            return await r.Xa(t, i, e, s)
        }
    }
}
{
    const kw = self.t
      , Ow = kw.bW(import.meta.url).getElementById("okDialog")
      , Dw = "OK"
      , Fw = {
        message: "",
        align: "center",
        e_i: !1,
        s_i: null,
        n_i: null
    }
      , Lw = kw.Qs.Ks.OK = class extends kw.Qs.Ks {
        constructor() {
            super(Ow),
            this.r_i = this.Pet("okMessage"),
            this.h_i = this.Pet("okList"),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.a_i = this.Pet("okDialogDoNotShowAgainWrapper"),
            this.l_i = this.Pet("doNotShowAgainInput"),
            this.u_i = this.Pet("doNotShowAgainLabel"),
            this.c_i = null,
            this.nEi = !1
        }
        $et() {
            this.o_i.textContent = self.lang("common.ok")
        }
        Xa(t, i) {
            let e;
            kw.bti(t) ? (e = Object.assign({}, Fw),
            e.message = t) : (kw.IL(t),
            e = Object.assign({}, Fw, t));
            let s = e.message;
            if (kw.Qs.eit(this.Oet(), "alignleft", "left" === e.align),
            kw.Qs.eit(this.Oet(), "selectable", e.e_i),
            "function" == typeof e.s_i ? (kw.wQ(this.u_i, self.lang("common.do-not-show-again")),
            this.c_i = () => {
                e.s_i(this.l_i.value)
            }
            ,
            this.l_i.addEventListener("input", this.c_i),
            this.a_i.style.display = "") : this.a_i.style.display = "none",
            kw.wQ(this.r_i, s),
            kw.Qs.L6(this.h_i),
            e.n_i && kw.B9(e.n_i)) {
                this.h_i.style.display = "";
                for (const t of e.n_i) {
                    kw.p0(t);
                    const i = kw.Qs.W_("li", this.h_i, null, "okListItem");
                    kw.wQ(i, t)
                }
            } else
                this.h_i.style.display = "none";
            return super.Xa(i)
        }
        xO() {
            this.l_i.removeEventListener("input", this.c_i),
            this.l_i.value = !1,
            this.Wa(null)
        }
    }
    ;
    kw.Qs.mk.iit.addEventListener("load", function() {
        kw.Qs.Ks.rit(Dw, Lw)
    })
}
{
    const Bw = self.t
      , Uw = Bw.bW(import.meta.url).getElementById("confirmDialog")
      , Nw = "Confirm"
      , jw = Bw.Qs.Ks.d_i = class extends Bw.Qs.Ks {
        constructor() {
            super(Uw),
            this.Pii = null,
            this.f_i = this.Pet("confirmMessage"),
            this.p_i = this.Pet("confirmButton"),
            this.nEi = !1,
            this.p_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelConfirmButton"),
            this.FMt.onclick = () => this._et()
        }
        $et() {}
        Xa(t, i) {
            Bw.J1(t),
            Bw.mGt(i);
            let e = t.caption || ""
              , s = t.message || ""
              , n = t._nt || self.lang("common.ok")
              , r = t.bnt || self.lang("common.cancel");
            const h = !t.m_i;
            return e && this.Wa(e),
            Bw.wQ(this.f_i, s),
            this.p_i.textContent = n,
            this.FMt.textContent = r,
            h ? this.p_i.classList.add("bold") : this.p_i.classList.remove("bold"),
            this.kEi = !t.w_i,
            super.Xa(i)
        }
        xet() {
            this.Pii && this.Pii(),
            super.xet()
        }
        xO() {
            this.Pii = null
        }
    }
    ;
    Bw.Qs.mk.iit.addEventListener("load", function() {
        Bw.Qs.Ks.rit(Nw, jw)
    })
}
{
    const $w = self.t
      , zw = $w.bW(import.meta.url).getElementById("confirmCheckDialog")
      , Vw = "ConfirmCheck"
      , Ww = $w.Qs.Ks.g_i = class extends $w.Qs.Ks {
        constructor() {
            super(zw),
            this.Pii = null,
            this.f_i = this.Pet("confirmMessage"),
            this.p_i = this.Pet("confirmButton"),
            this.y_i = this.Pet("confirmCheckbox"),
            this.b_i = this.Pet("confirmCheckLabel"),
            this.v_i = !1,
            this.nEi = !1,
            this.p_i.onclick = () => (this.Pii && this.Pii(),
            this.xet()),
            this.FMt = this.Pet("cancelConfirmButton"),
            this.FMt.onclick = () => this._et(),
            this.S_i = this.Pet("buttonSpacer")
        }
        $et() {}
        Xa(t, i) {
            $w.J1(t),
            $w.mGt(i),
            $w.zt(t.x_i);
            let e = t.caption || ""
              , s = t.message || ""
              , n = t._nt || self.lang("common.ok")
              , r = t.bnt || self.lang("common.cancel");
            const h = !!t.M_i;
            this.y_i.checked = h,
            this.v_i = h,
            this.b_i.textContent = t.x_i,
            e && this.Wa(e),
            $w.wQ(this.f_i, s),
            this.p_i.textContent = n,
            this.FMt.textContent = r,
            this.kEi = !t.w_i,
            t.E_i ? (this.FMt.style.display = "none",
            this.S_i.style.display = "none",
            this.p_i.classList.remove("bold")) : (this.FMt.style.display = "",
            this.S_i.style.display = "",
            this.p_i.classList.add("bold"));
            const o = super.Xa(i);
            return this.p_i.focus(),
            o
        }
        xet() {
            this.v_i = this.y_i.checked,
            super.xet()
        }
        _et() {
            this.v_i = this.y_i.checked,
            super._et()
        }
        C_i() {
            return this.v_i
        }
        xO() {
            this.Pii = null
        }
    }
    ;
    $w.Qs.mk.iit.addEventListener("load", function() {
        $w.Qs.Ks.rit(Vw, Ww)
    })
}
{
    const Hw = self.t
      , Kw = Hw.bW(import.meta.url).getElementById("confirmMultipleDialog")
      , qw = "ConfirmMultiple"
      , Xw = Hw.Qs.Ks.__i = class extends Hw.Qs.Ks {
        constructor() {
            super(Kw),
            this.Pii = null,
            this.f_i = this.Pet("confirmMultipleMessage"),
            this.T_i = this.Pet("optionButtonsWrap"),
            this.I_i = this.Pet("cancelButtonWrap"),
            this.P_i = ""
        }
        $et() {}
        Xa(t, i) {
            Hw.J1(t),
            Hw.mGt(i),
            Hw.RH(t.options);
            const e = t.caption || ""
              , s = t.message || "";
            e && this.Wa(e),
            Hw.wQ(this.f_i, s);
            const n = super.Xa(i);
            for (let i = 0, e = t.options.length; i < e; ++i) {
                const s = t.options[i]
                  , n = s.text
                  , r = s.tag;
                Hw.zt(n),
                Hw.zt(r);
                const h = Hw.Qs.W_("button", this.T_i);
                if (h.textContent = n,
                h.onclick = () => this.xet(r),
                0 === i && (this.P_i = r,
                h.setAttribute("main", "")),
                i < e - 1) {
                    Hw.Qs.W_("span", this.T_i).setAttribute("button-spacer", "")
                }
            }
            if (t.Stt) {
                const t = Hw.Qs.W_("button", this.I_i);
                t.textContent = self.lang("common.cancel"),
                t.onclick = () => this.xet("cancel"),
                t.setAttribute("cancel", "")
            }
            return n
        }
        xet(t) {
            Hw.gL(t),
            t || (t = this.P_i),
            "cancel" === t ? this.Pct() : (this.Pii && this.Pii(t),
            this.sW(t))
        }
        xO() {
            this.Pii = null,
            Hw.Qs.L6(this.T_i),
            Hw.Qs.L6(this.I_i)
        }
    }
    ;
    Hw.Qs.mk.iit.addEventListener("load", function() {
        Hw.Qs.Ks.rit(qw, Xw)
    })
}
{
    const Yw = self.t
      , Jw = Yw.bW(import.meta.url)
      , Zw = Jw.getElementById("progressDialog")
      , Qw = Yw.IW(Jw.URL);
    Yw.p.MW(Qw + "lang");
    const tg = "Progress"
      , ig = 100
      , eg = Yw.Qs.Ks.G_i = class extends Yw.Qs.Ks {
        constructor() {
            super(Zw),
            this.A_i = this.Pet("progressBar"),
            this.onprogress = null,
            this.R_i = !0,
            this.Ppi = -1,
            this.k_i = 0,
            this.O_i = "",
            this.wF = null,
            this.nEi = !1,
            this.D_i = null,
            this.FMt = this.Pet("cancelConfirmButton"),
            this.FMt.onclick = () => this._et()
        }
        $et() {}
        Xa(t, i, e) {
            Yw.gL(t),
            this.k_i = 0,
            t ? this.O_i = t : this.onprogress ? this.O_i = `${self.lang("ui.dialogs.progress.titleBase")} ({0}%)...` : this.O_i = `${self.lang("ui.dialogs.progress.titleBase")}...`,
            this.FMt.textContent = self.lang("ui.dialogs.progress.cancelButton"),
            this.onprogress ? (this.F_i(!1),
            this.L_i(!0),
            this.Ppi = window.setInterval( () => this.L_i(), ig)) : (this.F_i(!0),
            this.Wa(this.O_i)),
            e ? (this.D_i = e,
            this.FMt.style.display = "") : (this.D_i = null,
            this.FMt.style.display = "none"),
            this.kEi = !!e;
            const s = super.Xa(i);
            return this.wF || (this.wF = Yw.Qs.sk.ik("wait", this.FO())),
            s
        }
        F_i(t) {
            t = !!t,
            this.R_i !== t && (this.R_i = t,
            this.R_i ? (this.A_i.removeAttribute("value"),
            this.A_i.removeAttribute("max")) : (this.A_i.value = this.k_i,
            this.A_i.max = 1))
        }
        L_i(t) {
            if (!this.onprogress)
                return;
            let i = this.onprogress();
            (this.k_i !== i || t) && (this.k_i = i,
            null === this.k_i ? (this.F_i(!0),
            this.Wa(this.O_i.replace("{0}", "0"))) : (isFinite(this.k_i) || (this.k_i = 0),
            this.k_i = Yw.Ne(this.k_i, 0, 1),
            this.F_i(!1),
            this.A_i.value = this.k_i,
            this.Wa(this.O_i.replace("{0}", Math.round(1e3 * i) / 10))))
        }
        LCi() {
            -1 !== this.Ppi && (window.clearInterval(this.Ppi),
            this.Ppi = -1),
            Yw.Qs.sk.hk(this.wF),
            this.wF = null,
            this.onprogress = null,
            this.k_i = 0,
            super.LCi()
        }
        xet() {}
        _et() {
            this.D_i && (this.D_i(),
            super._et())
        }
    }
    ;
    Yw.Qs.mk.iit.addEventListener("load", function() {
        Yw.Qs.Ks.rit(tg, eg)
    })
}
{
    const sg = self.t
      , ng = sg.bW(import.meta.url)
      , rg = ng.getElementById("downloadDialog")
      , hg = sg.IW(ng.URL);
    sg.p.MW(hg + "lang");
    const og = "Download"
      , ag = 10
      , lg = sg.Qs.Ks.gLt = class extends sg.Qs.Ks {
        constructor() {
            super(rg),
            this.A_i = this.Pet("downloadProgressBar"),
            this.B_i = this.Pet("downloadDetails"),
            this.Ppi = -1,
            this.U_i = "",
            this.N_i = "",
            this.j_i = 0,
            this.$_i = 0,
            this.z_i = 0,
            this.V_i = [],
            this.W_i = 0,
            this.H_i = !1,
            this.wF = null,
            this.nEi = !1
        }
        $et() {}
        Xa(t, i) {
            sg.zt(t),
            this.U_i = t,
            this.j_i = 0,
            this.$_i = 0,
            this.W_i = 0,
            this.z_i = 0,
            sg.Io(this.V_i),
            this.H_i = !0;
            let e = this.U_i.lastIndexOf("/");
            this.N_i = this.U_i.substring(e + 1),
            this.Wa(self.lang("ui.dialogs.download.caption")),
            this.kEi = !1;
            let s = super.Xa(i);
            return this.wF || (this.wF = sg.Qs.sk.ik("progress", this.FO())),
            sg._4(t, t => this.K_i(t)).then(t => {
                sg.Qs.sk.hk(this.wF),
                this.wF = null,
                this.sW(t)
            }
            ).catch(t => {
                sg.Qs.sk.hk(this.wF),
                this.wF = null,
                this.$Ci(t)
            }
            ),
            this.Ppi = window.setInterval( () => this.q_i(!0), 1e3),
            this.q_i(),
            s
        }
        K_i(t) {
            if (!t.lengthComputable)
                return;
            this.W_i = t.total,
            this.$_i = t.loaded,
            this.H_i && (this.H_i = !1,
            this.q_i(!1));
            let i = 100 * this.$_i / this.W_i;
            this.A_i.value = i,
            this.Wa(self.h_("ui.dialogs.download.caption-progress", Math.round(i)))
        }
        X_i(t) {
            sg.Ge(t),
            this.V_i.length >= ag && this.V_i.shift(),
            this.V_i.push(t)
        }
        Y_i() {
            if (0 === this.V_i.length)
                return 0;
            let t = 0;
            for (let i of this.V_i)
                t += i;
            return t / this.V_i.length
        }
        q_i(t) {
            t && (this.z_i = this.$_i - this.j_i,
            this.X_i(this.z_i),
            this.j_i = this.$_i);
            const i = self.lang;
            sg.p.u("ui.dialogs.download");
            let e = i(".downloading-label") + this.N_i;
            this.W_i > 0 && (e += " (" + sg.Woi(this.W_i) + ")"),
            e += "<br/>",
            e += i(".speed-label"),
            0 === this.z_i ? e += i(".calculating") : e += sg.Woi(this.z_i, !0);
            let s = navigator.connection || navigator.J_i || navigator.Z_i
              , n = s ? s.type : "";
            n && "other" !== n && "unknown" !== n && (e += " (" + n + ")"),
            e += "<br/>",
            e += i(".time-remaining-label");
            let r = -1;
            if (this.V_i.length < 2)
                e += i(".calculating");
            else {
                let t = this.Y_i();
                0 === t ? e += i(".stalled") : (r = (this.W_i - this.$_i) / t,
                r = 5 * Math.round(r / 5),
                e += r < 5 ? i("common.time.a-few-seconds") : sg.Joi(r, {
                    Hoi: !0
                }))
            }
            this.B_i.innerHTML = e,
            sg.p.j(),
            this.kCi()
        }
        LCi() {
            window.clearInterval(this.Ppi),
            this.Ppi = -1,
            super.LCi()
        }
        xet() {}
        _et() {}
    }
    ;
    sg.Qs.mk.iit.addEventListener("load", function() {
        sg.Qs.Ks.rit(og, lg)
    })
}
{
    const ug = self.t
      , cg = ug.bW(import.meta.url)
      , dg = cg.getElementById("openPopupWindowDialog")
      , fg = ug.IW(cg.URL)
      , pg = "OpenPopupWindow";
    ug.p.MW(fg + "lang");
    const mg = ug.Qs.Ks.Q_i = class extends ug.Qs.Ks {
        constructor() {
            super(dg),
            this.f_i = this.Pet("openPopupWindowMessage"),
            this.tTi = this.Pet("openPopupWindowTryAgain"),
            this.tTi.onclick = () => this.xet(),
            this.FMt = this.Pet("openPopupWindowCancel"),
            this.FMt.onclick = () => this._et(),
            this.U_i = "",
            this.bht = null,
            this.nEi = !1
        }
        $et() {
            const t = self.lang;
            this.Wa(t("ui.dialogs.openPopupWindow.caption")),
            ug.p.u("ui.dialogs.openPopupWindow"),
            this.f_i.textContent = t(".body"),
            this.FMt.textContent = t("common.cancel"),
            this.tTi.textContent = t(".try-again"),
            ug.p.j()
        }
        Xa(t, i) {
            return this.U_i = t,
            this.bht = i,
            super.Xa(i._Et)
        }
        xet() {
            const t = Object.assign({}, this.bht);
            t.Vxi = !1,
            ug.Qs.zxi.hMi(this.U_i, t).then(t => {
                t && this.sW(t)
            }
            )
        }
    }
    ;
    ug.Qs.mk.iit.addEventListener("load", function() {
        ug.Qs.Ks.rit(pg, mg)
    })
}
{
    const wg = self.t
      , gg = wg.bW(import.meta.url).getElementById("fontPickerDialog")
      , yg = "FontPicker"
      , bg = 250
      , vg = {
        wae: "",
        yae: "",
        bae: 20,
        gae: [],
        kae: ""
    }
      , Sg = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
      , xg = wg.Qs.Ks.iTi = class extends wg.Qs.Ks {
        constructor() {
            super(gg),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.eTi = this.Pet("fontPickerLocalHeaderText"),
            this.sTi = this.Pet("localFontSelect"),
            this.sTi.addEventListener("change", () => this.nTi()),
            this.rTi = this.Pet("additionalFontSection"),
            this.hTi = this.Pet("fontPickerAdditionalHeaderText"),
            this.oTi = this.Pet("additionalFontSelect"),
            this.oTi.addEventListener("change", () => this.aTi()),
            this.lTi = this.Pet("sampleTextHeader"),
            this.uTi = this.Pet("sampleText"),
            this.cTi = "",
            this.dTi = this.Pet("fontPickerMorePreview"),
            this.dTi.onclick = () => this.fTi(),
            this.pTi = "",
            this.mTi = "",
            this.wTi = !1,
            this.pn = !1,
            this.nEi = !1
        }
        $et() {
            wg.p.u("ui.dialogs.std.font-picker");
            const t = self.lang;
            this.Wa(t(".caption")),
            this.eTi.textContent = t(".loading-message"),
            this.o_i.textContent = t("common.ok"),
            this.FMt.textContent = t("common.cancel"),
            this.dTi.textContent = t(".more-preview"),
            wg.p.j()
        }
        Xa(t, i) {
            wg.IL(t),
            t = Object.assign({}, vg, t),
            wg.zt(t.wae),
            wg.zt(t.yae),
            wg.RH(t.gae),
            wg.zt(t.kae),
            this.wTi || this.pn || this.gTi(),
            this.pTi = t.wae || "",
            this.mTi = this.pTi,
            this.cTi = t.yae || "";
            let e = t.bae;
            return e > 72 && (e = 72),
            this.uTi.style.fontSize = `${e}pt`,
            this.cTi.length > bg && (this.cTi = this.cTi.substr(0, bg) + "..."),
            t.gae.length ? (this.rTi.removeAttribute("hidden"),
            this.hTi.textContent = t.kae || self.lang("ui.dialogs.std.font-picker.default-additional-fonts-header"),
            this.yTi(t.gae)) : this.rTi.setAttribute("hidden", ""),
            this.wTi && (this.uTi.textContent = this.cTi || self.lang("ui.dialogs.std.font-picker.default-sample-text"),
            this.bTi()),
            super.Xa(i)
        }
        gTi() {
            this.pn = !0;
            const t = this.k_().ownerDocument
              , i = wg.p.Yue("ui.dialogs.std.font-picker")
              , e = t.createElement("option");
            e.value = "",
            e.textContent = i(".none-selected"),
            this.sTi.appendChild(e);
            const s = t.createElement("optgroup");
            s.label = i(".generic-font-families-group");
            for (const e of Sg) {
                const n = t.createElement("option");
                n.value = e,
                n.textContent = i(`.generic-font-families.${e}`),
                n.style.fontFamily = e,
                n.setAttribute("title", e),
                n.addEventListener("UIDoubleTap", () => this.sW(e)),
                s.appendChild(n)
            }
            this.sTi.appendChild(s),
            wg.boi.voi().then(t => this.vTi(t))
        }
        vTi(t) {
            this.pn = !1,
            this.wTi = !0;
            const i = this.k_().ownerDocument
              , e = wg.p.Yue("ui.dialogs.std.font-picker")
              , s = i.createElement("optgroup");
            s.label = e(".other-fonts-group");
            for (const e of t) {
                const t = i.createElement("option");
                t.value = e,
                t.textContent = e,
                t.style.fontFamily = e,
                t.setAttribute("title", e),
                t.addEventListener("UIDoubleTap", () => this.sW(e)),
                s.appendChild(t)
            }
            this.sTi.appendChild(s),
            this.bTi(),
            this.eTi.textContent = e(".local-font-header"),
            this.lTi.textContent = e(".sample-text-header"),
            this.uTi.textContent = this.cTi || e(".default-sample-text")
        }
        yTi(t) {
            let i = this.k_().ownerDocument
              , e = i.createElement("option");
            e.value = "",
            e.textContent = self.lang("ui.dialogs.std.font-picker.none-selected"),
            this.oTi.appendChild(e);
            for (let e of t) {
                let t = i.createElement("option");
                t.value = e,
                t.textContent = e,
                t.style.fontFamily = e,
                t.setAttribute("title", e),
                t.addEventListener("UIDoubleTap", () => this.sW(e)),
                this.oTi.appendChild(t)
            }
        }
        bTi() {
            this.pTi && (this.sTi.value = this.pTi,
            -1 === this.sTi.selectedIndex ? (this.oTi.value = this.pTi,
            -1 === this.oTi.selectedIndex ? (this.sTi.selectedIndex = 0,
            this.nTi()) : this.aTi()) : this.nTi())
        }
        nTi() {
            0 !== this.sTi.selectedIndex ? (this.mTi = this.sTi.value,
            this.sTi.style.fontFamily = this.mTi,
            this.oTi.selectedIndex = 0,
            this.oTi.style.fontFamily = "",
            this.STi()) : this.sTi.style.fontFamily = ""
        }
        aTi() {
            0 !== this.oTi.selectedIndex ? (this.mTi = this.oTi.value,
            this.oTi.style.fontFamily = this.mTi,
            this.sTi.selectedIndex = 0,
            this.sTi.style.fontFamily = "",
            this.STi()) : this.oTi.style.fontFamily = ""
        }
        STi() {
            this.uTi.style.fontFamily = this.mTi
        }
        fTi() {
            wg.Qs.Ks.qs("FontPreview").Xa(this.mTi, this.k_())
        }
        xet() {
            this.sW(this.mTi)
        }
        xO() {
            wg.Qs.L6(this.oTi)
        }
    }
    ;
    wg.Qs.mk.iit.addEventListener("load", function() {
        wg.Qs.Ks.rit(yg, xg)
    })
}
{
    const Mg = self.t
      , Eg = Mg.bW(import.meta.url)
      , Cg = Eg.getElementById("fontPreviewDialog")
      , _g = Mg.IW(Eg.URL);
    Mg.p.MW(_g + "lang");
    const Tg = "FontPreview"
      , Ig = [5, 8, 11, 14, 20, 36, 48, 72]
      , Pg = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"])
      , Gg = Mg.Qs.Ks.xTi = class extends Mg.Qs.Ks {
        constructor() {
            super(Cg),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.MTi = this.Pet("fontPreviewBody"),
            this.nEi = !1,
            this.ETi = "",
            this.CTi = null
        }
        $et() {
            this.o_i.textContent = self.lang("common.close-dialog")
        }
        async Xa(t, i) {
            if (Mg.K9(t))
                this.ETi = t;
            else {
                const i = await Mg.bhi(t);
                if (!i)
                    return;
                this.CTi = i,
                document.fonts.add(this.CTi),
                this.ETi = this.CTi.family
            }
            Mg.p.u("ui.dialogs.fontPreview"),
            this.Wa(self.h_(".caption", this.ETi));
            let e = self.lang(".example-text");
            Mg.p.j();
            for (let t = 0; t < Ig.length; ++t) {
                let i = document.createElement("span");
                i.className = "exampleText",
                i.textContent = e,
                i.style.fontSize = Ig[t] + "pt",
                i.style.fontFamily = Pg.has(this.ETi) ? this.ETi : `'${this.ETi}'`,
                this.MTi.appendChild(i)
            }
            return super.Xa(i)
        }
        xO() {
            this.ETi = "",
            this.CTi = null,
            Mg.Qs.L6(this.MTi)
        }
    }
    ;
    Mg.Qs.mk.iit.addEventListener("load", () => {
        Mg.Qs.Ks.rit(Tg, Gg)
    }
    )
}
{
    const Ag = self.t
      , Rg = Ag.bW(import.meta.url).getElementById("inputDialog")
      , kg = "Input"
      , Og = {
        caption: "",
        message: "",
        label: "",
        inputType: "text",
        _Ti: "",
        nvt: "",
        TTi: !1,
        spellcheck: !0,
        _nt: "",
        bnt: "",
        ITi: [],
        size: NaN
    }
      , Dg = Ag.Qs.Ks.PTi = class extends Ag.Qs.Ks {
        constructor() {
            super(Rg),
            this.f_i = this.Pet("inputMessage"),
            this.LGt = this.Pet("inputLabel"),
            this.uVt = this.Pet("input"),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.nEi = !1,
            this.GTi = null
        }
        $et() {}
        Xa(t, i) {
            Ag.IL(t),
            t = Object.assign({}, Og, t),
            Ag.zt(t.caption),
            Ag.p0(t.message),
            Ag.p0(t.label),
            Ag.gL(t.inputType),
            Ag.gL(t._Ti),
            Ag.gL(t.nvt),
            Ag.gL(t._nt),
            Ag.gL(t.bnt),
            Ag.D_t(t.ITi),
            Ag.Lj(t.size),
            this.Wa(t.caption),
            Ag.wQ(this.f_i, t.message),
            Ag.wQ(this.LGt, t.label),
            this.uVt.setAttribute("type", t.inputType || "text"),
            this.uVt.setAttribute("placeholder", t._Ti || ""),
            this.uVt.setAttribute("spellcheck", t.spellcheck ? "true" : "false"),
            Ag.ub(t.size) && (this.uVt.setAttribute("size", t.size),
            this.uVt.setAttribute("maxLength", t.size)),
            this.uVt.value = t.nvt || "",
            t.TTi && this.uVt.select(),
            this.o_i.textContent = t._nt || self.lang("common.ok"),
            this.FMt.textContent = t.bnt || self.lang("common.cancel"),
            this.GTi = t.ITi;
            const e = super.Xa(i);
            return this.uVt.focus(),
            e
        }
        xet() {
            for (const t of this.GTi)
                if (!t.check(this.uVt.value))
                    return void Ag.Qs.Fk.Uk.NT(this.uVt, "warning", t.ATi.title, t.ATi.message, {
                        align: "bottom"
                    });
            this.uVt.value ? this.sW(this.uVt.value) : this.sW(0)
        }
        xO() {
            this.Wa(null)
        }
    }
    ;
    Ag.Qs.mk.iit.addEventListener("load", function() {
        Ag.Qs.Ks.rit(kg, Dg)
    })
}
{
    const Fg = self.t
      , Lg = Fg.bW(import.meta.url).getElementById("inputCheckDialog")
      , Bg = "InputCheck"
      , Ug = {
        caption: "",
        message: "",
        label: "",
        inputType: "text",
        _Ti: "",
        nvt: "",
        spellcheck: !0,
        _nt: "",
        bnt: "",
        M_i: !1,
        x_i: ""
    }
      , Ng = Fg.Qs.Ks.RTi = class extends Fg.Qs.Ks {
        constructor() {
            super(Lg),
            this.f_i = this.Pet("inputMessage"),
            this.LGt = this.Pet("inputLabel"),
            this.uVt = this.Pet("input"),
            this.y_i = this.Pet("inputCheckbox"),
            this.b_i = this.Pet("inputCheckLabel"),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.nEi = !1
        }
        $et() {}
        Xa(t, i) {
            Fg.IL(t),
            t = Object.assign({}, Ug, t),
            Fg.zt(t.caption),
            Fg.p0(t.message),
            Fg.p0(t.label),
            Fg.gL(t.inputType),
            Fg.gL(t._Ti),
            Fg.gL(t.nvt),
            Fg.gL(t._nt),
            Fg.gL(t.bnt),
            Fg.gL(t.x_i),
            this.Wa(t.caption),
            Fg.wQ(this.f_i, t.message),
            Fg.wQ(this.LGt, t.label),
            this.uVt.setAttribute("type", t.inputType || "text"),
            this.uVt.setAttribute("placeholder", t._Ti || ""),
            this.uVt.setAttribute("spellcheck", t.spellcheck ? "true" : "false"),
            this.uVt.value = t.nvt || "",
            this.y_i.checked = !!t.M_i,
            this.b_i.textContent = t.x_i,
            this.o_i.textContent = t._nt || self.lang("common.ok"),
            this.FMt.textContent = t.bnt || self.lang("common.cancel");
            const e = super.Xa(i);
            return this.uVt.focus(),
            e
        }
        xet() {
            this.sW({
                value: this.uVt.value,
                check: this.y_i.checked
            })
        }
        xO() {
            this.Wa(null)
        }
    }
    ;
    Fg.Qs.mk.iit.addEventListener("load", function() {
        Fg.Qs.Ks.rit(Bg, Ng)
    })
}
{
    const jg = self.t
      , $g = self.assert;
    jg.Qs.g_ = class extends jg.Me {
        constructor(t, i, e) {
            jg.zt(t),
            jg.Ef(e, jg.Qs.g_.SQ),
            super(),
            this.Rdi = t,
            this.kTi = i,
            this.OTi = e || null,
            this.DTi = !1,
            this.OTi ? (this.ght = this.OTi.ght,
            this.ght.id = t,
            this.DTi = e.DTi) : (this.ght = jg.Qs.W_("ui-pane", null, t),
            document.body.appendChild(this.ght),
            jg.Qs.zvi(this)),
            this.FTi = [],
            this.LTi = !0,
            this.ght.removeAttribute(this.kTi ? "vgrid" : "hgrid"),
            this.ght.setAttribute(this.kTi ? "hgrid" : "vgrid", ""),
            this.BTi = null,
            this.UTi = !0,
            this.dn = !1
        }
        Lw() {
            if (this.dn)
                throw new Error("layout has already been released");
            if (jg.Qs.Wvi(this))
                throw new Error("main layout can not be removed");
            this.dn = !0,
            this.ght = null,
            this.OTi = null,
            this.BTi = null,
            jg.he(this)
        }
        NTi(t) {
            t ? (this.ght.style.position = "relative",
            this.ght.style.top = window.innerHeight + 100 + "px") : (this.ght.style.position = "",
            this.ght.style.top = "")
        }
        Bk() {
            return this.Rdi
        }
        jTi() {
            return this.kTi
        }
        $Ti() {
            return this.OTi
        }
        zTi(t) {
            return this.FTi.includes(t)
        }
        k_() {
            return this.ght
        }
        VTi() {
            return this.FTi
        }
        WTi() {
            return this.DTi
        }
        HTi(t) {
            if (t = !!t,
            this.DTi !== t) {
                this.DTi = t;
                for (let i = 0, e = this.FTi.length; i < e; ++i)
                    this.FTi[i].HTi(t)
            }
        }
        KTi(t, i, e) {
            this.qTi(t);
            let s = jg.v(jg.Qs.g_.SQ, this, t, i, e);
            return this.FTi.push(s),
            this.LTi = !0,
            this._0(),
            jg.Qs.TO.kxi(),
            s
        }
        XTi(t, i, e) {
            this.qTi(t);
            let s = jg.v(jg.Qs.g_.YTi, this, t, i, e);
            return s.JTi(t),
            jg.Qs.TO.kxi(),
            s
        }
        b_(t, i, e) {
            this.qTi(t);
            let s = jg.v(jg.Qs.g_.ZTi, this, t, i, e);
            return s.JTi(t),
            jg.Qs.TO.kxi(),
            s
        }
        wq(t, i, e) {
            this.qTi(t);
            let s = jg.v(jg.Qs.g_.QTi, this, t, i, e);
            return this.FTi.push(s),
            this.LTi = !0,
            this._0(),
            jg.Qs.TO.kxi(),
            s
        }
        qTi(t) {
            if (!jg.Qs.Jvi(t))
                throw new Error(`invalid CSS length: '${t}'`)
        }
        tIi(t) {
            let i = this.FTi.indexOf(t);
            -1 !== i && (this.FTi.splice(i, 1),
            this.ght.removeChild(t.k_()),
            this.LTi = !0,
            this._0())
        }
        iIi(t, i, e) {
            if ($g(!this.FTi.includes(t), "Cannot link a pane already in grid"),
            this.LTi = !0,
            i)
                e || (e = i.eIi()),
                $g(this.jTi() && ("left" === e || "right" === e) || !this.jTi() && ("top" === e || "bottom" === e), "Dock side incompatible with direction of this layout"),
                "left" === e || "top" === e ? (this.ght.insertBefore(t.k_(), i.k_()),
                this.FTi.splice(this.FTi.indexOf(i), 0, t)) : (this.ght.insertBefore(t.k_(), i.k_().nextSibling),
                this.FTi.splice(this.FTi.indexOf(i) + 1, 0, t));
            else {
                let i = t.eIi();
                i && $g(this.jTi() && ("left" === i || "right" === i) || !this.jTi() && ("top" === i || "bottom" === i), "Dock side incompatible with direction of this layout"),
                "left" === i || "top" === i ? (this.ght.insertBefore(t.k_(), this.ght.firstChild),
                this.FTi.unshift(t)) : (this.ght.appendChild(t.k_()),
                this.FTi.push(t))
            }
            this._0()
        }
        sIi(t, i) {
            let e = this.FTi.indexOf(t);
            $g(e >= 0, "Cannot find old pane to replace"),
            t.Lw(),
            this.FTi[e] = i,
            this.LTi = !0,
            this._0(),
            this.nIi()
        }
        rIi() {
            for (let t = 0; t < this.FTi.length; ++t) {
                if (this.FTi[t].hIi())
                    return !0
            }
            return !1
        }
        PF(t) {
            if (!this.LTi && !t)
                return;
            this.LTi = !1;
            let i = this.rIi()
              , e = ""
              , s = !1;
            for (let t = 0, n = this.FTi.length; t < n; ++t) {
                let r = this.FTi[t]
                  , h = r.oIi();
                !i && t > 0 && t === n - 1 ? r.aIi(!0) : t < n - 1 && r.aIi(!1),
                r.lIi() && (h = "1fr"),
                0 !== t && (e += " "),
                e += h,
                this.kTi ? r.uIi(t + 1) : r.cIi(t + 1),
                r.dIi() && !r.hIi() && "" !== r.fIi ? this.kTi ? r.pIi(s ? "right" : "left") : r.pIi(s ? "bottom" : "top") : s = !0
            }
            this.kTi ? (this.ght.style.gridTemplateColumns = e,
            this.ght.style.gridTemplateRows = "") : (this.ght.style.gridTemplateColumns = "",
            this.ght.style.gridTemplateRows = e)
        }
        KWt() {
            return this.UTi && (this.BTi = this.ght.getBoundingClientRect(),
            this.UTi = !1),
            this.BTi
        }
        ns() {
            let t = this.KWt();
            return t.right - t.left
        }
        er() {
            let t = this.KWt();
            return t.bottom - t.top
        }
        _0() {
            this.UTi = !0;
            for (let t = 0, i = this.FTi.length; t < i; ++t)
                this.FTi[t]._0()
        }
        gz(t, i) {
            jg.Ge(t),
            jg.Ge(i);
            let e = this.KWt();
            return t >= e.left && t < e.right && i >= e.top && i < e.bottom
        }
        mIi(t, i, e) {
            if (jg.Ge(t),
            jg.Ge(i),
            !this.gz(t, i))
                return null;
            for (let s = 0, n = this.FTi.length; s < n; ++s) {
                let n = this.FTi[s];
                if (n.gz(t, i, e)) {
                    if (n.wIi()) {
                        return n.gIi().mIi(t, i, e)
                    }
                    return n
                }
            }
            return null
        }
        yIi(t) {
            $g(!t != !this.jTi(), "No point subdividing a Layout in the same direction"),
            $g(this.OTi, "Subdividing the top level layout is not yet supported");
            let i = jg.v(jg.Qs.g_, jg.SUt(this.Rdi), t, this.OTi);
            this.OTi.bIi(i);
            let e = i.KTi("1fr");
            return e.vIi(this),
            this.ght = e.ght,
            this.ght.id = this.Rdi,
            this.DTi = e.DTi,
            this.LTi = !0,
            this._0(),
            this.nIi(),
            i.PF(),
            this.PF(),
            i
        }
        SIi(t, i) {
            jg.U(t, jg.Qs.g_.SQ),
            $g(!i != !this.jTi(), "No point subdividing a Layout in the same direction");
            let e = this.FTi.indexOf(t);
            $g(e >= 0, "Cannot find pane to split");
            let s, n = jg.SUt(this.Rdi);
            if (t.dIi()) {
                s = jg.v(jg.Qs.g_.YTi, this, t.oIi(), n);
                let e = t.eIi();
                e || (e = i ? "left" : "top"),
                s.xIi() || s.pIi(e)
            } else
                s = jg.v(jg.Qs.g_.SQ, this, t.oIi(), n);
            let r = s.MIi(jg.SUt(n), i);
            return r.FTi.push(t),
            this.FTi[e] = s,
            r.nIi(),
            this.nIi(),
            r.PF(),
            this.PF(),
            jg.Qs.TO.kxi(),
            r
        }
        EIi(t) {
            jg.U(t, jg.Qs.g_.SQ),
            $g(!(t instanceof jg.Qs.g_.QTi), "cannot replace tabbed pane with another tabbed pane");
            let i = this.FTi.indexOf(t);
            $g(i >= 0, "Cannot find pane to replace");
            let e = jg.SUt(this.Rdi)
              , s = jg.v(jg.Qs.g_.QTi, this, t.oIi(), e);
            return t instanceof jg.Qs.g_.YTi && (s.CIi = t.CIi,
            s.pIi(t.eIi())),
            jg.Qs.UO(t.k_()),
            this.FTi[i] = s,
            this.LTi = !0,
            this._0(),
            this.nIi(),
            this.PF(),
            jg.Qs.TO.kxi(),
            s
        }
        _Ii(t) {
            jg.U(t, jg.Qs.g_.QTi),
            $g(1 === t.HQ(), "expected tabbed pane with a single tab"),
            $g(!t.TIi(), "should keep tabbed pane");
            let i = t.eIi()
              , e = this.FTi.indexOf(t);
            $g(e >= 0, "Cannot find tabbed pane to remove");
            let s = t.IIi();
            s.PIi(null),
            s.GIi(t.oIi()),
            s.dIi() && s.pIi(i),
            t.Lw(),
            this.FTi[e] = s,
            this.LTi = !0,
            this._0(),
            this.nIi(),
            this.PF(),
            s.AIi()
        }
        nIi() {
            for (let t = 0, i = this.FTi.length; t < i; ++t) {
                let i = this.FTi[t]
                  , e = i.k_();
                jg.Qs.UO(e),
                this.ght.appendChild(e),
                i.H_ = this
            }
        }
        RIi() {
            return 1 === this.FTi.length
        }
        kIi(t) {
            !this.kTi != !t && (this.kTi = !!t,
            this.ght.removeAttribute(this.kTi ? "vgrid" : "hgrid"),
            this.ght.setAttribute(this.kTi ? "hgrid" : "vgrid", ""),
            this.LTi = !0,
            this._0())
        }
        OIi() {
            if ($g(this.FTi.length > 0, "Layout has ended up with 0 panes, how did this happen?"),
            this.FTi.length > 1)
                return this;
            return this.FTi[0].wIi() ? this.DIi() : this.OTi && this.OTi.H_ && this.OTi.H_.WTi() ? this.FIi() : this
        }
        DIi() {
            $g(1 === this.FTi.length, "Cannot merge down unless layout has exactly 1 pane");
            let t = this.FTi[0];
            $g(t.wIi(), "Cannot merge down unless pane has sub grid");
            let i = t.gIi()
              , e = i.Rdi;
            return this.FTi = i.FTi,
            t.aIi(!1),
            t.Lw(),
            this.nIi(),
            this.kTi = i.kTi,
            this.ght.removeAttribute(this.kTi ? "vgrid" : "hgrid"),
            this.ght.setAttribute(this.kTi ? "hgrid" : "vgrid", ""),
            this.Rdi = e,
            this.ght.id = e,
            this.LTi = !0,
            this._0(),
            this.PF(),
            this
        }
        FIi() {
            $g(1 === this.FTi.length, "Cannot merge up unless layout has exactly 1 pane");
            let t = this.FTi[0]
              , i = this.OTi.H_;
            $g(i && i.WTi(), "Must have parent grid which is dock target to merge up"),
            this.OTi.dIi() && t.GIi(this.OTi.oIi());
            const e = this.Rdi;
            return t.aIi(!1),
            i.sIi(this.OTi, t),
            i.PF(),
            i.Rdi.startsWith(e) && (i.Rdi = e,
            i.ght.id = e),
            i
        }
        LIi() {
            if (!this.WTi())
                return;
            let t = []
              , i = !1
              , e = !1;
            for (let s = 0, n = this.FTi.length; s < n; ++s) {
                let n = this.FTi[s]
                  , r = n.gIi();
                if (n.hIi() && (e = !0),
                n.dIi()) {
                    let t = n.eIi();
                    this.jTi() ? "top" !== t && "bottom" !== t || n.pIi(e ? "right" : "left") : "left" !== t && "right" !== t || n.pIi(e ? "bottom" : "top")
                }
                r && (r.jTi() === this.jTi() || r.RIi()) ? (this.Rdi.startsWith(r.Rdi) && (this.Rdi = r.Rdi,
                this.ght.id = r.Rdi),
                jg.Oo(t, r.FTi),
                n.Lw(),
                i = !0) : t.push(n)
            }
            i && (this.FTi = t,
            this.LTi = !0,
            this._0(),
            this.nIi(),
            this.PF()),
            this.OTi && this.OTi.H_ && this.OTi.H_.LIi()
        }
        GSt() {
            let t = 0;
            if (this.jTi())
                for (let i = 0, e = this.FTi.length; i < e; ++i) {
                    let e = this.FTi[i];
                    e.dIi() && !e.hIi() ? t += e.ns() : t += e.GSt()
                }
            else
                for (let i = 0, e = this.FTi.length; i < e; ++i) {
                    let e = this.FTi[i].GSt();
                    t < e && (t = e)
                }
            return t
        }
        MSt() {
            let t = 0;
            if (this.jTi())
                for (let i = 0, e = this.FTi.length; i < e; ++i) {
                    let e = this.FTi[i].MSt();
                    t < e && (t = e)
                }
            else
                for (let i = 0, e = this.FTi.length; i < e; ++i) {
                    let e = this.FTi[i];
                    e.dIi() && !e.hIi() ? t += e.er() : t += e.MSt()
                }
            return t
        }
        BIi(t) {
            let i = this.KWt()
              , e = 0;
            e = this.jTi() ? i.right - i.left : i.bottom - i.top;
            for (let i = 0, s = this.FTi.length; i < s; ++i) {
                let s = this.FTi[i];
                s !== t && (s.dIi() && !s.hIi() ? e -= this.jTi() ? s.ns() : s.er() : e -= this.jTi() ? s.GSt() : s.MSt())
            }
            return e < 0 ? 1 / 0 : Math.floor(.9 * e)
        }
        UIi() {
            let t = 0;
            for (let i = 0, e = this.FTi.length; i < e; ++i) {
                let e = this.FTi[i];
                this.jTi() ? t += Math.max(e.ns(), e.GSt()) : t += Math.max(e.er(), e.MSt())
            }
            return t
        }
        NIi(t, i) {
            jg.Ge(t),
            jg.Ge(i);
            let e = t / i;
            for (let t = 0, i = this.FTi.length; t < i; ++t) {
                let i = this.FTi[t];
                i.dIi() && !i.xIi() && (this.jTi() ? i.Cb(jg.rat(i.ns() * e), !0) : i.Ib(jg.rat(i.er() * e), !0))
            }
        }
        jIi() {
            let t = this.KWt()
              , i = 0;
            i = this.jTi() ? t.right - t.left : t.bottom - t.top;
            let e = this.UIi();
            e > i && this.NIi(i, e);
            for (let t = 0, i = this.FTi.length; t < i; ++t) {
                let i = this.FTi[t].gIi();
                i && i.jIi()
            }
        }
        Xvi() {
            this._0(),
            this.jIi(),
            this.$Ii()
        }
        $Ii(t) {
            for (let t of this.FTi)
                t.AIi()
        }
        static zIi(t) {
            if (t)
                for (let i of t)
                    if ("main" === i.id) {
                        if (!i.layout || !i.layout.children)
                            throw new Error("[Load UI State] main pane does not have a layout");
                        let t = i.layout.size;
                        for (let e of i.layout.children) {
                            t && !e.fixedSize && e.size.includes("px") && (jg.Qs.g_.VIi(t, "Load UI State"),
                            jg.Qs.g_.WIi(e.size, "Load UI State"));
                            let i = e.layout && e.layout.children;
                            i && 1 === i.length && "TabPane" !== e.type ? (jg.Qs.g_.WIi(e.size, "Load UI State"),
                            i[0].size = e.size,
                            jg.Qs.g_.HIi(i[0])) : jg.Qs.g_.HIi(e)
                        }
                    } else
                        jg.Qs.g_.HIi(i)
        }
        static HIi(t) {
            let i;
            switch ("midPane" === t.id && (t.size = "1fr",
            t.side = ""),
            jg.Qs.g_.WIi(t.size, "Load UI State"),
            t.type) {
            case "CaptionPane":
            case "TabPane":
            case "DockingPane":
                i = !0;
                break;
            case "Pane":
                i = !1;
                break;
            default:
                throw new Error("unknown type of pane")
            }
            if (t.layout && t.layout.children.length > 0) {
                let i = t.layout.size
                  , e = t.layout.frame;
                e && (jg.Qs.g_.KIi(e.width, "Load UI State"),
                jg.Qs.g_.KIi(e.height, "Load UI State"));
                for (let e of t.layout.children) {
                    i && !e.fixedSize && e.size.includes("px") && (jg.Qs.g_.VIi(i, "Load UI State"),
                    jg.Qs.g_.WIi(e.size, "Load UI State"));
                    let t = e.layout && e.layout.children;
                    t && 1 === t.length ? (jg.Qs.g_.WIi(e.size, "Load UI State"),
                    t[0].size = e.size,
                    jg.Qs.g_.HIi(t[0])) : jg.Qs.g_.HIi(e)
                }
            }
        }
        static qIi(t, i, e=!1) {
            if (t) {
                for (let s of t)
                    if ("main" === s.id) {
                        jg.Qs.g_.XIi(s);
                        let t = i.gIi();
                        for (let i of t.FTi.slice(0))
                            t.tIi(i),
                            i instanceof jg.Qs.g_.YTi && i.YIi();
                        $g(0 === t.FTi.length, "Layout subgrid should be empty!"),
                        $g(s.layout && s.layout.children, "Main pane does not have a layout");
                        let n = s.layout.size
                          , r = s.layout.isHorizontal ? i.ns() : i.er();
                        for (let t of s.layout.children) {
                            n && !t.fixedSize && t.size.includes("px") && (jg.Qs.g_.VIi(n, "Load UI State"),
                            jg.Qs.g_.WIi(t.size, "Load UI State"),
                            t.size = Math.floor(t.size.slice(0, -2) / n * r) + "px");
                            let s = t.layout && t.layout.children;
                            s && 1 === s.length && "TabPane" !== t.type ? (jg.Qs.g_.WIi(t.size, "Load UI State"),
                            s[0].size = t.size,
                            s[0].side = t.side,
                            s[0].docked = t.docked,
                            jg.Qs.g_.JIi(i, s[0], e)) : jg.Qs.g_.JIi(i, t, e)
                        }
                        t && t.PF(!0)
                    } else
                        jg.Qs.g_.JIi(i, s, e);
                jg.Qs.TO.kxi()
            }
        }
        static XIi(t) {
            if (!t.layout.tabSide && t.layout.children.length > 1) {
                const i = [];
                if (t.layout.isHorizontal)
                    for (let e of t.layout.children) {
                        if ("left" !== e.side)
                            break;
                        i.push(e)
                    }
                else
                    for (let e of t.layout.children) {
                        if ("top" !== e.side)
                            break;
                        i.push(e)
                    }
                i.length > 1 && (i.reverse(),
                t.layout.children.splice(0, i.length, ...i))
            }
        }
        static JIi(t, i, e) {
            let s = self.s1.ZIi(i.id, e);
            if (!s) {
                let t = i.id && self.app.L1(i.id);
                s = t && t.ez()
            }
            let n = s && s.jO()
              , r = t.gIi()
              , h = !0;
            if ("midPane" === i.id && (i.size = "1fr",
            i.side = ""),
            jg.Qs.g_.WIi(i.size, "Load UI State"),
            n)
                n.YIi(),
                n.eP(!0);
            else
                switch (i.type) {
                case "CaptionPane":
                    n = jg.v(jg.Qs.g_.ZTi, r, i.size, i.name, i.id);
                    break;
                case "TabPane":
                    n = jg.v(jg.Qs.g_.QTi, r, i.size, i.name, i.id);
                    break;
                case "DockingPane":
                    n = jg.v(jg.Qs.g_.YTi, r, i.size, i.name, i.id);
                    break;
                case "Pane":
                    n = r.KTi(i.size, i.name, i.id),
                    h = !1;
                    break;
                default:
                    throw new Error("unknown type of pane")
                }
            if (h)
                if (n.H_ && n.JTi(),
                i.docked)
                    if (t instanceof jg.Qs.g_.QTi)
                        t.TQ(n),
                        i.activeTab && t.QIi(n);
                    else {
                        const t = i.side ? "left" === i.side || "right" === i.side : null;
                        null !== t && r.kIi(t),
                        n.v1(r, i.side),
                        null !== t && i.size.includes("px") ? t ? n.Cb(+i.size.slice(0, -2), !0) : n.Ib(+i.size.slice(0, -2), !0) : n.GIi("1fr")
                    }
                else if (i.popup) {
                    const t = i.popupWindowScreenX ?? screen.width / 2
                      , e = i.popupWindowScreenY ?? screen.height / 2;
                    n.Z5t(t, e, i.popupWindowWidth, i.popupWindowHeight)
                } else if (!1 === i.docked) {
                    let t = i.position;
                    n.P_(),
                    n.Fo(t.x),
                    n.Eo(t.y),
                    n.Cb(t.width, !0),
                    n.Ib(t.height, !0)
                }
            if (n && "TabPane" !== i.type && i.layout && !n.wIi() && n.MIi(i.layout.id, i.layout.isHorizontal),
            r && r._0(),
            r && r.PF(!0),
            n && i.layout && i.layout.children.length > 0) {
                jg.Qs.g_.XIi(i);
                let t = n.gIi();
                if (t)
                    for (let i of t.FTi.slice(0))
                        t.tPi(i),
                        i instanceof jg.Qs.g_.YTi && i.YIi();
                let s = i.layout.size
                  , h = i.layout.frame
                  , o = null;
                h && (jg.Qs.g_.KIi(h.width, "Load UI State"),
                jg.Qs.g_.KIi(h.height, "Load UI State")),
                o = i.layout.isHorizontal ? h ? window.innerWidth / h.width : n.ns() / s : h ? window.innerHeight / h.height : n.er() / s;
                for (let t of i.layout.children) {
                    if (s && !t.fixedSize && t.size.includes("px")) {
                        jg.Qs.g_.VIi(s, "Load UI State"),
                        jg.Qs.g_.WIi(t.size, "Load UI State");
                        const i = t.size.slice(0, -2) * o;
                        t.size = Math.floor(i) + "px"
                    }
                    let i = t.layout && t.layout.children;
                    i && 1 === i.length && "TabPane" !== t.type ? (jg.Qs.g_.WIi(t.size, "Load UI State"),
                    i[0].size = t.size,
                    i[0].side = t.side,
                    i[0].docked = t.docked,
                    jg.Qs.g_.JIi(n, i[0], e)) : jg.Qs.g_.JIi(n, t, e)
                }
                r && r._0(),
                r && r.PF(!0)
            }
        }
        static iPi(t, i, e) {
            if (!jg.ub(t))
                throw new Error(`[${i}] ${e} size must be a finite number`);
            if (t <= 0)
                throw new Error(`[${i}] ${e} size must be greater than 0`)
        }
        static KIi(t, i="") {
            this.iPi(t, i, "frame")
        }
        static VIi(t, i="") {
            this.iPi(t, i, "layout")
        }
        static WIi(t, i="") {
            if (jg.K9(t)) {
                if (!jg.Qs.Jvi(t))
                    throw new Error(`[${i}] pane string size must be a valid css length`);
                this.iPi(parseFloat(t), i, "pane string")
            } else {
                if (!jg.ub(t))
                    throw new Error(`[${i}] invalid pane size`);
                this.iPi(t, i, "pane numeric")
            }
        }
    }
}
{
    const zg = self.t
      , Vg = self.assert
      , Wg = 20
      , Hg = 40
      , Kg = new Set;
    zg.Qs.g_.SQ = class extends zg.Qs.Window {
        constructor(t, i, e, s) {
            zg.U(t, zg.Qs.g_),
            zg.zt(i),
            zg.gL(e),
            zg.gL(s),
            e = e || s || "(no name)",
            super(zg.Qs.W_("ui-pane", t.k_(), s), e),
            this.H_ = t,
            this.$c = i.toLowerCase(),
            this.ePi = !1,
            this.Rdi = s || "",
            this.DTi = t.DTi,
            this.sPi = null,
            this.nPi = null,
            this.rPi = "",
            this.hPi = !0,
            this.vEi = Wg,
            this.SEi = Hg,
            this.oPi = 0,
            this.aPi = 0,
            this.lPi = null,
            this.uPi = null,
            this.cPi = !0,
            this.dPi = !0,
            this.fPi = !0,
            this.pPi = "",
            this.mPi = "",
            this.wPi = !1,
            Kg.add(this)
        }
        txi(t) {
            if (t)
                super.txi("PANE_" + t);
            else {
                const t = "abcdefghijklmnopqrstuvwxyz0123456789"
                  , i = t.length;
                let e = "";
                for (let s = 0; s < 11; ++s)
                    e += t.charAt(Math.floor(Math.random() * i));
                super.txi("PANE_" + e)
            }
        }
        gPi() {
            const t = this instanceof zg.Qs.g_.ZTi && this.TEi
              , i = this.H_ && this.H_.OTi
              , e = this.aP()
              , s = !("main" === this.Rdi) && (!(this instanceof zg.Qs.g_.YTi && void 0 !== this.CIi) || this.CIi);
            if (!t && s && (i || e))
                return;
            const n = {
                width: zg.Qs.Hvi(),
                height: zg.Qs.Kvi()
            };
            return zg.Qs.g_.KIi(n.width, "Save UI State"),
            zg.Qs.g_.KIi(n.height, "Save UI State"),
            this.yPi( (t, i) => {
                zg.Qs.g_.WIi(t.$c, "Save UI State");
                const e = {
                    id: t.Rdi,
                    size: t.$c,
                    name: t.Ftt,
                    devicePixelRatio: window.devicePixelRatio,
                    type: null,
                    activeTab: t.bPi()
                };
                if ("CaptionPane" === t.constructor.name && t.yk()) {
                    e.popup = !0,
                    e.popupWindowWidth = t.ns(),
                    e.popupWindowHeight = t.er();
                    const [i,s] = t.vPi();
                    Number.isFinite(i) && Number.isFinite(s) && (e.popupWindowScreenX = i,
                    e.popupWindowScreenY = s)
                }
                switch (t.constructor) {
                case zg.Qs.g_.QTi:
                    e.side = t.fIi,
                    e.type = "TabPane",
                    e.docked = "main" !== t.Rdi && t.CIi;
                    break;
                case zg.Qs.g_.ZTi:
                    e.caption = t.SPi,
                    e.side = t.fIi,
                    e.type = "CaptionPane",
                    e.docked = "main" !== t.Rdi && t.CIi;
                    break;
                case zg.Qs.g_.YTi:
                    e.side = t.fIi,
                    e.type = "DockingPane",
                    e.docked = "main" !== t.Rdi && t.CIi;
                    break;
                default:
                    e.type = "Pane"
                }
                if ("main" !== t.Rdi && !1 === t.CIi && (e.position = {
                    x: t.xPi,
                    y: t.MPi,
                    width: t.EPi,
                    height: t.CPi
                }),
                t.nPi) {
                    const i = t.nPi.kTi ? t.ns() : t.er();
                    zg.Qs.g_.VIi(i, "Save UI State"),
                    e.layout = {
                        frame: n,
                        tabSide: !1,
                        size: i,
                        id: t.nPi.Bk(),
                        isHorizontal: t.nPi.kTi,
                        children: []
                    }
                } else
                    "TabPane" === e.type && (e.layout = {
                        tabSide: t.TPi._Pi,
                        children: []
                    });
                return i && i.layout && i.layout.children.push(e),
                e
            }
            )
        }
        IPi() {
            return this.Kmt()
        }
        Lw() {
            if (!this.ght)
                throw new Error("removing pane which has already been removed");
            let t = new zg.Event("remove");
            t.QQ = this,
            this.dispatchEvent(t),
            this.nPi && (this.nPi.Lw(),
            this.nPi = null),
            Kg.delete(this),
            super.Lw()
        }
        td() {
            return this.H_
        }
        PPi() {
            if (this.xIi())
                throw new Error("pane has flex size");
            return parseInt(this.$c, 10)
        }
        oIi() {
            return this.$c
        }
        GIi(t) {
            if (zg.zt(t),
            t = t.toLowerCase(),
            !zg.Qs.Jvi(t))
                throw new Error(`invalid CSS length: '${t}'`);
            this.$c = t
        }
        xIi() {
            return this.$c.includes("fr")
        }
        hIi() {
            return this.xIi() || this.lIi()
        }
        lIi() {
            return this.ePi
        }
        aIi(t) {
            t = !!t,
            this.ePi = t
        }
        GPi() {
            this.hPi = !1
        }
        APi() {
            return !!this.hPi || "midPane" === this.Rdi
        }
        RPi(t) {
            for (const i of t) {
                if (i.APi())
                    if (i.nPi && i.nPi.FTi) {
                        if (i.RPi(i.nPi.FTi))
                            return !0
                    } else {
                        if (i.constructor !== zg.Qs.g_.QTi)
                            return !0;
                        if (i.RPi(i.TPi.kPi.map(t => t.Kc)))
                            return !0
                    }
            }
            return "midPane" === this.Rdi
        }
        yPi(t, i) {
            if (!this.APi())
                return;
            if (!this.Rdi)
                if (this.nPi && this.nPi.FTi) {
                    if (!this.RPi(this.nPi.FTi))
                        return
                } else if (this.constructor === zg.Qs.g_.QTi && !this.RPi(this.TPi.kPi.map(t => t.Kc)))
                    return;
            const e = t(this, i);
            if (this.nPi && this.nPi.FTi)
                for (let i of this.nPi.FTi)
                    i.yPi(t, e);
            else if (this.constructor === zg.Qs.g_.QTi)
                for (let i of this.TPi.kPi)
                    i.Kc.yPi(t, e);
            return e
        }
        lxi() {
            return !1
        }
        dIi() {
            return !1
        }
        WTi() {
            return this.DTi
        }
        HTi(t) {
            t = !!t,
            this.DTi !== t && (this.DTi = t,
            this.nPi && this.nPi.HTi(t))
        }
        PIi(t) {
            this.sPi = t
        }
        lP() {
            return this.sPi
        }
        aP() {
            return !!this.sPi
        }
        bPi() {
            return this.sPi && this.sPi.OPi() === this
        }
        tPi() {
            this.dispatchEvent(new zg.Event("beforeunlink")),
            this.H_ && (this.H_.tIi(this),
            this.H_.PF(),
            this.H_ = null),
            zg.Qs.UO(this.ght),
            this.DPi(),
            this.FPi(),
            this._0()
        }
        BO(t) {
            return !!this.ght.parentElement
        }
        BA() {
            return this.BO()
        }
        XO() {
            return this.BA()
        }
        MIi(t, i) {
            if (zg.zt(t),
            i = !!i,
            this.nPi)
                throw new Error("cannot create a sub-grid on a pane which already has one");
            return this.nPi = zg.v(zg.Qs.g_, t, i, this),
            this.nPi
        }
        vIi(t) {
            if (zg.U(t, zg.Qs.g_),
            this.nPi)
                throw new Error("cannot attach a sub grid on a pane which already has one");
            this.nPi = t,
            this.nPi.OTi = this;
            let i = t.jTi();
            this.ght.removeAttribute(i ? "vgrid" : "hgrid"),
            this.ght.setAttribute(i ? "hgrid" : "vgrid", "")
        }
        bIi(t) {
            zg.U(t, zg.Qs.g_),
            Vg(this.nPi, "Should not replace a sub grid on a pane which does not already have one"),
            Vg(this.nPi !== t, "Should not replace a sub grid with the same grid"),
            this.nPi = t,
            this.nPi.OTi = this;
            let i = new zg.Event("replacesubgrid");
            i.QQ = this,
            i.LPi = t,
            this.dispatchEvent(i)
        }
        gIi() {
            return this.nPi
        }
        wIi() {
            return !!this.nPi
        }
        gz(t, i, e) {
            return zg.Ge(t),
            zg.Ge(i),
            !(!e && this.wIi()) && super.gz(t, i)
        }
        j0() {
            this.ght.setAttribute("hide", "")
        }
        lQ() {
            this.ght.removeAttribute("hide")
        }
        yQ() {
            if (!this.cPi)
                return;
            this.cPi = !1;
            let t = this.ght.style.gridTemplateColumns;
            if (t)
                this.pPi = t,
                this.wPi = !0;
            else {
                let t = this.ght.style.gridTemplateRows;
                t && (this.pPi = t,
                this.wPi = !1)
            }
            this.mPi = this.oIi(),
            this.BPi(!1),
            this.PQ(!1)
        }
        gQ() {
            this.cPi || (this.cPi = !0,
            this.BPi(!0),
            this.PQ(!0),
            this.pPi && (this.wPi ? this.ght.style.gridTemplateColumns = this.pPi : this.ght.style.gridTemplateRows = this.pPi),
            this.mPi && this.GIi(this.mPi),
            this.pPi = "",
            this.mPi = "",
            this._0())
        }
        _Q() {
            if (this.cPi)
                return;
            let t = this.ght.style.gridTemplateColumns;
            if (t)
                this.pPi = t,
                this.wPi = !0;
            else {
                let t = this.ght.style.gridTemplateRows;
                t && (this.pPi = t,
                this.wPi = !1)
            }
            this.mPi = this.oIi()
        }
        BPi(t) {
            (t = !!t) !== this.dPi && (this.dPi = t,
            t ? this.ght.removeAttribute("disablegridtemplates") : this.ght.setAttribute("disablegridtemplates", ""))
        }
        PQ(t) {
            (t = !!t) !== this.fPi && (this.fPi = t,
            t ? this.ght.removeAttribute("disablegridstartandend") : this.ght.setAttribute("disablegridstartandend", ""))
        }
        DPi() {
            this.ght.style.gridColumn = "",
            this.ght.style.gridRow = ""
        }
        FPi() {
            this.rPi && (this.ght.removeAttribute(this.rPi),
            this._0()),
            this.rPi = ""
        }
        cIi(t) {
            zg.Ge(t),
            Vg(t >= 1 && t <= 20, "Invalid grid row number, must be 1-20");
            let i = "row" + t;
            this.rPi !== i && (this.FPi(),
            this.rPi = i,
            this.ght.setAttribute(this.rPi, ""),
            this._0())
        }
        uIi(t) {
            zg.Ge(t),
            Vg(t >= 1 && t <= 20, "Invalid grid column number, must be 1-20");
            let i = "col" + t;
            this.rPi !== i && (this.FPi(),
            this.rPi = i,
            this.ght.setAttribute(this.rPi, ""),
            this._0())
        }
        _0() {
            super._0(),
            this.nPi && this.nPi._0()
        }
        ka() {
            return this.KWt().left
        }
        Ra() {
            return this.KWt().top
        }
        ns() {
            let t = this.KWt();
            return t.right - t.left
        }
        er() {
            let t = this.KWt();
            return t.bottom - t.top
        }
        GSt() {
            return this.wIi() ? this.nPi.GSt() : this.vEi
        }
        MSt() {
            return this.wIi() ? this.nPi.MSt() : this.SEi
        }
        UPi() {
            "PANE_main" === this.$Si && this.oxi()
        }
        NPi(t=!0) {
            if ("PANE_main" === this.$Si) {
                const i = [];
                let e;
                for (const t of Kg)
                    e = t.gPi(),
                    e && i.push(e);
                return zg.S9t.y9t("log-pane") && console.info("Saving layout", JSON.stringify(i, null, 4)),
                t && this.hxi(i),
                i
            }
            return null
        }
        jPi() {
            Kg.delete(this)
        }
        AIi() {
            if (this.YSi)
                return;
            let t = this.ns()
              , i = this.er();
            if (t !== this.oPi || i !== this.aPi) {
                this.oPi = t,
                this.aPi = i;
                let e = new zg.Event("resize");
                e.QQ = this,
                this.dispatchEvent(e),
                this.nPi && this.nPi.$Ii()
            }
        }
        M_(t) {
            zg.Ef(t, zg.za),
            this.lPi = t ? t.clone() : null
        }
        G_() {
            return this.lPi ? this.lPi.clone() : null
        }
        O_(t) {
            zg.Ef(t, zg.za),
            this.uPi = t ? t.clone() : null
        }
        C_() {
            return this.uPi ? this.uPi.clone() : null
        }
        $Pi() {
            return ""
        }
        static zPi(t) {
            return !!Kg.has(t) && this.APi()
        }
    }
}
{
    const qg = self.t
      , Xg = self.assert
      , Yg = ["left", "top", "right", "bottom"]
      , Jg = 300
      , Zg = 350;
    let Qg = 0;
    const ty = 100
      , iy = 100
      , ey = 100
      , sy = 100;
    qg.Qs.g_.YTi = class extends qg.Qs.g_.SQ {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.ght.setAttribute("role", "section"),
            this.CIi = !0,
            this.VPi = !1,
            this.WPi = !1,
            this.HPi = !1,
            this.KPi = !0,
            this.qPi = 0,
            this.fIi = "",
            this.fEi = null,
            this.mF = t => this.mP(),
            this.ght.addEventListener("pointerdown", this.mF),
            this.XPi = ty,
            this.YPi = iy,
            this.xPi = 0,
            this.MPi = 0,
            this.EPi = 0,
            this.CPi = 0,
            this.vEi = ey,
            this.SEi = sy,
            this.JPi = !0,
            this.Ikt = !1,
            this.ZPi = null,
            this.QPi = 0,
            qg.Qs._O.tGi(this)
        }
        static iGi(t) {
            qg.Ge(t),
            Qg = t
        }
        JTi(t) {
            qg.gL(t),
            this.CIi = !1,
            this.ePi = !1,
            this.fIi = this.H_.jTi() ? "left" : "top";
            const i = parseInt(t, 10) || Jg;
            this.GIi(`${i}px`),
            this.DPi(),
            this.FPi(),
            this.eGi(),
            this.sGi(this.YPi, this.XPi, i, Qg || Zg),
            Qg = 0,
            document.body.appendChild(this.ght),
            this._0(),
            this.mP()
        }
        Lw() {
            this.JPi = !1,
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            qg.Qs._O.nGi(this),
            super.Lw()
        }
        dIi() {
            return !0
        }
        pIi(t) {
            qg.zt(t),
            Xg(Yg.includes(t), "Invalid dock side parameter"),
            this.fIi !== t && (this.rGi() && this.lIi() ? this.fIi = t : (this.YIi(),
            this.hGi(t),
            this.H_ && this.H_._0()))
        }
        oGi() {
            return this.VPi
        }
        aGi() {
            return this.KPi
        }
        bat() {
            this.KPi = !1
        }
        gat() {
            this.KPi = !0
        }
        lGi() {
            Xg(!this.sPi && !this.CIi, "should not be tabbed or docked to go in swipe-in mode"),
            this.VPi = !0,
            this.ght.setAttribute("swipe-in-" + this.fIi, ""),
            this.ght.removeAttribute("floating"),
            this.ght.setAttribute("role", "complementary"),
            this.uGi(!0),
            this.cGi(),
            qg.Qs._O.dGi(this)
        }
        fGi() {
            let t = document.activeElement;
            for (; t; )
                if (t = t.parentElement,
                t === this.ght)
                    return void document.activeElement.blur()
        }
        cUt(t) {
            t = !!t,
            this.pGi();
            let i = qg.Qs.Hvi();
            this.WPi = t,
            this.WPi && this.uGi(!1),
            this.WPi ? (this.mGi("left" === this.fIi ? 0 : i - this.ns()),
            qg.Qs.TO.Pz(this)) : (this.mGi("left" === this.fIi ? -this.ns() : i),
            this.fGi())
        }
        pGi() {
            this.fEi && (this.fEi.cancel(),
            this.ICi())
        }
        mGi(t) {
            if (qg.Ge(t),
            this.xPi === t)
                return void this.ICi();
            let i = this.xPi;
            this.Fo(t),
            self.app.jKt() ? (this.fEi = this.ght.animate([{
                transform: `translate(${i}px,${this.MPi}px)`
            }, {
                transform: `translate(${t}px,${this.MPi}px)`
            }], {
                duration: 200,
                easing: "ease"
            }),
            this.fEi.onfinish = () => this.ICi()) : this.ICi()
        }
        ICi() {
            this.fEi = null,
            this.WPi || this.uGi(!0)
        }
        uGi(t) {
            t = !!t,
            this.HPi !== t && (t ? (this.KWt(),
            this.HPi = !0,
            this.ght.style.display = "none",
            this.ght.setAttribute("aria-hidden", "true")) : (this.ght.style.display = "",
            this.ght.removeAttribute("aria-hidden"),
            this.HPi = !1,
            this._0()),
            this.wGi(!t))
        }
        _0() {
            this.HPi || super._0()
        }
        KWt() {
            return this.lxi() ? {
                left: this.xPi,
                top: this.MPi,
                right: this.xPi + this.EPi,
                bottom: this.MPi + this.CPi,
                width: this.EPi,
                height: this.CPi
            } : super.KWt()
        }
        gz(t, i, e) {
            return !(this.VPi && !this.WPi) && super.gz(t, i, e)
        }
        gGi(t) {
            qg.Ge(t),
            t = qg.Ne(t, 0, 1),
            this.pGi();
            let i = qg.Qs.Hvi()
              , e = "left" === this.fIi ? -this.ns() : i
              , s = "left" === this.fIi ? 0 : i - this.ns()
              , n = qg.rat(qg.mi(e, s, t));
            this.Fo(n),
            this.uGi(!1)
        }
        yGi() {
            return "left" === this.fIi ? (this.ka() + this.ns() + this.qPi) / 2 : (this.ka() + this.qPi - qg.Qs.Hvi()) / 2
        }
        cGi() {
            this.Eo(0),
            this.Ib(Math.min(qg.Qs.Kvi())),
            this.Cb(Math.min(qg.Qs.Hvi() - 50, 375)),
            this.cUt(this.WPi)
        }
        YIi() {
            this.fIi && this.ght.removeAttribute(`dock${this.fIi}`)
        }
        hGi(t) {
            t && (this.fIi = t),
            "" !== this.fIi && this.ght.setAttribute(`dock${this.fIi}`, "")
        }
        aIi(t) {
            (t = !!t) !== this.lIi() && (super.aIi(t),
            this.rGi() && (t ? this.YIi() : this.hGi(),
            this.H_._0()))
        }
        eIi() {
            return this.sPi ? this.sPi.fIi : this.fIi
        }
        rGi() {
            return this.CIi && !this.VPi
        }
        lxi() {
            return !this.CIi || this.VPi
        }
        eP(t) {
            t = !!t,
            this.JPi !== t && (this.JPi = t,
            this.JPi ? (this.ght.style.display = "",
            this._0()) : this.ght.style.display = "none")
        }
        BA() {
            return this.VPi ? this.WPi : this.JPi && super.BA()
        }
        d7t() {
            return !!this.dIi() && (this.lxi() || "right" === this.fIi)
        }
        bGi() {
            return !!this.dIi() && (this.lxi() || "left" === this.fIi)
        }
        vGi() {
            return !!this.dIi() && (this.lxi() || "bottom" === this.fIi)
        }
        SGi() {
            return !!this.dIi() && (this.lxi() || "top" === this.fIi)
        }
        WCi() {
            this.ght.style.transform = `translate(${this.xPi}px, ${this.MPi}px)`
        }
        Fo(t, i) {
            if (qg.Ge(t),
            t = qg.rat(t),
            i = !!i,
            this.rGi())
                throw new Error("cannot set the position of a docked pane");
            this.xPi = t,
            this.WCi(),
            this._0(),
            i || (this.XPi = t)
        }
        Eo(t, i) {
            if (qg.Ge(t),
            t = qg.rat(t),
            i = !!i,
            this.rGi())
                throw new Error("cannot set the position of a docked pane");
            this.MPi = t,
            this.WCi(),
            this._0(),
            i || (this.YPi = t)
        }
        xGi(t) {
            if ((t = !!t) ? ++this.QPi : --this.QPi,
            this.QPi < 0)
                throw new Error("invalid unlock");
            0 === this.QPi && this.AIi()
        }
        AIi() {
            this.QPi > 0 || this.Ikt || (++this.QPi,
            super.AIi(),
            this.rGi() && this.H_ && this.H_.$Ii(),
            --this.QPi)
        }
        Cb(t, i) {
            if (qg.Ge(t),
            t = qg.rat(t),
            i = !!i,
            this.rGi() && ("top" === this.fIi || "bottom" === this.fIi))
                throw new Error("cannot set width of vertically docked bar");
            let e = this.GSt();
            if (t < e && (t = e),
            this.rGi()) {
                if (!i) {
                    let i = this.H_.BIi(this);
                    t > i && (t = i)
                }
                this.GIi(`${t}px`),
                this.H_.PF(!0),
                this.H_._0()
            } else
                this.EPi = t,
                this.ght.style.width = `${t}px`,
                this._0();
            this.AIi()
        }
        Ib(t, i) {
            if (qg.Ge(t),
            t = qg.rat(t),
            i = !!i,
            this.rGi() && ("left" === this.fIi || "right" === this.fIi))
                throw new Error("cannot set height of horizontally docked bar");
            let e = this.MSt();
            if (t < e && (t = e),
            this.rGi()) {
                if (!i) {
                    let i = this.H_.BIi(this);
                    t > i && (t = i)
                }
                this.GIi(`${t}px`),
                this.H_.PF(!0),
                this.H_._0()
            } else
                this.CPi = t,
                this.ght.style.height = `${t}px`,
                this._0();
            this.AIi()
        }
        tPi() {
            super.tPi(),
            this.uxi(-1),
            this.fIi && (this.YIi(),
            this.fIi = ""),
            this.MGi(),
            this.H_ && this.H_._0(),
            qg.Qs.TO.kxi()
        }
        PIi(t) {
            super.PIi(t),
            t && (this.fIi = t.eIi(),
            this.CIi = !0,
            t.TIi() && (this.ZPi = t))
        }
        P_() {
            if (!this.CIi)
                return;
            const t = new qg.Event("beforeundock");
            t.QQ = this,
            this.dispatchEvent(t);
            const i = new qg.Event("beforeanyundock");
            i.QQ = this,
            qg.Qs._O.dispatchEvent(i),
            this.xGi(!0);
            let e = null
              , s = null;
            this.aP() && (s = this.sPi.KWt(),
            this.H_ = this.sPi.td(),
            this.fIi = this.sPi.eIi(),
            this.sPi.nGi(this),
            1 === this.sPi.HQ() && (e = this.sPi),
            this.sPi = null);
            let n = "left" === this.fIi || "right" === this.fIi;
            "" === this.fIi && (n = this.H_.jTi());
            let r, h = this.H_.$Ti();
            if (h && h.dIi()) {
                let t = h.eIi();
                n = "left" === t || "right" === t
            }
            s || (s = this.KWt()),
            n ? (r = s.right - s.left,
            r > window.innerWidth / 2 && (r = window.innerWidth / 2)) : (r = s.bottom - s.top,
            r > window.innerHeight / 2 && (r = window.innerHeight / 2)),
            r <= 0 && (r = Jg),
            this.H_.tIi(this),
            this.DPi(),
            this.H_.PF(),
            this.FPi(),
            this.YIi(),
            this.eGi(),
            this.sGi(this.YPi, this.XPi, r, Zg),
            this.GIi(`${r}px`),
            h && h.dIi() && h.fIi ? this.fIi = h.fIi : this.fIi || (this.fIi = n ? "left" : "top"),
            document.body.appendChild(this.ght),
            this.CIi = !1,
            this.ePi = !1,
            this._0(),
            this.H_ = this.H_.OIi(),
            this.H_.LIi(),
            e && !e.TIi() && (e.rGi() ? this.H_._Ii(e) : qg.Qs.g_.QTi.EGi(e)),
            this.mP(),
            this.xGi(!1),
            this.H_.$Ii();
            const o = new qg.Event("afterundock");
            o.QQ = this,
            this.dispatchEvent(o);
            const a = new qg.Event("afteranyundock");
            a.QQ = this,
            qg.Qs._O.dispatchEvent(a),
            this.ght.setAttribute("role", "complementary")
        }
        v1(t, i, e) {
            if (qg.Ef(t, qg.Qs.g_),
            qg.gL(i),
            qg.Ef(e, qg.Qs.g_.SQ),
            this.CIi)
                return;
            if (qg.kt.Y_)
                return this.fIi = "left" === i || "top" === i ? "left" : "right",
                void this.lGi();
            if (!t && !i && !e && this.ZPi)
                return this.ZPi.TQ(this),
                void this.ZPi.FQ(this);
            const s = new qg.Event("beforedock");
            s.QQ = this,
            this.dispatchEvent(s);
            const n = new qg.Event("beforeanydock");
            n.QQ = this,
            qg.Qs._O.dispatchEvent(n),
            this.xGi(!0),
            t || (t = this.H_),
            t.k_() || (t = qg.Qs._O.CGi(),
            Xg(t && t.k_(), "Nowhere to dock this pane to"));
            let r = i;
            if (i || (this.fIi = ""),
            e && e.dIi()) {
                let t = e.eIi();
                t && (r = t)
            }
            t.jTi() ? "top" === r ? r = "left" : "bottom" === r && (r = "right") : "left" === r ? r = "top" : "right" === r && (r = "bottom");
            let h = this.KWt()
              , o = "left" === r || "right" === r ? h.right - h.left : h.bottom - h.top;
            this.H_ = t,
            e && e.dIi() ? "left" === r || "right" === r ? e.xIi() ? o = Math.min(e.ns() / 2, Math.max(o, this.GSt())) : (o = Math.max(e.ns() / 2, this.GSt()),
            e.Cb(e.ns() / 2)) : "top" !== r && "bottom" !== r || (e.xIi() ? o = Math.min(e.er() / 2, Math.max(o, this.MSt())) : (o = Math.max(e.er() / 2, this.MSt()),
            e.Ib(e.er() / 2))) : e || ("left" === r || "right" === r ? o = Math.min(this.H_.ns() / 2, o) : "top" !== r && "bottom" !== r || (o = Math.min(this.H_.er() / 2, o))),
            this.hGi(r),
            this.CIi = !0,
            document.body.removeChild(this.ght),
            i && this.GIi(`${o}px`),
            this.MGi(),
            this.H_.iIi(this, e, i),
            this.H_.PF(),
            qg.Qs.TO.kxi(),
            this.xGi(!1);
            const a = new qg.Event("afterdock");
            a.QQ = this,
            this.dispatchEvent(a);
            const l = new qg.Event("afteranydock");
            l.QQ = this,
            qg.Qs._O.dispatchEvent(l),
            this.ght.setAttribute("role", "section")
        }
        Ggt() {
            this.Ikt = !0,
            this.P_(),
            this.Lw(),
            this.Ikt = !1
        }
        mP() {
            this.aP() ? (this.sPi.FQ(this),
            this.sPi.mP()) : super.mP()
        }
        _Gi(t) {
            if (t = !!t,
            !this.dIi() || this.rGi() || this.oGi())
                return;
            t && (this.Fo(this.XPi, !0),
            this.Eo(this.YPi, !0));
            let i = this.KWt()
              , e = window.innerWidth
              , s = window.innerHeight;
            i.right > e && this.Fo(Math.max(this.ka() - (i.right - e), 0), !0),
            i.left < 0 && this.Fo(this.ka() - i.left, !0),
            i.bottom > s && this.Eo(Math.max(this.Ra() - (i.bottom - s), 0), !0),
            i.top < 0 && this.Eo(this.Ra() - i.top, !0)
        }
        TGi() {
            let t = new qg.Event("activate");
            t.QQ = this,
            this.dispatchEvent(t)
        }
        wGi(t) {
            let i = new qg.Event("displaystylechange");
            i.QQ = this,
            i.visible = t,
            this.dispatchEvent(i)
        }
        zMi(t, i) {
            if (qg.Ge(t),
            qg.Ge(i),
            this.aP() || !this.fIi)
                return "";
            if (self.app.Kue().O0() && !qg.kt.Y_)
                return "";
            let e = this.KWt()
              , s = qg.Qs.f7t()
              , n = 2 * s
              , r = "";
            if (t > e.left + s && t < e.right - s && i > e.top + s && i < e.bottom - s ? r = "m" : qg.Qs.TO.Gxi() ? this.lIi() || (t >= e.left && t <= e.left + n ? i >= e.top && i <= e.top + n ? r = "nw" : i <= e.bottom && i >= e.bottom - n ? r = "sw" : i > e.top + n && i < e.bottom - n && t <= e.left + s && (r = "w") : t <= e.right && t >= e.right - n ? i >= e.top && i <= e.top + n ? r = "ne" : i <= e.bottom && i >= e.bottom - n ? r = "se" : i > e.top + n && i < e.bottom - n && t >= e.right - s && (r = "e") : t > e.left + n && t < e.right - n && (i >= e.top && i <= e.top + s ? r = "n" : i <= e.bottom && i >= e.bottom - s && (r = "s"))) : r = "",
            this.rGi())
                if ("left" === this.fIi)
                    r = "ne" === r || "se" === r || "e" === r ? "e" : "";
                else if ("right" === this.fIi)
                    r = "nw" === r || "sw" === r || "w" === r ? "w" : "";
                else if ("top" === this.fIi)
                    r = "sw" === r || "se" === r || "s" === r ? "s" : "";
                else if ("bottom" === this.fIi)
                    r = "nw" === r || "ne" === r || "n" === r ? "n" : "";
                else if ("tab" === this.fIi)
                    return "";
            return r
        }
        eGi() {
            let t = qg.Qs._O.IGi(this.XPi, this.YPi);
            this.XPi = t.x,
            this.YPi = t.y
        }
        sGi(t, i, e, s) {
            this.ght.setAttribute("floating", ""),
            this.xPi = i,
            this.MPi = t,
            this.WCi(),
            this.EPi = e,
            this.CPi = s,
            this.ght.style.width = `${e}px`,
            this.ght.style.height = `${s}px`
        }
        MGi() {
            this.ght.style.transform = "",
            this.ght.style.width = "",
            this.ght.style.height = "",
            this.ght.removeAttribute("floating")
        }
        static PGi(t) {
            qg.U(t, qg.Qs.g_.SQ),
            Xg(!(t instanceof qg.Qs.g_.QTi), "cannot replace tabbed pane with another tabbed pane"),
            Xg(t.dIi() && t.lxi(), "expected floating docking pane");
            let i = qg.SUt(t.Rdi)
              , e = qg.v(qg.Qs.g_.QTi, t.td(), t.oIi(), i);
            return e.P_(),
            e.pIi(t.eIi()),
            e.Cb(t.ns()),
            e.Ib(t.er()),
            e.Fo(t.ka()),
            e.Eo(t.Ra()),
            qg.Qs.UO(t.k_()),
            t._0(),
            qg.Qs.TO.kxi(),
            e
        }
    }
}
{
    const ny = self.t
      , ry = 350
      , hy = 2e3;
    let oy = -1;
    function ay() {
        for (const t of ly)
            t.GGi()
    }
    const ly = new Set;
    ny.Qs.g_.ZTi = class extends ny.Qs.g_.YTi {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.cEi = ny.Qs.W_("ui-caption", this.ght),
            this.SPi = this.La(),
            this.dEi = ny.Qs.W_("span", this.cEi, null, "pane-caption-text"),
            this.dEi.textContent = this.SPi,
            this.AGi = "",
            this.PEi = ny.v(ny.Qs.Fk.Eq, this.cEi),
            this.PEi.onclick = () => this.RGi(),
            this.kGi = !1,
            this.OGi = "",
            this.oit = ny.Qs.W_("ui-body", this.ght),
            this.oit.setAttribute("row2", ""),
            this.ght.setAttribute("captioned", ""),
            this.DGi = !1,
            this.FGi = !1,
            this.TEi = null,
            this.CEi = !1,
            this.LGi = !0,
            this.BGi = !1,
            this.IEi = t => this.R5t(),
            this.UGi = t => this.NGi(),
            this.jGi = NaN,
            this.$Gi = NaN,
            this.zGi = t => this.VGi(),
            this.mF = t => {
                t.button === ny.gF.sV && this.WGi(t.clientX, t.clientY, t.pointerId)
            }
            ,
            this.cEi.addEventListener("pointerdown", this.mF),
            this.yWt = t => this.HGi(),
            this.cEi.addEventListener("UIDoubleTap", this.yWt),
            this.GB = t => {
                t.preventDefault(),
                this.KGi(t.clientX, t.clientY)
            }
            ,
            this.cEi.addEventListener("contextmenu", this.GB),
            this.qGi = null,
            ly.add(this)
        }
        dCi() {
            return this.cEi
        }
        D_() {
            return this.oit
        }
        Lw() {
            this.BGi = !0,
            this.R5t(),
            this.cEi.removeEventListener("pointerdown", this.mF),
            this.cEi.removeEventListener("UIDoubleTap", this.yWt),
            this.cEi.removeEventListener("contextmenu", this.GB),
            this.mF = null,
            this.yWt = null,
            this.GB = null,
            this.qGi = null,
            this.PEi.he(),
            this.PEi = null,
            ny.Qs.UO(this.dEi),
            ny.Qs.UO(this.cEi),
            ny.Qs.UO(this.oit),
            this.dEi = null,
            this.cEi = null,
            this.oit = null,
            ly.delete(this),
            super.Lw()
        }
        hit(t, i) {
            this.kGi = !!t,
            this.kGi && (ny.zt(i),
            this.OGi = i)
        }
        async RGi() {
            const t = self.app
              , i = self.lang;
            if (this.kGi) {
                const e = "close-bar-dont-ask-again";
                if (!await localforage.getItem(e)) {
                    t.XGi("CloseBarPrompt", "Shown"),
                    ny.p.u("ui.bars.confirm-close-prompt");
                    const s = ny.Qs.Ks.qs("ConfirmCheck")
                      , n = s.Xa({
                        caption: i(".caption"),
                        message: ny.v(ny.ix, self.h_(".message", this.OGi), {
                            AU: !0
                        }),
                        _nt: i(".close-bar"),
                        x_i: i("common.dont-ask-again")
                    });
                    ny.p.j();
                    if (null === await n)
                        return void t.XGi("CloseBarPrompt", "Cancelled");
                    if (s.C_i()) {
                        t.XGi("CloseBarPrompt", "Confirmed-DontAskAgain");
                        try {
                            await localforage.setItem(e, !0)
                        } catch (t) {
                            (() => {})('Failed to save "Don\'t ask again" preference: ', t)
                        }
                    } else
                        t.XGi("CloseBarPrompt", "Confirmed")
                }
            }
            this.Ggt()
        }
        lGi() {
            super.lGi(),
            this.PEi.he(),
            this.PEi = null
        }
        WGi(t, i, e) {
            ny.Ge(t),
            ny.Ge(i),
            ny.Ge(e),
            ny.Qs._O.jMi(this, t, i, e)
        }
        HGi() {
            this.oGi() || (this.lxi() ? this.YGi() : this.P_())
        }
        Q5t() {
            return this.CEi
        }
        async Z5t(t, i, e, s) {
            if (ny.iM(t),
            ny.iM(i),
            ny.iM(e),
            ny.iM(s),
            this.CEi)
                throw new Error("already awaiting popup window");
            if (this.TEi)
                throw new Error("already in popup window");
            if (!this.Pxi())
                throw new Error("opening to popup window disabled for this pane");
            this.CEi = !0;
            let n = new ny.Event("beforepopupopen");
            n.QQ = this,
            this.dispatchEvent(n);
            let r = "window.html";
            ny.q8t() || (r += "?mode=dev"),
            Number.isFinite(t) && Number.isFinite(i) || !Number.isFinite(this.jGi) || !Number.isFinite(this.$Gi) || (t = this.jGi,
            i = this.$Gi),
            Number.isFinite(e) || (e = this.ns()),
            Number.isFinite(s) || (s = ry);
            try {
                const n = (await ny.Qs.zxi.Wxi(r, this.Rdi, e, s, t, i, e, s)).window;
                return this.jGi = n.screenX,
                this.$Gi = n.screenY,
                -1 === oy && (oy = globalThis.setInterval(ay, hy)),
                this.qCi(n),
                self.app.D1(),
                n.addEventListener("unload", t => this.KCi(n)),
                n
            } catch (t) {
                this.CEi = !1,
                ny.Qs.Ks.qs("OK").Xa(self.lang("ui.cannot-open-popup"));
                let i = new ny.Event("afterpopupclose");
                return i.QQ = this,
                this.dispatchEvent(i),
                null
            }
        }
        qCi(t) {
            this.rGi() ? (this.LGi = !0,
            this.P_()) : this.LGi = !1,
            this.eP(!1),
            ny.Qs.UO(this.oit),
            t.document.body.setAttribute("id", this.Rdi),
            t.document.body.className = this.k_().className,
            t.document.body.appendChild(this.oit),
            this.CEi = !1,
            this.TEi = t,
            window.addEventListener("unload", this.IEi),
            t.addEventListener("resize", this.UGi),
            t.addEventListener("focus", this.zGi),
            t.document.title = this.SPi,
            this.AIi(),
            this.VGi();
            let i = new ny.Event("afterpopupopen");
            i.QQ = this,
            this.dispatchEvent(i)
        }
        KCi(t) {
            if (this.BGi)
                return;
            let i = new ny.Event("beforepopupclose");
            i.QQ = this,
            this.dispatchEvent(i);
            for (const t of ny.Qs.mk.gMi(this.TEi))
                t.Pct(!0);
            ny.Qs.UO(this.oit),
            this.ght.appendChild(this.oit),
            this.TEi = null,
            t.removeEventListener("resize", this.UGi),
            t.removeEventListener("focus", this.zGi),
            window.removeEventListener("unload", this.IEi),
            this.dEi.textContent = this.SPi,
            this.eP(!0),
            this.LGi ? this.YGi() : this._Gi(),
            [...ly].some(t => t.yk()) || -1 !== oy && (globalThis.clearInterval(oy),
            oy = -1),
            i = new ny.Event("afterpopupclose"),
            i.QQ = this,
            this.dispatchEvent(i)
        }
        gz(t, i, e) {
            return !this.yk() && super.gz(t, i, e)
        }
        zMi(t, i) {
            return ny.Ge(t),
            ny.Ge(i),
            this.yk() ? "" : super.zMi(t, i)
        }
        R5t() {
            this.TEi && (this.TEi.close(),
            this.TEi = null,
            this.CEi = !1)
        }
        yk() {
            return !!this.TEi
        }
        T5t() {
            return this.TEi
        }
        NGi() {
            this.AIi(),
            globalThis.app.JGi()
        }
        VGi() {
            ny.Qs.TO.Pz(this)
        }
        GGi() {
            if (!this.yk())
                return;
            const t = this.TEi.screenX
              , i = this.TEi.screenY;
            this.jGi === t && this.$Gi === i || (this.jGi = t,
            this.$Gi = i,
            globalThis.app.JGi())
        }
        BA() {
            return super.BA() || this.yk()
        }
        eP(t) {
            t = !!t,
            this.BA() !== t && super.eP(t)
        }
        ns() {
            return this.TEi ? this.TEi.innerWidth : super.ns()
        }
        er() {
            return this.TEi ? this.TEi.innerHeight : super.er()
        }
        vPi() {
            return [this.jGi, this.$Gi]
        }
        lR() {
            return this.oit.clientWidth
        }
        QO() {
            return this.oit.clientHeight
        }
        KGi(t, i) {
            if (ny.Ge(t),
            ny.Ge(i),
            this.oGi())
                return;
            if (this.CEi)
                return;
            ny.p.u("ui.bars.captionMenu");
            let e = ny.v(ny.Qs.EA, this.cEi);
            ny.kt.FG && (e._A(null, this.rGi() ? self.lang(".undock") : self.lang(".dock"), this.yWt),
            this.Pxi() && e._A("open-popup", self.lang(".open-to-popup-window"), () => this.Z5t(), {
                MT: !0
            })),
            e._A("close", self.lang(".close"), () => this.RGi()),
            e.NT(t, i),
            ny.p.j()
        }
        R_(t) {
            ny.nu(t),
            this.qGi = t
        }
        A_(t) {
            this.qGi && this.qGi(t)
        }
        I_() {
            this.DGi = !0
        }
        ZGi(t) {
            (t = !!t) && !this.FGi ? (this.ght.setAttribute("caption-hidden", ""),
            this.cEi.setAttribute("hidden", "")) : !t && this.FGi && (this.ght.removeAttribute("caption-hidden"),
            this.cEi.removeAttribute("hidden")),
            this.FGi = t
        }
        PIi(t) {
            super.PIi(t),
            this.DGi && (t ? this.ZGi(t.TIi()) : this.ZGi(!1))
        }
        XE(t) {
            if (ny.zt(t),
            this.SPi === t)
                return;
            this.SPi = t,
            this.TEi ? this.TEi.document.title = t : this.dEi.textContent = t;
            let i = this.lP();
            i && i.QGi(this, this.SPi)
        }
        tAi() {
            return this.SPi
        }
        ZL(t) {
            if (ny.zt(t),
            this.AGi === t)
                return;
            this.AGi = t;
            let i = this.lP();
            i && i.iAi(this, this.AGi)
        }
        $Pi() {
            return this.AGi
        }
        M_(t) {
            super.M_(t);
            const i = this.lP();
            i && i.eAi(this)
        }
        O_(t) {
            super.O_(t);
            const i = this.lP();
            i && i.eAi(this)
        }
        P_() {
            this.ZGi(!1),
            super.P_()
        }
        v1(t, i, e) {
            this.DGi || (this.ZPi = null),
            super.v1(t, i, e)
        }
        YGi() {
            let t = this.ZPi ? null : this.eIi();
            this.v1(null, t)
        }
        static sAi() {
            for (const t of ly)
                t.Ggt()
        }
    }
}
{
    const uy = self.t
      , cy = self.assert
      , dy = -30
      , fy = -16
      , py = new Set(["top", "bottom"]);
    uy.Qs.g_.QTi = class extends uy.Qs.g_.YTi {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this._Pi = "",
            this.oit = uy.Qs.W_("ui-body", this.ght),
            this.TPi = uy.v(uy.Qs.Fk.nAi, this.ght, {
                rAi: !0,
                hAi: !0
            }),
            this.oAi = !1,
            this.aAi = null,
            this.Wgi = uy.v(uy.Rf, uy._f.Gf(this.TPi, "activetabchanged", t => this.lAi(t)), uy._f.Gf(this.TPi, "tearofftab", t => this.uAi(t)), uy._f.Gf(this.TPi, "tabmiddleclick", t => this.cAi(t.tab)), uy._f.Gf(this.TPi, "tabcontextmenu", t => {
                t.preventDefault(),
                this.dAi(t.tab, t.clientX, t.clientY)
            }
            ), uy._f.Gf(this.TPi, "tabclose", t => this.RQ(t.tab)), uy._f.Gf(uy.Qs.TO, "activewindowchange", t => this.kO())),
            this.fAi = -1,
            this.vq("bottom")
        }
        Lw() {
            -1 !== this.fAi && (window.clearTimeout(this.fAi),
            this.fAi = -1),
            this.Wgi.Ff(),
            this.Wgi = null,
            uy.Qs.UO(this.oit),
            this.oit = null,
            this.TPi.he(),
            this.TPi = null,
            super.Lw()
        }
        D_() {
            return this.oit
        }
        fP() {
            return this.TPi
        }
        HQ() {
            return this.TPi.HQ()
        }
        jq() {
            this.oAi = !0
        }
        TIi() {
            return this.oAi
        }
        vq(t) {
            if (!py.has(t))
                throw new Error(`invalid tab side '${t}'`);
            this._Pi !== t && ("bottom" === this._Pi ? (this.ght.removeAttribute("tabbed-bottom"),
            this.oit.removeAttribute("row1"),
            this.TPi.k_().removeAttribute("row2")) : (this.ght.removeAttribute("tabbed-top"),
            this.oit.removeAttribute("row2"),
            this.TPi.k_().removeAttribute("row1")),
            this._Pi = t,
            this.ght.setAttribute("tabbed-" + this._Pi, ""),
            "bottom" === this._Pi ? (this.oit.setAttribute("row1", ""),
            this.TPi.k_().setAttribute("row2", "")) : (this.oit.setAttribute("row2", ""),
            this.TPi.k_().setAttribute("row1", "")),
            this.TPi.vq(this._Pi))
        }
        IIi() {
            return cy(1 === this.TPi.HQ(), "should have only one tab"),
            this.TPi.pAi(0).Do()
        }
        TQ(t, i) {
            if (uy.U(t, uy.Qs.g_.SQ),
            t instanceof uy.Qs.g_.QTi) {
                let e = t.TPi;
                for (let t of e.tabs()) {
                    let e = t.Do();
                    e.tPi();
                    let s = this.TPi.OQ(e.La(), i);
                    s.goe(e),
                    s.dse(e.G_()),
                    s.MJt(e.C_()),
                    e.PIi(this)
                }
                t.Lw(),
                this.TPi.JQ(this.TPi.HQ() - 1)
            } else {
                let e;
                t.tPi(),
                t.PIi(this),
                e = t instanceof uy.Qs.g_.ZTi ? t.tAi() : t.La();
                let s = this.TPi.OQ(e, i);
                s.goe(t),
                s.dse(t.G_()),
                s.MJt(t.C_());
                const n = t.$Pi();
                n && s.mAi(n),
                this.aAi || this.wAi(t)
            }
            this.AIi()
        }
        gAi(t) {
            uy.U(t, uy.Qs.g_.SQ);
            for (let i of this.TPi.tabs())
                if (i.Do() === t)
                    return i;
            return null
        }
        yAi(t) {
            uy.U(t, uy.Qs.g_.SQ);
            let i = 0;
            for (let e of this.TPi.tabs()) {
                if (e.Do() === t)
                    return i;
                ++i
            }
            return -1
        }
        nGi(t) {
            uy.U(t, uy.Qs.g_.SQ);
            let i = this.yAi(t);
            cy(i > -1, "Cannot find tab for pane to remove"),
            this.aAi === t && (this.aAi = null),
            this.TPi.bAi(i),
            this.aAi && this.aAi._0()
        }
        OPi() {
            return this.aAi
        }
        QIi(t) {
            if (uy.U(t, uy.Qs.g_.SQ),
            this.aAi !== t)
                for (let i of this.TPi.tabs())
                    i.Do() === t && this.TPi.vAi(i)
        }
        wAi(t, i) {
            if (uy.U(t, uy.Qs.g_.SQ),
            uy.gL(i),
            this.aAi !== t) {
                if (this.aAi && this.aAi.tPi(),
                this.oit.appendChild(t.k_()),
                this.aAi = t,
                this.aAi._0(),
                this.aAi.AIi(),
                -1 !== this.fAi && window.clearTimeout(this.fAi),
                "removal" === i) {
                    const t = this.aAi;
                    this.fAi = window.setTimeout( () => {
                        if (uy.$M) {
                            if (uy.gn(t))
                                return
                        } else if (t.gn())
                            return;
                        t.TGi()
                    }
                    , 5)
                } else
                    this.aAi.TGi();
                uy.Qs.TO.Pz(this.aAi)
            }
        }
        AIi() {
            super.AIi(),
            this.aAi && this.aAi.AIi()
        }
        FQ(t) {
            uy.U(t, uy.Qs.g_.SQ);
            let i = this.yAi(t);
            i < 0 || this.TPi.JQ(i)
        }
        QGi(t, i) {
            uy.U(t, uy.Qs.g_.SQ),
            uy.zt(i);
            let e = this.gAi(t);
            e && e.UYt(i)
        }
        iAi(t, i) {
            uy.U(t, uy.Qs.g_.SQ),
            uy.zt(i);
            const e = this.gAi(t);
            e && e.mAi(i)
        }
        eAi(t) {
            uy.U(t, uy.Qs.g_.SQ);
            const i = this.gAi(t);
            i && (i.dse(t.G_()),
            i.MJt(t.C_()))
        }
        lAi(t) {
            let i = t.tab.Do();
            i && this.wAi(i, t.SAi)
        }
        uAi(t) {
            let i = t.tab.Do();
            self.app.mdt() || i.dIi() && (i.yxi(dy, fy),
            uy.Qs._O.xAi(i, t.pointerId),
            uy.Qs._O.oMi(t.clientX, t.clientY, t.pointerId),
            uy.Qs.TO.Pz(i),
            this.aAi && this.aAi._0())
        }
        dAi(t, i, e) {
            uy.U(t, uy.Qs.Fk.Tab),
            uy.Ge(i),
            uy.Ge(e);
            let s = t.MAi()
              , n = t.NQ()
              , r = t.EAi();
            if (!s && !n && !r)
                return;
            uy.p.u("ui.bars.tabPaneMenu");
            let h = uy.v(uy.Qs.EA, this.oit);
            const o = t.Do();
            o.A_(h),
            uy.kt.FG && s && h._A(null, self.lang(".undock"), () => o.P_()),
            n && h._A("close", self.lang(".close"), () => this.RQ(t)),
            this.HQ() > 1 && r && h._A(null, self.lang(".close-others"), () => this.CAi(t)),
            h.NT(i, e),
            uy.p.j()
        }
        RQ(t) {
            t.Do().Ggt()
        }
        cAi(t) {
            t.NQ() && t._Ai() && this.RQ(t)
        }
        CAi(t) {
            uy.U(t, uy.Qs.Fk.Tab);
            let i = t.Do()
              , e = [];
            for (let t of this.TPi.tabs()) {
                let s = t.Do();
                s !== i && e.push(s)
            }
            for (let t of e)
                t.Ggt()
        }
        _0() {
            super._0(),
            this.aAi && this.aAi._0()
        }
        TAi() {
            for (let t of this.TPi.tabs()) {
                if (!t.Do().dIi())
                    return !0
            }
            return !1
        }
        pxi() {
            return this.aAi || this
        }
        LQ() {
            return this.ght.hasAttribute("active")
        }
        kO() {
            let t = uy.Qs.TO.QU() === this.aAi;
            uy.Qs.eit(this.ght, "active", t)
        }
        static EGi(t) {
            uy.U(t, uy.Qs.g_.QTi),
            cy(!t.TIi(), "should keep tabbed pane"),
            uy.U(t, uy.Qs.g_.QTi),
            cy(1 === t.HQ(), "expected tab pane with a single tab");
            let i = t.IIi();
            i.P_(),
            i.pIi(t.eIi()),
            i.Cb(t.ns()),
            i.Ib(t.er()),
            i.Fo(t.ka()),
            i.Eo(t.Ra()),
            t.Lw()
        }
    }
}
{
    const my = self.t
      , wy = self.assert
      , gy = 80
      , yy = 40
      , by = 30
      , vy = 30
      , Sy = 40;
    let xy = !1
      , My = new Map
      , Ey = new Map
      , Cy = !1
      , _y = null
      , Ty = null
      , Iy = null
      , Py = new Map
      , Gy = new Map
      , Ay = []
      , Ry = []
      , ky = null;
    function Oy() {
        my.Qs.sk.hk(ky),
        ky = null
    }
    let Dy = NaN;
    function Fy() {
        if (isNaN(Dy)) {
            let t = my.Qs.pW("width", {
                className: "dockIndicator"
            });
            if (!t.endsWith("px"))
                throw new Error("CSS style for dock indicators must specify the size in units of 'px'");
            Dy = parseInt(t, 10) || Sy
        }
        return Dy
    }
    function Ly() {
        return window.innerWidth <= 600 ? 30 : 50
    }
    let By = []
      , Uy = []
      , Ny = null
      , jy = null
      , $y = null
      , zy = null
      , Vy = null
      , Wy = -2
      , Hy = 0
      , Ky = -2
      , qy = 0
      , Xy = 0;
    function Yy(t) {
        let i = t.eIi()
          , e = Uy.indexOf(t);
        wy(-1 !== e, "cannot find swipe-in pane");
        for (let t = 1, s = Uy.length; t < s; ++t) {
            let n = Uy[(e + t) % s];
            if (n.eIi() === i)
                return n
        }
        return t
    }
    const Jy = t => {
        t.button === my.gF.sV && xy && my.ev() && my.Qs._O.Axi(t.clientX, t.clientY, t.pointerId) && (t.preventDefault(),
        t.stopPropagation())
    }
    ;
    document.addEventListener("pointerdown", Jy);
    const Zy = t => {
        xy && my.ev() && my.Qs._O.oMi(t.clientX, t.clientY, t.pointerId) && (t.preventDefault(),
        t.stopPropagation())
    }
    ;
    document.addEventListener("pointermove", Zy);
    const Qy = t => {
        xy && my.ev() && (my.Qs._O.aMi(t.clientX, t.clientY, t.screenX, t.screenY, t.pointerId) && (t.preventDefault(),
        t.stopPropagation()),
        void 0 !== self.app && self.app.IAi() && self.app.D1())
    }
    ;
    document.addEventListener("pointerup", Qy);
    const tb = t => {
        Qy(t)
    }
    ;
    document.addEventListener("pointercancel", tb);
    const ib = "iOS" === my.kt.OS ? "after-resize" : "resize";
    window.addEventListener(ib, () => {
        if (void 0 === self.app || !self.app.IAi())
            return;
        const t = my.Qs.Vvi();
        t && t.Xvi(),
        my.Qs._O.PAi(),
        my.Qs._O.Yvi(!0),
        self.app.D1()
    }
    ),
    my.Qs.TO.addEventListener("zindexchanged", () => my.Qs._O.GAi()),
    my.Qs.mk.addEventListener("showmodal", () => {
        my.Qs._O.AAi() && my.Qs._O.RAi()
    }
    ),
    my.Qs.mk.addEventListener("hidemodal", () => {
        my.Qs.mk.wk() || my.Qs._O.kAi()
    }
    );
    class eb extends my.Event.v_ {
        constructor() {
            if (xy)
                throw new Error("already created DockManager");
            super(),
            xy = !0
        }
        OAi() {
            return !(!My.size && !Py.size)
        }
        tGi(t) {
            my.U(t, my.Qs.g_.YTi),
            wy(!By.includes(t), "Docking pane already exists in dock manager, don't try to add again"),
            By.push(t)
        }
        nGi(t) {
            my.U(t, my.Qs.g_.YTi);
            let i = By.indexOf(t);
            wy(i >= 0, "Cannot find docking pane to remove"),
            By.splice(i, 1)
        }
        dGi(t) {
            my.U(t, my.Qs.g_.YTi),
            wy(t.oGi(), "should be in swipe-in mode"),
            Uy.push(t),
            Ny || "left" !== t.eIi() ? jy || "right" !== t.eIi() || (jy = t) : Ny = t
        }
        GAi() {
            By.sort(my.Qs.Window.BD)
        }
        DAi(t, i) {
            my.Ge(t),
            my.Ge(i);
            for (let e = 0, s = By.length; e < s; ++e) {
                let s = By[e];
                if (!s.rGi() && (s.ka() === t && s.Ra() === i))
                    return !0
            }
            return !1
        }
        IGi(t, i) {
            for (my.Ge(t),
            my.Ge(i); this.DAi(t, i); )
                t += yy,
                i += yy;
            return {
                x: t,
                y: i
            }
        }
        jMi(t, i, e, s) {
            if (my.U(t, my.Qs.g_.YTi),
            my.Ge(i),
            my.Ge(e),
            my.Ge(s),
            t.oGi())
                return;
            if (Ey.has(t) || Gy.has(t))
                return;
            if (my.Qs.mk.wk() || my.Qs.EA.iSi(i, e, window))
                return;
            if (my.Qs._O.Axi(i, e, s),
            Py.has(s))
                return;
            let n = t;
            if (n.TGi(),
            n.aP()) {
                let t = n.lP();
                if (!t.TAi() && !t.TIi()) {
                    if (Ey.has(t))
                        return;
                    n = t
                }
            }
            My.set(s, n),
            Ey.set(n, s),
            n.mxi(i, e),
            n.yxi(n.ka() - i, n.Ra() - e),
            n.lxi() && n.mP()
        }
        FAi(t) {
            return my.Ge(t),
            t <= Ly()
        }
        LAi(t) {
            return my.Ge(t),
            t >= my.Qs.Hvi() - Ly()
        }
        lk(t) {
            return my.Ge(t),
            this.FAi(t) || this.LAi(t)
        }
        Axi(t, i, e) {
            if (my.Ge(t),
            my.Ge(i),
            my.Ge(e),
            My.has(e) || Py.has(e) || my.Qs.mk.wk() || my.Qs.EA.iSi(t, i, window))
                return !1;
            if (Uy.length && -2 === Wy) {
                if (this.FAi(t) && Ny)
                    return !(zy && !zy.aGi()) && (zy && "left" === zy.eIi() && (Ny = Yy(zy)),
                    Ny !== zy && ($y = Ny,
                    $y.mP(),
                    Wy = e,
                    Hy = 0),
                    !0);
                if (this.LAi(t) && jy)
                    return !(zy && !zy.aGi()) && (zy && "right" === zy.eIi() && (jy = Yy(zy)),
                    jy !== zy && ($y = jy,
                    $y.mP(),
                    Wy = e,
                    Hy = 0),
                    !0)
            }
            for (let s = By.length - 1; s >= 0; --s) {
                let n = By[s]
                  , r = n.zMi(t, i);
                if ("m" === r)
                    return n !== zy || -2 !== Wy || my.Qs.nk(t, i, n) || (Ky = e,
                    qy = t,
                    Xy = i,
                    Hy = "left" === zy.eIi() ? zy.ns() - t : zy.ka() - t),
                    !1;
                if (r && !n.oGi()) {
                    if (Ey.has(n))
                        return !1;
                    if (my.Qs.TO.jxi(t, i, n, window))
                        break;
                    return Py.set(e, n),
                    Gy.set(n, e),
                    n.Sxi(r),
                    n.mxi(t, i),
                    n.Mxi(n.ka(), n.Ra()),
                    n._xi(n.ns(), n.er()),
                    n.TGi(),
                    my.Qs._O.BAi(),
                    !0
                }
            }
            return !1
        }
        UAi(t, i) {
            my.Ge(t),
            my.Ge(i);
            for (let e = 0, s = Ay.length; e < s; ++e) {
                let s = Ay[e];
                if (s.gz(t, i))
                    return s
            }
            return null
        }
        eSi(t, i, e) {
            my.Ge(t),
            my.Ge(i),
            my.Ef(e, my.Qs.g_.SQ);
            for (let s = By.length - 1; s >= 0; --s) {
                let n = By[s];
                if (n === e)
                    return !1;
                if (n.lxi() && n.gz(t, i))
                    return !0
            }
            return !1
        }
        NAi(t, i, e) {
            if (my.Ge(t),
            my.Ge(i),
            my.U(e, my.Qs.g_.YTi),
            !my.Qs.mk.iSi(t, i, window) && !my.Qs.EA.iSi(t, i, window)) {
                for (let s = By.length - 1; s >= 0; --s) {
                    let n = By[s];
                    if (n !== e && n.lxi() && n.gz(t, i))
                        return n
                }
                return null
            }
        }
        oMi(t, i, e, s) {
            if (my.Ge(t),
            my.Ge(i),
            my.Ge(e),
            s = !!s,
            my.IF.Ofi(e))
                return !1;
            if (my.Qs.mk.wk() || my.Qs.EA.iSi(t, i, window))
                return Oy(),
                !1;
            if (zy && zy.oGi() && !zy.aGi())
                return !1;
            if (zy && Ky === e)
                return ("left" === zy.eIi() && t <= qy - by || "right" === zy.eIi() && t >= qy + by) && !my.Qs.nk(t, i, zy) && (Wy = Ky,
                Ky = -2,
                $y = zy,
                zy = null),
                Math.abs(Xy - i) >= vy && (Ky = -2),
                !0;
            if ($y && Wy === e)
                return my.Qs._O.jAi(t + Hy, i),
                !0;
            if (My.has(e))
                return my.Qs._O.$Ai(t, i, e, My.get(e), s),
                !0;
            if (Py.has(e))
                return my.Qs._O.zAi(t, i, e, Py.get(e)),
                !0;
            for (let e = By.length - 1; e >= 0; --e) {
                let s = By[e];
                if (s.oGi())
                    continue;
                let n = s.zMi(t, i);
                if (n) {
                    if (my.Qs.TO.jxi(t, i, s, window))
                        break;
                    if (ky)
                        "e" === n || "w" === n ? ky.Set("ew-resize") : "n" === n || "s" === n ? ky.Set("ns-resize") : "nw" === n || "se" === n ? ky.Set("nwse-resize") : "ne" === n || "sw" === n ? ky.Set("nesw-resize") : "m" === n && Oy();
                    else {
                        const e = {
                            onpointerdown: Jy,
                            onpointermove: Zy,
                            onpointerup: Qy,
                            onpointercancel: tb
                        };
                        "e" === n || "w" === n ? ky = my.Qs.sk.ik("ew-resize", document, t, i, e) : "n" === n || "s" === n ? ky = my.Qs.sk.ik("ns-resize", document, t, i, e) : "nw" === n || "se" === n ? ky = my.Qs.sk.ik("nwse-resize", document, t, i, e) : "ne" !== n && "sw" !== n || (ky = my.Qs.sk.ik("nesw-resize", document, t, i, e))
                    }
                    return !!ky
                }
            }
            return Oy(),
            !1
        }
        xAi(t, i) {
            my.U(t, my.Qs.g_.YTi),
            my.Ge(i),
            t.mP();
            let e = t.eIi()
              , s = "top" === e || "bottom" === e;
            t.P_(),
            s && t.yxi(t.ns() / -2, t.vxi()),
            My.set(i, t),
            Ey.set(t, i),
            1 === My.size ? my.Qs._O.VAi() : my.Qs._O.WAi()
        }
        jAi(t, i) {
            my.Ge(t),
            my.Ge(i);
            let e = my.Qs.Hvi()
              , s = $y.ns()
              , n = 0;
            if ("left" === $y.eIi()) {
                let i = t - s;
                i > 0 && (i = 0),
                n = t / s
            } else {
                let i = t
                  , r = e - s;
                t < r && (i = r),
                n = 1 - (t - r) / s
            }
            $y.gGi(n),
            zy && zy !== $y && zy.gGi(1 - n),
            this.HAi()
        }
        $Ai(t, i, e, s, n) {
            if (my.Ge(t),
            my.Ge(i),
            my.Ge(e),
            my.U(s, my.Qs.g_.YTi),
            n = !!n,
            s.QSi())
                return My.delete(e),
                Ey.delete(s),
                my.Qs._O.KAi(),
                my.Qs._O.WAi(),
                my.Qs._O.qAi(),
                _y = null,
                void (Ty = null);
            if (!s.lxi() && my.di(s.wxi(), s.gxi(), t, i) > gy && my.Qs._O.xAi(s, e),
            s.lxi()) {
                s.Fo(t + s.bxi()),
                s.Eo(i + s.vxi());
                const e = new my.Event("move");
                e.QQ = s,
                s.dispatchEvent(e);
                let r = my.Qs._O.UAi(t, i);
                n || 1 !== My.size ? my.Qs._O.WAi() : s.wxi() === t && s.gxi() === i || my.Qs._O.VAi(),
                r !== _y && (_y && my.Qs._O.qAi(),
                r && my.Qs._O.XAi(r, s),
                _y = r);
                let h = my.Qs.Vvi();
                if (h && 1 === My.size) {
                    let e = my.Qs._O.NAi(t, i, s);
                    e || (e = h.mIi(t, i, !0)),
                    e && !e.WTi() && (e = null),
                    Gy.has(e) && (e = null),
                    e !== Ty && (Ty && my.Qs._O.KAi(),
                    e && my.Qs._O.YAi(e),
                    Ty = e)
                }
            }
        }
        zAi(t, i, e, s) {
            if (my.Ge(t),
            my.Ge(i),
            my.Ge(e),
            my.U(s, my.Qs.g_.YTi),
            s.QSi())
                return Py.delete(e),
                void Gy.delete(s);
            let n = t - s.wxi()
              , r = i - s.gxi()
              , h = s.Exi()
              , o = s.Cxi()
              , a = s.Txi()
              , l = s.Ixi()
              , u = s.xxi();
            if ("e" === u || "se" === u || "ne" === u)
                s.Cb(a + n);
            else if ("w" === u || "sw" === u || "nw" === u) {
                if (s.lxi()) {
                    let t = h + a - s.GSt();
                    s.Fo(Math.min(h + n, t))
                }
                s.Cb(a - n)
            }
            if ("s" === u || "sw" === u || "se" === u)
                s.Ib(l + r);
            else if ("n" === u || "nw" === u || "ne" === u) {
                if (s.lxi()) {
                    let t = o + l - s.MSt();
                    s.Eo(Math.min(o + r, t))
                }
                s.Ib(l - r)
            }
        }
        aMi(t, i, e, s, n) {
            if (my.Ge(t),
            my.Ge(i),
            my.Ge(e),
            my.Ge(s),
            my.Ge(n),
            Ky === n && (Ky = -2),
            $y && Wy === n)
                return t += Hy,
                "left" === $y.eIi() ? t < $y.ns() / 2 ? ($y.cUt(!1),
                zy && zy !== $y && zy.cUt(!0),
                zy === $y && (zy = null)) : ($y.cUt(!0),
                zy && zy !== $y && zy.cUt(!1),
                zy = $y) : t > my.Qs.Hvi() - $y.ns() / 2 ? ($y.cUt(!1),
                zy && zy !== $y && zy.cUt(!0),
                zy === $y && (zy = null)) : ($y.cUt(!0),
                zy && zy !== $y && zy.cUt(!1),
                zy = $y),
                $y = null,
                Wy = -2,
                this.HAi(),
                !0;
            if (My.has(n)) {
                let r = My.get(n);
                if (my.Qs._O.$Ai(t, i, n, r, !0),
                _y)
                    my.Qs._O.JAi(r);
                else {
                    let t = r.KWt();
                    if (r instanceof my.Qs.g_.ZTi && r.Pxi() && (t.right <= 0 || t.bottom <= 0 || t.left > my.Qs.Hvi() || t.top > my.Qs.Kvi())) {
                        const t = self.devicePixelRatio;
                        r.Z5t(e / t + r.bxi(), s / t + r.vxi()).catch(t => {
                            r._Gi()
                        }
                        )
                    } else
                        r._Gi()
                }
                return My.delete(n),
                Ey.delete(r),
                my.Qs._O.KAi(),
                my.Qs._O.WAi(),
                my.Qs._O.qAi(),
                _y = null,
                Ty = null,
                !0
            }
            if (Py.has(n)) {
                let e = Py.get(n);
                return my.Qs._O.oMi(t, i, n),
                e._Gi(),
                Py.delete(n),
                Gy.delete(e),
                my.Qs._O.ZAi(),
                !0
            }
            return !1
        }
        BAi() {
            my.Qs._O.dispatchEvent(new my.Event("paneresizestart"))
        }
        ZAi() {
            my.Qs._O.dispatchEvent(new my.Event("paneresizeend"))
        }
        PAi() {
            for (let t = 0, i = By.length; t < i; ++t)
                By[t]._0()
        }
        Yvi(t) {
            t = !!t;
            for (let i of By)
                i._Gi(t);
            for (let t of Uy)
                t.cGi()
        }
        QAi(t) {
            if (my.U(t, my.Qs.g_),
            t.WTi())
                return t;
            let i, e, s = t.VTi();
            for (let t = 0, n = s.length; t < n; ++t)
                if (i = s[t].gIi(),
                i && (e = my.Qs._O.QAi(i),
                e))
                    return e;
            return null
        }
        CGi() {
            let t = my.Qs.Vvi();
            return t ? my.Qs._O.QAi(t) : null
        }
        tRi(t, i, e, s) {
            my.Ge(i),
            my.Ge(e),
            my.zt(s);
            let n = Fy()
              , r = my.v(my.Qs.iRi, t, i, e, n, n, s);
            return r.eRi(),
            r
        }
        VAi() {
            if (Cy)
                return;
            let t = my.Qs._O.CGi();
            if (!t)
                return;
            wy(t.WTi(), "Expected to find a dock target to show dock indicators for");
            let i = t.KWt();
            const e = Fy()
              , s = e / 2
              , n = e + s
              , r = (i.left + i.right) / 2 - s
              , h = (i.top + i.bottom) / 2 - s;
            let o = my.Qs._O.tRi(t, i.left + s, h - n, "left")
              , a = my.Qs._O.tRi(t, r + n, i.top + s, "top")
              , l = my.Qs._O.tRi(t, i.right - e - s, h - n, "right")
              , u = my.Qs._O.tRi(t, r + n, i.bottom - e - s, "bottom");
            Ay.push(o, a, l, u),
            Cy = !0
        }
        WAi() {
            my.Qs._O.qAi(),
            my.Qs._O.KAi();
            for (let t = 0, i = Ay.length; t < i; ++t)
                Ay[t].sRi();
            my.Io(Ay),
            Cy = !1
        }
        XAi(t, i) {
            my.U(t, my.Qs.iRi),
            my.U(i, my.Qs.g_.SQ),
            my.Qs._O.qAi();
            let e = t.nRi()
              , s = e.KWt()
              , n = i.KWt()
              , r = e instanceof my.Qs.g_.YTi
              , h = e instanceof my.Qs.g_.SQ && e.xIi() || !(e instanceof my.Qs.g_.SQ)
              , o = s.left
              , a = s.top
              , l = s.right - s.left
              , u = s.bottom - s.top
              , c = t.rRi();
            if ("left" === c || "right" === c) {
                const t = n.right - n.left;
                h ? l = Math.min(t, l / 2) : r ? l /= 2 : l = t
            } else if ("top" === c || "bottom" === c) {
                const t = n.bottom - n.top;
                h ? u = Math.min(t, u / 2) : r ? u /= 2 : u = t
            }
            "right" === c ? o = s.right - l : "bottom" === c && (a = s.bottom - u),
            Iy = my.v(my.Qs.hRi, o, a, l, u, c),
            Iy.eRi()
        }
        qAi() {
            Iy && (Iy.sRi(),
            Iy = null)
        }
        JAi(t) {
            my.U(t, my.Qs.g_.SQ),
            wy(t && _y, "Must have dragging pane and hovered indicator to dock");
            let i = _y.nRi();
            wy(i, "No dock target available when docking");
            let e = _y.rRi();
            i instanceof my.Qs.g_ ? my.Qs._O.oRi(t, i, e) : i instanceof my.Qs.g_.SQ ? my.Qs._O.aRi(t, i, e) : wy(!1, "Unexpected dock target type")
        }
        oRi(t, i, e) {
            if (my.U(t, my.Qs.g_.SQ),
            my.zt(e),
            wy("tab" !== e, "Cannot dock as tabbed to a layout"),
            i.RIi() && i.kIi("left" === e || "right" === e),
            i.jTi() && ("left" === e || "right" === e) || !i.jTi() && ("top" === e || "bottom" === e))
                t.v1(i, e);
            else {
                let s = i.yIi(!i.jTi());
                t.v1(s, e)
            }
        }
        aRi(t, i, e) {
            if (my.U(t, my.Qs.g_.SQ),
            my.zt(e),
            i instanceof my.Qs.g_.YTi && i.oGi())
                return;
            t.xGi(!0),
            i.xGi(!0);
            let s = i.td();
            if ("tab" === e)
                if (i instanceof my.Qs.g_.QTi)
                    i.TQ(t),
                    t instanceof my.Qs.g_.QTi || i.FQ(t);
                else {
                    let e;
                    e = i.dIi() && i.lxi() ? my.Qs.g_.YTi.PGi(i) : s.EIi(i),
                    e.TQ(i),
                    e.TQ(t),
                    t instanceof my.Qs.g_.QTi || e.FQ(t)
                }
            else if (s.jTi() && ("left" === e || "right" === e) || !s.jTi() && ("top" === e || "bottom" === e))
                t.v1(s, e, i);
            else {
                let n = s.jTi() ? i.er() : i.ns()
                  , r = i.ns() / 2
                  , h = i.er() / 2
                  , o = s.SIi(i, !s.jTi());
                if (t.v1(o, e),
                i.dIi())
                    if (t.lIi()) {
                        let t = o.VTi();
                        if (t.length >= 2) {
                            let i = t.at(-2);
                            s.jTi() ? i.Ib(n / 2) : i.Cb(n / 2)
                        }
                    } else
                        s.jTi() ? (!i.xIi() || t.er() > h) && t.Ib(n / 2) : (!i.xIi() || t.ns() > r) && t.Cb(n / 2);
                s.PF(!0)
            }
            i.xGi(!1),
            t.xGi(!1)
        }
        KAi() {
            for (let t = 0, i = Ry.length; t < i; ++t) {
                let i = Ry[t];
                i.sRi(),
                my.sii(Ay, i)
            }
            my.Io(Ry)
        }
        YAi(t) {
            if (!Cy)
                return;
            wy(t.WTi(), "Expected to find a dock target to show dock indicators for");
            let i = t.KWt();
            const e = Fy()
              , s = e / 2
              , n = e / 8
              , r = (i.left + i.right) / 2 - s
              , h = (i.top + i.bottom) / 2 - s;
            let o, a, l, u, c;
            t.dIi() && !t.rGi() || (o = my.Qs._O.tRi(t, r - n - e, h, "left"),
            a = my.Qs._O.tRi(t, r, h - n - e, "top"),
            l = my.Qs._O.tRi(t, r + n + e, h, "right"),
            u = my.Qs._O.tRi(t, r, h + n + e, "bottom"),
            Ay.push(o, a, l, u),
            Ry.push(o, a, l, u)),
            c = my.Qs._O.tRi(t, r, h, "tab"),
            Ay.push(c),
            Ry.push(c)
        }
        HAi() {
            let t = 0;
            $y && (t += $y.yGi()),
            zy && (t += zy.yGi());
            let i = new my.Event("swipeinviewoffset");
            i.offsetX = t,
            this.dispatchEvent(i)
        }
        AAi() {
            return zy && !$y
        }
        RAi(t=!0) {
            zy && (Vy = t ? zy : null,
            zy.cUt(!1),
            zy = null)
        }
        kAi() {
            Vy && (zy = Vy,
            zy.cUt(!0),
            Vy = null)
        }
        lRi(t) {
            zy = t,
            zy.cUt(!0)
        }
    }
    my.Qs._O = my.v(eb)
}
{
    const sb = self.t
      , nb = self.assert
      , rb = ["left", "top", "right", "bottom", "tab"]
      , hb = -50
      , ob = -50
      , ab = 50
      , lb = 50;
    let ub = {
        duration: 300,
        easing: "ease",
        direction: null
    };
    sb.Qs.iRi = class extends sb.Me {
        constructor(t, i, e, s, n, r) {
            sb.Ge(i),
            sb.Ge(e),
            sb.Ge(s),
            sb.Ge(n),
            super(),
            nb(t.WTi(), "Must be a dock target"),
            nb(rb.includes(r), "Invalid dock indicator side"),
            this.pSi = document.body,
            this.ght = sb.Qs.W_("div", this.pSi, null, "dockIndicator"),
            this.uRi = t,
            this.cRi = r,
            this.dRi = 0,
            this.fRi = 0,
            this.Ec = i,
            this.zc = e,
            this.Fx = s,
            this.Ex = n,
            this.fEi = null,
            this.pRi = !1,
            "left" === this.cRi ? this.dRi = ob : "top" === this.cRi ? this.fRi = hb : "right" === this.cRi ? this.dRi = ab : "bottom" === this.cRi && (this.fRi = lb)
        }
        mRi(t) {
            t = !!t,
            nb(!this.fEi, "Should not start new dock indicator animation if already playing animation");
            let i = [{
                transform: `translate(${this.Ec + this.dRi}px, ${this.zc + this.fRi}px)`,
                opacity: "0"
            }, {
                transform: `translate(${this.Ec}px, ${this.zc}px)`,
                opacity: "1"
            }];
            ub.direction = t ? "reverse" : "normal",
            this.fEi = this.ght.animate(i, ub),
            this.fEi.onfinish = t => this.wRi()
        }
        eRi() {
            self.app.jKt() ? this.mRi(!1) : this.wRi()
        }
        sRi() {
            nb(!this.pRi, "Animating out dock indicator which is already animating out"),
            this.pRi = !0,
            this.ght.style.transform = "",
            self.app.jKt() ? this.fEi ? this.fEi.playbackRate *= -1 : this.mRi(!0) : (this.gRi(),
            window.setTimeout( () => this.wRi(), 10))
        }
        wRi() {
            this.fEi = null,
            this.pRi ? this.Lw() : this.gRi()
        }
        gRi() {
            this.ght && (this.ght.style.transform = `translate(${this.Ec}px, ${this.zc}px)`)
        }
        Lw() {
            this.fEi = null,
            this.pRi = !1,
            this.pSi && this.ght && this.pSi.removeChild(this.ght),
            this.ght = null,
            this.pSi = null,
            this.uRi = null,
            sb.he(this)
        }
        gz(t, i) {
            return sb.Ge(t),
            sb.Ge(i),
            t >= this.Ec && i >= this.zc && t <= this.Ec + this.Fx && i <= this.zc + this.Ex
        }
        rRi() {
            return this.cRi
        }
        nRi() {
            return this.uRi
        }
    }
}
{
    const cb = self.t
      , db = "0.5"
      , fb = [{
        transform: "scale(0.9)",
        opacity: "0"
    }, {
        transform: "scale(1)",
        opacity: db
    }];
    let pb = {
        duration: 300,
        easing: "ease",
        fill: "forwards",
        direction: null
    };
    cb.Qs.hRi = class extends cb.Me {
        constructor(t, i, e, s, n) {
            switch (cb.Ge(t),
            cb.Ge(i),
            cb.Ge(e),
            cb.Ge(s),
            cb.zt(n),
            super(),
            this.pSi = document.body,
            this.ght = cb.Qs.W_("div", this.pSi, null, "dockGhost"),
            this.fEi = null,
            this.pRi = !1,
            n) {
            case "left":
                this.ght.classList.add("originLeft");
                break;
            case "top":
                this.ght.classList.add("originTop");
                break;
            case "right":
                this.ght.classList.add("originRight");
                break;
            case "bottom":
                this.ght.classList.add("originBottom");
                break;
            case "tab":
                this.ght.classList.add("originMiddle")
            }
            this.yRi(t, i, e, s)
        }
        mRi(t) {
            t = !!t,
            self.assert(!this.fEi, "Should not start new dock ghost animation if already playing animation"),
            pb.direction = t ? "reverse" : "normal",
            this.fEi = this.ght.animate(fb, pb),
            this.fEi.onfinish = t => this.bRi()
        }
        eRi() {
            self.app.jKt() ? this.mRi(!1) : this.ght.style.opacity = db
        }
        sRi() {
            this.pRi = !0,
            self.app.jKt() ? this.fEi ? this.fEi.playbackRate *= -1 : this.mRi(!0) : this.bRi()
        }
        bRi() {
            this.fEi = null,
            this.pRi && this.Lw()
        }
        Lw() {
            this.fEi = null,
            this.pRi = !1,
            this.pSi && this.ght && this.pSi.removeChild(this.ght),
            this.ght = null,
            this.pSi = null,
            cb.he(this)
        }
        yRi(t, i, e, s) {
            cb.Ge(t),
            cb.Ge(i),
            cb.Ge(e),
            cb.Ge(s),
            this.ght.style.left = `${t}px`,
            this.ght.style.top = `${i}px`,
            this.ght.style.width = `${e}px`,
            this.ght.style.height = `${s}px`
        }
    }
}
{
    const mb = self.t
      , wb = 1
      , gb = 2048
      , yb = new Set(["normal", "mask"]);
    let bb = new Map;
    const vb = {
        name: null,
        source: null,
        wd: !1
    };
    mb.Qs.d0 = class extends mb.Me {
        constructor(t, i, e, s, n) {
            mb.U(t, mb.Qs.vRi),
            mb.Ge(i),
            mb.Ge(e),
            mb.gL(s),
            mb.gL(n),
            super(),
            this.SRi = t;
            const r = mb.Qs.vRi.Dc();
            this.xRi = i,
            this.MRi = e,
            this.ERi = i / r,
            this.CRi = e / r,
            this._Ri = null,
            this.wTi = !1,
            this.TRi = null,
            this.zzt = null,
            this.IRi = !1,
            this.PRi = !1,
            this.Ftt = "",
            this.dmt = "",
            this.GRi(s, n)
        }
        GRi(t, i) {
            if (this.Ftt = t || "",
            this.dmt = i || "",
            this.IRi = !1,
            this.PRi = !1,
            this.zzt = new Promise(t => this.TRi = t),
            this.dmt) {
                let t = `${this.SRi.ARi()},${this.dmt}`;
                self.assert(!bb.has(t), "icon already cached"),
                bb.set(t, this)
            }
        }
        he() {
            if (!this.IRi) {
                if (this.IRi = !0,
                this.PRi = !1,
                this.SRi.RRi(this),
                this.dmt) {
                    let t = `${this.SRi.ARi()},${this.dmt}`;
                    bb.delete(t)
                }
                this.wTi = !1,
                this.TRi = null,
                this.zzt = null,
                this.Ftt = "<removed>",
                this.dmt = ""
            }
        }
        kRi() {
            return this.ARi() <= self.app.m4()
        }
        ORi() {
            return this.ARi() > self.app.m4() && this.ARi() <= self.app.Oq()
        }
        DRi() {
            return this.ARi() > self.app.Oq()
        }
        FRi() {
            return this.IRi
        }
        LRi() {
            return this.PRi
        }
        BRi() {
            return this.SRi
        }
        URi() {
            return this.SRi.URi()
        }
        NRi() {
            return this.SRi.NRi()
        }
        jRi() {
            return this.SRi.jRi()
        }
        $Ri() {
            return this.SRi.zRi()
        }
        ARi() {
            return this.SRi.ARi()
        }
        VRi() {
            return this.ERi
        }
        WRi() {
            return this.CRi
        }
        HRi() {
            return this.SRi.HRi()
        }
        KRi() {
            return this.xRi
        }
        qRi() {
            return this.MRi
        }
        XRi(t) {
            mb.Ef(t, mb.Qs.YRi),
            this._Ri = t
        }
        JRi() {
            return this._Ri
        }
        Q9() {
            return this.wTi
        }
        Yme() {
            this.wTi || (this.wTi = !0,
            this.TRi && (this.TRi(),
            this.TRi = null))
        }
        bEt() {
            return this.zzt
        }
        addEventListener(t, i, e) {
            return this.SRi.addEventListener(t, i, e)
        }
        removeEventListener(t, i, e) {
            return this.SRi.removeEventListener(t, i, e)
        }
        async ZRi(t, i) {
            mb.zt(t),
            mb.kQ(i),
            this.SRi.QRi();
            try {
                if (mb.QL.ImageBitmap && !i.wd) {
                    const e = await mb._4(t);
                    let s = null;
                    s = mb.QL.O9t ? await createImageBitmap(e, {
                        premultiplyAlpha: "none"
                    }) : await createImageBitmap(e),
                    this.PF(s, i)
                } else {
                    const e = await mb.$ii(t);
                    this.PF(e, i)
                }
            } catch (i) {
                console.error(`Error updating icon from URL '${t}': `, i),
                this.PRi = !0
            } finally {
                this.SRi.tki()
            }
        }
        PF(t, i) {
            mb.mti(t),
            mb.kQ(i),
            i && i.wd && (t.width <= 0 || t.height <= 0) && (i.width = this.ARi(),
            i.height = this.ARi()),
            this.SRi.iki(this, t, i)
        }
        async Zme(t) {
            mb.RH(t);
            const i = []
              , e = [];
            for (const s of t) {
                let t = null
                  , n = "normal";
                if (s instanceof mb.Qs.d0)
                    t = s;
                else if (mb.IL(s),
                t = s.icon,
                n = s.type,
                mb.U(t, mb.Qs.d0),
                !yb.has(n))
                    throw new Error("invalid overlay icon type");
                if (t.ARi() !== this.ARi())
                    throw new Error("overlay icons must be same size");
                e.push(t.bEt()),
                i.push({
                    icon: t,
                    type: n
                })
            }
            await Promise.all(e);
            for (const t of i)
                this.eki(t.icon, t.type)
        }
        eki(t, i) {
            this.BRi().eki(this, t, i)
        }
        static ski(t, i, e) {
            mb.zt(t),
            mb.Qs.d0.nki(i),
            mb.kQ(e),
            e = Object.assign({}, vb, e);
            let s = bb.get(`${i},${t}`);
            if (s)
                return s;
            let n = mb.Qs.hki.rki(i, e.name, e.source || t);
            return n.ZRi(t, {
                z_t: !0,
                wd: e.wd
            }),
            n
        }
        static hP(t, i, e) {
            mb.GC(t),
            mb.Qs.d0.nki(i),
            mb.kQ(e),
            e = Object.assign({}, vb, e);
            let s = mb.Qs.hki.rki(i, e.name, e.source);
            return t && s.PF(t, {
                z_t: !0,
                wd: e.wd
            }),
            s
        }
        static nki(t) {
            if (mb.Ge(t),
            t < wb || t > gb)
                throw new RangeError("invalid icon size")
        }
    }
}
{
    const Sb = self.t
      , xb = self.assert;
    let Mb = NaN;
    const Eb = 24
      , Cb = 48
      , _b = 96
      , Tb = 128
      , Ib = 256
      , Pb = 512
      , Gb = 1024
      , Ab = 2048
      , Rb = 50
      , kb = 250
      , Ob = 500
      , Db = {
        z_t: !1,
        wd: !1,
        width: 0,
        height: 0,
        oki: !1
    };
    let Fb = new Set;
    Sb.Qs.vRi = class extends Sb.Event.v_ {
        constructor(t, i) {
            super(),
            Sb.Qs.d0.nki(t),
            Sb.Ge(i);
            const e = Sb.Qs.vRi.Dc();
            this.aki = t,
            this.lki = Math.ceil(t * e),
            this.uki = Math.floor(t * e),
            this.cki = 2,
            this.dki = 0,
            this.fki = 0,
            this.pki = i,
            this.q_ = null,
            this.kM = null,
            this.mki = !1,
            this.wki = null,
            this.U_i = "",
            this.i$ = !1,
            this.gki = 0,
            this.yki = -1,
            this.bki = -1,
            this.vki = () => {
                this.yki = -1,
                this.Ski()
            }
            ,
            this.xki = [],
            this.Mki = [],
            this.Eki = [],
            this.Cki = [],
            this._ki = 0,
            this.Tki = 0,
            this.Iki = !1,
            this.aki <= Eb ? this.dki = Tb : this.aki <= Cb ? this.dki = Ib : this.aki <= _b ? this.dki = Pb : this.dki = Gb,
            this.dki * e > Ab && (this.dki = Math.floor(Ab / e));
            let s = this.dki / this.aki;
            this.fki = Math.ceil((this.lki + this.cki) * s),
            Fb.add(this)
        }
        static Dc() {
            return isNaN(Mb) && (Mb = self.devicePixelRatio),
            Mb
        }
        ARi() {
            return this.aki
        }
        HRi() {
            return this.lki
        }
        URi() {
            return this.dki
        }
        NRi() {
            return this.fki / Sb.Qs.vRi.Dc()
        }
        jRi() {
            return this.fki
        }
        Pki() {
            return this.q_
        }
        Gki() {
            return this.Eki.length - this.Cki.length
        }
        Aki() {
            return this.Iki && 0 === this.Cki.length
        }
        QRi() {
            this.gki++
        }
        tki() {
            if (this.gki--,
            this.gki < 0)
                throw new Error("too many pending icons removed")
        }
        Ski() {
            if (!this.q_)
                return;
            if (this.mki || this.U_i && !this.i$)
                return;
            this.mki = !0,
            this.i$ = !1,
            Sb.mf(this.Mki, this.xki),
            Sb.Io(this.xki),
            this.bki = Date.now();
            let t = this.U_i;
            Sb.Jdt(this.q_).then(t => (this.wki = t,
            this.U_i = URL.createObjectURL(t),
            Sb.$ii(this.U_i))).then(i => {
                this.mki = !1,
                this.Rki(),
                t && URL.revokeObjectURL(t)
            }
            )
        }
        Rki() {
            for (let t of this.Mki)
                t.Yme();
            Sb.Io(this.Mki),
            this.dispatchEvent(new Sb.Event("change")),
            this.i$ && this.kki()
        }
        zRi() {
            return this.U_i
        }
        kki() {
            if (this.mki || -1 !== this.yki)
                return;
            let t = self.app.iN() && Sb.kt.FG ? kb : Ob;
            Date.now() - this.bki >= t && (t = Rb),
            this.yki = window.setTimeout(this.vki, t)
        }
        Oki() {
            if (!this.kM && (this.q_ = document.createElement("canvas"),
            this.q_.width = this.fki,
            this.q_.height = this.fki,
            this.kM = this.q_.getContext("2d"),
            this.kM.imageSmoothingEnabled = !0,
            this.kM.imageSmoothingQuality = "high",
            !this.kM))
                throw new Error("failed to create 2d context")
        }
        Dki() {
            if (this.Iki)
                throw new Error("no icon spaces left");
            const t = this.lki + this.cki;
            this._ki += t,
            this._ki > this.fki - t && (this.Tki += t,
            this._ki = 0,
            this.Tki > this.fki - t && (this.Iki = !0))
        }
        RRi(t) {
            if (Sb.U(t, Sb.Qs.d0),
            t.BRi() !== this)
                throw new Error("icon from wrong sheet");
            xb(!this.Cki.includes(t), "icon already removed"),
            this.Cki.push(t),
            this.kM && this.kM.clearRect(t.KRi(), t.qRi(), this.lki, this.lki)
        }
        Fki(t, i) {
            if (Sb.gL(t),
            Sb.gL(i),
            this.Aki())
                throw new Error("icon sheet is already full");
            if (this.Cki.length) {
                let e = this.Cki.pop();
                return e.GRi(t, i),
                e
            }
            {
                let e = Sb.v(Sb.Qs.d0, this, this._ki, this.Tki, t, i);
                return this.Eki.push(e),
                this.Dki(),
                e
            }
        }
        iki(t, i, e) {
            if (Sb.U(t, Sb.Qs.d0),
            Sb.mti(i),
            Sb.kQ(e),
            e = Object.assign({}, Db, e),
            t.FRi())
                return;
            if (t.BRi() !== this)
                throw new Error("updating icon from wrong sheet");
            if (i instanceof Image && !i.complete)
                throw new Error("image is not complete");
            const s = i.width || e.width
              , n = i.height || e.height;
            if (!isFinite(s) || s <= 0 || !isFinite(n) || n <= 0)
                throw new Error("invalid size");
            let r, h;
            const o = Sb.Qs.vRi.Dc();
            if (s < this.aki && n < this.aki && !e.wd)
                r = s * o,
                h = n * o;
            else {
                let t = Math.max(s, n)
                  , i = this.uki / t;
                r = Math.min(s * i, this.uki),
                h = Math.min(n * i, this.uki)
            }
            let a = Math.max(Math.floor((this.lki - r) / 2), 0)
              , l = Math.max(Math.floor((this.lki - h) / 2), 0)
              , u = t.KRi()
              , c = t.qRi();
            this.Oki(),
            e.z_t || this.kM.clearRect(u, c, this.lki, this.lki),
            e.oki && (i = Sb.y4(i, r, h)),
            this.kM.drawImage(i, u + a, c + l, r, h),
            this.xki.push(t),
            this.i$ = !0,
            this.kki()
        }
        eki(t, i, e) {
            Sb.U(t, Sb.Qs.d0),
            Sb.U(i, Sb.Qs.d0),
            xb(t.BRi() === this, "icon from wrong sheet"),
            xb(t !== i, "icon and overlay are the same"),
            xb(t.ARi() === i.ARi(), "icon sizes must match"),
            Sb.zt(e),
            this.Oki();
            let s = this.HRi();
            const n = i.BRi();
            "mask" === e && (this.kM.globalCompositeOperation = "destination-out"),
            this.kM.drawImage(n.q_, i.KRi(), i.qRi(), s, s, t.KRi(), t.qRi(), s, s),
            "mask" === e && (this.kM.globalCompositeOperation = "source-over"),
            this.xki.push(t),
            this.i$ = !0,
            this.kki()
        }
        WE() {
            let t = 0;
            return this.q_ && (t += this.fki * this.fki * 4),
            this.wki && (t += this.wki.size),
            t
        }
        static all() {
            return Fb.values()
        }
    }
}
{
    const Lb = self.t
      , Bb = new Map;
    let Ub = 0;
    Lb.Qs.hki = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static Lki(t) {
            Lb.Qs.d0.nki(t);
            let i = Bb.get(t);
            if (i) {
                for (let t of i)
                    if (!t.Aki())
                        return t;
                let e = Lb.v(Lb.Qs.vRi, t, Ub++);
                return i.push(e),
                e
            }
            {
                let i = Lb.v(Lb.Qs.vRi, t, Ub++);
                return Bb.set(t, [i]),
                i
            }
        }
        static rki(t, i, e) {
            return Lb.Qs.d0.nki(t),
            Lb.gL(i),
            Lb.gL(e),
            Lb.Qs.hki.Lki(t).Fki(i, e)
        }
        static*Bki() {
            for (let t of Bb.values())
                yield*t
        }
    }
}
{
    const Nb = self.t;
    let jb = [{
        opacity: 0
    }, {
        opacity: 1
    }];
    const $b = {
        duration: 200,
        easing: "linear"
    }
      , zb = {
        icon: null,
        Uki: null,
        Nki: !1,
        ariaLabel: null
    };
    Nb.Qs._q = class extends Nb.Me {
        constructor(t, i) {
            let e;
            if (super(),
            t instanceof Nb.Qs.d0)
                e = Object.assign({}, zb),
                e.icon = t;
            else if ("number" == typeof t)
                e = Object.assign({}, zb),
                e.Uki = t;
            else {
                if (!Nb.Wft(t))
                    throw new TypeError("invalid parameter");
                e = Object.assign({}, zb, t)
            }
            this.G4 = null,
            this.aki = 0,
            this.jki = "",
            this.$ki = !!e.Nki,
            this.ght = document.createElement("ui-icon"),
            this.zki = "",
            this.Vki = null,
            this.Wki = null,
            this.Hki = !1,
            this.Kki = !1,
            this.fEi = null,
            this.JPi = !0,
            this.qki = t => this.Xki(),
            Nb.q9t(e.Uki) ? (Nb.Qs.d0.nki(e.Uki),
            this.aki = e.Uki) : this.Yki(e.icon),
            this.Jki(),
            this.Xki(),
            e.ariaLabel && (Nb.zt(e.ariaLabel),
            this.ght.setAttribute("aria-label", e.ariaLabel)),
            i && i.appendChild(this.ght)
        }
        he(t) {
            this.RRi(),
            this.qki = null,
            this.Wki = null,
            t || Nb.Qs.UO(this.ght),
            this.ght = null,
            Nb.he(this)
        }
        Zki(t) {
            const i = this.aki;
            this.ght.parentElement.insertBefore(t, this.ght),
            this.he(),
            t.setAttribute("width", i),
            t.setAttribute("height", i)
        }
        U_t(t) {
            if (Nb.nu(t),
            this.G4)
                throw new Error("already got an icon");
            this.Wki = t,
            this.Hki = !0
        }
        N_t() {
            if (!this.Wki)
                return;
            let t = this.Wki();
            Nb.Ef(t, Nb.Qs.d0),
            t && (t.Q9() || (this.Kki = !0),
            this.m0(t))
        }
        zo() {
            return this.aki
        }
        j6() {
            return this.G4
        }
        m0(t) {
            this.Wki = null,
            this.G4 !== t && (this.RRi(),
            this.Yki(t),
            this.Jki(),
            this.Xki())
        }
        b8(t) {
            if (this.ght.parentElement)
                return this.ght.parentElement !== t ? (Nb.Qs.UO(this.ght),
                void t.appendChild(this.ght)) : void 0;
            t.appendChild(this.ght)
        }
        k_() {
            return this.ght
        }
        Qki(t) {
            t = !!t,
            this.$ki !== t && (this.$ki = t,
            this.Jki(!0))
        }
        tOi() {
            return this.$ki
        }
        eP(t) {
            t = !!t,
            this.JPi !== t && (this.JPi = t,
            Nb.Qs.eit(this.ght, "hidden", !this.JPi))
        }
        j0() {
            this.eP(!1)
        }
        lQ() {
            this.eP(!0)
        }
        i7t(t) {
            Nb.zt(t),
            this.jki !== t && (this.jki = t,
            this.Jki(!0),
            this.Xki())
        }
        Yki(t) {
            Nb.Ef(t, Nb.Qs.d0),
            this.iOi(),
            this.G4 = t,
            this.G4 && (this.aki = this.G4.ARi(),
            this.G4.addEventListener("change", this.qki))
        }
        RRi() {
            this.G4 && (this.iOi(),
            this.G4.removeEventListener("change", this.qki),
            this.G4 = null)
        }
        eOi(t) {
            return Nb.Ge(t),
            this.jki ? `calc(${t}px * var(${this.jki}))` : `${t}px`
        }
        Jki(t) {
            if (!t && this.aki === this.Vki)
                return;
            const i = this.eOi(this.aki);
            this.ght.style.width = i,
            this.ght.style.height = i,
            this.$ki && (this.ght.style.borderRadius = this.aki / 2 + "px"),
            this.Vki = this.aki
        }
        Xki() {
            let t = this.zki;
            this.G4 && this.G4.Q9() ? (this.Kki && (this.sOi(),
            this.Kki = !1),
            t = `url("${this.G4.$Ri()}") ${this.eOi(-this.G4.VRi())} ${this.eOi(-this.G4.WRi())} / ${this.eOi(this.G4.NRi())} ${this.eOi(this.G4.NRi())} no-repeat`) : this.G4 || (t = ""),
            t !== this.zki && (this.ght.style.background = t,
            this.zki = t)
        }
        sOi() {
            Nb.QL.A9t && (this.fEi = this.ght.animate(jb, $b),
            this.fEi.onfinish = () => this.nOi())
        }
        iOi() {
            this.fEi && (this.fEi.cancel(),
            this.fEi = null)
        }
        nOi() {
            this.fEi = null
        }
    }
}
{
    const Vb = self.t;
    Vb.Qs.YRi = class extends Vb.Me {
        constructor(t, i, e) {
            super(),
            Vb.U(t, Vb.UMi),
            Vb.gL(i),
            Vb.IL(e),
            Vb.gL(e.name),
            Vb.gL(e.source),
            this.rOi = t,
            this.hOi = i || "",
            this.oOi = "",
            this.aOi = null,
            this.lOi = null,
            this.Ftt = e.name,
            this.dmt = e.source,
            this.Co = e.color,
            this.uOi = null,
            this.cOi = null,
            this.dOi = null,
            this.fOi = new Map,
            this.pOi = null,
            this.mOi = !1,
            this.hOi || (Vb.zt(e.wOi),
            this.oOi = e.wOi)
        }
        he() {
            this.uOi && this.uOi.he(),
            this.cOi && this.cOi.he(),
            this.dOi && this.dOi.he();
            for (const t of this.fOi.values())
                t.he();
            this.fOi.clear(),
            this.fOi = null,
            this.gOi(),
            this.uOi = null,
            this.cOi = null,
            this.dOi = null,
            this.rOi = null,
            this.hOi = "",
            this.oOi = "",
            this.aOi = null,
            this.lOi = null,
            this.Ftt = "",
            this.pOi = null,
            Vb.he(this)
        }
        yOi() {
            return this.Ftt.endsWith("-color")
        }
        $ii() {
            return this.lOi ? Promise.resolve(this.lOi) : this.pOi ? this.pOi : this.mOi ? Promise.resolve(null) : (this.pOi = this.bOi(),
            this.pOi)
        }
        async bOi() {
            try {
                if (!this.oOi) {
                    const t = await self.app.vOi(this.hOi);
                    this.gOi(),
                    this.oOi = t
                }
                const t = Vb.v(Vb.tI.Document);
                await t.Npi(this.oOi, "image/svg+xml"),
                this.aOi = t.aI().qpi(),
                await this.SOi();
                const i = new Blob([this.oOi],{
                    type: "image/svg+xml"
                })
                  , e = await Vb.bS(i);
                return await Vb.lre( () => this.xOi(e))
            } catch (t) {
                return console.error("Error fetching icon: ", t),
                this.mOi = !0,
                this.aOi = document.createElement("svg"),
                null
            }
        }
        gOi() {
            this.hOi.match(/^blob:.+$/) && URL.revokeObjectURL(this.hOi)
        }
        async SOi(t) {
            const i = this.Co || self.app.MOi();
            i && ("#000000" !== i || t) && await Vb.lre( () => {
                this.aOi.setAttribute("fill", i),
                this.aOi.hasAttribute("stroke") && "none" !== this.aOi.getAttribute("stroke") && this.aOi.setAttribute("stroke", i);
                const t = new XMLSerializer;
                this.oOi = t.serializeToString(this.aOi.ownerDocument)
            }
            )
        }
        async Jn(t) {
            this.Co === t || this.yOi() || (this.Co = t,
            await this.NSi())
        }
        async NSi() {
            if (!this.aOi || this.mOi)
                return;
            await this.SOi(!0);
            const t = new Blob([this.oOi],{
                type: "image/svg+xml"
            })
              , i = await Vb.bS(t);
            this.lOi = i,
            this.EOi({
                z_t: !1,
                wd: !0
            })
        }
        xOi(t) {
            return this.lOi = t,
            this.pOi = null,
            this.EOi({
                z_t: !0,
                wd: !0
            }),
            this.lOi
        }
        EOi(t) {
            this.uOi && this.uOi.PF(this.lOi, t),
            this.cOi && this.cOi.PF(this.lOi, t),
            this.dOi && this.dOi.PF(this.lOi, t);
            for (const i of this.fOi.values())
                i.PF(this.lOi, t)
        }
        uP() {
            return this.uOi || (this.uOi = Vb.Qs.d0.hP(this.lOi, this.rOi.m4(), {
                name: this.Ftt,
                source: this.dmt,
                wd: !0
            }),
            this.uOi.XRi(this),
            Vb.W8t() && this.$ii()),
            this.uOi
        }
        M8() {
            return this.cOi || (this.cOi = Vb.Qs.d0.hP(this.lOi, this.rOi.Oq(), {
                name: this.Ftt,
                source: this.dmt,
                wd: !0
            }),
            this.cOi.XRi(this),
            Vb.W8t() && this.$ii()),
            this.cOi
        }
        COi() {
            return this.dOi || (this.dOi = Vb.Qs.d0.hP(this.lOi, this.rOi.s8(), {
                name: this.Ftt,
                source: this.dmt,
                wd: !0
            }),
            this.dOi.XRi(this),
            Vb.W8t() && this.$ii()),
            this.dOi
        }
        j6(t) {
            Vb.Ge(t),
            self.assert(t > 0, "custom icon size must be larger than 0");
            const i = t.toString();
            if (this.fOi.has(i))
                return this.fOi.get(i);
            const e = Vb.Qs.d0.hP(this.lOi, t, {
                name: this.Ftt,
                source: this.dmt,
                wd: !0
            });
            return e.XRi(this),
            Vb.W8t() && this.$ii(),
            this.fOi.set(i, e),
            e
        }
        async _Oi() {
            return await this.$ii(),
            this.aOi
        }
        async HGt() {
            const t = await this._Oi();
            return t ? t.cloneNode(!0) : null
        }
    }
}
self.t.Qs.Fk = {};
{
    const Wb = self.t
      , Hb = [{
        opacity: "0"
    }, {
        opacity: "1"
    }]
      , Kb = Wb.S9t.y9t("slow-animations") ? 3e3 : 200
      , qb = {
        duration: Kb,
        easing: "ease-out"
    }
      , Xb = {
        duration: Kb,
        easing: "ease-out",
        direction: "reverse"
    };
    let Yb = null
      , Jb = null
      , Zb = !1
      , Qb = !1
      , tv = null
      , iv = 0
      , ev = -1;
    function sv() {
        -1 !== ev && (self.clearTimeout(ev),
        ev = -1)
    }
    Wb.Qs.Tvi = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static lQ(t) {
            if (tv = document,
            ++iv,
            sv(),
            Jb)
                return Qb && (Qb = !1,
                Zb = !0,
                Jb.playbackRate *= -1),
                void (window.C3_IsPopupWindow || Wb.Qs.zxi.nMi(!0));
            Yb || (window.C3_IsPopupWindow || Wb.Qs.zxi.nMi(!0),
            Yb = Wb.Qs.W_("div", tv.body, null, "c3-dimmer"),
            Zb = !0,
            Wb.QL.R9t || Yb.setAttribute("polyfill", ""),
            self.app.jKt() ? (Jb = Yb.animate(Hb, qb),
            Jb.onfinish = Wb.Qs.Tvi.ICi) : Wb.Qs.Tvi.ICi())
        }
        static j0() {
            0 !== iv && (--iv,
            iv > 0 || Yb && (window.C3_IsPopupWindow || Wb.Qs.zxi.nMi(!1),
            sv(),
            ev = self.setTimeout( () => {
                ev = -1,
                Wb.Qs.Tvi.ICi()
            }
            , 2 * Kb),
            Jb ? Zb && (Qb = !0,
            Zb = !1,
            Jb.playbackRate *= -1) : (Qb = !0,
            self.app.jKt() ? (Jb = Yb.animate(Hb, Xb),
            Jb.onfinish = Wb.Qs.Tvi.ICi) : Wb.Qs.Tvi.ICi())))
        }
        static TOi() {
            Yb && (Yb.style.backgroundColor = "rgba(128, 0, 0, 0.4)")
        }
        static ICi() {
            Qb && (sv(),
            Wb.Qs.UO(Yb),
            Yb = null),
            Jb = null,
            tv = null,
            Zb = !1,
            Qb = !1
        }
    }
}
{
    const nv = self.t
      , rv = [{
        opacity: "0"
    }, {
        opacity: "1"
    }]
      , hv = nv.S9t.y9t("slow-animations") ? 3e3 : 200
      , ov = 350
      , av = {
        duration: hv,
        easing: "ease-out"
    }
      , lv = {
        duration: hv,
        easing: "ease-out",
        direction: "reverse"
    }
      , uv = {
        message: null,
        IOi: "outside-auto",
        POi: "",
        GOi: 12,
        AOi: !0,
        ROi: !0,
        kOi: !1,
        OOi: !1
    };
    let cv = "outside-auto"
      , dv = ""
      , fv = 12
      , pv = !0
      , mv = !0
      , wv = !1
      , gv = !1;
    const yv = 6;
    let bv = null
      , vv = null
      , Sv = null
      , xv = null
      , Mv = null
      , Ev = null
      , Cv = null
      , _v = null
      , Tv = null
      , Iv = null
      , Pv = null
      , Gv = null
      , Av = !1
      , Rv = !1;
    window.addEventListener("resize", async () => {
        bv && xv && (await nv.mii(),
        nv.Qs.FOi.DOi())
    }
    ),
    nv.Qs.mk.addEventListener("dialogpositioningchange", () => {
        vv && nv.Qs.FOi.DOi()
    }
    );
    const kv = new Set(["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", " ", "PageUp", "PageDown", "Home", "End"]);
    function Ov(t) {
        ("Tab" === t.key || pv && kv.has(t.key)) && (t.preventDefault(),
        t.stopPropagation())
    }
    function Dv(t) {
        const i = nv.Rect.nJt(bv.getBoundingClientRect());
        "#document" !== t.target.nodeName && (i.nB(t.clientX, t.clientY) || t.target === _v || nv.TP(t.target, _v) || nv.Fft(t.target, ["ui-menu"]) || nv.HEt(t.target, ["autoCompleteWrap"]) || nv.HEt(t.target, ["construct-monaco-overlay"])) || (t.preventDefault(),
        t.stopPropagation())
    }
    nv.Qs.FOi = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static lQ(t, i) {
            if (nv.ibt(t),
            bv = t,
            i = Object.assign({}, uv, i),
            fv = i.GOi,
            pv = !!i.AOi,
            mv = !!i.ROi,
            wv = !!i.kOi,
            gv = !!i.OOi,
            Sv = nv.xii(bv),
            Sv === document.body ? Sv = null : (nv.Qs.x5(bv, Sv),
            pv && (Sv.addEventListener("scroll", nv.Qs.Pdt, {
                capture: !0,
                passive: !1
            }),
            Sv.addEventListener("wheel", nv.Qs.Pdt, {
                capture: !0,
                passive: !1
            }))),
            window.addEventListener("pointerdown", Dv, {
                capture: !0,
                passive: !1
            }),
            window.addEventListener("pointermove", Dv, {
                capture: !0,
                passive: !1
            }),
            window.addEventListener("pointerup", Dv, {
                capture: !0,
                passive: !1
            }),
            gv && window.addEventListener("contextmenu", nv.Qs.gdt, {
                capture: !0
            }),
            wv ? nv.Qs.mk.LMi(!1) : mv && nv.Qs.mk.OMi(!1),
            vv = nv.Sii(bv, "dialog"),
            xv && (vv ? vv.appendChild(xv) : document.body.appendChild(xv)),
            Gv && Rv && (Rv = !1,
            Gv.playbackRate *= -1),
            Av = !0,
            !xv) {
                xv = nv.Qs.W_("div", vv || document.body, null, "c3-dimmer-cutout-container");
                for (let t = 0; t < 4; ++t)
                    nv.Qs.W_("div", xv, null, "c3-dimmer-cutout-filler");
                Mv = nv.Qs.W_("div", xv, null, "c3-dimmer-cutout-gap");
                for (let t = 0; t < 4; ++t)
                    nv.Qs.W_("div", xv, null, "c3-dimmer-cutout-filler");
                for (let t = 0; t < 4; ++t)
                    nv.Qs.W_("div", Mv, null, "c3-dimmer-gap-filler");
                nv.Qs.W_("div", Mv, null, "c3-dimmer-gap-gap");
                for (let t = 0; t < 4; ++t)
                    nv.Qs.W_("div", Mv, null, "c3-dimmer-gap-filler");
                Ev = nv.Qs.W_("div", xv, null, "c3-dimmer-cutout-outline"),
                Cv = nv.Qs.W_("div", xv, null, "c3-dimmer-smallwindowmessage"),
                Cv.textContent = self.lang("tours.window-too-small")
            }
            i.message ? (cv = i.IOi,
            dv = i.POi,
            _v || (_v = nv.Qs.W_("div", xv, null, "c3-dimmer-cutout-message"),
            Tv = nv.Qs.W_("div", _v),
            Iv = nv.Qs.W_("div", _v),
            Pv = nv.Qs.W_("div", xv, null, "c3-dimmer-cutout-message-arrow")),
            nv.wQ(Tv, i.message),
            Iv.className = "",
            nv.Qs.L6(Iv)) : (nv.Qs.UO(_v),
            nv.Qs.UO(Pv),
            _v = null,
            Tv = null,
            Iv = null,
            Pv = null),
            nv.Qs.FOi.DOi(),
            requestAnimationFrame( () => nv.Qs.FOi.DOi()),
            nv.Qs.TO.$xi(!1),
            window.addEventListener("keydown", Ov, !0),
            self.app.jKt() ? (Gv = xv.animate(rv, av),
            Gv.onfinish = nv.Qs.FOi.ICi) : nv.Qs.FOi.ICi()
        }
        static j0() {
            window.removeEventListener("pointerdown", Dv, {
                capture: !0,
                passive: !1
            }),
            window.removeEventListener("pointermove", Dv, {
                capture: !0,
                passive: !1
            }),
            window.removeEventListener("pointerup", Dv, {
                capture: !0,
                passive: !1
            }),
            gv && window.removeEventListener("contextmenu", nv.Qs.gdt, {
                capture: !0
            }),
            wv ? nv.Qs.mk.LMi(!0) : mv && nv.Qs.mk.OMi(!0),
            nv.Qs.TO.$xi(!0),
            window.removeEventListener("keydown", Ov, !0),
            Sv && (pv && (Sv.removeEventListener("scroll", nv.Qs.Pdt, {
                capture: !0,
                passive: !1
            }),
            Sv.removeEventListener("wheel", nv.Qs.Pdt, {
                capture: !0,
                passive: !1
            })),
            Sv = null),
            bv = null,
            vv = null,
            nv.Qs.UO(_v),
            nv.Qs.UO(Pv),
            _v = null,
            Tv = null,
            Iv = null,
            Pv = null,
            Gv ? Av && (Rv = !0,
            Av = !1,
            Gv.playbackRate *= -1) : (Rv = !0,
            self.app.jKt() && xv ? (Gv = xv.animate(rv, lv),
            Gv.onfinish = nv.Qs.FOi.ICi) : nv.Qs.FOi.ICi())
        }
        static ICi() {
            Rv ? (nv.Qs.UO(xv),
            xv = null,
            Ev = null,
            Cv = null) : Av && bv && bv.focus(),
            Gv = null,
            Av = !1,
            Rv = !1
        }
        static DOi() {
            if (!bv)
                return;
            nv.Qs.x5(bv),
            bv.focus();
            const t = nv.Rect.nJt(bv.getBoundingClientRect())
              , i = nv.v(nv.Rect, 0, 0, 0, 0);
            if (vv) {
                const t = nv.Qs.Ks.rCi(vv)
                  , e = t.ECi();
                i.set(-t.ka() - e, -t.Ra() - e, Math.min(t.ka() + t.ns() - window.innerWidth, 0) + e, Math.min(t.Ra() + t.er() - window.innerHeight, 0) + e)
            }
            nv.Qs.FOi.LOi(t, i)
        }
        static LOi(t, i) {
            nv.U(t, nv.Rect),
            nv.U(i, nv.Rect);
            const e = window.innerHeight < ov
              , s = fv
              , n = yv;
            let r = fv
              , h = fv
              , o = t.Yr() - s
              , a = t.width() + 2 * s;
            o < 0 && (h = Math.max(h + o, 0),
            a = Math.max(a + o, 0),
            o = 0);
            let l = t.Jr() - s
              , u = t.height() + 2 * s
              , c = "1fr";
            l < 0 && (r += l,
            u += l,
            l = 0),
            e && (o = 0,
            a = 0,
            l = 0,
            u = 0),
            "WebKit" === nv.kt._9t && (c = window.innerHeight - u - l + "px"),
            xv.style.gridTemplateColumns = `${o}px ${a}px 1fr`,
            xv.style.gridTemplateRows = `${l}px ${u}px ${c}`,
            Mv.style.gridTemplateColumns = `${h}px 1fr ${s}px`,
            Mv.style.gridTemplateRows = `${r}px 1fr ${s}px`;
            const d = t.Yr() - s - n
              , f = t.Jr() - s - n;
            if (Ev.style.left = d + "px",
            Ev.style.top = f + "px",
            Ev.style.width = t.width() + 2 * s + 2 * n + "px",
            Ev.style.height = t.height() + 2 * s + 2 * n + "px",
            Ev.style.display = e ? "none" : "",
            Cv.style.display = e ? "" : "none",
            xv.style.left = (i ? i.Yr() : 0) + "px",
            xv.style.top = (i ? i.Jr() : 0) + "px",
            xv.style.right = (i ? i.pl() : 0) + "px",
            xv.style.bottom = (i ? i.dl() : 0) + "px",
            _v && (_v.style.display = e ? "none" : "",
            Pv.style.display = e ? "none" : "",
            !e))
                if ("outside-auto" === cv)
                    nv.Qs.FOi.BOi(t);
                else {
                    if ("screen-bottom" !== cv)
                        throw new Error("invalid message positioning");
                    nv.Qs.FOi.UOi()
                }
        }
        static BOi(t) {
            const i = nv.v(nv.Rect, Math.max(t.Yr(), 0), Math.max(t.Jr(), 0), Math.min(t.pl(), window.innerWidth), Math.min(t.dl(), window.innerHeight))
              , e = fv
              , s = yv
              , n = window.innerWidth
              , r = window.innerHeight
              , h = [];
            "left" !== dv && h.push([i.Yr(), "left"]),
            "top" !== dv && h.push([i.Jr(), "top"]),
            "right" !== dv && h.push([n - i.pl(), "right"]),
            "bottom" !== dv && h.push([r - i.dl(), "bottom"]),
            h.sort( (t, i) => i[0] - t[0]);
            const o = h[0][1];
            _v.style.left = "0px",
            _v.style.top = "0px",
            _v.style.width = "",
            _v.style.maxHeight = "";
            let a = _v.getBoundingClientRect();
            const l = 2 * (e + s) + 10;
            let u = 0
              , c = a.width
              , d = 0
              , f = r - 10;
            if ("left" === o || "right" === o) {
                if ("left" === o) {
                    const t = i.Yr() - l;
                    u = Math.max(5, t - a.width),
                    c = t - u
                } else
                    "right" === o && (u = i.pl() + l,
                    c = Math.min(c, n - 5 - u));
                _v.style.width = c + "px",
                a = _v.getBoundingClientRect();
                const t = Math.min(a.height, f);
                d = nv.Ne(i.ml() - t / 2, 5, r - 5 - t)
            } else {
                if ("top" === o) {
                    const t = i.Jr() - l;
                    d = Math.max(5, t - a.height),
                    f = t - d
                } else
                    "bottom" === o && (d = i.dl() + l,
                    f = Math.min(f, r - 5 - d));
                c = Math.min(a.width, n - 10),
                u = nv.Ne(i.fl() - c / 2, 5, n - 5 - c)
            }
            _v.style.left = u + "px",
            _v.style.top = d + "px",
            _v.style.width = c + "px",
            _v.style.maxHeight = f + "px";
            const p = nv.Rect.nJt(_v.getBoundingClientRect())
              , m = 12;
            Pv.className = "c3-dimmer-cutout-message-arrow " + o;
            let w = 0
              , g = 0;
            "left" === o ? (w = p.pl(),
            g = i.ml() - m) : "right" === o ? (w = p.Yr() - m,
            g = i.ml() - m) : "top" === o ? (w = i.fl() - m,
            g = p.dl()) : "bottom" === o && (w = i.fl() - m,
            g = p.Jr() - m),
            Pv.style.display = "",
            Pv.style.left = w + "px",
            Pv.style.top = g + "px"
        }
        static UOi() {
            Pv.style.display = "none",
            _v.style.left = "0px",
            _v.style.top = "0px",
            _v.style.width = "",
            _v.style.maxHeight = "10em";
            const t = _v.getBoundingClientRect();
            _v.style.left = window.innerWidth / 2 - t.width / 2 + "px",
            _v.style.top = window.innerHeight - t.height - 25 + "px"
        }
        static XO() {
            return !!bv
        }
        static NOi() {
            return xv
        }
        static jOi() {
            return Iv
        }
    }
}
{
    const Fv = self.t;
    Fv.Qs.Fk.rpe = class extends Fv.Me {
        constructor(t, i, e, s) {
            Fv.U(t, Fv.Qs.Fk.Mbt),
            Fv.zt(i),
            Fv.gL(e),
            super(),
            this.Sbt = t,
            this.Ftt = i,
            this.$Oi = e,
            this.c8 = s,
            this.Rdi = this.Sbt.zOi(),
            this.lbt = !0,
            this.dn = !1,
            this.VOi = "",
            this.ght = Fv.Qs.W_("ui-proprow", this.Sbt.WOi()),
            this.HOi = t => this.gO(t),
            this.ght.addEventListener("contextmenu", this.HOi)
        }
        S0() {
            this.dn = !0,
            this.Sbt.KOi(this),
            this.ght.removeEventListener("contextmenu", this.HOi),
            this.HOi = null,
            Fv.Qs.UO(this.ght),
            this.ght = null,
            this.Sbt = null,
            Fv.he(this)
        }
        gO(t) {
            this.Sbt.qOi("contextmenu", this, t)
        }
        XOi() {
            this.Sbt.YOi(this)
        }
        gn() {
            return this.dn
        }
        CEt() {}
        JOi() {
            let t = 0
              , i = this.c8;
            for (; i; )
                ++t,
                i = i.c8;
            return t
        }
        Ute() {
            return this.Sbt
        }
        dD() {
            return this.c8
        }
        La() {
            return this.Ftt
        }
        nse() {
            return this.$Oi
        }
        Kte() {
            return this.ght
        }
        Bk() {
            return this.Rdi
        }
        Gue() {
            return !1
        }
        hoe(t) {
            Fv.zt(t),
            this.VOi = t
        }
        ZOi() {
            return this.VOi
        }
        z6() {
            return !0
        }
        QOi(t, i) {
            if (t = !!t,
            !(i = !!i) && this.Sbt.tDi() && this.Sbt.iDi(),
            t && !this.lbt)
                if (this.lbt = !0,
                i)
                    this.Sbt.eDi(this);
                else {
                    this.ght.removeAttribute("collapsed");
                    let t = this.Sbt.sDi();
                    t && t()
                }
            else if (!t && this.lbt)
                if (this.lbt = !1,
                i)
                    this.Sbt.nDi(this);
                else {
                    this.ght.setAttribute("collapsed", "");
                    let t = this.Sbt.sDi();
                    t && t()
                }
        }
        B6() {
            let t = this.c8;
            for (; t; ) {
                if (!t.z6())
                    return !1;
                t = t.c8
            }
            return !0
        }
        qk() {
            return !0
        }
        rDi() {}
        The() {}
        Pit() {}
        f1() {}
        S5() {}
        Q3(t) {}
    }
}
{
    const Lv = self.t;
    Lv.Qs.Fk.hDi = class extends Lv.Qs.Fk.rpe {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.q1t = Lv.Qs.W_("ui-propname", this.ght);
            let n = this.JOi();
            n > 0 && this.q1t.setAttribute("level" + n, ""),
            this.oDi = t => {
                t.button === Lv.gF.sV && t.isPrimary && (this.Sbt.Ez(this) && t.preventDefault(),
                this.XOi())
            }
            ,
            this.q1t.addEventListener("pointerdown", this.oDi),
            this.fJt = Lv.Qs.W_("div", this.q1t, null, "propname-wrap"),
            this.aDi = Lv.Qs.W_("label", this.fJt, null, "propname-label"),
            this.aDi.textContent = this.Ftt,
            this.aDi.setAttribute("for", this.Rdi),
            this.lDi = Lv.Qs.W_("ui-propvalue", this.ght),
            this.DF = !0,
            this.Kc = null
        }
        S0() {
            this.q1t.removeEventListener("pointerdown", this.oDi),
            this.oDi = null,
            Lv.Qs.UO(this.aDi),
            this.aDi = null,
            Lv.Qs.UO(this.fJt),
            this.fJt = null,
            Lv.Qs.UO(this.q1t),
            this.q1t = null,
            Lv.Qs.UO(this.lDi),
            this.lDi = null,
            super.S0()
        }
        XOi() {
            super.XOi(),
            this.x5()
        }
        x5() {
            this.Sbt.XEt(this)
        }
        goe(t) {
            return this.Kc = t,
            this
        }
        Do() {
            return this.Kc
        }
        Gue() {
            return !0
        }
        uDi() {
            return this.q1t
        }
        cDi() {
            return this.lDi
        }
        cA(t) {
            t = !!t,
            this.DF !== t && (Lv.Qs.eit(this.aDi, "disabled", !t),
            Lv.Qs.eit(this.lDi, "disabled", !t),
            t || this.Sbt.KOi(this),
            this.DF = t,
            this.dDi(t))
        }
        qk() {
            return this.DF
        }
        dDi(t) {}
        *lpe() {}
        fDi() {
            return this.Sbt.pDi(this)
        }
    }
}
{
    const Bv = self.t;
    let Uv = null;
    const Nv = new Map([["text", "text"], ["integer", "number"], ["float", "number"], ["percent", "text"], ["angle", "text"], ["custom-numeric", "text"], ["email", "email"], ["password", "password"], ["tel", "tel"], ["url", "url"]]);
    Bv.Qs.Fk.mDi = class extends Bv.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r, h, o, a) {
            if (super(t, i, e, n),
            Bv.gL(s),
            Bv.tot(r),
            Bv.tot(h),
            Bv.tot(o),
            s = s || "text",
            !Nv.has(s))
                throw new Error(`invalid InputProperty type '${s}'`);
            this.aGt = s,
            this.uVt = Bv.Qs.W_("input", this.lDi),
            this.uVt.id = this.Bk(),
            this.wDi = !0;
            let l = Nv.get(this.aGt);
            this.gDi() && this.yDi() && (l = "text"),
            this.uVt.type = l,
            "text" === l && this.uVt.setAttribute("spellcheck", "false"),
            this.gDi() && this.uVt.setAttribute("numeric", ""),
            this.uVt.setAttribute("autocomplete", "off"),
            this.bDi = r,
            this.vDi = h,
            this.SDi = o,
            this.xDi = this.Sbt.MDi(),
            this.EDi = !1,
            this.CDi = a,
            this._Di = !1,
            this.TDi = null,
            this.IDi = null,
            this.PDi = !1,
            this.GDi = !0,
            this.ADi = !1,
            this.RDi = !1,
            this.kDi = !1,
            this.ODi = NaN,
            this.DDi = !1,
            this.FDi = NaN,
            this.LDi = () => !0,
            this.BDi = () => !0,
            this.UDi = !0,
            this.NDi = 6,
            this.jDi = "",
            this.$Di = !1,
            this.zDi = "",
            this.VDi = t => this.WDi(),
            this.uVt.addEventListener("change", this.VDi),
            this.HDi = t => {
                if (Bv.Qs._O.OAi())
                    return t.preventDefault(),
                    void this.uVt.blur();
                this.XOi(),
                this.GDi = !1,
                this.Sbt.KDi( () => {
                    this.uVt && this.x5()
                }
                )
            }
            ,
            this.uVt.addEventListener("focus", this.HDi),
            this.qDi = t => {
                this.Sbt.KOi(this),
                this.GDi = !0,
                this.ADi = !1,
                this.XDi() && (this.Sbt.xee(this),
                this.IDi = this.YDi())
            }
            ,
            this.uVt.addEventListener("blur", this.qDi),
            this.JDi = -1,
            this.ZDi = () => {
                if (this.q0)
                    return;
                const {value: t} = this.QDi();
                t !== this.TDi && (this.RDi || (this.XSt(t),
                this.RDi = !0),
                this.EDi = !0,
                this.WDi(t),
                this.EDi = !1),
                this.JDi = requestAnimationFrame(this.ZDi)
            }
            ,
            this.tFi = () => {
                this.GDi && (this.ADi = !0,
                this.GDi = !1),
                this.iFi() && -1 === this.JDi && (this.RDi = !1,
                this.JDi = requestAnimationFrame(this.ZDi),
                this.uVt.ownerDocument.addEventListener("pointerup", this.eFi),
                this.uVt.ownerDocument.addEventListener("pointercancel", this.sFi))
            }
            ,
            this.uVt.addEventListener("pointerdown", this.tFi),
            this.zM = -1,
            this.nFi = t => {
                this.ADi && (this.ADi = !1,
                this.zM = requestAnimationFrame( () => {
                    this.uVt && this.uVt.select(),
                    this.zM = -1
                }
                ))
            }
            ,
            this.uVt.addEventListener("pointerup", this.nFi),
            this.rFi = t => {
                this.ADi = !0,
                this.GDi = !1,
                cancelAnimationFrame(this.zM),
                this.zM = -1
            }
            ,
            this.uVt.addEventListener("pointercancel", this.rFi),
            this.eFi = null,
            this.sFi = null,
            this.hFi = !0,
            this.oFi = t => {
                t.preventDefault(),
                this.hFi && this.q3(t.clientX, t.clientY)
            }
            ,
            this.uVt.addEventListener("dragstart", this.oFi),
            this.aFi = t => this.wG(t),
            this.uVt.addEventListener("keydown", this.aFi),
            this.cG = null,
            this.uG = null,
            this.q0 = !1,
            this.lFi = 0,
            this.uFi = 0,
            this.cFi = 0,
            this.dFi = 1,
            this.gDi() && (this.cG = t => this.fG(t),
            this.uG = t => this.dG(t),
            this.eFi = t => {
                -1 !== this.JDi && (cancelAnimationFrame(this.JDi),
                this.JDi = -1),
                this.uVt.ownerDocument.removeEventListener("pointerup", this.eFi),
                this.uVt.ownerDocument.removeEventListener("pointercancel", this.sFi)
            }
            ,
            this.sFi = t => {
                this.q0 = !1,
                Bv.Qs.sk.hk(Uv),
                Uv = null,
                cancelAnimationFrame(this.JDi),
                this.JDi = -1,
                this.uVt.ownerDocument.removeEventListener("pointerup", this.eFi),
                this.uVt.ownerDocument.removeEventListener("pointercancel", this.sFi),
                this.uVt.ownerDocument.removeEventListener("pointermove", this.cG),
                this.uVt.ownerDocument.removeEventListener("pointerup", this.uG)
            }
            ),
            this.bDi && (this.TDi = this.YDi(),
            this.IDi = this.TDi,
            this.fFi(this.TDi))
        }
        YDi() {
            return this.bDi ? this.CDi ? this.Sbt.pFi(this.bDi, this) : this.bDi(this) : null
        }
        mFi(t) {
            this.vDi && (this.CDi ? this.Sbt.wFi(this.vDi, t, this, this.TDi) : this.vDi(t, this, this.TDi))
        }
        XSt(t) {
            this.xDi && this.xDi(this.La(), t)
        }
        XDi() {
            let t;
            if (this.gDi() && Bv.ub(this.IDi)) {
                let i, e, s, n;
                if ("integer" === this.aGt ? (t = parseInt(this.uVt.value),
                i = this.DDi,
                e = this.kDi,
                s = this.ODi,
                n = this.FDi) : "float" === this.aGt ? (t = parseFloat(this.uVt.value),
                i = this.DDi,
                e = this.kDi,
                s = this.ODi,
                n = this.FDi) : "percent" === this.aGt ? (t = parseFloat(this.uVt.value) / 100,
                i = !0,
                e = !0,
                s = Bv.ub(this.ODi) ? this.ODi : 0,
                n = Bv.ub(this.FDi) ? this.FDi : 1) : "angle" === this.aGt || "custom-numeric" === this.aGt ? (t = parseFloat(this.uVt.value),
                i = !0,
                e = !0,
                s = Bv.ub(this.ODi) ? this.ODi : 0,
                n = Bv.ub(this.FDi) ? this.FDi : 360) : "custom-numeric" === this.aGt && (t = parseFloat(this.uVt.value),
                i = this.DDi,
                e = this.kDi,
                s = this.ODi,
                n = this.FDi),
                this.LDi() && i && t < s && this.IDi === s)
                    return !1;
                if (this.BDi() && e && t > n && this.IDi === n)
                    return !1;
                if (t === this.IDi)
                    return !1
            } else {
                if (Bv.aM(this.IDi))
                    return !1;
                if (this.uVt.value === this.IDi)
                    return !1
            }
            return !0
        }
        fFi(t) {
            this.PDi = !0,
            this.gFi(t),
            this.PDi = !1
        }
        S0() {
            -1 !== this.JDi && cancelAnimationFrame(this.JDi),
            this.ZDi = null,
            this.bDi = null,
            this.vDi = null,
            this.SDi = null,
            this.xDi = null,
            this.TDi = null,
            this.IDi = null,
            this.gDi() && (this.uVt.ownerDocument.removeEventListener("pointermove", this.cG),
            this.cG = null,
            this.uVt.ownerDocument.removeEventListener("pointerup", this.uG),
            this.uG = null,
            this.uVt.ownerDocument.removeEventListener("pointerup", this.eFi),
            this.eFi = null,
            this.uVt.ownerDocument.removeEventListener("pointercancel", this.sFi),
            this.sFi = null),
            this.uVt.removeEventListener("keydown", this.aFi),
            this.aFi = null,
            this.uVt.removeEventListener("dragstart", this.oFi),
            this.oFi = null,
            this.uVt.removeEventListener("change", this.VDi),
            this.VDi = null,
            this.uVt.removeEventListener("blur", this.qDi),
            this.qDi = null,
            this.uVt.removeEventListener("focus", this.HDi),
            this.HDi = null,
            this.uVt.removeEventListener("pointerdown", this.tFi),
            this.tFi = null,
            this.uVt.removeEventListener("pointerup", this.nFi),
            this.nFi = null,
            this.uVt.removeEventListener("pointercancel", this.rFi),
            this.rFi = null,
            Bv.Qs.UO(this.uVt),
            this.uVt = null,
            super.S0()
        }
        Voe() {
            return this._Di = !0,
            this
        }
        yFi() {
            return this._Di
        }
        gDi() {
            return "integer" === this.aGt || "float" === this.aGt || "percent" === this.aGt || "angle" === this.aGt || "custom-numeric" === this.aGt
        }
        iFi() {
            return "integer" === this.aGt || "float" === this.aGt
        }
        Yne(t) {
            Bv.Ge(t),
            this.dFi = t
        }
        ade(t) {
            return this.hFi = !!t,
            this
        }
        Abt(t) {
            if (Bv.Ge(t),
            !this.gDi())
                throw new Error("cannot set minimum value on this property type");
            if ("integer" === this.aGt && (t = Math.floor(t)),
            this.DDi && t > this.FDi)
                throw new Error("cannot set a minimum value greater than the maximum value");
            return this.kDi = !0,
            this.ODi = t,
            this.uVt.setAttribute("min", t.toString()),
            this
        }
        Nre(t) {
            if (Bv.Ge(t),
            !this.gDi())
                throw new Error("cannot set maximum value on this property type");
            if ("integer" === this.aGt && (t = Math.floor(t)),
            this.kDi && t < this.ODi)
                throw new Error("cannot set a maximum value less than the minimum value");
            return this.DDi = !0,
            this.FDi = t,
            this.uVt.setAttribute("max", t.toString()),
            this
        }
        Ese(t, i) {
            if (Bv.Ge(t),
            Bv.Ge(i),
            !this.gDi())
                throw new Error("cannot set minimum/maximum value on this property type");
            if (i < t)
                throw new Error("cannot set a maximum value less than the minimum value");
            return this.DDi = !1,
            this.Abt(t),
            this.kDi = !1,
            this.Nre(i),
            this.kDi = !0,
            this.DDi = !0,
            this
        }
        Moe(t) {
            return Bv.nu(t),
            this.LDi = t,
            this
        }
        Aoe(t) {
            return Bv.nu(t),
            this.BDi = t,
            this
        }
        are(t, i) {
            if (t) {
                if (Bv.Ge(i),
                (i = Math.floor(i)) < 0 || i > 20)
                    throw new Error("invalid rounding digit count");
                if ("float" !== this.aGt)
                    throw new Error("can only round 'float' input type");
                this.NDi = i
            }
            this.UDi = !!t,
            this.TDi = null,
            this.The()
        }
        bFi(t) {
            if (Bv.Ge(t),
            t = Math.floor(t),
            this.gDi())
                throw new Error("cannot set a max length on this property type");
            return t < 0 ? this.uVt.removeAttribute("maxlength") : this.uVt.setAttribute("maxlength", t.toString()),
            this
        }
        Xte(t) {
            if (Bv.zt(t),
            this.gDi())
                throw new Error("cannot set a placeholder on this property type");
            return this.jDi = t,
            this.$Di || this.uVt.setAttribute("placeholder", t),
            this
        }
        vFi() {
            this.$Di && (this.jDi ? this.uVt.setAttribute("placeholder", this.jDi) : this.uVt.removeAttribute("placeholder"),
            this.$Di = !1)
        }
        yDi() {
            return this.wDi && Bv.kt.FG && this.Sbt.SFi()
        }
        jre(t) {
            if (t = !!t,
            this.wDi === t)
                return;
            this.wDi = t;
            let i = Nv.get(this.aGt);
            if (this.gDi() && this.yDi() && (i = "text"),
            this.uVt.type !== i) {
                let t = this.uVt.value;
                this.uVt.type = i,
                this.uVt.value = t
            }
        }
        _he(t) {
            return Bv.zt(t),
            this.zDi = t,
            this.bDi && (this.TDi = this.YDi(),
            this.IDi = this.TDi,
            this.fFi(this.TDi)),
            this
        }
        gFi(t) {
            if (null === t)
                return this.uVt.value = "",
                this.uVt.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder")),
                void (this.$Di = !0);
            if (this.vFi(),
            "integer" === this.aGt)
                Bv.Ck(t),
                t = Math.floor(t),
                this.BDi() && this.DDi && t > this.FDi && (t = this.FDi),
                this.LDi() && this.kDi && t < this.ODi && (t = this.ODi),
                this.uVt.value = t.toString();
            else if ("float" === this.aGt)
                Bv.Ck(t),
                this.BDi() && this.DDi && t > this.FDi && (t = this.FDi),
                this.LDi() && this.kDi && t < this.ODi && (t = this.ODi),
                this.UDi ? this.uVt.value = Bv.toFixed(t, this.NDi) : this.uVt.value = t.toString();
            else if ("percent" === this.aGt)
                Bv.Ck(t),
                this.BDi() && this.DDi && t > this.FDi && (t = this.FDi),
                this.LDi() && this.kDi && t < this.ODi && (t = this.ODi),
                t *= 100,
                this.uVt.value = Bv.toFixed(t, 2) + self.lang("ui.bars.properties.percent-suffix");
            else if ("angle" === this.aGt)
                Bv.Ck(t),
                this.BDi() && this.DDi && t > this.FDi && (t = this.FDi),
                this.LDi() && this.kDi && t < this.ODi && (t = this.ODi),
                (t %= 360) < 0 && (t += 360),
                this.uVt.value = Bv.toFixed(t, 1) + self.lang("ui.bars.properties.angle-suffix");
            else if ("custom-numeric" === this.aGt) {
                Bv.Ck(t),
                this.BDi() && this.DDi && t > this.FDi && (t = this.FDi),
                this.LDi() && this.kDi && t < this.ODi && (t = this.ODi);
                const i = this.zDi ? this.zDi : "";
                this.UDi ? this.uVt.value = Bv.toFixed(t, this.NDi) + i : this.uVt.value = t.toString() + i
            } else
                Bv.zt(t),
                this.uVt.value = t
        }
        xFi(t) {
            if (Bv.zt(t),
            this.uVt.value !== t && (!this.gDi() || t)) {
                if (this.gDi() && this.yDi()) {
                    let i = this.MFi(t);
                    return "number" == typeof i && isFinite(i) && this.gFi(i),
                    this.EDi = !0,
                    this.WDi(),
                    void (this.EDi = !1)
                }
                if ("integer" === this.aGt) {
                    let i = parseInt(t, 10);
                    if (!isFinite(i))
                        return;
                    this.gFi(i)
                } else if ("float" === this.aGt || "angle" === this.aGt || "custom-numeric" === this.aGt) {
                    let i = parseFloat(t);
                    if (!isFinite(i))
                        return;
                    this.gFi(i)
                } else if ("percent" === this.aGt) {
                    let i = parseFloat(t);
                    if (!isFinite(i))
                        return;
                    i /= 100,
                    this.gFi(i)
                } else
                    this.uVt.value = t;
                this.EDi = !0,
                this.WDi(),
                this.EDi = !1
            }
        }
        QDi() {
            const t = this.uVt.value;
            let i = null
              , e = !1
              , s = !1;
            return "integer" === this.aGt ? (i = parseInt(t, 10),
            isFinite(i) ? s = !0 : i = NaN) : "float" === this.aGt ? (i = parseFloat(t),
            isFinite(i) ? s = !0 : i = NaN) : "percent" === this.aGt ? (i = parseFloat(t),
            isFinite(i) ? (i /= 100,
            s = !0) : i = NaN) : "angle" === this.aGt ? (i = parseFloat(t),
            isFinite(i) ? (i %= 360,
            i < 0 && (i += 360),
            s = !0) : i = NaN) : "custom-numeric" === this.aGt ? (i = parseFloat(t),
            isFinite(i) ? s = !0 : i = NaN) : i = t,
            s && (this.BDi() && this.DDi && i > this.FDi && (i = this.FDi,
            e = !0),
            this.LDi() && this.kDi && i < this.ODi && (i = this.ODi,
            e = !0)),
            {
                value: i,
                EFi: e
            }
        }
        CFi() {
            return null === this.TDi ? "" : "percent" === this.aGt || "angle" === this.aGt || "custom-numeric" === this.aGt ? this.uVt.value : this.QDi().value.toString()
        }
        XOi() {
            this.uVt.select(),
            super.XOi()
        }
        CEt() {
            this.uVt && this.uVt.focus()
        }
        MFi(t) {
            let i = this.Sbt._Fi();
            if ("percent" === this.aGt) {
                let i = self.lang("ui.bars.properties.percent-suffix");
                t.endsWith(i) && (t = t.substr(0, t.length - i.length))
            } else if ("angle" === this.aGt) {
                let i = self.lang("ui.bars.properties.angle-suffix");
                t.endsWith(i) && (t = t.substr(0, t.length - i.length))
            } else if ("custom-numeric" === this.aGt && this.zDi) {
                let i = this.zDi;
                t.endsWith(i) && (t = t.substr(0, t.length - i.length))
            }
            let e = i(t);
            return null === e ? NaN : ("integer" === this.aGt ? e = Math.round(e) : "percent" === this.aGt && (e /= 100),
            e)
        }
        WDi(t) {
            if (this.PDi || !this.vDi)
                return;
            const i = this.Sbt;
            let e = !1
              , s = !1;
            if (void 0 === t)
                if (this.gDi() && this.yDi())
                    t = this.MFi(this.uVt.value),
                    isFinite(t) && (e = !0,
                    this.LDi() && this.kDi && t < this.ODi && (t = this.ODi),
                    this.BDi() && this.DDi && t > this.FDi && (t = this.FDi));
                else {
                    const i = this.QDi();
                    t = i.value,
                    s = i.EFi
                }
            let n = !("number" == typeof t && isNaN(t));
            if (n && (this.q0 || this.EDi || this.RDi || this.XSt(t),
            this.EDi || (this.RDi = !1),
            this.mFi(t),
            this.TDi = t),
            this.vFi(),
            this.bDi) {
                let t = this.YDi();
                const i = this.zDi || "percent" === this.aGt || "angle" === this.aGt;
                (!n || e || s || t !== this.TDi || i) && (this.TDi = t,
                this.fFi(this.TDi))
            }
            n && (this.TFi(),
            i.vee(this))
        }
        TFi() {
            this.c8 && this.c8 instanceof Bv.Qs.Fk.IFi && this.c8.PFi()
        }
        Zte() {
            return this.uVt
        }
        q3(t, i) {
            Bv.Ge(t),
            Bv.Ge(i),
            this.gDi() && (this.q0 || null !== this.TDi && (this.q0 = !0,
            this.lFi = t,
            this.uFi = i,
            this.cFi = 0,
            Uv = Bv.Qs.sk.ik("ns-resize", this.uVt.ownerDocument, t, i),
            this.XSt(this.TDi),
            this.uVt.ownerDocument.addEventListener("pointermove", this.cG),
            this.uVt.ownerDocument.addEventListener("pointerup", this.uG)))
        }
        fG(t) {
            if (!t.isPrimary)
                return;
            if (!this.q0)
                return;
            t.preventDefault();
            let i = t.clientX
              , e = t.clientY
              , s = Bv.bk.$F(t)
              , n = t.shiftKey
              , r = this.uFi - e;
            if (r *= this.dFi,
            s ? r *= 10 : n && (r /= 10),
            "integer" === this.aGt && (this.cFi += r,
            r = 0 | this.cFi,
            this.cFi -= r),
            "percent" === this.aGt ? r /= 1e3 : "angle" === this.aGt && (r /= 5),
            0 !== r) {
                let t = this.TDi + r;
                this.LDi() && this.kDi && (this.TDi < this.ODi || t < this.ODi) && (t = this.ODi),
                this.BDi() && this.DDi && (this.TDi > this.FDi || t > this.FDi) && (t = this.FDi),
                this.fFi(t),
                this.WDi(t),
                this.TDi = t
            }
            this.uVt.select(),
            this.lFi = i,
            this.uFi = e
        }
        dG(t) {
            t.isPrimary && this.q0 && (t.preventDefault(),
            this.fG(t),
            this.q0 = !1,
            Bv.Qs.sk.hk(Uv),
            Uv = null,
            this.uVt.ownerDocument.removeEventListener("pointermove", this.cG),
            this.uVt.ownerDocument.removeEventListener("pointerup", this.uG))
        }
        wG(t) {
            t.which === Bv.Mk.aY && (t.preventDefault(),
            this.uVt.blur(),
            this.Sbt.GFi(this))
        }
        rDi() {
            this.SDi && !this.q0 && (this.CDi ? this.cA(this.Sbt.AFi(this.SDi)) : this.cA(this.SDi()))
        }
        dDi(t) {
            this.uVt.disabled = !t,
            this.uVt.readOnly = !t
        }
        The() {
            if (this.q0 || !this.bDi)
                return;
            let t = this.YDi();
            t !== this.TDi && (this.TDi = t,
            this.fFi(this.TDi),
            this.TFi())
        }
        *lpe() {
            yield*super.lpe(),
            yield this.uVt
        }
        Pit() {
            return this.q0
        }
        f1() {
            this.q0 && this.sFi && this.sFi()
        }
    }
}
{
    const jv = self.t
      , $v = /\\/g
      , zv = /\n/g
      , Vv = /\t/g;
    function Wv(t) {
        let i = t.replace($v, "\\\\");
        return i = i.replace(Vv, "\\t"),
        i.replace(zv, "\\n")
    }
    function Hv(t) {
        let i = [];
        for (let e of t)
            i.push(e);
        let e = "";
        for (let t = 0, s = i.length; t < s; ++t) {
            let n = i[t];
            if ("\\" === n && t < s - 1) {
                let s = i[t + 1];
                switch (s) {
                case "\\":
                    e += "\\";
                    break;
                case "n":
                    e += "\n";
                    break;
                case "t":
                    e += "\t";
                    break;
                default:
                    e += "\\" + s
                }
                ++t
            } else
                e += n
        }
        return e
    }
    jv.Qs.Fk.RFi = class extends jv.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            jv.tot(n),
            jv.tot(r),
            jv.tot(h),
            this.kFi = jv.Qs.W_("div", this.lDi, null, "flexVstretch"),
            this.uVt = jv.Qs.W_("input", this.kFi, null, "longTextProperty"),
            this.uVt.type = "text",
            this.uVt.id = this.Bk(),
            this.uVt.setAttribute("spellcheck", "false"),
            this.uVt.setAttribute("autocomplete", "off"),
            this.OFi = jv.Qs.W_("button", this.kFi, null, "longTextProperty"),
            this.OFi.textContent = self.lang("common.ellipsis"),
            this.DFi = null,
            this.bDi = n,
            this.vDi = r,
            this.SDi = h,
            this.xDi = this.Sbt.MDi(),
            this.CDi = o,
            this.TDi = null,
            this.PDi = !1,
            this.GDi = !0,
            this.ADi = !1,
            this.jDi = "",
            this.$Di = !1,
            this.FFi = t => this.LFi(),
            this.OFi.addEventListener("click", this.FFi),
            this.BFi = null,
            this.VDi = t => this.WDi(),
            this.uVt.addEventListener("change", this.VDi),
            this.HDi = t => {
                this.XOi(),
                this.GDi = !1,
                this.Sbt.KDi( () => {
                    this.uVt && this.x5()
                }
                )
            }
            ,
            this.uVt.addEventListener("focus", this.HDi),
            this.qDi = t => {
                this.Sbt.KOi(this),
                this.GDi = !0,
                this.ADi = !1
            }
            ,
            this.uVt.addEventListener("blur", this.qDi),
            this.tFi = t => {
                this.GDi && (this.ADi = !0,
                this.GDi = !1)
            }
            ,
            this.uVt.addEventListener("pointerdown", this.tFi),
            this.nFi = t => {
                this.ADi && (t.preventDefault(),
                this.ADi = !1)
            }
            ,
            this.uVt.addEventListener("pointerup", this.nFi),
            this.rFi = t => {
                this.ADi = !1,
                this.GDi = !1
            }
            ,
            this.uVt.addEventListener("pointercancel", this.rFi),
            this.aFi = t => this.wG(t),
            this.uVt.addEventListener("keydown", this.aFi),
            this.uVt.addEventListener("dragstart", jv.Qs.Pdt),
            this.bDi && (this.TDi = this.YDi(),
            this.fFi(this.TDi))
        }
        YDi() {
            return this.bDi ? this.CDi ? this.Sbt.pFi(this.bDi, this) : this.bDi(this) : null
        }
        mFi(t) {
            this.vDi && (this.CDi ? this.Sbt.wFi(this.vDi, t, this) : this.vDi(t, this))
        }
        XSt() {
            this.xDi && this.xDi(this.La())
        }
        S0() {
            this.UFi(),
            this.bDi = null,
            this.vDi = null,
            this.SDi = null,
            this.xDi = null,
            this.TDi = null,
            this.uVt.removeEventListener("change", this.VDi),
            this.VDi = null,
            this.uVt.removeEventListener("blur", this.qDi),
            this.qDi = null,
            this.uVt.removeEventListener("focus", this.HDi),
            this.HDi = null,
            this.uVt.removeEventListener("pointerdown", this.tFi),
            this.tFi = null,
            this.uVt.removeEventListener("pointerup", this.nFi),
            this.nFi = null,
            this.uVt.removeEventListener("pointercancel", this.rFi),
            this.rFi = null,
            this.uVt.removeEventListener("keydown", this.aFi),
            this.aFi = null,
            this.uVt.removeEventListener("dragstart", jv.Qs.Pdt),
            jv.Qs.UO(this.uVt),
            this.uVt = null,
            this.OFi.removeEventListener("click", this.FFi),
            this.FFi = null,
            this.BFi = null,
            jv.Qs.UO(this.OFi),
            this.OFi = null,
            jv.Qs.UO(this.kFi),
            this.kFi = null,
            super.S0()
        }
        UFi() {
            this.uVt.removeAttribute("list"),
            jv.Qs.UO(this.DFi),
            this.DFi = null
        }
        uae(t) {
            jv.nu(t),
            this.BFi = t
        }
        dae(t) {
            jv.zt(t),
            this.OFi.textContent = t
        }
        bFi(t) {
            return jv.Ge(t),
            (t = Math.floor(t)) < 0 ? this.uVt.removeAttribute("maxlength") : this.uVt.setAttribute("maxlength", t.toString()),
            this
        }
        Xte(t) {
            return jv.zt(t),
            this.jDi = t,
            this.$Di || this.uVt.setAttribute("placeholder", t),
            this
        }
        vFi() {
            this.$Di && (this.jDi ? this.uVt.setAttribute("placeholder", this.jDi) : this.uVt.removeAttribute("placeholder"),
            this.$Di = !1)
        }
        hre(t) {
            if (this.gn())
                return;
            this.UFi();
            const i = "list" + Math.floor(1e6 * Math.random());
            this.DFi = document.createElement("datalist"),
            this.DFi.id = i;
            for (const i of t) {
                const t = document.createElement("option");
                t.value = i,
                this.DFi.appendChild(t)
            }
            this.uVt.parentElement.insertBefore(this.DFi, this.uVt),
            this.uVt.setAttribute("list", i)
        }
        XOi() {
            this.uVt.select(),
            super.XOi()
        }
        CEt() {
            this.uVt && this.uVt.focus()
        }
        fFi(t) {
            this.PDi = !0,
            this.gFi(t),
            this.PDi = !1
        }
        gFi(t) {
            if (null === t)
                return this.uVt.value = "",
                this.uVt.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder")),
                void (this.$Di = !0);
            this.vFi(),
            this.uVt.value = Wv(t)
        }
        QDi() {
            return Hv(this.uVt.value)
        }
        WDi() {
            if (this.PDi || !this.vDi)
                return;
            this.XSt();
            let t = this.QDi();
            if (this.mFi(t),
            this.TDi = t,
            this.bDi) {
                let t = this.YDi();
                t === this.TDi && Wv(t) === this.uVt.value || (this.TDi = t,
                this.fFi(this.TDi))
            }
            this.Sbt.vee(this)
        }
        LFi() {
            if (this.XOi(),
            this.BFi) {
                let t = this.BFi(this);
                return void (t.then && t.then(t => {
                    "string" == typeof t && this.uVt && (this.gFi(t),
                    this.WDi())
                }
                ))
            }
            let t = jv.Qs.Ks.qs("LongTextPropertyDialog");
            t.Wa(this.Ftt),
            t.Xa(this.QDi()).then(t => {
                null !== t && this.uVt && (t || null !== this.TDi) && (this.gFi(t),
                this.WDi())
            }
            )
        }
        wG(t) {
            t.which === jv.Mk.aY && (t.preventDefault(),
            this.uVt.blur(),
            this.Sbt.GFi(this))
        }
        Zte() {
            return this.uVt
        }
        rDi() {
            this.SDi && (this.CDi ? this.cA(this.Sbt.AFi(this.SDi)) : this.cA(this.SDi()))
        }
        dDi(t) {
            this.uVt.disabled = !t,
            this.uVt.readOnly = !t,
            this.OFi.disabled = !t
        }
        The() {
            if (!this.bDi)
                return;
            let t = this.YDi();
            t !== this.TDi && (this.TDi = t,
            this.fFi(this.TDi))
        }
        *lpe() {
            yield*super.lpe(),
            yield this.uVt
        }
        static NFi(t) {
            return jv.zt(t),
            Wv(t)
        }
        static jFi(t) {
            return jv.zt(t),
            Hv(t)
        }
    }
}
{
    const Kv = self.t
      , qv = "__multiple__";
    Kv.Qs.Fk.$Fi = class extends Kv.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            Kv.tot(n),
            Kv.tot(r),
            Kv.tot(h),
            this.zFi = Kv.Qs.W_("select", this.lDi),
            this.zFi.id = this.Bk(),
            this.bDi = n,
            this.vDi = r,
            this.SDi = h,
            this.xDi = this.Sbt.MDi(),
            this.CDi = o,
            this.VFi = !1,
            this.WFi = null,
            this.PDi = !1,
            this.TDi = null,
            this.bDi && (this.TDi = this.YDi(),
            null === this.TDi && this.HFi()),
            this.VDi = t => this.WDi(),
            this.zFi.addEventListener("change", this.VDi),
            this.HDi = t => this.XOi(),
            this.zFi.addEventListener("focus", this.HDi),
            this.qDi = t => this.Sbt.KOi(this),
            this.zFi.addEventListener("blur", this.qDi),
            this.KFi = null
        }
        S0() {
            this.bDi = null,
            this.vDi = null,
            this.SDi = null,
            this.xDi = null,
            this.zFi.removeEventListener("change", this.VDi),
            this.VDi = null,
            this.zFi.removeEventListener("focus", this.HDi),
            this.HDi = null,
            this.zFi.removeEventListener("blur", this.qDi),
            this.qDi = null,
            Kv.Qs.UO(this.zFi),
            this.zFi = null,
            this.KFi && (this.KFi.clear(),
            this.KFi = null),
            super.S0()
        }
        YDi() {
            return this.bDi ? this.CDi ? this.Sbt.pFi(this.bDi, this) : this.bDi(this) : null
        }
        mFi(t) {
            this.vDi && (this.CDi ? this.Sbt.wFi(this.vDi, t, this) : this.vDi(t, this))
        }
        XSt(t) {
            this.xDi && this.xDi(this.La(), t)
        }
        qFi(t) {
            this.PDi = !0,
            null === t ? this.HFi() : this.zFi.value = t,
            this.PDi = !1
        }
        HFi() {
            this.VFi || (this._A(self.lang("ui.bars.properties.multiple-placeholder"), qv),
            this.VFi = !0),
            this.zFi.value = qv
        }
        XFi() {
            this.WFi && (Kv.Qs.UO(this.WFi),
            this.VFi = !1)
        }
        WDi() {
            !this.PDi && this.vDi && this.zFi.value !== qv && (this.XSt(this.zFi.value),
            this.mFi(this.zFi.value),
            this.bDi && (this.TDi = this.YDi(),
            null !== this.TDi && this.XFi(),
            this.zFi.value !== this.TDi && this.qFi(this.TDi)),
            this.Sbt.vee(this))
        }
        efe() {
            return this.zFi
        }
        _A(t, i, e=!1, s="") {
            let n;
            if (Kv.zt(t),
            Kv.gL(i),
            Kv.gL(s),
            e = !!e,
            null == i && (i = t),
            s) {
                const t = this.KFi.get(s);
                if (!t)
                    throw new Error("missing options group");
                n = t
            } else
                n = this.zFi;
            let r = Kv.Qs.W_("option", n);
            return r.text = t,
            r.value = i,
            e && r.setAttribute("hidden", ""),
            i === this.TDi && (r.selected = !0),
            i === qv && (this.WFi = r),
            this
        }
        Doe(t, i) {
            Kv.zt(t),
            Kv.zt(i);
            const e = Kv.Qs.W_("optgroup", this.zFi);
            return e.setAttribute("label", i),
            this.KFi || (this.KFi = new Map),
            this.KFi.set(t, e),
            this
        }
        CEt() {
            this.zFi && this.zFi.focus()
        }
        rDi() {
            this.SDi && (this.CDi ? this.cA(this.Sbt.AFi(this.SDi)) : this.cA(this.SDi()))
        }
        dDi(t) {
            this.zFi.disabled = !t
        }
        The() {
            if (!this.bDi)
                return;
            let t = this.YDi();
            t !== this.TDi && (this.TDi = t,
            this.qFi(this.TDi))
        }
        *lpe() {
            yield*super.lpe(),
            yield this.zFi
        }
    }
}
{
    const Xv = self.t;
    let Yv = function(t) {
        t.preventDefault();
        let i = this.getAttribute("for")
          , e = this.ownerDocument.getElementById(i);
        e && e.focus()
    };
    Xv.Qs.Fk.YFi = class extends Xv.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r, h, o) {
            if (super(t, i, e, s),
            Xv.tot(n),
            Xv.tot(r),
            Xv.tot(h),
            this.kFi = Xv.Qs.W_("div", this.lDi, null, "flexVstretch"),
            this.JFi = Xv.Qs.W_("input", this.kFi, null, "colorProperty"),
            this.JFi.type = "color",
            this.JFi.id = this.Bk(),
            this.ZFi = Xv.Qs.W_("input", this.kFi, null, "colorProperty"),
            this.ZFi.type = "text",
            this.ZFi.setAttribute("spellcheck", "false"),
            this.bDi = n,
            this.vDi = r,
            this.SDi = h,
            this.xDi = this.Sbt.MDi(),
            this.CDi = o,
            this.PDi = !1,
            this.QFi = Xv.v(Xv.za, 0, 0, 0, 1),
            this.tLi = !1,
            this.TDi = Xv.v(Xv.za, 0, 0, 0, 1),
            this.IDi = null,
            this.bDi) {
                let t = this.YDi();
                null === t ? (this.tLi = !0,
                this.TDi = null) : t instanceof Xv.za && (this.QFi.set(t),
                this.TDi.set(t))
            }
            this.JFi.value = this.QFi.GA(),
            this.tLi ? (this.ZFi.value = "",
            this.ZFi.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder"))) : this.ZFi.value = this.QFi.Osi(),
            this.aDi.addEventListener("click", Yv),
            this.iLi = t => this.eLi(),
            this.JFi.addEventListener("change", this.iLi),
            this.sLi = t => this.XOi(),
            this.JFi.addEventListener("focus", this.sLi),
            this.nLi = t => this.rLi(),
            this.JFi.addEventListener("blur", this.nLi),
            this.hLi = t => this.oLi(),
            this.ZFi.addEventListener("change", this.hLi),
            this.aLi = t => {
                if (Xv.Qs._O.OAi())
                    return t.preventDefault(),
                    void this.ZFi.blur();
                this.XOi()
            }
            ,
            this.ZFi.addEventListener("focus", this.aLi),
            this.lLi = t => this.Sbt.KOi(this),
            this.ZFi.addEventListener("blur", this.lLi),
            this.uLi = t => this.wG(t),
            this.ZFi.addEventListener("keydown", this.uLi),
            this.ZFi.addEventListener("dragstart", Xv.Qs.Pdt)
        }
        S0() {
            this.aDi.removeEventListener("click", Yv),
            this.bDi = null,
            this.vDi = null,
            this.SDi = null,
            this.xDi = null,
            this.JFi.removeEventListener("change", this.iLi),
            this.iLi = null,
            this.JFi.removeEventListener("focus", this.sLi),
            this.sLi = null,
            this.JFi.removeEventListener("blur", this.nLi),
            this.nLi = null,
            Xv.Qs.UO(this.JFi),
            this.JFi = null,
            this.ZFi.removeEventListener("change", this.hLi),
            this.hLi = null,
            this.ZFi.removeEventListener("focus", this.aLi),
            this.aLi = null,
            this.ZFi.removeEventListener("blur", this.lLi),
            this.lLi = null,
            this.ZFi.removeEventListener("keydown", this.uLi),
            this.uLi = null,
            this.ZFi.removeEventListener("dragstart", Xv.Qs.Pdt),
            Xv.Qs.UO(this.ZFi),
            this.ZFi = null,
            Xv.Qs.UO(this.kFi),
            this.kFi = null,
            super.S0()
        }
        mFi() {
            if (!this.vDi)
                return;
            let t = Xv.v(Xv.za, this.QFi)
              , i = Xv.v(Xv.za, this.TDi);
            this.CDi ? this.Sbt.wFi(this.vDi, t, this, i) : this.vDi(t, this, i),
            this.Sbt.vee(this)
        }
        YDi() {
            if (!this.bDi)
                return null;
            if (this.CDi) {
                const t = this.Sbt.pFi(this.bDi, this);
                return t && !this.IDi && (this.IDi = Xv.v(Xv.za, 0, 0, 0, 1),
                this.IDi.set(t)),
                t
            }
            {
                const t = this.bDi(this);
                return t && !this.IDi && (this.IDi = Xv.v(Xv.za, 0, 0, 0, 1),
                this.IDi.set(t)),
                t
            }
        }
        XSt() {
            this.xDi && this.xDi(this.La())
        }
        rLi() {
            this.eLi(!1),
            this.Sbt.KOi(this)
        }
        eLi(t=!0) {
            if (this.PDi || !this.vDi)
                return;
            if (!t && this.tLi)
                return;
            const i = this.JFi.value
              , e = this.IDi && this.IDi.GA();
            this.QFi.OA(this.JFi.value),
            this.PDi = !0,
            this.ZFi.value = this.QFi.Osi(),
            this.PDi = !1,
            this.IDi = null,
            this.cLi(),
            e && e !== i && this.Sbt.xee(this),
            t && this.JFi.focus()
        }
        oLi() {
            if (!this.PDi && this.vDi) {
                if (!this.QFi.Cx(this.ZFi.value))
                    return this.PDi = !0,
                    this.tLi ? (this.ZFi.value = "",
                    this.ZFi.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder"))) : (this.ZFi.value = this.QFi.Osi(),
                    this.ZFi.removeAttribute("placeholder")),
                    void (this.PDi = !1);
                this.PDi = !0,
                this.JFi.value = this.QFi.GA(),
                this.ZFi.value = this.QFi.Osi(),
                this.PDi = !1,
                this.cLi()
            }
        }
        cLi() {
            if (this.TDi && this.QFi && !this.TDi.wle(this.QFi) && this.XSt(),
            this.mFi(),
            this.TDi.set(this.QFi),
            this.tLi = !1,
            this.ZFi.removeAttribute("placeholder"),
            this.bDi) {
                let t = this.YDi();
                null === t ? (this.tLi = !0,
                this.QFi.wsi(0, 0, 0),
                this.TDi.wsi(0, 0, 0),
                this.PDi = !0,
                this.JFi.value = this.QFi.GA(),
                this.ZFi.value = "",
                this.ZFi.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder")),
                this.PDi = !1) : this.QFi.wle(t) || (this.tLi = !1,
                this.PDi = !0,
                this.QFi.wsi(t.r, t.g, t.b),
                this.TDi.wsi(t.r, t.g, t.b),
                this.JFi.value = this.QFi.GA(),
                this.ZFi.value = this.QFi.Osi(),
                this.PDi = !1)
            }
        }
        wG(t) {
            t.which === Xv.Mk.aY && (t.preventDefault(),
            this.ZFi.blur(),
            this.Sbt.GFi(this))
        }
        CEt() {
            this.JFi && this.JFi.focus()
        }
        dLi() {
            return this.JFi
        }
        rDi() {
            this.SDi && (this.CDi ? this.cA(this.Sbt.AFi(this.SDi)) : this.cA(this.SDi()))
        }
        dDi(t) {
            this.JFi.disabled = !t,
            this.ZFi.disabled = !t,
            this.ZFi.readOnly = !t
        }
        The() {
            if (!this.bDi)
                return;
            let t = this.YDi();
            this.tLi && null === t || !this.tLi && null !== t && t.wle(this.QFi) || (this.tLi = null === t,
            this.tLi ? (this.QFi.wsi(0, 0, 0),
            this.TDi && this.TDi.wsi(0, 0, 0),
            this.JFi.value = this.QFi.GA(),
            this.ZFi.value = "",
            this.ZFi.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder"))) : (this.QFi.wsi(t.r, t.g, t.b),
            this.TDi || (this.TDi = Xv.v(Xv.za, 0, 0, 0, 1)),
            this.TDi.wsi(t.r, t.g, t.b),
            this.JFi.value = this.QFi.GA(),
            this.ZFi.value = this.QFi.Osi(),
            this.ZFi.removeAttribute("placeholder")))
        }
        *lpe() {
            yield*super.lpe(),
            yield this.JFi,
            yield this.ZFi
        }
    }
}
{
    const Jv = self.t;
    function Zv(t) {
        t.preventDefault();
        let i = this.getAttribute("for")
          , e = this.ownerDocument.getElementById(i);
        e && e.focus()
    }
    Jv.Qs.Fk.fLi = class extends Jv.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            Jv.tot(n),
            Jv.tot(r),
            Jv.tot(h),
            this.pLi = Jv.Qs.W_("div", this.lDi, null, "checkpropertywrap"),
            this.y_i = Jv.Qs.W_("input", this.pLi),
            this.y_i.type = "checkbox",
            this.y_i.id = this.Bk(),
            this.aDi.addEventListener("click", Zv),
            this.bDi = n,
            this.vDi = r,
            this.SDi = h,
            this.xDi = this.Sbt.MDi(),
            this.TDi = null,
            this.CDi = o,
            this.PDi = !1,
            this.bDi && (this.TDi = this.YDi(),
            this.mLi(this.TDi)),
            this.VDi = t => this.WDi(),
            this.y_i.addEventListener("change", this.VDi),
            this.HDi = t => this.XOi(),
            this.y_i.addEventListener("focus", this.HDi),
            this.qDi = t => this.Sbt.KOi(this),
            this.y_i.addEventListener("blur", this.qDi),
            this.wLi = !1,
            this.mF = t => {
                t.button === Jv.gF.sV && t.isPrimary && t.target === this.pLi && ("mouse" !== !t.pointerType && t.preventDefault(),
                this.wLi = !0,
                this.y_i.focus())
            }
            ,
            this.pLi.addEventListener("pointerdown", this.mF),
            this.MB = t => {
                t.target === this.pLi && this.wLi && (t.preventDefault(),
                this.y_i.click()),
                this.wLi = !1
            }
            ,
            this.pLi.addEventListener("UITap", this.MB)
        }
        S0() {
            this.aDi.removeEventListener("click", Zv),
            this.bDi = null,
            this.vDi = null,
            this.SDi = null,
            this.xDi = null,
            this.TDi = null,
            this.y_i.removeEventListener("change", this.VDi),
            this.VDi = null,
            this.y_i.removeEventListener("focus", this.HDi),
            this.HDi = null,
            this.y_i.removeEventListener("blur", this.qDi),
            this.qDi = null,
            this.pLi.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.pLi.removeEventListener("UITap", this.MB),
            this.MB = null,
            Jv.Qs.UO(this.y_i),
            this.y_i = null,
            Jv.Qs.UO(this.pLi),
            this.pLi = null,
            super.S0()
        }
        YDi() {
            return this.bDi ? this.CDi ? this.Sbt.pFi(this.bDi, this) : this.bDi(this) : null
        }
        mFi(t) {
            this.vDi && (t = !!t,
            this.CDi ? this.Sbt.wFi(this.vDi, t, this) : this.vDi(t, this))
        }
        XSt() {
            this.xDi && this.xDi(this.La(), !!this.y_i.checked)
        }
        mLi(t) {
            this.PDi = !0,
            null === t ? this.y_i.indeterminate = !0 : (this.y_i.indeterminate = !1,
            this.y_i.checked = !!t),
            this.PDi = !1
        }
        WDi() {
            !this.PDi && this.vDi && (this.XSt(),
            this.mFi(!!this.y_i.checked),
            this.bDi && (this.TDi = this.YDi(),
            !!this.y_i.checked !== this.TDi && this.mLi(this.TDi)),
            this.Sbt.vee(this))
        }
        CEt() {
            this.y_i && this.y_i.focus()
        }
        bce() {
            return this.y_i
        }
        rDi() {
            this.SDi && (this.CDi ? this.cA(this.Sbt.AFi(this.SDi)) : this.cA(this.SDi()))
        }
        dDi(t) {
            this.y_i.disabled = !t
        }
        The() {
            if (!this.bDi)
                return;
            let t = this.YDi();
            t !== this.TDi && (this.TDi = t,
            this.mLi(this.TDi))
        }
        *lpe() {
            yield*super.lpe(),
            yield this.lDi
        }
    }
}
{
    const Qv = self.t;
    Qv.Qs.Fk.gLi = class extends Qv.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r, h) {
            super(t, i, e, s),
            Qv.tot(n),
            this.yLi = Qv.Qs.W_("span", this.lDi, null, "infoProperty"),
            this.yLi.setAttribute("tabindex", "-1"),
            this.bLi = n,
            this.TDi = null,
            this.SDi = r,
            this.CDi = h,
            this.The(),
            this.cA(!1)
        }
        YDi() {
            return this.bLi ? this.CDi ? this.Sbt.pFi(this.bLi, this) : this.bLi(this) : null
        }
        The() {
            if (!this.bLi)
                return;
            let t = this.YDi();
            null === t ? t = self.lang("ui.bars.properties.multiple-placeholder") : Qv.bti(t) || (t = t.toString()),
            Qv.Boi(this.TDi, t) || (this.TDi = t,
            Qv.wQ(this.yLi, this.TDi))
        }
        CEt() {
            this.yLi && this.yLi.focus()
        }
        S0() {
            Qv.Qs.UO(this.yLi),
            this.yLi = null,
            this.bLi = null,
            this.SDi = null,
            this.TDi = null,
            super.S0()
        }
        vLi() {
            return this.yLi
        }
        rDi() {
            this.SDi && (this.CDi ? this.cA(this.Sbt.AFi(this.SDi)) : this.cA(this.SDi()))
        }
    }
}
{
    const tS = self.t;
    tS.Qs.Fk.SLi = class extends tS.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            tS.tot(n),
            tS.tot(r),
            tS.tot(h),
            this.kFi = tS.Qs.W_("div", this.lDi, null, "flexVstretch"),
            this.xLi = tS.Qs.W_("div", this.kFi, null, "iconPropertyWrap"),
            this.xLi.id = this.Bk(),
            this.BGt = tS.v(tS.Qs._q, self.app.m4(), this.xLi),
            this.MLi = tS.Qs.W_("div", this.xLi, null, "iconPropertyLabel"),
            this.OFi = tS.Qs.W_("button", this.kFi, null, "iconProperty"),
            this.OFi.textContent = self.lang("common.ellipsis"),
            this.bDi = n,
            this.vDi = r,
            this.SDi = h,
            this.xDi = this.Sbt.MDi(),
            this.CDi = o,
            this.TDi = null,
            this.FFi = t => this.LFi(),
            this.OFi.addEventListener("click", this.FFi),
            this.ELi = null,
            this.CLi = null
        }
        S0() {
            this.bDi = null,
            this.vDi = null,
            this.SDi = null,
            this.xDi = null,
            this.TDi = null,
            this.BGt.he(),
            this.BGt = null,
            tS.Qs.UO(this.MLi),
            this.MLi = null,
            tS.Qs.UO(this.xLi),
            this.xLi = null,
            this.OFi.removeEventListener("click", this.FFi),
            this.FFi = null,
            this.ELi = null,
            this.CLi = null,
            tS.Qs.UO(this.OFi),
            this.OFi = null,
            tS.Qs.UO(this.kFi),
            this.kFi = null,
            super.S0()
        }
        YDi() {
            return this.bDi ? this.CDi ? this.Sbt.pFi(this.bDi, this) : this.bDi(this) : null
        }
        mFi(t) {
            this.vDi && (this.CDi ? this.Sbt.wFi(this.vDi, t, this) : this.vDi(t, this))
        }
        XSt() {
            this.xDi && this.xDi(this.La())
        }
        _Li(t) {
            if (null === t)
                this.BGt.m0(null),
                this.MLi.textContent = self.lang("ui.bars.properties.multiple-placeholder");
            else {
                if (!this.CLi)
                    throw new Error("no display info function");
                const i = this.CLi(t);
                null === i ? (this.BGt.m0(null),
                this.MLi.textContent = "") : (this.BGt.m0(i.icon),
                this.MLi.textContent = i.text)
            }
        }
        CEt() {
            this.OFi && this.OFi.focus()
        }
        uae(t) {
            tS.nu(t),
            this.ELi = t
        }
        dae(t) {
            tS.zt(t),
            this.OFi.textContent = t
        }
        async LFi() {
            if (!this.ELi)
                throw new Error("no button click handler");
            const t = await this.ELi(this.TDi);
            this.OFi && null !== t && t !== this.TDi && (this.mFi(t),
            this.TDi = t,
            this._Li(t),
            this.Sbt.vee(this))
        }
        Aae(t) {
            tS.nu(t),
            this.CLi = t,
            this.bDi && (this.TDi = this.YDi(),
            this._Li(this.TDi))
        }
        rDi() {
            this.SDi && (this.CDi ? this.cA(this.Sbt.AFi(this.SDi)) : this.cA(this.SDi()))
        }
        dDi(t) {
            this.OFi.disabled = !t
        }
        The() {
            if (!this.bDi)
                return;
            const t = this.YDi();
            t !== this.TDi && (this.TDi = t,
            this._Li(this.TDi))
        }
        *lpe() {
            yield*super.lpe(),
            yield this.xLi
        }
    }
}
{
    const iS = self.t;
    iS.Qs.Fk.TLi = class extends iS.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r) {
            if (super(t, i, e, s),
            iS.zt(n),
            this.ILi = iS.Qs.W_("a", this.lDi),
            this.ILi.setAttribute("tabindex", -1),
            this.nse() && this.ILi.setAttribute("title", this.nse()),
            this.PLi = null,
            "string" == typeof r)
                this.ILi.href = r,
                this.PLi = t => {
                    t.preventDefault(),
                    self.app.pQ(r, "PropertiesBar-LinkProperty")
                }
                ;
            else {
                if ("function" != typeof r)
                    throw new TypeError("expected string or function");
                this.PLi = r
            }
            this.ILi.addEventListener("click", this.PLi),
            this.ILi.textContent = n,
            this.HDi = t => this.XOi(),
            this.ILi.addEventListener("focus", this.HDi),
            this.qDi = t => this.Sbt.KOi(this),
            this.ILi.addEventListener("blur", this.qDi)
        }
        S0() {
            this.ILi.removeEventListener("focus", this.HDi),
            this.HDi = null,
            this.ILi.removeEventListener("blur", this.qDi),
            this.qDi = null,
            this.PLi && (this.ILi.removeEventListener("click", this.PLi),
            this.PLi = null),
            iS.Qs.UO(this.ILi),
            this.ILi = null,
            super.S0()
        }
        CEt() {
            this.ILi && this.ILi.focus()
        }
        Cce() {
            return this.ILi
        }
        GLi(t) {
            if (iS.zt(t),
            this.PLi)
                throw new Error("not an external link");
            this.ILi.href = t
        }
        ALi(t) {
            iS.zt(t),
            this.ILi.textContent = t
        }
    }
}
{
    const eS = self.t;
    eS.Qs.Fk.RLi = class extends eS.Qs.Fk.rpe {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.cYt = eS.Qs.W_("td", this.ght),
            this.cYt.setAttribute("colspan", "2"),
            this.cYt.setAttribute("tabindex", "-1"),
            this.cYt.setAttribute("propgroup", ""),
            this.cYt.setAttribute("role", "heading"),
            this.fJt = eS.Qs.W_("div", this.cYt, null, "propgroup-wrap");
            let n = this.JOi();
            n > 0 && this.fJt.setAttribute("level" + n, ""),
            this.aDi = eS.Qs.W_("label", this.fJt, null, "propgroup-label"),
            this.aDi.textContent = i,
            this.kLi = eS.v(eS.Qs._q, self.app.oi("expanded"), this.fJt),
            this.OLi = !0,
            this.DLi = [],
            this.FLi = t => this.XOi(),
            this.cYt.addEventListener("focus", this.FLi),
            this.LLi = t => this.Sbt.KOi(this),
            this.cYt.addEventListener("blur", this.LLi),
            this.BLi = t => this.NKt(!0),
            this.aDi.addEventListener("UIDoubleTap", this.BLi),
            this.kLi.k_().addEventListener("pointerdown", this.BLi),
            this.ght.classList.add("propertyGroup")
        }
        S0() {
            this.kLi.k_().removeEventListener("pointerdown", this.BLi),
            this.kLi.he(),
            this.kLi = null,
            this.aDi.removeEventListener("UIDoubleTap", this.BLi),
            this.BLi = null,
            eS.Qs.UO(this.aDi),
            this.aDi = null,
            eS.Qs.UO(this.fJt),
            this.fJt = null,
            this.cYt.removeEventListener("blur", this.LLi),
            this.LLi = null,
            this.cYt.removeEventListener("focus", this.FLi),
            this.FLi = null,
            eS.Qs.UO(this.cYt),
            this.cYt = null,
            super.S0()
        }
        CEt() {
            this.cYt && this.cYt.focus()
        }
        uDi() {
            return this.cYt
        }
        nre() {
            return this.aDi
        }
        ULi() {
            if (this.DLi.length <= 2) {
                for (let t of this.DLi)
                    if (t instanceof eS.Qs.Fk.RLi)
                        return !0;
                return !1
            }
            return !0
        }
        z6() {
            return this.OLi
        }
        v6(t, i) {
            t = !!t,
            i = !!i,
            this.OLi !== t && (this.Sbt.tDi() || (this.ULi() || (i = !1),
            this.OLi = t,
            this.kLi.m0(self.app.oi(this.OLi ? "expanded" : "collapsed")),
            this.NLi(i)))
        }
        NKt(t) {
            t = !!t,
            this.v6(!this.z6(), t)
        }
        QOi(t, i) {
            t = !!t,
            i = !!i,
            super.QOi(t, i),
            this.NLi(i)
        }
        NLi(t) {
            let i = this.OLi && this.B6();
            for (let e of this.DLi)
                e.QOi(i, t)
        }
        Obt(t, i, e, s, n, r, h) {
            let o = eS.v(eS.Qs.Fk.mDi, this.Sbt, t, i, e, this, s, n, r, !!h);
            return o.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(o),
            this.DLi.push(o),
            o
        }
        sse(t, i, e, s, n, r) {
            let h = eS.v(eS.Qs.Fk.RFi, this.Sbt, t, i, this, e, s, n, !!r);
            return h.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(h),
            this.DLi.push(h),
            h
        }
        gse(t, i, e, s, n, r) {
            let h = eS.v(eS.Qs.Fk.$Fi, this.Sbt, t, i, this, e, s, n, !!r);
            return h.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(h),
            this.DLi.push(h),
            h
        }
        hse(t, i, e, s, n, r) {
            let h = eS.v(eS.Qs.Fk.YFi, this.Sbt, t, i, this, e, s, n, !!r);
            return h.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(h),
            this.DLi.push(h),
            h
        }
        Yte(t, i, e, s, n, r) {
            let h = eS.v(eS.Qs.Fk.fLi, this.Sbt, t, i, this, e, s, n, !!r);
            return h.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(h),
            this.DLi.push(h),
            h
        }
        Mse(t, i, e, s, n) {
            let r = eS.v(eS.Qs.Fk.gLi, this.Sbt, t, i, this, e, s, n);
            return r.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(r),
            this.DLi.push(r),
            r
        }
        Iae(t, i, e, s, n, r) {
            let h = eS.v(eS.Qs.Fk.SLi, this.Sbt, t, i, this, e, s, n, r);
            return h.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(h),
            this.DLi.push(h),
            h
        }
        zne(t, i, e, s) {
            let n = eS.v(eS.Qs.Fk.TLi, this.Sbt, t, i, this, e, s);
            return n.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(n),
            this.DLi.push(n),
            n
        }
        Cbt(t, i) {
            let e = eS.v(eS.Qs.Fk.RLi, this.Sbt, t, i, this);
            return e.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(e),
            this.DLi.push(e),
            e
        }
        $se(t, i, e, s) {
            let n = eS.v(eS.Qs.Fk.IFi, this.Sbt, t, i, e, this, s);
            return n.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(n),
            this.DLi.push(n),
            n
        }
        *children() {
            for (let t of this.DLi)
                yield t
        }
        S5() {
            return {
                name: this.La(),
                expanded: this.z6(),
                children: this.DLi.map(t => t.S5()).filter(t => t)
            }
        }
        Q3(t) {
            if (t) {
                for (let i of t.children) {
                    let t = this.$Li(i.name);
                    t && t.Q3(i)
                }
                this.v6(t.expanded)
            }
        }
        $Li(t) {
            eS.zt(t);
            for (let i of this.DLi)
                if (i.La() === t)
                    return i
        }
    }
}
{
    const sS = self.t
      , nS = 3;
    sS.Qs.Fk.IFi = class extends sS.Qs.Fk.hDi {
        constructor(t, i, e, s, n, r) {
            if (super(t, i, e, n),
            sS.zt(s),
            !s)
                throw new Error("non-empty separator required");
            this.zLi = s,
            this.VLi = [],
            this.SDi = r,
            this.WLi = sS.Qs.W_("input", this.lDi),
            this.WLi.type = "text",
            this.WLi.id = this.Bk(),
            this.WLi.setAttribute("spellcheck", "false"),
            this.kLi = sS.v(sS.Qs._q, self.app.oi("collapsed"), this.fJt),
            this.HLi = t => this.NKt(!0),
            this.kLi.k_().addEventListener("pointerdown", this.HLi),
            this.PDi = !1,
            this.GDi = !0,
            this.ADi = !1,
            this.xDi = this.Sbt.MDi(),
            this.IDi = null,
            this.OLi = !1,
            this.DLi = [],
            this.VDi = t => this.WDi(),
            this.WLi.addEventListener("change", this.VDi),
            this.HDi = t => {
                if (sS.Qs._O.OAi())
                    return t.preventDefault(),
                    void this.WLi.blur();
                this.XOi(),
                this.GDi = !1,
                this.Sbt.KDi( () => {
                    this.WLi && this.x5()
                }
                )
            }
            ,
            this.WLi.addEventListener("focus", this.HDi),
            this.qDi = t => {
                this.Sbt.KOi(this),
                this.GDi = !0,
                this.ADi = !1,
                this.IDi !== this.WLi.value && (this.Sbt.xee(this),
                this.IDi = this.WLi.value)
            }
            ,
            this.WLi.addEventListener("blur", this.qDi),
            this.mF = t => {
                this.GDi && (this.ADi = !0,
                this.GDi = !1)
            }
            ,
            this.WLi.addEventListener("pointerdown", this.mF),
            this.zM = -1,
            this.uG = t => {
                this.ADi && (this.ADi = !1,
                this.zM = requestAnimationFrame( () => {
                    this.WLi && this.WLi.select(),
                    this.zM = -1
                }
                ))
            }
            ,
            this.WLi.addEventListener("pointerup", this.uG),
            this.KLi = t => {
                this.GDi = !1,
                this.ADi = !1,
                cancelAnimationFrame(this.zM),
                this.zM = -1
            }
            ,
            this.WLi.addEventListener("pointercancel", this.KLi),
            this.pG = t => this.wG(t),
            this.WLi.addEventListener("keydown", this.pG),
            this.WLi.addEventListener("dragstart", sS.Qs.Pdt),
            this.BLi = t => this.NKt(!0),
            this.aDi.addEventListener("UIDoubleTap", this.BLi)
        }
        S0() {
            this.xDi = null,
            this.SDi = null,
            this.IDi = null,
            this.aDi.removeEventListener("UIDoubleTap", this.BLi),
            this.BLi = null,
            this.WLi.removeEventListener("change", this.VDi),
            this.VDi = null,
            this.WLi.removeEventListener("focus", this.HDi),
            this.HDi = null,
            this.WLi.removeEventListener("blur", this.qDi),
            this.qDi = null,
            this.WLi.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.WLi.removeEventListener("pointerup", this.uG),
            this.uG = null,
            this.WLi.removeEventListener("pointercancel", this.KLi),
            this.KLi = null,
            this.WLi.removeEventListener("keydown", this.pG),
            this.pG = null,
            this.WLi.removeEventListener("dragstart", sS.Qs.Pdt),
            sS.Qs.UO(this.WLi),
            this.WLi = null,
            this.kLi.k_().removeEventListener("pointerdown", this.HLi),
            this.HLi = null,
            this.kLi.he(),
            this.kLi = null,
            super.S0()
        }
        XOi() {
            this.WLi.select(),
            super.XOi()
        }
        CEt() {
            this.WLi && this.WLi.focus()
        }
        XSt() {
            this.xDi && this.xDi(this.La())
        }
        qLi() {
            let t = [];
            for (let i of this.DLi)
                i.yFi() || t.push(i);
            return t
        }
        zse(t) {
            if ("string" == typeof t)
                this.VLi = [t];
            else {
                if (!Array.isArray(t))
                    throw new Error("expected string or array");
                this.VLi = t
            }
        }
        WDi() {
            if (this.PDi)
                return;
            this.XSt(),
            this.PDi = !0;
            const t = this.WLi.value.trim()
              , i = this.zLi.trim();
            let e = t.split(i);
            if (1 === e.length)
                for (const i of this.VLi) {
                    const s = i.trim()
                      , n = t.split(s);
                    if (n.length >= 2) {
                        e = n;
                        break
                    }
                }
            const s = this.qLi()
              , n = Math.min(e.length, s.length);
            for (let t = 0; t < n; ++t) {
                const i = e[t].trim();
                s[t].xFi(i)
            }
            this.PFi(),
            this.PDi = !1
        }
        PFi() {
            let t = ""
              , i = this.qLi();
            for (let e = 0, s = i.length; e < s; ++e) {
                t += i[e].CFi(),
                e < s - 1 && (t += this.zLi)
            }
            this.WLi.value !== t && (this.PDi = !0,
            this.WLi.value = t,
            this.PDi = !1)
        }
        Foe() {
            this.PFi(),
            this.IDi = this.WLi.value
        }
        wG(t) {
            t.which === sS.Mk.aY && (t.preventDefault(),
            this.WLi.blur(),
            this.Sbt.GFi(this))
        }
        rDi() {
            this.SDi && this.cA(this.SDi())
        }
        dDi(t) {
            this.WLi.disabled = !t,
            this.WLi.readOnly = !t
        }
        XLi() {
            return this.WLi
        }
        z6() {
            return this.OLi
        }
        v6(t, i) {
            t = !!t,
            i = !!i,
            this.OLi !== t && (this.DLi.length <= nS && (i = !1),
            this.OLi = t,
            this.kLi.m0(self.app.oi(this.OLi ? "expanded" : "collapsed")),
            this.NLi(i))
        }
        NKt(t) {
            t = !!t,
            this.v6(!this.z6(), t)
        }
        QOi(t, i) {
            t = !!t,
            i = !!i,
            super.QOi(t, i),
            this.NLi(i)
        }
        NLi(t) {
            let i = this.OLi && this.B6();
            for (let e of this.DLi)
                e.QOi(i, t)
        }
        Obt(t, i, e, s, n, r, h) {
            let o = sS.v(sS.Qs.Fk.mDi, this.Sbt, t, i, e, this, s, n, r, !!h);
            return o.QOi(this.OLi && this.B6()),
            this.Sbt.jLi.push(o),
            this.DLi.push(o),
            this.PFi(),
            this.IDi = this.WLi.value,
            o
        }
        S5() {
            return {
                name: this.La(),
                expanded: this.z6(),
                children: this.DLi.map(t => t.S5()).filter(t => t)
            }
        }
        Q3(t) {
            if (t) {
                for (let i of t.children) {
                    let t = this.$Li(i.name);
                    t && t.Q3(i)
                }
                this.v6(t.expanded)
            }
        }
        $Li(t) {
            sS.zt(t);
            for (let i of this.DLi)
                if (i.La() === t)
                    return i
        }
        *lpe() {
            yield*super.lpe(),
            yield this.WLi
        }
    }
}
{
    const rS = self.t
      , hS = 2
      , oS = 300
      , aS = {
        resizable: !1,
        YLi: {
            borderTop: !0,
            borderLeft: !1,
            borderRight: !1,
            borderBottom: !1
        }
    };
    rS.Qs.Fk.Mbt = class extends rS.Event.v_ {
        constructor(t, i) {
            super(),
            rS.kQ(i),
            i = Object.assign({}, aS, i),
            this.c8 = t,
            this.ght = rS.Qs.W_("ui-propertygrid", this.c8),
            this.JLi = rS.Qs.W_("ui-propertygrid-container", this.ght),
            this.ZLi = rS.Qs.W_("ui-propertygrid-table", this.JLi),
            this.ZLi.setAttribute("role", "none"),
            this.QLi = rS.Qs.W_("tr", this.ZLi),
            this.tBi = rS.Qs.W_("td", this.QLi, null, "firstRow"),
            this.tBi.style.width = "50%",
            this.tBi.classList.add("firstRow"),
            this.iBi = rS.Qs.W_("td", this.QLi, null, "firstRow"),
            this.eBi = rS.Qs.W_("ui-propertygrid-footer", this.ght),
            this.eBi.style.display = "none",
            i.YLi.borderTop && this.eBi.setAttribute("useBorderTop", ""),
            i.YLi.borderLeft && this.eBi.setAttribute("useBorderLeft", ""),
            i.YLi.borderRight && this.eBi.setAttribute("useBorderRight", ""),
            i.YLi.borderBottom && this.eBi.setAttribute("useBorderBottom", ""),
            this.sBi = rS.Qs.W_("span", this.eBi, null, "property-footer-title"),
            this.nBi = rS.Qs.W_("span", this.eBi, null, "property-footer-description"),
            this.rBi = !!i.resizable,
            this.jLi = [],
            this.xDi = null,
            this.hBi = null,
            this.oBi = null,
            this.aBi = 0,
            this.lBi = null,
            this.uBi = 0,
            this.cBi = [],
            this.dBi = -1,
            this.fBi = [],
            this.pBi = () => this.mBi(!1),
            this.wBi = -1,
            this.gBi = [],
            this.yBi = () => this.bBi(!1),
            this.vBi = !0,
            this.SBi = 1,
            this.mF = t => this.mO(t),
            this.cG = t => this.fG(t),
            this.KLi = t => this.IN(t),
            this.xBi = t => this.MBi(t),
            this.eFi = t => this.EBi(t),
            this.sFi = t => this.CBi(t),
            this.wF = null,
            this._Bi = {
                onpointerdown: this.mF,
                onpointermove: this.xBi,
                onpointerup: this.eFi,
                onpointercancel: this.sFi
            },
            this.TBi = !1,
            this.Y2t = 0,
            this.Q2t = null,
            this.IBi = -1,
            this.rBi && (this.ZLi.addEventListener("pointerdown", this.mF, !0),
            this.ZLi.addEventListener("pointermove", this.cG),
            this.ZLi.addEventListener("pointercancel", this.KLi),
            this.FO().addEventListener("pointermove", this.xBi),
            this.FO().addEventListener("pointerup", this.eFi),
            this.FO().addEventListener("pointercancel", this.sFi))
        }
        he() {
            this.PBi(),
            this.Ry(),
            this.q5t(),
            this.ZLi.removeEventListener("pointerdown", this.mF, !0),
            this.mF = null,
            this.ZLi.removeEventListener("pointermove", this.cG),
            this.cG = null,
            this.FO().removeEventListener("pointermove", this.xBi),
            this.xBi = null,
            this.FO().removeEventListener("pointerup", this.eFi),
            this.eFi = null,
            this.ZLi.removeEventListener("pointercancel", this.KLi),
            this.KLi = null,
            this.FO().removeEventListener("pointercancel", this.sFi),
            this.sFi = null,
            rS.Qs.UO(this.Q2t),
            this.Q2t = null,
            rS.Qs.UO(this.iBi),
            this.iBi = null,
            rS.Qs.UO(this.tBi),
            this.tBi = null,
            rS.Qs.UO(this.QLi),
            this.QLi = null,
            rS.Qs.UO(this.ZLi),
            this.ZLi = null,
            rS.Qs.UO(this.JLi),
            this.JLi = null,
            rS.Qs.UO(this.eBi),
            this.eBi = null,
            rS.Qs.UO(this.ght),
            this.ght = null,
            this.c8 = null,
            this.pBi = null,
            this.yBi = null,
            this.oBi = null,
            super.he()
        }
        Ry() {
            this.PBi(),
            this.fGi(),
            rS.Io(this.cBi),
            this.GBi("", ""),
            -1 !== this.dBi && (this.LO().cancelAnimationFrame(this.dBi),
            this.dBi = -1),
            rS.Io(this.fBi),
            -1 !== this.wBi && (this.LO().cancelAnimationFrame(this.wBi),
            this.wBi = -1),
            rS.Io(this.gBi);
            for (let t = this.jLi.length - 1; t >= 0; --t)
                this.jLi[t].S0();
            this.xDi = null,
            this.hBi = null,
            rS.Io(this.jLi),
            this.aBi = 0
        }
        q5t() {
            rS.Qs.sk.hk(this.wF),
            this.wF = null
        }
        fGi() {
            let t = document.activeElement;
            for (; t; )
                if (t = t.parentElement,
                t === this.ZLi)
                    return void document.activeElement.blur()
        }
        k_() {
            return this.ght
        }
        zOi() {
            return "propid" + this.aBi++
        }
        WOi() {
            return this.ZLi
        }
        FO() {
            return this.k_().ownerDocument
        }
        LO() {
            return this.FO().defaultView
        }
        GBi(t, i) {
            rS.zt(t),
            rS.zt(i);
            let e = this.JLi.scrollTop;
            if (t && "" !== t) {
                let i = self.lang("ui.bars.properties.footer-title-prefix")
                  , e = self.lang("ui.bars.properties.footer-title-suffix");
                this.sBi.textContent = i + t + e
            } else
                rS.Qs.L6(this.sBi);
            i ? this.nBi.textContent = i : rS.Qs.L6(this.nBi),
            this.eBi.style.display = t || i ? "" : "none",
            this.JLi.scrollTop = e
        }
        Yie(t) {
            if (rS.RH(t),
            !t.length)
                throw new Error("cannot set empty item array");
            rS.mf(this.cBi, t)
        }
        b8(t) {
            rS.ibt(t),
            this.c8 !== t && (this.c8 && this.c8.removeChild(this.ght),
            this.c8 = t,
            this.c8.appendChild(this.ght))
        }
        Jte(t) {
            rS.tot(t),
            this.xDi = t
        }
        MDi() {
            return this.xDi
        }
        Vne(t) {
            rS.tot(t),
            this.hBi = t
        }
        sDi() {
            return this.hBi
        }
        pFi(t, i) {
            if (!this.cBi.length)
                throw new Error("no item array available");
            let e = t(this.cBi[0], i)
              , s = e instanceof rS.za;
            for (let n = 1, r = this.cBi.length; n < r; ++n) {
                let r = t(this.cBi[n], i);
                if (s) {
                    if (!e.wle(r))
                        return null
                } else if (r !== e)
                    return null
            }
            return e
        }
        wFi(t, i, e, s) {
            if (!this.cBi.length)
                throw new Error("no item array available");
            for (let n of this.cBi)
                t(n, i, e, s)
        }
        AFi(t) {
            rS.nu(t);
            for (let i of this.cBi)
                if (t(i))
                    return !0;
            return !1
        }
        Ez(t) {
            return rS.U(t, rS.Qs.Fk.rpe),
            this.lBi === t
        }
        YOi(t) {
            if (rS.U(t, rS.Qs.Fk.rpe),
            !this.jLi.includes(t))
                throw new Error("property not from this grid");
            this.PBi(),
            this.lBi && this.lBi.uDi().removeAttribute("selected"),
            this.lBi = t,
            this.lBi.uDi().setAttribute("selected", ""),
            this.GBi(this.lBi.La(), this.lBi.nse())
        }
        GFi(t) {
            rS.U(t, rS.Qs.Fk.rpe);
            let i = this.jLi.indexOf(t);
            if (!(i < 0)) {
                ++i;
                for (let t = this.jLi.length; i < t; ++i) {
                    let t = this.jLi[i];
                    if (t.B6())
                        return this.YOi(t),
                        void t.CEt()
                }
            }
        }
        KOi(t) {
            if (rS.U(t, rS.Qs.Fk.rpe),
            this.lBi === t) {
                let t = this.lBi.uDi();
                t && t.removeAttribute("selected"),
                this.lBi = null,
                this.PBi()
            }
        }
        KDi(t) {
            rS.nu(t),
            this.PBi(),
            this.IBi = self.setTimeout( () => {
                this.IBi = -1,
                t()
            }
            , oS)
        }
        PBi() {
            -1 !== this.IBi && (self.clearTimeout(this.IBi),
            this.IBi = -1)
        }
        XEt(t) {
            this.PBi(),
            rS.Qs.x5(t.uDi(), this.JLi)
        }
        tDi() {
            return -1 !== this.dBi || -1 !== this.wBi
        }
        iDi() {
            for (; -1 !== this.dBi; )
                this.mBi(!0);
            for (; -1 !== this.wBi; )
                this.bBi(!0)
        }
        eDi(t) {
            rS.U(t, rS.Qs.Fk.rpe),
            -1 !== this.wBi && this.iDi(),
            -1 === this.dBi && (this.dBi = this.LO().requestAnimationFrame(this.pBi),
            this.vBi = !0),
            this.fBi.push(t)
        }
        nDi(t) {
            rS.U(t, rS.Qs.Fk.rpe),
            -1 !== this.dBi && this.iDi(),
            -1 === this.wBi && (this.wBi = this.LO().requestAnimationFrame(this.yBi),
            this.vBi = !0),
            this.gBi.push(t)
        }
        mBi(t) {
            this.dBi = -1,
            this.vBi && (this.SBi = Math.max(Math.round(this.fBi.length / 10), 1),
            this.vBi = !1);
            for (let t = 0; t < this.SBi && this.fBi.length; ++t) {
                this.fBi.shift().Kte().removeAttribute("collapsed")
            }
            if (this.fBi.length && !t)
                return void (this.dBi = this.LO().requestAnimationFrame(this.pBi));
            let i = this.sDi();
            i && i()
        }
        bBi(t) {
            this.wBi = -1,
            this.vBi && (this.SBi = Math.max(Math.round(this.gBi.length / 10), 1),
            this.vBi = !1);
            for (let t = 0; t < this.SBi && this.gBi.length; ++t) {
                this.gBi.pop().Kte().setAttribute("collapsed", "")
            }
            if (this.gBi.length && !t)
                return void (this.wBi = this.LO().requestAnimationFrame(this.yBi));
            let i = this.sDi();
            i && i()
        }
        vee(t) {
            this.zte();
            const i = new rS.Event("afteranypropertychanged");
            i.Ote = t,
            this.dispatchEvent(i)
        }
        xee(t) {
            this.zte();
            const i = new rS.Event("anypropertychangedafterblur");
            i.Ote = t,
            this.dispatchEvent(i)
        }
        qOi(t, i, e) {
            const s = new rS.Event(t);
            s.Ote = i,
            s.Sue = e,
            this.dispatchEvent(s)
        }
        pDi(t) {
            return new Promise(i => {
                const e = s => {
                    s.Ote === t && (this.removeEventListener("afteranypropertychanged", e),
                    i(t))
                }
                ;
                this.addEventListener("afteranypropertychanged", e)
            }
            )
        }
        zte() {
            this.Ebt(),
            this.ABi()
        }
        Ebt() {
            for (let t of this.jLi)
                t.rDi()
        }
        ABi() {
            for (let t of this.jLi)
                t.The()
        }
        Ate() {
            return this.uBi = this.JLi.scrollTop,
            this.uBi
        }
        Mte(t) {
            rS.iM(t),
            this.JLi.scrollTop = "number" == typeof t ? t : this.uBi
        }
        see(t) {
            rS.tot(t),
            this.oBi = t
        }
        SFi() {
            return !!this.oBi
        }
        _Fi() {
            return this.oBi
        }
        Obt(t, i, e, s, n, r, h) {
            let o = rS.v(rS.Qs.Fk.mDi, this, t, i, e, null, s, n, r, !!h);
            return this.jLi.push(o),
            o
        }
        sse(t, i, e, s, n, r) {
            let h = rS.v(rS.Qs.Fk.RFi, this, t, i, null, e, s, n, !!r);
            return this.jLi.push(h),
            h
        }
        gse(t, i, e, s, n, r) {
            let h = rS.v(rS.Qs.Fk.$Fi, this, t, i, null, e, s, n, !!r);
            return this.jLi.push(h),
            h
        }
        hse(t, i, e, s, n, r) {
            let h = rS.v(rS.Qs.Fk.YFi, this, t, i, null, e, s, n, !!r);
            return this.jLi.push(h),
            h
        }
        Yte(t, i, e, s, n, r) {
            let h = rS.v(rS.Qs.Fk.fLi, this, t, i, null, e, s, n, !!r);
            return this.jLi.push(h),
            h
        }
        Mse(t, i, e, s, n) {
            let r = rS.v(rS.Qs.Fk.gLi, this, t, i, null, e, s, n);
            return this.jLi.push(r),
            r
        }
        Iae(t, i, e, s, n, r) {
            let h = rS.v(rS.Qs.Fk.SLi, this, t, i, null, e, s, n, r);
            return this.jLi.push(h),
            h
        }
        zne(t, i, e, s) {
            let n = rS.v(rS.Qs.Fk.TLi, this, t, i, null, e, s);
            return this.jLi.push(n),
            n
        }
        Cbt(t, i) {
            let e = rS.v(rS.Qs.Fk.RLi, this, t, i, null);
            return this.jLi.push(e),
            e
        }
        $se(t, i, e) {
            let s = rS.v(rS.Qs.Fk.IFi, this, t, i, e, null);
            return this.jLi.push(s),
            s
        }
        RBi(t, i) {
            if (rS.Ge(t),
            rS.Ge(i),
            !rS.Qs.TO.Gxi())
                return !1;
            let e = this.JLi.getBoundingClientRect()
              , s = this.tBi.getBoundingClientRect().width
              , n = e.left + s;
            return Math.abs(t - n) <= hS && i > e.top && i < e.bottom
        }
        mO(t) {
            let i = t.clientX
              , e = t.clientY;
            t.button === rS.gF.sV && t.isPrimary && (this.TBi || this.RBi(i, e) && (t.preventDefault(),
            t.stopPropagation(),
            this.TBi = !0,
            this.Y2t = i,
            this.Q2t = rS.Qs.W_("div", this.JLi, null, "columnResizeIndicator"),
            this.Q2t.style.height = this.ZLi.getBoundingClientRect().height + "px",
            this.b7t(i)))
        }
        fG(t) {
            if (!t.isPrimary)
                return;
            const i = t.clientX
              , e = t.clientY;
            this.RBi(i, e) && (this.wF || (this.wF = rS.Qs.sk.ik("col-resize", this.FO(), i, e, this._Bi)))
        }
        IN(t) {
            this.q5t()
        }
        MBi(t) {
            const i = t.clientX
              , e = t.clientY;
            t.isPrimary && (this.TBi ? (this.wF || (this.wF = rS.Qs.sk.ik("col-resize", this.FO(), i, e, this._Bi)),
            this.TBi && this.b7t(i)) : this.wF && !this.RBi(i, e) && this.q5t())
        }
        b7t(t) {
            rS.Ge(t),
            t -= 2;
            let i = this.ZLi.getBoundingClientRect()
              , e = i.left
              , s = Math.round(.1 * i.width)
              , n = Math.round(.9 * i.width)
              , r = rS.Ne(t - e, s, n);
            this.Q2t.style.transform = `translate(${r}px,0px)`
        }
        EBi(t) {
            let i = t.clientX;
            t.clientY;
            if (!this.TBi)
                return;
            if (!t.isPrimary)
                return;
            this.TBi = !1,
            rS.Qs.UO(this.Q2t),
            this.Q2t = null;
            let e = this.ZLi.getBoundingClientRect()
              , s = rS.Ne((i - e.left) / e.width, .1, .9);
            this.tBi.style.width = 100 * s + "%"
        }
        CBi(t) {
            this.TBi = !1,
            rS.Qs.UO(this.Q2t),
            this.Q2t = null,
            this.q5t()
        }
        S5() {
            let t = {
                properties: []
            };
            for (let i of this.jLi) {
                if (null !== i.dD())
                    continue;
                let e = i.S5();
                e && t.properties.push(e)
            }
            return t.scrollPosition = this.uBi,
            t
        }
        Q3(t) {
            if (t && t.properties) {
                for (let i of t.properties) {
                    let t = this.$Li(i.name);
                    t && t.Q3(i)
                }
                rS.ub(t.scrollPosition) && (this.uBi = t.scrollPosition,
                this.Mte())
            }
        }
        $Li(t) {
            rS.zt(t);
            for (const i of this.jLi)
                if (i.La() === t)
                    return i
        }
        kBi(t) {
            rS.zt(t);
            for (const i of this.jLi)
                if (i.ZOi() === t)
                    return i;
            return null
        }
        OBi() {
            for (const t of this.jLi)
                if (t.Pit())
                    return !0;
            return !1
        }
        f1() {
            if (this.OBi())
                for (const t of this.jLi)
                    t.f1()
        }
    }
}
{
    const lS = self.t
      , uS = lS.bW(import.meta.url)
      , cS = uS.getElementById("longTextPropertyDialog")
      , dS = "LongTextPropertyDialog"
      , fS = lS.Qs.Fk.DBi = class extends lS.Qs.Ks {
        constructor() {
            super(cS),
            this.FBi = uS.getElementById("longTextArea"),
            this.o_i = uS.getElementById("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = uS.getElementById("cancelButton"),
            this.FMt.onclick = () => this._et()
        }
        $et() {
            this.o_i.textContent = self.lang("common.ok"),
            this.FMt.textContent = self.lang("common.cancel")
        }
        Xa(t, i) {
            return lS.zt(t),
            this.FBi.value = t,
            super.Xa(i)
        }
        xet() {
            this.sW(this.FBi.value)
        }
    }
    ;
    lS.Qs.mk.iit.addEventListener("load", function() {
        lS.Qs.Ks.rit(dS, fS)
    })
}
{
    const pS = self.t
      , mS = 80
      , wS = 20
      , gS = 10
      , yS = {
        title: "",
        VP: "",
        LBi: !1,
        BBi: !0,
        UBi: !0,
        NBi: !0,
        jBi: !0
    };
    pS.Qs.Fk.Tab = class extends pS.Me {
        constructor(t, i) {
            super(),
            pS.kQ(i),
            i = Object.assign({}, yS, i),
            pS.zt(i.title),
            this.TPi = t,
            this.ght = pS.Qs.W_("ui-tab"),
            this.ght.setAttribute("role", "tab");
            const e = this.TPi.k_();
            if ("front" !== i.$Bi || this.TPi.q5())
                e.appendChild(this.ght);
            else {
                const t = this.TPi.pAi(0);
                e.insertBefore(this.ght, t.k_())
            }
            this.zBi = pS.Qs.W_("span", this.ght),
            this.zBi.textContent = i.title,
            this.Fc = !1,
            this._gi = i.title,
            this.VBi = i.VP,
            this.PEi = null,
            this.WBi = !0,
            this.HBi = !0,
            this.VBi && this.ght.setAttribute("title", this.VBi),
            this.q0 = !1,
            this.EY = 0,
            this.DY = 0,
            this.KBi = !1,
            this.Kc = null,
            this.kf = pS.v(pS.Rf, pS._f.Gf(this.ght, "pointerdown", t => this.mO(t)), pS._f.Gf(this.ght, "contextmenu", t => this.gO(t)), pS._f.Gf(this.ght, "auxclick", t => this.qBi(t)), pS._f.Gf(this.ght, "click", t => this.qBi(t))),
            this.cG = t => this.fG(t),
            this.uG = t => this.dG(t),
            this.KLi = t => this.IN(t),
            i.LBi && (this.ght.setAttribute("closebutton", ""),
            this.PEi = pS.v(pS.Qs.Fk.Eq, this.ght),
            this.PEi.onclick = () => this.XBi()),
            i.className && this.ght.classList.add(i.className),
            this.YBi = !1,
            this.JBi = !1,
            this.ZBi = !1,
            this.QBi = !1,
            pS.w9(i.BBi) ? this.YBi = i.BBi : this.YBi = !!i.BBi,
            pS.w9(i.UBi) ? this.JBi = i.UBi : this.JBi = !!i.UBi,
            pS.w9(i.NBi) ? this.ZBi = i.NBi : this.ZBi = !!i.NBi,
            pS.w9(i.jBi) ? this.QBi = i.jBi : this.QBi = !!i.jBi,
            this.dn = !1
        }
        S0() {
            this.kf.he(),
            this.kf = null,
            this.ght.ownerDocument.removeEventListener("pointerup", this.uG),
            this.uG = null,
            this.ght.ownerDocument.removeEventListener("pointercancel", this.KLi),
            this.KLi = null,
            this.ght.ownerDocument.removeEventListener("pointermove", this.cG),
            this.cG = null,
            this.PEi && (this.PEi.he(),
            this.PEi = null),
            pS.Qs.UO(this.zBi),
            this.zBi = null,
            pS.Qs.UO(this.ght),
            this.ght = null,
            this.Kc = null,
            this.TPi = null,
            this.dn = !0,
            pS.he(this)
        }
        gn() {
            return this.dn
        }
        tUi() {
            return pS.w9(this.YBi) ? this.YBi() : this.YBi
        }
        MAi() {
            return pS.w9(this.JBi) ? this.JBi() : this.JBi
        }
        NQ() {
            return pS.w9(this.ZBi) ? this.ZBi() : this.ZBi
        }
        EAi() {
            return pS.w9(this.QBi) ? this.QBi() : this.QBi
        }
        XBi() {
            this.TPi.iUi(this, "tabclose")
        }
        eUi(t) {
            t = !!t,
            this.WBi = t,
            this.PEi && this.PEi.cA(t)
        }
        _Ai() {
            return this.WBi
        }
        j0() {
            this.ght && this.ght.setAttribute("hide", "")
        }
        lQ() {
            this.ght && this.ght.removeAttribute("hide")
        }
        mO(t) {
            let i = t.clientX
              , e = t.clientY;
            this.q0 || 1 !== t.button && (2 !== t.button || this.HBi) && (this.TPi.vAi(this),
            this.tUi() && 0 === t.button && (this.q0 = !0,
            this.EY = i,
            this.DY = e,
            this.KBi = !1,
            this.ght.ownerDocument.addEventListener("pointermove", this.cG),
            this.ght.ownerDocument.addEventListener("pointerup", this.uG),
            this.ght.ownerDocument.addEventListener("pointercancel", this.KLi)))
        }
        qBi(t) {
            if (1 === t.button)
                return t.preventDefault(),
                void this.fP().iUi(this, "tabmiddleclick")
        }
        fG(t) {
            let i = t.clientX
              , e = t.clientY
              , s = t.pointerId;
            if (this.q0) {
                if (this.TPi.sUi() && Math.abs(i - this.EY) >= gS && (this.KBi = !0),
                this.KBi) {
                    let t = this.TPi.nUi(i, e);
                    if (t && t !== this && t.tUi()) {
                        let s = this.ns()
                          , n = t.ns() - s
                          , r = !0;
                        return n > 0 && (this.ka() < t.ka() ? t.gz(i - n, e) || (r = !1) : t.gz(i + n, e) || (r = !1)),
                        void (r && this.TPi.rUi(this, t))
                    }
                }
                if (this.JBi) {
                    let t = this.TPi.k_().getBoundingClientRect();
                    const n = wS;
                    let r = i >= t.left - n && e >= t.top - n && i <= t.right + n && e <= t.bottom + n;
                    pS.di(this.EY, this.DY, i, e) > mS && !r && pS.kt.FG && (this.dG(),
                    this.fP().uAi(this, i, e, s))
                }
            }
        }
        dG(t) {
            this.q0 = !1,
            this.KBi = !1,
            this.ght.ownerDocument.removeEventListener("pointerup", this.uG),
            this.ght.ownerDocument.removeEventListener("pointermove", this.cG),
            this.ght.ownerDocument.removeEventListener("pointercancel", this.KLi)
        }
        IN(t) {
            this.dG(t)
        }
        hUi(t) {
            this.HBi = !!t
        }
        gO(t) {
            this.HBi && (this.TPi.dAi(this, t.clientX, t.clientY) || t.preventDefault())
        }
        oUi(t) {
            t = !!t,
            this.Fc !== t && (pS.Qs.eit(this.ght, "active", t),
            this.Fc = t)
        }
        ka() {
            return this.ght.getBoundingClientRect().left
        }
        ns() {
            let t = this.ght.getBoundingClientRect();
            return t.right - t.left
        }
        gz(t, i) {
            pS.Ge(t),
            pS.Ge(i);
            let e = this.ght.getBoundingClientRect();
            return t >= e.left && i >= e.top && t < e.right && i < e.bottom
        }
        fP() {
            return this.TPi
        }
        UYt(t) {
            pS.zt(t),
            this._gi !== t && (this._gi = t,
            this.zBi.textContent = this._gi)
        }
        MBt() {
            return this._gi
        }
        mAi(t) {
            pS.zt(t),
            this.VBi !== t && (this.VBi = t,
            this.VBi ? this.ght.setAttribute("title", this.VBi) : this.ght.removeAttribute("title"))
        }
        aUi() {
            return this.VBi
        }
        goe(t) {
            this.Kc = t
        }
        Do(t) {
            return this.Kc
        }
        dse(t) {
            pS.Ef(t, pS.za),
            this.ght.style.backgroundColor = t ? t.Rsi() : ""
        }
        MJt(t) {
            pS.Ef(t, pS.za),
            this.ght.style.color = t ? t.Rsi() : ""
        }
        k_() {
            return this.ght
        }
    }
}
{
    const bS = self.t
      , vS = new Set(["top", "bottom"])
      , SS = {
        rAi: !1,
        hAi: !1
    };
    bS.Qs.Fk.nAi = class extends bS.Event.v_ {
        constructor(t, i) {
            super(),
            bS.kQ(i),
            i = Object.assign({}, SS, i),
            this.c8 = t,
            this._Pi = "",
            this.ght = bS.Qs.W_("ui-tabbar", this.c8),
            this.ght.setAttribute("role", "tablist"),
            this.lUi = !!i.rAi,
            this.uUi = !!i.hAi,
            this.kPi = [],
            this.cUi = null,
            this.vq("bottom")
        }
        he() {
            for (let t = 0, i = this.kPi.length; t < i; ++t)
                this.kPi[t].S0();
            bS.Io(this.kPi),
            bS.Qs.UO(this.ght),
            this.ght = null,
            this.c8 = null,
            this.cUi = null,
            super.he()
        }
        k_() {
            return this.ght
        }
        cP() {
            return this.cUi
        }
        sUi() {
            return this.uUi
        }
        vq(t) {
            if (bS.zt(t),
            !vS.has(t))
                throw new Error(`invalid tab side '${t}'`);
            this._Pi !== t && (this.ght.removeAttribute("tabbed-" + this._Pi),
            this._Pi = t,
            this.ght.setAttribute("tabbed-" + this._Pi, ""))
        }
        HQ() {
            return this.kPi.length
        }
        WQ(t) {
            bS.U(t, bS.Qs.Fk.Tab),
            self.assert(this.kPi.includes(t), "tab is not part of this tab bar");
            for (let i = 0, e = this.kPi.length; i < e; ++i)
                if (this.kPi[i] === t)
                    return i
        }
        pAi(t) {
            return bS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.kPi.length ? null : this.kPi[t]
        }
        *tabs() {
            for (let t = 0, i = this.kPi.length; t < i; ++t)
                yield this.kPi[t]
        }
        q5() {
            return 0 === this.HQ()
        }
        OQ(t, i) {
            bS.zt(t);
            let e = Object.assign({}, {
                title: t,
                LBi: this.lUi
            }, i)
              , s = bS.v(bS.Qs.Fk.Tab, this, e);
            return "front" === e.$Bi ? this.kPi.unshift(s) : this.kPi.push(s),
            this.cUi || (this.cUi = s,
            this.dUi()),
            this.iUi(s, "tabadd"),
            s
        }
        bAi(t) {
            if (bS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.kPi.length)
                throw new RangeError("tab index out of range");
            let i = this.kPi[t];
            if (i.S0(),
            this.kPi.splice(t, 1),
            this.cUi === i) {
                const i = Math.max(t - 1, 0);
                i < this.kPi.length ? this.vAi(this.kPi[i], !0) : this.cUi = null
            }
            this.iUi(null, "tabremove")
        }
        JQ(t) {
            if (bS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.kPi.length)
                throw new RangeError("tab index out of range");
            this.vAi(this.kPi[t])
        }
        nUi(t, i) {
            bS.Ge(t),
            bS.Ge(i);
            for (let e of this.kPi)
                if (e.gz(t, i))
                    return e;
            return null
        }
        vAi(t, i=!1) {
            if (bS.U(t, bS.Qs.Fk.Tab),
            this.cUi !== t) {
                if (!this.kPi.includes(t))
                    throw new Error("tab does not belong to this tab bar");
                this.cUi = t,
                this.dUi(),
                this.iUi(t, "activetabchanged", i)
            }
        }
        dUi() {
            for (let t = 0, i = this.kPi.length; t < i; ++t) {
                let i = this.kPi[t];
                i.oUi(i === this.cUi)
            }
        }
        rUi(t, i) {
            bS.U(t, bS.Qs.Fk.Tab),
            bS.U(i, bS.Qs.Fk.Tab);
            const e = this.kPi.indexOf(t)
              , s = this.kPi.indexOf(i);
            if (e < 0 || s < 0)
                throw new Error("cannot find tab");
            this.kPi.splice(e, 1),
            this.kPi.splice(s, 0, t),
            this.fUi();
            const n = new bS.Event("taborderchanged");
            n.i0 = t,
            n.pUi = i,
            this.dispatchEvent(n)
        }
        fUi() {
            for (let t of this.kPi)
                bS.Qs.UO(t.k_());
            for (let t of this.kPi)
                this.ght.appendChild(t.k_())
        }
        uAi(t, i, e, s) {
            bS.U(t, bS.Qs.Fk.Tab),
            bS.Ge(i),
            bS.Ge(e),
            bS.Ge(s);
            let n = new bS.Event("tearofftab");
            n.tab = t,
            n.clientX = i,
            n.clientY = e,
            n.pointerId = s,
            this.dispatchEvent(n)
        }
        dAi(t, i, e) {
            bS.U(t, bS.Qs.Fk.Tab),
            bS.Ge(i),
            bS.Ge(e);
            let s = new bS.Event("tabcontextmenu",!0);
            return s.tab = t,
            s.clientX = i,
            s.clientY = e,
            this.dispatchEvent(s)
        }
        iUi(t, i, e=!1) {
            bS.Ef(t, bS.Qs.Fk.Tab),
            bS.zt(i);
            let s = new bS.Event(i);
            s.tab = t,
            s.SAi = e ? "removal" : "",
            this.dispatchEvent(s)
        }
    }
}
{
    const xS = self.t
      , MS = {
        t8: -1,
        ait: !1,
        N2: !1,
        l$t: !1,
        mUi: !1,
        H2: !1,
        uit: !1,
        Z2: !0,
        K2: !1,
        cit: .5,
        J2: " ",
        W2: "auto",
        Q2: []
    }
      , ES = 400
      , CS = 10
      , _S = 100;
    xS.Qs.Fk.z2 = class extends xS.Event.v_ {
        constructor(t, i) {
            super(),
            xS.mGt(t),
            xS.kQ(i),
            i = Object.assign({}, MS, i),
            xS.Ge(i.t8),
            this.c8 = t,
            this.wUi = i.t8,
            this.wUi < 0 && (this.wUi = self.app.m4()),
            this.gUi = !!i.ait && xS.kt.FG,
            this.yUi = !!i.N2,
            this.bUi = !!i.H2,
            this.vUi = !!i.uit,
            this.SUi = !!i.l$t,
            this.xUi = !!i.mUi,
            this.MUi = !!i.Z2,
            this.EUi = !!i.K2,
            this.CUi = i.cit,
            xS.Ge(this.CUi),
            this.ght = xS.Qs.W_("ui-tree", this.c8),
            this.ght.setAttribute("role", "tree"),
            this.ght.setAttribute("tabindex", 0),
            this.HDi = t => this._Ui(),
            this.qDi = t => this.xft(),
            this.ght.addEventListener("focus", this.HDi),
            this.ght.addEventListener("blur", this.qDi),
            this.mF = t => this.mO(t),
            this.ght.addEventListener("pointerdown", this.mF),
            this.pG = t => this.wG(t),
            this.vUi ? this.ght.setAttribute("fullrowselect", "") : this.ght.setAttribute("itemselect", ""),
            this.MUi && this.ght.setAttribute("wraplongitems", ""),
            this.Ott = xS.v(xS.Qs.Fk.f5, this, null, null, "<root>"),
            this.TUi = self.app.oi("expanded"),
            this.IUi = self.app.oi("collapsed"),
            this.PUi = new Set,
            this.GUi = null,
            this.AUi = 0,
            this.RUi = new Set,
            this.r5t = xS.Qs.W_("div", null, null, "tree-insert-mark"),
            this.kUi = null,
            this.u5t = "",
            this.OUi = null,
            this.zM = -1,
            this.fPt = () => this.DUi(),
            this.FUi = 0,
            this.LUi = 0,
            this.BUi = 0,
            this.UUi = 0,
            this.NUi = "",
            this.jUi = new xS.ZG( () => this.$Ui(),_S),
            this.jUi.JG(!0),
            this.zUi = !1,
            this.VUi = !0,
            this.WUi = null,
            this.HUi = xS.Qs.W_("div", this.ght, null, "treeNoItems"),
            this.HUi.textContent = i.J2 || self.lang("ui.controls.tree.no-items-showing"),
            this.HUi.setAttribute("position", i.W2),
            this.KUi = xS.Qs.W_("div", this.HUi, null, "treeNoItemsOptions");
            for (const t of i.Q2) {
                xS.zt(t.text),
                xS.zt(t.tag);
                const i = xS.Qs.W_("button", this.KUi, null, "treeNoItemsOption");
                i.textContent = t.text,
                i.addEventListener("click", () => this.qUi("noitemsoptionclick", {
                    tag: t.tag
                }))
            }
            this.XUi = !0,
            this.YUi = xS.Qs.W_("div", null, null, "treeNoSearchResults"),
            this.YUi.setAttribute("position", i.W2),
            this.JUi = !1
        }
        he() {
            this.jUi.he(),
            this.jUi = null,
            this.FO().removeEventListener("keydown", this.pG),
            this.pG = null,
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.PUi.clear(),
            this.GUi = null,
            this.Hnt(),
            this.r5t = null,
            this.ZUi(),
            this.fPt = null,
            this.Ott.he(!0),
            this.Ott = null,
            xS.Qs.UO(this.YUi),
            this.YUi = null,
            xS.Qs.UO(this.HUi),
            this.HUi = null,
            this.ght.removeEventListener("focus", this.HDi),
            this.ght.removeEventListener("blur", this.qDi),
            this.HDi = null,
            this.qDi = null,
            xS.Qs.UO(this.ght),
            this.ght = null,
            this.c8 = null,
            super.he()
        }
        m5(t) {
            t = !!t,
            this.Ott.p5(t)
        }
        yTt(t, i, e) {
            let s;
            s = t instanceof xS.Qs.Fk.f5 ? t : this.YEt(i => i.Do() === t),
            s && (i = !!i,
            (e = !!e) ? s.p5(i) : s.v6(!1, i))
        }
        u5(t) {
            t = !!t,
            this.Ott.w5(t)
        }
        bTt(t, i, e) {
            let s;
            s = t instanceof xS.Qs.Fk.f5 ? t : this.YEt(i => i.Do() === t),
            i = !!i,
            (e = !!e) ? s.w5(i) : s.v6(!0, i)
        }
        QUi(t) {
            if (xS.U(t, xS.Qs.Fk.f5),
            t.o5() !== this)
                throw new Error("item from different tree")
        }
        tNi(t) {
            if (xS.Ef(t, xS.Qs.Fk.f5),
            t && t.o5() !== this)
                throw new Error("item from different tree")
        }
        YEt(t) {
            return this.Ott.YEt(t)
        }
        Ry() {
            this.Hnt(),
            this.Ott.Xit(),
            this.i5(!1),
            this.iNi()
        }
        eNi() {
            return this.wUi
        }
        R5() {
            return this.Ott
        }
        k_() {
            return this.ght
        }
        FO() {
            return this.ght.ownerDocument
        }
        LO() {
            return this.FO().defaultView
        }
        sNi() {
            return this.TUi
        }
        nNi() {
            return this.IUi
        }
        rNi() {
            return this.gUi
        }
        hNi() {
            return this.yUi
        }
        oNi() {
            return this.SUi
        }
        aNi() {
            return this.xUi
        }
        lNi() {
            return this.bUi
        }
        uNi(t) {
            this.bUi = !!t
        }
        cNi() {
            return this.vUi
        }
        dNi() {
            return this.EUi
        }
        fNi(t) {
            this.QUi(t),
            this.PUi.add(t),
            this.pNi(t, "itemselect")
        }
        mNi(t) {
            this.QUi(t),
            this.PUi.delete(t)
        }
        q5() {
            return ![...this.d7()].length
        }
        _Tt() {
            let t = 0;
            for (const i of this.I_t())
                ++t;
            return t
        }
        kEt() {
            for (const t of this.PUi)
                t.wNi(),
                t.gNi();
            for (const t of this.RUi.values())
                t.wNi(),
                t.gNi()
        }
        vFt(t=!1) {
            const i = this.GUi;
            for (const t of this.PUi)
                t.I6(!1);
            this.GUi = t ? i : null,
            self.assert(0 === this.PUi.size, "should have deleted all selected items")
        }
        yNi(t=!1) {
            const i = this.GUi;
            for (const t of this.PUi)
                t.bNi(!1);
            this.PUi.clear(),
            this.GUi = t ? i : null,
            self.assert(0 === this.PUi.size, "should have deleted all selected items")
        }
        *I_t() {
            for (const t of this.PUi.values())
                t.U6() || (yield t)
        }
        Eit() {
            return xS.th(this.I_t())
        }
        a5() {
            let t = [];
            for (let i of this.I_t())
                t.push(i);
            return this.vNi(t),
            t
        }
        SNi(t) {
            this.tNi(t),
            this.GUi = t
        }
        xNi() {
            return this.GUi
        }
        d7() {
            return this.Ott.d7()
        }
        MNi() {
            return this.Ott.MNi()
        }
        Fit(t, i) {
            xS.zt(t);
            const e = t.toLowerCase();
            for (const t of this.d7())
                if ((i || t.B6()) && t.iSt().toLowerCase().startsWith(e))
                    return t;
            return null
        }
        ENi(t, i) {
            if (this.QUi(t),
            this.QUi(i),
            t === i)
                return void t.I6(!0);
            let e = !1
              , s = null
              , n = [];
            for (let r of this.d7())
                if (e || (r === t ? (e = !0,
                s = i) : r === i && (e = !0,
                s = t)),
                e && (n.push(r),
                r === s))
                    break;
            s === t && n.reverse();
            for (let t of n)
                t.I6(!0)
        }
        IUt(t) {
            for (const i of t)
                this.QUi(i),
                i.I6(!0)
        }
        CNi(t) {
            let i;
            for (const e of t)
                i || (i = e),
                e.bNi(!0);
            this.PUi = new Set(t),
            this.SNi(i)
        }
        _Ui() {
            this.FO().addEventListener("keydown", this.pG)
        }
        xft() {
            this.FO().removeEventListener("keydown", this.pG)
        }
        mO(t) {
            if (t.target !== this.ght || xS.bk.$F(t) || t.shiftKey)
                return;
            const i = this.ght.getBoundingClientRect()
              , e = i.left + this.ght.clientWidth
              , s = i.top + this.ght.clientHeight;
            i.left < t.clientX && e > t.clientX && i.top < t.clientY && s > t.clientY && (this.qUi("emptyspaceclick"),
            this.vFt())
        }
        wG(t) {
            if (1 !== this._Tt())
                return;
            const i = t.which;
            if (i !== xS.Mk.UZ && i !== xS.Mk.FZ)
                return;
            const e = this.Eit()
              , s = [...this.MNi()];
            let n = s.indexOf(e);
            n < 0 || (i === xS.Mk.UZ ? --n : ++n,
            n < 0 || n >= s.length || (s[n]._5(),
            s[n].x5(),
            t.preventDefault()))
        }
        _Ni() {
            return this.CUi
        }
        gz(t, i, e, s, n) {
            xS.Ge(t),
            xS.Ge(i),
            xS.gL(e),
            xS.PD(n, xS.Qs.Fk.f5),
            e = e || "full",
            s = !!s;
            const r = this.ght.getBoundingClientRect();
            if (t < r.left || i < r.top || t > r.right || i > r.bottom)
                return null;
            for (const s of n ?? this.d7()) {
                if (!s || s.Z5())
                    continue;
                const n = s.gz(t, i, e);
                if (n)
                    return {
                        item: s,
                        Mnt: n.Mnt,
                        Bnt: n.Bnt
                    }
            }
            return s && t > r.left && i > r.top && t < r.right && i < r.bottom ? {
                item: this,
                Mnt: "tree",
                Bnt: !1
            } : null
        }
        Tnt(t, i) {
            if (this.QUi(t),
            xS.zt(i),
            t !== this.kUi || i !== this.u5t) {
                if (this.Hnt(),
                "inside" === i)
                    t.ynt().setAttribute("insert-inside", "");
                else {
                    if ("before" !== i && "after" !== i)
                        throw new Error("invalid insert mark type");
                    {
                        let e = t.k_();
                        e.parentElement.insertBefore(this.r5t, "before" === i ? e : e.nextSibling)
                    }
                }
                this.kUi = t,
                this.u5t = i
            }
        }
        Hnt() {
            this.u5t && ("inside" === this.u5t ? this.kUi.ynt().removeAttribute("insert-inside") : "before" !== this.u5t && "after" !== this.u5t || xS.Qs.UO(this.r5t),
            this.kUi = null,
            this.u5t = "")
        }
        TNi() {
            return this.kUi
        }
        pit(t) {
            !this.OUi && this.LO() && (this.OUi = t,
            this.UUi = 0,
            this.FUi = performance.now(),
            this.zM = this.LO().requestAnimationFrame(this.fPt))
        }
        _it(t, i) {
            this.OUi && (this.LUi = t,
            this.BUi = i)
        }
        DUi() {
            if (this.zM = -1,
            !this.OUi || !this.LO())
                return;
            let t = performance.now()
              , i = (t - this.FUi) / 1e3;
            this.FUi = t;
            let e = this.ght.getBoundingClientRect();
            if (this.LUi >= e.left && this.LUi <= e.right)
                if (this.BUi < e.top + CS) {
                    let t = this.ght.scrollTop - ES * i - this.UUi;
                    this.UUi = Math.ceil(t) - t,
                    t = Math.ceil(t),
                    this.ght.scrollTop = t
                } else if (this.BUi > e.bottom - CS) {
                    let t = this.ght.scrollTop + ES * i + this.UUi;
                    this.UUi = t - Math.floor(t),
                    t = Math.floor(t),
                    this.ght.scrollTop = t
                }
            this.zM = this.LO().requestAnimationFrame(this.fPt)
        }
        h5() {
            return this.OUi
        }
        qnt() {
            return !!this.OUi
        }
        Pit() {
            return this.qnt()
        }
        ZUi() {
            this.OUi = null,
            -1 !== this.zM && this.LO() && (this.LO().cancelAnimationFrame(this.zM),
            this.zM = -1)
        }
        f1() {
            if (this.OUi)
                this.OUi.INi(),
                this.OUi.PNi(),
                this.ZUi();
            else
                for (const t of this.d7())
                    t.INi()
        }
        GNi(t, i) {
            this.AUi += t ? 1 : -1,
            t ? this.RUi.add(i) : this.RUi.delete(i)
        }
        zHt() {
            return this.AUi > 0
        }
        vNi(t) {
            xS.RH(t);
            for (let i of t)
                this.QUi(i);
            this.ANi(),
            t.sort(xS.Qs.Fk.f5.RNi)
        }
        ANi() {
            let t = 0;
            for (let i of this.d7())
                i.kNi(t++)
        }
        qUi(t, i) {
            xS.zt(t);
            let e = new xS.Event(t,!0);
            return e.G5 = this,
            this.dispatchEvent(Object.assign(e, i))
        }
        pNi(t, i, e) {
            this.QUi(t),
            xS.zt(i);
            let s = new xS.Event(i,!0);
            return s.item = t,
            s.ctrlKey = xS.bk.Sk(xS.Mk.mci),
            s.metaKey = xS.bk.Sk(xS.Mk.Sdi),
            s.shiftKey = xS.bk.Sk(xS.Mk.YX),
            this.dispatchEvent(Object.assign(s, e))
        }
        ONi(t, i, e, s) {
            this.QUi(t),
            xS.zt(i),
            xS.Ge(e),
            xS.Ge(s);
            let n = new xS.Event(i,!0);
            return n.item = t,
            n.clientX = e,
            n.clientY = s,
            n.ctrlKey = xS.bk.Sk(xS.Mk.mci),
            n.metaKey = xS.bk.Sk(xS.Mk.Sdi),
            n.shiftKey = xS.bk.Sk(xS.Mk.YX),
            this.dispatchEvent(n)
        }
        B3(t, i) {
            this.QUi(t);
            let e = new xS.Event("itemcontextmenu",!0);
            return e.item = t,
            e.clientX = i.clientX,
            e.clientY = i.clientY,
            this.dispatchEvent(e)
        }
        $Et(t, i) {
            xS.zt(t),
            xS.kQ(i),
            this.zUi = !1,
            this.VUi = !0,
            i && (this.zUi = !!i.dTt,
            this.VUi = !!i.DNi,
            xS.oti(i.FNi),
            this.WUi = i.FNi),
            this.NUi = t,
            i && i.uTt ? this.$Ui() : this.jUi.FE()
        }
        $Ui() {
            const t = this.NUi.toLowerCase();
            let i = !0
              , e = !1;
            const s = new Set;
            for (const n of this.d7())
                if (t) {
                    let r = n.iSt().toLowerCase().includes(t);
                    if (this.WUi && !r)
                        for (const i of this.WUi)
                            if (r = i(n, n.Do(), t),
                            r)
                                break;
                    if (n.LNi(r),
                    r)
                        e = !0,
                        i && (this.zUi && n._5(),
                        i = !1);
                    else {
                        const t = n.dD();
                        t && !t.oD() && t.BNi() && (s.add(n),
                        n.UNi())
                    }
                } else
                    n.UNi(),
                    e = !0;
            for (const t of this.d7()) {
                if (!t.BNi() || !t.kP())
                    continue;
                const i = t.CH().some(t => t.BNi());
                t.NNi(i, !0)
            }
            for (const t of s.values()) {
                const i = t.Do();
                if (xS.Bm(i, self.xpe) || xS.w9(i.N6)) {
                    if (!t.kP()) {
                        t.LNi(!1);
                        break
                    }
                    t.CH().some(t => t.BNi()) || t.LNi(!1)
                }
            }
            if (!t) {
                for (const t of this.d7())
                    t.jNi();
                if (this.VUi) {
                    const t = this.Eit();
                    t && t.B6() && t.x5()
                }
            }
            this.i5(t && !e),
            this.iNi();
            const n = new xS.Event("searchresultsupdate");
            this.dispatchEvent(n)
        }
        z5(t) {
            xS.zt(t),
            this.HUi.textContent = t
        }
        N5(t) {
            t = !!t,
            this.KUi.style.display = t ? "" : "none"
        }
        iNi() {
            const t = ![...this.d7()].length;
            this.XUi = t,
            this.XUi ? (this.ght.contains(this.HUi) || this.ght.appendChild(this.HUi),
            this.HUi.contains(this.KUi) || this.HUi.appendChild(this.KUi)) : this.ght.contains(this.HUi) && xS.Qs.UO(this.HUi)
        }
        r5() {
            return this.JUi
        }
        i5(t) {
            this.JUi !== t ? (this.JUi = t,
            this.JUi ? (this.ght.contains(this.YUi) || this.ght.appendChild(this.YUi),
            this.YUi.textContent = self.h_("ui.controls.tree.no-text-search-results", this.NUi)) : xS.Qs.UO(this.YUi)) : this.JUi && (this.ght.contains(this.YUi) || this.ght.appendChild(this.YUi),
            this.YUi.textContent = self.h_("ui.controls.tree.no-text-search-results", this.NUi))
        }
        S5() {
            return {
                name: this.Ott.iSt(),
                children: [...this.Ott.children()].map(t => t.S5())
            }
        }
        Q3(t) {
            if (xS.ML(t),
            !t)
                return;
            if (this.NUi)
                return;
            this.pNi(this.Ott, "setjson");
            const i = [...this.Ott.children()];
            for (let e = 0; e < i.length; e++) {
                const s = i[e];
                s && s.Q3(this.$Ni(s, t.children), [])
            }
            this.pNi(this.Ott, "setjsonfinish")
        }
        $Ni(t, i) {
            const e = t.iSt();
            for (let t = 0; t < i.length; t++) {
                if (e === i[t].name)
                    return i[t]
            }
        }
        n$t(t, i, e) {
            if (xS.ML(t),
            xS.Ge(i),
            xS.nu(e),
            !t)
                return;
            if (this.NUi)
                return;
            let s = this.YEt(e)
              , n = t.children[i];
            s && n && s.Q3(n)
        }
    }
}
{
    const TS = self.t
      , IS = self.assert;
    let PS = [{
        height: ""
    }, {
        height: ""
    }];
    const GS = {
        duration: 200,
        easing: "ease"
    }
      , AS = {
        enable: !0,
        addToParent: !0
    }
      , RS = 700
      , kS = 10;
    TS.Qs.Fk.f5 = class t extends TS.Me {
        constructor(t, i, e, s, n, r, h) {
            if (TS.U(t, TS.Qs.Fk.z2),
            TS.Ef(i, TS.Qs.Fk.f5),
            TS.zt(s),
            TS.iM(r),
            TS.ML(h),
            super(),
            h = Object.assign({}, AS, h),
            !(null == e || TS.K9(e) || e instanceof TS.Qs.d0))
                throw new TypeError("invalid icon");
            this.L2 = t,
            this.c8 = i || null,
            this.G4 = TS.K9(e) ? self.app.oi(e) : e,
            this.IUi = null,
            this.hy = s,
            this.Kc = n,
            this.Xhi = h.enable,
            this.ght = null,
            this.pYt = null,
            this.OLi = !0,
            this.zNi = !1,
            this.IKt = null,
            this.VNi = "",
            this.$Ei = [],
            this.WNi = !1,
            this.HNi = !1,
            this.KNi = null,
            this.mF = null,
            this.qNi = -1,
            this.XNi = t => this.YNi(),
            this.JNi = !0,
            this.ZNi = t => this.QNi(t),
            this.tji = 0,
            this.iji = 0,
            this.n5t = -1,
            this.EY = 0,
            this.DY = 0,
            this.q0 = !1,
            this.cG = null,
            this.uG = null,
            this.KLi = null,
            this.eji = null,
            this.sji = 0,
            this.nji = 0,
            this.yWt = t => this.vO(t),
            this.mYt = t => this.vYt(t),
            this.OKt = t => this.TKt(),
            this.rji = null,
            this.bWt = !1,
            this.GB = t => this.gO(t),
            this.hji = null,
            this.oji = null,
            this.aji = null,
            this.BGt = null,
            this.lji = null,
            this.uji = null,
            this.MLi = null,
            this.uVt = null,
            this.cji = null,
            this.dji = null,
            this.aFi = null,
            this.fji = null,
            this.pji = null,
            this.mji = -1,
            this.oD() || (h.addToParent ? this.ght = TS.Qs.W_("ui-treeitem", this.c8.q6(), null, null, null, r) : this.ght = TS.Qs.W_("ui-treeitem"),
            this.ght.setAttribute("role", "treeitem"),
            this.ght.addEventListener("contextmenu", this.GB),
            this.Xhi || this.ght.setAttribute("disable", ""),
            this.pYt = TS.v(TS.Qs._q, this.L2.sNi().ARi(), this.ght),
            this.rji = TS.Qs.W_("div", this.ght, null, "tree-item-wrap"),
            this.eUt().addEventListener("UIDoubleTap", this.yWt),
            this.BGt = TS.v(TS.Qs._q, this.G4 || this.L2.eNi(), this.rji),
            this.lji = t => this.wji(t),
            this.BGt.k_().addEventListener("pointerdown", this.lji),
            this.MLi = TS.Qs.W_("span", this.rji, null, "tree-item-name"),
            this.MLi.textContent = this.hy,
            this.fji = t => this.gji(),
            this.mF = t => this.mO(t),
            this.eUt().addEventListener("pointerdown", this.mF),
            this.cG = t => this.fG(t),
            this.uG = t => this.dG(t),
            this.KLi = t => this.IN(t)),
            this.yji = !1,
            this.dn = !1,
            this.eQ = !1
        }
        bji(t) {
            t = !!t,
            this.HNi = t
        }
        rHt(t) {
            return this.HNi
        }
        Xit() {
            this.VKt(),
            this.WNi = !0;
            for (let t = this.$Ei.length - 1; t >= 0; --t) {
                let i = this.$Ei[t];
                i.bji(!0),
                i.he()
            }
            TS.Io(this.$Ei),
            this.WNi = !1,
            this.T6()
        }
        SCi(t) {
            if (TS.U(t, TS.Qs.Fk.f5),
            t.Z5())
                return;
            if (this.WNi)
                return;
            let i = this.$Ei.indexOf(t);
            IS(i >= 0, "cannot find child to remove"),
            this.$Ei.splice(i, 1),
            this.$Ei.length || this.T6()
        }
        B5() {
            IS(this.o5().dNi(), "configure tree to use detachable items"),
            this.o5().kEt();
            const t = [];
            for (const i of this.d7())
                i.J5(),
                t.push(i);
            return this.q6() && TS.Qs.L6(this.q6()),
            TS.Io(this.$Ei),
            this.T6(),
            t
        }
        J5() {
            this.gNi(),
            this.wNi(),
            this.VKt(),
            this.I6(!1),
            this.yji = !0,
            TS.Io(this.$Ei),
            this.T6()
        }
        he(t) {
            if (!this.dn) {
                if (this.dn = !0,
                this.oD() && !t)
                    throw new Error("root item cannot be removed");
                if (this.wNi(),
                this.ZNi = null,
                this.gNi(),
                this.VKt(),
                this.I6(!1),
                this.L2.xNi() === this && (this.L2._Tt() >= 1 ? this.L2.SNi(this.L2.Eit()) : this.L2.SNi(null)),
                this.L2.TNi() === this && this.L2.Hnt(),
                this.q0 && this.L2.f1(),
                this.Xit(),
                this.OKt = null,
                this.fji = null,
                this.oD() || (this.eUt().removeEventListener("UIDoubleTap", this.yWt),
                this.eUt().removeEventListener("pointerdown", this.mF),
                this.FO().removeEventListener("pointermove", this.cG),
                this.FO().removeEventListener("pointerup", this.uG),
                this.FO().removeEventListener("pointercancel", this.KLi)),
                this.pYt && (this.pYt.k_().removeEventListener("UITap", this.mYt),
                this.pYt.he(),
                this.pYt = null),
                this.KNi && (TS.Qs.UO(this.KNi),
                this.KNi = null),
                this.MLi && (TS.Qs.UO(this.MLi),
                this.MLi = null),
                this.eji && (TS.Qs.UO(this.eji),
                this.eji = null),
                this.hji && (this.hji.removeEventListener("change", this.oji),
                this.oji = null,
                this.hji.removeEventListener("UIDoubleTap", this.aji),
                this.aji = null,
                this.hji.removeEventListener("pointerdown", TS.Qs.gdt),
                TS.Qs.UO(this.hji),
                this.hji = null),
                this.BGt && (this.BGt.k_().removeEventListener("pointerdown", this.lji),
                this.lji = null,
                this.BGt.he(),
                this.BGt = null),
                this.uji) {
                    for (const t of this.uji.values())
                        t.vji.he();
                    this.uji.clear(),
                    this.uji = null
                }
                this.rji && (TS.Qs.UO(this.rji),
                this.rji = null),
                this.ght && (this.ght.removeEventListener("contextmenu", this.GB),
                TS.Qs.UO(this.ght),
                this.ght = null),
                this.GB = null,
                this.yWt = null,
                this.mF = null,
                this.cG = null,
                this.uG = null,
                this.KLi = null,
                this.XNi = null,
                this.mYt = null,
                this.c8 && -1 !== this.c8.az(this) && this.c8.SCi(this),
                this.c8 && !this.c8.kP() && this.T6(),
                this.oD() || this.L2.pNi(this, "itemremove"),
                this.G4 = null,
                this.Kc = null,
                this.L2 = null,
                this.c8 = null,
                TS.he(this)
            }
        }
        k_() {
            return this.ght
        }
        ynt() {
            return this.rji
        }
        Sji() {
            return this.MLi
        }
        eUt() {
            return this.L2.cNi() ? this.ght : this.rji
        }
        o5() {
            return this.L2
        }
        FO() {
            return this.ght.ownerDocument
        }
        cA(t) {
            t = !!t,
            this.Xhi !== t && (this.Xhi = t,
            this.Xhi ? this.ght.removeAttribute("disable") : this.ght.setAttribute("disable", ""))
        }
        qk() {
            return this.Xhi
        }
        Z5() {
            return this.yji
        }
        gn() {
            return this.dn
        }
        *d7() {
            this.oD() || (yield this);
            for (const t of this.$Ei)
                yield*t.d7()
        }
        *MNi() {
            if (this.oD() || (yield this),
            this.xji())
                for (const t of this.$Ei)
                    t.U6() || (yield*t.MNi())
        }
        *children() {
            for (let t of this.$Ei)
                yield t
        }
        mO(t) {
            if (t.button !== TS.gF.sV)
                return;
            const i = t.clientX
              , e = t.clientY;
            this.L2.ONi(this, "itemdown", i, e),
            this.eUt().setAttribute("pointerheld", ""),
            this.FO().addEventListener("pointermove", this.cG),
            this.FO().addEventListener("pointerup", this.uG),
            this.FO().addEventListener("pointercancel", this.KLi),
            this.n5t = t.pointerId,
            this.EY = i,
            this.DY = e,
            this.q0 = !1,
            "match" === this.VNi && this.Mji(!0),
            t.stopPropagation()
        }
        fG(t) {
            if (t.pointerId !== this.n5t)
                return;
            const i = t.clientX
              , e = t.clientY;
            if (t.stopPropagation(),
            this.L2.lNi() && !this.q0 && TS.di(this.EY, this.DY, i, e) >= kS) {
                if (this.eUt().removeAttribute("pointerheld", ""),
                !this.L2.ONi(this, "dragstart", i, e))
                    return this.n5t = -1,
                    this.FO().removeEventListener("pointermove", this.cG),
                    this.FO().removeEventListener("pointerup", this.uG),
                    this.FO().removeEventListener("pointercancel", this.KLi),
                    void (this.Ez() || this._5());
                {
                    this.q0 = !0,
                    this.wNi(),
                    this.L2.SNi(this),
                    this.Ez() || this._5();
                    for (let t of this.L2.I_t())
                        t.eUt().setAttribute("dragged", "");
                    1 === this.L2._Tt() ? (this.eji = this.rji.cloneNode(!0),
                    this.eji.removeAttribute("selected"),
                    this.eji.setAttribute("drag-thumbnail", "")) : (this.eji = this.MLi.cloneNode(!0),
                    this.eji.setAttribute("drag-thumbnail", ""),
                    this.eji.textContent = self.n_("ui.controls.tree.multi-select-drag-tooltip", null, this.L2._Tt()));
                    let t = TS.Sii(this.ght, "dialog");
                    if (t) {
                        t.appendChild(this.eji);
                        let i = TS.Qs.Ks.rCi(t);
                        this.sji = i.ESi(),
                        this.nji = i.CSi()
                    } else
                        this.FO().body.appendChild(this.eji);
                    this.L2.pit(this)
                }
            }
            this.q0 && (t.preventDefault(),
            this.L2.ONi(this, "dragmove", i, e),
            this.eji.style.left = i - this.sji + "px",
            this.eji.style.top = e - this.nji + "px",
            this.L2._it(i, e))
        }
        QNi(t) {
            this.tji = t.clientX,
            this.iji = t.clientY
        }
        dG(t) {
            if (t.pointerId !== this.n5t)
                return;
            const i = t.clientX
              , e = t.clientY;
            if (this.eUt().removeAttribute("pointerheld", ""),
            this.FO().removeEventListener("pointermove", this.cG),
            this.FO().removeEventListener("pointerup", this.uG),
            this.FO().removeEventListener("pointercancel", this.KLi),
            this.q0)
                this.PNi(),
                this.L2.ZUi(),
                this.L2.ONi(this, "drop", i, e);
            else {
                if (t.target === this.hji)
                    return;
                let s = !1;
                s = 1 === this.L2._Tt() || this.L2.aNi(),
                this.L2.rNi() && this.Ez() && s && this.gz(i, e, "label") && (this.wNi(),
                t.target !== this.BGt.k_() && (this.tji = i,
                this.iji = e,
                this.FO().addEventListener("pointermove", this.ZNi),
                this.qNi = setTimeout(this.XNi, RS))),
                this.L2.ONi(this, "itemclick", i, e);
                let n = this.L2.xNi();
                if (this.L2.hNi()) {
                    let t = TS.bk.$F()
                      , s = TS.bk.Sk(TS.Mk.YX);
                    if (t && s && n)
                        return this.L2.ENi(this, n),
                        this.Ez() && this.L2.SNi(this),
                        this.L2.oNi() && this.Eji(!0),
                        void this.L2.ONi(this, "afteritemclick", i, e);
                    if (t) {
                        let t = !this.Ez();
                        return this.I6(t),
                        this.Ez() && this.L2.SNi(this),
                        this.L2.oNi() && this.Eji(t),
                        void this.L2.ONi(this, "afteritemclick", i, e)
                    }
                    if (s && n)
                        return this.L2.vFt(!0),
                        this.L2.ENi(this, n),
                        this.L2.oNi() && (this.Eji(!0),
                        n.Eji(!0)),
                        void this.L2.ONi(this, "afteritemclick", i, e)
                }
                this.L2.SNi(this),
                this.Cji(!1),
                this.L2.vFt(),
                this.I6(!0),
                this.Cji(!0),
                this.L2.oNi() && this.Eji(!0),
                this.L2.ONi(this, "afteritemclick", i, e)
            }
        }
        IN(t) {
            this.eUt().removeAttribute("pointerheld", ""),
            this.FO().removeEventListener("pointermove", this.cG),
            this.FO().removeEventListener("pointerup", this.uG),
            this.FO().removeEventListener("pointercancel", this.KLi),
            this.gNi(),
            this.wNi(),
            this.L2.vFt(),
            this.PNi(),
            this.L2.ZUi()
        }
        INi() {
            -1 !== this.n5t && (this.eUt().removeAttribute("pointerheld", ""),
            this.FO().removeEventListener("pointermove", this.cG),
            this.FO().removeEventListener("pointerup", this.uG),
            this.FO().removeEventListener("pointercancel", this.KLi))
        }
        PNi() {
            this.q0 = !1,
            this.n5t = -1;
            for (const t of this.L2.I_t())
                t.eUt().removeAttribute("dragged");
            TS.Qs.UO(this.eji),
            this.eji = null
        }
        Eji(t) {
            if (t = !!t,
            this.kP())
                for (let i of this.children())
                    i.I6(t)
        }
        vO(t) {
            this.wNi(),
            this.L2.pNi(this, "itemdoubletap") && this.KNi && this.NKt(!0)
        }
        wji(t) {
            this.wNi(),
            t.button === TS.gF.sV && (this.L2.pNi(this, "itemiconclick") || t.stopPropagation())
        }
        YEt(t) {
            if (TS.nu(t),
            t(this))
                return this;
            for (let i = 0; i < this.$Ei.length; i++) {
                let e = this.$Ei[i].YEt(t);
                if (e)
                    return e
            }
        }
        q6() {
            return this.oD() ? this.L2.k_() : this.KNi
        }
        kP() {
            return this.$Ei.length > 0
        }
        EH() {
            return this.$Ei
        }
        *CH() {
            for (const t of this.$Ei)
                yield t,
                yield*t.CH()
        }
        _ji() {
            return this.$Ei.length
        }
        az(t) {
            return TS.U(t, TS.Qs.Fk.f5),
            this.$Ei.indexOf(t)
        }
        oD() {
            return !this.c8
        }
        dD() {
            return this.c8
        }
        NAt(i) {
            let e, s;
            TS.w9(i) ? s = i : e = i,
            e && TS.U(e, t),
            s && TS.nu(s);
            for (let t of this.V6())
                if (e) {
                    if (t === e)
                        return !0
                } else if (s && s(t))
                    return !0;
            return !1
        }
        *V6() {
            let t = this.dD();
            for (; t; )
                yield t,
                t = t.oD() ? null : t.dD()
        }
        iSt() {
            return this.hy
        }
        ha(t) {
            TS.zt(t),
            this.hy !== t && (this.hy = t,
            this.uVt || (this.MLi.textContent = t))
        }
        goe(t) {
            this.Kc = t
        }
        Do(t) {
            return this.Kc
        }
        gz(t, i, e) {
            let s;
            if (TS.Ge(t),
            TS.Ge(i),
            TS.zt(e),
            "label" === e)
                s = this.rji.getBoundingClientRect();
            else {
                if ("full" !== e)
                    throw new Error("invalid hit test type");
                s = this.ght.getBoundingClientRect()
            }
            if (t < s.left || t > s.right || i < s.top || i > s.bottom)
                return null;
            const n = (1 - this.L2._Ni()) / 2;
            let r = s.bottom - s.top
              , h = s.top + r * n
              , o = s.bottom - r * n
              , a = i >= s.top + r / 2
              , l = i > h && i <= o;
            return a && !l && this.xji() && this.kP() && (l = !0),
            {
                Mnt: a ? "after" : "before",
                Bnt: l
            }
        }
        Tji() {
            if (this.N_t(),
            this.xji())
                for (let t of this.$Ei)
                    t.Tji()
        }
        m0(t) {
            if (!(TS.K9(t) || t instanceof TS.Qs.d0))
                throw new TypeError("invalid icon");
            this.BGt && (TS.K9(t) ? this.BGt.m0(self.app.oi(t)) : this.BGt.m0(t))
        }
        Iji(t, i) {
            if (TS.zt(t),
            !(TS.K9(i) || i instanceof TS.Qs.d0))
                throw new TypeError("invalid icon");
            const e = this.uji.get(t);
            e && (TS.K9(i) ? e.vji.m0(self.app.oi(i)) : e.vji.m0(i))
        }
        U_t(t) {
            TS.nu(t),
            this.BGt && (this.BGt.U_t(t),
            this.B6() && this.N_t())
        }
        N_t() {
            this.BGt.N_t()
        }
        B6() {
            let t = this.c8;
            for (; t; ) {
                if (!t.xji())
                    return !1;
                t = t.c8
            }
            return !0
        }
        Mji(t) {
            t = !!t;
            for (const i of this.V6())
                i.oD() || (i.OLi = t)
        }
        vYt(t) {
            t.detail.fk === TS.gF.sV && this.NKt(!0)
        }
        z6() {
            return this.OLi
        }
        xji() {
            return this.BNi() ? this.zNi : this.z6() || this.zNi
        }
        Pji(t) {
            return !!((t = !!t) && this.B6() && self.app.jKt())
        }
        Gji(t) {
            return (!(t = !!t) || t && this.WKt()) && !!this.IKt
        }
        v6(t, i, e) {
            if (this.oD())
                throw new Error("cannot change expanded state of root item");
            if (t = !!t,
            i = !!(i && this.B6() && self.app.jKt()),
            !this.KNi)
                return e || (this.OLi = t),
                void this.pYt.m0(null);
            (!i || i && this.WKt()) && (this.VKt(),
            i = !1);
            if (this.xji() !== t)
                if (t) {
                    if (e ? this.zNi = !0 : this.OLi = !0,
                    this.KNi.removeAttribute("collapsed"),
                    this.kP() ? (this.pYt.m0(this.L2.sNi()),
                    this.IUi && this.BGt.m0(this.G4)) : (this.pYt.m0(null),
                    this.BGt.m0(this.G4)),
                    e || this.Aji(i),
                    this.B6() && this.Tji(),
                    i) {
                        let t = this.KNi.getBoundingClientRect()
                          , i = t.bottom - t.top;
                        PS[0].height = "0px",
                        PS[1].height = `${i}px`,
                        this.KNi.style.overflow = "hidden",
                        this.IKt = this.KNi.animate(PS, GS),
                        this.IKt.onfinish = this.OKt
                    }
                } else if (this.zNi = !1,
                e || (this.OLi = !1),
                this.kP() ? (this.pYt.m0(this.L2.nNi()),
                this.IUi && this.BGt.m0(this.IUi)) : (this.pYt.m0(null),
                this.BGt.m0(this.G4)),
                e || this.Aji(i),
                i) {
                    let t = this.KNi.getBoundingClientRect()
                      , i = t.bottom - t.top;
                    PS[0].height = `${i}px`,
                    PS[1].height = "0px",
                    this.KNi.style.overflow = "hidden",
                    this.IKt = this.KNi.animate(PS, GS),
                    this.IKt.onfinish = this.OKt
                } else
                    this.KNi.setAttribute("collapsed", "")
        }
        jNi() {
            this.OLi ? this.KNi && this.KNi.hasAttribute("collapsed") ? (this.OLi = !1,
            this.zNi = !1,
            this.v6(!0, !1)) : this.v6(this.OLi, !1) : this.KNi && !this.KNi.hasAttribute("collapsed") ? (this.OLi = !0,
            this.zNi = !1,
            this.v6(!1, !1)) : this.v6(this.OLi, !1)
        }
        Aji(t) {
            this.eQ || this.L2.pNi(this, "itemexpand", {
                H6: t
            })
        }
        Rji() {
            let t = this.c8;
            for (; t; ) {
                if (!t.oD() && t.xji())
                    return !0;
                t = t.dD()
            }
            return !1
        }
        kji() {
            let t = this.c8;
            for (; t; ) {
                if (!t.oD() && !t.xji())
                    return !0;
                t = t.dD()
            }
            return !1
        }
        Oji() {
            if (!this.oD() && this.xji())
                return !0;
            for (const t of this.d7())
                if (t.xji())
                    return !0;
            return !1
        }
        Dji() {
            if (!this.oD() && !this.xji())
                return !0;
            for (const t of this.d7())
                if (!t.xji())
                    return !0;
            return !1
        }
        w5(t, i=!0, e=[]) {
            let s;
            t = !!t,
            (i = !!i) && (s = this.Dji(),
            s && this.L2.pNi(this, "itemexpandmany"));
            let n = null;
            if (!this.oD()) {
                if (t = this.Pji(t),
                (t = this.Gji(t)) && this.KNi && !this.xji()) {
                    const t = new Promise(t => {
                        n = i => {
                            i.item === this && t()
                        }
                        ,
                        this.L2.addEventListener("itemexpandfinish", n)
                    }
                    );
                    e.push({
                        promise: t,
                        item: this,
                        Fji: n
                    })
                }
                this.v6(!0, t)
            }
            let r = this.$Ei.length;
            for (let i = 0; i < r; i++)
                this.$Ei[i].w5(t, !1, e);
            i && TS.Iti(s) && s ? e.length ? Promise.all(e.map(t => t.promise)).then( () => {
                e.forEach(t => this.L2.removeEventListener("itemexpandfinish", t.Fji)),
                this.L2.pNi(this, "itemexpandmanyfinish")
            }
            ) : this.L2.pNi(this, "itemexpandmanyfinish") : e.forEach(t => this.L2.removeEventListener("itemexpandfinish", t.Fji))
        }
        p5(t, i=!0, e=[]) {
            let s;
            t = !!t,
            (i = !!i) && (s = this.Oji(),
            s && this.L2.pNi(this, "itemexpandmany"));
            let n = null;
            if (!this.oD()) {
                if (t = this.Pji(t),
                (t = this.Gji(t)) && this.KNi && this.xji()) {
                    const t = new Promise(t => {
                        n = i => {
                            i.item === this && t()
                        }
                        ,
                        this.L2.addEventListener("itemexpandfinish", n)
                    }
                    );
                    e.push({
                        promise: t,
                        item: this,
                        Fji: n
                    })
                }
                this.v6(!1, t)
            }
            let r = this.$Ei.length;
            for (let i = 0; i < r; i++)
                this.$Ei[i].p5(t, !1);
            i && TS.Iti(s) && s ? e.length ? Promise.all(e.map(t => t.promise)).then( () => {
                e.forEach(t => this.L2.removeEventListener("itemexpandfinish", t.Fji)),
                this.L2.pNi(this, "itemexpandmanyfinish")
            }
            ) : this.L2.pNi(this, "itemexpandmanyfinish") : e.forEach(t => this.L2.removeEventListener("itemexpandfinish", t.Fji))
        }
        NKt(t) {
            this.v6(!this.xji(), t, this.BNi())
        }
        WKt() {
            return !!this.IKt
        }
        TKt() {
            this.IKt && (this.xji() || this.KNi.setAttribute("collapsed", ""),
            this.KNi.style.overflow = "",
            this.IKt = null,
            this.L2.pNi(this, "itemexpandfinish"))
        }
        VKt() {
            this.IKt && (this.IKt.cancel(),
            this.TKt())
        }
        _5() {
            this.Ez() && 1 === this.L2._Tt() || (this.L2.vFt(),
            this.I6(!0))
        }
        vvt() {
            this.I6(!1)
        }
        Ez(t) {
            return this.bWt
        }
        I6(t) {
            this.oD() || (t = !!t,
            this.wNi(),
            this.bWt !== t && (t ? (this.L2.pNi(this, "beforeitemselect"),
            this.eUt().setAttribute("selected", ""),
            this.L2.fNi(this),
            this.L2.xNi() || this.L2.SNi(this)) : (this.eUt().removeAttribute("selected"),
            this.L2.mNi(this),
            this.L2.xNi() === this && (this.L2._Tt() >= 1 ? this.L2.SNi(this.L2.Eit()) : this.L2.SNi(null))),
            this.bWt = t))
        }
        bNi(t) {
            this.oD() || (t = !!t,
            this.wNi(),
            this.bWt !== t && (t ? this.eUt().setAttribute("selected", "") : this.eUt().removeAttribute("selected"),
            this.bWt = t))
        }
        R6() {
            if (!this.oD() && !this.KNi) {
                if (this.ght.classList.add("parentItem"),
                this.KNi = TS.Qs.W_("ui-treeitem-children"),
                this.$Ei.length && this.pYt) {
                    this.pYt.m0(null),
                    this.pYt.k_().removeEventListener("UITap", this.mYt);
                    let t = this.xji() ? this.L2.sNi() : this.L2.nNi();
                    this.pYt.m0(t),
                    this.IUi && (t = this.xji() ? this.G4 : this.IUi,
                    this.BGt.m0(t)),
                    this.pYt.k_().addEventListener("UITap", this.mYt)
                }
                this.ght.parentElement || TS.Qs.xgt(this.ght, this.c8.q6()),
                this.ght.parentElement.insertBefore(this.KNi, this.ght.nextSibling),
                this.xji() || this.KNi.setAttribute("collapsed", "")
            }
        }
        Lji() {
            for (let t of this.$Ei) {
                let i = t.q6();
                if (!i)
                    continue;
                let e = t.k_();
                if (i.previousSibling === e)
                    return;
                i.parentElement && i.parentElement.removeChild(i),
                e.parentElement && e.parentElement.insertBefore(i, e.nextSibling)
            }
        }
        D6() {
            const t = this.q6();
            for (let i = 0; i < this.$Ei.length; i++) {
                const e = this.$Ei[i]
                  , s = e.q6();
                e && e.k_().parentElement === t && t.appendChild(e.k_()),
                s && s.parentElement === t && t.appendChild(s)
            }
        }
        T6() {
            this.oD() || this.KNi && (this.ght.classList.remove("parentItem"),
            this.pYt.m0(null),
            this.IUi && this.BGt.m0(this.G4),
            this.pYt.k_().removeEventListener("UITap", this.mYt),
            TS.Qs.UO(this.KNi),
            this.KNi = null)
        }
        WH(t, i, e, s, n) {
            if (!(null == t || TS.K9(t) || t instanceof TS.Qs.d0))
                throw new TypeError("invalid icon");
            TS.zt(i),
            this.R6();
            let r = TS.v(TS.Qs.Fk.f5, this.L2, this, t, i, e, s, n);
            return this.Bji(r, s),
            (!n || n && n.repositionChildContainers) && this.Lji(),
            r
        }
        _A(t, i, e, s) {
            return TS.U(t, TS.Qs.Fk.f5),
            TS.gL(i),
            TS.iM(e),
            IS(this.o5().dNi(), "configure tree to use detachable items"),
            IS(!t.gn(), "item already released"),
            IS(!t.oD(), "can not add root item"),
            IS(t.Z5(), "item is not detached"),
            this.R6(),
            i && t.ha(i),
            t.c8 = this,
            t.yji = !1,
            (!s || s && s.addToParent) && TS.Qs.xgt(t.k_(), this.q6(), e),
            this.Bji(t, e),
            (!s || s && s.repositionChildContainers) && this.Lji(),
            t
        }
        Bji(t, i) {
            if (TS.U(t, TS.Qs.Fk.f5),
            TS.iM(i),
            TS.ub(i) ? i < 0 ? this.$Ei.unshift(t) : this.$Ei.splice(i, 0, t) : this.$Ei.push(t),
            this.$Ei.length && this.pYt && !this.oD()) {
                this.pYt.m0(null),
                this.pYt.k_().removeEventListener("UITap", this.mYt);
                let t = this.xji() ? this.L2.sNi() : this.L2.nNi();
                this.pYt.m0(t),
                this.IUi && (t = this.xji() ? this.G4 : this.IUi,
                this.BGt.m0(t)),
                this.pYt.k_().addEventListener("UITap", this.mYt)
            }
            this.L2.iNi()
        }
        BTt(t) {
            t ? this.ght.setAttribute("fade", "") : this.ght.removeAttribute("fade", "")
        }
        E6(t) {
            TS.U(t, TS.Qs.d0),
            this.oD() || (this.IUi = t,
            this.KNi && !this.xji() && this.BGt.m0(this.IUi))
        }
        dHt(t) {
            TS.U(t, TS.Qs.d0),
            this.oD() || (this.G4 = t,
            this.KNi && this.xji() && this.BGt.m0(this.G4))
        }
        gO(t) {
            this.Ez() || this._5(),
            this.wNi(),
            this.L2.B3(this, t) || (t.preventDefault(),
            t.stopPropagation())
        }
        Rqt(t) {
            t = !!t;
            const i = this.kji();
            i && this.L2.pNi(this, "itemexpandmany");
            const e = [];
            let s = this.c8;
            for (; s; ) {
                if (!s.oD()) {
                    let i = this.Pji(t);
                    i = this.Gji(i);
                    let n = null;
                    if (i && this.KNi && !this.xji()) {
                        const t = new Promise(t => {
                            n = i => {
                                i.item === this && t()
                            }
                            ,
                            this.L2.addEventListener("itemexpandfinish", n)
                        }
                        );
                        e.push({
                            promise: t,
                            item: this,
                            Fji: n
                        })
                    }
                    s.v6(!0, i)
                }
                s = s.dD()
            }
            i ? e.length ? Promise.all(e.map(t => t.promise)).then( () => {
                e.forEach(t => this.L2.removeEventListener("itemexpandfinish", t.Fji)),
                this.L2.pNi(this, "itemexpandmanyfinish")
            }
            ) : this.L2.pNi(this, "itemexpandmanyfinish") : e.forEach(t => this.L2.removeEventListener("itemexpandfinish", t.Fji))
        }
        x5(t="auto") {
            this.L2 && TS.Qs.x5(this.ght, this.L2.k_(), t)
        }
        Vit(t) {
            t = !!t,
            this.Rqt(t),
            this.x5()
        }
        YNi() {
            this.qNi = -1,
            this.ght && this.FO().removeEventListener("pointermove", this.ZNi),
            this.gz(this.tji, this.iji, "label") && this.L2.pNi(this, "itemedit")
        }
        Cji(t) {
            this.JNi = !!t
        }
        wNi() {
            this.JNi && (this.ght && this.FO().removeEventListener("pointermove", this.ZNi),
            -1 !== this.qNi && (clearTimeout(this.qNi),
            this.qNi = -1))
        }
        Uji() {
            return !!this.uVt
        }
        mnt(t=this.iSt(), i=0, e=t.length) {
            if (TS.gL(t),
            this.uVt || this.dn)
                return Promise.resolve("");
            this._5(),
            this.Vit();
            const s = this.L2.k_()
              , n = s.getBoundingClientRect();
            let r = this.MLi.getBoundingClientRect();
            const h = TS.Ne(r.width + 5, 30, s.clientWidth - (r.left - n.left) - 15)
              , o = r.left - n.left
              , a = r.top - n.top + s.scrollTop;
            return this.uVt = TS.Qs.W_("input", this.L2.k_(), null, "tree-edit-text"),
            this.uVt.type = "text",
            this.uVt.style.left = `${o}px`,
            this.uVt.style.top = `${a}px`,
            this.uVt.style.width = `${h}px`,
            this.uVt.style.maxWidth = `${h}px`,
            this.uVt.setAttribute("spellcheck", "false"),
            this.cji = t => this.Rwi(),
            this.uVt.addEventListener("blur", this.cji),
            this.dji = t => this.Nji(),
            this.uVt.addEventListener("input", this.dji),
            this.aFi = t => this.jji(t),
            this.uVt.addEventListener("keydown", this.aFi, !0),
            this.L2.k_().addEventListener("scroll", this.fji),
            this.L2.GNi(!0, this),
            this.uVt.value = t,
            this.uVt.focus(),
            this.uVt.setSelectionRange(i, e),
            this.MLi.textContent = ".",
            r = this.MLi.getBoundingClientRect(),
            this.uVt.style.height = r.bottom - r.top + "px",
            new Promise(t => this.pji = t)
        }
        jji(t) {
            t.which === TS.Mk.aY ? (t.preventDefault(),
            t.stopPropagation(),
            this.Rwi()) : t.which === TS.Mk.VJ && (t.preventDefault(),
            t.stopPropagation(),
            this.gNi())
        }
        Nji() {
            const t = this.L2.k_()
              , i = t.getBoundingClientRect();
            this.MLi.textContent = this.uVt.value;
            const e = this.MLi.getBoundingClientRect()
              , s = TS.Ne(e.width + 5, 30, t.clientWidth - (e.left - i.left) - 15);
            this.uVt.style.width = `${s}px`,
            this.uVt.style.maxWidth = `${s}px`,
            this.MLi.textContent = "."
        }
        gji() {
            let t = this.L2.k_().getBoundingClientRect()
              , i = this.MLi.getBoundingClientRect();
            this.uVt.style.left = i.left - t.left + "px",
            this.uVt.style.top = `${i.top - t.top + this.L2.k_().scrollTop}px`;
            let e = this.uVt.getBoundingClientRect();
            (e.bottom > t.bottom + 1 || e.top < t.top - 1) && this.gNi()
        }
        $ji() {
            this.uVt && (this.MLi.textContent = this.hy,
            this.L2.k_().removeEventListener("scroll", this.fji, {
                passive: !0
            }),
            this.L2.GNi(!1, this),
            this.uVt.removeEventListener("keydown", this.aFi, !0),
            this.aFi = null,
            this.uVt.removeEventListener("input", this.dji),
            this.dji = null,
            this.uVt.removeEventListener("blur", this.cji),
            this.cji = null,
            TS.Qs.UO(this.uVt),
            this.uVt = null)
        }
        gNi() {
            this.uVt && (this.$ji(),
            this.pji && this.pji(null),
            this.pji = null)
        }
        Rwi() {
            if (!this.uVt)
                return;
            let t = this.uVt.value;
            this.$ji(),
            this.pji && this.pji(t),
            this.pji = null,
            this._5(),
            this.L2.k_().focus()
        }
        hnt() {
            if (this.oD())
                throw new Error("cannot add checkbox to root item");
            this.hji || (this.hji = this.FO().createElement("input"),
            this.hji.className = "tree-checkbox",
            this.hji.type = "checkbox",
            this.oji = t => this.zji(t),
            this.hji.addEventListener("change", this.oji),
            this.aji = t => t.stopPropagation(),
            this.hji.addEventListener("UIDoubleTap", this.aji),
            this.hji.addEventListener("pointerdown", TS.Qs.gdt),
            this.rji.insertBefore(this.hji, this.rji.firstChild))
        }
        Vji(t, i) {
            this.int(t, i, this.BGt.k_())
        }
        int(t, i, e) {
            if (TS.zt(t),
            this.oD())
                throw new Error("cannot add extra icons to root item");
            if (this.uji || (this.uji = new Map),
            this.uji.has(t))
                return;
            const s = TS.K9(i) ? self.app.oi(i) : i
              , n = TS.v(TS.Qs._q, s, null);
            e = e || this.MLi,
            this.rji.insertBefore(n.k_(), e),
            this.uji.set(t, {
                vji: n,
                Wji: i => {
                    this.wNi(),
                    i.button === TS.gF.sV && (this.L2.pNi(this, "itemiconclick", {
                        Hji: t
                    }) || i.stopPropagation())
                }
            }),
            n.k_().addEventListener("pointerdown", this.uji.get(t).Wji),
            n.k_().addEventListener("UIDoubleTap", TS.Qs.gdt)
        }
        snt(t) {
            if (TS.zt(t),
            !this.uji)
                return;
            const i = this.uji.get(t);
            i && (i.vji && (i.vji.k_().removeEventListener("pointerdown", i.Wji),
            i.vji.k_().removeEventListener("UIDoubleTap", TS.Qs.gdt),
            i.vji.he()),
            this.uji.delete(t))
        }
        zji(t) {
            this.wNi(),
            this.L2.pNi(this, "itemcheckchange") || t.stopPropagation()
        }
        lnt(t) {
            if (!this.hji)
                throw new Error("no checkbox added");
            this.hji.checked = !!t
        }
        dnt() {
            if (!this.hji)
                throw new Error("no checkbox added");
            return !!this.hji.checked
        }
        LNi(t) {
            this.Kji(t ? "match" : "no-match")
        }
        UNi() {
            this.Kji(""),
            this.NNi(!1)
        }
        qji() {
            return this.VNi
        }
        U6() {
            return "no-match" === this.qji()
        }
        BNi() {
            return "match" === this.qji()
        }
        Xji() {
            return "" === this.qji()
        }
        Kji(t) {
            if ("match" === t || this.VNi !== t) {
                if ("" === t)
                    this.ght.classList.remove("searchMatch"),
                    this.ght.classList.remove("searchNoMatch");
                else if ("match" === t) {
                    "match" !== this.VNi && (this.ght.classList.add("searchMatch"),
                    this.ght.classList.remove("searchNoMatch"));
                    for (const t of this.V6())
                        t.NNi(!0),
                        "no-match" === t.qji() && t.Kji("")
                } else
                    "no-match" === t && (this.ght.classList.add("searchNoMatch"),
                    this.ght.classList.remove("searchMatch"));
                this.VNi = t
            }
        }
        NNi(t, i=!1) {
            t = !!t,
            this.oD() || (i ? (this.zNi === t && (this.zNi = !this.zNi),
            this.v6(t, !1, !0)) : this.v6(this.z6() || t, !1, !0))
        }
        kNi(t) {
            TS.Ge(t),
            this.mji = t
        }
        Yji() {
            return this.mji
        }
        static RNi(t, i) {
            return t.Yji() - i.Yji()
        }
        S5() {
            return {
                name: this.iSt(),
                expanded: this.z6(),
                children: [...this.children()].map(t => t.S5())
            }
        }
        Q3(t) {
            if (!t)
                return;
            this.eQ = !0,
            this.oD() || this.v6(t.expanded);
            const i = this.Do();
            TS.Bm(i, self.xpe) && i.N6(this.z6()),
            TS.w9(i.N6) && i.N6(this.z6());
            const e = [...this.children()];
            if (e.length)
                for (let i = 0; i < e.length; i++) {
                    const s = e[i];
                    s && s.Q3(this.L2.$Ni(e[i], t.children))
                }
            this.eQ = !1
        }
    }
}
{
    const OS = globalThis.t
      , DS = globalThis.assert
      , FS = ["static", "sortable", "draggable"]
      , LS = ["left", "right"]
      , BS = ["label-under", "label-right"]
      , US = 100
      , NS = {
        t8: -1,
        Jji: "label-under",
        itemType: "static",
        N2: !1,
        J2: "",
        W2: "auto",
        Q2: [],
        e8: NaN
    };
    OS.Qs.Fk.Y6 = class extends OS.Event.v_ {
        constructor(t, i) {
            if (super(),
            OS.mGt(t),
            OS.kQ(i),
            i = Object.assign({}, NS, i),
            OS.Ge(i.t8),
            OS.zt(i.Jji),
            OS.zt(i.itemType),
            !FS.includes(i.itemType))
                throw new Error("invalid item type");
            if (!BS.includes(i.Jji))
                throw new Error("invalid item style");
            this.c8 = null,
            this.ght = null,
            this.wUi = i.t8,
            this.wUi < 0 && (this.wUi = self.app.Oq()),
            this.jtt = i.itemType,
            this.Zji = i.Jji,
            this.yUi = !!i.N2,
            this.Mri = [],
            this.PUi = new Set,
            this.Qji = [],
            t && "ui-iconview" === t.tagName.toLowerCase() ? (this.c8 = t.parentElement,
            this.ght = t) : (this.c8 = t,
            this.ght = OS.Qs.W_("ui-iconview", this.c8)),
            this.ght.setAttribute(this.Zji, ""),
            this.mF = t => this.mO(t),
            this.ght.addEventListener("pointerdown", this.mF),
            this.ght.setAttribute("tabindex", 0),
            this.HDi = t => this._Ui(),
            this.qDi = t => this.xft(),
            this.ght.addEventListener("focus", this.HDi),
            this.ght.addEventListener("blur", this.qDi),
            this.t$i = [],
            this.pG = t => this.wG(t),
            this.NUi = "",
            this.i$i = null,
            this.jUi = new OS.ZG( () => this.$Ui(),US),
            this.jUi.JG(!0),
            this.zUi = !1,
            this.YUi = OS.Qs.W_("div", null, null, "iconViewNoSearchResults"),
            this.YUi.setAttribute("position", i.W2),
            this.JUi = !1,
            this.HUi = OS.Qs.W_("div", this.ght, null, "iconViewNoItems"),
            this.HUi.textContent = i.J2 || self.lang("ui.controls.icon-view.no-items-showing"),
            this.HUi.setAttribute("position", i.W2),
            this.KUi = OS.Qs.W_("div", this.HUi, null, "iconViewNoItemsOptions");
            for (const t of i.Q2) {
                OS.zt(t.text),
                OS.zt(t.tag);
                const i = OS.Qs.W_("button", this.KUi, null, "treeNoItemsOption");
                i.textContent = t.text,
                i.addEventListener("click", () => this.e$i("noitemsoptionclick", {
                    tag: t.tag
                }))
            }
            this.XUi = !0,
            this.s$i = null,
            this.BTi = null,
            this.n$i = OS.ub(i.e8) && i.e8 > 0 ? i.e8 : NaN,
            this.r$i = [],
            this.h$i = 0,
            this.o$i = null,
            this.a$i = null,
            this.l$i = null,
            this.u$i = null,
            this.c$i = null,
            this.d$i = null,
            OS.ub(this.n$i) && this.n$i > 0 && (this.a$i = OS.Qs.W_("div", this.c8, null, "icon-view-pagination-controls"),
            this.a$i.setAttribute("hide", ""),
            this.l$i = OS.Qs.W_("button", this.a$i),
            this.l$i.textContent = self.lang("common.previous"),
            this.l$i.addEventListener("click", () => this.f$i()),
            this.o$i = OS.Qs.W_("label", this.a$i),
            this.o$i.textContent = self.lang("ui.controls.icon-view.pagination.pages"),
            this.u$i = OS.Qs.W_("select", this.a$i),
            this.u$i.addEventListener("change", () => this.p$i()),
            this.c$i = OS.Qs.W_("label", this.a$i),
            this.d$i = OS.Qs.W_("button", this.a$i),
            this.d$i.textContent = self.lang("common.next"),
            this.d$i.addEventListener("click", () => this.m$i()),
            this.c8 && (this.c8.style.display = "flex",
            this.c8.style.flexFlow = "column"))
        }
        he() {
            this.Ry(!0),
            this.FO().removeEventListener("keydown", this.pG),
            this.pG = null,
            this.i$i = null,
            this.jUi.he(),
            this.jUi = null,
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            OS.Qs.UO(this.HUi),
            this.HUi = null,
            OS.Qs.UO(this.YUi),
            this.YUi = null,
            this.ght.removeEventListener("focus", this.HDi),
            this.ght.removeEventListener("blur", this.qDi),
            this.HDi = null,
            this.qDi = null,
            OS.Qs.UO(this.ght),
            this.ght = null,
            this.s$i = null,
            this.c8 = null,
            super.he()
        }
        b8(t) {
            OS.ibt(t),
            this.c8 !== t && (this.c8 && (this.a$i && (this.c8.style.display = "",
            this.c8.style.flexFlow = ""),
            this.c8.removeChild(this.ght)),
            this.c8 = t,
            this.c8.appendChild(this.ght),
            this.a$i && (this.c8.appendChild(this.a$i),
            this.c8.style.display = "flex",
            this.c8.style.flexFlow = "column"))
        }
        FO() {
            return this.ght.ownerDocument
        }
        w$i(t) {
            if (OS.U(t, OS.Qs.Fk.q4),
            t.g$i() !== this)
                throw new Error("item from different icon view")
        }
        Ry(t) {
            for (const i of this.Qji)
                i.S0(t);
            OS.Io(this.Qji);
            for (const i of this.Mri)
                i.S0(t);
            OS.Io(this.Mri);
            for (const i of this.r$i) {
                for (const e of i)
                    ("function" != typeof e.g$i || e.g$i()) && "function" == typeof e.S0 && e.S0(t);
                OS.Io(i)
            }
            OS.Io(this.r$i),
            this.PUi.clear(),
            OS.Io(this.t$i),
            this.u$i && (OS.Qs.L6(this.u$i),
            OS.Qs.UO(this.a$i)),
            t ? OS.Qs.L6(this.ght) : (this.i5(!1),
            this.iNi())
        }
        y$i(t) {
            this.w$i(t),
            t.S0(),
            this.Mri.splice(this.Mri.indexOf(t), 1),
            this.iNi()
        }
        eNi() {
            return this.wUi
        }
        b$i() {
            return this.Zji
        }
        v$i() {
            return OS.ub(this.n$i)
        }
        S$i() {
            return this.n$i
        }
        x$i() {
            return this.a$i
        }
        f$i() {
            if (!this.v$i())
                return;
            const t = this.h$i;
            if (this.h$i--,
            this.h$i < 0 && (this.h$i = 0),
            t === this.h$i)
                return;
            OS.Io(this.Mri),
            this.PUi.clear(),
            OS.Io(this.t$i),
            OS.Qs.L6(this.ght),
            this.e$i("beforepagechange");
            const i = this.r$i[this.h$i];
            for (let t = 0; t < i.length; t++) {
                let e = i[t];
                if (!OS.Bm(e, OS.Qs.Fk.q4) && !OS.Bm(e, OS.Qs.Fk.M$i) && !OS.Bm(e, OS.Qs.Fk.E$i)) {
                    const s = e?.j8;
                    "static" === this.jtt && (e = OS.v(OS.Qs.Fk.q4, this, e.icon, e.text, e.C$i, e.index, e.group, !0)),
                    "sortable" === this.jtt && (e = OS.v(OS.Qs.Fk.M$i, this, e.icon, e.text, e.C$i, e.index, !0)),
                    "draggable" === this.jtt && (e = OS.v(OS.Qs.Fk.E$i, this, e.icon, e.text, e.C$i, e.index, !0)),
                    s && s(e),
                    i[t] = e
                }
                this.ght.appendChild(e.k_()),
                this.Mri.push(e)
            }
            this.u$i.selectedIndex = this.h$i,
            this.i5(!1),
            this.iNi(),
            this.e$i("pagechange")
        }
        p$i() {
            if (!this.v$i())
                return;
            this.h$i = this.u$i.selectedIndex,
            OS.Io(this.Mri),
            this.PUi.clear(),
            OS.Io(this.t$i),
            OS.Qs.L6(this.ght),
            this.e$i("beforepagechange");
            const t = this.r$i[this.h$i];
            for (let i = 0; i < t.length; i++) {
                let e = t[i];
                if (!OS.Bm(e, OS.Qs.Fk.q4) && !OS.Bm(e, OS.Qs.Fk.M$i) && !OS.Bm(e, OS.Qs.Fk.E$i)) {
                    const s = e?.j8;
                    "static" === this.jtt && (e = OS.v(OS.Qs.Fk.q4, this, e.icon, e.text, e.C$i, e.index, e.group, !0)),
                    "sortable" === this.jtt && (e = OS.v(OS.Qs.Fk.M$i, this, e.icon, e.text, e.C$i, e.index, !0)),
                    "draggable" === this.jtt && (e = OS.v(OS.Qs.Fk.E$i, this, e.icon, e.text, e.C$i, e.index, !0)),
                    s && s(e),
                    t[i] = e
                }
                this.ght.appendChild(e.k_()),
                this.Mri.push(e)
            }
            this.u$i.selectedIndex = this.h$i,
            this.i5(!1),
            this.iNi(),
            this.e$i("pagechange")
        }
        m$i() {
            if (!this.v$i())
                return;
            const t = this.h$i;
            if (this.h$i++,
            this.h$i >= this.r$i.length && (this.h$i = this.r$i.length - 1),
            t === this.h$i)
                return;
            OS.Io(this.Mri),
            this.PUi.clear(),
            OS.Io(this.t$i),
            OS.Qs.L6(this.ght),
            this.e$i("beforepagechange");
            const i = this.r$i[this.h$i];
            for (let t = 0; t < i.length; t++) {
                let e = i[t];
                if (!OS.Bm(e, OS.Qs.Fk.q4) && !OS.Bm(e, OS.Qs.Fk.M$i) && !OS.Bm(e, OS.Qs.Fk.E$i)) {
                    const s = e?.j8;
                    "static" === this.jtt && (e = OS.v(OS.Qs.Fk.q4, this, e.icon, e.text, e.C$i, e.index, e.group, !0)),
                    "sortable" === this.jtt && (e = OS.v(OS.Qs.Fk.M$i, this, e.icon, e.text, e.C$i, e.index, !0)),
                    "draggable" === this.jtt && (e = OS.v(OS.Qs.Fk.E$i, this, e.icon, e.text, e.C$i, e.index, !0)),
                    s && s(e),
                    i[t] = e
                }
                this.ght.appendChild(e.k_()),
                this.Mri.push(e)
            }
            this.u$i.selectedIndex = this.h$i,
            this.i5(!1),
            this.iNi(),
            this.e$i("pagechange")
        }
        hNi() {
            return this.yUi
        }
        _$i(t) {
            t = !!t,
            this.yUi !== t && (t || this.vFt(),
            this.yUi = t)
        }
        k_() {
            return this.ght
        }
        KWt() {
            return this.BTi || (this.BTi = this.ght.getBoundingClientRect()),
            this.BTi
        }
        dD() {
            return this.c8
        }
        T$i() {
            return this.s$i
        }
        I$i(t) {
            OS.U(t, OS.Qs.Fk.q4),
            this.s$i = t
        }
        h5() {
            return OS.Qs.Fk.M$i.h5()
        }
        qnt() {
            return OS.Qs.Fk.M$i.Pit()
        }
        Pit() {
            return OS.Qs.Fk.M$i.Pit()
        }
        f1() {
            this.Pit() && OS.Qs.Fk.M$i.f1()
        }
        items() {
            return this.Mri
        }
        *MNi() {
            for (const t of this.Mri)
                t.fae() || (yield t)
        }
        T_t() {
            return this.Mri.length
        }
        E_t(t) {
            return OS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.Mri.length ? null : this.Mri[t]
        }
        P$i() {
            return OS.th(this.items())
        }
        G$i(t) {
            this.w$i(t);
            let i = this.S_t(t) - 1;
            return OS.nii(i, this.Mri) ? this.Mri[i] : null
        }
        A$i(t) {
            this.w$i(t);
            let i = this.S_t(t) + 1;
            return OS.nii(i, this.Mri) ? this.Mri[i] : null
        }
        R$i(t) {
            if (OS.zt(t),
            !FS.includes(t))
                throw new Error("invalid item type");
            this.jtt = t
        }
        Rtt() {
            return "static" === this.jtt ? OS.Qs.Fk.q4 : "sortable" === this.jtt ? OS.Qs.Fk.M$i : "draggable" === this.jtt ? OS.Qs.Fk.E$i : void 0
        }
        k$i(t) {
            OS.nu(t);
            for (let i of this.Mri)
                if (t(i))
                    return i;
            return null
        }
        O$i() {
            this.Mri.reverse();
            let t = this.ght.firstChild;
            for (let i = this.ght.children.length - 1; i > 0; i--) {
                let i = this.ght.lastChild;
                this.ght.removeChild(i),
                this.ght.insertBefore(i, t)
            }
        }
        D$i(t, i) {
            if (OS.Ge(t),
            OS.Ge(i),
            t < 0 || t >= this.Mri.length)
                throw new Error("invalid item index");
            if (i < 0 || i >= this.Mri.length)
                throw new Error("invalid item index");
            if (t === i)
                return;
            let e = this.Mri[t].k_();
            this.ght.removeChild(e);
            let s = this.Mri[i].k_();
            t < i ? this.ght.insertBefore(e, s.nextSibling) : this.ght.insertBefore(e, s),
            this.Mri.splice(i, 0, this.Mri.splice(t, 1)[0])
        }
        fNi(t) {
            this.w$i(t),
            this.PUi.add(t),
            this.s$i = t,
            this.pNi(t, "itemselect")
        }
        mNi(t) {
            this.w$i(t),
            this.PUi.delete(t),
            this.s$i === t && (this.s$i = null),
            this.pNi(t, "itemunselect")
        }
        _Tt() {
            return this.PUi.size
        }
        F$i(t) {
            t.I6(!0)
        }
        ENi(t, i) {
            if (OS.U(t, OS.Qs.Fk.q4),
            OS.U(i, OS.Qs.Fk.q4),
            this.w$i(t),
            this.w$i(i),
            t === i)
                return this.e$i("beforeselectrange"),
                t.I6(!0),
                void this.e$i("selectrange");
            let e = !1
              , s = null;
            const n = [];
            for (const r of this.items())
                if (e || (r === t ? (e = !0,
                s = i) : r === i && (e = !0,
                s = t)),
                e && (n.push(r),
                r === s))
                    break;
            s === t && n.reverse(),
            this.e$i("beforeselectrange");
            for (const t of n)
                t.fae() || t.I6(!0);
            this.e$i("selectrange")
        }
        vFt() {
            for (let t of this.PUi)
                t.I6(!1);
            self.assert(0 === this.PUi.size, "should have deleted all selected items")
        }
        I_t() {
            return this.PUi.values()
        }
        d8() {
            return [...this.PUi.values()].map(t => t.Do())
        }
        Eit() {
            return OS.th(this.PUi)
        }
        L$i() {
            const t = this.P$i();
            t && t._5()
        }
        B$i() {
            const t = this.P$i();
            t && (t._5(),
            t.x5())
        }
        _Ui() {
            this.FO().addEventListener("keydown", this.pG)
        }
        xft() {
            this.FO().removeEventListener("keydown", this.pG)
        }
        wG(t) {
            if (1 !== this._Tt())
                return;
            const i = t.which;
            if (i !== OS.Mk.UZ && i !== OS.Mk.FZ && i !== OS.Mk.zZ && i !== OS.Mk.WZ)
                return;
            const e = this.Eit();
            let s = this.Mri.indexOf(e);
            if (!(s < 0)) {
                if (i === OS.Mk.zZ)
                    do {
                        --s
                    } while (s >= 0 && this.Mri[s].fae());
                else if (i === OS.Mk.WZ)
                    do {
                        ++s
                    } while (s < this.Mri.length && this.Mri[s].fae());
                else {
                    e.fxi();
                    const t = e.KWt()
                      , n = i === OS.Mk.FZ ? 1 : -1;
                    s += n;
                    for (let i = this.Mri.length; s >= 0 && s < i; s += n) {
                        const i = this.Mri[s];
                        if (i.fae())
                            continue;
                        i.fxi();
                        const e = i.KWt();
                        if (!(e.right < t.left + 1 || e.left > t.right - 1) && (1 === n && e.top > t.bottom - 1 || -1 === n && e.bottom < t.top + 1))
                            break
                    }
                }
                s < 0 || s >= this.Mri.length || (this.Mri[s]._5(),
                this.Mri[s].x5(),
                t.preventDefault())
            }
        }
        mO(t) {
            if (t.target !== this.ght || OS.bk.$F(t) || t.shiftKey)
                return;
            const i = this.ght.getBoundingClientRect()
              , e = i.left + this.ght.clientWidth
              , s = i.top + this.ght.clientHeight;
            i.left < t.clientX && e > t.clientX && i.top < t.clientY && s > t.clientY && (this.e$i("emptyspaceclick"),
            this.vFt())
        }
        U$i(t) {
            this.w$i(t),
            this.t$i.push(t),
            this.t$i.length > 2 && this.t$i.shift()
        }
        N$i() {
            return this.t$i
        }
        e$i(t, i) {
            OS.zt(t);
            let e = new OS.Event(t,!0);
            return e.j$i = this,
            this.dispatchEvent(Object.assign(e, i))
        }
        pNi(t, i) {
            this.w$i(t),
            OS.zt(i);
            let e = new OS.Event(i,!0);
            return e.item = t,
            this.dispatchEvent(e)
        }
        B3(t, i) {
            this.w$i(t);
            let e = new OS.Event("itemcontextmenu",!0);
            return e.item = t,
            e.clientX = i.clientX,
            e.clientY = i.clientY,
            this.dispatchEvent(e)
        }
        S_t(t) {
            return this.w$i(t),
            this.Mri.indexOf(t)
        }
        $$i(t) {
            return this.w$i(t),
            Array.prototype.indexOf.call(this.ght.children, t.k_())
        }
        z$i(t, i, e) {
            this.w$i(t),
            OS.Ge(i),
            OS.zt(e);
            let s = this.Mri;
            if (i < 0 || i >= s.length)
                throw new Error("new index is out of bounds");
            if (!LS.includes(e))
                throw new Error(`invalid position, '${e}' was used. Only ${LS.toString()} are valid positions.`);
            let n = this.Mri[i];
            if (n === t)
                return;
            this.k_().removeChild(t.k_()),
            "left" === e && this.k_().insertBefore(t.k_(), n.k_()),
            "right" === e && n.k_().parentNode.insertBefore(t.k_(), n.k_().nextSibling);
            let r = this.S_t(t)
              , h = 0;
            return i > r ? ("left" === e && (h = i > 0 ? i - 1 : 0,
            s.splice(h, 0, s.splice(r, 1)[0])),
            "right" === e && (h = i,
            s.splice(h, 0, s.splice(r, 1)[0]))) : ("left" === e && (h = i,
            s.splice(h, 0, s.splice(r, 1)[0])),
            "right" === e && (h = i < s.length - 1 ? i + 1 : i,
            s.splice(h, 0, s.splice(r, 1)[0]))),
            h
        }
        V$i(t, i, e) {
            OS.Ge(i),
            OS.zt(e),
            this.w$i(t);
            let s = this.Mri;
            if (i < 0 || i >= s.length)
                throw new Error("new index is out of bounds");
            if (!LS.includes(e))
                throw new Error(`invalid position, '${e}' was used. Only ${LS.toString()} are valid positions.`);
            let n = 0;
            return i > this.S_t(t) ? ("left" === e && (n = i > 0 ? i - 1 : 0),
            "right" === e && (n = i)) : ("left" === e && (n = i),
            "right" === e && (n = i < s.length - 1 ? i + 1 : i)),
            n
        }
        W$i() {
            this.BTi = this.ght.getBoundingClientRect();
            for (let t of this.Mri)
                t.fxi()
        }
        H$i() {}
        K$i() {}
        _A(t, i, e, s, n, r) {
            let h;
            if (OS.Ef(t, OS.Qs.d0),
            OS.p0(i),
            OS.iM(s),
            OS.Ef(n, OS.Qs.Fk.q$i),
            n && (s = null),
            this.v$i()) {
                if (DS(!n, "groups not supported with pagination"),
                DS(!s, "indexing not supported with pagination"),
                n = null,
                s = null,
                !(this.Mri.length <= this.S$i())) {
                    "static" === this.jtt && (h = {
                        icon: t,
                        text: i,
                        C$i: e,
                        C$i: e,
                        index: s,
                        group: n,
                        j8: r?.j8
                    }),
                    "sortable" === this.jtt && (h = {
                        icon: t,
                        text: i,
                        C$i: e,
                        C$i: e,
                        index: s,
                        group: n,
                        j8: r?.j8
                    }),
                    "draggable" === this.jtt && (h = {
                        icon: t,
                        text: i,
                        C$i: e,
                        C$i: e,
                        index: s,
                        group: n,
                        j8: r?.j8
                    });
                    let o = this.r$i[this.r$i.length - 1];
                    return o || (o = this.X$i(!0)),
                    o.length >= this.S$i() && (o = this.X$i(!0)),
                    void o.push(h)
                }
                {
                    "static" === this.jtt && (h = OS.v(OS.Qs.Fk.q4, this, t, i, e, s, n, !0)),
                    "sortable" === this.jtt && (h = OS.v(OS.Qs.Fk.M$i, this, t, i, e, s, !0)),
                    "draggable" === this.jtt && (h = OS.v(OS.Qs.Fk.E$i, this, t, i, e, s, !0));
                    let o = this.r$i[this.r$i.length - 1];
                    o || (o = this.X$i()),
                    o.length >= this.S$i() && (o = this.X$i()),
                    o.push(h),
                    this.Mri.push(h),
                    r?.j8 && r.j8(h)
                }
            } else
                "static" === this.jtt && (h = OS.v(OS.Qs.Fk.q4, this, t, i, e, s, n, !0)),
                "sortable" === this.jtt && (h = OS.v(OS.Qs.Fk.M$i, this, t, i, e, s, !0)),
                "draggable" === this.jtt && (h = OS.v(OS.Qs.Fk.E$i, this, t, i, e, s, !0)),
                OS.ub(s) ? s < 0 ? this.Mri.unshift(h) : this.Mri.splice(s, 0, h) : this.Mri.push(h),
                r?.j8 && r.j8(h);
            return this.iNi(),
            h
        }
        X$i(t) {
            t = !!t;
            const i = []
              , e = OS.Qs.W_("option", this.u$i);
            return this.r$i.push(i),
            e.value = this.r$i.length - 1,
            e.textContent = String(this.r$i.length),
            t && (this.x$i().removeAttribute("hide"),
            this.a$i && this.c8 && (this.c8.appendChild(this.a$i),
            this.c8.style.display = "flex",
            this.c8.style.flexFlow = "column")),
            this.c$i.textContent = self.h_("ui.controls.icon-view.pagination.total", this.r$i.length),
            i
        }
        Doe(t) {
            if (OS.zt(t),
            "sortable" === this.jtt)
                throw new Error("not yet implemented: groups for sortable icon views");
            let i = OS.v(OS.Qs.Fk.q$i, this, t);
            return this.Qji.push(i),
            this.iNi(),
            i
        }
        $Et(t, i) {
            OS.zt(t),
            OS.kQ(i),
            this.zUi = !1,
            i && (this.zUi = !!i.dTt),
            this.NUi = t,
            this.i$i = null,
            this.jUi.FE()
        }
        Y$i(t, i, e) {
            OS.nu(t),
            OS.gL(i),
            OS.kQ(e),
            this.NUi = i || "",
            this.i$i = t,
            this.zUi = !1,
            !e || (this.zUi = !!e.dTt,
            void 0 === e.J$i || e.J$i) ? this.jUi.FE() : this.$Ui()
        }
        $Ui() {
            let t = this.NUi.toLowerCase()
              , i = !1
              , e = this.i$i
              , s = !0;
            for (let n of this.items())
                if (e) {
                    let t = e(n);
                    n.FWt(!t),
                    t && (s && (this.zUi && n._5(),
                    s = !1),
                    i = !0)
                } else if (t) {
                    let e = n.Z$i(t);
                    n.FWt(!e),
                    e && (s && (this.zUi && n._5(),
                    s = !1),
                    i = !0)
                } else
                    n.FWt(!1),
                    i = !0;
            this.i5(!i),
            this.i$i = null;
            const n = new OS.Event("searchresultsupdate");
            this.dispatchEvent(n)
        }
        z5(t) {
            OS.zt(t),
            this.HUi.textContent = t
        }
        N5(t) {
            t = !!t,
            this.KUi.style.display = t ? "" : "none"
        }
        iNi() {
            let t = !this.Mri.length && !this.Qji.length;
            this.XUi = t,
            this.XUi ? (this.ght.contains(this.HUi) || this.ght.appendChild(this.HUi),
            this.HUi.contains(this.KUi) || this.HUi.appendChild(this.KUi)) : this.ght.contains(this.HUi) && OS.Qs.UO(this.HUi)
        }
        i5(t) {
            this.XUi || (this.JUi !== t ? (this.JUi = t,
            this.JUi ? (this.ght.contains(this.YUi) || this.ght.appendChild(this.YUi),
            this.i$i && !this.NUi ? this.YUi.textContent = self.lang("ui.controls.icon-view.no-search-results") : this.YUi.textContent = self.h_("ui.controls.icon-view.no-text-search-results", this.NUi)) : OS.Qs.UO(this.YUi)) : this.JUi && (this.ght.contains(this.YUi) || this.ght.appendChild(this.YUi),
            this.i$i && !this.NUi ? this.YUi.textContent = self.lang("ui.controls.icon-view.no-search-results") : this.YUi.textContent = self.h_("ui.controls.icon-view.no-text-search-results", this.NUi)))
        }
    }
}
{
    const jS = self.t;
    jS.Qs.Fk.q4 = class extends jS.Me {
        constructor(t, i, e, s, n, r, h) {
            if (jS.U(t, jS.Qs.Fk.Y6),
            jS.Ef(i, jS.Qs.d0),
            jS.p0(e),
            jS.iM(n),
            jS.Ef(r, jS.Qs.Fk.q$i),
            h = !!h,
            super(),
            this.X6 = t,
            this.G4 = i || null,
            this.hy = e,
            this.Kc = s,
            this.bWt = !1,
            this.Q$i = r,
            this.tzi = !1,
            this.n5t = -1,
            this.EY = 0,
            this.DY = 0,
            this.BTi = null,
            this.ght = null,
            jS.ub(n)) {
                let t = null;
                h && (t = this.X6.k_()),
                this.ght = jS.Qs.W_("ui-iconviewitem", t, null, null, null, n)
            } else {
                let t = null;
                h && (t = this.Q$i ? this.Q$i.izi() : this.X6.k_()),
                this.ght = jS.Qs.W_("ui-iconviewitem", t)
            }
            this.fJt = jS.Qs.W_("div", this.ght, null, "iconViewItemWrap"),
            this.BGt = jS.v(jS.Qs._q, this.G4 || this.X6.eNi(), this.fJt),
            this.MLi = jS.Qs.W_("span", this.fJt, null, "iconViewItemText"),
            jS.wQ(this.MLi, this.hy),
            this.yWt = t => this.vO(t),
            this.ght.addEventListener("UIDoubleTap", this.yWt),
            this.GB = t => this.gO(t),
            this.ght.addEventListener("contextmenu", this.GB),
            this.mF = t => this.mO(t),
            this.ght.addEventListener("pointerdown", this.mF),
            this.cG = t => this.fG(t),
            this.uG = t => this.dG(t),
            this.KLi = t => this.IN(t)
        }
        S0(t) {
            this.I6(!1),
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.FO().removeEventListener("pointermove", this.cG),
            this.cG = null,
            this.FO().removeEventListener("pointerup", this.uG),
            this.uG = null,
            this.FO().removeEventListener("pointercancel", this.KLi),
            this.KLi = null,
            this.ght.removeEventListener("UIDoubleTap", this.yWt),
            this.yWt = null,
            this.ght.removeEventListener("contextmenu", this.GB),
            this.GB = null,
            this.BGt.he(t),
            this.BGt = null,
            t || (jS.Qs.UO(this.MLi),
            jS.Qs.UO(this.fJt),
            jS.Qs.UO(this.ght)),
            this.MLi = null,
            this.fJt = null,
            this.ght = null,
            this.X6 = null,
            this.G4 = null,
            this.Kc = null,
            jS.he(this)
        }
        FO() {
            return this.ght.ownerDocument
        }
        LO() {
            return this.FO().defaultView
        }
        m0(t) {
            jS.U(t, jS.Qs.d0),
            this.BGt && this.BGt.m0(t)
        }
        U_t(t) {
            jS.nu(t),
            this.BGt && this.BGt.U_t(t)
        }
        N_t() {
            this.BGt.N_t()
        }
        mO(t) {
            t.stopPropagation(),
            t.button === jS.gF.sV && t.isPrimary && (this.X6.U$i(this),
            this.fxi(),
            this.ght.setAttribute("pointerheld", ""),
            this.FO().addEventListener("pointermove", this.cG),
            this.FO().addEventListener("pointerup", this.uG),
            this.FO().addEventListener("pointercancel", this.KLi),
            this.n5t = t.pointerId,
            this.EY = t.clientX,
            this.DY = t.clientY)
        }
        vO(t) {
            this.X6.N$i().every(t => t === this) && this.X6.pNi(this, "itemdoubletap")
        }
        fG(t) {
            t.pointerId === this.n5t && t.isPrimary
        }
        dG(t) {
            if (this.ght && t.pointerId === this.n5t && t.isPrimary) {
                if (this.ght.removeAttribute("pointerheld", ""),
                this.FO().removeEventListener("pointermove", this.cG),
                this.FO().removeEventListener("pointerup", this.uG),
                this.FO().removeEventListener("pointercancel", this.KLi),
                this.X6.pNi(this, "itemclick"),
                this.X6.hNi()) {
                    let t = jS.bk.$F()
                      , i = jS.bk.Sk(jS.Mk.YX)
                      , e = this.X6.T$i();
                    if (t && i && e)
                        return this.X6.ENi(this, e),
                        void this.X6.I$i(this);
                    if (i && e)
                        return this.X6.vFt(),
                        this.X6.ENi(this, e),
                        void this.X6.I$i(this);
                    if (t)
                        return void this.I6(!this.Ez())
                }
                this.ezi(t.clientX, t.clientY) && this._5()
            }
        }
        IN(t) {
            this.ght && this.ght.removeAttribute("pointerheld", "");
            const i = t ? t.currentTarget : this.FO();
            i.removeEventListener("pointermove", this.cG),
            i.removeEventListener("pointerup", this.uG),
            i.removeEventListener("pointercancel", this.KLi),
            this.X6 && this.X6.vFt()
        }
        _5() {
            this.Ez() && 1 === this.X6._Tt() || (this.X6.vFt(),
            this.I6(!0))
        }
        vvt() {
            this.I6(!1)
        }
        Ez() {
            return this.bWt
        }
        I6(t) {
            t = !!t,
            this.bWt !== t && (t ? (this.X6.pNi(this, "beforeitemselect"),
            this.ght.setAttribute("selected", ""),
            this.X6.fNi(this)) : (this.ght.removeAttribute("selected"),
            this.X6.mNi(this)),
            this.bWt = t)
        }
        k_() {
            return this.ght
        }
        g$i() {
            return this.X6
        }
        goe(t) {
            this.Kc = t
        }
        Do() {
            return this.Kc
        }
        KWt() {
            return this.BTi
        }
        ha(t) {
            jS.p0(t),
            jS.Boi(this.hy, t) || (this.hy = t,
            jS.wQ(this.MLi, this.hy))
        }
        iSt() {
            return this.hy
        }
        FWt(t) {
            t = !!t,
            this.tzi !== t && (this.tzi = t,
            this.tzi ? (this.I6(!1),
            this.ght.setAttribute("hidden", ""),
            this.Q$i && this.Q$i.szi(this, !0)) : (this.ght.removeAttribute("hidden"),
            this.Q$i && this.Q$i.szi(this, !1)))
        }
        fae() {
            return this.tzi
        }
        x5(t="auto") {
            jS.Qs.x5(this.ght, this.X6.k_(), t)
        }
        Z$i(t) {
            return this.hy.toLowerCase().includes(t)
        }
        fxi() {
            this.BTi = this.ght.getBoundingClientRect()
        }
        gO(t) {
            this.g$i().hNi() && this.Ez() || this._5(),
            this.X6.B3(this, t) || (t.preventDefault(),
            t.stopPropagation())
        }
        ezi(t, i) {
            if (jS.Ge(t),
            jS.Ge(i),
            !this.BTi)
                return !1;
            let e = this.BTi;
            return t >= e.left && i >= e.top && t < e.right && i < e.bottom
        }
    }
}
{
    const $S = self.t
      , zS = 500
      , VS = 20;
    let WS = 0
      , HS = 0
      , KS = 0
      , qS = 0
      , XS = null
      , YS = !1
      , JS = !0
      , ZS = null
      , QS = null
      , tx = null
      , ix = null
      , ex = 0
      , sx = 0
      , nx = 0
      , rx = !1
      , hx = !1
      , ox = -1;
    function ax(t, i) {
        -1 === ox && (rx || hx) && XS && ZS && (ox = requestAnimationFrame( () => {
            if (ox = -1,
            !ZS)
                return;
            let e = ZS.k_()
              , s = ZS.KWt()
              , n = s.width
              , r = s.height
              , h = t - s.left
              , o = i - s.top
              , a = 0
              , l = 0;
            rx && (h <= VS || h >= n - VS) && (h <= VS ? a = -Math.abs(h - VS) : h >= n - VS && (a = Math.abs(h - (n - VS)))),
            hx && (o <= VS || o >= r - VS) && (o <= VS ? l = -Math.abs(o - VS) : o >= r - VS && (l = Math.abs(o - (r - VS)))),
            0 === a && 0 === l || (0 !== a && 0 !== l && (a /= Math.SQRT2,
            l /= Math.SQRT2),
            0 !== a && (e.scrollLeft += a / self.devicePixelRatio),
            0 !== l && (e.scrollTop += l / self.devicePixelRatio),
            ZS.W$i(),
            ax(WS, HS))
        }
        ))
    }
    function lx(t, i) {
        WS = t.clientX,
        HS = t.clientY;
        let e = Math.abs(KS - WS)
          , s = Math.abs(qS - HS);
        if (XS && JS) {
            if ("sortable" === i)
                $S.Qs.Fk.M$i.e$i("attemptitemsort", QS, WS, HS);
            JS = !1
        }
        if (e * e + s * s < zS && !YS)
            return;
        if (XS && !YS) {
            switch (i) {
            case "sortable":
                $S.Qs.Fk.M$i.e$i("startitemsort", QS, WS, HS);
                break;
            case "draggable":
                $S.Qs.Fk.M$i.e$i("dragstart", QS, WS, HS)
            }
            XS.style.visibility = "visible",
            YS = !0
        }
        $S.Qs.Fk.M$i.nzi(WS, HS);
        if (XS && ZS)
            switch (ax(WS, HS),
            i) {
            case "sortable":
                if (tx) {
                    if (tx.ezi(WS, HS)) {
                        let t = tx.k_();
                        return t.setAttribute("drop-target", ""),
                        void t.setAttribute("hit-side", tx.rzi(WS, HS))
                    }
                    tx.hzi()
                }
                for (let t of ZS.items())
                    if (t !== QS && t.ezi(WS, HS)) {
                        tx = t;
                        let i = tx.k_();
                        return i.setAttribute("drop-target", ""),
                        void i.setAttribute("hit-side", t.rzi(WS, HS))
                    }
                tx = null;
                break;
            case "draggable":
                YS && $S.Qs.Fk.M$i.e$i("dragmove", QS, WS, HS)
            }
    }
    function ux(t, i) {
        if (XS)
            switch (XS.parentNode.removeChild(XS),
            i) {
            case "sortable":
                if (tx !== QS && QS && tx) {
                    const t = ZS._Tt();
                    if (t <= 1) {
                        let t = ZS.$$i(tx)
                          , i = ZS.$$i(QS)
                          , e = tx.k_().getAttribute("hit-side");
                        t = ZS.z$i(QS, t, e),
                        $S.Qs.Fk.M$i.ozi(i, t, QS)
                    } else if (t > 1) {
                        let t = ZS.$$i(tx)
                          , i = tx.rzi(WS, HS);
                        const e = [...ZS.I_t()]
                          , s = e.map(t => ({
                            azi: ZS.$$i(t),
                            lzi: NaN,
                            item: t,
                            uzi: NaN,
                            delta: NaN
                        }));
                        let n = ZS.$$i(QS);
                        const r = []
                          , h = [];
                        for (const t of s)
                            t.delta = Math.abs(t.azi - n),
                            t.azi < n ? (t.lzi = n - t.delta,
                            r.push(t)) : t.azi > n && (t.lzi = n + t.delta,
                            h.push(t));
                        r.sort( (t, i) => i.lzi - t.lzi),
                        h.sort( (t, i) => t.lzi - i.lzi);
                        const o = []
                          , a = []
                          , l = ZS.$$i(QS);
                        t = ZS.z$i(QS, t, i),
                        o.push(l),
                        a.push(t);
                        for (let i = 0; i < r.length; i++) {
                            const e = r[i];
                            t = ZS.$$i(QS),
                            e.azi = ZS.$$i(e.item),
                            e.lzi = t - e.delta;
                            let s = "right";
                            e.lzi < 0 && (e.lzi = 0,
                            s = "left"),
                            e.lzi = ZS.z$i(e.item, e.lzi, s),
                            $S.ub(e.azi) && $S.ub(e.lzi) && (o.push(e.azi),
                            a.push(e.lzi))
                        }
                        for (let i = 0; i < h.length; i++) {
                            const e = h[i];
                            t = ZS.$$i(QS),
                            e.azi = ZS.$$i(e.item),
                            e.lzi = t + e.delta;
                            let s = "left";
                            e.lzi >= ZS.T_t() && (e.lzi = ZS.T_t() - 1,
                            s = "right"),
                            e.lzi = ZS.z$i(e.item, e.lzi, s),
                            $S.ub(e.azi) && $S.ub(e.lzi) && (o.push(e.azi),
                            a.push(e.lzi))
                        }
                        $S.Qs.Fk.M$i.czi(o, a, e)
                    }
                }
                dx();
                break;
            case "draggable":
                YS && $S.Qs.Fk.M$i.e$i("drop", QS, t.clientX, t.clientY),
                dx()
            }
    }
    function cx(t, i) {
        XS && XS.parentNode.removeChild(XS),
        dx(),
        cancelAnimationFrame(ox),
        ox = -1
    }
    function dx() {
        tx && tx.hzi(),
        XS = null,
        ZS = null,
        tx = null,
        QS = null
    }
    $S.Qs.Fk.M$i = class extends $S.Qs.Fk.q4 {
        constructor(t, i, e, s, n, r) {
            $S.U(t, $S.Qs.Fk.Y6),
            $S.Ef(i, $S.Qs.d0),
            $S.p0(e),
            $S.iM(n),
            super(t, i, e, s, n, void 0, r = !!r),
            this.dzi = $S.Qs.W_("div", this.ght, null, "dropTargetDownArrow"),
            this.fzi = $S.Qs.W_("div", this.ght, null, "dropTargetUpArrow"),
            this.pzi = $S.Qs.W_("div", this.ght, null, "dropTargetBorder")
        }
        S0() {
            cancelAnimationFrame(ox),
            $S.Qs.UO(this.dzi),
            $S.Qs.UO(this.fzi),
            $S.Qs.UO(this.pzi),
            this.dzi = null,
            this.fzi = null,
            this.pzi = null,
            super.S0()
        }
        mO(t) {
            if (super.mO(t),
            t.button !== $S.gF.sV)
                return;
            if (!t.isPrimary)
                return;
            let i = this.g$i();
            i.W$i();
            let e = this.ght.cloneNode(!0);
            e.setAttribute("ghost", ""),
            e.setAttribute(i.b$i(), ""),
            e.style.visibility = "hidden",
            i._Tt() > 1 && (e.textContent = self.n_("ui.controls.icon-view.multi-select-drag-tooltip", null, i._Tt())),
            YS = !1,
            JS = !0;
            let s, n = $S.Sii(i.dD(), "dialog");
            s = n || this.ght.ownerDocument.body,
            s.appendChild(e),
            ex = s.offsetLeft,
            sx = s.offsetTop,
            nx = $S.Qs.Fk.M$i.mzi(s),
            ix = e.getBoundingClientRect(),
            XS = e,
            tx = this,
            QS = this,
            ZS = i,
            cancelAnimationFrame(ox),
            ox = -1,
            rx = ZS.k_().clientWidth < ZS.k_().scrollWidth,
            hx = ZS.k_().clientHeight < ZS.k_().scrollHeight,
            WS = t.clientX,
            HS = t.clientY,
            KS = t.clientX,
            qS = t.clientY,
            $S.Qs.Fk.M$i.nzi(WS, HS)
        }
        fG(t) {
            super.fG(t),
            t.isPrimary && this.wzi(t, "sortable")
        }
        dG(t) {
            super.dG(t),
            t.isPrimary && this.gzi(t, "sortable")
        }
        IN(t) {
            super.IN(t),
            this.yzi(t, "sortable")
        }
        wzi(t, i) {
            $S.zt(i),
            lx(t, i)
        }
        gzi(t, i) {
            $S.zt(i),
            ux(t, i)
        }
        yzi(t, i) {
            $S.zt(i),
            cx()
        }
        ezi(t, i) {
            if ($S.Ge(t),
            $S.Ge(i),
            !this.BTi)
                return !1;
            let e = this.BTi;
            return t >= e.left && i >= e.top && t < e.right && i < e.bottom
        }
        rzi(t, i) {
            if ($S.Ge(t),
            $S.Ge(i),
            !this.BTi)
                return "";
            let e = this.BTi;
            return t >= e.left && t <= e.left + e.width / 2 ? "left" : "right"
        }
        hzi() {
            let t = this.k_();
            t.removeAttribute("drop-target"),
            t.removeAttribute("hit-side")
        }
        static nzi(t, i) {
            if ($S.Ge(t),
            $S.Ge(i),
            XS) {
                let e = -ex + t - nx - ix.width / 2
                  , s = -sx + i - nx - ix.height / 2
                  , n = $S.Sii(XS, "dialog");
                if (n) {
                    let t = $S.Qs.Ks.rCi(n);
                    e -= t.ka(),
                    s -= t.Ra()
                }
                XS.style.transform = `translateX(${e}px) translateY(${s}px)`
            }
        }
        static mzi(t) {
            $S.ibt(t);
            let i = $S.Qs.pW(["border-width", "border-left-width", "border-right-width", "border-bottom-width", "border-top-width"], {
                wW: t
            });
            if (!i.endsWith("px"))
                throw new Error("CSS style for menu border-width must be in units of 'px'");
            return parseFloat(i) || 0
        }
        static e$i(t, i, e, s) {
            $S.zt(t);
            let n = new $S.Event(t);
            n.item = i,
            n.clientX = e,
            n.clientY = s,
            i.g$i().dispatchEvent(n)
        }
        static ozi(t, i, e) {
            $S.Ge(t),
            $S.Ge(i),
            $S.U(e, $S.Qs.Fk.q4);
            let s = new $S.Event("itemsorted");
            s.azi = t,
            s.lzi = i,
            s.item = e,
            e.g$i().dispatchEvent(s)
        }
        static czi(t, i, e) {
            $S.RH(t),
            $S.RH(i),
            $S.QH(e, $S.Qs.Fk.q4);
            let s = new $S.Event("itemssorted");
            s.bzi = t,
            s.vzi = i,
            s.items = e,
            e[0].g$i().dispatchEvent(s)
        }
        static Pit() {
            return !!XS
        }
        static h5() {
            if (XS)
                return QS
        }
        static f1() {
            XS && (QS ? QS.IN() : cx())
        }
    }
}
{
    const fx = self.t;
    fx.Qs.Fk.E$i = class extends fx.Qs.Fk.M$i {
        constructor(t, i, e, s, n, r) {
            fx.U(t, fx.Qs.Fk.Y6),
            fx.Ef(i, fx.Qs.d0),
            fx.p0(e),
            fx.iM(n),
            super(t, i, e, s, n, r = !!r),
            this.dzi.style.display = "none",
            this.fzi.style.display = "none",
            this.pzi.style.display = "none"
        }
        wzi(t, i) {
            fx.zt(i),
            super.wzi(t, "draggable")
        }
        gzi(t, i) {
            fx.zt(i),
            super.gzi(t, "draggable")
        }
        yzi(t, i) {
            fx.zt(i),
            super.yzi(t, "draggable")
        }
    }
}
{
    const px = self.t;
    px.Qs.Fk.q$i = class extends px.Me {
        constructor(t, i) {
            px.U(t, px.Qs.Fk.Y6),
            px.zt(i),
            super(),
            this.X6 = t,
            this.Ftt = i,
            this.cYt = px.Qs.W_("div", this.X6.k_(), null, "iconview-group"),
            this.fYt = px.Qs.W_("div", this.cYt, null, "iconview-grouptitle"),
            this.q1t = px.Qs.W_("span", this.fYt, null, "iconview-groupname"),
            this.Szi = px.Qs.W_("span", this.fYt, null, "iconview-grouprule"),
            this.xzi = px.Qs.W_("div", this.cYt, null, "iconview-groupcontent"),
            this.Mri = [],
            this.Mzi = 0,
            this.tzi = !1,
            this.q1t.textContent = this.Ftt
        }
        izi() {
            return this.xzi
        }
        S0(t) {
            px.Io(this.Mri),
            t || (px.Qs.UO(this.xzi),
            px.Qs.UO(this.Szi),
            px.Qs.UO(this.q1t),
            px.Qs.UO(this.fYt),
            px.Qs.UO(this.cYt)),
            this.xzi = null,
            this.Szi = null,
            this.q1t = null,
            this.fYt = null,
            this.cYt = null,
            this.X6 = null,
            px.he(this)
        }
        _A(t, i, e, s) {
            let n = this.X6._A(t, i, e, s, this);
            return this.Mri.push(n),
            n
        }
        szi(t, i) {
            px.U(t, px.Qs.Fk.q4),
            (i = !!i) ? this.Mzi++ : this.Mzi--,
            this.FWt(this.Mzi === this.Mri.length)
        }
        FWt(t) {
            t = !!t,
            this.tzi !== t && (this.tzi = t,
            px.Qs.eit(this.cYt, "hidden", this.tzi))
        }
        fae() {
            return this.tzi
        }
    }
}
{
    const mx = self.t
      , wx = {
        wrap: !0,
        flex: !0
    };
    mx.Qs.v2 = class extends mx.Event.v_ {
        constructor(t, i, e) {
            mx.ibt(t),
            mx.U(i, mx.Qs.Window),
            mx.ML(e),
            super(),
            e = Object.assign({}, wx, e),
            this.c8 = t,
            this.Ezi = i,
            this.Czi = [],
            this._zi = new Map,
            this.Tzi = !1,
            this.Izi = null,
            this.Pzi = [],
            this.oft = e,
            this.oft.flex && (this.c8.style.display = "flex"),
            this.Gft = t => this.eO(),
            this.vft = t => this.hO(),
            this.Tft = t => this.nO(),
            this.Ift = t => this.rO(),
            this.Ezi.addEventListener("beforepopupopen", this.Gft),
            this.Ezi.addEventListener("afterpopupopen", this.vft),
            this.Ezi.addEventListener("beforepopupclose", this.Tft),
            this.Ezi.addEventListener("afterpopupclose", this.Ift),
            this.vG()
        }
        he() {
            mx.Io(this.Pzi),
            this.Pzi = null,
            this.WO();
            for (let t = 0; t < this.Czi.length; t++)
                this.Czi[t].Gzi() && this.Czi[t].he();
            for (let t of this._zi)
                t.he();
            mx.Qs.UO(this.Izi),
            Array.prototype.forEach.call(this.c8.getElementsByTagName("ui-toolbar-remaining-space"), t => {
                mx.Qs.UO(t)
            }
            ),
            Array.prototype.forEach.call(this.c8.getElementsByTagName("ui-toolbar-container"), t => {
                mx.Qs.UO(t)
            }
            ),
            this.Ezi.removeEventListener("beforepopupopen", this.Gft),
            this.Gft = null,
            this.Ezi.removeEventListener("afterpopupopen", this.vft),
            this.vft = null,
            this.Ezi.removeEventListener("beforepopupclose", this.Tft),
            this.Tft = null,
            this.Ezi.removeEventListener("afterpopupclose", this.Ift),
            this.Ift = null,
            this.Ezi = null,
            this.c8.style.display = "",
            this.c8 = null,
            this.Czi = null,
            this.Izi = null,
            this._zi = null,
            super.he()
        }
        X0() {
            return this.Izi
        }
        tlt() {
            if (!this.c8)
                throw new Error("missing parent element");
            let t = this.c8.querySelector("ui-toolbar-container[level='0']");
            if (!t)
                throw new Error("missing root container element");
            return t
        }
        S2(t, i, e, s) {
            mx.zt(t),
            mx.Ge(i),
            mx.RH(e),
            s = Object.assign({}, this.oft, s);
            let n = mx.v(mx.Qs.Fk.Azi, this, this.c8, t, i, "horizontal", "required", s);
            return this.Czi.push(n),
            this.Tzi = !0,
            this.Rzi(n, e),
            n
        }
        kzi(t, i, e, s) {
            mx.zt(t),
            mx.Ge(i),
            mx.RH(e),
            s = Object.assign({}, this.oft, s);
            let n = mx.v(mx.Qs.Fk.Azi, this, this.c8, t, i, "vertical", "required", s);
            return this.Czi.push(n),
            this.Tzi = !0,
            this.Rzi(n, e),
            n
        }
        Ozi(t, i, e, s) {
            mx.zt(t),
            mx.Ge(i),
            mx.RH(e),
            s = Object.assign({}, this.oft, s);
            let n = mx.v(mx.Qs.Fk.Azi, this, this.c8, t, i, "horizontal", "optional", s);
            this._zi.set(t, n),
            this.Rzi(n, e)
        }
        Dzi(t, i, e) {
            mx.zt(t),
            mx.Ge(i),
            mx.RH(e);
            let s = mx.v(mx.Qs.Fk.Azi, this, this.c8, t, i, "vertical", "optional", this.oft);
            this._zi.set(t, s),
            this.Rzi(s, e)
        }
        Fzi(t) {
            mx.nu(t),
            this.Pzi.push(t)
        }
        Lzi() {
            return !!this.Pzi && (!!this.Pzi.length && this.Pzi.some(t => t()))
        }
        Bzi(t, i) {
            mx.zt(t),
            i = !!i;
            let e = this._zi.get(t);
            if (self.assert(e, "optional toolbar is not present in this toolbar layout"),
            i) {
                if (-1 !== this.Czi.indexOf(e))
                    return;
                this.Czi.push(e)
            } else {
                if (-1 === this.Czi.indexOf(e))
                    return;
                this.Czi.splice(this.Czi.indexOf(e), 1)
            }
            e.eP(i),
            this.Tzi = !0
        }
        Uzi(t) {
            t = !!t;
            for (let i of this._zi.keys())
                this.Bzi(i, t)
        }
        Nzi() {
            for (let t = 0; t < this.Czi.length; t++) {
                if (this.Czi[t].jzi())
                    return !0
            }
            return !1
        }
        $zi(t) {
            return mx.zt(t),
            !!this._zi.get(t)
        }
        zzi(t) {
            mx.zt(t);
            for (let i = 0; i < this.Czi.length; i++) {
                let e = this.Czi[i];
                e.Wxt() == t && e.Vzi()
            }
        }
        g_() {
            if (!this.Tzi)
                return;
            this.Tzi = !1;
            let t = 0
              , i = 0;
            this.Izi && (t = this.Izi.scrollLeft,
            i = this.Izi.scrollTop);
            let e = this.c8.querySelector("ui-toolbar-container[level='0']");
            e && e.parentNode.removeChild(e);
            let s = this.Czi.length
              , n = this.c8
              , r = this.c8.getBoundingClientRect();
            for (let t = 0; t < s; t++) {
                let i = this.Czi[t]
                  , e = i.k_()
                  , h = mx.Qs.W_("ui-toolbar-container", n);
                h.setAttribute("level", t.toString()),
                h.appendChild(e);
                let o, a = h.getBoundingClientRect();
                i.jTi() ? h.setAttribute("horizontal", "") : i.Wzi() && h.setAttribute("vertical", ""),
                i.Hzi() ? h.setAttribute("wrap", "") : i.BA() ? (h.style.setProperty("--parent-x-offset", `${Math.abs(r.left - a.left)}px`),
                h.style.setProperty("--parent-y-offset", `${Math.abs(r.top - a.top)}px`)) : (h.style.setProperty("--parent-x-offset", "0px"),
                h.style.setProperty("--parent-y-offset", "0px")),
                t == s - 1 ? this.Izi ? o = h.appendChild(this.Izi) : (o = mx.Qs.W_("ui-toolbar-layout-remaining-space", h),
                this.oft.wrap && o.setAttribute("wrap", "")) : o = mx.Qs.W_("ui-toolbar-remaining-space", h),
                n = o
            }
            for (let t = 0; t < s; t++)
                this.Czi[t].Mte();
            this.Izi = n,
            this.Izi.scrollLeft = t,
            this.Izi.scrollTop = i
        }
        Kzi() {
            if (!this.oft.wrap) {
                let t = this.c8.getBoundingClientRect()
                  , i = this.c8.querySelectorAll("ui-toolbar-container")
                  , e = i.length;
                for (let s = 0; s < e; s++) {
                    let e = i[s]
                      , n = e.getBoundingClientRect()
                      , r = (e.style,
                    Number(e.getAttribute("level")));
                    this.Czi[r].BA() ? (e.style.setProperty("--parent-x-offset", `${Math.abs(t.left - n.left)}px`),
                    e.style.setProperty("--parent-y-offset", `${Math.abs(t.top - n.top)}px`)) : (e.style.setProperty("--parent-x-offset", "0px"),
                    e.style.setProperty("--parent-y-offset", "0px"))
                }
            }
        }
        qd(t) {
            if (mx.Jvt(t))
                for (let i = 0; i < this.Czi.length; i++)
                    this.Czi[i].qd(t);
            else if (mx.K9(t)) {
                let i = this.qs(t);
                i && i.qd()
            } else
                for (let t = 0; t < this.Czi.length; t++)
                    this.Czi[t].qd()
        }
        qs(t) {
            mx.zt(t);
            for (let i = 0; i < this.Czi.length; i++)
                if (this.Czi[i].Wxt() === t)
                    return this.Czi[i]
        }
        k_(t) {
            mx.zt(t);
            for (let i = 0; i < this.Czi.length; i++) {
                let e = this.Czi[i].c2(t);
                if (e && e.Wxt() === t)
                    return e
            }
            throw new Error("id does not correspong to any toolbar element")
        }
        qzi(t) {
            mx.zt(t);
            let i = this.k_(t);
            return !!i && i.BA()
        }
        oM() {
            const t = {};
            for (const i of this.Czi) {
                t[i.Wxt()] = i.oM()
            }
            return t
        }
        uM(t) {
            if (t)
                for (const i of Object.keys(t)) {
                    const e = this.qs(i);
                    e && e.uM(t[i])
                }
        }
        vG() {
            for (const t of this.Czi)
                t.H$i()
        }
        WO() {
            for (const t of this.Czi)
                t.K$i()
        }
        eO() {
            this.WO()
        }
        hO() {
            this.vG()
        }
        nO() {
            this.WO()
        }
        rO() {
            this.vG()
        }
        static Xzi(t) {
            t.group = "",
            t.qot = function(i) {
                return mx.zt(i),
                t.group = i,
                t
            }
        }
        static Yzi(t) {
            t.options = {},
            t.B2 = function(i) {
                return mx.J1(i),
                t.options = i,
                t
            }
        }
        static C2(t, i, e, s, n) {
            mx.zt(t),
            mx.U(i, mx.Qs.d0),
            mx.gL(e);
            let r = {
                type: "click",
                id: t,
                icon: i,
                VP: e,
                Jzi: s,
                disable: n = !!n
            };
            return this.Xzi(r),
            this.Yzi(r),
            r
        }
        static Qot(t, i, e, s, n) {
            mx.zt(t),
            mx.U(i, mx.Qs.d0),
            mx.gL(e);
            let r = {
                type: "check",
                id: t,
                icon: i,
                VP: e,
                Zzi: s,
                disable: n = !!n
            };
            return this.Xzi(r),
            this.Yzi(r),
            r
        }
        static Qzi(t, i, e, s, n, r) {
            mx.zt(t),
            mx.U(i, mx.Qs.d0),
            mx.U(e, mx.Qs.d0),
            mx.gL(s);
            let h = {
                type: "switch",
                id: t,
                tVi: i,
                iVi: e,
                VP: s,
                Zzi: n,
                disable: r = !!r
            };
            return this.Xzi(h),
            this.Yzi(h),
            h
        }
        static Kot(t, i, e, s, n) {
            mx.zt(t),
            mx.U(i, mx.Qs.d0),
            mx.gL(e);
            let r = {
                type: "radio",
                id: t,
                icon: i,
                VP: e,
                Zzi: s,
                disable: n = !!n
            };
            return this.Xzi(r),
            this.Yzi(r),
            r
        }
        static Zyt(t, i, e, s, n, r, h) {
            mx.zt(t),
            mx.U(i, mx.Qs.d0),
            mx.gL(e),
            mx.gL(s);
            let o = {
                type: "split",
                id: t,
                icon: i,
                eVi: e,
                sVi: s,
                nVi: n,
                rVi: r,
                disable: h = !!h
            };
            return this.Xzi(o),
            this.Yzi(o),
            o
        }
        static hVi(t, i, e, s, n, r, h) {
            mx.zt(t),
            mx.U(i, mx.Qs.d0),
            mx.gL(e),
            mx.gL(s);
            let o = {
                type: "splitcheck",
                id: t,
                icon: i,
                eVi: e,
                sVi: s,
                nVi: n,
                rVi: r,
                disable: h = !!h
            };
            return this.Xzi(o),
            this.Yzi(o),
            o
        }
        static Zot(t, i, e, s, n, r, h) {
            mx.zt(t),
            mx.U(i, mx.Qs.d0),
            mx.gL(e),
            mx.gL(s);
            let o = {
                type: "splitradio",
                id: t,
                icon: i,
                eVi: e,
                sVi: s,
                nVi: n,
                rVi: r,
                disable: h = !!h
            };
            return this.Xzi(o),
            this.Yzi(o),
            o
        }
        static YA(t, i, e) {
            mx.gL(i);
            let s = {
                id: i,
                type: "separator",
                hidden: t = !!t,
                disable: e = !!e
            };
            return this.Xzi(s),
            this.Yzi(s),
            s
        }
        static oVi(t, i, e, s, n, r, h, o, a) {
            mx.zt(t),
            mx.Ge(i),
            mx.Ge(e),
            mx.iM(s),
            mx.iM(n),
            mx.gL(r);
            let l = {
                type: "slider",
                id: t,
                min: i,
                max: e,
                step: s,
                value: n,
                label: r,
                aVi: h,
                disable: o = !!o,
                lVi: a = !!a
            };
            return this.Xzi(l),
            this.Yzi(l),
            l
        }
        static uVi(t, i, e, s, n, r, h) {
            mx.zt(t),
            mx.RH(i),
            mx.iM(e),
            mx.gL(s);
            let o = {
                type: "stepslider",
                id: t,
                cVi: i,
                value: e,
                label: s,
                aVi: n,
                disable: r = !!r,
                lVi: h = !!h
            };
            return this.Xzi(o),
            this.Yzi(o),
            o
        }
        static dVi(t, i, e) {
            mx.zt(t);
            let s = {
                type: "color",
                id: t,
                fVi: i,
                disable: e = !!e
            };
            return this.Xzi(s),
            this.Yzi(s),
            s
        }
        static pVi(t, i, e, s, n) {
            mx.zt(t),
            mx.gL(i);
            let r = {
                type: "checkbox",
                id: t,
                label: i,
                Zzi: e,
                disable: s = !!s,
                lVi: n = !!n
            };
            return this.Xzi(r),
            this.Yzi(r),
            r
        }
        static Kyt(t, i, e, s, n, r, h, o, a, l) {
            mx.zt(t),
            mx.iM(i),
            mx.iM(e),
            mx.iM(s),
            mx.iM(n),
            mx.gL(r),
            mx.gL(h);
            let u = {
                type: "spinner",
                id: t,
                min: i,
                max: e,
                step: s,
                value: n,
                label: r,
                VP: h,
                mVi: o,
                disable: a = !!a,
                lVi: l = !!l
            };
            return this.Xzi(u),
            this.Yzi(u),
            u
        }
        static R2(t, i, e, s, n, r) {
            mx.zt(t),
            mx.tot(s),
            mx.gL(i);
            let h = {
                type: "textbox",
                value: i,
                label: e,
                id: t,
                fVi: s,
                disable: n = !!n,
                lVi: r
            };
            return this.Xzi(h),
            this.Yzi(h),
            h
        }
        static O2(t, i, e, s, n, r) {
            mx.zt(t),
            mx.tot(s),
            mx.D_t(i);
            let h = {
                type: "dropdown",
                id: t,
                values: i,
                label: e,
                fVi: s,
                disable: n = !!n,
                lVi: r
            };
            return this.Xzi(h),
            this.Yzi(h),
            h
        }
        static $yt(t, i, e, s, n, r) {
            mx.zt(t),
            mx.tot(s),
            mx.D_t(i);
            let h = {
                type: "editable-dropdown",
                id: t,
                values: i,
                label: e,
                fVi: s,
                disable: n = !!n,
                lVi: r
            };
            return this.Xzi(h),
            this.Yzi(h),
            h
        }
        static P2() {
            return this.vwe(26)
        }
        static _2() {
            return this.vwe(35)
        }
        static wVi() {
            return this.vwe(45)
        }
        static vwe(t) {
            return mx.Ge(t),
            Math.round(mx.Qs.vwe() * (t / 13))
        }
        static gVi(t, i) {
            mx.ibt(t),
            mx.U(i, mx.Qs.v2);
            for (let e = 0; e < i.Czi.length; e++)
                for (const s of i.Czi[e].elements())
                    if (mx.TP(t, s))
                        return !0;
            return !1
        }
        Rzi(t, i) {
            for (let e = 0; e < i.length; e++) {
                let s = i[e];
                switch (s.type) {
                case "click":
                    t.C2(s.id, s.icon, s.VP, s.Jzi, s.options, s.disable, s.group);
                    break;
                case "check":
                    t.Qot(s.id, s.icon, s.VP, s.Zzi, s.options, s.disable, s.group);
                    break;
                case "switch":
                    t.Qzi(s.id, s.tVi, s.iVi, s.VP, s.Zzi, s.options, s.disable, s.group);
                    break;
                case "radio":
                    t.Kot(s.id, s.icon, s.VP, s.Zzi, s.options, s.disable, s.group);
                    break;
                case "split":
                    t.Zyt(s.id, s.icon, s.eVi, s.sVi, s.nVi, s.rVi, s.disable, s.group);
                    break;
                case "splitcheck":
                    t.hVi(s.id, s.icon, s.eVi, s.sVi, s.nVi, s.rVi, s.disable, s.group);
                    break;
                case "splitradio":
                    t.Zot(s.id, s.icon, s.eVi, s.sVi, s.nVi, s.rVi, s.disable, s.group);
                    break;
                case "separator":
                    t.YA(s.hidden, s.id, s.disable, s.group);
                    break;
                case "slider":
                    t.oVi(s.id, s.min, s.max, s.step, s.value, s.label, s.aVi, s.disable, s.lVi, s.group);
                    break;
                case "stepslider":
                    t.uVi(s.id, s.cVi, s.value, s.label, s.aVi, s.disable, s.lVi, s.group);
                    break;
                case "color":
                    t.dVi(s.id, s.fVi, s.disable, s.group);
                    break;
                case "checkbox":
                    t.pVi(s.id, s.label, s.Zzi, s.disable, s.lVi, s.group);
                    break;
                case "textbox":
                    t.yVi(s.id, s.value, s.label, s.fVi, s.disable, s.lVi, s.group, s.options);
                    break;
                case "dropdown":
                    t.O2(s.id, s.values, s.label, s.fVi, s.options, s.disable, s.lVi, s.group);
                    break;
                case "editable-dropdown":
                    t.$yt(s.id, s.values, s.label, s.fVi, s.options, s.disable, s.lVi, s.group);
                    break;
                case "spinner":
                    t.Kyt(s.id, s.min, s.max, s.step, s.value, s.label, s.VP, s.mVi, s.disable, s.lVi, s.group)
                }
            }
        }
    }
}
{
    const gx = self.t
      , yx = self.assert
      , bx = new Set(["horizontal", "vertical"])
      , vx = new Set(["required", "optional"]);
    gx.Qs.Fk.Azi = class extends gx.Me {
        constructor(t, i, e, s, n, r, h) {
            if (gx.U(t, gx.Qs.v2),
            gx.ibt(i),
            gx.zt(e),
            gx.Ge(s),
            gx.zt(n),
            gx.zt(r),
            gx.J1(h),
            super(),
            !bx.has(n))
                throw new Error(`invalid toolbar layout '${n}'`);
            if (!vx.has(r))
                throw new Error(`invalid toolbar type '${r}'`);
            this.oft = h,
            this.bVi = t,
            this.vVi = i,
            this.$c = s,
            this.Rdi = e,
            this.kTi = "horizontal" === n,
            this.aGt = r,
            this.JPi = !0,
            this.SVi = !0,
            this.xVi = !!h.wrap,
            this.MVi = [],
            this.ght = gx.Qs.W_("ui-toolbar"),
            this.ght.setAttribute("role", "toolbar"),
            this.ght.setAttribute(n, ""),
            this.EVi = null,
            this.CVi = !1,
            this.xVi ? this.ght.setAttribute("wrap", "") : (this.EVi = t => this.Z_(t),
            this.ght.addEventListener("scroll", this.EVi)),
            this.eP(!1),
            this.wPt = 0,
            this.mPt = 0
        }
        he() {
            this.ght.removeEventListener("scroll", this.EVi),
            this.EVi = null;
            for (let t = 0; t < this.MVi.length; t++)
                this.MVi[t].he();
            gx.Qs.UO(this.ght),
            this.ght = null,
            this.vVi = null,
            this.MVi = null,
            gx.he(this)
        }
        eP(t, i) {
            if (t = !!t,
            i = !!i,
            this.jzi() || i) {
                if (t) {
                    if (this.JPi)
                        return;
                    this.ght.style.display = ""
                } else {
                    if (!this.JPi)
                        return;
                    this.ght.style.display = "none"
                }
                this.JPi = t
            }
        }
        _Vi(t) {
            t = !!t;
            for (let i = 0; i < this.MVi.length; i++)
                this.MVi[i].eP(t)
        }
        BA() {
            return this.JPi
        }
        zo() {
            return this.$c
        }
        TVi() {
            this.wPt = this.ght.scrollLeft,
            this.mPt = this.ght.scrollTop
        }
        Mte() {
            this.ght.scrollLeft = this.wPt,
            this.ght.scrollTop = this.mPt
        }
        Wxt() {
            return this.Rdi
        }
        k_() {
            return this.ght
        }
        X0() {
            let t = this.ght.nextSibling;
            for (; t; ) {
                if ("UI-TOOLBAR-REMAINING-SPACE" === t.tagName)
                    return t;
                if ("UI-TOOLBAR-LAYOUT-REMAINING-SPACE" === t.tagName)
                    return t;
                t = t.nextSibling
            }
        }
        IVi() {
            return this.bVi
        }
        Wrt() {
            return this.oft
        }
        Gzi() {
            return "required" === this.aGt
        }
        jzi() {
            return "optional" === this.aGt
        }
        jTi() {
            return this.kTi
        }
        Wzi() {
            return !this.kTi
        }
        Hzi() {
            return this.xVi
        }
        gwe() {
            this.ght.setAttribute("transparent", "")
        }
        C2(t, i, e, s, n, r, h) {
            gx.zt(t),
            gx.U(i, gx.Qs.d0),
            gx.gL(e),
            gx.tot(s),
            gx.zt(h);
            let o = gx.v(gx.Qs.Fk.Azi.jr, this, t, i, e, "click", s, n);
            o.I2(!r),
            o.qot(h),
            this.MVi.push(o)
        }
        Qot(t, i, e, s, n, r, h) {
            gx.zt(t),
            gx.U(i, gx.Qs.d0),
            gx.gL(e),
            gx.tot(s),
            gx.zt(h);
            let o = gx.v(gx.Qs.Fk.Azi.jr, this, t, i, e, "check", s, n);
            o.I2(!r),
            o.qot(h),
            this.MVi.push(o)
        }
        Qzi(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.U(i, gx.Qs.d0),
            gx.U(e, gx.Qs.d0),
            gx.gL(s),
            gx.tot(n),
            gx.zt(o);
            let a = gx.v(gx.Qs.Fk.Azi.PVi, this, t, i, e, s, "check", n, r);
            a.I2(!h),
            a.qot(o),
            this.MVi.push(a)
        }
        Kot(t, i, e, s, n, r, h) {
            gx.zt(t),
            gx.U(i, gx.Qs.d0),
            gx.gL(e),
            gx.tot(s),
            gx.zt(h);
            let o = gx.v(gx.Qs.Fk.Azi.jr, this, t, i, e, "radio", s, n);
            o.I2(!r),
            o.qot(h),
            this.MVi.push(o)
        }
        Zyt(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.U(i, gx.Qs.d0),
            gx.gL(e),
            gx.gL(s),
            gx.tot(n),
            gx.tot(r),
            gx.zt(o);
            let a = gx.v(gx.Qs.Fk.Azi.GVi, this, t, i, e, s, n, r);
            a.I2(!h),
            a.qot(o),
            a.ndt("click"),
            this.MVi.push(a)
        }
        hVi(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.U(i, gx.Qs.d0),
            gx.gL(e),
            gx.gL(s),
            gx.tot(n),
            gx.tot(r),
            gx.zt(o);
            let a = gx.v(gx.Qs.Fk.Azi.GVi, this, t, i, e, s, n, r);
            a.I2(!h),
            a.qot(o),
            a.ndt("check"),
            this.MVi.push(a)
        }
        Zot(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.U(i, gx.Qs.d0),
            gx.gL(e),
            gx.gL(s),
            gx.tot(n),
            gx.tot(r),
            gx.zt(o);
            let a = gx.v(gx.Qs.Fk.Azi.GVi, this, t, i, e, s, n, r);
            a.I2(!h),
            a.qot(o),
            a.ndt("radio"),
            this.MVi.push(a)
        }
        YA(t, i, e, s) {
            gx.gL(i),
            gx.zt(s),
            t = !!t;
            let n = gx.v(gx.Qs.Fk.Azi.AVi, this, t, i);
            n.I2(!e),
            n.qot(s),
            this.MVi.push(n)
        }
        oVi(t, i, e, s, n, r, h, o, a, l) {
            gx.zt(t),
            gx.Ge(i),
            gx.Ge(e),
            gx.iM(s),
            gx.iM(n),
            gx.gL(r),
            gx.tot(h),
            gx.zt(l),
            a = !!a;
            let u = gx.v(gx.Qs.Fk.Azi.RVi, this, t, i, e, s, n, r, h, a);
            u.I2(!o),
            u.qot(l),
            this.MVi.push(u)
        }
        uVi(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.RH(i),
            gx.iM(e),
            gx.gL(s),
            gx.tot(n),
            gx.zt(o),
            h = !!h;
            let a = gx.v(gx.Qs.Fk.Azi.kVi, this, t, i, e, s, n, h);
            a.I2(!r),
            a.qot(o),
            this.MVi.push(a)
        }
        dVi(t, i, e, s) {
            gx.zt(t),
            gx.tot(i),
            gx.zt(s);
            let n = gx.v(gx.Qs.Fk.Azi.OVi, this, t, i);
            n.I2(!e),
            n.qot(s),
            this.MVi.push(n)
        }
        pVi(t, i, e, s, n, r) {
            gx.zt(t),
            gx.gL(i),
            gx.tot(e),
            gx.zt(r),
            n = !!n;
            let h = gx.v(gx.Qs.Fk.Azi.DVi, this, t, i, e, n);
            h.I2(!s),
            h.qot(r),
            this.MVi.push(h)
        }
        Kyt(t, i, e, s, n, r, h, o, a, l, u) {
            gx.zt(t),
            gx.iM(i),
            gx.iM(e),
            gx.iM(s),
            gx.iM(n),
            gx.gL(r),
            gx.gL(h),
            gx.tot(o),
            gx.zt(u),
            l = !!l;
            let c = gx.v(gx.Qs.Fk.Azi.FVi, this, t, i, e, s, n, r, h, o, l);
            c.I2(!a),
            c.qot(u),
            this.MVi.push(c)
        }
        yVi(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.tot(s),
            gx.gL(i),
            gx.zt(h);
            let a = gx.v(gx.Qs.Fk.Azi.LVi, this, t, i, e, s, r, o);
            a.I2(!n),
            a.qot(h),
            this.MVi.push(a)
        }
        O2(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.tot(s),
            gx.D_t(i),
            gx.zt(o);
            let a = gx.v(gx.Qs.Fk.Azi.BVi, this, t, i, e, s, n, h);
            a.I2(!r),
            a.qot(o),
            this.MVi.push(a)
        }
        $yt(t, i, e, s, n, r, h, o) {
            gx.zt(t),
            gx.tot(s),
            gx.D_t(i),
            gx.zt(o);
            let a = gx.v(gx.Qs.Fk.Azi.UVi, this, t, i, e, s, n, h);
            a.I2(!r),
            a.qot(o),
            this.MVi.push(a)
        }
        qd(t) {
            if (gx.Jvt(t)) {
                gx.zt(t["element-group"]),
                "no-group" === t["element-group"] && (t["element-group"] = "");
                for (let i = 0; i < this.MVi.length; i++) {
                    let e = this.MVi[i];
                    e.NVi() === t["element-group"] && e.qd()
                }
            } else if (gx.K9(t))
                this.jVi(t);
            else
                for (let t = 0; t < this.MVi.length; t++)
                    this.MVi[t].qd()
        }
        Vzi() {
            for (let t = 0; t < this.MVi.length; t++)
                this.MVi[t].Vzi()
        }
        I2(t) {
            (t = !!t) !== this.SVi && (t ? this.ght.removeAttribute("disable") : this.ght.setAttribute("disable", ""),
            this.SVi = t)
        }
        qk() {
            return this.SVi
        }
        jVi(t) {
            gx.zt(t);
            let i = this.c2(t);
            i && i.qd()
        }
        yut(t, i) {
            gx.zt(t),
            i = !!i;
            let e = this.c2(t);
            yx(e, "element is not part of toolbar"),
            e.I2(i)
        }
        Ilt(t, i) {
            gx.zt(t);
            let e = this.c2(t);
            yx(e, "element is not part of toolbar"),
            e.$Vi(i)
        }
        c2(t) {
            gx.zt(t);
            for (let i = 0; i < this.MVi.length; i++)
                if (this.MVi[i].Wxt() === t)
                    return this.MVi[i]
        }
        *elements() {
            for (let t = 0; t < this.MVi.length; t++)
                yield this.MVi[t].k_()
        }
        olt(t, ...i) {
            gx.zt(t);
            let e = this.c2(t);
            e && e.e_t(...i)
        }
        zVi() {
            return this.CVi
        }
        oM() {
            return {
                scrollLeft: this.wPt,
                scrollTop: this.mPt
            }
        }
        uM(t) {
            t && (this.wPt = t.scrollLeft,
            this.mPt = t.scrollTop,
            this.ght.scrollLeft = this.wPt,
            this.ght.scrollTop = this.mPt)
        }
        H$i() {
            for (let t = 0; t < this.MVi.length; t++)
                this.MVi[t].H$i()
        }
        K$i() {
            for (let t = 0; t < this.MVi.length; t++)
                this.MVi[t].K$i()
        }
        VVi() {
            this.CVi = !1
        }
        Z_(t) {
            this.TVi(),
            this.CVi = !0
        }
    }
}
{
    const Sx = self.t;
    Sx.Qs.Fk.Azi.Element = class extends Sx.Me {
        constructor(t, i, e) {
            Sx.U(t, Sx.Qs.Fk.Azi),
            Sx.gL(i),
            Sx.tot(e),
            super(),
            this.WVi = t,
            this.Rdi = i,
            this.ght = null,
            this.HVi = e,
            this.KVi = !0,
            this.Xhi = !0,
            this.Q$i = ""
        }
        k_() {
            return this.ght
        }
        Wxt() {
            return this.Rdi
        }
        FO() {
            return this.ght.ownerDocument || document
        }
        qVi() {
            this.WVi.Wrt().wrap && this.ght.setAttribute("wrap", "")
        }
        eP(t) {
            t = !!t,
            this.KVi !== t && (this.ght.style.display = t ? "" : "none",
            this.KVi = t)
        }
        BA() {
            return this.KVi
        }
        I2(t) {
            t = !!t,
            this.Xhi !== t && (t ? this.ght.removeAttribute("disable") : this.ght.setAttribute("disable", ""),
            this.Xhi = t)
        }
        qk() {
            return this.Xhi
        }
        $Vi(t) {}
        qot(t) {
            Sx.zt(t),
            this.Q$i = t
        }
        NVi() {
            return this.Q$i
        }
        xwe(t) {
            Sx.zt(t),
            this.ght.setAttribute("title", t)
        }
        XVi(...t) {
            this.HVi && this.HVi(...t)
        }
        he() {
            Sx.Qs.UO(this.ght),
            this.ght = null,
            this.WVi = null,
            this.HVi = null
        }
        PF() {
            Sx.kK()
        }
        qd() {
            Sx.kK()
        }
        Vzi() {
            Sx.kK()
        }
        e_t() {
            Sx.kK()
        }
        H$i() {}
        K$i() {}
        YVi(t, i) {
            for (var e in Sx.J1(t),
            Sx.RH(i),
            t)
                t.hasOwnProperty(e) && self.assert(i.includes(e), `'${e}' is not a supported update property. Supported update properties for this control are '${i.toString()}'`)
        }
    }
}
{
    const xx = self.t
      , Mx = ["color"];
    xx.Qs.Fk.Azi.OVi = class extends xx.Qs.Fk.Azi.Element {
        constructor(t, i, e) {
            super(t, i, e),
            this.JVi = t => this.eLi(t),
            this.ght = xx.Qs.W_("ui-toolbar-color-picker", this.WVi.k_()),
            this.ZVi = xx.Qs.W_("input", this.ght, null, null, {
                type: "color"
            }),
            this.ZVi.addEventListener("change", this.JVi),
            this.LGt = xx.Qs.W_("span", this.ght),
            this.LGt.innerHTML = this.ZVi.value,
            this.qVi()
        }
        he() {
            this.ZVi.removeEventListener("change", this.JVi),
            xx.Qs.UO(this.ZVi),
            xx.Qs.UO(this.LGt),
            this.JVi = null,
            this.ZVi = null,
            this.LGt = null,
            super.he()
        }
        PF(t) {
            xx.J1(t),
            this.YVi(t, Mx),
            t.hasOwnProperty("color") && xx.K9(t.color) && (this.ZVi.value = t.color)
        }
        qd() {}
        Vzi() {
            this.QVi()
        }
        e_t() {
            this.qk()
        }
        eLi(t) {
            this.LGt.innerHTML = this.ZVi.value,
            this.QVi()
        }
        QVi() {
            let t = new xx.Event("colorchange");
            t.tWi = this.WVi.Wxt(),
            t.iWi = this.Rdi.toLowerCase(),
            t.color = this.ZVi.value,
            this.WVi.IVi().dispatchEvent(t),
            this.XVi(this.ZVi.value)
        }
    }
}
{
    const Ex = self.t
      , Cx = ["min", "max", "step", "value", "label"];
    Ex.Qs.Fk.Azi.RVi = class extends Ex.Qs.Fk.Azi.Element {
        constructor(t, i, e, s, n, r, h, o, a) {
            Ex.Ge(e),
            Ex.Ge(s),
            Ex.Ge(n),
            Ex.iM(r),
            Ex.gL(h),
            super(t, i, o),
            this.eWi = e,
            this.sWi = s,
            this.nWi = n || 1,
            this.$fi = r || 0,
            this.rWi = this.$fi,
            this.ght = Ex.Qs.W_("ui-toolbar-slider", this.WVi.k_()),
            this.ZVi = Ex.Qs.W_("input", this.ght, null, null, {
                type: "range",
                min: e.toString(),
                max: s.toString(),
                step: this.nWi.toString(),
                value: this.$fi.toString()
            }),
            this.hWi = Ex.Qs.W_("input", this.ght, null, null, {
                type: "number",
                min: e.toString(),
                max: s.toString(),
                step: this.nWi.toString(),
                value: this.ZVi.value.toString()
            }),
            this.LGt = Ex.Qs.W_("span"),
            a ? (this.LGt.setAttribute("side", "right"),
            this.ght.appendChild(this.LGt)) : (this.LGt.setAttribute("side", "left"),
            this.ght.insertBefore(this.LGt, this.ZVi)),
            this.LGt.textContent = h || i.charAt(0).toUpperCase() + i.slice(1),
            this.kf = null,
            this.oWi = null,
            this.aWi(),
            this.lWi(),
            this.qVi()
        }
        he() {
            Ex.Qs.UO(this.ZVi),
            Ex.Qs.UO(this.LGt),
            Ex.Qs.UO(this.hWi),
            this.kf && (this.kf.Ff(),
            this.kf = null),
            this.oWi && (this.oWi.Ff(),
            this.oWi = null),
            this.ZVi = null,
            this.LGt = null,
            this.hWi = null,
            super.he()
        }
        PF(t) {
            if (Ex.J1(t),
            this.YVi(t, Cx),
            t.hasOwnProperty("min") && Ex.ub(t.min) && (this.eWi = t.min,
            this.ZVi.min = this.eWi.toString(),
            this.hWi.min = this.eWi.toString()),
            t.hasOwnProperty("max") && Ex.ub(t.max) && (this.sWi = t.max,
            this.ZVi.max = this.sWi.toString(),
            this.hWi.max = this.eWi.toString()),
            t.hasOwnProperty("step") && Ex.ub(t.step) && (this.nWi = t.step,
            this.ZVi.step = t.step.toString(),
            this.hWi.step = t.step.toString()),
            t.hasOwnProperty("value") && Ex.ub(t.value)) {
                let i = t.value.toString();
                this.ZVi.value = i,
                this.hWi.value = i
            }
            t.hasOwnProperty("label") && Ex.K9(t.label) && (this.ZVi.label = t.label)
        }
        qd() {}
        Vzi() {
            this.uWi("sliderchange")
        }
        e_t() {
            this.qk()
        }
        aWi() {
            this.kf = Ex.v(Ex.Rf, Ex._f.Gf(this.ZVi, "input change", t => this.cWi(t)), Ex._f.Gf(this.hWi, "keypress", t => this.dWi(t)), Ex._f.Gf(this.hWi, "change input", t => this.fWi(t)), Ex._f.Gf(this.hWi, "blur", t => this.xft()))
        }
        lWi() {
            this.oWi = Ex.cwi(this.hWi)
        }
        cWi(t) {
            this.hWi.value = this.ZVi.value,
            this.rWi = Number(this.ZVi.value),
            "change" === t.type && this.uWi("sliderchange"),
            "input" === t.type && this.uWi("sliderinput")
        }
        dWi(t) {
            t.key.match(/[0-9.e\-]/) || t.preventDefault()
        }
        fWi(t) {
            let i = this.hWi.value;
            if (i.length && (i = Number(i),
            !isNaN(i))) {
                let t = this.pWi()
                  , e = this.mWi();
                if ((i > e || i < t) && (i = Ex.Ne(i, t, e),
                this.hWi.value = i),
                this.ZVi.value === i.toString())
                    return;
                this.ZVi.value = i,
                this.rWi = i,
                this.uWi("sliderinput")
            }
        }
        xft() {
            let t = this.hWi.value;
            if (t = Number(t),
            isNaN(t))
                this.hWi.value = this.rWi;
            else {
                let i = this.pWi()
                  , e = this.mWi();
                if (t = Ex.Ne(t, i, e),
                t /= this.nWi,
                t = Math.round(t) * this.nWi,
                this.hWi.value === t.toString())
                    return;
                this.hWi.value = t,
                this.ZVi.value = t,
                this.rWi = t,
                this.uWi("sliderinput")
            }
        }
        wWi(t) {
            this.eWi = t,
            this.hWi.setAttribute("min", t)
        }
        pWi() {
            return this.eWi
        }
        gWi(t) {
            this.sWi = t,
            this.hWi.setAttribute("max", t)
        }
        mWi() {
            return this.sWi
        }
        uWi(t) {
            Ex.zt(t);
            let i = new Ex.Event(t);
            i.tWi = this.WVi.Wxt(),
            i.yWi = this.Rdi.toLowerCase(),
            i.bWi = NaN;
            let e = Number(this.ZVi.value);
            Ex.ub(e) ? i.bWi = Ex.Ne(e, this.eWi, this.sWi) : i.bWi = this.eWi,
            this.WVi.IVi().dispatchEvent(i),
            this.XVi(i.bWi)
        }
    }
}
{
    const _x = self.t
      , Tx = self.assert
      , Ix = ["steps", "percentage", "value", "label"]
      , Px = ["linear", "logarithmic"];
    _x.Qs.Fk.Azi.kVi = class extends _x.Qs.Fk.Azi.RVi {
        constructor(t, i, e, s, n, r, h) {
            _x.RH(e),
            super(t, i, 0, 100, 1, _x.Ne(s, 0, 100), n, r, h),
            this.vWi = [],
            this.SWi(e),
            this.wWi(this.vWi[0].xWi),
            this.gWi(this.vWi.at(-1).MWi),
            this.ZVi.value = _x.Ne(s, 0, 100).toString(),
            this.hWi.value = this.EWi()
        }
        he() {
            _x.Io(this.vWi),
            this.vWi = null,
            super.he()
        }
        PF(t) {
            if (_x.J1(t),
            this.YVi(t, Ix),
            t.hasOwnProperty("steps") && _x.B9(t.steps) && (this.SWi(t.steps),
            this.wWi(this.vWi[0].xWi),
            this.gWi(this.vWi.at(-1).MWi),
            this.hWi.value = this.EWi()),
            t.hasOwnProperty("percentage") && _x.ub(t.percentage)) {
                let i = Math.floor(t.percentage);
                this.ZVi.value = _x.Ne(i, 0, 100).toString(),
                this.hWi.value = this.EWi()
            }
            if (t.hasOwnProperty("value") && _x.ub(t.value)) {
                let i = Math.floor(t.value);
                this.hWi.value = _x.Ne(i, this.vWi[0].xWi, this.vWi.at(-1).MWi).toString(),
                this.ZVi.value = this.CWi()
            }
            t.hasOwnProperty("label") && _x.K9(t.label) && (this.ZVi.label = t.label)
        }
        qd() {}
        Vzi() {
            this.uWi("sliderchange")
        }
        e_t() {
            this.qk()
        }
        aWi() {
            this.kf = _x.v(_x.Rf, _x._f.Gf(this.ZVi, "input change", t => this.cWi(t)), _x._f.Gf(this.hWi, "keypress", t => this.dWi(t)), _x._f.Gf(this.hWi, "change input", t => this.fWi(t)))
        }
        SWi(t) {
            _x.RH(t),
            Tx(t.length, "no steps defined for the step slider"),
            _x.Io(this.vWi);
            let i = 0;
            for (var e = 0; e < t.length; e++) {
                let s = t[e];
                if (_x.J1(s),
                _x.Ge(s._Wi),
                _x.Ge(s.max),
                _x.iM(s.min),
                _x.zt(s.scale),
                Tx(s._Wi <= 100, "percentage slice of a step can not be larger than 100%"),
                Tx(s._Wi > 0, "percentage slice of a step can not be lower than 0%"),
                Tx(Px.includes(s.scale), `unexpected scale value '${s.scale}' for step. Valid values are '${Px}'`),
                e > 0 && _x.ub(s.min) && (() => {})("only the first step of a step slider needs to define a minimum value"),
                "logarithmic" === s.scale && Tx(0 !== s.max, "maximum value must be different of 0 when using a logarithmic scale"),
                0 === e) {
                    switch (s.scale) {
                    case "linear":
                        this.vWi.push({
                            TWi: 0,
                            IWi: s._Wi,
                            xWi: s.min || 0,
                            MWi: s.max,
                            scale: s.scale
                        });
                        break;
                    case "logarithmic":
                        this.vWi.push({
                            TWi: 0,
                            IWi: s._Wi,
                            xWi: s.min || 1,
                            MWi: s.max,
                            scale: s.scale
                        })
                    }
                    i += s._Wi
                } else {
                    let n = t[e - 1];
                    this.vWi.push({
                        TWi: n._Wi,
                        IWi: s._Wi,
                        xWi: n.max,
                        MWi: s.max,
                        scale: s.scale
                    }),
                    i += s._Wi - n._Wi
                }
            }
            Tx(100 === i, "steps can not add up to more than 100%")
        }
        cWi(t) {
            let i = this.EWi();
            this.hWi.value = i,
            this.rWi = Number(this.ZVi.value),
            "change" === t.type && this.uWi("sliderchange"),
            "input" === t.type && this.uWi("sliderinput")
        }
        dWi(t) {
            t.key.match(/[0-9.e\-]/) || t.preventDefault()
        }
        fWi(t) {
            let i = this.hWi.value
              , e = this.pWi()
              , s = this.mWi();
            (i > s || i < e) && (i = _x.Ne(i, e, s),
            this.hWi.value = i);
            let n = this.CWi();
            _x.ub(n) && (n = _x.Ne(n, 0, 100),
            this.ZVi.value = n,
            this.rWi = n,
            this.PWi("sliderinput"))
        }
        uWi(t) {
            _x.zt(t);
            let i = this.EWi();
            this.qOi(t, i)
        }
        PWi(t) {
            _x.zt(t);
            let i = this.pWi()
              , e = this.mWi()
              , s = Number(this.hWi.value);
            (s > e || s < i) && (s = _x.Ne(s, i, e)),
            this.qOi(t, s)
        }
        qOi(t, i) {
            _x.zt(t),
            _x.Ge(i);
            let e = new _x.Event(t);
            e.tWi = this.WVi.Wxt(),
            e.yWi = this.Rdi.toLowerCase(),
            e.bWi = i,
            this.WVi.IVi().dispatchEvent(e),
            this.XVi(e.bWi)
        }
        GWi() {
            let t = this.ZVi.value;
            for (let i of this.vWi)
                if (t >= i.TWi && t <= i.IWi)
                    return i
        }
        AWi() {
            let t = this.hWi.value;
            for (let i of this.vWi)
                if (t >= i.xWi && t <= i.MWi)
                    return i
        }
        RWi(t) {
            for (let i = 0; i < this.vWi.length; i++) {
                if (t === this.vWi[i] && 0 !== i)
                    return this.vWi[i - 1]
            }
        }
        EWi() {
            let t = Number(this.ZVi.value)
              , i = this.GWi();
            if (Tx(!isNaN(t), "step slider value is not a number"),
            i)
                switch (i.scale) {
                case "linear":
                    let e, s = this.RWi(i);
                    return e = s ? this.kWi(s).MWi : i.xWi,
                    Math.round(_x.WOt(t, i.TWi, i.IWi, e, i.MWi));
                case "logarithmic":
                    let n = i.TWi
                      , r = i.IWi
                      , h = Math.log(i.xWi)
                      , o = (Math.log(i.MWi) - h) / (r - n);
                    return Math.round(Math.exp(h + o * (t - n)))
                }
        }
        CWi() {
            let t = Number(this.hWi.value)
              , i = this.AWi();
            if (Tx(!isNaN(t), "step slider value is not a number"),
            i)
                switch (i.scale) {
                case "linear":
                    let e, s = this.RWi(i);
                    return e = s ? this.kWi(s).MWi : i.xWi,
                    Math.round(_x.WOt(t, e, i.MWi, i.TWi, i.IWi));
                case "logarithmic":
                    let n = i.TWi
                      , r = i.IWi
                      , h = Math.log(i.xWi)
                      , o = (Math.log(i.MWi) - h) / (r - n);
                    return Math.round((Math.log(t) - h) / o + n)
                }
        }
    }
}
{
    const Gx = self.t
      , Ax = [];
    Gx.Qs.Fk.Azi.AVi = class extends Gx.Qs.Fk.Azi.Element {
        constructor(t, i, e) {
            i = !!i,
            super(t, e),
            this.ght = Gx.Qs.W_("ui-toolbar-separator", this.WVi.k_()),
            this.ght.style.visibility = i ? "hidden" : "",
            this.WVi.jTi() && (this.ght.setAttribute("horizontal", ""),
            this.ght.style.height = `${this.WVi.zo()}px`),
            this.WVi.Wzi() && (this.ght.setAttribute("vertical", ""),
            this.ght.style.width = `${this.WVi.zo()}px`),
            this.qVi()
        }
        he() {
            super.he()
        }
        PF(t) {
            Gx.J1(t),
            this.YVi(t, Ax)
        }
        qd() {}
        Vzi() {}
        e_t() {}
    }
}
{
    const Rx = self.t
      , kx = ["tooltip"]
      , Ox = new Set(["click", "check", "radio"])
      , Dx = 1e3
      , Fx = 5
      , Lx = 100;
    let Bx = !1;
    const Ux = {
        button: Rx.gF.sV,
        preventDefault: () => {}
        ,
        fireEvent: !0
    }
      , Nx = {
        OWi: !1,
        Xyt: "",
        Vyt: "default"
    }
      , jx = new Map;
    jx.set("select", ["border-color"]);
    const $x = new Map;
    $x.set("dropdown", "select");
    const zx = new Map;
    Rx.Qs.Fk.Azi.jr = class extends Rx.Qs.Fk.Azi.Element {
        constructor(t, i, e, s, n, r, h) {
            if (Rx.U(e, Rx.Qs.d0),
            Rx.gL(s),
            Rx.zt(n),
            super(t, i, r),
            !Ox.has(n))
                throw new Error(`invalid button type "${n}"`);
            if (this.aGt = n,
            this.oft = Object.assign({}, Nx, h),
            this.DWi = !1,
            this.FWi = !1,
            this.LWi = -1,
            this.BWi = -1,
            this.UWi = !1,
            this.NWi = !1,
            this.ght = Rx.Qs.W_("ui-toolbar-button", this.WVi.k_()),
            "default" !== this.oft.Vyt && this.ght.setAttribute("corners", this.oft.Vyt),
            this.oft.Xyt) {
                const t = $x.get(this.oft.Xyt);
                if (t) {
                    this.ght.setAttribute("support", t);
                    const i = jx.get(t);
                    if (i)
                        for (const e of i) {
                            const s = `${t}-${e}`;
                            if (zx.has(s)) {
                                const t = zx.get(s);
                                this.ght.style.setProperty(`--${e}`, t)
                            } else {
                                const n = Rx.Qs.W_(t, document.body)
                                  , r = getComputedStyle(n).getPropertyValue(i);
                                this.ght.style.setProperty(`--${e}`, r),
                                zx.set(s, r),
                                Rx.Qs.UO(n)
                            }
                        }
                }
            }
            this.BGt = Rx.v(Rx.Qs._q, e, this.ght);
            let o = this.WVi.zo();
            this.ght.style.width = `${o}px`,
            this.ght.style.height = `${o}px`,
            s && (this.ght.setAttribute("title", s),
            this.ght.setAttribute("aria-label", s)),
            "click" === this.aGt ? (this.aft = this.jWi(this.$Wi),
            this.dft = this.jWi(this.zWi),
            this.VWi = this.jWi(),
            this.WWi = this.jWi(this.HWi),
            this.KWi = this.jWi(this.qWi),
            this.XWi = this.jWi(this.YWi)) : "check" === this.aGt ? (this.aft = this.jWi(this.JWi),
            this.dft = this.jWi(),
            this.VWi = this.jWi(this.ZWi),
            this.WWi = this.jWi(this.QWi),
            this.KWi = this.jWi(this.tHi),
            this.XWi = this.jWi(this.iHi)) : "radio" === this.aGt && (this.aft = this.jWi(this.JWi),
            this.dft = this.jWi(),
            this.VWi = this.jWi(this.eHi),
            this.WWi = this.jWi(this.sHi),
            this.KWi = this.jWi(this.tHi),
            this.XWi = this.jWi(this.iHi)),
            this.nHi = this.jWi(this.gO),
            this.rHi = this.jWi(this.hHi),
            this.ght.addEventListener("pointerdown", this.aft),
            this.ght.addEventListener("pointerup", this.dft),
            this.ght.addEventListener("pointerup", this.VWi),
            this.ght.addEventListener("pointercancel", this.WWi),
            this.ght.addEventListener("contextmenu", this.nHi),
            this.ght.addEventListener("mouseout", this.KWi),
            this.ght.addEventListener("mouseover", this.XWi),
            this.qVi(),
            this.oHi = NaN,
            this.aHi = NaN,
            this.lHi = t => {
                this.oHi = NaN,
                this.aHi = NaN
            }
            ,
            this.uHi = t => {
                this.oHi = t.clientX,
                this.aHi = t.clientY
            }
            ,
            this.H$i()
        }
        he() {
            this.oft = null,
            this.ght.removeEventListener("pointerdown", this.aft),
            this.ght.removeEventListener("pointerup", this.dft),
            this.ght.removeEventListener("pointerup", this.VWi),
            this.ght.removeEventListener("pointercancel", this.WWi),
            this.ght.removeEventListener("mouseout", this.KWi),
            this.ght.removeEventListener("mouseover", this.XWi),
            Rx.Qs.UO(this.ght),
            this.BGt.he(),
            this.BGt = null,
            this.aft = null,
            this.dft = null,
            this.KWi = null,
            this.XWi = null,
            clearTimeout(this.LWi),
            this.LWi = -1,
            clearTimeout(this.BWi),
            this.BWi = -1,
            super.he()
        }
        H$i() {
            const t = this.ght.ownerDocument;
            t.addEventListener("pointerdown", this.lHi, !0),
            t.addEventListener("pointermove", this.uHi, !0)
        }
        K$i() {
            const t = this.ght.ownerDocument;
            t.removeEventListener("pointerdown", this.lHi, !0),
            t.removeEventListener("pointermove", this.uHi, !0)
        }
        PF(t) {
            Rx.J1(t),
            this.YVi(t, kx),
            t.hasOwnProperty("tooltip") && Rx.K9(t.tooltip) && (this.ght.setAttribute("title", t.tooltip),
            this.ght.setAttribute("aria-label", t.tooltip))
        }
        qd() {
            this.ght.removeAttribute("mouse-down"),
            this.ght.removeAttribute("mouse-over"),
            this.DWi && !this.UWi && (this.DWi = !1,
            this.ght.addEventListener("pointerup", this.dft),
            this.ght.addEventListener("pointercancel", this.WWi),
            this.ght.addEventListener("mouseout", this.KWi),
            this.ght.addEventListener("mouseover", this.XWi)),
            clearTimeout(this.LWi),
            this.LWi = -1,
            clearTimeout(this.BWi),
            this.BWi = -1
        }
        Vzi() {}
        e_t(t=!0) {
            if (this.qk())
                if (t = !!t,
                this.FWi = !1,
                "click" === this.aGt) {
                    if (this.NWi)
                        return;
                    this.$Wi(Ux, !1),
                    this.NWi = !0,
                    this.BWi = setTimeout( () => {
                        this.NWi = !1,
                        this.zWi(Ux, t, !1),
                        this.BWi = -1
                    }
                    , Lx)
                } else
                    "check" === this.aGt ? this.cHi(t, !1, !0, !1) : "radio" === this.aGt && this.dHi(t, !0, !1)
        }
        I2(t) {
            super.I2(t),
            t || this.qd()
        }
        m0(t) {
            this.BGt.m0(t)
        }
        $Vi(t) {
            if ("check" === this.aGt)
                switch (t) {
                case "check":
                    return this.cHi(!1, !0, !0, !1);
                case "uncheck":
                    return this.qd()
                }
            else if ("radio" === this.aGt)
                switch (t) {
                case "check":
                    return this.dHi(!1, !0, !1);
                case "uncheck":
                    return this.qd()
                }
        }
        jWi(t) {
            return i => {
                t && (this.WVi.IVi().Lzi() || t.call(this, i))
            }
        }
        $Wi(t, i=void 0) {
            this.WVi.VVi(),
            Bx = void 0 === i ? !(!t.pointerType || "mouse" === t.pointerType) : !!t.pointerType && "mouse" !== t.pointerType,
            (Bx || t.button === Rx.gF.sV) && (this.NWi || (this.FWi = !1,
            this.ght.setAttribute("mouse-down", "")))
        }
        zWi(t, i=!0, e=void 0) {
            const s = Bx;
            void 0 === e && (Bx = !(!t.pointerType || "mouse" === t.pointerType));
            let n = !1;
            if ((Bx || t.button === Rx.gF.sV) && this.ght.hasAttribute("mouse-down") ? this.NWi && (n = !0) : n = !0,
            n)
                return Bx = s,
                void (t.pointerType && "mouse" !== t.pointerType && this.ght.removeAttribute("mouse-over"));
            this.FWi || this.WVi.zVi() || (t.preventDefault(),
            i && this.fHi()),
            this.ght.removeAttribute("mouse-down"),
            t.pointerType && "mouse" !== t.pointerType && this.ght.removeAttribute("mouse-over")
        }
        qWi(t) {
            Bx || this.NWi || (this.ght.removeAttribute("mouse-down"),
            this.ght.removeAttribute("mouse-over"))
        }
        YWi(t) {
            Bx || this.NWi || this.ght.setAttribute("mouse-over", "")
        }
        JWi(t) {
            this.WVi.VVi(),
            Bx = !!t.pointerType && "mouse" !== t.pointerType,
            this.FWi = !1,
            (Bx || t.button === Rx.gF.sV) && -1 === this.LWi && (this.LWi = Bx ? setTimeout(this.rHi, Dx) : setTimeout(this.rHi, Fx))
        }
        ZWi(t) {
            -1 !== this.LWi && (t.preventDefault(),
            clearTimeout(this.LWi),
            this.LWi = -1,
            this.cHi())
        }
        tHi(t) {
            this.ght.removeAttribute("mouse-down"),
            this.ght.removeAttribute("mouse-over")
        }
        iHi(t) {
            Bx || this.ght.setAttribute("mouse-over", "")
        }
        eHi(t) {
            -1 !== this.LWi && (t.preventDefault(),
            clearTimeout(this.LWi),
            this.LWi = -1,
            this.dHi())
        }
        IN(t) {
            this.qd()
        }
        HWi(t) {
            this.IN(t)
        }
        QWi(t) {
            this.IN(t)
        }
        sHi(t) {
            this.IN(t)
        }
        gO(t) {
            t.preventDefault(),
            this.WVi.zVi() || t.button === Rx.gF.mat && (this.FWi = !0,
            this.pHi(t))
        }
        cHi(t=!0, i=!0, e=!1, s=!0) {
            if (!this.FWi && (!this.WVi.zVi() || e)) {
                if (Rx.ub(this.oHi) && Rx.ub(this.aHi) && s) {
                    const t = this.ght.getBoundingClientRect();
                    if (!Rx.Rect.nJt(t).nB(this.oHi, this.aHi))
                        return
                }
                this.UWi = !0,
                this.DWi = !this.DWi,
                t && this.mHi(),
                this.DWi ? (this.ght.setAttribute("mouse-down", ""),
                this.ght.removeAttribute("mouse-over"),
                this.ght.removeEventListener("pointerup", this.dft),
                this.ght.removeEventListener("pointercancel", this.WWi),
                this.ght.removeEventListener("mouseout", this.KWi),
                this.ght.removeEventListener("mouseover", this.XWi)) : (this.ght.removeAttribute("mouse-down"),
                Bx || this.ght.setAttribute("mouse-over", ""),
                i || this.ght.removeAttribute("mouse-over"),
                this.ght.addEventListener("pointerup", this.dft),
                this.ght.addEventListener("pointercancel", this.WWi),
                this.ght.addEventListener("mouseout", this.KWi),
                this.ght.addEventListener("mouseover", this.XWi)),
                this.UWi = !1
            }
        }
        dHi(t=!0, i=!1, e=!0) {
            if (!this.FWi && (!this.WVi.zVi() || i)) {
                if (Rx.ub(this.oHi) && Rx.ub(this.aHi) && e) {
                    const t = this.ght.getBoundingClientRect();
                    if (!Rx.Rect.nJt(t).nB(this.oHi, this.aHi))
                        return
                }
                this.UWi = !0,
                this.DWi || (this.DWi = !0,
                t && this.wHi(),
                this.ght.setAttribute("mouse-down", ""),
                this.ght.removeAttribute("mouse-over"),
                this.ght.removeEventListener("pointerup", this.dft),
                this.ght.removeEventListener("pointercancel", this.WWi),
                this.ght.removeEventListener("mouseout", this.KWi),
                this.ght.removeEventListener("mouseover", this.XWi)),
                this.UWi = !1
            }
        }
        hHi() {
            "check" === this.aGt ? this.cHi() : "radio" === this.aGt && this.dHi(),
            this.LWi = -1
        }
        fHi() {
            let t = new Rx.Event("click");
            t.tWi = this.WVi.Wxt(),
            t.vlt = this.Rdi,
            this.WVi.IVi().dispatchEvent(t),
            this.XVi()
        }
        mHi() {
            let t = new Rx.Event("check");
            t.tWi = this.WVi.Wxt(),
            t.vlt = this.Rdi,
            t.checked = this.DWi,
            this.WVi.IVi().dispatchEvent(t),
            this.XVi(this.DWi)
        }
        wHi() {
            let t = new Rx.Event("radio");
            t.tWi = this.WVi.Wxt(),
            t.vlt = this.Rdi,
            t.checked = this.DWi,
            this.WVi.IVi().dispatchEvent(t),
            this.XVi(this.DWi)
        }
        pHi(t) {
            let i = new Rx.Event("buttoncontextmenu");
            i.tWi = this.WVi.Wxt(),
            i.vlt = this.Rdi,
            i.clientX = t.clientX,
            i.clientY = t.clientY,
            this.WVi.IVi().dispatchEvent(i)
        }
        k_() {
            return this.ght
        }
    }
}
{
    const Vx = self.t
      , Wx = ["checked"];
    Vx.Qs.Fk.Azi.DVi = class extends Vx.Qs.Fk.Azi.Element {
        constructor(t, i, e, s, n) {
            Vx.gL(e),
            super(t, i, s),
            this.ght = Vx.Qs.W_("ui-toolbar-checkbox", this.WVi.k_()),
            this.gHi = Vx.Qs.W_("div", null, null, "checkboxWrapper"),
            this.ZVi = Vx.Qs.W_("input", this.gHi, null, null, {
                type: "checkbox"
            }),
            this.yHi = t => this.mHi(this.ZVi.checked),
            this.ZVi.addEventListener("change", this.yHi),
            this.bHi = t => {
                this.e_t(),
                this.yHi()
            }
            ,
            this.vHi = t => {}
            ,
            this.LGt = null,
            e && (this.LGt = Vx.Qs.W_("span", null),
            Vx.wQ(this.LGt, e),
            this.LGt.addEventListener("pointerup", this.bHi),
            this.LGt.addEventListener("pointercancel", this.vHi)),
            this.ght.style.height = `${this.WVi.zo()}px`,
            this.WVi.Wrt().wrap && this.ght.setAttribute("wrap", ""),
            n ? (this.ght.appendChild(this.LGt),
            this.ght.appendChild(this.gHi)) : (this.ght.appendChild(this.gHi),
            this.ght.appendChild(this.LGt))
        }
        he() {
            this.ZVi.removeEventListener("change", this.yHi),
            this.LGt && (this.LGt.removeEventListener("pointerup", this.bHi),
            this.LGt.removeEventListener("pointercancel", this.vHi)),
            Vx.Qs.UO(this.ZVi),
            Vx.Qs.UO(this.gHi),
            Vx.Qs.UO(this.LGt),
            Vx.Qs.UO(this.ght),
            this.yHi = null,
            this.WVi = null,
            this.ght = null,
            this.gHi = null,
            this.ZVi = null,
            this.LGt = null
        }
        Ft() {
            return this.ZVi.checked
        }
        Svt(t) {
            this.ZVi.checked = !!t
        }
        PF(t) {
            Vx.J1(t),
            this.YVi(t, Wx),
            t.hasOwnProperty("checked") && (this.ZVi.checked = !!t.checked)
        }
        qd() {}
        Vzi() {
            this.mHi()
        }
        e_t() {
            this.qk() && (this.ZVi.checked = !this.ZVi.checked)
        }
        mHi(t) {
            let i = new Vx.Event("checkboxchecked");
            i.tWi = this.WVi.Wxt(),
            i.SHi = this.Rdi,
            i.checked = this.ZVi.checked,
            this.WVi.IVi().dispatchEvent(i),
            this.XVi(this.ZVi.checked)
        }
    }
}
{
    const Hx = self.t
      , Kx = ["min", "max", "step", "value", "label"]
      , qx = "first"
      , Xx = "change"
      , Yx = "focus"
      , Jx = "blur"
      , Zx = 10;
    Hx.Qs.Fk.Azi.FVi = class extends Hx.Qs.Fk.Azi.Element {
        constructor(t, i, e, s, n, r, h, o, a, l) {
            Hx.iM(e),
            Hx.iM(s),
            Hx.iM(n),
            Hx.iM(r),
            Hx.gL(h),
            Hx.gL(o),
            super(t, i, a),
            this.eWi = e,
            this.sWi = s,
            this.nWi = n || 1,
            this.$fi = r || 0,
            this.xHi = null,
            this.MHi = !0,
            this.Jht = !1,
            this.EHi = "",
            this.CHi = !1,
            this._Hi = !1,
            this.THi = !1,
            this.IHi = -1,
            this.ght = Hx.Qs.W_("ui-toolbar-spinner", this.WVi.k_()),
            o && this.ght.setAttribute("title", o),
            this.PHi = {},
            this.PHi.type = "number",
            this.PHi.step = this.nWi.toString(),
            this.PHi.value = this.$fi.toString(),
            Hx.ub(e) && (this.PHi.min = e.toString()),
            Hx.ub(s) && (this.PHi.max = s.toString()),
            this.ZVi = Hx.Qs.W_("input", this.ght, null, null, this.PHi),
            this.ZVi.style.height = `${this.WVi.zo()}px`,
            this.GHi = null,
            this.AHi = null,
            this.RHi = null,
            this.kHi = h || i.charAt(0).toUpperCase() + i.slice(1),
            this.LGt = document.createElement("span"),
            this.LGt.textContent = this.kHi,
            l ? this.ght.appendChild(this.LGt) : this.ght.insertBefore(this.LGt, this.ZVi),
            this.OHi = t => this.DHi(t),
            this.FHi = t => this.LHi(t),
            this.BHi = t => this.UHi(t),
            this.NHi = t => this.jHi(t),
            this.$Hi = t => this._Ui(t),
            this.ZVi.addEventListener("focus", this.$Hi),
            this.zHi = t => this.xft(t),
            this.kf = Hx.v(Hx.Rf, Hx._f.Gf(this.ZVi, "pointerdown", t => this.mO(t)), Hx._f.Gf(this.ZVi, "pointerup", t => this.dG(t)), Hx._f.Gf(this.ZVi, "pointercancel", t => this.IN(t)), Hx._f.Gf(this.ZVi, "change", this.OHi), Hx._f.Gf(this.ZVi, "input", this.FHi), Hx.cwi(this.ZVi)),
            this.qVi()
        }
        c_t() {
            let t = 0;
            this.GHi ? (t = this.GHi.value,
            t = Hx.Qs.Fk.Azi.FVi.nee(t)) : t = parseFloat(this.ZVi.value),
            Hx.ub(t) || (t = 0);
            const i = parseFloat(this.ZVi.min)
              , e = parseFloat(this.ZVi.max);
            return Hx.ub(i) && t < i ? t = i : Hx.ub(e) && t > e && (t = e),
            t
        }
        he() {
            this.VHi(),
            this.ZVi.removeEventListener("focus", this.$Hi),
            this.$Hi = null,
            Hx.Qs.UO(this.ZVi),
            Hx.Qs.UO(this.LGt),
            this.kf.Ff(),
            this.kf = null,
            this._Hi = null,
            this.AHi && this.AHi.Ff(),
            this.RHi && this.RHi.Ff(),
            this.AHi = null,
            this.RHi = null,
            this.ZVi = null,
            this.LGt = null,
            super.he()
        }
        H$i() {
            this.RHi && this.RHi.lgi()
        }
        PF(t) {
            if (Hx.J1(t),
            this.YVi(t, Kx),
            t.hasOwnProperty("min") && Hx.ub(t.min)) {
                let i = t.min;
                this.eWi = i,
                this.PHi.min = i.toString(),
                this.ZVi.min = i.toString(),
                Number(this.ZVi.value) < i && (this.ZVi.value = i.toString(),
                this.PHi.value = i.toString(),
                this.$fi = i),
                this.GHi && (this.GHi.min = i.toString(),
                Number(this.GHi.value) < i && (this.GHi.value = i.toString()))
            }
            if (t.hasOwnProperty("max") && Hx.ub(t.max)) {
                let i = t.max;
                this.sWi = i,
                this.PHi.max = i.toString(),
                this.ZVi.max = i.toString(),
                Number(this.ZVi.value) > i && (this.ZVi.value = i.toString(),
                this.PHi.value = i.toString(),
                this.$fi = i),
                this.GHi && (this.GHi.max = i.toString(),
                Number(this.GHi.value) > i && (this.GHi.value = i.toString()))
            }
            if (t.hasOwnProperty("step") && Hx.ub(t.step)) {
                let i = t.step;
                this.nWi = i,
                this.PHi.step = i.toString(),
                this.ZVi.step = i.toString(),
                this.GHi && (this.GHi.step = i.toString())
            }
            if (t.hasOwnProperty("value") && Hx.ub(t.value)) {
                let i = t.value;
                this.$fi = i,
                this.PHi.value = i.toString(),
                this.ZVi.value = i.toString(),
                this.ZVi.min && this.$fi < Number(this.ZVi.min) && (this.ZVi.value = this.ZVi.min.toString(),
                this.PHi.value = this.ZVi.min.toString(),
                this.$fi = Number(this.ZVi.min),
                i = Number(this.ZVi.min)),
                this.ZVi.max && this.$fi > Number(this.ZVi.max) && (this.ZVi.value = this.ZVi.max.toString(),
                this.PHi.value = this.ZVi.max.toString(),
                this.$fi = Number(this.ZVi.max),
                i = Number(this.ZVi.min)),
                this.GHi && this.WHi(i.toString())
            }
            t.hasOwnProperty("label") && Hx.K9(t.label) && (this.kHi = t.label,
            this.LGt.textContent = this.kHi)
        }
        qd() {}
        Vzi() {
            this.HHi("spinnerchange")
        }
        e_t() {
            this.qk()
        }
        KHi(t) {
            Hx.zt(t),
            this.kHi !== t && (this.kHi = t,
            this.LGt.textContent = t)
        }
        qHi() {
            return this.kHi
        }
        mO(t) {
            this.IHi = Number(this.ZVi.value),
            this.CHi = !0,
            this.WVi.VVi(),
            this.Jht = !0
        }
        dG(t) {
            this.Jht && (Hx.kt.T9t && t.preventDefault(),
            this.Jht = !1,
            this.MHi = !0,
            this.IHi === Number(this.ZVi.value) ? (this._Ui(),
            this.GHi && this.CHi && this.GHi.ownerDocument.execCommand("selectAll", !1)) : this.ZVi.addEventListener("blur", this.zHi))
        }
        IN(t) {
            this.MHi = !0,
            this.Jht = !1,
            this.EHi = "",
            this.CHi = !1,
            this._Hi = !1,
            this.THi = !1,
            this.IHi = -1,
            this.ZVi.addEventListener("focus", this.$Hi),
            this.ZVi.removeEventListener("blur", this.zHi),
            this.VHi()
        }
        _Ui(t) {
            if (this.Jht)
                return;
            if (this.GHi)
                return;
            const i = this.ZVi.getBoundingClientRect();
            this.EHi = this.ZVi.value,
            this.ZVi.style.display = "none",
            this.PHi.value = this.ZVi.value,
            this.PHi.min = this.ZVi.min.toString(),
            this.PHi.max = this.ZVi.max.toString(),
            this.PHi.step = this.ZVi.step.toString();
            const e = Object.assign({}, this.PHi, {
                type: "text"
            });
            this.GHi = Hx.Qs.W_("input", this.ght, "spinnerEditInput", null, e, 1),
            this.GHi.style.width = `${i.width}px`,
            this.GHi.style.height = `${i.height}px`,
            this.AHi = Hx.cwi(this.GHi),
            this.RHi = Hx.agi(this.GHi),
            this.GHi.addEventListener("change", this.OHi),
            this.GHi.addEventListener("input", this.FHi),
            this.GHi.addEventListener("blur", this.NHi),
            this.GHi.addEventListener("focus", this.BHi),
            this.THi = !0,
            this.GHi.focus(),
            this.THi = !1
        }
        xft(t) {
            this.Jht || (this.MHi = !0,
            this.ZVi.removeEventListener("blur", this.zHi),
            this.IHi !== Number(this.ZVi.value) && this.XHi(),
            this.zm(this.ZVi.value))
        }
        DHi(t) {
            if (this._Hi)
                return;
            this.GHi && this.zm(this.c_t());
            this.c_t();
            const i = new Hx.Event("spinnerchange");
            i.tWi = this.WVi.Wxt(),
            i.UCt = this.Rdi.toLowerCase(),
            i.PCt = this.c_t(),
            this.WVi.IVi().dispatchEvent(i),
            this.CHi = !1
        }
        LHi(t) {
            this._Hi || (this.GHi && this.zm(this.c_t()),
            this.MHi ? (this.MHi = !1,
            this.YHi()) : this.HHi("spinnerinput"),
            this.CHi = !1)
        }
        UHi(t) {
            this.THi = !1,
            this.GHi && (this.GHi.value = this.EHi,
            this.GHi.removeEventListener("focus", this.BHi),
            this.JHi())
        }
        jHi(t) {
            if (this.THi)
                return;
            this.ZVi.removeEventListener("focus", this.$Hi);
            const i = this.c_t();
            this.ZVi.style.display = "",
            this.ZVi.value = i,
            this.zm(i),
            this.VHi(),
            setTimeout( () => {
                this.ZVi && (this.ZVi.blur(),
                this.ZVi.addEventListener("focus", this.$Hi),
                this.IHi !== Number(this.ZVi.value) && this.XHi())
            }
            , Zx)
        }
        VHi() {
            this.GHi && (this.MHi = !0,
            this.AHi.Ff(),
            this.AHi = null,
            this.RHi.Ff(),
            this.RHi = null,
            this.GHi.removeEventListener("change", this.OHi),
            this.GHi.removeEventListener("input", this.FHi),
            this.GHi.removeEventListener("focus", this.BHi),
            this.GHi.removeEventListener("blur", this.NHi),
            Hx.Qs.UO(this.GHi),
            this.GHi = null)
        }
        zm(t) {
            "" === t ? this.ZVi.value = "0" : this.eWi && Number(t) < this.eWi ? this.ZVi.value = this.eWi.toString() : this.sWi && Number(t) > this.sWi ? this.ZVi.value = this.sWi.toString() : this.ZVi.value = t
        }
        WHi(t) {
            this.GHi && (this._Hi = !0,
            this.GHi.value = t,
            this._Hi = !1)
        }
        YHi() {
            let t = new Hx.Event("firstspinnerinput")
              , i = this.c_t();
            t.tWi = this.WVi.Wxt(),
            t.UCt = this.Rdi.toLowerCase(),
            t.PCt = i,
            this.xHi = i,
            this.WVi.IVi().dispatchEvent(t),
            this.XVi(this.c_t(), qx)
        }
        JHi() {
            let t = new Hx.Event("focusspinnerinput")
              , i = this.c_t();
            t.tWi = this.WVi.Wxt(),
            t.UCt = this.Rdi.toLowerCase(),
            t.PCt = i,
            this.WVi.IVi().dispatchEvent(t),
            this.XVi(this.c_t(), Yx)
        }
        XHi() {
            let t = new Hx.Event("blurspinnerinput")
              , i = this.c_t();
            t.tWi = this.WVi.Wxt(),
            t.UCt = this.Rdi.toLowerCase(),
            t.PCt = i,
            this.WVi.IVi().dispatchEvent(t),
            this.XVi(this.c_t(), Jx)
        }
        HHi(t) {
            Hx.zt(t);
            let i = this.c_t();
            if (i === this.xHi)
                return;
            let e = new Hx.Event(t);
            e.tWi = this.WVi.Wxt(),
            e.UCt = this.Rdi.toLowerCase(),
            e.PCt = i,
            this.xHi = i,
            this.WVi.IVi().dispatchEvent(e),
            this.XVi(i, Xx)
        }
        static nee(t) {
            Hx.zt(t);
            try {
                const i = self.Wte.Bte(t);
                return "number" == typeof i && isFinite(i) ? i : 0
            } catch (i) {
                if (t.trim().startsWith(".")) {
                    const i = parseFloat(t.trim());
                    if (isFinite(i))
                        return i
                }
                return 0
            }
        }
    }
}
{
    const Qx = self.t
      , tM = ["value", "label"];
    Qx.Qs.Fk.Azi.LVi = class extends Qx.Qs.Fk.Azi.Element {
        constructor(t, i, e, s, n, r, h) {
            Qx.gL(s),
            Qx.gL(e),
            super(t, i, n),
            this.MHi = !0,
            this.ght = Qx.Qs.W_("ui-toolbar-textbox", this.WVi.k_()),
            this.ZVi = document.createElement("input"),
            this.ZVi.type = h?.type ?? "text",
            this.ZVi.value = e,
            this.ZVi.style.height = `${this.WVi.zo()}px`,
            this.ZVi.placeholder = h?.V2 ?? "",
            this.kf = Qx.v(Qx.Rf, Qx._f.Gf(this.ZVi, "input", t => this.ZHi(t)), Qx._f.Gf(this.ZVi, "change", t => this.ZHi(t))),
            this.ght.appendChild(this.ZVi),
            this.LGt = null,
            s && (this.LGt = document.createElement("span"),
            r ? this.ght.insertBefore(this.LGt, this.ZVi) : this.ght.appendChild(this.LGt),
            Qx.wQ(this.LGt, s)),
            this.qVi()
        }
        Ft() {
            return this.ZVi.value
        }
        Svt(t) {
            Qx.zt(t),
            this.ZVi.value = t
        }
        Zte() {
            return this.ZVi
        }
        he() {
            Qx.Qs.UO(this.ZVi),
            Qx.Qs.UO(this.LGt),
            this.kf.Ff(),
            this.kf = null,
            this.ZVi = null,
            this.LGt = null,
            super.he()
        }
        PF(t) {
            Qx.J1(t),
            this.YVi(t, tM),
            t.hasOwnProperty("value") && Qx.K9(t.value) && (this.ZVi.value = t.value.toString()),
            t.hasOwnProperty("label") && Qx.K9(t.label) && (this.ZVi.label = t.label)
        }
        qd() {}
        Vzi() {
            this.ZHi()
        }
        e_t() {
            this.qk()
        }
        ZHi(t) {
            const i = t ? t.type : "input"
              , e = new Qx.Event("input" === i ? "textinput" : "textchange");
            e.tWi = this.WVi.Wxt(),
            e.QHi = this.Rdi.toLowerCase(),
            e.tKi = this.Ft(),
            this.WVi.IVi().dispatchEvent(e),
            this.XVi(this.Ft(), e.type)
        }
    }
}
{
    const iM = self.t
      , eM = ["value", "label", "values", "subValues"]
      , sM = {
        Vyt: "default"
    };
    iM.Qs.Fk.Azi.BVi = class extends iM.Qs.Fk.Azi.Element {
        constructor(t, i, e, s, n, r, h, o="ui-toolbar-dropdown") {
            iM.gL(s),
            iM.RH(e),
            super(t, i, n),
            r = Object.assign({}, sM, r),
            this.MHi = !0,
            this.ght = iM.Qs.W_(o, this.WVi.k_()),
            this.ZVi = document.createElement("select"),
            this.ZVi.style.height = `${this.WVi.zo()}px`,
            this.ZVi.setAttribute("corners", r.Vyt),
            this.ght.appendChild(this.ZVi);
            for (let t of e)
                if (!iM.w9(t.A2) || t.A2())
                    if (iM.B9(t.F2)) {
                        const i = document.createElement("optgroup");
                        i.setAttribute("value", t.value),
                        i.label = t.label;
                        for (const e of t.F2) {
                            if (iM.w9(e.A2) && !e.A2())
                                continue;
                            const t = document.createElement("option");
                            t.value = e.value,
                            t.textContent = e.label,
                            e.selected && t.setAttribute("selected", ""),
                            e.disabled && t.setAttribute("disabled", ""),
                            i.appendChild(t)
                        }
                        this.ZVi.appendChild(i)
                    } else {
                        let i = document.createElement("option");
                        this.ZVi.appendChild(i),
                        i.value = t.value,
                        i.textContent = t.label,
                        t.selected && i.setAttribute("selected", ""),
                        t.disabled && i.setAttribute("disabled", "")
                    }
            this.ZVi.selectedIndex = 0,
            this.kf = iM.v(iM.Rf, iM._f.Gf(this.ZVi, "change", t => this.ZHi(t))),
            this.LGt = null,
            s && (this.LGt = document.createElement("span"),
            h ? this.ght.insertBefore(this.LGt, this.ZVi) : this.ght.appendChild(this.LGt),
            iM.wQ(this.LGt, s)),
            this.qVi()
        }
        Ft() {
            return this.ZVi.value
        }
        m2(t) {
            iM.Ge(t),
            this.ZVi.selectedIndex = t
        }
        iKi(t) {
            iM.zt(t),
            this.ZVi.value = t
        }
        he() {
            iM.Qs.UO(this.ZVi),
            iM.Qs.UO(this.LGt),
            this.kf.Ff(),
            this.kf = null,
            this.ZVi = null,
            this.LGt = null,
            super.he()
        }
        PF(t) {
            if (iM.J1(t),
            this.YVi(t, eM),
            t.hasOwnProperty("values") && iM.B9(t.values)) {
                for (; this.ZVi.firstChild; )
                    this.ZVi.removeChild(this.ZVi.firstChild);
                let i = t.values;
                for (let t of i) {
                    if (iM.w9(t.A2) && !t.A2())
                        continue;
                    let i = document.createElement("option");
                    this.ZVi.appendChild(i),
                    i.value = t.value,
                    i.textContent = t.label,
                    t.selected && i.setAttribute("selected", ""),
                    t.disabled && i.setAttribute("disabled", "")
                }
            }
            if (t.hasOwnProperty("subValues") && iM.Wft(t.subValues) && iM.K9(t.subValues.parent) && iM.B9(t.subValues.children)) {
                const i = t.subValues.parent
                  , e = Array.from(this.ZVi.children)
                  , s = e.filter(t => "OPTGROUP" === t.tagName)
                  , n = e.filter(t => "OPTION" === t.tagName).find(t => t.value === i)
                  , r = s.find(t => t.getAttribute("value") === i)
                  , h = n ?? r;
                if (h)
                    if (t.subValues.children.length) {
                        const i = document.createElement("optgroup");
                        i.setAttribute("value", h?.value ?? h?.getAttribute("value")),
                        i.label = h.label ?? h?.textContent;
                        for (const e of t.subValues.children) {
                            if (iM.w9(e.A2) && !e.A2())
                                continue;
                            const t = document.createElement("option");
                            t.value = e.value,
                            t.textContent = e.label,
                            e.selected && t.setAttribute("selected", ""),
                            e.disabled && t.setAttribute("disabled", ""),
                            i.appendChild(t)
                        }
                        this.ZVi.replaceChild(i, h)
                    } else {
                        const t = document.createElement("option");
                        t.value = h?.value ?? h?.getAttribute("value"),
                        t.textContent = h.label ?? h?.textContent,
                        t.setAttribute("selected", ""),
                        this.ZVi.replaceChild(t, h)
                    }
            }
            t.hasOwnProperty("value") && iM.K9(t.value) && (this.ZVi.value = t.value.toString()),
            t.hasOwnProperty("label") && iM.K9(t.label) && (this.ZVi.label = t.label)
        }
        qd() {}
        Vzi() {
            this.ZHi()
        }
        e_t() {
            this.qk()
        }
        ZHi() {
            let t = new iM.Event("optionselected");
            t.tWi = this.WVi.Wxt(),
            t.eKi = this.Rdi.toLowerCase(),
            t.sKi = this.Ft(),
            this.WVi.IVi().dispatchEvent(t),
            this.XVi(this.Ft())
        }
    }
}
{
    const nM = self.t
      , rM = {
        Jyt: null,
        jyt: !0
    };
    nM.Qs.Fk.Azi.UVi = class extends nM.Qs.Fk.Azi.BVi {
        constructor(t, i, e, s, n, r, h) {
            super(t, i, e, s, n, r = Object.assign({}, rM, r), h, "ui-toolbar-editable-dropdown"),
            this.nKi = r.Jyt,
            this.oft = r,
            this.rKi = nM.Qs.W_("div", this.ght, null, "wrapper"),
            this.rKi.appendChild(this.ZVi),
            this.ZFi = nM.Qs.W_("input", this.rKi, null, "textInput", {
                type: "text"
            }),
            this.ZFi.style.height = `${this.WVi.zo()}px`,
            r.jyt ? this.ZVi.setAttribute("pointer-edit", "") : (this.ZFi.tabIndex = "-1",
            this.ZFi.style.pointerEvents = "none"),
            this.hKi = t => this.oKi(t),
            this.ZFi.addEventListener("blur", this.hKi),
            this.aKi = t => this.lKi(t),
            this.ZFi.addEventListener("focus", this.aKi),
            this.mkt = t => this.wG(t),
            this.ZFi.addEventListener("keydown", this.mkt),
            this.uKi = -1,
            requestAnimationFrame( () => this.ZVi.blur(), 16)
        }
        he() {
            this.nKi = null,
            this.oft = null,
            this.ZFi.removeEventListener("change", this.hKi),
            this.hKi = null,
            this.ZFi.removeEventListener("focus", this.aKi),
            this.aKi = null,
            this.ZFi.removeEventListener("keydown", this.mkt),
            this.mkt = null,
            nM.Qs.UO(this.rKi),
            this.rKi = null,
            nM.Qs.UO(this.ZFi),
            this.ZFi = null,
            super.he()
        }
        e_t() {
            this.qk() && (this.ZFi.style.pointerEvents = "",
            this.ZFi.focus())
        }
        oKi(t) {
            const i = this.uKi;
            -1 !== i && (this.cKi(i),
            this.ZFi.value = "",
            this.uKi = -1,
            this.ZVi.selectedIndex = i,
            this.ZVi.removeAttribute("hide-drop-down"),
            !1 === this.oft.jyt && (this.ZFi.style.pointerEvents = "none"),
            this.dKi())
        }
        cKi(t) {
            const i = [];
            for (let e = 0; e < this.ZVi.length; e++) {
                const s = this.ZVi.options[e];
                t === e ? i.push({
                    value: this.ZFi.value,
                    label: this.ZFi.value
                }) : i.push({
                    value: s.value,
                    label: s.text
                })
            }
            this.PF({
                values: i
            })
        }
        lKi(t) {
            this.ZFi.value = this.Ft(),
            this.uKi = this.ZVi.selectedIndex,
            this.ZVi.selectedIndex = -1,
            this.ZVi.setAttribute("hide-drop-down", "")
        }
        wG(t) {
            this.ZFi.ownerDocument.activeElement === this.ZFi && (t.keyCode !== nM.Mk.aY && t.keyCode !== nM.Mk.VJ || this.ZFi.blur())
        }
        dKi() {
            let t = new nM.Event("optionrenamed");
            t.tWi = this.WVi.Wxt(),
            t.eKi = this.Rdi.toLowerCase(),
            t.sKi = this.Ft(),
            this.WVi.IVi().dispatchEvent(t),
            this.nKi && this.nKi(this.Ft())
        }
    }
}
{
    const hM = self.t
      , oM = ["tooltip"]
      , aM = ["primary", "secondary"]
      , lM = new Set(["click", "check", "radio"])
      , uM = 1e3
      , cM = 5;
    let dM = !1;
    hM.Qs.Fk.Azi.GVi = class extends hM.Qs.Fk.Azi.Element {
        constructor(t, i, e, s, n, r, h) {
            hM.U(e, hM.Qs.d0),
            hM.gL(s),
            hM.gL(n),
            hM.tot(h),
            super(t, i, r),
            this.fKi = h,
            this.FWi = !1,
            this.dpt = "click",
            this.ght = hM.Qs.W_("ui-toolbar-split-button", this.WVi.k_()),
            this.ght.style.height = `${this.WVi.zo()}px`,
            this.ght.setAttribute("type", "split"),
            this.pKi = hM.Qs.W_("div", this.ght),
            this.mKi = hM.Qs.W_("div", this.ght),
            this.pKi.setAttribute("primary", ""),
            this.mKi.setAttribute("secondary", ""),
            s && (this.pKi.setAttribute("title", s),
            this.pKi.setAttribute("aria-label", s)),
            n && (this.mKi.setAttribute("title", n),
            this.mKi.setAttribute("aria-label", n)),
            this.wKi = hM.v(hM.Qs._q, e, this.pKi),
            this.gKi = hM.Qs.W_("div", this.mKi, null, "arrow"),
            this.ght.style.setProperty("--arrow-size", self.app.m4() / 2 + "px"),
            this.ght.style.setProperty("--arrow-color", self.app.MOi()),
            this.kf = hM.v(hM.Rf, hM._f.Gf(this.pKi, "pointerdown", t => this.mO(t)), hM._f.Gf(this.pKi, "pointerup", t => this.dG(t)), hM._f.Gf(this.pKi, "pointerup", t => this.yKi(t)), hM._f.Gf(this.pKi, "pointercancel", t => this.IN(t)), hM._f.Gf(this.pKi, "mouseout", t => this.bKi(t)), hM._f.Gf(this.pKi, "mouseover", t => this.vKi(t)), hM._f.Gf(this.pKi, "contextmenu", t => this.gO(t)), hM._f.Gf(this.mKi, "pointerdown", t => this.mO(t)), hM._f.Gf(this.mKi, "pointerup", t => this.dG(t)), hM._f.Gf(this.mKi, "pointerup", t => this.yKi(t)), hM._f.Gf(this.mKi, "pointercancel", t => this.IN(t)), hM._f.Gf(this.mKi, "mouseout", t => this.bKi(t)), hM._f.Gf(this.mKi, "mouseover", t => this.vKi(t)), hM._f.Gf(this.mKi, "contextmenu", t => this.gO(t)), hM._f.Gf(self.app, "settingschange", t => this.SKi(t))),
            this.rHi = t => this.hHi(t),
            this.UWi = !1,
            this.LWi = -1,
            this.DWi = !1,
            this.xKi = !1,
            this.MKi = !1,
            this.EKi = !1,
            this.CKi = !1,
            this._Ki = !1,
            this.TKi = !1,
            this.IKi = !1,
            this.PKi = !1,
            this.qVi()
        }
        he() {
            clearTimeout(this.LWi),
            this.LWi = -1,
            this.kf.Ff(),
            this.kf = null,
            this.wKi.he(),
            this.wKi = null,
            hM.Qs.UO(this.gKi),
            this.gKi = null,
            hM.Qs.UO(this.pKi),
            this.pKi = null,
            hM.Qs.UO(this.mKi),
            this.mKi = null,
            super.he()
        }
        PF(t) {
            hM.J1(t),
            this.YVi(t, oM),
            hM.ML(t.tooltip),
            t.tooltip && this.YVi(t.tooltip, aM),
            t.hasOwnProperty("tooltip") && hM.Jvt(t.tooltip) && this.xwe(t.tooltip.primary ?? "", t.tooltip.secondary ?? "")
        }
        I2(t) {
            super.I2(t),
            t || this.qd()
        }
        xwe(t, i) {
            hM.gL(t),
            hM.gL(i),
            t && (this.pKi.setAttribute("title", t),
            this.pKi.setAttribute("aria-label", t)),
            i && (this.mKi.setAttribute("title", i),
            this.mKi.setAttribute("aria-label", i))
        }
        m0(t) {
            this.wKi.m0(t)
        }
        qd() {
            clearTimeout(this.LWi),
            this.LWi = -1,
            this.DWi && !this.UWi && (this.DWi = !1),
            this.xKi = !1,
            this.MKi = !1,
            this.EKi = !1,
            this.CKi = !1,
            this._Ki = !1,
            this.TKi = !1,
            this.IKi = !1,
            this.PKi = !1,
            this.pKi.removeAttribute("mouse-down"),
            this.pKi.removeAttribute("mouse-over-light"),
            this.pKi.removeAttribute("mouse-over"),
            this.mKi.removeAttribute("mouse-down"),
            this.mKi.removeAttribute("mouse-over-light"),
            this.mKi.removeAttribute("mouse-over")
        }
        ndt(t) {
            if (hM.zt(t),
            !lM.has(t))
                throw new Error(`invalid button mode "${t}"`);
            this.dpt = t
        }
        Vzi() {}
        e_t(t=!0) {
            this.qk() && this.GKi(t => this.AKi(t), t => this.RKi(t), t => this.kKi(t), t)
        }
        AKi(t) {
            this.pKi.setAttribute("mouse-down", ""),
            this.pKi.removeAttribute("mouse-down-light"),
            this.mKi.removeAttribute("mouse-down", ""),
            this.mKi.removeAttribute("mouse-down-light"),
            this.OKi()
        }
        RKi(t) {
            this.cHi(t, !0, !0)
        }
        kKi(t) {
            this.dHi(t, !0, !0)
        }
        qyt() {
            this.ght.setAttribute("type", "single"),
            this.ght.style.width = `${this.WVi.zo()}px`,
            this.ght.style.padding = "",
            this.mKi.setAttribute("hide", "")
        }
        Qyt() {
            this.ght.setAttribute("type", "split"),
            this.ght.style.width = "",
            this.ght.style.padding = "",
            this.mKi.removeAttribute("hide")
        }
        DKi() {
            this.ght.setAttribute("type", "wide"),
            this.ght.style.width = "",
            this.ght.style.padding = `0 ${self.app.m4() / 4 + 1}px`,
            this.mKi.setAttribute("hide", "")
        }
        mO(t) {
            this.WVi.VVi(),
            dM = "mouse" !== t.pointerType,
            (dM || t.button === hM.gF.sV) && (this.FWi = !1,
            this.GKi(t => this.FKi(t), t => this.LKi(t), t => this.LKi(t), t))
        }
        FKi(t) {
            this.ght.setAttribute("mouse-down", ""),
            t.target === this.pKi && (this.xKi || this.pKi.setAttribute("mouse-down", ""),
            this.MKi || this.mKi.removeAttribute("mouse-down")),
            t.target === this.mKi && (this.xKi || this.pKi.removeAttribute("mouse-down"),
            this.MKi || this.mKi.setAttribute("mouse-down", ""))
        }
        LKi(t) {
            if (-1 === this.LWi)
                if (t.target === this.pKi)
                    this.LWi = dM ? setTimeout(this.rHi, uM) : setTimeout(this.rHi, cM);
                else if (t.target === this.mKi) {
                    const i = this.xKi;
                    this.xKi = !0,
                    this.FKi(t),
                    i || (this.xKi = !1)
                }
        }
        hHi() {
            "check" === this.dpt ? (this.cHi(),
            this.LWi = -1) : "radio" === this.dpt && (this.dHi(),
            this.LWi = -1)
        }
        cHi(t=!0, i=!0, e=!1) {
            this.FWi || this.WVi.zVi() && !e || (this.UWi = !0,
            this.DWi = !this.DWi,
            t && this.BKi(),
            this.DWi ? (this.ght.setAttribute("mouse-down", ""),
            this.pKi.setAttribute("mouse-down", ""),
            this.pKi.removeAttribute("mouse-over"),
            this.pKi.removeAttribute("mouse-over-light"),
            this.mKi.setAttribute("mouse-over-light", ""),
            this.mKi.removeAttribute("mouse-over"),
            this.EKi = !0,
            this.CKi = !1,
            this._Ki = !0,
            this.TKi = !1,
            this.IKi = !0,
            this.PKi = !1) : (this.ght.removeAttribute("mouse-down"),
            this.pKi.removeAttribute("mouse-down"),
            dM || (this.ght.setAttribute("mouse-over", ""),
            this.pKi.setAttribute("mouse-over", ""),
            this.pKi.setAttribute("mouse-over-light", "")),
            i || (this.ght.removeAttribute("mouse-over"),
            this.pKi.removeAttribute("mouse-over"),
            this.pKi.removeAttribute("mouse-over-light")),
            this.mKi.setAttribute("mouse-over-light", ""),
            this.mKi.removeAttribute("mouse-over"),
            this.EKi = !1,
            this.CKi = !1,
            this._Ki = !1,
            this.TKi = !1,
            this.IKi = !1,
            this.PKi = !1),
            this.UWi = !1)
        }
        dHi(t=!0, i=!1) {
            this.FWi || this.WVi.zVi() && !i || (this.UWi = !0,
            this.DWi || (this.DWi = !0,
            t && this.UKi(),
            this.ght.setAttribute("mouse-down", ""),
            this.pKi.setAttribute("mouse-down", ""),
            this.pKi.removeAttribute("mouse-over"),
            this.pKi.removeAttribute("mouse-over-light"),
            this.mKi.setAttribute("mouse-over-light", ""),
            this.mKi.removeAttribute("mouse-over"),
            this.EKi = !0,
            this.CKi = !1,
            this._Ki = !0,
            this.TKi = !1,
            this.IKi = !0,
            this.PKi = !1),
            this.UWi = !1)
        }
        dG(t) {
            t.preventDefault(),
            this.GKi(t => this.NKi(t), t => this.jKi(t), t => this.$Ki(t), t)
        }
        NKi(t) {
            (dM || t.button === hM.gF.sV) && this.ght.hasAttribute("mouse-down") && (this.FWi || this.WVi.zVi() || (t.target === this.pKi && "click" === this.dpt && this.OKi(t),
            t.target === this.mKi && this.zKi(t)),
            this.EKi || this.CKi || this.ght.removeAttribute("mouse-down"),
            this.EKi || (this.pKi.removeAttribute("mouse-down"),
            this.pKi.removeAttribute("mouse-down-light")),
            this.CKi || (this.mKi.removeAttribute("mouse-down"),
            this.mKi.removeAttribute("mouse-down-light")))
        }
        jKi(t) {
            const i = this.EKi;
            this.EKi = !0,
            this.NKi(t),
            i || (this.EKi = !1)
        }
        $Ki(t) {
            const i = this.EKi;
            this.EKi = !0,
            this.NKi(t),
            i || (this.EKi = !1)
        }
        yKi(t) {
            t.preventDefault(),
            this.GKi(t => this.VKi(t), t => this.WKi(t), t => this.HKi(t), t)
        }
        VKi(t) {}
        WKi(t) {
            -1 !== this.LWi && (clearTimeout(this.LWi),
            this.LWi = -1,
            this.cHi())
        }
        HKi(t) {
            -1 !== this.LWi && (clearTimeout(this.LWi),
            this.LWi = -1,
            this.dHi())
        }
        IN(t) {
            this.ght.removeAttribute("mouse-down"),
            this.ght.removeAttribute("mouse-over"),
            this.qd()
        }
        bKi(t) {
            dM || (this._Ki || this.TKi || (this.ght.removeAttribute("mouse-down"),
            this.ght.removeAttribute("mouse-over")),
            this._Ki || (this.pKi.removeAttribute("mouse-down"),
            this.pKi.removeAttribute("mouse-over")),
            this.TKi || (this.DWi && this.mKi.setAttribute("mouse-over-light", ""),
            this.mKi.removeAttribute("mouse-down"),
            this.mKi.removeAttribute("mouse-over")))
        }
        vKi(t) {
            dM || (this.ght.setAttribute("mouse-over", ""),
            t.target === this.pKi && (this.IKi || (this.pKi.setAttribute("mouse-over", ""),
            this.pKi.removeAttribute("mouse-over-light", "")),
            this.PKi || (this.mKi.setAttribute("mouse-over-light", ""),
            this.mKi.removeAttribute("mouse-over"))),
            t.target !== this.mKi || this.PKi || (this.IKi || (this.pKi.setAttribute("mouse-over-light", ""),
            this.pKi.removeAttribute("mouse-over")),
            this.PKi || (this.mKi.setAttribute("mouse-over", ""),
            this.mKi.removeAttribute("mouse-over-light"))))
        }
        GKi(t, i, e, s) {
            switch (this.dpt) {
            case "click":
                return t(s);
            case "check":
                return i(s);
            case "radio":
                return e(s)
            }
        }
        gO(t) {
            t.preventDefault(),
            this.WVi.zVi() || t.button === hM.gF.mat && (this.FWi = !0,
            this.pHi(t))
        }
        SKi(t) {
            this.ght.style.setProperty("--arrow-color", self.app.MOi())
        }
        OKi(t) {
            let i = new hM.Event("primaryclick");
            i.tWi = this.WVi.Wxt(),
            i.vlt = this.Rdi,
            i.clientX = t ? t.clientX : 0,
            i.clientY = t ? t.clientY : 0,
            this.WVi.IVi().dispatchEvent(i),
            this.XVi()
        }
        BKi(t) {
            let i = new hM.Event("primarycheck");
            i.tWi = this.WVi.Wxt(),
            i.vlt = this.Rdi,
            i.clientX = t ? t.clientX : 0,
            i.clientY = t ? t.clientY : 0,
            i.checked = this.DWi,
            this.WVi.IVi().dispatchEvent(i),
            this.XVi()
        }
        UKi(t) {
            let i = new hM.Event("primaryradio");
            i.tWi = this.WVi.Wxt(),
            i.vlt = this.Rdi,
            i.clientX = t ? t.clientX : 0,
            i.clientY = t ? t.clientY : 0,
            i.checked = this.DWi,
            this.WVi.IVi().dispatchEvent(i),
            this.XVi()
        }
        zKi(t) {
            let i = new hM.Event("secondaryclick");
            i.tWi = this.WVi.Wxt(),
            i.vlt = this.Rdi,
            i.clientX = t.clientX,
            i.clientY = t.clientY,
            this.WVi.IVi().dispatchEvent(i),
            this.fKi && this.fKi()
        }
        pHi(t) {
            let i = new hM.Event("splitbuttoncontextmenu");
            i.tWi = this.WVi.Wxt(),
            i.vlt = this.Rdi,
            i.clientX = t.clientX,
            i.clientY = t.clientY,
            this.WVi.IVi().dispatchEvent(i)
        }
        KKi() {
            return this.pKi
        }
    }
}
{
    const fM = self.t
      , pM = ["checked", "tooltip"];
    fM.Qs.Fk.Azi.PVi = class extends fM.Qs.Fk.Azi.jr {
        constructor(t, i, e, s, n, r, h, o) {
            fM.U(e, fM.Qs.d0),
            fM.U(s, fM.Qs.d0),
            fM.gL(n),
            fM.zt(r),
            super(t, i, e, n, r, h, o),
            this.qKi = fM.v(fM.Qs._q, s, this.ght),
            this.qKi.k_().setAttribute("hide", "")
        }
        he() {
            this.qKi.he(),
            this.qKi = null,
            super.he()
        }
        qd() {
            super.qd(),
            this.BGt.k_().removeAttribute("hide"),
            this.qKi.k_().setAttribute("hide", "")
        }
        PF(t) {
            fM.J1(t),
            this.YVi(t, pM),
            t.hasOwnProperty("checked") && this.$Vi(t.checked ? "check" : "uncheck"),
            t.hasOwnProperty("tooltip") && fM.K9(t.tooltip) && (this.ght.setAttribute("title", t.tooltip),
            this.ght.setAttribute("aria-label", t.tooltip)),
            this.XKi()
        }
        cHi(t=!0, i=!0, e=!1, s=!0) {
            super.cHi(t, i, e, s),
            this.XKi()
        }
        dHi(t=!0, i=!1, e=!0) {
            super.dHi(t, i, e),
            this.XKi()
        }
        XKi() {
            this.DWi ? (this.BGt.k_().setAttribute("hide", ""),
            this.qKi.k_().removeAttribute("hide")) : (this.BGt.k_().removeAttribute("hide"),
            this.qKi.k_().setAttribute("hide", ""))
        }
    }
}
{
    const mM = self.t
      , wM = 100
      , gM = 200
      , yM = 50;
    mM.Qs.Fk.YKi = class extends mM.Event.v_ {
        constructor() {
            super(),
            this.ght = null,
            this.JKi = [],
            this.ZKi = -1,
            this.QKi = () => this.tqi()
        }
        he() {
            mM.Qs.UO(this.ght),
            this.ght = null;
            for (let t of this.JKi)
                t.he();
            mM.Io(this.JKi),
            this.ZKi > -1 && (window.clearTimeout(this.ZKi),
            this.ZKi = -1),
            this.QKi = null,
            super.he()
        }
        iqi(t) {
            if (this.JKi.length >= wM)
                throw new Error("too much content added to status indicator");
            if (this.JKi.includes(t))
                throw new Error("already added");
            this.JKi.push(t),
            this.eqi()
        }
        sqi(t) {
            let i = this.JKi.indexOf(t);
            if (i < 0)
                throw new Error("content not added to status indicator");
            this.JKi.splice(i, 1),
            this.eqi()
        }
        eqi() {
            this.ZKi > -1 || (this.ZKi = window.setTimeout(this.QKi, this.ght ? yM : gM))
        }
        tqi() {
            if (this.ZKi = -1,
            this.JKi.length) {
                this.QOi(!0);
                let t = "";
                for (let i = 0; i < this.JKi.length; ++i)
                    i >= 1 && (t += "<br/>"),
                    t += this.JKi[i].nqi();
                mM.wQ(this.ght, new mM.vti(t))
            } else
                this.QOi(!1)
        }
        QOi(t) {
            t = !!t,
            !!this.ght !== t && (t ? (this.ght = mM.Qs.W_("ui-statusIndicator", document.body),
            this.ght.setAttribute("role", "status")) : (mM.Qs.UO(this.ght),
            this.ght = null))
        }
    }
}
{
    const bM = self.t;
    bM.Qs.Fk.rqi = class {
        constructor(t, i) {
            bM.U(t, bM.Qs.Fk.YKi),
            bM.zt(i),
            this.hqi = t,
            this.oqi = i,
            this.gki = 0
        }
        he() {
            this.gki > 0 && (this.hqi.sqi(this),
            this.gki = 0),
            this.hqi = null
        }
        WL() {
            0 === this.gki && this.hqi.iqi(this),
            this.gki++,
            this.hqi.eqi()
        }
        Lw() {
            if (this.gki <= 0)
                throw new Error("removed too many times");
            this.gki--,
            0 === this.gki ? this.hqi.sqi(this) : this.hqi.eqi()
        }
        nqi() {
            return bM.Uoi(this.oqi, this.gki)
        }
    }
}
{
    const vM = self.t;
    vM.Qs.Fk.aqi = class {
        constructor(t, i) {
            vM.U(t, vM.Qs.Fk.YKi),
            vM.zt(i),
            this.hqi = t,
            this.oqi = i,
            this.lqi = 0,
            this.Fc = !1
        }
        he() {
            this.Fc && (this.hqi.sqi(this),
            this.Fc = !1),
            this.hqi = null
        }
        uqi(t) {
            vM.Ge(t),
            t = vM.Ne(t, 0, 1),
            this.Fc || (this.hqi.iqi(this),
            this.Fc = !0),
            this.lqi !== t && (this.lqi = t,
            this.hqi.eqi())
        }
        FR() {
            this.Fc && (this.hqi.sqi(this),
            this.Fc = !1,
            this.lqi = 0)
        }
        nqi() {
            return vM.Uoi(this.oqi, Math.round(1e3 * this.lqi) / 10)
        }
    }
}
{
    const SM = self.t;
    SM.Qs.Fk.dqi = class {
        constructor(t, i) {
            SM.U(t, SM.Qs.Fk.YKi),
            SM.zt(i),
            this.hqi = t,
            this.hy = i,
            this.Fc = !1
        }
        he() {
            this.Fc && (this.hqi.sqi(this),
            this.Fc = !1),
            this.hqi = null
        }
        lQ() {
            !this.Fc && this.hqi && (this.hqi.iqi(this),
            this.Fc = !0)
        }
        ha(t) {
            SM.zt(t),
            this.hqi && (this.lQ(),
            this.hy !== t && (this.hy = t,
            this.hqi.eqi()))
        }
        nqi() {
            return this.hy
        }
    }
}
{
    const xM = self.t
      , MM = [{
        opacity: "1"
    }, {
        opacity: "0"
    }]
      , EM = [{
        transform: "scale(0.85)",
        opacity: "0"
    }, {
        transform: "scale(1)",
        opacity: "1"
    }]
      , CM = {
        duration: 100,
        easing: "ease-out"
    }
      , _M = {
        UEt: 1e4,
        maxWidth: "300px",
        align: "center",
        anchor: "auto",
        clientX: null,
        clientY: null
    }
      , TM = 5
      , IM = new Set(["top-left", "top", "top-right", "left", "center", "right", "bottom-left", "bottom", "bottom-right"])
      , PM = new Set(["auto", "top", "bottom"]);
    let GM = null;
    const AM = {};
    xM.Qs.Fk.Uk = class extends xM.Me {
        constructor(t, i, e, s, n, r) {
            if (xM.kti(t, HTMLElement, Range),
            xM.p0(e),
            xM.p0(s),
            xM.kQ(n),
            super(),
            r !== AM)
                throw new Error("Balloon tip can not be created directly. Use C3.UI.Controls.BalloonTip.ShowAt instead.");
            "string" == typeof i && (i = self.app.u0(i)),
            xM.Ef(i, xM.Qs.d0),
            this.fqi = t,
            this.pqi = e,
            this.mqi = s,
            this.dn = !1,
            n = Object.assign({}, _M, n),
            xM.zt(n.maxWidth),
            xM.Ge(n.UEt),
            xM.zt(n.align),
            xM.iM(n.clientX),
            xM.iM(n.clientY);
            let h = n.clientX
              , o = n.clientY
              , a = Number.isFinite(h) && Number.isFinite(o);
            if (!IM.has(n.align))
                throw new Error("invalid alignment");
            if (!PM.has(n.anchor))
                throw new Error("invalid alignment");
            GM && GM.wqi(),
            GM = this,
            this.gqi = n.maxWidth,
            this.yqi = n.UEt,
            this.bqi = n.align,
            this.vqi = n.anchor,
            this.ght = null,
            this.Sqi = -1,
            this.mF = t => this.mO(),
            this.xqi = !1;
            let l = this.fqi;
            l instanceof Range && (l = this.fqi.commonAncestorContainer);
            let u = null
              , c = xM.Sii(l, "dialog")
              , d = 0
              , f = 0;
            if (xM.Qs.FOi.XO())
                u = xM.Qs.FOi.NOi();
            else if (c) {
                const t = xM.Qs.Ks.rCi(c);
                t.iCi() || (d = t.ESi(),
                f = t.CSi()),
                u = c
            } else
                u = l.ownerDocument.body;
            this.ght = xM.Qs.W_("ui-balloontip", u),
            this.Mqi = xM.Qs.W_("ui-balloontip-icon", this.ght),
            this.Eqi = xM.Qs.W_("ui-balloontip-text", this.ght),
            this.r0t = xM.v(xM.Qs._q, i || self.app.Oq()),
            this.Mqi.appendChild(this.r0t.k_()),
            this.fYt = xM.Qs.W_("ui-balloontip-title", this.Eqi),
            this.oit = xM.Qs.W_("ui-balloontip-body", this.Eqi),
            xM.wQ(this.fYt, this.pqi),
            xM.wQ(this.oit, this.mqi),
            this.fYt.style.maxWidth = this.gqi,
            this.oit.style.maxWidth = this.gqi;
            let p = this.Mqi.getBoundingClientRect()
              , m = this.Eqi.getBoundingClientRect();
            this.ght.style.width = `${p.width + m.width}px`;
            let w = this.fqi.getBoundingClientRect()
              , g = 0
              , y = 0;
            switch (this.bqi) {
            case "top-left":
                g = 0,
                y = 0;
                break;
            case "top":
                g = w.width / 2,
                y = 0;
                break;
            case "top-right":
                g = w.width,
                y = 0;
                break;
            case "left":
                g = 0,
                y = w.height / 2;
                break;
            case "center":
                g = w.width / 2,
                y = w.height / 2;
                break;
            case "right":
                g = w.width,
                y = w.height / 2;
                break;
            case "bottom-left":
                g = 0,
                y = w.height;
                break;
            case "bottom":
                g = w.width / 2,
                y = w.height;
                break;
            case "bottom-right":
                g = w.width,
                y = w.height;
                break;
            default:
                throw new Error("invalid alignment")
            }
            let b = w.left + g
              , v = w.top + y;
            a && (b = h - d,
            v = o - f);
            let S = this.ght.ownerDocument.defaultView.getComputedStyle(this.ght);
            const x = parseInt(S.getPropertyValue("--balloontip-padding"));
            let M = x
              , E = x
              , C = b - 2 * M - d
              , _ = v + E - f
              , T = this.ght.ownerDocument.defaultView.getComputedStyle(this.ght)
              , I = parseInt(T.width)
              , P = parseInt(T.height)
              , G = I + 4 * M
              , A = P + 4 * E;
            this.lOt = xM.Qs.Fk.Uk.Cqi(),
            this.lOt.setAttributeNS(null, "width", G),
            this.lOt.setAttributeNS(null, "height", A),
            this.ght.style.setProperty("--balloontip-left", -M + "px"),
            this.ght.style.setProperty("--balloontip-top", -E + "px"),
            this._qi = this.lOt.querySelector(".balloontipPath"),
            this.ght.insertBefore(this.lOt, this.Mqi);
            let R = null;
            if (this.Tqi(C + 2 * M, I - M, d))
                switch (this.vqi) {
                case "auto":
                case "top":
                    this.Iqi(_ + E, P, f) ? (this.ght.style.top = `${_}px`,
                    this.ght.style.left = `${C}px`,
                    this.ght.style.transformOrigin = b - C - d + "px 0%",
                    R = this.Pqi) : (this.ght.style.top = _ - P - 4 * E + "px",
                    this.ght.style.left = `${C}px`,
                    this.ght.style.transformOrigin = b - C - d + "px 100%",
                    R = this.Gqi);
                    break;
                case "bottom":
                    this.Aqi(_ + E, P, f) ? (this.ght.style.top = _ - P - 4 * E + "px",
                    this.ght.style.left = `${C}px`,
                    this.ght.style.transformOrigin = b - C - d + "px 100%",
                    R = this.Gqi) : (this.ght.style.top = `${_}px`,
                    this.ght.style.left = `${C}px`,
                    this.ght.style.transformOrigin = b - C - d + "px 0%",
                    R = this.Pqi)
                }
            else
                switch (this.vqi) {
                case "auto":
                case "top":
                    if (this.Iqi(_ + E, P, f)) {
                        let t = C - I + 2 * M;
                        this.ght.style.top = `${_}px`,
                        this.ght.style.left = `${t}px`,
                        this.ght.style.transformOrigin = b - t - d + "px 0%",
                        R = this.Rqi
                    } else {
                        let t = C - I + 2 * M;
                        this.ght.style.top = _ - P - 4 * E + "px",
                        this.ght.style.left = `${t}px`,
                        this.ght.style.transformOrigin = b - t - d + "px 100%",
                        R = this.kqi
                    }
                    break;
                case "bottom":
                    if (this.Aqi(_ + E, P, f)) {
                        let t = C - I + 2 * M;
                        this.ght.style.top = _ - P - 4 * E + "px",
                        this.ght.style.left = `${t}px`,
                        this.ght.style.transformOrigin = b - t - d + "px 100%",
                        R = this.kqi
                    } else {
                        let t = C - I + 2 * M;
                        this.ght.style.top = `${_}px`,
                        this.ght.style.left = `${t}px`,
                        this.ght.style.transformOrigin = b - t - d + "px 0%",
                        R = this.Rqi
                    }
                }
            this._qi.setAttributeNS(null, "d", R(M, E, G - M, A - E, M, E)),
            this.mRi(EM, CM, "show")
        }
        Oqi() {
            let t = this.fqi;
            return t instanceof Range && (t = this.fqi.commonAncestorContainer),
            t.ownerDocument
        }
        Dqi() {
            return this.Oqi().defaultView
        }
        mRi(t, i, e) {
            let s;
            "show" === e && (s = this.Fqi),
            "hide" === e && (s = this.Lqi),
            self.app.jKt() ? (this.fEi = this.ght.animate(t, i),
            this.fEi.onfinish = t => s.call(this)) : s.call(this)
        }
        Fqi() {
            xM.gn(this) || this.dn || (this.Sqi = setTimeout( () => this.wqi(), this.yqi),
            this.Oqi().addEventListener("pointerdown", this.mF))
        }
        Lqi() {
            this.S0()
        }
        mO() {
            this.wqi()
        }
        wqi() {
            this.dn || this.xqi || (GM === this && (GM = null),
            this.xqi = !0,
            this.mRi(MM, CM, "hide"))
        }
        S0() {
            xM.gn(this) || this.dn || (this.dn = !0,
            GM === this && (GM = null),
            -1 !== this.Sqi && (clearTimeout(this.Sqi),
            this.Sqi = -1),
            this.Oqi().removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.r0t && this.r0t.he(),
            xM.Qs.UO(this.fYt),
            xM.Qs.UO(this.fYt),
            xM.Qs.UO(this.fYt),
            xM.Qs.UO(this.lOt),
            xM.Qs.UO(this.Mqi),
            xM.Qs.UO(this.Eqi),
            xM.Qs.UO(this.ght),
            this.Mqi = null,
            this.Eqi = null,
            this.r0t = null,
            this.lOt = null,
            this.fYt = null,
            this.oit = null,
            this.fqi = null,
            this.ght = null,
            xM.he(this))
        }
        Pqi(t, i, e, s, n, r) {
            return `M ${t + TM} ${i}\n\t\t\t\tL ${t + n} ${i}\n\t\t\t\tL ${t + 2 * n} ${i - r}\n\t\t\t\tL ${t + 2 * n} ${i}\n\t\t\t\tL ${e - TM} ${i}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e} ${i + TM}\n\t\t\t\tL ${e} ${s - TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e - TM} ${s}\n\t\t\t\tL ${t + TM} ${s}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t} ${s - TM}\n\t\t\t\tL ${t} ${i + TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t + TM} ${i}\n\t\t\t\tZ`
        }
        Rqi(t, i, e, s, n, r) {
            return `M ${e / 2} ${i}\n\t\t\t\tL ${t + e - 4 * n} ${i}\n\t\t\t\tL ${t + e - 4 * n + n} ${i - r}\n\t\t\t\tL ${t + e - 4 * n + n} ${i}\n\t\t\t\tL ${e - TM} ${i}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e} ${i + TM}\n\t\t\t\tL ${e} ${s - TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e - TM} ${s}\n\t\t\t\tL ${t + TM} ${s}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t} ${s - TM}\n\t\t\t\tL ${t} ${i + TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t + TM} ${i}\n\t\t\t\tZ`
        }
        Gqi(t, i, e, s, n, r) {
            return `M ${t + TM} ${i}\n\t\t\t\tL ${e - TM} ${i}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e} ${i + TM}\n\t\t\t\tL ${e} ${s - TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e - TM} ${s}\n\t\t\t\tL ${t + 2 * n} ${s}\n\t\t\t\tL ${t + 2 * n} ${s + r}\n\t\t\t\tL ${t + n} ${s}\n\t\t\t\tL ${t + TM} ${s}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t} ${s - TM}\n\t\t\t\tL ${t} ${i + TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t + TM} ${i}\n\t\t\t\tZ`
        }
        kqi(t, i, e, s, n, r) {
            return `M ${t + TM} ${i}\n\t\t\t\tL ${e - TM} ${i}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e} ${i + TM}\n\t\t\t\tL ${e} ${s - TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${e - TM} ${s}\n\t\t\t\tL ${t + e - 4 * n + n} ${s}\n\t\t\t\tL ${t + e - 4 * n + n} ${s + r}\n\t\t\t\tL ${t + e - 4 * n} ${s}\n\t\t\t\tL ${t + TM} ${s}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t} ${s - TM}\n\t\t\t\tL ${t} ${i + TM}\n\t\t\t\tA ${TM} ${TM} 0 0 1 ${t + TM} ${i}\n\t\t\t\tZ`
        }
        Tqi(t, i, e) {
            return t + i + e < this.Dqi().innerWidth
        }
        Bqi(t, i, e) {
            return t - e > 0
        }
        Aqi(t, i, e) {
            return t - e > 0
        }
        Iqi(t, i, e) {
            return t + i + e < this.Dqi().innerHeight
        }
        Uqi(t) {
            return xM.U(t, xM.Qs.Ks),
            xM.TP(this.ght, t.k_())
        }
        static NT(t, i, e, s, n) {
            let r = t;
            if (r instanceof Range && (r = t.commonAncestorContainer),
            r.ownerDocument.defaultView)
                return xM.v(xM.Qs.Fk.Uk, t, i, e, s, n, AM)
        }
        static JF() {
            return !!GM
        }
        static Nqi() {
            GM && GM.wqi()
        }
        static jqi(t) {
            xM.U(t, xM.Qs.Ks),
            GM && GM.Uqi(t) && GM.wqi()
        }
        static BCi() {
            GM && GM.S0()
        }
        static UCi(t) {
            xM.U(t, xM.Qs.Ks),
            GM && GM.Uqi(t) && GM.S0()
        }
        static Cqi() {
            return (new DOMParser).parseFromString('<svg id="balloontip-svg" xmlns="http://www.w3.org/2000/svg">\n\t\t    <path class="balloontipPath"></path>\n\t\t</svg>', "image/svg+xml").getElementById("balloontip-svg")
        }
    }
}
{
    const RM = self.t
      , kM = self.assert
      , OM = {
        H2: !1,
        N2: !1,
        border: !1,
        $qi: !0,
        overflow: "auto",
        BVt: !0,
        LVt: !0,
        HVt: () => 1
    }
      , DM = 400
      , FM = ["auto", "scroll", "hidden"];
    RM.Qs.Fk.Table = class extends RM.Event.v_ {
        constructor(t, i) {
            super(),
            RM.ibt(t),
            RM.kQ(i),
            i = Object.assign({}, OM, i),
            this.c8 = t,
            this.bUi = !!i.H2,
            this.yUi = !!i.N2,
            this.zqi = !!i.$qi,
            this.Vqi = i.overflow,
            this.sEi = !!i.BVt,
            this.Wqi = i.HVt,
            kM(FM.includes(this.Vqi), `unexpected 'overflow' value, valid values are '${FM}'`),
            this.Hqi = RM.Qs.W_("ui-table", this.c8),
            i.border && this.Hqi.setAttribute("own-border", ""),
            this.Kqi = null,
            this.qqi = [],
            this.Xqi = new Set,
            this.L_ = null,
            this.Yqi = t => this.Z_(t),
            this.Jqi = () => this.Zqi(),
            this.Qqi = 0,
            this.x5t = 0,
            this.zM = -1,
            this.r5t = RM.Qs.W_("div", null, null, "table-insert-mark"),
            this.tXi = null,
            this.u5t = "",
            this.iXi = !1,
            this.eXi = null,
            this.zM = -1,
            this.fPt = () => this.DUi(),
            this.FUi = 0,
            this.LUi = 0,
            this.BUi = 0,
            this.UUi = 0,
            this.sXi = !1,
            this.nXi = null,
            this.rXi = null,
            this.hXi = null,
            this.oXi = i.LVt,
            this.JPi = !0,
            this.aXi = 0
        }
        he() {
            this.Ry(),
            this.Hnt(),
            this.r5t = null,
            this.lXi(),
            this.uXi(),
            this.fPt = null,
            this.Kqi && (this.Kqi.he(),
            this.Kqi = null),
            this.hXi && (RM.Qs.UO(this.hXi),
            this.hXi = null),
            this.rXi && (this.rXi.he(),
            this.rXi = null),
            -1 !== this.zM && (this.LO().cancelAnimationFrame(this.zM),
            this.zM = -1),
            this.L_ && (this.L_.removeEventListener("scroll", this.Yqi, {
                passive: !0
            }),
            this.Yqi = null,
            RM.Qs.UO(this.L_),
            this.L_ = null),
            RM.Qs.UO(this.Hqi),
            this.Hqi = null,
            this.Jqi = null,
            this.c8 = null,
            super.he()
        }
        Ry() {
            this.Xqi.clear(),
            this.Hnt();
            for (let t of this.qqi)
                t.he();
            for (const t of this.Kqi.cXi())
                t.dXi();
            RM.Io(this.qqi)
        }
        PF() {
            for (const t of this.Kqi.cXi())
                t.PF();
            for (const t of this.qqi)
                t.PF()
        }
        DSt() {
            let t = 0;
            for (const i of this.Kqi.cXi())
                i.fXi() && (t += i.pXi());
            return t
        }
        kSt() {
            let t = 0;
            for (const i of this.Kqi.cXi())
                i.fXi() || (t += i.mXi());
            return t
        }
        zSt() {
            return !!this.qqi.some(t => t.zSt())
        }
        k_() {
            return this.Hqi
        }
        FO() {
            return this.k_().ownerDocument
        }
        LO() {
            return this.FO().defaultView
        }
        lNi() {
            return this.bUi
        }
        hNi() {
            return this.yUi
        }
        Q$() {
            return this.sEi
        }
        wXi() {
            return this.Wqi()
        }
        gXi() {
            return this.zqi
        }
        yXi(t, i) {
            this.sXi = t,
            this.nXi = i
        }
        bXi() {
            return this.sXi
        }
        vXi(t) {
            this.SXi(t),
            this.Xqi.add(t)
        }
        xXi(t) {
            this.SXi(t),
            this.Xqi.delete(t)
        }
        _Tt() {
            return this.Xqi.size
        }
        f1() {
            this.Pit() && (this.iXi && (this.eXi && this.eXi.f1(),
            this.lXi()),
            this.sXi && (this.nXi && this.nXi.f1(),
            this.uXi()))
        }
        Pit() {
            return !!this.iXi || !!this.sXi
        }
        vFt() {
            this.MXi();
            for (let t of this.Xqi)
                t.I6(!1);
            this.EXi(),
            this.CXi("allunselected"),
            kM(0 === this.Xqi.size, "should have deleted all selected row")
        }
        ijt() {
            return this.Xqi.values()
        }
        _Xi() {
            return RM.th(this.Xqi)
        }
        TXi() {
            return this.Xqi.size > 0
        }
        IXi() {
            return this.Kqi
        }
        MXi() {
            this.aXi++
        }
        EXi() {
            this.aXi--,
            kM(this.aXi >= 0, "missing matching call to block events")
        }
        PXi() {
            return this.aXi > 0
        }
        GXi() {
            return this.L_
        }
        AXi(t) {
            this.oXi ? this.L_.insertBefore(t, this.rXi.k_()) : this.L_.appendChild(t)
        }
        skt(t) {
            for (const i of this.qqi)
                if (i.Do() === t)
                    return i;
            return null
        }
        Aet() {
            if (this.qqi.length)
                throw new Error("table must be empty before setting the top row");
            return this.Kqi && this.Kqi.he(),
            this.Kqi = RM.v(RM.Qs.Fk.Table.RXi, this),
            this.L_ = RM.Qs.W_("div", this.Hqi, null, "table-scroll-container"),
            this.L_.addEventListener("scroll", this.Yqi, {
                passive: !0
            }),
            this.L_.style.overflow = this.Vqi,
            this.Kqi
        }
        Wet(t) {
            this.ket();
            let i = RM.v(RM.Qs.Fk.Table.uvt, t, this);
            return this.qqi.push(i),
            i
        }
        ket() {
            !this.rXi && this.oXi && (this.rXi = RM.v(RM.Qs.Fk.Table.uvt, null, this, !0))
        }
        kXi() {
            if (this.hXi)
                return this.hXi;
            if (!this.rXi)
                throw new Error("must create padding row before footer element");
            this.hXi = RM.Qs.W_("div", null, null, "tableFooterElem");
            const t = this.rXi.k_();
            return t.insertBefore(this.hXi, t.firstChild),
            this.hXi
        }
        fCi() {
            return this.hXi
        }
        OXi(t) {
            RM.nu(t);
            for (let i of this.qqi)
                if (t(i))
                    return i
        }
        wvt(t) {
            RM.U(t, RM.Qs.Fk.Table.uvt);
            let i = this.qqi.indexOf(t);
            if (i < 0)
                throw new Error("cannot find row");
            this.qqi[i].he(),
            this.qqi.splice(i, 1)
        }
        gNi() {
            for (let t of this.qqi)
                t.gNi()
        }
        Z_(t) {
            let i = this.L_.scrollLeft
              , e = this.L_.scrollTop;
            if ((this.Qqi !== i || this.x5t !== e) && (this.Qqi = i,
            this.x5t = e,
            -1 === this.zM)) {
                this.LO() && (this.zM = this.LO().requestAnimationFrame(this.Jqi))
            }
        }
        Zqi() {
            const t = this.Kqi.k_()
              , i = `${this.Qqi}px`;
            t.style.marginLeft = `-${i}`,
            t.style.paddingRight = i;
            for (const t of this.rows()) {
                t.k_().style.setProperty("--width-offset", i)
            }
            this.zM = -1
        }
        SXi(t) {
            if (RM.U(t, RM.Qs.Fk.Table.uvt),
            t.VFt() !== this)
                throw new Error("row from different table")
        }
        *rows() {
            for (let t of this.qqi)
                yield t
        }
        gz(t, i) {
            RM.Ge(t),
            RM.Ge(i);
            let e = this.Hqi.getBoundingClientRect();
            if (t < e.left || i < e.top || t > e.right || i > e.bottom)
                return null;
            for (let e of this.rows()) {
                let s = e.gz(t, i);
                if (s)
                    return {
                        Eet: e,
                        Mnt: s.Mnt
                    }
            }
            return null
        }
        Tnt(t, i) {
            if (this.SXi(t),
            RM.zt(i),
            "before" !== i && "after" !== i)
                throw new Error("invalid insert mark type");
            if (t === this.tXi && i === this.u5t)
                return;
            this.Hnt();
            let e = t.k_();
            e.parentElement.insertBefore(this.r5t, "before" === i ? e : e.nextSibling),
            this.tXi = t,
            this.u5t = i
        }
        Hnt() {
            this.u5t && (RM.Qs.UO(this.r5t),
            this.tXi = null,
            this.u5t = "")
        }
        DXi() {
            return this.tXi
        }
        hFt(t) {
            !this.iXi && this.LO() && (this.eXi = t,
            this.iXi = !0,
            this.UUi = 0,
            this.FUi = performance.now(),
            this.zM = this.LO().requestAnimationFrame(this.fPt))
        }
        nFt(t, i) {
            this.iXi && (this.LUi = t,
            this.BUi = i)
        }
        DUi() {
            if (this.zM = -1,
            !this.iXi || !this.LO())
                return;
            let t = performance.now()
              , i = (t - this.FUi) / 1e3;
            this.FUi = t;
            let e = this.Hqi.getBoundingClientRect();
            if (this.LUi >= e.left && this.LUi <= e.right)
                if (this.BUi < e.top) {
                    let t = this.L_.scrollTop - DM * i - this.UUi;
                    this.UUi = Math.ceil(t) - t,
                    t = Math.ceil(t),
                    this.FXi(t)
                } else if (this.BUi > e.bottom) {
                    let t = this.L_.scrollTop + DM * i + this.UUi;
                    this.UUi = t - Math.floor(t),
                    t = Math.floor(t),
                    this.FXi(t)
                }
            this.zM = this.LO().requestAnimationFrame(this.fPt)
        }
        LXi() {
            return this.L_.scrollTop
        }
        BXi(t) {
            RM.Ge(t),
            this.L_.scrollLeft = t,
            this.Qqi = this.L_.scrollLeft
        }
        lJt() {
            return this.L_.scrollTop
        }
        FXi(t) {
            RM.Ge(t),
            this.L_.scrollTop = t,
            this.x5t = this.L_.scrollTop
        }
        lXi() {
            this.eXi && this.eXi.f1(),
            this.eXi = null,
            this.iXi = !1,
            -1 !== this.zM && this.LO() && (this.LO().cancelAnimationFrame(this.zM),
            this.zM = -1)
        }
        uXi() {
            this.nXi && this.nXi.f1(),
            this.nXi = null,
            this.yXi(!1)
        }
        UXi(t, i, e, s, n, r) {
            if (this.PXi())
                return;
            let h = new RM.Event(i)
              , o = null;
            return !e || (o = e.getAttribute("columnName"),
            o) ? (h.Eet = t,
            h.eSt = o,
            r && (s = r.clientX,
            n = r.clientY,
            h.adt = r),
            void 0 !== s && void 0 !== n && (h.clientX = s,
            h.clientY = n),
            h.QFt = e ? t.sit(h.eSt) : null,
            this.dispatchEvent(h)) : void 0
        }
        CXi(t, i, e, s) {
            if (this.PXi())
                return;
            let n = new RM.Event(t);
            return n.table = this,
            s && (i = s.clientX,
            e = s.clientY,
            n.adt = s),
            void 0 !== i && void 0 !== e && (n.clientX = i,
            n.clientY = e),
            this.dispatchEvent(n)
        }
        BA() {
            return this.JPi
        }
        eP(t) {
            t = !!t,
            this.JPi !== t && (this.JPi = t,
            this.JPi ? this.Hqi.style.display = "" : this.Hqi.style.display = "none")
        }
        S5() {
            const t = {};
            if (t.scrollLeft = this.Qqi,
            t.scrollTop = this.x5t,
            this.Xqi.size) {
                const i = [];
                for (let t of this.Xqi.values())
                    i.push({
                        number: t.NXi(),
                        selected: t.Ez()
                    });
                t.selectedRows = i
            } else
                t.selectedRows = null;
            return t.columnsUIStateJson = this.Kqi.cXi().map(t => t.S5()),
            t
        }
        Q3(t, i) {
            if (t) {
                if (RM.ub(t.scrollLeft) && (this.L_.scrollLeft = t.scrollLeft,
                this.Qqi = t.scrollLeft),
                RM.ub(t.scrollTop) && (this.L_.scrollTop = t.scrollTop,
                this.x5t = t.scrollTop),
                t.selectedRows && t.selectedRows.length) {
                    this.MXi();
                    for (let i of t.selectedRows)
                        for (let t of this.rows())
                            t.NXi() === i.number && i.selected && t._5();
                    this.EXi(),
                    this.TXi() && this.CXi("rowsselected")
                }
                if (t.columnsUIStateJson && t.columnsUIStateJson.length)
                    for (const e of t.columnsUIStateJson) {
                        const t = this.Kqi.jXi(e.id);
                        t && t.Q3(e, i)
                    }
                this.Zqi(),
                this.PF(),
                this.zSt()
            }
        }
    }
}
{
    const LM = self.t
      , BM = 10
      , UM = {
        ZVt: !1,
        cursor: ""
    };
    LM.Qs.Fk.Table.uvt = class extends LM.Event.v_ {
        constructor(t, i, e, s) {
            LM.U(i, LM.Qs.Fk.Table),
            e = !!e,
            super(),
            this.Tet = i,
            this.Kc = t,
            this.$Xi = e,
            this.bWt = !1,
            this.JPi = !0,
            this.Kqi = i.IXi(),
            this.zXi = LM.Qs.W_("ui-table-row"),
            this.zXi.setAttribute("tabindex", -1),
            this.$Xi && this.zXi.setAttribute("filler", ""),
            this.$Xi ? this.Tet.GXi().appendChild(this.zXi) : this.Tet.AXi(this.zXi),
            this.VXi = [],
            this.WXi = new Set,
            this.HXi = this.Kqi.cXi(),
            this.KXi = [];
            for (let t = 0; t < this.HXi.length; t++) {
                let i, e = this.HXi[t], s = e.Wxt(), n = e.zo();
                const r = Object.assign({}, e.Wrt());
                r.qXi = r.Fet,
                r.XXi = e,
                r.YXi = !1,
                i = e.fXi() && t === this.HXi.length - 1 ? LM.v(LM.Qs.Fk.Table.avt, this.Tet, this.zXi, -1, s, r) : LM.v(LM.Qs.Fk.Table.avt, this.Tet, this.zXi, n, s, r),
                e.JXi(i),
                this.KXi.push(i)
            }
            this.MB = t => this.yO(t),
            this.yWt = t => this.vO(t),
            this.GB = t => this.gO(t),
            this.HDi = t => this._Ui(t),
            this.qDi = t => this.xft(t),
            this.n5t = -1,
            this.EY = 0,
            this.DY = 0,
            this.q0 = !1,
            this.mF = null,
            this.cG = null,
            this.uG = null,
            this.KLi = null,
            this.zXi.addEventListener("UIDoubleTap", this.yWt),
            this.$Xi || (this.zXi.addEventListener("focus", this.HDi),
            this.zXi.addEventListener("UITap", this.MB),
            this.Tet.gXi() && this.zXi.addEventListener("blur", this.qDi),
            this.Tet.lNi() && (this.mF = t => this.mO(t),
            this.cG = t => this.fG(t),
            this.uG = t => this.dG(t),
            this.KLi = t => this.IN(t),
            this.zXi.addEventListener("pointerdown", this.mF))),
            this.zXi.addEventListener("contextmenu", this.GB)
        }
        he() {
            this.Tet.DXi() === this && this.Tet.Hnt();
            for (let t of this.VXi)
                t.he();
            for (let t of this.KXi)
                t.he();
            LM.Io(this.KXi),
            LM.Io(this.VXi),
            this.WXi.clear(),
            this.I6(!1),
            LM.Qs.UO(this.zXi),
            this.zXi.removeEventListener("focus", this.HDi),
            this.HDi = null,
            this.zXi.removeEventListener("blur", this.qDi),
            this.qDi = null,
            this.zXi.removeEventListener("UITap", this.MB),
            this.MB = null,
            this.zXi.removeEventListener("UIDoubleTap", this.yWt),
            this.yWt = null,
            this.zXi.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.FO().removeEventListener("pointermove", this.cG),
            this.cG = null,
            this.FO().removeEventListener("pointerup", this.uG),
            this.uG = null,
            this.FO().removeEventListener("pointercancel", this.KLi),
            this.KLi = null,
            this.zXi.removeEventListener("contextmenu", this.GB),
            this.GB = null,
            this.WXi = null,
            this.VXi = null,
            this.zXi = null,
            this.HXi = null,
            this.Tet = null,
            this.Kc = null,
            this.Kqi = null,
            this.KXi = null,
            super.he()
        }
        PF() {
            for (const t of this.VXi)
                t.PF();
            for (const t of this.KXi)
                t.PF()
        }
        zSt() {
            const t = t => t.zSt();
            return !!this.HXi.some(t) || !!this.KXi.some(t)
        }
        Do() {
            return this.Kc
        }
        VFt() {
            return this.Tet
        }
        k_() {
            return this.zXi
        }
        FO() {
            return this.k_().ownerDocument
        }
        NXi() {
            return Array.prototype.indexOf.call(this.zXi.parentElement.children, this.zXi)
        }
        sit(t) {
            LM.zt(t);
            for (let i of this.VXi)
                if (i.ZXi() === t)
                    return i;
            return null
        }
        gNi() {
            for (let t of this.VXi)
                t.hb() && t.gNi()
        }
        Xet(t, i, e) {
            LM.zt(t),
            this.QXi(t),
            e = Object.assign({}, UM, e);
            let s = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.tYi, s, i, e)),
            this
        }
        jVt(t, i, e) {
            LM.zt(t),
            this.QXi(t),
            e = Object.assign({}, UM, e);
            let s = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.iYi, s, i, e)),
            this
        }
        KVt(t, i, e, s) {
            LM.zt(t),
            this.QXi(t),
            (s = Object.assign({}, UM, s)).table = this.Tet,
            s.Eet = this,
            s.eYi = e;
            let n = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.sYi, n, i, s)),
            this
        }
        nYi(t, i, e) {
            LM.zt(t),
            this.QXi(t),
            e = Object.assign({}, UM, e);
            let s = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.rYi, s, i, e)),
            this
        }
        Yet(t, i, e) {
            LM.zt(t),
            this.QXi(t),
            e = Object.assign({}, UM, e);
            let s = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.hYi, s, i, e)),
            this
        }
        ZBt(t, i, e) {
            LM.zt(t),
            i && LM.U(i, i.ownerDocument.defaultView.DocumentFragment),
            this.QXi(t),
            e = Object.assign({}, UM, e);
            let s = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.oYi, s, i, e)),
            this
        }
        tit(t, i, e) {
            LM.zt(t),
            this.QXi(t),
            (e = Object.assign({}, UM, e)).table = this.Tet,
            e.Eet = this;
            let s = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.aYi, s, i, e)),
            this
        }
        Qet(t, i, e) {
            LM.zt(t),
            this.QXi(t),
            (e = Object.assign({}, UM, e)).table = this.Tet,
            e.Eet = this;
            let s = this.zXi.querySelector(`[columnName="${t}"]`);
            return this.VXi.push(LM.v(LM.Qs.Fk.Table.lYi, s, i, e)),
            this
        }
        QXi(t) {
            if (this.WXi.has(t))
                throw new Error(`field '${t}' has already been set`);
            if (!this.HXi.some(i => i.Wxt() === t))
                throw new Error(`field '${t}' does not exist`);
            this.WXi.add(t)
        }
        yO(t) {
            this.Tet.UXi(this, "rowtapped", t.target, t.clientX, t.clientY, t)
        }
        vO(t) {
            this.$Xi ? this.Tet.CXi("tablespacedoubletap", t.clientX, t.clientY, t) : this.Tet.UXi(this, "rowdoubletapped", t.target, t.clientX, t.clientY, t)
        }
        gO(t) {
            t.preventDefault(),
            t.stopPropagation(),
            this.$Xi ? this.Tet.CXi("tablecontextmenu", t.clientX, t.clientY, t) : this.Tet.UXi(this, "rowcontextmenu", t.target, t.clientX, t.clientY, t)
        }
        eP(t) {
            t = !!t,
            this.JPi !== t && (this.JPi = t,
            this.JPi ? this.zXi.style.display = "" : this.zXi.style.display = "none")
        }
        _5(t) {
            this.Ez() || (this.Tet.hNi() && LM.bk.eDt() || this.Tet.vFt(),
            this.I6(!0))
        }
        vvt() {
            this.I6(!1)
        }
        I6(t) {
            t = !!t,
            this.bWt !== t && (t ? (this.zXi.setAttribute("selected", ""),
            this.Tet.UXi(this, "rowselected"),
            this.Tet.vXi(this)) : (this.zXi.removeAttribute("selected"),
            this.Tet.UXi(this, "rowunselected"),
            this.Tet.xXi(this)),
            this.bWt = t)
        }
        Ez() {
            return this.bWt
        }
        _Ui(t) {
            this._5()
        }
        xft(t) {
            this.Tet.hNi() ? LM.bk.eDt() || this.Tet.vFt() : this.I6(!1)
        }
        gz(t, i) {
            if (LM.Ge(t),
            LM.Ge(i),
            this.$Xi)
                return null;
            let e = this.zXi.getBoundingClientRect();
            if (t < e.left || t > e.right || i < e.top || i > e.bottom)
                return null;
            let s = e.bottom - e.top;
            return {
                Mnt: i >= e.top + s / 2 ? "after" : "before"
            }
        }
        f1() {
            this.FO().removeEventListener("pointermove", this.cG),
            this.FO().removeEventListener("pointerup", this.uG),
            this.FO().removeEventListener("pointercancel", this.KLi),
            this.q0 = !1,
            this.n5t = -1
        }
        mO(t) {
            t.button === LM.gF.sV && (this.Tet.bXi() || -1 === this.n5t && (this.FO().addEventListener("pointermove", this.cG),
            this.FO().addEventListener("pointerup", this.uG),
            this.FO().addEventListener("pointercancel", this.KLi),
            this.n5t = t.pointerId,
            this.EY = t.clientX,
            this.DY = t.clientY,
            this.q0 = !1))
        }
        fG(t) {
            if (t.preventDefault(),
            t.pointerId === this.n5t && !this.Tet.bXi()) {
                if (this.Tet.lNi() && !this.q0 && LM.di(this.EY, this.DY, t.clientX, t.clientY) >= BM) {
                    if (!this.Tet.UXi(this, "dragstart", t.target, t.clientX, t.clientY, t))
                        return this.n5t = -1,
                        this.FO().removeEventListener("pointermove", this.cG),
                        this.FO().removeEventListener("pointerup", this.uG),
                        void this.FO().removeEventListener("pointercancel", this.KLi);
                    this.q0 = !0,
                    this.Tet.hFt(this)
                }
                this.q0 && (this.Tet.UXi(this, "dragmove", null, t.clientX, t.clientY, t),
                this.Tet.nFt(t.clientX, t.clientY))
            }
        }
        dG(t) {
            if (t.pointerId !== this.n5t)
                return;
            const i = this.q0;
            if (this.f1(),
            i) {
                if (!this.Tet)
                    return;
                this.Tet.lXi(),
                this.Tet.UXi(this, "drop", null, t.clientX, t.clientY, t)
            }
        }
        IN(t) {
            this.dG(t)
        }
    }
}
{
    const NM = self.t
      , jM = 3;
    NM.Qs.Fk.Table.avt = class extends NM.Event.v_ {
        constructor(t, i, e, s, n) {
            NM.U(t, NM.Qs.Fk.Table),
            NM.ibt(i),
            NM.Ge(e),
            NM.gL(s),
            NM.J1(n),
            super(),
            this.Tet = t,
            this.c8 = i,
            this.$c = e,
            this.Rdi = s,
            this.bht = n,
            this.ght = null,
            this.uYi = null,
            this.cYi = null,
            this.dYi = null,
            this.fYi = null,
            this.KXi = null,
            this.pYi = 0,
            this.mYi = 0,
            this.wYi = 0,
            this.gYi = -1,
            this.yYi = -1,
            this.bYi = !!this.bht.YXi,
            this.vYi = this.bht.XXi,
            this.SYi = "",
            this.ght = s ? NM.Qs.W_("ui-table-column", i, null, null, {
                columnName: s
            }) : NM.Qs.W_("ui-table-column", i),
            this.bYi && this.ght.setAttribute("top-row-column", ""),
            this.ght.setAttribute("horizontal-align", n.qXi),
            this.ght.setAttribute("has-size-styles", ""),
            this.ght.setAttribute("current-size", ""),
            this.ght.setAttribute("min-size", this.bht.Yzt),
            e && -1 !== e ? (this.ght.style.width = `${e}px`,
            this.ght.setAttribute("current-size", `${e}px`),
            this.ght.style.maxWidth = `${e}px`,
            this.ght.style.minWidth = `${e}px`) : (this.ght.removeAttribute("has-size-styles"),
            this.ght.style.width = `${this.bht.Yzt}px`,
            this.ght.setAttribute("current-size", `${this.bht.Yzt}px`)),
            this.xYi = -1,
            this.aft = t => this.mO(t),
            this.pft = t => this.fG(t),
            this.dft = t => this.dG(t),
            this.MYi = t => this.EYi(t),
            this.WWi = t => this.IN(t),
            this.ght.addEventListener("pointerdown", this.aft),
            this.ght.addEventListener("pointermove", this.MYi)
        }
        he() {
            this.ght.removeEventListener("pointerdown", this.aft),
            this.ght.removeEventListener("pointermove", this.MYi),
            this.Tet.FO().removeEventListener("pointermove", this.pft, {
                passive: !0
            }),
            this.Tet.FO().removeEventListener("pointerup", this.dft),
            this.Tet.FO().removeEventListener("pointercancel", this.WWi),
            NM.Qs.UO(this.ght),
            this.uYi && NM.Io(this.uYi),
            this.cYi && NM.Io(this.cYi),
            this.KXi && NM.Io(this.KXi),
            this.aft = null,
            this.pft = null,
            this.dft = null,
            this.MYi = null,
            this.uYi = null,
            this.dYi = null,
            this.cYi = null,
            this.fYi = null,
            this.KXi = null,
            this.Tet = null,
            this.c8 = null,
            this.ght = null,
            this.bht = null,
            this.vYi = null,
            super.he()
        }
        dXi() {
            this.KXi && NM.Io(this.KXi)
        }
        PF() {
            if (!this.fXi())
                return;
            this.CYi();
            const t = this._Yi();
            -1 !== t && this.TYi(t)
        }
        zSt() {
            this.CYi();
            const t = this.zo()
              , i = Number(this.ght.getAttribute("min-size"));
            return t !== i && (-1 !== i && -1 !== t && t < i && (this.IYi(i),
            !0))
        }
        k_() {
            return this.ght
        }
        Wrt() {
            return this.bht
        }
        fXi() {
            return -1 === this.$c
        }
        PYi() {
            return 0 === this.GYi(this.ght)
        }
        AYi() {
            return this.GYi(this.ght) === this.Tet.IXi().cXi().length - 1
        }
        Wxt() {
            return this.Rdi
        }
        CYi() {
            this.xYi = -1
        }
        pXi() {
            return Number(this.ght.getAttribute("min-size"))
        }
        mXi() {
            const t = getComputedStyle(this.ght);
            return this.ght.getBoundingClientRect().width + parseInt(t.padding) + parseInt(t.borderWidth)
        }
        RYi() {
            return parseFloat(this.ght.style.width)
        }
        TYi(t) {
            NM.Ge(t);
            const i = `${t}px`;
            this.ght.style.width = i,
            this.ght.removeAttribute("has-size-styles"),
            this.fXi() || (this.ght.setAttribute("has-size-styles", ""),
            this.ght.style.maxWidth = i,
            this.ght.style.minWidth = i,
            this.zr(t))
        }
        IYi(t) {
            NM.Ge(t),
            this.uYi = this.kYi(0);
            for (let i of this.uYi) {
                const e = `${t}px`;
                i.style.width = e,
                i.removeAttribute("has-size-styles"),
                this.fXi() || (i.setAttribute("has-size-styles", ""),
                i.style.maxWidth = e,
                i.style.minWidth = e)
            }
            if (this.zr(t),
            this.OYi())
                for (const i of this.OYi())
                    i.zr(t);
            NM.Io(this.uYi),
            this.uYi = null
        }
        _Yi() {
            return this.bYi ? this.zo() : -1 === this.$c ? (this.xYi = this.vYi.zo(),
            this.xYi) : this.$c
        }
        zo() {
            if (-1 !== this.xYi)
                return this.xYi;
            if (-1 === this.$c) {
                let t = getComputedStyle(this.ght)
                  , i = parseInt(t.width);
                return NM.ub(i) && (this.xYi = i),
                this.xYi
            }
            return this.$c
        }
        zr(t) {
            NM.Ge(t),
            -1 !== this.$c && (this.$c = t)
        }
        JXi(t) {
            NM.U(t, NM.Qs.Fk.Table.avt),
            this.KXi || (this.KXi = []),
            this.KXi.push(t)
        }
        OYi() {
            return this.KXi
        }
        f1() {
            this.IN()
        }
        GYi(t) {
            const i = Array.prototype.filter.call(t.parentNode.childNodes, t => "ui-table-column" === t.tagName.toLowerCase());
            return Array.prototype.indexOf.call(i, t)
        }
        kYi(t) {
            NM.Ge(t);
            let i = this.GYi(this.ght) + t
              , e = this.Tet.k_().getElementsByTagName("ui-table-column");
            return 0 === t ? this.dYi = this.Tet.IXi().cXi()[i] : this.fYi = this.Tet.IXi().cXi()[i],
            Array.prototype.filter.call(e, t => this.GYi(t) === i)
        }
        mO(t) {
            if (!this.Tet.Q$())
                return;
            this.Tet.PF();
            let i = this.ght
              , e = i.getBoundingClientRect()
              , s = t.clientX - e.left;
            if (this.pYi = t.clientX,
            i.style.width)
                this.mYi = parseFloat(i.style.width);
            else {
                let t = parseInt(getComputedStyle(i).padding);
                this.mYi = e.width - 2 * t
            }
            if (s <= jM) {
                if (this.PYi())
                    return;
                return this.Tet.yXi(!0, this),
                this.SYi = "left",
                this.uYi = this.kYi(0),
                this.cYi = this.kYi(-1),
                this.fYi && (this.fYi.CYi(),
                this.wYi = this.fYi.zo()),
                this.Tet.FO().addEventListener("pointermove", this.pft, {
                    passive: !0
                }),
                this.Tet.FO().addEventListener("pointerup", this.dft),
                this.Tet.FO().addEventListener("pointercancel", this.WWi),
                this.ght.removeEventListener("pointermove", this.MYi),
                void this.Tet.CXi("columnresizestart", void 0, void 0, t)
            }
            return s >= e.width - jM ? (this.Tet.yXi(!0, this),
            this.SYi = "right",
            this.uYi = this.kYi(0),
            this.cYi = this.kYi(1),
            this.fYi && (this.fYi.CYi(),
            this.wYi = this.fYi.zo()),
            this.Tet.FO().addEventListener("pointermove", this.pft),
            this.Tet.FO().addEventListener("pointerup", this.dft),
            this.Tet.FO().addEventListener("pointercancel", this.WWi),
            this.ght.removeEventListener("pointermove", this.MYi, {
                passive: !0
            }),
            void this.Tet.CXi("columnresizestart", void 0, void 0, t)) : void 0
        }
        DYi(t, i) {
            NM.Ge(t),
            NM.RH(i);
            const e = `${Math.floor(t)}px`;
            for (let t of i) {
                if (t.getAttribute("current-size") === e)
                    continue;
                t.setAttribute("current-size", e),
                t.style.width = e;
                const i = t.hasAttribute("has-size-styles");
                i && (t.style.maxWidth = e),
                i && (t.style.minWidth = e)
            }
        }
        fG(t) {
            const i = this.Tet.wXi();
            let e = Math.floor((t.clientX - this.pYi) / i);
            "left" === this.SYi && (e *= -1),
            this.gYi = this.mYi + e;
            let s = Number(this.ght.getAttribute("min-size"));
            if (s = -1 === s ? 0 : s,
            this.gYi < s)
                return this.gYi = s,
                this.DYi(this.gYi, this.uYi),
                void (this.fYi && (this.yYi = this.wYi + (this.mYi - s),
                this.DYi(this.yYi, this.cYi)));
            if (this.fYi) {
                this.yYi = this.wYi - e;
                let t = Number(this.cYi[0].getAttribute("min-size"));
                if (t = -1 === t ? 0 : t,
                this.yYi < t)
                    return this.yYi = t,
                    this.DYi(this.yYi, this.cYi),
                    this.gYi = this.mYi + (this.wYi - t),
                    void this.DYi(this.gYi, this.uYi)
            }
            this.DYi(this.gYi, this.uYi),
            this.DYi(this.yYi, this.cYi),
            this.Tet.CXi("columnresizeupdate", void 0, void 0, t)
        }
        EYi(t) {
            if (!this.Tet.Q$())
                return;
            let i = this.ght
              , e = i.getBoundingClientRect()
              , s = t.clientX - e.left;
            return s <= jM ? 0 === this.GYi(i) ? void this.Tet.k_().removeAttribute("resizing-column") : void this.Tet.k_().setAttribute("resizing-column", "") : s >= e.width - jM ? this.fXi() && this.AYi() ? void this.Tet.k_().removeAttribute("resizing-column") : void this.Tet.k_().setAttribute("resizing-column", "") : void this.Tet.k_().removeAttribute("resizing-column")
        }
        dG(t) {
            if (this.dYi && -1 !== this.gYi) {
                let t = this.gYi > 0 ? this.gYi : 0;
                if (this.dYi.zr(t),
                this.dYi.OYi())
                    for (let i of this.dYi.OYi())
                        i.zr(t)
            }
            if (this.fYi && -1 !== this.yYi) {
                let t = this.yYi > 0 ? this.yYi : 0;
                if (this.fYi.zr(t),
                this.fYi.OYi())
                    for (let i of this.fYi.OYi())
                        i.zr(t)
            }
            NM.Io(this.uYi),
            NM.Io(this.cYi),
            this.gYi = -1,
            this.yYi = -1,
            this.dYi = null,
            this.fYi = null,
            this.SYi = "",
            this.Tet.yXi(!1),
            this.Tet.k_().removeAttribute("resizing-column"),
            this.Tet.FO().removeEventListener("pointermove", this.pft, {
                passive: !0
            }),
            this.Tet.FO().removeEventListener("pointerup", this.dft),
            this.Tet.FO().removeEventListener("pointercancel", this.WWi),
            this.ght.addEventListener("pointermove", this.MYi),
            this.Tet.CXi("columnresize", void 0, void 0, t),
            this.Tet.CXi("columnresizeend", void 0, void 0, t)
        }
        IN(t) {
            this.Tet && this.Tet.bXi() && this.dG(t)
        }
        S5() {
            const t = {};
            if (t.id = this.Wxt(),
            t.computedSize = this.fXi() ? -1 : this.RYi(),
            t.hasSizeStyle = this.ght.hasAttribute("has-size-styles"),
            t.currentSize = this.ght.hasAttribute("current-size") ? this.ght.getAttribute("current-size") : "",
            this.ght.style.width)
                t.currentColumnSize = parseFloat(this.ght.style.width);
            else {
                let i = this.ght.getBoundingClientRect()
                  , e = parseInt(getComputedStyle(this.ght).padding);
                t.currentColumnSize = i.width - 2 * e
            }
            return this.fYi && (this.fYi.CYi(),
            t.currentAdjacentColumnSize = this.fYi.zo()),
            t
        }
        Q3(t, i) {
            if (t) {
                if (t.hasOwnProperty("hasSizeStyle") && this.ght.setAttribute("has-size-styles", ""),
                t.hasOwnProperty("computedSize") && this.IYi(t.computedSize),
                t.hasOwnProperty("currentColumnSize") && this.dYi) {
                    const i = t.currentColumnSize > 0 ? t.currentColumnSize : 0;
                    if (this.dYi.zr(i),
                    this.dYi.OYi())
                        for (const t of this.dYi.OYi())
                            t.zr(i)
                }
                if (t.hasOwnProperty("currentAdjacentColumnSize") && this.fYi && this.dYi) {
                    const i = t.currentAdjacentColumnSize > 0 ? t.currentAdjacentColumnSize : 0;
                    if (this.fYi.zr(i),
                    this.dYi.OYi())
                        for (const t of this.fYi.OYi())
                            t.zr(i)
                }
            }
        }
    }
}
{
    const $M = self.t
      , zM = self.assert
      , VM = {
        qXi: "left",
        qVt: "left",
        Fet: "left",
        Yzt: -1,
        YXi: !1
    }
      , WM = ["left", "center", "right"];
    $M.Qs.Fk.Table.RXi = class extends $M.Event.v_ {
        constructor(t) {
            super(),
            this.Tet = t,
            this.ght = $M.Qs.W_("ui-table-row"),
            this.ght.setAttribute("topRow", ""),
            this.Tet.k_().appendChild(this.ght),
            this.FYi = !1,
            this.HXi = [],
            this.HOi = t => {
                t.preventDefault(),
                this.Tet.CXi("tablecontextmenu", t.clientX, t.clientY, t)
            }
            ,
            this.ght.addEventListener("contextmenu", this.HOi)
        }
        he() {
            this.ght.removeEventListener("contextmenu", this.HOi),
            this.HOi = null,
            $M.Qs.UO(this.ght),
            this.ght = null;
            for (let t of this.HXi)
                t.he();
            $M.Io(this.HXi),
            this.HXi = null,
            this.Tet = null,
            this.FYi = !1,
            super.he()
        }
        k_() {
            return this.ght
        }
        cXi() {
            return this.HXi
        }
        jXi(t) {
            $M.zt(t);
            for (const i of this.HXi)
                if (i.Wxt() === t)
                    return i
        }
        LYi(t) {
            return $M.U(t, $M.Qs.Fk.Table.avt),
            -1 !== this.HXi.indexOf(t)
        }
        Get(t, i, e, s) {
            if ($M.zt(t),
            $M.Ge(i),
            $M.gL(e),
            $M.ML(s),
            this.FYi)
                throw new Error("only one auto sizing column at the end of the table is allowed");
            s = Object.assign({}, VM, s),
            zM(WM.includes(s.qVt), `unexpected header horizontal align value ${s.qVt}, supported values are ${WM}`),
            zM(WM.includes(s.Fet), `unexpected content horizontal align value ${s.Fet}, supported values are ${WM}`),
            s.qXi = s.qVt,
            s.YXi = !0;
            let n = $M.v($M.Qs.Fk.Table.avt, this.Tet, this.ght, i, t, s);
            if (n.k_().classList.add("top-row-column"),
            e) {
                $M.Qs.W_("div", n.k_()).textContent = e
            }
            return this.HXi.push(n),
            this
        }
        jet(t, i, e) {
            $M.zt(t),
            $M.gL(i),
            $M.ML(e),
            this.Get(t, -1, i, e),
            this.Tet.k_().setAttribute("flex-filler", ""),
            this.FYi = !0
        }
    }
}
{
    const HM = self.t;
    HM.Qs.Fk.Table.BYi = class {
        constructor() {
            this.UYi = !1
        }
        ZXi() {
            HM.kK()
        }
        he() {
            HM.kK()
        }
        PF() {
            HM.kK()
        }
        k_() {
            HM.kK()
        }
        hb() {
            return this.UYi
        }
    }
}
{
    const KM = self.t
      , qM = {
        ZVt: !1,
        cursor: null,
        JVt: null
    };
    KM.Qs.Fk.Table.tYi = class extends KM.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            KM.ibt(t),
            super(),
            this.BGt = null,
            e = Object.assign({}, qM, e),
            KM.Bm(i, KM.Qs.d0) && (this.BGt = KM.v(KM.Qs._q, i || {}, t),
            this.NYi(e, this.BGt.k_())),
            KM.Bm(i, KM.Qs.YRi) && (this.BGt = KM.Qs.W_("div"),
            t.appendChild(this.BGt),
            i.HGt().then(t => {
                this.jYi(t, e, this.BGt),
                this.NYi(e, this.BGt),
                this.BGt && this.c8 && this.BGt.appendChild(t)
            }
            )),
            this.c8 = t,
            this.c8.setAttribute("icon", "")
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        he() {
            KM.Bm(this.BGt, KM.Qs._q) ? this.BGt.he() : KM.Qs.UO(this.BGt),
            this.BGt = null,
            this.c8 = null
        }
        PF() {}
        k_() {
            return KM.Bm(this.BGt, KM.Qs._q) ? this.BGt.k_() : this.BGt
        }
        m0(t) {
            KM.Bm(this.BGt, KM.Qs._q) && this.BGt.m0(t)
        }
        NYi(t, i) {
            (this.BGt || this.c8) && (t.ZVt ? i.classList.add("table-column-content-with-pointer") : i.classList.add("table-column-content"),
            t.cursor && (i.style.cursor = t.cursor))
        }
        jYi(t, i, e) {
            (this.BGt || this.c8) && (i.JVt && KM.ub(i.JVt.width) && (e.style.width = `${i.JVt.width}px`),
            i.JVt && KM.ub(i.JVt.height) && (e.style.height = `${i.JVt.height}px`),
            i.JVt && KM.ub(i.JVt.width) && t.setAttribute("width", i.JVt.width),
            i.JVt && KM.ub(i.JVt.height) && t.setAttribute("height", i.JVt.height))
        }
    }
}
{
    const XM = self.t
      , YM = self.assert;
    XM.Qs.Fk.Table.hYi = class extends XM.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            XM.ibt(t),
            super();
            const s = typeof i;
            YM("function" === s || "string" === s || "number" === s || "object" === s, "unexpected type"),
            this.hy = XM.Qs.W_("div", t, null, "table-column-content"),
            this.$Yi = "function" === s ? i : null,
            XM.wQ(this.hy, "function" === s ? i() : i),
            this.c8 = t
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        he() {
            XM.Qs.UO(this.hy),
            this.hy = null,
            this.c8 = null,
            this.$Yi = null
        }
        PF() {
            this.$Yi && this.hy && XM.wQ(this.hy, this.$Yi())
        }
        ha(t) {
            XM.p0(t),
            XM.wQ(this.hy, t)
        }
        iSt() {
            return this.hy.textContent
        }
        k_() {
            return this.hy
        }
    }
}
{
    const JM = self.t
      , ZM = self.assert;
    JM.Qs.Fk.Table.rYi = class extends JM.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            JM.ibt(t),
            super();
            const s = typeof i;
            ZM("function" === s || "string" === s || "number" === s || "object" === s, "unexpected type"),
            this.zYi = JM.Qs.W_("div", t, null, "table-column-content"),
            this.VYi = "function" === s ? i : null,
            JM.wQ(this.zYi, "function" === s ? i().toString() : i.toString()),
            this.c8 = t
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        he() {
            JM.Qs.UO(this.zYi),
            this.zYi = null,
            this.c8 = null,
            this.VYi = null
        }
        PF() {
            this.VYi && this.zYi && JM.wQ(this.zYi, this.VYi().toString())
        }
        k_() {
            return this.zYi
        }
    }
}
{
    const QM = self.t
      , tE = self.assert
      , iE = 30;
    QM.Qs.Fk.Table.iYi = class extends QM.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            QM.ibt(t),
            super();
            const s = typeof i;
            tE("function" === s || "string" === s || "number" === s || "object" === s, "unexpected type"),
            this.c8 = t,
            this.WYi = "function" === s ? i() : i,
            this.$Yi = "function" === s ? i : null,
            this.hy = QM.Qs.W_("div", this.c8, null, "table-column-content"),
            QM.wQ(this.hy, this.WYi),
            this.uVt = null,
            this.pji = null,
            this.HYi = null,
            this.cji = null,
            this.aFi = null,
            this.KYi = null,
            this.qYi = t => this.gji(),
            this.UYi = !0,
            this.XYi = NaN
        }
        he() {
            this.$ji(),
            QM.Qs.UO(this.hy),
            this.WYi = null,
            this.hy = null,
            this.c8 = null,
            this.pji = null,
            this.HYi = null,
            this.cji = null,
            this.aFi = null,
            this.KYi = null,
            this.qYi = null,
            this.$Yi = null,
            QM.ub(this.XYi) && (self.clearTimeout(this.XYi),
            this.XYi = NaN)
        }
        PF() {
            this.$Yi && this.hy && (this.WYi = this.$Yi(),
            this.hy.textContent = this.WYi)
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        k_() {
            return this.hy
        }
        ha(t) {
            QM.zt(t),
            this.WYi = t,
            this.hy.textContent = this.WYi
        }
        iSt() {
            return this.WYi
        }
        mnt() {
            return this.uVt ? Promise.resolve(null) : this.c8 ? (this.uVt = QM.Qs.W_("input", this.c8, null, "table-edit-text"),
            this.uVt.classList.add("table-column-input"),
            this.uVt.type = "text",
            this.uVt.setAttribute("spellcheck", "false"),
            this.uVt.addEventListener("UITap", QM.Qs.DVt),
            this.uVt.addEventListener("UIDoubleTap", QM.Qs.DVt),
            this.XYi = window.setTimeout(t => {
                this.XYi = NaN,
                this.uVt && (this.cji = t => this.Rwi(),
                this.uVt.addEventListener("blur", this.cji),
                this.uVt.select())
            }
            , iE),
            this.aFi = t => this.jji(t),
            this.uVt.addEventListener("keydown", this.aFi, !0),
            this.c8.addEventListener("scroll", this.qYi, {
                passive: !0
            }),
            this.uVt.value = this.WYi,
            this.uVt.focus(),
            this.hy.textContent = "",
            new Promise( (t, i) => {
                this.pji = t,
                this.HYi = i
            }
            )) : Promise.resolve(null)
        }
        jji(t) {
            t.which === QM.Mk.aY ? (t.preventDefault(),
            t.stopPropagation(),
            this.Rwi()) : t.which === QM.Mk.VJ && (t.preventDefault(),
            t.stopPropagation(),
            this.gNi())
        }
        Rwi() {
            if (!this.uVt)
                return;
            let t = this.uVt.value;
            this.$ji(),
            this.pji && this.pji(t),
            this.pji = null,
            this.HYi = null
        }
        gNi() {
            this.uVt && (this.$ji(),
            this.pji && this.pji(null),
            this.pji = null,
            this.HYi = null)
        }
        $ji() {
            this.uVt && (this.WYi = this.uVt.value,
            this.hy.textContent = this.WYi,
            this.c8.removeEventListener("scroll", this.qYi, {
                passive: !0
            }),
            this.uVt.removeEventListener("keydown", this.aFi, !0),
            this.uVt.removeEventListener("blur", this.cji),
            this.uVt.removeEventListener("contextmenu", this.KYi),
            this.uVt.removeEventListener("UITap", QM.Qs.DVt),
            this.uVt.removeEventListener("UIDoubleTap", QM.Qs.DVt),
            QM.Qs.UO(this.uVt),
            this.aFi = null,
            this.cji = null,
            this.uVt = null)
        }
        gji() {
            this.uVt.style.left = `${this.hy.offsetLeft}px`,
            this.uVt.style.top = this.hy.offsetTop - this.c8.scrollTop + "px";
            let t = this.c8.getBoundingClientRect()
              , i = this.uVt.getBoundingClientRect();
            (i.bottom > t.bottom || i.top < t.top || i.left < t.left || i.right > t.right) && this.gNi()
        }
    }
}
{
    const eE = self.t
      , sE = self.assert
      , nE = 30;
    eE.Qs.Fk.Table.sYi = class extends eE.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            eE.ibt(t),
            super();
            let s = typeof e.eYi;
            sE("function" === s || "string" === s, "unexpected type'"),
            this.c8 = t,
            this.YYi = e.eYi,
            this.Tet = e.table,
            this.JYi = e.Eet,
            this.ZYi = e.XVt ? e.XVt : self.lang("common.ellipsis"),
            s = typeof i,
            sE("function" === s || "string" === s, "unexpected type"),
            this.$Yi = "function" === s ? i : null,
            this.rGt = eE.Qs.W_("div", this.c8, null, "table-column-content-long-text"),
            this.rGt.classList.add("table-column-content"),
            this.uVt = eE.Qs.W_("input", this.rGt),
            this.uVt.type = "text",
            this.uVt.value = "function" === s ? i() : i,
            this.uVt.setAttribute("spellcheck", "false"),
            this.uVt.setAttribute("autocomplete", "off"),
            this.OFi = eE.Qs.W_("button", this.rGt),
            this.OFi.textContent = this.ZYi,
            this.QYi = t => this.LFi(t),
            this.OFi.addEventListener("click", this.QYi),
            this.UYi = !0,
            this.tJi = null,
            this.XYi = NaN,
            this.pji = null,
            this.HYi = null,
            this.iJi = t => this.Rwi(),
            this.eJi = t => this.jji(t),
            this.qYi = t => this.gji()
        }
        he() {
            this.$ji(),
            this.tJi = null,
            this.pji = null,
            this.HYi = null,
            this.iJi = null,
            this.eJi = null,
            this.qYi = null,
            this.OFi.removeEventListener("click", this.QYi),
            this.QYi = null,
            eE.Qs.UO(this.OFi),
            this.OFi = null,
            eE.Qs.UO(this.uVt),
            this.uVt = null,
            eE.Qs.UO(this.rGt),
            this.rGt = null,
            this.c8 = null,
            this.YYi = null,
            this.Tet = null,
            this.JYi = null,
            this.$Yi = null
        }
        PF() {
            this.$Yi && this.uVt && (this.uVt.value = this.$Yi())
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        k_() {
            return this.rGt
        }
        iSt() {
            return this.uVt.value
        }
        oSt() {
            return this.tJi ? Promise.resolve(null) : this.c8 ? (this.tJi = eE.Qs.W_("input", this.c8, null, "long-table-edit-text"),
            this.tJi.classList.add("table-column-input"),
            this.tJi.type = "text",
            this.tJi.setAttribute("spellcheck", "false"),
            this.tJi.addEventListener("UITap", eE.Qs.DVt),
            this.tJi.addEventListener("UIDoubleTap", eE.Qs.DVt),
            this.XYi = window.setTimeout(t => {
                this.XYi = NaN,
                this.tJi && (this.tJi.addEventListener("blur", this.iJi),
                this.tJi.select())
            }
            , nE),
            this.tJi.addEventListener("keydown", this.eJi, !0),
            this.c8.addEventListener("scroll", this.qYi, {
                passive: !0
            }),
            this.tJi.value = this.uVt.value,
            this.tJi.focus(),
            this.uVt.textContent = ".",
            new Promise( (t, i) => {
                this.pji = t,
                this.HYi = i
            }
            )) : Promise.resolve(null)
        }
        mnt() {
            let t = eE.Qs.Ks.qs("LongTextPropertyDialog");
            switch (typeof this.YYi) {
            case "function":
                t.Wa(this.YYi());
                break;
            case "string":
                t.Wa(this.YYi)
            }
            const i = this.$Yi ? this.$Yi() : this.uVt.value;
            return t.Xa(i).then(t => null === t ? null : (this.uVt && (this.uVt.value = t),
            t))
        }
        LFi(t) {
            this.Tet.UXi(this.JYi, "longtextedittapped", this.c8, t.clientX, t.clientY, t)
        }
        jji(t) {
            t.which === eE.Mk.aY ? (t.preventDefault(),
            t.stopPropagation(),
            this.Rwi()) : t.which === eE.Mk.VJ && (t.preventDefault(),
            t.stopPropagation(),
            this.gNi())
        }
        Rwi() {
            if (!this.tJi)
                return;
            let t = this.tJi.value;
            this.$ji(),
            this.pji && this.pji(t),
            this.pji = null,
            this.HYi = null
        }
        gNi() {
            this.tJi && (this.$ji(),
            this.pji && this.pji(null),
            this.pji = null,
            this.HYi = null)
        }
        $ji() {
            this.tJi && (this.uVt.textContent = this.tJi.value,
            this.c8.removeEventListener("scroll", this.qYi, {
                passive: !0
            }),
            this.tJi.removeEventListener("keydown", this.eJi, !0),
            this.tJi.removeEventListener("blur", this.iJi),
            this.tJi.removeEventListener("UITap", eE.Qs.DVt),
            this.tJi.removeEventListener("UIDoubleTap", eE.Qs.DVt),
            eE.Qs.UO(this.tJi),
            this.tJi = null)
        }
        gji() {
            this.tJi.style.left = `${this.uVt.offsetLeft}px`,
            this.tJi.style.top = this.uVt.offsetTop - this.c8.scrollTop + "px";
            let t = this.c8.getBoundingClientRect()
              , i = this.tJi.getBoundingClientRect();
            (i.bottom > t.bottom || i.top < t.top || i.left < t.left || i.right > t.right) && this.gNi()
        }
    }
}
{
    const rE = self.t;
    rE.Qs.Fk.Table.oYi = class extends rE.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            if (rE.ibt(t),
            i && rE.Ef(i, i.ownerDocument.defaultView.DocumentFragment),
            super(),
            this.c8 = t,
            i) {
                let t = i.childNodes;
                for (let i = 0, e = t.length; i < e; i++)
                    t[i].classList.add("table-column-content"),
                    rE._ii(t[i]) && t[i].classList.add("table-column-input");
                this.c8.appendChild(i)
            }
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        he() {
            this.c8 = null
        }
        PF() {}
        k_() {
            return this.c8
        }
    }
}
{
    const hE = self.t
      , oE = self.assert;
    hE.Qs.Fk.Table.aYi = class extends hE.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            hE.ibt(t),
            super(),
            oE(hE.w9(i) || hE.B9(i), "unexpected type"),
            this.Tet = e.table,
            this.JYi = e.Eet,
            this.zFi = hE.Qs.W_("select", t, null, "table-column-content-select"),
            this.sJi = t => this.Cet(t),
            this.zFi.addEventListener("change", this.sJi),
            this.nJi = i,
            this.rJi(),
            hE.ub(e.selectedIndex) && -1 !== e.selectedIndex && (this.zFi.selectedIndex = e.selectedIndex),
            this.c8 = t
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        he() {
            this.zFi.removeEventListener("change", this.sJi),
            this.sJi = null,
            hE.Qs.UO(this.zFi),
            this.zFi = null,
            this.c8 = null,
            this.nJi = null,
            this.Tet = null,
            this.JYi = null
        }
        iSt() {
            return this.zFi.options[this.zFi.selectedIndex].textContent
        }
        Ft() {
            return this.zFi.value
        }
        Do() {
            const t = this.zFi.selectedIndex;
            if (hE.w9(this.nJi)) {
                const i = this.nJi()[t];
                if (hE.K9(i))
                    return null;
                if (hE.Jvt(i))
                    return i.userData
            }
            if (hE.B9(this.nJi)) {
                const i = this.nJi[t];
                if (hE.K9(i))
                    return null;
                if (hE.Jvt(i))
                    return i.userData
            }
            return null
        }
        PF() {
            const t = this.zFi.selectedIndex;
            this.nJi && this.zFi && (this.zFi.replaceChildren(),
            this.rJi(),
            this.zFi.selectedIndex = t)
        }
        k_() {
            return this.zFi
        }
        rJi() {
            if (hE.w9(this.nJi))
                for (const t of this.nJi()) {
                    if (hE.K9(t)) {
                        hE.Qs.W_("option", this.zFi).textContent = t
                    }
                    if (hE.Jvt(t)) {
                        hE.zt(t.value),
                        hE.zt(t.text);
                        const i = hE.Qs.W_("option", this.zFi);
                        i.value = t.value,
                        i.textContent = t.text
                    }
                }
            if (hE.B9(this.nJi))
                for (const t of this.nJi) {
                    if (hE.K9(t)) {
                        hE.Qs.W_("option", this.zFi).textContent = t
                    }
                    if (hE.Jvt(t)) {
                        hE.zt(t.value),
                        hE.zt(t.text);
                        const i = hE.Qs.W_("option", this.zFi);
                        i.value = t.value,
                        i.textContent = t.text
                    }
                }
        }
        Cet(t) {
            this.Tet.UXi(this.JYi, "selectoptionchange", this.c8, t.clientX, t.clientY, t)
        }
    }
}
{
    const aE = self.t
      , lE = self.assert;
    aE.Qs.Fk.Table.lYi = class extends aE.Qs.Fk.Table.BYi {
        constructor(t, i, e) {
            aE.ibt(t),
            super();
            const s = typeof i;
            lE("function" === s || "boolean" === s, "unexpected type"),
            this.Tet = e.table,
            this.JYi = e.Eet,
            this.uVt = aE.Qs.W_("input", t, null, "table-column-content"),
            this.uVt.type = "checkbox",
            this.hJi = t => this.Met(t),
            this.uVt.addEventListener("change", this.hJi),
            this.oJi = "function" === s ? i : null,
            this.uVt.checked = "function" === s ? !!this.oJi() : !!i,
            this.c8 = t
        }
        ZXi() {
            return this.c8.getAttribute("columnName")
        }
        he() {
            this.uVt.removeEventListener("change", this.hJi),
            this.hJi = null,
            aE.Qs.UO(this.uVt),
            this.uVt = null,
            this.c8 = null,
            this.oJi = null,
            this.Tet = null,
            this.JYi = null
        }
        PF() {
            this.oJi && this.uVt && (this.uVt.checked = !!this.oJi())
        }
        Svt(t) {
            this.uVt.checked = !!t
        }
        Ft() {
            return this.uVt.checked
        }
        k_() {
            return this.uVt
        }
        Met(t) {
            this.Tet.UXi(this.JYi, "checkboxchange", this.c8, t.clientX, t.clientY, t)
        }
    }
}
{
    const uE = self.t;
    uE.Qs.Fk.Eq = class extends uE.Event.v_ {
        constructor(t) {
            super(),
            uE.ibt(t),
            this.ght = uE.Qs.W_("ui-close-button", t),
            this.ght.setAttribute("title", self.lang("ui.controls.close-button.close-tooltip")),
            this.ght.setAttribute("aria-label", self.lang("ui.controls.close-button.close-tooltip")),
            this.ght.setAttribute("role", "button"),
            this.aOi = null,
            self.app.YVt("close").HGt().then(t => {
                uE.gn(this) || this.aJi(t)
            }
            ),
            this.onclick = null,
            this.DF = !0,
            this.lJi = t => this.uJi(t),
            this.ght.addEventListener("click", this.lJi),
            this.mF = t => this.mO(t),
            this.ght.addEventListener("pointerdown", this.mF),
            this.dn = !1
        }
        he() {
            this.dn = !0,
            uE.Qs.UO(this.aOi),
            this.aOi = null,
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.ght.removeEventListener("click", this.lJi),
            this.lJi = null,
            this.onclick = null,
            uE.Qs.UO(this.ght),
            this.ght = null,
            super.he()
        }
        aJi(t) {
            this.dn || (this.aOi = t,
            this.aOi.setAttribute("role", "none"),
            this.ght.appendChild(this.aOi))
        }
        k_() {
            return this.ght
        }
        uJi(t) {
            0 === t.button && this.DF && (t.stopPropagation(),
            this.onclick && this.onclick())
        }
        mO(t) {
            t.stopPropagation()
        }
        cA(t) {
            t = !!t,
            this.DF !== t && (this.DF = t,
            t ? (this.ght.classList.remove("disabled"),
            this.ght.setAttribute("title", self.lang("ui.controls.close-button.close-tooltip")),
            this.ght.setAttribute("aria-disabled", "true")) : (this.ght.classList.add("disabled"),
            this.ght.removeAttribute("title"),
            this.ght.removeAttribute("aria-disabled")))
        }
    }
}
{
    const cE = self.t;
    cE.Qs.Fk.DEi = class extends cE.Event.v_ {
        constructor(t) {
            super(),
            cE.ibt(t),
            this.VBi = self.lang("ui.controls.menu-dots-button.options-tooltip"),
            this.ght = cE.Qs.W_("ui-menu-dots-button", t),
            this.ght.setAttribute("title", this.VBi),
            this.ght.setAttribute("aria-label", this.VBi),
            this.aOi = null,
            self.app.YVt("menu-dots").HGt().then(t => {
                cE.gn(this) || this.aJi(t)
            }
            ),
            this.onclick = null,
            this.DF = !0,
            this.mF = t => this.mO(t),
            this.ght.addEventListener("pointerdown", this.mF),
            this.dn = !1
        }
        he() {
            this.dn = !0,
            cE.Qs.UO(this.aOi),
            this.aOi = null,
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.onclick = null,
            cE.Qs.UO(this.ght),
            this.ght = null,
            super.he()
        }
        aJi(t) {
            this.dn || (this.aOi = t,
            this.ght.appendChild(this.aOi))
        }
        k_() {
            return this.ght
        }
        mAi(t) {
            cE.zt(t),
            this.VBi = t,
            this.ght.setAttribute("title", this.VBi),
            this.ght.setAttribute("aria-label", this.VBi)
        }
        mO(t) {
            0 === t.button && this.DF && (t.stopPropagation(),
            this.onclick && this.onclick())
        }
        cA(t) {
            t = !!t,
            this.DF !== t && (this.DF = t,
            t ? (this.ght.classList.remove("disabled"),
            this.ght.setAttribute("title", this.VBi),
            this.ght.setAttribute("aria-disabled", "true")) : (this.ght.classList.add("disabled"),
            this.ght.removeAttribute("title"),
            this.ght.removeAttribute("aria-disabled")))
        }
    }
}
{
    const dE = self.t;
    dE.Qs.Fk.FEi = class extends dE.Event.v_ {
        constructor(t) {
            super(),
            dE.ibt(t),
            this.ght = dE.Qs.W_("ui-back-button"),
            t.insertBefore(this.ght, t.firstChild),
            this.ght.setAttribute("title", self.lang("ui.controls.back-button.back-tooltip")),
            this.ght.setAttribute("aria-label", self.lang("ui.controls.back-button.back-tooltip")),
            this.aOi = null,
            self.app.YVt("back").HGt().then(t => this.aJi(t)),
            this.onclick = null,
            this.mF = t => this.mO(t),
            this.ght.addEventListener("pointerdown", this.mF),
            this.KVi = !0,
            this.dn = !1
        }
        he() {
            this.dn = !0,
            dE.Qs.UO(this.aOi),
            this.aOi = null,
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            this.onclick = null,
            dE.Qs.UO(this.ght),
            this.ght = null,
            super.he()
        }
        aJi(t) {
            this.dn || (this.aOi = t,
            this.ght.appendChild(this.aOi))
        }
        eP(t) {
            this.KVi !== t && (this.ght.style.visibility = t ? "visible" : "hidden",
            this.KVi = t)
        }
        k_() {
            return this.ght
        }
        mO(t) {
            0 === t.button && (t.stopPropagation(),
            this.onclick && this.onclick())
        }
    }
}
{
    const fE = self.t;
    fE.Qs.Fk.cJi = class extends fE.Event.v_ {
        constructor(t) {
            fE.Rti(t, HTMLElement),
            super(),
            this.ght = t,
            this.Wgi = fE.v(fE.Rf, fE._f.Gf(this.ght, "keydown", t => this.wG(t)), fE._f.Gf(this.ght, "keypress", t => this.$ft(t)), fE._f.Gf(this.ght, "paste", t => this.uO(t)), fE._f.Gf(this.ght, "cut", t => this.cO(t)), fE._f.Gf(this.ght, "blur", t => this.xft(t))),
            this.j_t = [],
            this.X_t = [],
            this.pwi = null,
            this.dJi = new Map,
            this.dJi.set("delete", t => this.fJi(t)),
            this.dJi.set("backspace", t => this.pJi(t));
            const i = t => this.mJi(t, this.X_t, this.j_t)
              , e = t => this.mJi(t, this.j_t, this.X_t);
            fE.kt.hyt ? (this.dJi.set("cmd-shift-z", i),
            this.dJi.set("cmd-y", i),
            this.dJi.set("cmd-z", e)) : (this.dJi.set("ctrl-shift-z", i),
            this.dJi.set("ctrl-y", i),
            this.dJi.set("ctrl-z", e)),
            fE.Qs.eit(this.ght, "contenteditable", !0)
        }
        he() {
            this.ght = null,
            this.Wgi.Ff(),
            this.Wgi = null,
            fE.Io(this.j_t),
            fE.Io(this.X_t),
            this.j_t = null,
            this.X_t = null,
            this.pwi = null,
            this.dJi.clear(),
            this.dJi = null,
            super.he()
        }
        k_() {
            return this.ght
        }
        ha(t, i) {
            fE.zt(t),
            i = !!i,
            this.ght.textContent !== t && (i || this.XSt(),
            this.ght.textContent = t)
        }
        wJi(t) {
            const i = [];
            return fE.kt.hyt && t.metaKey && i.push("cmd"),
            t.ctrlKey && i.push("ctrl"),
            t.shiftKey && i.push("shift"),
            i.push(t.key.toLowerCase()),
            i.join("-")
        }
        gJi() {
            return fE.QRt.Wwi(this.ght)
        }
        yJi(t) {
            t && fE.QRt.YRt(this.ght, t.start, t.end)
        }
        XSt() {
            fE.Io(this.X_t);
            let t = this.ght.textContent
              , i = this.gJi();
            this.j_t.push( () => {
                const e = this.ght.textContent
                  , s = this.gJi();
                this.ght.textContent = t,
                this.yJi(i),
                t = e,
                i = s,
                this.ght.dispatchEvent(new Event("modified"))
            }
            )
        }
        xft(t) {
            this.pwi = null
        }
        wG(t) {
            const i = this.wJi(t)
              , e = this.dJi.get(i);
            e && e(t)
        }
        $ft(t) {
            const i = this.gJi();
            if (!i)
                return;
            const e = this.pwi
              , s = "Enter" === t.key ? "\n" : t.key;
            i.start === i.end ? (e && "insert" === e.type && e.cursor.end === i.end || this.XSt(),
            i.end = i.start = i.end + s.length,
            this.pwi = {
                type: "insert",
                cursor: i
            }) : (this.XSt(),
            i.end = i.start = i.start + s.length,
            this.pwi = {
                type: "insert",
                cursor: i
            })
        }
        uO(t) {
            const i = this.gJi();
            if (!i)
                return;
            t.preventDefault();
            const {start: e, end: s} = i
              , n = t.clipboardData.getData("text")
              , r = this.ght.textContent
              , h = r.slice(0, e) + n + r.slice(s);
            this.ha(h),
            i.end = i.start = e + n.length,
            this.yJi(i),
            this.ght.dispatchEvent(new Event("modified")),
            this.pwi = {
                type: "paste",
                cursor: i
            }
        }
        cO(t) {
            const i = this.gJi();
            i && (this.XSt(),
            i.end = i.start,
            this.pwi = {
                type: "cut",
                cursor: i
            })
        }
        fJi(t) {
            const i = this.gJi();
            if (!i)
                return;
            const e = this.pwi;
            i.start === i.end ? e && "delete" === e.type && e.cursor.end === i.end || (this.XSt(),
            this.pwi = {
                type: "delete",
                cursor: i
            }) : (this.XSt(),
            this.pwi = {
                type: "deleteRange",
                cursor: i
            })
        }
        pJi(t) {
            const i = this.gJi();
            if (!i)
                return;
            const e = this.pwi;
            i.start === i.end ? (e && "delete" === e.type && e.cursor.end === i.end || this.XSt(),
            i.end = i.start = i.end - 1,
            this.pwi = {
                type: "delete",
                cursor: i
            }) : (this.XSt(),
            i.end = i.start,
            this.pwi = {
                type: "deleteRange",
                cursor: i
            })
        }
        mJi(t, i, e) {
            t.preventDefault();
            const s = i.pop();
            s && (s(),
            e.push(s))
        }
    }
}
{
    const pE = self.t
      , mE = self.assert
      , wE = [{
        opacity: "1"
    }, {
        opacity: "0"
    }]
      , gE = [{
        transform: "scale(0.85)",
        opacity: "0"
    }, {
        transform: "scale(1)",
        opacity: "1"
    }]
      , yE = [{
        opacity: "0"
    }, {
        opacity: "1"
    }]
      , bE = {
        duration: 100,
        easing: "ease-out"
    }
      , vE = ["top-left", "top", "top-right", "left", "center", "right", "bottom-left", "bottom", "bottom-right"]
      , SE = ["right", "left"]
      , xE = 4
      , ME = {
        bJi: null,
        className: "",
        id: ""
    };
    let EE = null
      , CE = NaN;
    function _E(t) {
        EE && EE.fG(t)
    }
    pE.Qs.EA = class extends pE.Me {
        constructor(t, i, e, s) {
            pE.ibt(t),
            pE.iM(i),
            pE.Ef(e, pE.Qs.EA.vJi),
            pE.kQ(s),
            super(),
            s = Object.assign({}, ME, s),
            this.SJi = t,
            this.Upi = null,
            this.Rdi = s.id,
            this.xJi = s.className,
            this.MJi = s.bJi || null,
            this.EJi = !1,
            this.ght = pE.Qs.W_("ui-menu"),
            this.ght.setAttribute("role", "menu"),
            this.xJi && (this.ght.className = this.xJi),
            this.Mri = [],
            this.BTi = null,
            this.CJi = [],
            this._Ji = null,
            this.fEi = null,
            this.pEi = !1,
            this.mEi = !1,
            this.Fc = !1,
            this.TJi = e,
            this.JPi = !0,
            this.IJi(!1),
            this.PJi = 0,
            this.GJi = !1,
            this.fj = 0,
            this.uj = 0,
            this.AJi = "right",
            this.oEi = null,
            this.RJi = pE.kt.Y_ && window.matchMedia("(max-width: 500px), (max-height: 500px)").matches,
            this.wEi = !1,
            this.kJi = !1,
            this.REi = null,
            this.RJi && this.ght.setAttribute("compact", ""),
            this.EVi = t => this.Z_(t),
            this.ght.addEventListener("scroll", this.EVi, {
                passive: !0
            }),
            this.ght.addEventListener("contextmenu", pE.Qs.gdt),
            this.OJi = () => pE.Qs.EA.Nqi(),
            self.app.addEventListener("projectobjectdelete", this.OJi),
            this.wUi = i || (this.RJi ? self.app.Oq() : self.app.m4()),
            this.dn = !1
        }
        he() {
            mE(!this.dn, "already released"),
            this.DJi() && this.FJi() && this.wEi && pE.Qs.Tvi.j0(),
            self.app.removeEventListener("projectobjectdelete", this.OJi),
            this.OJi = null,
            this.LJi(),
            this.fEi && (this.fEi.finish(),
            this.fEi = null);
            for (let t of this.Mri)
                t.S0();
            pE.Io(this.Mri);
            for (let t of this.CJi)
                pE.Qs.UO(t);
            pE.Io(this.CJi),
            this._Ji = null,
            this.ght && (this.ght.removeEventListener("scroll", this.EVi),
            this.EVi = null,
            this.ght.removeEventListener("contextmenu", pE.Qs.gdt),
            pE.Qs.UO(this.ght),
            this.ght = null),
            this.BTi = null,
            this.fEi = null,
            this.SJi = null,
            this.TJi = null,
            this.dn = !0,
            pE.he(this)
        }
        gn() {
            return this.dn
        }
        k_() {
            return this.ght
        }
        FO() {
            return this.ght.ownerDocument
        }
        LO() {
            return this.FO().defaultView
        }
        Bk() {
            return this.Rdi
        }
        BJi() {
            return this.xJi
        }
        UJi() {
            return this._Ji || this.ght
        }
        eNi() {
            return this.wUi
        }
        NJi() {
            return this.TJi
        }
        jJi() {
            if (isNaN(CE)) {
                let t = pE.Qs.pW("padding-top", {
                    wW: this.ght
                });
                if (!t.endsWith("px"))
                    throw new Error("CSS style for menu padding-top must be in units of 'px'");
                CE = parseFloat(t) || 0
            }
            return CE
        }
        tc() {
            return this.Fc
        }
        $Ji() {
            return this.GJi
        }
        Z_(t) {
            this.GJi = !0
        }
        zJi() {
            this.GJi = !1
        }
        VJi() {
            this.zJi();
            for (let t of this.Mri) {
                if (!t.WJi())
                    continue;
                if (!t.HJi())
                    continue;
                let i = t.KJi();
                i && i.qJi().VJi()
            }
        }
        N4() {
            return this.Mri.length
        }
        qA() {
            return !!this.Mri.length
        }
        _A(t, i, e, s) {
            "string" == typeof t && (t = self.app.XJi(t, this.wUi)),
            pE.Ef(t, pE.Qs.d0),
            pE.zt(i),
            pE.tot(e),
            pE.kQ(s),
            this.kJi || (this.kJi = !0,
            this.RJi && this.FJi() && this.YJi());
            let n = pE.v(pE.Qs.EA.vJi, this, t, i, e, s);
            return this.Mri.push(n),
            this.JJi(),
            n
        }
        YA() {
            let t = pE.v(pE.Qs.EA.AVi, this);
            return this.Mri.push(t),
            this.JJi(),
            t
        }
        gA(t, i, e, s) {
            "string" == typeof t && (t = self.app.XJi(t, this.wUi)),
            pE.Ef(t, pE.Qs.d0),
            pE.zt(i),
            pE.kQ(e),
            pE.kQ(s);
            let n = this._A(t, i, null, e);
            return n.ZJi(s),
            n.KJi()
        }
        RT() {
            if (!this.DJi()) {
                if (this.QJi())
                    throw new Error("already in a group");
                this._Ji = pE.Qs.W_("div", this.k_(), null, "menuitemgroup"),
                this.CJi.push(this._Ji)
            }
        }
        ET() {
            if (!this.DJi()) {
                if (!this.QJi())
                    throw new Error("not in a group");
                this._Ji = null
            }
        }
        tZi() {
            if (!this.QJi())
                throw new Error("not in a group");
            pE.Qs.UO(this._Ji),
            this._Ji = null,
            this.CJi.pop()
        }
        QJi() {
            return !!this._Ji
        }
        YJi() {
            this.REi = pE.Ugi.WL( () => this.j0());
            const t = this.QJi();
            t && this.tZi(),
            this._A(self.app.XJi("close", this.eNi()), self.lang("common.close-menu"), pE.wS, {
                id: "compact-mode-close-button"
            }),
            this.YA(),
            t && this.RT()
        }
        iZi(t) {
            pE.nu(t),
            mE(!this.REi, "already set back stack entry"),
            this.REi = pE.Ugi.WL(t)
        }
        JJi() {
            null !== this.MJi && this.Mri.length > this.MJi && (this.EJi = !0)
        }
        NT(t, i, e) {
            if (pE.Ge(t),
            pE.Ge(i),
            pE.iM(e),
            mE(!this.dn, "menu was released"),
            mE(!this.Fc, "showing already active menu"),
            this._Ji)
                throw new Error("group not finished");
            if (this.FJi()) {
                pE.Qs.EA.Nqi(),
                pE.Qs.Fk.Uk.Nqi(),
                EE = this;
                let e = new Promise(t => this.oEi = t);
                return this.RJi && !pE.Qs.FOi.XO() && (this.wEi = !0,
                pE.Qs.Tvi.lQ(this.SJi)),
                this.eZi(t, i),
                this.sZi(),
                this.Upi.addEventListener("pointerdown", pE.Qs.EA.mO, !0),
                this.Upi.addEventListener("keydown", pE.Qs.EA.wG),
                this.Upi.defaultView.addEventListener("resize", pE.Qs.EA.Nqi),
                this.Upi.defaultView.addEventListener("unload", pE.Qs.EA.Nqi),
                this.Upi.addEventListener("pointermove", _E),
                !this.EJi && this.ght.scrollHeight <= this.ght.offsetHeight && this.Upi.addEventListener("wheel", pE.Qs.EA.nZi, !0),
                pE.$M || this.Upi.defaultView.addEventListener("blur", pE.Qs.EA.Nqi),
                e
            }
            this.rZi() && (this.hZi() ? this.NJi().qJi().$Ji() && this.eZi(t, i, e) : this.eZi(t, i, e),
            this.sZi(),
            this.ght.scrollHeight > this.ght.offsetHeight && this.ght.ownerDocument.removeEventListener("wheel", pE.Qs.EA.nZi, !0))
        }
        Jlt(t="top-left", i=0, e=0, s="right") {
            if (pE.zt(t),
            pE.Ge(i),
            pE.Ge(e),
            pE.zt(s),
            !vE.includes(t))
                throw new Error("invalid alignment");
            if (!SE.includes(s))
                throw new Error("invalid preferred expand direction");
            this.AJi = s;
            const n = this.SJi.getBoundingClientRect();
            switch (t) {
            case "top-left":
                return this.NT(n.left + i, n.top + e);
            case "top":
                return this.NT(n.left + n.width / 2 + i, n.top + e);
            case "top-right":
                return this.NT(n.right + i, n.top + e);
            case "left":
                return this.NT(n.left + i, n.top + n.height / 2 + e);
            case "center":
                return this.NT(n.left + n.width / 2 + i, n.top + n.height / 2 + e);
            case "right":
                return this.NT(n.right + i, n.top + n.height / 2 + e);
            case "bottom-left":
                return this.NT(n.left + i, n.bottom + e);
            case "bottom":
                return this.NT(n.left + n.width / 2 + i, n.bottom + e);
            case "bottom-right":
                return this.NT(n.right + i, n.bottom + e)
            }
        }
        j0(t) {
            (t || !this.mEi && !this.oZi() && this.Fc) && (this.Fc = !1,
            this.aZi(),
            this.REi && (this.REi.he(),
            this.REi = null),
            this.FJi() && (EE === this && (EE = null),
            this.wEi && pE.Qs.Tvi.j0(),
            this.Upi && (this.Upi.removeEventListener("pointerdown", pE.Qs.EA.mO, !0),
            this.Upi.removeEventListener("keydown", pE.Qs.EA.wG),
            this.Upi.removeEventListener("wheel", pE.Qs.EA.nZi, !0),
            this.Upi.defaultView.removeEventListener("resize", pE.Qs.EA.Nqi),
            this.Upi.defaultView.removeEventListener("unload", pE.Qs.EA.Nqi),
            this.Upi.removeEventListener("pointermove", _E),
            pE.$M || this.Upi.defaultView.removeEventListener("blur", pE.Qs.EA.Nqi)),
            this.LJi()),
            this.Upi = null,
            this.lZi())
        }
        LJi() {
            this.oEi && (this.oEi(),
            this.oEi = null)
        }
        gz(t, i) {
            if (pE.Ge(t),
            pE.Ge(i),
            mE(!this.dn, "menu was released"),
            this.mEi || !this.Fc || this.oZi())
                return !1;
            let e = this.BTi;
            return e ? t >= e.left && i >= e.top && t < e.right && i < e.bottom : void 0
        }
        eZi(t, i, e) {
            if (this.Upi = this.SJi.ownerDocument,
            this.RJi || (this.ght.style.left = "0px",
            this.ght.style.top = "0px",
            this.ght.style.width = "",
            this.ght.style.height = ""),
            !this.hZi()) {
                let t = this.Upi.body;
                pE.Qs.FOi.XO() && (t = pE.Qs.FOi.NOi()),
                t.appendChild(this.ght);
                let i = pE.Sii(this.SJi, "dialog");
                if (i && !pE.Qs.FOi.XO()) {
                    pE.Qs.UO(this.ght),
                    i.appendChild(this.ght);
                    let t = pE.Qs.Ks.rCi(i);
                    t && !t.iCi() && (this.fj = t.ESi(),
                    this.uj = t.CSi())
                }
            }
            if (this.RJi)
                return void (this.BTi = this.ght.getBoundingClientRect());
            let s = this.ght.getBoundingClientRect()
              , n = s.right - s.left
              , r = s.bottom - s.top;
            if (this.EJi && this.Mri.length) {
                let t = this.Mri[this.MJi - 1].uZi();
                r = t.top - s.top,
                this.ght.style.maxHeight = t.top - s.top + "px",
                this.ght.style.overflowY = "scroll"
            }
            let h = ""
              , o = ""
              , a = this.Upi.defaultView.innerWidth
              , l = this.Upi.defaultView.innerHeight
              , u = 0;
            if (this.TJi) {
                let t = this.TJi.uZi();
                u = t.right - t.left
            }
            const c = t - (n + u) >= 0;
            if (!(t + n + xE <= a) || c && "right" !== this.AJi)
                if (c)
                    t -= n + u,
                    h = "100%";
                else {
                    t - u > a - t ? (t = 0,
                    pE.kt.Y_ && (i = e),
                    h = "100%") : (t = a - n,
                    h = "0%")
                }
            else
                h = "0%";
            let d = "number" == typeof e ? e : i;
            i + r + xE <= l ? o = "0%" : d - r >= 0 ? (i = d - r,
            o = "100%") : (o = 100 * i / l + "%",
            i = 0,
            this.ght.style.height = Math.min(r, l - 5) + "px"),
            this.ght.style.transformOrigin = `${h} ${o}`;
            const f = pE.rat(t - this.fj)
              , p = pE.rat(i - this.uj);
            this.ght.style.left = `${f}px`,
            this.ght.style.top = `${p}px`,
            "DIALOG" === this.cZi().tagName && (this.ght.style.width = `${n}px`)
        }
        sZi() {
            mE(!this.dn, "menu was released"),
            mE(!this.pEi, "already fading in"),
            this.mEi && this.fEi && (this.mEi = !1,
            this.fEi.onfinish = null,
            this.fEi.finish(),
            this.fEi = null),
            this.pEi = !0,
            this.Fc = !0,
            this.oZi() ? (this.IJi(!0),
            this.mRi(this.RJi ? yE : gE, bE)) : this.ICi()
        }
        lZi() {
            mE(!this.mEi, "already animating out"),
            mE(EE !== this, "should not be current menu"),
            pE.gn(this) || this.dn || (this.mEi = !0,
            this.pEi && (this.pEi = !1,
            this.fEi) ? this.fEi.reverse() : this.dZi() ? this.mRi(wE, bE) : this.ICi())
        }
        mRi(t, i) {
            self.app.jKt() ? (mE(!this.fEi, "already animating"),
            this.fEi = this.ght.animate(t, i),
            this.fEi.onfinish = t => this.ICi()) : this.ICi()
        }
        ICi() {
            if (pE.gn(this) || this.dn)
                return;
            let t = !1;
            this.mEi && (mE(EE !== this, "should not be current menu"),
            this.FJi() && (t = !0),
            this.rZi() && this.IJi(!1)),
            this.pEi && (this.BTi = this.ght.getBoundingClientRect()),
            this.pEi = !1,
            this.mEi = !1,
            this.fEi = null,
            t && this.he()
        }
        fZi(t) {
            pE.Ef(t, pE.Qs.EA.vJi);
            for (let i of this.Mri)
                i.I6(i === t)
        }
        aZi() {
            for (let t of this.Mri) {
                if (!t.WJi())
                    continue;
                let i = t.KJi();
                i && i.qJi().j0()
            }
        }
        pZi() {
            for (let t of this.Mri) {
                if (!t.WJi())
                    continue;
                let i = t.KJi();
                i && i.qJi().he()
            }
        }
        mZi(t, i, e=!1) {
            for (let s of this.Mri) {
                if (!s.WJi())
                    continue;
                let n = s.KJi();
                if (n) {
                    if (n.wZi().gz(t, i, e))
                        return !0;
                    if (n.qJi().gZi(t, i, e))
                        return !0
                }
            }
            return !1
        }
        gZi(t, i, e=!1) {
            return this.gz(t, i, e) || this.mZi(t, i, e)
        }
        IJi(t) {
            if (t = !!t,
            this.JPi !== t && (this.JPi = t,
            this.ght.setAttribute("visible", this.JPi ? "true" : "false"),
            !this.JPi))
                for (let t of this.Mri)
                    t.I6(!1)
        }
        yZi() {
            return this.mEi
        }
        zOt() {
            return this.Fc
        }
        oZi() {
            return !this.JPi
        }
        dZi() {
            return this.JPi
        }
        rZi() {
            return !!this.TJi
        }
        FJi() {
            return !this.TJi
        }
        DJi() {
            return this.RJi
        }
        bZi(t) {
            this.RJi && (this.Fc = !!t,
            this.IJi(this.Fc))
        }
        vZi() {
            return this.ght.scrollHeight > this.ght.clientHeight
        }
        hZi() {
            return !!this.ght.parentNode
        }
        cZi() {
            return this.ght.parentNode
        }
        static JF() {
            return !!EE
        }
        static Nqi(t) {
            EE && (!t || "blur" !== t.type && "unload" !== t.type ? (mE(!EE.gn(), "menu was released"),
            EE.j0(EE.DJi()),
            EE = null) : pE.Qs.EA.BCi())
        }
        static BCi() {
            EE && (mE(!EE.gn(), "menu was released"),
            EE.pZi(),
            EE.he(),
            EE = null)
        }
        static SZi(t) {
            return pE.ibt(t),
            pE.Fft(t, ["ui-menu"])
        }
        static iSi(t, i, e) {
            return !!EE && (mE(!EE.gn(), "menu was released"),
            (!e || EE.LO() === e) && EE.gZi(t, i))
        }
        static mO(t) {
            EE && (mE(!EE.gn(), "menu was released"),
            EE.VJi(),
            EE.gZi(t.clientX, t.clientY) || (EE.DJi() && (t.stopPropagation(),
            t.preventDefault()),
            pE.Qs.EA.Nqi()))
        }
        fG(t) {
            if (this.gn())
                return;
            const i = pE.Qs.EA.xZi(this, []).reverse();
            let e = !1
              , s = !1;
            for (const n of i) {
                for (let i of n.Mri) {
                    if (!i.WJi())
                        continue;
                    i.fG(t);
                    let n = i.KJi();
                    n && n.MZi(t),
                    s || n && n.qA() && n.fG(t) && (e = !0)
                }
                e && (s = !0)
            }
        }
        static xZi(t, i) {
            pE.U(t, pE.Qs.EA),
            pE.RH(i),
            i.push(t);
            for (const e of t.Mri) {
                if (!e.WJi() || !e.HJi())
                    continue;
                const t = e.KJi();
                t.qA() && this.xZi(t.qJi(), i)
            }
            return i
        }
        static wG(t) {
            EE && t.which === pE.Mk.VJ && pE.Qs.EA.Nqi()
        }
        static nZi(t) {
            pE.Qs.EA.JF() && (t.preventDefault(),
            t.stopPropagation())
        }
        EZi(t) {
            return pE.Qs.CZi.EZi(this.Bk(), t)
        }
    }
}
{
    const TE = self.t
      , IE = 16
      , PE = 25
      , GE = {
        MT: !1,
        bold: !1,
        VP: "",
        Eme: !1,
        _Zi: !1,
        id: ""
    };
    let AE = 0;
    TE.Qs.EA.vJi = class extends TE.Me {
        constructor(t, i, e, s, n) {
            if (TE.U(t, TE.Qs.EA),
            TE.Ef(i, TE.Qs.d0),
            TE.zt(e),
            TE.tot(s),
            TE.kQ(n),
            n = Object.assign({}, GE, n),
            TE.zt(n.VP),
            super(),
            this.TZi = t,
            this.IZi = null,
            this.ght = TE.Qs.W_("ui-menuitem", this.TZi.UJi()),
            this.ght.setAttribute("role", "menuitem"),
            this.BTi = null,
            this.bWt = !1,
            this.Rdi = n.id,
            this.DF = this.rz().EZi(this.Rdi),
            this.pYi = 0,
            this.PZi = 0,
            this.GZi = !1,
            this.AZi = !0,
            this.BGt = null,
            this.aOi = null,
            i) {
                this.BGt = TE.v(TE.Qs._q, {
                    icon: i,
                    Nki: n.Eme
                }, this.ght);
                let t = i.JRi();
                t && t.HGt().then(t => {
                    this.BGt && (this.BGt.Zki(t),
                    this.BGt = null,
                    this.aOi = t)
                }
                )
            } else
                this.BGt = TE.v(TE.Qs._q, this.TZi.eNi(), this.ght);
            this.RZi = TE.Qs.W_("span", this.ght, null, "menu-item-text"),
            this.RZi.textContent = e,
            this.PLi = s,
            this.kZi = !!n.MT,
            this.OZi = !!n._Zi,
            n.bold && this.ght.setAttribute("bold", ""),
            n.VP && this.ght.setAttribute("title", n.VP),
            this.DF || this.ght.setAttribute("disabled", ""),
            this.mF = t => this.mO(t),
            this.ght.addEventListener("pointerdown", this.mF),
            this.uG = t => this.dG(t),
            this.ght.addEventListener("pointerup", this.uG, !0),
            this.KLi = t => this.IN(t),
            this.ght.addEventListener("pointercancel", this.KLi, !0),
            this.DZi = null,
            this.FZi = new Promise( (t, i) => {
                this.DZi = t
            }
            ),
            this.LZi = !1,
            this.BZi = t => this.gO(t),
            this.ght.addEventListener("contextmenu", this.BZi, !0),
            this.DF && TE.Qs.CZi.UZi() && "help" !== this.Rdi && this.ght.classList.add("highlight")
        }
        S0() {
            this.IZi && (this.IZi.he(),
            this.IZi = null),
            this.BGt && (this.BGt.he(),
            this.BGt = null),
            TE.Qs.UO(this.aOi),
            this.aOi = null,
            this.RZi && (TE.Qs.UO(this.RZi),
            this.RZi = null),
            this.ght && (this.ght.removeEventListener("contextmenu", this.BZi, !0),
            this.ght.removeEventListener("pointerup", this.uG, !0),
            this.uG = null,
            this.ght.removeEventListener("pointerdown", this.mF),
            this.mF = null,
            TE.Qs.UO(this.ght),
            this.ght = null),
            this.DZi = null,
            this.FZi = null,
            this.TZi = null,
            this.PLi = null,
            this.BTi = null,
            TE.he(this)
        }
        k_() {
            return this.ght
        }
        KJi() {
            return this.IZi
        }
        qJi() {
            return this.TZi
        }
        Bk() {
            return this.Rdi
        }
        rz() {
            let t = this.qJi();
            do {
                if (t.FJi())
                    return t;
                t = t.NJi().qJi()
            } while (t);
            throw new Error("unable to get root menu")
        }
        WJi() {
            return !0
        }
        HJi() {
            return !!this.KJi()
        }
        uZi(t) {
            return (t = !!t) ? (this.BTi = this.ght.getBoundingClientRect(),
            this.BTi) : (this.BTi || (this.BTi = this.ght.getBoundingClientRect()),
            this.BTi)
        }
        ZJi(t) {
            TE.kQ(t),
            this.IZi || (self.assert(!this.PLi, "submenu items should not have a callback function"),
            t = Object.assign({
                className: this.TZi.BJi()
            }, t),
            this.IZi = TE.v(TE.Qs.EA.NZi, this, this.TZi.eNi(), t))
        }
        jZi(t) {}
        $Zi(t) {}
        mO(t) {
            this.TZi.tc() && this.DF && (t.button !== TE.gF.mat || this.rz().DJi() ? this.LZi = !1 : this.LZi = !0,
            this.TZi.vZi() || (t.preventDefault(),
            t.stopPropagation()),
            this.pYi = t.clientX,
            this.PZi = t.clientY,
            "mouse" !== t.pointerType && this.TZi.fZi(this))
        }
        fG(t) {
            if (TE.gn(this))
                return;
            if (this.rz().DJi())
                return;
            let i = this.AZi || this.TZi.$Ji()
              , e = this.gz(t.clientX, t.clientY, i);
            !this.GZi && e ? (this.GZi = !0,
            this.AZi = !1,
            this.jZi(t)) : this.GZi && !e && (this.GZi = !1,
            this.$Zi(t))
        }
        dG(t) {
            if (!this.TZi.tc() || !this.DF)
                return;
            if (t.preventDefault(),
            t.button === TE.gF.vF)
                return;
            const i = "mouse" !== t.pointerType;
            if (i) {
                let i = this.qJi();
                if (!this.gz(t.clientX, t.clientY))
                    return void i.fZi(null);
                if (i.$Ji())
                    return void i.fZi(null)
            }
            if (this.HJi())
                return void (this.IZi.tc() && !i || this.TZi.aZi());
            let e = t.clientX
              , s = t.clientY;
            if (TE.di(this.pYi, this.PZi, e, s) >= PE)
                return void this.TZi.fZi(null);
            const n = this.PLi;
            n && (this.kZi ? (n(),
            TE.Qs.CZi.zZi("menuitemchosen", this)) : (AE++,
            AE > 1 || (window.addEventListener("keydown", TE.Qs.gdt, !0),
            window.addEventListener("keyup", TE.Qs.gdt, !0),
            window.addEventListener("keypress", TE.Qs.gdt, !0)),
            window.setTimeout( () => {
                AE--,
                AE > 0 || (window.removeEventListener("keydown", TE.Qs.gdt, !0),
                window.removeEventListener("keyup", TE.Qs.gdt, !0),
                window.removeEventListener("keypress", TE.Qs.gdt, !0)),
                n(),
                TE.Qs.CZi.zZi("menuitemchosen", this)
            }
            , IE))),
            this.OZi || (this.LZi ? this.FZi.then( () => {
                TE.Qs.EA.Nqi()
            }
            ) : TE.Qs.EA.Nqi())
        }
        IN(t) {
            this.GZi = !1,
            this.LZi = !1,
            this.TZi.fZi(null)
        }
        gO(t) {
            t.preventDefault(),
            t.stopPropagation(),
            this.DZi()
        }
        gz(t, i, e) {
            TE.Ge(t),
            TE.Ge(i);
            let s = this.qJi();
            return !(s.yZi() || !s.zOt() || s.oZi()) && (e = !!e,
            this.BTi = this.uZi(e),
            t >= this.BTi.left && i >= this.BTi.top && t < this.BTi.right && i < this.BTi.bottom)
        }
        I6(t) {
            (t = !!t) && !this.bWt ? this.ght.setAttribute("selected", "") : !t && this.bWt && this.ght.removeAttribute("selected"),
            this.bWt = t
        }
    }
}
{
    const RE = self.t;
    RE.Qs.EA.AVi = class extends RE.Me {
        constructor(t) {
            RE.U(t, RE.Qs.EA),
            super(),
            this.TZi = t,
            this.ght = RE.Qs.W_("ui-menuseparator", this.TZi.k_()),
            this.ght.setAttribute("role", "separator")
        }
        S0() {
            RE.Qs.UO(this.ght),
            this.ght = null,
            this.TZi = null,
            RE.he(this)
        }
        WJi() {
            return !1
        }
        I6(t) {}
    }
}
{
    const kE = self.t
      , OE = 300
      , DE = 500;
    kE.Qs.EA.NZi = class extends kE.Me {
        constructor(t, i, e) {
            kE.U(t, kE.Qs.EA.vJi),
            kE.iM(i),
            kE.kQ(e),
            super(),
            this.VZi = t,
            this.wUi = i,
            this.SJi = this.VZi.k_(),
            this.BGt = null,
            this.aOi = null,
            this.WZi = !1,
            this.HZi = !1,
            this.KZi = !1,
            this.qZi = !1,
            this.XZi = !1,
            this.YZi = !0,
            this.JZi = -1,
            this.ZZi = -1,
            this.ini = 0,
            this.eni = 0,
            this.nni = 0,
            this.SJi.setAttribute("sub-menu", "empty"),
            this.QZi = -1,
            this.Sqi = -1,
            this.uG = t => this.dG(t),
            this.KLi = t => this.IN(t),
            this.mF = t => this.mO(t),
            this.REi = null,
            this.TZi = kE.v(kE.Qs.EA, this.SJi, this.wUi, this.VZi, e)
        }
        he() {
            this.tQi(),
            this.iQi(),
            this.SJi.removeEventListener("pointerup", this.uG),
            this.SJi.removeEventListener("pointercancel", this.KLi),
            this.SJi.removeEventListener("pointerdown", this.mF),
            this.SJi.removeEventListener("contextmenu", kE.Qs.gdt, !0),
            this.BGt && (this.BGt.he(),
            this.BGt = null),
            kE.Qs.UO(this.aOi),
            this.aOi = null,
            this.TZi && !kE.gn(this.TZi) && this.TZi.k_() && this.TZi.he(),
            this.TZi = null,
            this.uG = null,
            this.KLi = null,
            this.mF = null,
            this.SJi = null,
            this.VZi = null,
            kE.he(this)
        }
        qJi() {
            return this.TZi
        }
        wZi() {
            return this.VZi
        }
        qA() {
            return this.WZi
        }
        rz() {
            let t = this.VZi.qJi();
            do {
                if (t.FJi())
                    return t;
                t = t.NJi().qJi()
            } while (t);
            throw new Error("unable to get root menu")
        }
        _A(t, i, e, s) {
            return this.eQi(),
            this.qJi()._A(t, i, e, s)
        }
        YA() {
            return this.eQi(),
            this.qJi().YA()
        }
        gA(t, i, e) {
            return this.eQi(),
            this.qJi().gA(t, i)
        }
        RT() {
            this.qJi().RT()
        }
        ET() {
            this.qJi().ET()
        }
        QJi() {
            this.qJi().QJi()
        }
        mO(t) {
            this.HZi = !1,
            this.KZi = !1
        }
        IN(t) {
            this.qZi = !1,
            this.XZi = !1,
            this.tQi(),
            this.iQi(),
            this.VZi.qJi().fZi(null)
        }
        dG(t) {
            const i = "mouse" !== t.pointerType;
            if (!(i && this.TZi.yZi() || t.button === kE.gF.vF)) {
                if (i) {
                    let i = this.VZi.qJi();
                    if (!this.VZi.gz(t.clientX, t.clientY))
                        return void i.fZi(null);
                    if (this.rz().DJi() && (this.HZi || this.KZi))
                        return void i.fZi(null);
                    if (i.$Ji())
                        return void i.fZi(null)
                }
                this.sQi()
            }
        }
        jZi(t) {
            this.tQi(),
            this.iQi(),
            this.QZi = setTimeout( () => {
                this.nQi()
            }
            , OE)
        }
        $Zi() {
            this.qZi = !1,
            this.XZi = !1,
            this.tQi(),
            this.iQi(),
            this.Sqi = setTimeout( () => {
                this.rQi(this.JZi, this.ZZi)
            }
            , DE)
        }
        fG(t) {
            if (kE.gn(this))
                return;
            let i = this.YZi || !this.TZi.$Ji()
              , e = !1
              , s = this.VZi.gz(this.JZi, this.ZZi, i);
            return s && (e = s),
            !this.qZi && s ? (this.qZi = !0,
            this.YZi = !1,
            this.rz().DJi() || this.jZi(t)) : this.qZi && !s && (this.qZi = !1,
            this.rz().DJi() ? this.HZi = !0 : this.$Zi(t)),
            s = this.TZi.gz(this.JZi, this.ZZi),
            s && (e = s),
            !this.XZi && s ? this.XZi = !0 : this.XZi && !s && (this.XZi = !1,
            this.rz().DJi() ? this.KZi = !0 : this.$Zi(t)),
            e
        }
        MZi(t) {
            this.JZi = t.clientX,
            this.ZZi = t.clientY
        }
        tQi() {
            -1 !== this.QZi && (clearTimeout(this.QZi),
            this.QZi = -1)
        }
        iQi() {
            -1 !== this.Sqi && (clearTimeout(this.Sqi),
            this.Sqi = -1)
        }
        tc() {
            return this.qJi().tc()
        }
        sQi() {
            this.VZi.qJi().bZi(!1);
            let t = this.VZi.qJi();
            const i = this.rz().DJi()
              , e = t.yZi()
              , s = t.oZi()
              , n = t.tc();
            if (!i && (e || s || !n))
                return;
            let r = this.qJi();
            if (!r.tc()) {
                if (this.tQi(),
                this.iQi(),
                0 === this.ini && 0 === this.eni && 0 === this.nni) {
                    let i = t.jJi()
                      , e = this.VZi.uZi(!0);
                    this.ini = e.left + e.width,
                    this.eni = e.top - i,
                    this.nni = e.bottom + i
                } else if (t.$Ji()) {
                    let i = t.jJi()
                      , e = this.VZi.uZi(!0);
                    this.ini = e.left + e.width,
                    this.eni = e.top - i,
                    this.nni = e.bottom + i
                }
                r.NT(this.ini, this.eni, this.nni),
                i && r.iZi( () => this.hQi())
            }
        }
        nQi() {
            this.QZi = -1,
            this.qJi().tc() || (this.VZi.qJi().aZi(),
            this.sQi())
        }
        rQi(t, i) {
            kE.Ge(t),
            kE.Ge(i),
            this.Sqi = -1;
            const e = this.qJi();
            e.tc() && !e.gZi(t, i) && e.j0()
        }
        eQi() {
            if (!this.WZi) {
                this.SJi.setAttribute("sub-menu", "full");
                let t = self.app.oi("menu-submenu");
                this.BGt = kE.v(kE.Qs._q, t, this.SJi);
                let i = t.JRi();
                i && i.HGt().then(t => {
                    this.BGt && (this.BGt.Zki(t),
                    this.BGt = null,
                    this.aOi = t)
                }
                ),
                this.SJi.addEventListener("pointerup", this.uG),
                this.SJi.addEventListener("pointercancel", this.KLi),
                this.SJi.addEventListener("pointerdown", this.mF),
                this.SJi.addEventListener("contextmenu", kE.Qs.gdt, !0),
                this.WZi = !0;
                const e = this.rz();
                if (e.DJi()) {
                    const t = this.qJi()
                      , i = t.QJi();
                    i && t.tZi(),
                    t._A(self.app.XJi("back", e.eNi()), self.lang("common.back"), () => this.hQi(), {
                        _Zi: !0,
                        id: "compact-mode-back-button"
                    }),
                    t.YA(),
                    i && t.RT()
                }
            }
        }
        hQi() {
            this.VZi && (this.VZi.qJi().bZi(!0),
            this.TZi.j0())
        }
    }
}
{
    const FE = self.t
      , LE = FE.v(FE.Event.v_)
      , BE = new Map;
    FE.Qs.CZi = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static zZi(t, i) {
            FE.zt(t),
            FE.Ef(i, FE.Qs.EA.vJi);
            const e = new FE.Event(t);
            e.oQi = i,
            this.dispatchEvent(e)
        }
        static addEventListener(t, i, e) {
            LE.addEventListener(t, i, e)
        }
        static removeEventListener(t, i, e) {
            LE.removeEventListener(t, i, e)
        }
        static dispatchEvent(t) {
            return LE.dispatchEvent(t)
        }
        static aQi(t) {
            return FE.Qs.CZi.lQi(t, "menuitemchosen")
        }
        static lQi(t, i) {
            return FE.RH(t),
            FE.zt(i),
            new Promise(e => {
                const s = n => {
                    t.includes(n.oQi.Bk()) && (FE.Qs.CZi.removeEventListener(i, s),
                    e(n.oQi))
                }
                ;
                FE.Qs.CZi.addEventListener(i, s)
            }
            )
        }
        static uQi(t) {
            FE.RH(t),
            BE.clear();
            for (const [i,e] of t)
                FE.zt(i),
                FE.RH(e),
                BE.set(i, new Set(e))
        }
        static cQi() {
            BE.clear()
        }
        static EZi(t, i) {
            if (0 === BE.size)
                return !0;
            if ("compact-mode-close-button" === i || "compact-mode-back-button" === i)
                return !0;
            const e = BE.get(t);
            return !!e && e.has(i)
        }
        static UZi() {
            return BE.size > 0
        }
    }
}
{
    const UE = self.t
      , NE = self.assert;
    function jE(t, i) {
        return !!t == !!i
    }
    UE.Qs.dQi = class {
        constructor(...t) {
            if (t.length < 2)
                throw new Error("missing arguments");
            this.PLi = null,
            this.LGt = "",
            this.fQi = t.at(-2),
            this.pQi = !1,
            this.mQi = !1,
            this.wQi = !1,
            this.gQi = !1,
            this.yQi = !1,
            this.bQi = !1,
            this.vQi = !1;
            let i = [];
            for (let e = 0, s = t.length - 2; e < s; ++e) {
                let s = t[e];
                if (UE.zt(s),
                i.includes(s))
                    throw new Error("duplicate modifier");
                switch (i.push(s),
                s) {
                case "ctrl":
                    this.pQi = !0;
                    break;
                case "shift":
                    this.mQi = !0;
                    break;
                case "alt":
                    this.wQi = !0;
                    break;
                case "meta":
                    this.gQi = !0;
                    break;
                case "alt-gr":
                    this.yQi = !0;
                    break;
                default:
                    throw new Error("invalid modifier")
                }
            }
            let e = t.at(-1);
            if ("function" == typeof e)
                this.PLi = e;
            else {
                if ("string" != typeof e)
                    throw new TypeError("expected function or string");
                this.LGt = e
            }
            NE(UE.ub(this.fQi) || UE.K9(this.fQi), "key must be a number or a string")
        }
        SQi() {
            return this.bQi = !0,
            this
        }
        xQi() {
            return this.bQi
        }
        MQi() {
            return this.vQi = !0,
            this
        }
        EQi() {
            return this.vQi
        }
        CQi(t) {
            return this.yQi && t.getModifierState("AltGraph") ? (NE(!this.pQi, "alt-gr can not be pressed together with ctrl"),
            NE(!this.wQi, "alt-gr can not be pressed together with alt"),
            !!UE.Mk.cdt(t.key, this.fQi) && (jE(t.shiftKey, this.mQi) && jE(t.metaKey, this.gQi))) : !!UE.Mk.cdt(t.which, this.fQi) && (jE(t.ctrlKey, this.pQi) && jE(t.shiftKey, this.mQi) && jE(t.altKey, this.wQi) && jE(t.metaKey, this.gQi))
        }
        _Qi(t) {
            if (this.PLi)
                return this.PLi(t),
                !0;
            {
                let t = UE.Qs.TO.QU();
                return !!t && t.aO(this.LGt)
            }
        }
    }
}
{
    const $E = self.t;
    $E.Qs.TQi = class {
        constructor(t) {
            this.rOi = t,
            this.IQi = [],
            this.PQi = window.C3_IsPopupWindow,
            this.GQi = !0,
            window.addEventListener("keydown", t => this.wG(t, !1)),
            this.PQi && (window.addEventListener("keyup", t => this.yG(t)),
            window.addEventListener("keypress", t => this.$ft(t))),
            t.addEventListener("external-keyboard-shortcut", t => this.wG(t.adt, !0))
        }
        AQi(t) {
            $E.QH(t, $E.Qs.dQi),
            $E.Oo(this.IQi, t)
        }
        RQi() {
            this.GQi = !1
        }
        wG(t, i) {
            const e = $E.ddt();
            for (const s of this.IQi)
                if ((!e || s.xQi()) && (!self.app.mdt() || s.EQi()) && s.CQi(t)) {
                    if (this.PQi)
                        t.preventDefault(),
                        window.opener.postMessage({
                            type: "popup-keyboard-shortcut",
                            event: {
                                key: t.key,
                                keyCode: t.keyCode,
                                keyIdentifier: t.keyIdentifier,
                                keyLocation: t.keyLocation,
                                code: t.code,
                                location: t.location,
                                char: t.char,
                                charCode: t.charCode,
                                which: t.which,
                                ctrlKey: t.ctrlKey,
                                shiftKey: t.shiftKey,
                                altKey: t.altKey,
                                metaKey: t.metaKey,
                                repeat: t.repeat,
                                isComposing: t.isComposing
                            }
                        }, location.origin);
                    else {
                        this.GQi = !0;
                        const e = s._Qi(this.rOi);
                        i && (t.sMi = e),
                        $E.Qs.EA.Nqi(),
                        e && !i && this.GQi && t.preventDefault()
                    }
                    return
                }
            this.PQi && !e && window.opener.postMessage({
                type: "popup-keydown",
                event: {
                    key: t.key,
                    keyCode: t.keyCode,
                    keyIdentifier: t.keyIdentifier,
                    keyLocation: t.keyLocation,
                    code: t.code,
                    location: t.location,
                    char: t.char,
                    charCode: t.charCode,
                    which: t.which,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    altKey: t.altKey,
                    metaKey: t.metaKey,
                    repeat: t.repeat,
                    isComposing: t.isComposing
                }
            }, location.origin)
        }
        yG(t) {
            $E.ddt() || window.opener.postMessage({
                type: "popup-keyup",
                event: {
                    key: t.key,
                    keyCode: t.keyCode,
                    keyIdentifier: t.keyIdentifier,
                    keyLocation: t.keyLocation,
                    code: t.code,
                    location: t.location,
                    char: t.char,
                    charCode: t.charCode,
                    which: t.which,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    altKey: t.altKey,
                    metaKey: t.metaKey,
                    repeat: t.repeat,
                    isComposing: t.isComposing
                }
            }, location.origin)
        }
        $ft(t) {
            $E.ddt() || window.opener.postMessage({
                type: "popup-keypress",
                event: {
                    key: t.key,
                    keyCode: t.keyCode,
                    keyIdentifier: t.keyIdentifier,
                    keyLocation: t.keyLocation,
                    code: t.code,
                    location: t.location,
                    char: t.char,
                    charCode: t.charCode,
                    which: t.which,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    altKey: t.altKey,
                    metaKey: t.metaKey,
                    repeat: t.repeat,
                    isComposing: t.isComposing
                }
            }, location.origin)
        }
    }
}
{
    const zE = self.t;
    zE.kQi = class extends zE.Me {
        constructor(t, i) {
            super(),
            zE.U(t, zE.bO.constructor),
            zE.zt(i),
            this.xyi = t,
            this.Ftt = i,
            this.OQi = `@font-face {\n\t\t\tfont-family: '${this.Ftt}';\n\t\t\tsrc: `,
            this.DQi = null,
            this.FQi = "",
            this.LQi = [],
            this.BQi = null
        }
        La() {
            return this.Ftt
        }
        JSi(t, i, e, s) {
            zE.U(t, Blob),
            zE.zt(i),
            zE.zt(e);
            let n = URL.createObjectURL(t);
            this.LQi.push(n),
            this.OQi += `url('${n}')`;
            let r = zE.bO.UQi(i, e);
            r && (this.OQi += ` format('${r}')`),
            this.OQi += s ? ";\n}" : ", "
        }
        async NQi() {
            return this.DQi = new Blob([this.OQi],{
                type: "text/css"
            }),
            this.FQi = URL.createObjectURL(this.DQi),
            this.BQi = await zE.jii(this.FQi),
            this.BQi.setAttribute("data-comment", "webfont-" + this.Ftt),
            void 0 !== document.fonts && "function" == typeof document.fonts.load && await document.fonts.load("1em '" + this.Ftt + "'"),
            zE.bO.jQi(this),
            this
        }
        he() {
            if (this.xyi) {
                this.xyi.$Qi(this),
                this.xyi = null;
                for (let t of this.LQi)
                    URL.revokeObjectURL(t);
                zE.Io(this.LQi),
                this.FQi && (URL.revokeObjectURL(this.FQi),
                this.FQi = ""),
                this.DQi = null,
                zE.Qs.UO(this.BQi),
                this.BQi = null
            }
        }
    }
}
{
    const VE = self.t;
    class WE extends VE.Event.v_ {
        constructor() {
            super(),
            this.zQi = new Map
        }
        yrt(t, i, e, s) {
            if (VE.zt(t),
            VE.zt(i),
            VE.zt(e),
            VE.U(s, Blob),
            this.zQi.has(t.toLowerCase()))
                return Promise.resolve(this.zQi.get(t.toLowerCase()));
            const n = VE.v(VE.kQi, this, t);
            return n.JSi(s, i.toLowerCase(), e.toLowerCase(), !0),
            this.zQi.set(t.toLowerCase(), n),
            n.NQi()
        }
        $Qi(t) {
            VE.U(t, VE.kQi),
            this.zQi.delete(t.La().toLowerCase())
        }
        jQi(t) {
            VE.U(t, VE.kQi);
            let i = new VE.Event("fontload");
            i.font = t,
            this.dispatchEvent(i)
        }
        UQi(t, i) {
            return VE.zt(t),
            VE.zt(i),
            t = t.toLowerCase(),
            i = i.toLowerCase(),
            "application/font-woff" === t || i.endsWith("woff") ? "woff" : "font/woff2" === t || i.endsWith("woff2") ? "woff2" : "application/vnd.ms-fontobject" === t || i.endsWith("eot") ? "embedded-opentype" : i.endsWith("ttf") ? "truetype" : i.endsWith("otf") ? "opentype" : ""
        }
    }
    VE.bO = VE.v(WE)
}
{
    const HE = self.t;
    HE.Qs.mk.addEventListener("showmodal", t => {
        t.jmt.Bxi() && !t.jmt.Imt() || HE.Qs.WQi.VQi()
    }
    ),
    HE.Qs.mk.addEventListener("hidemodal", t => {
        t.jmt.Bxi() && !t.jmt.Imt() || HE.Qs.WQi.he()
    }
    ),
    HE.Qs.WQi = class {
        constructor() {}
        static he() {
            for (let t of this.HQi.values()) {
                for (let i of t)
                    i.S0(!1);
                HE.Io(t)
            }
        }
        static KQi(t) {
            HE.U(t, HE.Qs.Notification);
            let i = this.HQi.get(t.qQi());
            i.unshift(t);
            for (let t = 0; t < i.length; t++)
                i[t].XQi(t);
            if (i.length >= this.YQi + 1) {
                let t = i.at(-1);
                this.JQi(t),
                t.wqi()
            }
        }
        static ZQi(t) {
            HE.U(t, HE.Qs.Notification),
            this.JQi(t)
        }
        static QQi(t) {
            HE.U(t, HE.Qs.Notification);
            let i = this.HQi.get(t.qQi());
            for (let t = 0; t < i.length; t++) {
                let e = i[t];
                e.iQi(),
                t === i.length - 1 && e.t0i()
            }
        }
        static VQi() {
            for (let t of this.HQi.values())
                for (let i of t)
                    i.wqi()
        }
        static i0i(t) {
            HE.U(t, HE.Qs.Notification);
            let i = this.HQi.get(t.qQi())
              , e = i.indexOf(t);
            if (e > 0) {
                let t = 0;
                for (var s = e - 1; s >= 0; s--)
                    t += i[s].zoe();
                return t
            }
            return 0
        }
        static JQi(t) {
            HE.U(t, HE.Qs.Notification);
            let i = this.HQi.get(t.qQi())
              , e = i.indexOf(t);
            -1 !== e && i.splice(e, 1),
            i.length && this.QQi(i[0])
        }
    }
    ,
    HE.Qs.WQi.HQi = new Map([["top-left", []], ["top-right", []], ["bottom-left", []], ["bottom-right", []]]),
    HE.Qs.WQi.YQi = 4
}
{
    const KE = self.t
      , qE = new Set(["top-left", "top-right", "bottom-left", "bottom-right"])
      , XE = 5
      , YE = 5e3
      , JE = {
        align: "top-right",
        UEt: 1300,
        e0i: !1,
        onclick: null
    }
      , ZE = {};
    KE.Qs.Notification = class extends KE.Event.v_ {
        constructor(t, i, e, s, n) {
            if (KE.p0(i),
            KE.p0(e),
            KE.kQ(s),
            n !== ZE)
                throw new Error("notifications can only be created using C3.UI.Notification.ShowAt() method");
            if (super(),
            "string" == typeof t && (t = self.app.u0(t)),
            t || (t = self.app.u0("info")),
            KE.Ef(t, KE.Qs.d0),
            !t.ORi())
                throw new Error("notifications can only use medium icons");
            if (this.pqi = i,
            this.mqi = e,
            s = Object.assign({}, JE, s),
            KE.zt(s.align),
            KE.Ge(s.UEt),
            !qE.has(s.align))
                throw new Error("invalid alignment");
            this.dn = !1,
            this.s0i = -1,
            this.bqi = s.align,
            this.n0i = !!s.e0i,
            this.r0i = 0,
            this.Sqi = -1,
            this.h0i = !1,
            this.yqi = s.UEt,
            this.o0i = () => this.a0i(),
            this.l0i = () => this.u0i(),
            this.c0i = () => this.d0i(),
            this.f0i = () => this.wqi(),
            this.p0i = t => this.m0i(t),
            this.w0i = t => this.g0i(t),
            this.ght = KE.Qs.W_("ui-notification"),
            this.y0i = null,
            this.n0i && (this.y0i = KE.Qs.mk.Oxi()),
            this.y0i ? (this.y0i.k_().appendChild(this.ght),
            this.y0i.addEventListener("positionchange", this.o0i),
            this.y0i.addEventListener("widthchange", this.o0i),
            this.y0i.addEventListener("heightchange", this.o0i),
            this.y0i.addEventListener("startdragging", this.c0i),
            this.y0i.addEventListener("finishdragging", this.l0i),
            this.y0i.addEventListener("startresizing", this.c0i),
            this.y0i.addEventListener("finishresizing", this.l0i)) : (document.body.appendChild(this.ght),
            this.ght.setAttribute("document-parent", "")),
            this.gmt = !1,
            this.Mqi = null,
            this.Eqi = null,
            this.r0t = null,
            this.fYt = null,
            this.oit = null,
            this.ght.ownerDocument.defaultView && (!this.y0i || !this.y0i.hCi() && this.y0i.XO()) && (this.gmt = !0,
            this.ght.setAttribute("align", this.bqi),
            this.ght.style.transitionDuration = s.duration,
            this.Mqi = KE.Qs.W_("ui-notification-icon", this.ght),
            this.Eqi = KE.Qs.W_("ui-notification-text", this.ght),
            this.r0t = KE.v(KE.Qs._q, t),
            this.Mqi.appendChild(this.r0t.k_()),
            this.fYt = KE.Qs.W_("ui-notification-title", this.Eqi),
            this.oit = KE.Qs.W_("ui-notification-body", this.Eqi),
            KE.wQ(this.fYt, this.pqi),
            KE.wQ(this.oit, this.mqi),
            this.Ex = this.ght.getBoundingClientRect().height,
            "function" == typeof s.onclick && this.ght.addEventListener("click", () => {
                this.wqi(),
                s.onclick()
            }
            ),
            KE.Qs.WQi.KQi(this),
            self.app.jKt() || (this.ght.style.transition = "none"),
            this.b0i())
        }
        S0(t=!0) {
            KE.gn(this) || this.dn || (clearTimeout(this.s0i),
            this.dn = !0,
            (t = !!t) && KE.Qs.WQi.ZQi(this),
            this.y0i && (this.y0i.removeEventListener("positionchange", this.o0i),
            this.y0i.removeEventListener("widthchange", this.o0i),
            this.y0i.removeEventListener("heightchange", this.o0i),
            this.y0i.removeEventListener("startdragging", this.c0i),
            this.y0i.removeEventListener("finishdragging", this.l0i),
            this.y0i.removeEventListener("startresizing", this.c0i),
            this.y0i.removeEventListener("finishresizing", this.l0i),
            this.y0i = null,
            this.o0i = null,
            this.c0i = null,
            this.l0i = null),
            this.ght.removeEventListener("transitionend", this.p0i),
            this.p0i = null,
            this.ght.removeEventListener("transitionend", this.w0i),
            this.w0i = null,
            this.iQi(),
            this.r0t && this.r0t.he(),
            KE.Qs.UO(this.fYt),
            KE.Qs.UO(this.Mqi),
            KE.Qs.UO(this.Eqi),
            KE.Qs.UO(this.ght),
            this.Mqi = null,
            this.Eqi = null,
            this.r0t = null,
            this.fYt = null,
            this.oit = null,
            this.ght = null,
            KE.he(this))
        }
        v0i() {
            return this.gmt
        }
        qQi() {
            return this.bqi
        }
        S0i() {
            return this.yqi
        }
        zoe() {
            return this.Ex + XE
        }
        XQi(t) {
            KE.Ge(t),
            t >= KE.Qs.WQi.YQi - 1 && (t = KE.Qs.WQi.YQi - 1),
            this.r0i !== t && (this.r0i = t,
            this.a0i())
        }
        b0i() {
            this.a0i(),
            this.ght.setAttribute("showing", this.bqi),
            self.app.jKt() ? this.ght.addEventListener("transitionend", this.p0i) : KE.Qs.WQi.QQi(this)
        }
        m0i(t) {
            KE.gn(this) || this.dn || "transform" === t.propertyName && (this.ght.removeEventListener("transitionend", this.p0i),
            KE.Qs.WQi.QQi(this))
        }
        x0i() {
            this.h0i || (this.h0i = !0,
            this.ght.removeAttribute("showing"),
            "top-left" !== this.bqi && "bottom-left" !== this.bqi || this.ght.setAttribute("hiding-left", ""),
            "top-right" !== this.bqi && "bottom-right" !== this.bqi || this.ght.setAttribute("hiding-right", ""),
            self.app.jKt() ? (this.ght.addEventListener("transitionend", this.w0i),
            this.s0i = setTimeout( () => {
                this.S0()
            }
            , YE)) : this.S0())
        }
        g0i(t) {
            KE.gn(this) || this.dn || "transform" === t.propertyName && (this.ght.removeEventListener("transitionend", this.w0i),
            this.S0())
        }
        iQi() {
            clearTimeout(this.Sqi)
        }
        t0i() {
            this.Sqi = setTimeout(this.f0i, this.yqi)
        }
        M0i() {
            this.ght.setAttribute("no-position-transitions", "")
        }
        d0i() {
            this.ght.setAttribute("no-transitions", "")
        }
        u0i() {
            this.ght.removeAttribute("no-transitions")
        }
        E0i() {
            return !this.ght.hasAttribute("no-transitions")
        }
        wqi() {
            this.iQi(),
            this.E0i() || (this.u0i(),
            this.M0i()),
            this.x0i()
        }
        a0i() {
            let t = this.ght.style
              , i = KE.Qs.WQi.i0i(this);
            if (this.y0i && !this.y0i.iCi()) {
                let e = this.ght.ownerDocument
                  , s = e.defaultView
                  , n = s.innerWidth || e.documentElement.clientWidth || e.body.clientWidth
                  , r = s.innerHeight || e.documentElement.clientHeight || e.body.clientHeight
                  , h = this.y0i.ESi()
                  , o = this.y0i.CSi()
                  , a = n - (h + this.y0i.ns())
                  , l = r - (o + this.y0i.er());
                "top-left" === this.bqi ? (t.left = -h + "px",
                t.top = `${-o + i}px`) : "top-right" === this.bqi ? (t.right = -a + "px",
                t.top = `${-o + i}px`) : "bottom-left" === this.bqi ? (t.left = -h + "px",
                t.bottom = `${-l + i}px`) : "bottom-right" === this.bqi && (t.right = -a + "px",
                t.bottom = `${-l + i}px`)
            } else
                "top-left" === this.bqi ? (t.left = "0px",
                t.top = `${i}px`) : "top-right" === this.bqi ? (t.right = "0px",
                t.top = `${i}px`) : "bottom-left" === this.bqi ? (t.left = "0px",
                t.bottom = `${i}px`) : "bottom-right" === this.bqi && (t.right = "0px",
                t.bottom = `${i}px`)
        }
        static NT(t, i, e, s) {
            if (!self.app.C0i())
                return;
            const n = KE.Qs.mk.Oxi();
            if (n && n.Bxi() && !s.e0i && !n.Tmt())
                return;
            const r = KE.v(KE.Qs.Notification, t, i, e, s, ZE);
            r.v0i() || r.S0(!1)
        }
    }
}
{
    const QE = self.t
      , tC = QE.bW(import.meta.url).getElementById("ui-loader-template")
      , iC = !1;
    QE.Qs.hEt = class {
        constructor(t) {
            QE.Ef(t, HTMLElement),
            this.element = document.createElement("ui-loader");
            const i = tC.content.cloneNode(!0);
            iC ? this.element.createShadowRoot().appendChild(i) : this.element.appendChild(i),
            t && t.appendChild(this.element)
        }
        eP(t) {
            t ? this.element.removeAttribute("hidden", "") : this.element.setAttribute("hidden", "")
        }
        aEt() {
            this.element.setAttribute("pause", "")
        }
        _0i() {
            this.element.removeAttribute("pause")
        }
        get rEt() {
            return this.element.getElementsByTagName("ui-loader-message")[0].textContent
        }
        set rEt(t) {
            this.element.getElementsByTagName("ui-loader-message")[0].textContent = t
        }
        remove() {
            this.element.remove()
        }
    }
}
{
    const eC = self.t;
    eC.sF = eC.v(eC.Event.v_),
    eC.Z1 = class {
        constructor(t, i, e) {
            if (eC.zt(t),
            eC.IL(i),
            eC.cti(e, "#document"),
            e === document)
                throw new Error("component cannot reference main document");
            this.Rdi = t,
            this.T0i = i,
            this.I0i = e,
            this.P0i = e.documentURI
        }
        he() {
            this.Rdi = null,
            this.T0i = null,
            this.I0i = null,
            this.P0i = null
        }
        Bk() {
            return this.Rdi
        }
        ez() {
            return this.T0i
        }
        bW() {
            return this.I0i
        }
        G0i() {
            return this.P0i
        }
    }
}
{
    const sC = self.t
      , nC = "c3-user-settings"
      , rC = ["account", "account-access-code", "account-login", "account-logout", "account-register", "add", "add-folder", "addon", "align-bottom", "align-top", "align-left", "align-vcenter", "align-hcenter", "align-right", "align-edge-left", "align-edge-top", "align-edge-right", "align-edge-bottom", "all-frames", "all-columns", "all-rows", "ambiguous", "animation", "animation-column", "animation-row", "array", "arrow-pointer", "archive", "async-action", "async-end", "audio", "auto-keyframes", "back", "bar", "bookmark", "breakpoint", "breakpoint-active-left", "breakpoint-active-right", "brush", "bucket", "build", "c3-mono", "check", "cleanup", "clear", "cloud", "cloud-upload", "close", "closed-folder", "code", "collapsed", "compress", "color", "copy", "crop", "cross", "csv", "cut", "debug", "default-interpolation", "delete", "delete-all", "delete-column", "delete-row", "dictionary", "disabled", "dot", "download", "dpad", "dropbox", "duplicate", "edit", "ellipse", "eraser", "error", "event-comment", "event-sheet", "exit-fullscreen", "expanded", "export", "external", "eye-dropper", "file", "file-preview", "flag", "flash", "flowchart", "focus", "font", "frame", "fullscreen", "function", "generic-file", "globe", "global-variable", "google-drive", "goto", "grid", "guided-tour", "hand", "help", "home", "html", "html-tag", "image", "import", "import-files", "insert-row-before", "insert-row-after", "insert-column-before", "insert-column-after", "install-app", "instance-variable", "info", "invert-ease", "invisible", "javascript", "javascript-color", "json", "language", "layers", "layout", "line", "link", "link-anchor", "local-variable", "location-pin", "locked", "loop-condition", "menu-dots", "menu-submenu", "mesh", "mirror-h", "mirror-v", "move-down", "move-up", "new", "next", "numbers", "offline", "onedrive", "open", "open-folder", "open-popup", "origin", "output", "paste", "patch", "pause", "pause-timeline", "pdf", "pin", "pin-off", "play", "polygon", "preview", "preview-debug", "previous", "print", "rectangle", "rectangle-select", "redo", "reload", "remote-preview", "remove", "replace", "replica", "resize", "reverse", "rotate-acw", "rotate-cw", "save", "scene-graph", "scirra-store", "scroll", "search", "security-shield", "select-all", "send-to-back", "send-to-front", "set-keyframes", "settings", "share-arrow", "shared-folder", "shopping-cart", "skip-first", "skip-last", "skip-next", "skip-previous", "sort", "sound", "space-horiz", "space-vert", "star", "statistics", "stop", "style", "support", "template", "terms", "text-overlay-l", "text-overlay-r", "text-short", "thumbnail", "tiles", "timeline", "timeline-ui", "timer", "toggle-background", "tools", "touch", "transition", "translucent", "trigger-condition", "typescript", "typescript-color", "undo", "unknown-file", "unlocked", "update", "upload", "up-arrow", "video", "videogame", "view", "visible", "warning", "wrap-selection", "xml", "z-order", "zoom-in", "zoom-out", "zoom-reset", "family-overlay-mask", "custom-ace-overlay-mask", {
        name: "effect",
        color: "--effect-icon-color"
    }, {
        name: "family-overlay",
        color: "--family-overlay-icon-color"
    }, {
        name: "custom-ace",
        color: "--custom-ace-icon-color"
    }, {
        name: "custom-ace-overlay",
        color: "--custom-ace-overlay-icon-color"
    }, {
        name: "image-point",
        color: "#FF0000"
    }, {
        name: "invert",
        color: "--invert-icon-color"
    }, {
        uci: "origin",
        name: "origin-cursor",
        color: "#FFFFFF"
    }, {
        uci: "image-point",
        name: "image-point-cursor",
        color: "#00FFFF"
    }, {
        uci: "animation",
        name: "default-animation",
        color: "--default-icon-color"
    }]
      , hC = new Set(["save", "undo", "redo", "preview", "preview-debug", "menu-submenu", "account", "open-folder", "closed-folder"])
      , oC = new Set(["animation", "event-sheet", "instance-variable", "layout", "loop-condition", "trigger-condition"])
      , aC = !!window.C3_IsPopupWindow;
    let lC = !1;
    sC.UMi = class extends sC.Event.v_ {
        constructor() {
            if (super(),
            lC)
                throw new Error("only one C3.App should be instantiated");
            lC = !0,
            this.Ftt = "MyApp",
            this.e1 = new Map,
            this.PQi = aC,
            this.A0i = null,
            this.R0i = 0,
            this.k0i = 0,
            this.O0i = 0,
            this.D0i = {},
            this.F0i = !1,
            "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", () => {
                this.R0i = Math.round(1.54 * sC.Qs.vwe()),
                this.k0i = 2 * this.R0i,
                this.O0i = 2 * this.k0i
            }
            ) : (this.R0i = Math.round(1.54 * sC.Qs.vwe()),
            this.k0i = 2 * this.R0i,
            this.O0i = 2 * this.k0i),
            this.L0i = new Map,
            this.B0i = new Map,
            this.U0i = new Map,
            window.app = this
        }
        N0i() {
            this.PQi || (this.A0i = sC.v(sC.Qs.g_, "main", !1),
            this.A0i.NTi(!0))
        }
        j0i() {
            self.C3_HideLoader(),
            sC.Qs.Uvi("supportMessage"),
            sC.Qs.Nvi("noscript"),
            sC.Qs.Nvi("script[src$='supportCheck.js']"),
            sC.Qs.Nvi("script[src$='es2015check.js']"),
            this.A0i.NTi(!1)
        }
        La() {
            return this.Ftt
        }
        Vvi() {
            return this.A0i
        }
        m4() {
            return this.R0i
        }
        Oq() {
            return this.k0i
        }
        s8() {
            return this.O0i
        }
        eNi(t) {
            switch (sC.zt(t),
            t) {
            case "small":
                return this.R0i;
            case "medium":
                return this.k0i;
            case "large":
                return this.O0i;
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        iCi() {
            return this.PQi
        }
        $0i() {
            const t = new sC.Event("load");
            return t.app = this,
            t.eF = this.PQi,
            sC.sF.ufi(t)
        }
        z0i() {
            const t = new sC.Event("afterload");
            return t.app = this,
            t.eF = this.PQi,
            sC.sF.ufi(t)
        }
        L1(t) {
            return sC.zt(t),
            this.e1.get(t)
        }
        V0i(t) {
            return sC.zt(t),
            this.e1.has(t)
        }
        hF(t, i, e) {
            if (sC.zt(t),
            sC.IL(i),
            sC.cti(e, "#document"),
            e === document)
                throw new Error("cannot register component with main document");
            if (this.V0i(t))
                throw new Error(`component id '${t}' already registered`);
            let s = sC.v(sC.Z1, t, i, e);
            this.e1.set(t, s);
            let n = new sC.Event("registercomponent");
            n.app = this,
            n.component = s,
            sC.sF.dispatchEvent(n)
        }
        W0i(t) {
            if (sC.zt(t),
            !this.V0i(t))
                throw new Error(`component id '${t}' is not registered`);
            let i = this.e1.get(t)
              , e = new sC.Event("unregistercomponent");
            e.app = this,
            e.component = i,
            sC.sF.dispatchEvent(e),
            i.he(),
            this.e1.delete(t)
        }
        uq(t) {
            const i = this.L1(t);
            return i ? i.ez() : null
        }
        H0i() {
            return {}
        }
        async K0i() {
            const t = await localforage.getItem(nC)
              , i = Object.assign({}, this.H0i(), t);
            return this.D0i = i,
            this.F0i = !0,
            i
        }
        q0i() {
            return this.F0i
        }
        aU() {
            return this.D0i
        }
        X0i() {
            return localforage.setItem(nC, this.D0i).catch(t => this._we(t))
        }
        Y0i(t) {
            sC.zt(t);
            let i = new sC.Event(t);
            i.J0i = this.D0i,
            this.dispatchEvent(i)
        }
        jKt() {
            return !0
        }
        iN() {
            return !0
        }
        Z0i() {
            let t = document.body.parentElement
              , i = this.iN() ? "highgfxmode" : "lowgfxmode"
              , e = this.iN() ? "lowgfxmode" : "highgfxmode";
            t.removeAttribute(e),
            t.setAttribute(i, "")
        }
        Q0i() {
            this.Z0i(),
            sC.V8t();
            const t = [];
            for (const i of hC)
                t.push(this.L0i.get(i).$ii());
            return Promise.all(t)
        }
        async t1i() {
            sC.lU("PrefetchAllIcons");
            const t = [];
            for (const [i,e] of this.L0i.entries())
                hC.has(i) || t.push(e.$ii());
            await Promise.all(t),
            sC.OU("PrefetchAllIcons")
        }
        i1i() {
            let t = sC.Qs.wP.DSi();
            for (let i of rC) {
                let e, s = null, n = null;
                "object" == typeof i ? (e = i.name,
                s = i.color,
                n = i.uci,
                s.startsWith("--") && (s = sC.Qs.wP.pP(s))) : (e = i,
                oC.has(i) && (s = sC.Qs.wP.pP("--project-item-icon-color")));
                let r = n || e
                  , h = sC.v(sC.Qs.YRi, this, `${t}${r}.svg`, {
                    name: e,
                    color: s
                });
                this.L0i.set(e, h)
            }
        }
        async e1i() {
            const t = [];
            for (let i of rC) {
                let e = ""
                  , s = null;
                "object" == typeof i ? (e = i.name,
                s = i.color,
                s.startsWith("--") && (s = sC.Qs.wP.pP(s))) : (e = i,
                oC.has(i) && (s = sC.Qs.wP.pP("--project-item-icon-color"))),
                e && s && t.push(this.L0i.get(e).Jn(s))
            }
            await Promise.all(t)
        }
        oi(t) {
            sC.zt(t);
            let i = this.L0i.get(t);
            if (i)
                return i.uP();
            throw new Error(`common small icon '${t}' not found`)
        }
        u0(t) {
            sC.zt(t);
            let i = this.L0i.get(t);
            if (i)
                return i.M8();
            throw new Error(`common medium icon '${t}' not found`)
        }
        s1i(t) {
            sC.zt(t);
            let i = this.L0i.get(t);
            if (i)
                return i.COi();
            throw new Error(`common large icon '${t}' not found`)
        }
        n1i(t, i) {
            switch (sC.zt(t),
            sC.zt(i),
            i) {
            case "small":
                return this.oi(t);
            case "medium":
                return this.u0(t);
            case "large":
                return this.s1i(t);
            default:
                throw new Error("invalid icon size")
            }
        }
        XJi(t, i) {
            return sC.zt(t),
            sC.Ge(i),
            i <= this.m4() ? this.oi(t) : i <= this.Oq() ? this.u0(t) : this.s1i(t)
        }
        async vOi(t) {
            const i = sC.Qs.wP.DSi();
            if (t.startsWith(i)) {
                const i = sC.zti(t).toLowerCase()
                  , e = await sC.Qs.wP.FSi();
                return e.hasOwnProperty(i) ? e[i] : sC.Bii(t)
            }
            return sC.Bii(t)
        }
        YVt(t) {
            return sC.zt(t),
            this.L0i.get(t) || null
        }
        g_t(t) {
            if (sC.zt(t),
            this.B0i.has(t))
                return this.B0i.get(t);
            let i = new Blob([`<svg version="1.1"\n\t\t\tbaseProfile="full"\n\t\t\twidth="100%" height="100%"\n\t\t\tstyle="text-rendering:geometricPrecision; image-rendering:optimizeQuality;"\n\t\t\txmlns="http://www.w3.org/2000/svg"\n\t\t\tstroke="black"\n\t\t\tfill="black">\n\t\n\t\t\t<text x="50%" y="50%" dy=".45em" font-size="10" text-anchor="middle" stroke-width="1.1px">${t}</text>\n\t\t</svg>`],{
                type: "image/svg+xml"
            })
              , e = URL.createObjectURL(i)
              , s = sC.v(sC.Qs.YRi, self.app, e, {});
            return this.B0i.set(t, s),
            s
        }
        dP(t, i) {
            if (sC.J1(i),
            sC.zt(i.name),
            sC.zt(i.color),
            this.U0i.has(i.name))
                return this.U0i.get(i.name);
            const e = sC.v(sC.Qs.YRi, self.app, t.r1i(), {
                name: "plugin-" + t.Bk() + "-" + i.name,
                color: i.color
            });
            return this.U0i.set(i.name, e),
            e
        }
        USi() {
            return this.L0i.values()
        }
        _we(t) {
            (() => {})("Storage write error:", t)
        }
    }
}
{
    const uC = self.t
      , cC = self.r_
      , dC = cC.l_
      , fC = cC.L8t
      , pC = cC.o_
      , mC = dC.create()
      , wC = dC.create()
      , gC = dC.create()
      , yC = fC.create()
      , bC = pC.create()
      , vC = dC.create()
      , SC = dC.create()
      , xC = dC.create()
      , MC = dC.create()
      , EC = dC.create()
      , CC = dC.create()
      , _C = dC.create()
      , TC = dC.create()
      , IC = fC.r6t(0, 0, 1, 1);
    function PC(t, i, e, s) {
        const n = gC;
        dC.m6t(mC, e, i),
        dC.m6t(wC, t, i),
        dC.Q6t(n, mC, wC),
        dC.normalize(n, n),
        s.set(n[0], n[1], n[2], dC.dot(t, n))
    }
    function GC(t, i, e, s, n, r, h) {
        const o = h.x
          , a = h.y
          , l = h.z
          , u = h.w
          , c = h.xF
          , d = h.yF
          , f = h.zF
          , p = 1 - c
          , m = 1 - d
          , w = 1 - f;
        if (o * t * c + o * s * p + a * i * d + a * n * m + l * e * f + l * r * w >= u)
            return !0;
        return o * s * c + o * t * p + a * n * d + a * i * m + l * r * f + l * e * w > u
    }
    function AC(t, i, e, s) {
        return s.x * t + s.y * i + s.z * e >= s.w
    }
    uC.ea = {
        jw(t, i, e, s, n, r, h) {
            const o = s[0] * t + s[4] * i + s[8] * e + s[12]
              , a = s[1] * t + s[5] * i + s[9] * e + s[13]
              , l = s[2] * t + s[6] * i + s[10] * e + s[14]
              , u = s[3] * t + s[7] * i + s[11] * e + s[15];
            let c = n[0] * o + n[4] * a + n[8] * l + n[12] * u
              , d = n[1] * o + n[5] * a + n[9] * l + n[13] * u
              , f = n[2] * o + n[6] * a + n[10] * l + n[14] * u
              , p = n[3] * o + n[7] * a + n[11] * l + n[15] * u;
            return 0 !== p && (p = 1 / p,
            c *= p,
            d *= p,
            f *= p,
            h[0] = (.5 * c + .5) * r[2] + r[0],
            h[1] = (.5 * d + .5) * r[3] + r[1],
            h[2] = .5 * (1 + f),
            !0)
        },
        h1i(t, i, e, s, n, r, h) {
            const o = bC
              , a = yC;
            return pC.multiply(o, n, s),
            null !== pC.o6t(o, o) && (a[0] = (t - r[0]) / r[2] * 2 - 1,
            a[1] = (i - r[1]) / r[3] * 2 - 1,
            a[2] = 2 * e - 1,
            a[3] = 1,
            fC.s8t(a, a, o),
            0 !== a[3] && (a[3] = 1 / a[3],
            h[0] = a[0] * a[3],
            h[1] = a[1] * a[3],
            h[2] = a[2] * a[3],
            !0))
        },
        o1i(t, i, e, s, n, r, h) {
            const o = mC
              , a = wC;
            if (!uC.ea.h1i(t, i, 0, s, n, r, o))
                return !1;
            if (!uC.ea.h1i(t, i, 1, s, n, r, a))
                return !1;
            const l = wC;
            dC.m6t(l, a, o);
            const u = gC;
            dC.set(u, 0, 0, 1);
            const c = -e
              , d = dC.dot(u, l);
            let f = 0;
            if (0 === d) {
                if (0 !== dC.dot(u, o) + c)
                    return !1
            } else if (f = -(dC.dot(o, u) + c) / d,
            f < 0)
                return !1;
            return dC.q6t(h, o, l, f),
            !0
        }
    };
    class RC {
        constructor() {
            this.x = NaN,
            this.y = NaN,
            this.z = NaN,
            this.w = NaN,
            this.xF = NaN,
            this.yF = NaN,
            this.zF = NaN
        }
        set(t, i, e, s) {
            this.x = t,
            this.y = i,
            this.z = e,
            this.w = s,
            this.xF = t > 0 ? 1 : 0,
            this.yF = i > 0 ? 1 : 0,
            this.zF = e > 0 ? 1 : 0
        }
    }
    uC.ea.a1i = class {
        constructor() {
            this.l1i = new RC,
            this.u1i = new RC,
            this.c1i = new RC,
            this.d1i = new RC,
            this.f1i = new RC,
            this.p1i = new RC
        }
        m1i(t, i) {
            const e = IC;
            uC.ea.h1i(0, 1, 0, t, i, e, vC),
            uC.ea.h1i(1, 1, 0, t, i, e, SC),
            uC.ea.h1i(0, 0, 0, t, i, e, xC),
            uC.ea.h1i(1, 0, 0, t, i, e, MC),
            uC.ea.h1i(0, 1, 1, t, i, e, EC),
            uC.ea.h1i(1, 1, 1, t, i, e, CC),
            uC.ea.h1i(0, 0, 1, t, i, e, _C),
            uC.ea.h1i(1, 0, 1, t, i, e, TC),
            PC(xC, vC, EC, this.l1i),
            PC(vC, SC, CC, this.u1i),
            PC(SC, MC, TC, this.c1i),
            PC(MC, xC, _C, this.d1i),
            PC(_C, EC, CC, this.p1i),
            PC(MC, SC, vC, this.f1i)
        }
        w1i(t, i, e, s, n, r) {
            return GC(t, i, e, s, n, r, this.l1i) && GC(t, i, e, s, n, r, this.u1i) && GC(t, i, e, s, n, r, this.c1i) && GC(t, i, e, s, n, r, this.d1i) && GC(t, i, e, s, n, r, this.f1i) && GC(t, i, e, s, n, r, this.p1i)
        }
        g1i(t, i, e) {
            return !AC(t, i, e, this.f1i)
        }
    }
}
{
    const kC = self.t;
    kC.ea.y1i = class {
        constructor(t, i, e, s, n, r, h) {
            this.cn = t,
            this.Byi = 0,
            this.b1i = null,
            this.v1i = "",
            this.S1i = e,
            this.Co = kC.v(kC.za),
            this.Co.set(s),
            this.x1i = n,
            this.M1i = r,
            this.E1i = h,
            "string" == typeof i ? this.v1i = i : (this.b1i = i,
            this.v1i = this.b1i.La())
        }
        he() {
            if (this.Byi > 0)
                throw new Error("releasing state group still in use");
            this.cn = null,
            this.b1i = null,
            this.v1i = ""
        }
        _Si() {
            const t = this.cn;
            t.dm(this.b1i),
            t.mb(this.S1i),
            t.Jn(this.Co),
            t.JR(this.x1i),
            t.hm(this.M1i),
            t.om(this.E1i),
            t.C1i(this)
        }
        _1i() {
            return kC.ea.y1i.T1i(this.v1i, this.S1i, this.Co, this.x1i, this.M1i, this.E1i)
        }
        I1i() {
            ++this.Byi
        }
        P1i() {
            --this.Byi
        }
        G1i() {
            return this.Byi
        }
        ks() {
            this.b1i = null
        }
        MS(t) {
            if (this.b1i = t.A1i(this.v1i),
            !this.b1i)
                throw new Error("failed to restore shader program")
        }
        static T1i(t, i, e, s, n, r) {
            return ("string" == typeof t ? t : t.La()) + "," + i + "," + e.xsi() + "," + e.Msi() + "," + e.Esi() + "," + e.Ix() + "," + s + "," + n + "," + r
        }
    }
}
{
    const OC = globalThis.t
      , DC = globalThis.assert
      , FC = 65535;
    function LC(t, i, e) {
        const s = e.Zn()
          , n = e.tr()
          , r = e.lm() - s
          , h = e.el() - n;
        return [s + r * t + (e.Fl() - s) * i, n + h * t + (e.El() - n) * i]
    }
    OC.ea.DE = class {
        constructor(t, i, e) {
            this.R1i = t,
            this.k1i = i,
            this.JYi = e,
            this.Ec = NaN,
            this.zc = NaN,
            this.x1i = NaN,
            this._u = NaN,
            this._v = NaN,
            this.Ec = 0,
            this.zc = 0,
            this.x1i = 0,
            this._u = 0,
            this._v = 0
        }
        GRi(t, i, e, s) {
            this.Ec = t,
            this.zc = i,
            this._u = e,
            this._v = s
        }
        ka() {
            return this.Ec
        }
        Fo(t) {
            this.Ec !== t && (this.Ec = t,
            this.R1i.O1i())
        }
        Ra() {
            return this.zc
        }
        Eo(t) {
            this.zc !== t && (this.zc = t,
            this.R1i.O1i())
        }
        qR() {
            return this.x1i
        }
        Nie(t) {
            this.x1i !== t && (this.x1i = Math.max(t, 0),
            this.R1i.O1i())
        }
        NX() {
            return this._u
        }
        ZX(t) {
            this._u = t
        }
        VX() {
            return this._v
        }
        $X(t) {
            this._v = t
        }
        D1i(t, i, e) {
            [this.Ec,this.zc] = LC(t.Ec, t.zc, i),
            this.x1i = t.x1i,
            this._u = OC.mi(e.Yr(), e.pl(), t._u),
            this._v = OC.mi(e.Jr(), e.dl(), t._v)
        }
        F1i(t, i, e) {
            [this.Ec,this.zc] = LC(t.Ec, t.zc, i),
            this.x1i = t.x1i,
            [this._u,this._v] = LC(t._u, t._v, e)
        }
        oM() {
            return {
                x: this.ka(),
                y: this.Ra(),
                z: this.qR(),
                u: this.NX(),
                v: this.VX()
            }
        }
        L1i(t) {
            this.Fo(t.x),
            this.Eo(t.y),
            t.hasOwnProperty("z") && this.Nie(t.z),
            this.ZX(t.u),
            this.$X(t.v)
        }
        Rte() {
            return this.R1i
        }
        Tle() {
            return this.k1i
        }
        Lle() {
            return this.JYi
        }
    }
    ,
    OC.ea.B1i = class {
        constructor(t, i, e) {
            if (t < 2 || i < 2)
                throw new Error("invalid mesh size");
            this.U1i = t,
            this.N1i = i,
            this.j1i = e || null,
            this.$1i = [],
            this.z1i = 0,
            this.V1i = 0,
            this.W1i = 1,
            this.H1i = 1,
            this.K1i = 0,
            this.q1i = !1,
            this.X1i = [],
            this.Y1i = 0,
            this.J1i = !0;
            const s = t - 1
              , n = i - 1;
            for (let e = 0; e < i; ++e) {
                const i = [];
                for (let r = 0; r < t; ++r) {
                    const t = OC.v(OC.ea.DE, this, r, e)
                      , h = r / s
                      , o = e / n;
                    t.GRi(h, o, h, o),
                    i.push(t)
                }
                this.$1i.push(i)
            }
        }
        he() {
            OC.Io(this.$1i),
            OC.Io(this.X1i)
        }
        Oa() {
            return this.U1i
        }
        Ta() {
            return this.N1i
        }
        _te() {
            return this.j1i
        }
        Z1i() {
            return this.$1i
        }
        O1i() {
            this.q1i = !0,
            this.J1i = !0
        }
        Q1i() {
            if (!this.q1i)
                return;
            let t = 1 / 0
              , i = 1 / 0
              , e = -1 / 0
              , s = -1 / 0
              , n = 0;
            for (const r of this.$1i)
                for (const h of r) {
                    const r = h.ka()
                      , o = h.Ra();
                    t = Math.min(t, r),
                    i = Math.min(i, o),
                    e = Math.max(e, r),
                    s = Math.max(s, o),
                    n = Math.max(n, h.qR())
                }
            this.z1i = t,
            this.V1i = i,
            this.W1i = e,
            this.H1i = s,
            this.K1i = n,
            this.q1i = !1
        }
        g$() {
            return this.Q1i(),
            this.z1i
        }
        _$() {
            return this.Q1i(),
            this.V1i
        }
        S$() {
            return this.Q1i(),
            this.W1i
        }
        b$() {
            return this.Q1i(),
            this.H1i
        }
        t2i() {
            return this.Q1i(),
            this.K1i
        }
        i2i() {
            return this.t2i() > 0
        }
        Pa(t, i) {
            return t = Math.floor(t),
            i = Math.floor(i),
            t < 0 || t >= this.U1i || i < 0 || i >= this.N1i ? null : this.$1i[i][t]
        }
        e2i(t, i, e) {
            OC.U(t, OC.ea.B1i),
            OC.U(i, OC.zn),
            OC.eI(e, OC.Rect, OC.zn);
            const s = e instanceof OC.Rect;
            if (t.Oa() !== this.Oa() || t.Ta() !== this.Ta())
                throw new Error("source mesh wrong size");
            const n = t.$1i
              , r = this.$1i;
            for (let t = 0, h = r.length; t < h; ++t) {
                const h = n[t]
                  , o = r[t];
                for (let t = 0, n = o.length; t < n; ++t) {
                    const n = h[t]
                      , r = o[t];
                    s ? r.D1i(n, i, e) : r.F1i(n, i, e)
                }
            }
            this.J1i = !0
        }
        s2i(t) {
            if (!this.J1i && this.Y1i === t)
                return;
            const i = this.U1i
              , e = this.N1i
              , s = this.X1i
              , n = Math.floor(FC / i) - 1;
            if (n <= 0)
                throw new Error("mesh too large");
            const r = Math.ceil((e - 1) / n);
            r < s.length && (s.length = r);
            let h = 0;
            for (let o = 0; o < r; ++o) {
                const r = Math.min(n, e - h - 1);
                DC(r > 0, "invalid mesh chunk");
                const a = (r + 1) * i
                  , l = 3 * a
                  , u = 2 * a
                  , c = (i - 1) * r * 6;
                if (o === s.length)
                    s.push({
                        n2i: new Float32Array(l),
                        r2i: new Float32Array(u),
                        h2i: new Uint16Array(c)
                    });
                else {
                    const t = s[o];
                    t.n2i.length !== l && (t.n2i = new Float32Array(l)),
                    t.r2i.length !== u && (t.r2i = new Float32Array(u)),
                    t.h2i.length !== c && (t.h2i = new Uint16Array(c))
                }
                const {n2i: d, r2i: f, h2i: p} = s[o];
                this.o2i(h, r, t, d, f, p),
                h += n
            }
            this.Y1i = t,
            this.J1i = !1
        }
        o2i(t, i, e, s, n, r) {
            const h = this.$1i
              , o = this.U1i;
            let a = 0
              , l = 0
              , u = 0;
            for (let c = t, d = t + i + 1; c < d; ++c) {
                const i = h[c]
                  , f = c + 1
                  , p = c - t
                  , m = p * o
                  , w = (p + 1) * o;
                for (let t = 0, h = i.length; t < h; ++t) {
                    const o = i[t]
                      , c = t + 1;
                    if (s[a++] = o.ka(),
                    s[a++] = o.Ra(),
                    s[a++] = o.qR() + e,
                    n[l++] = o.NX(),
                    n[l++] = o.VX(),
                    c < h && f < d) {
                        const i = t + m
                          , e = c + m
                          , s = c + w
                          , n = t + w;
                        r[u++] = i,
                        r[u++] = e,
                        r[u++] = s,
                        r[u++] = i,
                        r[u++] = s,
                        r[u++] = n
                    }
                }
            }
        }
        $n(t, i) {
            this.s2i(i);
            for (const {n2i: i, r2i: e, h2i: s} of this.X1i)
                t.a2i(i, e, s)
        }
        l2i(t, i) {
            i || (i = (t, i, e) => [t, i, e]);
            const e = this.$1i;
            let s = e[0];
            for (let n = 1, r = e.length; n < r; ++n) {
                const h = e[n];
                let o = s[0]
                  , a = h[0];
                for (let e = 1, l = h.length; e < l; ++e) {
                    const u = s[e]
                      , c = h[e]
                      , [d,f,p] = i(o.ka(), o.Ra(), o.qR())
                      , [m,w,g] = i(u.ka(), u.Ra(), u.qR())
                      , [y,b,v] = i(c.ka(), c.Ra(), c.qR())
                      , [S,x,M] = i(a.ka(), a.Ra(), a.qR());
                    t.u2i(d, f, p, m, w, g),
                    t.u2i(d, f, p, y, b, v),
                    t.u2i(d, f, p, S, x, M),
                    e === l - 1 && t.u2i(m, w, g, y, b, v),
                    n === r - 1 && t.u2i(S, x, M, y, b, v),
                    o = u,
                    a = c
                }
                s = h
            }
        }
        c2i(t) {
            const i = .001
              , e = .99999999
              , s = t.d2i()
              , n = []
              , r = this.Oa() - 1
              , h = this.Ta() - 1
              , o = 1 / r
              , a = 1 / h
              , l = r - 1
              , u = h - 1;
            let c = s[0]
              , d = s[1]
              , f = OC.Ne(Math.floor(c * r), 0, l)
              , p = OC.Ne(Math.floor(d * h), 0, u)
              , m = !0
              , w = 0
              , g = 0
              , y = 0;
            let b = -1;
            const v = () => {
                c = OC.Ne(OC.mi(c, w, y), 0, 1),
                d = OC.Ne(OC.mi(d, g, y), 0, 1),
                n.push(c, d)
            }
            ;
            for (let t = 0, S = s.length; t < S; t += 2) {
                c = s[t],
                d = s[t + 1],
                n.push(c, d),
                f = OC.Ne(Math.floor(c * r), 0, l),
                p = OC.Ne(Math.floor(d * h), 0, u);
                const x = (t + 2) % S;
                for (w = s[x],
                g = s[x + 1],
                b = -1; ; ) {
                    if (n.length > 1e6)
                        throw new Error("Too many mesh poly points");
                    const t = f * o
                      , s = p * a
                      , r = (f + 1) * o
                      , h = (p + 1) * a;
                    if (m = OC.esi(c, d, t, s, r, s, r, h),
                    0 !== b && (y = OC.isi(c, d, w, g, t, s, r, h, -.001),
                    y >= 0 && y <= e))
                        v(),
                        m = !m,
                        b = 0;
                    else if (p > 0 && 2 !== b && (y = OC.isi(c, d, w, g, t, s, r, s, i),
                    y >= 0 && y <= e))
                        v(),
                        p--,
                        m = !1,
                        b = 4;
                    else if (f < l && 3 !== b && (y = OC.isi(c, d, w, g, r, s, r, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f++,
                        m = !1,
                        b = 1;
                    else if (f > 0 && 1 !== b && (y = OC.isi(c, d, w, g, t, s, t, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f--,
                        m = !0,
                        b = 3;
                    else {
                        if (!(p < u && 4 !== b && (y = OC.isi(c, d, w, g, t, h, r, h, i),
                        y >= 0 && y <= e)))
                            break;
                        v(),
                        p++,
                        m = !0,
                        b = 2
                    }
                }
            }
            return OC.v(OC.Jp, n)
        }
        f2i(t, i) {
            const e = this.p2i(t);
            this.m2i(e),
            i.w2i(e)
        }
        p2i(t) {
            const i = []
              , e = t.d2i();
            for (let t = 0, s = e.length; t < s; t += 2) {
                const s = e[t]
                  , n = e[t + 1]
                  , [r,h] = this.g2i(s, n);
                i.push(r, h)
            }
            return i
        }
        g2i(t, i) {
            const e = this.Oa() - 1
              , s = this.Ta() - 1
              , n = 1 / e
              , r = 1 / s
              , h = OC.Ne(Math.floor(t * e), 0, e - 1)
              , o = OC.Ne(Math.floor(i * s), 0, s - 1)
              , a = h * n
              , l = o * r
              , u = (h + 1) * n
              , c = (o + 1) * r
              , d = this.Pa(h, o)
              , f = this.Pa(h + 1, o + 1)
              , p = OC.esi(t, i, a, l, u, l, u, c)
              , m = p ? a + n : a
              , w = p ? l : l + r
              , g = this.Pa(h + (p ? 1 : 0), o + (p ? 0 : 1))
              , [y,b,v] = OC.ssi(t, i, a, l, m, w, u, c);
            return OC.nsi(y, b, v, d.ka(), d.Ra(), d.qR(), g.ka(), g.Ra(), g.qR(), f.ka(), f.Ra(), f.qR())
        }
        m2i(t) {
            const i = []
              , e = 1e-7;
            let s = t[0]
              , n = t[1]
              , r = s - t.at(-2)
              , h = n - t.at(-1);
            for (let o = 0, a = t.length; o < a; o += 2) {
                const l = (o + 2) % a
                  , u = t[l]
                  , c = t[l + 1]
                  , d = u - s
                  , f = c - n
                  , p = Math.abs(d) < e && Math.abs(r) < e && Math.sign(f) === Math.sign(h)
                  , m = Math.abs(f) < e && Math.abs(h) < e && Math.sign(d) === Math.sign(r);
                (!p && !m && Math.abs(d / r - f / h) > .001 || 0 == d && 0 === f) && i.push(s, n),
                s = u,
                n = c,
                r = d,
                h = f
            }
            i.length >= 6 && i.length < t.length && OC.mf(t, i)
        }
        oM() {
            return {
                cols: this.Oa(),
                rows: this.Ta(),
                points: this.$1i.map(t => t.map(t => t.oM()))
            }
        }
        L1i(t) {
            const i = this.Oa()
              , e = this.Ta();
            if (t.cols !== i || t.rows !== e)
                throw new Error("mesh data wrong size");
            const s = t.points;
            for (let t = 0; t < e; ++t) {
                const e = s[t];
                for (let s = 0; s < i; ++s) {
                    this.Pa(s, t).L1i(e[s])
                }
            }
        }
    }
}
{
    const BC = self.t
      , UC = self.r_
      , NC = UC.l_
      , jC = UC.L8t
      , $C = UC.o_
      , zC = $C.create()
      , VC = NC.r6t(0, 0, 0)
      , WC = NC.r6t(0, 0, 0)
      , HC = NC.r6t(0, 0, 0)
      , KC = NC.r6t(0, 1, 0)
      , qC = (jC.r6t(0, 0, 0, 0),
    new BC.zn)
      , XC = new BC.Rect
      , YC = new BC.zn(0,0,1,0,1,1,0,1)
      , JC = {
        y2i: 1,
        b2i: 1e4
    }
      , ZC = $C.r6t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1);
    BC.ea.wx = class {
        constructor(t) {
            t = Object.assign({}, JC, t),
            this.Fx = 0,
            this.Ex = 0,
            this.v2i = BC.ct(45),
            this.S2i = Math.tan(this.v2i / 2),
            this.x2i = $C.create(),
            this.M2i = $C.create(),
            this.E2i = !1,
            this.C2i = t.y2i,
            this._2i = t.b2i,
            this.T2i = [],
            this.I2i = new Map,
            this.P2i = null,
            this.G2i = null,
            this.A2i = null,
            this.R2i = null,
            this.k2i = null,
            this.O2i = null,
            this.D2i = null,
            this.F2i = null,
            this.L2i = null,
            this.B2i = null,
            this.U2i = null,
            this.N2i = null,
            this.j2i = new Map,
            this.$2i = null,
            this.z2i = [],
            this.V2i = new Map,
            this.W2i = 0,
            this.H2i = 0,
            this.Bj = 1,
            this.K2i = [this.Bj],
            this.q2i = 1,
            this.X2i = [this.q2i],
            this.Y2i = .5,
            this.J2i = [this.Y2i],
            this.Z2i = 0,
            this.Q2i = !0,
            this.t3i = !1
        }
        Tot() {
            this.W2i = 0,
            this.H2i = 0,
            this.P2i = null,
            this.G2i = null,
            this.A2i = null,
            this.R2i = null,
            this.k2i = null,
            this.O2i = null,
            this.D2i = null,
            this.F2i = null,
            this.L2i = null,
            this.B2i = null,
            this.U2i = null,
            this.N2i = null,
            this.i3i()
        }
        vU() {
            this.Tot(),
            this.$2i = null
        }
        e3i() {
            for (const t of this.T2i)
                t.he();
            this.Tot()
        }
        ns() {
            return this.Fx
        }
        er() {
            return this.Ex
        }
        ga(t) {
            return this.s3i() ? 100 : t / (2 * this.n3i())
        }
        da(t) {
            if (this.s3i()) {
                return t / (2 * this.n3i()) / this.ga(t)
            }
            return 1
        }
        _R(t) {
            BC.Ge(t),
            this.C2i = t
        }
        fE() {
            return this.C2i
        }
        SR(t) {
            BC.Ge(t),
            this._2i = t
        }
        uE() {
            return this._2i
        }
        uR(t) {
            BC.Ge(t),
            this.v2i = t,
            this.S2i = Math.tan(this.v2i / 2)
        }
        r3i() {
            return this.v2i
        }
        n3i() {
            return this.S2i
        }
        fR() {
            this.E2i = !1
        }
        dR() {
            this.E2i = !0
        }
        s3i() {
            return !this.E2i
        }
        h3i() {
            return this.E2i
        }
        bR(t, i, e=.5, s=.5) {
            const n = this.fE()
              , r = this.uE()
              , h = this.r3i();
            if (.5 === e && .5 === s)
                this.hu() ? $C.j6t(t, h, i, n, r) : $C.perspective(t, h, i, n, r);
            else {
                const h = 2 * (e = 1 - e) - 2
                  , o = 2 * e
                  , a = 2 * s - 2
                  , l = 2 * s
                  , u = this.n3i() * n
                  , c = u * i;
                $C.U6t(t, h * c, o * c, a * u, l * u, n, r),
                this.hu() && $C.mul(t, ZC, t)
            }
        }
        o3i(t, i, e, s=1) {
            const n = self.devicePixelRatio
              , r = 2 * this.ga(e) * n * this.n3i() / e
              , h = i * r / (2 * n * s)
              , o = e * r / (2 * n * s)
              , a = -h
              , l = h
              , u = -o
              , c = o;
            this.hu() ? $C.W6t(t, a, l, u, c, this.fE(), this.uE()) : $C.V6t(t, a, l, u, c, this.fE(), this.uE())
        }
        a3i(t, i, e, s, n, r=1) {
            let h = 1;
            this.s3i() && (h = 200 * this.n3i() / n);
            const o = HC;
            NC.set(o, h, -h, 1);
            const a = VC
              , l = WC;
            NC.multiply(a, i, o),
            NC.multiply(l, e, o),
            $C.H6t(t, a, l, s || KC),
            o[2] = r,
            $C.scale(t, t, o)
        }
        nR(t, i, e, s, n, r, h, o) {
            return NC.set(VC, t, i, e),
            NC.set(WC, s, n, r),
            this.a3i(zC, VC, WC, KC, h, o),
            zC
        }
        l3i(t) {
            this.T2i.push(t),
            this.I2i.set(t.La(), t)
        }
        u3i(t) {
            const i = this.T2i.indexOf(t);
            -1 !== i && this.T2i.splice(i, 1),
            this.I2i.delete(t.La())
        }
        i3i() {
            BC.Io(this.T2i),
            this.I2i.clear()
        }
        A1i(t) {
            return this.I2i.get(t) || null
        }
        c3i() {
            return this.P2i
        }
        Wr() {
            this.dm(this.P2i)
        }
        d3i() {
            return this.G2i
        }
        f3i() {
            this.dm(this.G2i)
        }
        xI() {
            this.dm(this.A2i)
        }
        mC() {
            this.dm(this.R2i)
        }
        nr() {
            this.dm(this.k2i)
        }
        p3i() {
            this.dm(this.O2i)
        }
        af() {
            this.dm(this.D2i)
        }
        m3i() {
            this.dm(this.F2i)
        }
        w3i() {
            this.dm(this.L2i)
        }
        g3i() {
            this.dm(this.B2i)
        }
        y3i() {
            this.dm(this.U2i)
        }
        Hl() {
            this.dm(this.N2i)
        }
        C1i(t) {
            this.$2i = t
        }
        b3i() {
            return this.$2i
        }
        v3i(t, i, e, s, n, r) {
            const h = BC.ea.y1i.T1i(t, i, e, s, n, r);
            let o = this.j2i.get(h);
            return o || (o = BC.v(BC.ea.y1i, this, t, i, e, s, n, r),
            this.j2i.set(h, o)),
            o.I1i(),
            o
        }
        S3i(t) {
            t.P1i(),
            0 === t.G1i() && (this.$2i === t && (this.$2i = null),
            this.j2i.delete(t._1i()),
            t.he())
        }
        x3i(t) {
            BC.Io(this.z2i),
            this.V2i.clear();
            let i = 0;
            for (const e of t) {
                const t = e[0]
                  , s = e[1]
                  , n = e[2];
                this.z2i.push([s, n]),
                this.V2i.set(t, {
                    number: i,
                    M3i: s,
                    E3i: n
                }),
                i++
            }
        }
        C3i(t) {
            return this.z2i[t]
        }
        _3i(t) {
            return this.C3i(t)[0]
        }
        T3i(t) {
            return this.C3i(t)[1]
        }
        I3i(t) {
            const i = this.V2i.get(t);
            if (void 0 === i)
                throw new Error("invalid blend name");
            return i
        }
        P3i(t) {
            const i = this.V2i.get(t);
            if (void 0 === i)
                throw new Error("invalid blend name");
            return i.number
        }
        $R(t) {
            this.W2i = t
        }
        G3i() {
            return this.W2i
        }
        JR(t) {
            this.H2i = t,
            this.$2i = null
        }
        A3i() {
            return this.H2i
        }
        Va(t, i, e, s) {
            const n = BC.fi(t, i, e, s)
              , r = Math.sin(n)
              , h = Math.cos(n)
              , o = .5 * this.Bj
              , a = r * o
              , l = h * o
              , u = this.q2i;
            2 === u ? this.R3i(t, i, 0, e, s, 0, a, l) : 1 === u ? this.k3i(t, i, 0, e, s, 0, a, l) : this.O3i(t, i, 0, e, s, 0, a, l)
        }
        u2i(t, i, e, s, n, r) {
            const h = BC.fi(t, i, s, n)
              , o = Math.sin(h)
              , a = Math.cos(h)
              , l = .5 * this.Bj
              , u = o * l
              , c = a * l
              , d = this.q2i;
            2 === d ? this.R3i(t, i, e, s, n, r, u, c) : 1 === d ? this.k3i(t, i, e, s, n, r, u, c) : this.O3i(t, i, e, s, n, r, u, c)
        }
        R3i(t, i, e, s, n, r, h, o) {
            const a = this.Y2i
              , l = t + a - o
              , u = i + a - h
              , c = s + a + o
              , d = n + a + h
              , f = 2 * o
              , p = 2 * h
              , m = l + h
              , w = u - o
              , g = l - h + f
              , y = u + o + p
              , b = c + h
              , v = d - o
              , S = c - h - f
              , x = d + o - p;
            this.Vm(m, w, e, b, v, r, S, x, r, g, y, e, YC)
        }
        k3i(t, i, e, s, n, r, h, o) {
            const a = this.Y2i
              , l = t + a - o
              , u = i + a - h
              , c = s + a + o
              , d = n + a + h
              , f = l + h
              , p = u - o
              , m = l - h
              , w = u + o
              , g = c + h
              , y = d - o
              , b = c - h
              , v = d + o;
            this.Vm(f, p, e, g, y, r, b, v, r, m, w, e, YC)
        }
        O3i(t, i, e, s, n, r, h, o) {
            const a = this.Y2i
              , l = t + a
              , u = i + a
              , c = s + a
              , d = n + a
              , f = l + h
              , p = u - o
              , m = l - h
              , w = u + o
              , g = c + h
              , y = d - o
              , b = c - h
              , v = d + o;
            this.Vm(f, p, e, g, y, r, b, v, r, m, w, e, YC)
        }
        D3i(t, i, e, s, n, r) {
            const h = BC.fi(t, i, e, s)
              , o = Math.sin(h)
              , a = Math.cos(h)
              , l = .5 * this.Bj
              , u = o * l
              , c = a * l
              , d = this.q2i;
            2 === d ? this.F3i(t, i, e, s, u, c, n, r) : 1 === d ? this.L3i(t, i, e, s, u, c, n, r) : this.B3i(t, i, e, s, u, c, n, r)
        }
        F3i(t, i, e, s, n, r, h, o) {
            const a = this.Y2i
              , l = t + a - r
              , u = i + a - n
              , c = e + a + r
              , d = s + a + n
              , f = 2 * r
              , p = 2 * n
              , m = l + n
              , w = u - r
              , g = l - n + f
              , y = u + r + p
              , b = c + n
              , v = d - r
              , S = c - n - f
              , x = d + r - p;
            qC.set(m, w, b, v, S, x, g, y),
            XC.set(h, 0, o, 0),
            this.ur(qC, XC)
        }
        L3i(t, i, e, s, n, r, h, o) {
            const a = this.Y2i
              , l = t + a - r
              , u = i + a - n
              , c = e + a + r
              , d = s + a + n
              , f = l + n
              , p = u - r
              , m = l - n
              , w = u + r
              , g = c + n
              , y = d - r
              , b = c - n
              , v = d + r;
            qC.set(f, p, g, y, b, v, m, w),
            XC.set(h, 0, o, 0),
            this.ur(qC, XC)
        }
        B3i(t, i, e, s, n, r, h, o) {
            const a = this.Y2i
              , l = t + a
              , u = i + a
              , c = e + a
              , d = s + a
              , f = l + n
              , p = u - r
              , m = l - n
              , w = u + r
              , g = c + n
              , y = d - r
              , b = c - n
              , v = d + r;
            qC.set(f, p, g, y, b, v, m, w),
            XC.set(h, 0, o, 0),
            this.ur(qC, XC)
        }
        AY(t, i, e, s) {
            const n = .5 * this.Bj
              , r = this.q2i;
            2 === r ? this.U3i(t, i, e, s, n) : 1 === r ? this.N3i(t, i, e, s, n) : this.j3i(t, i, e, s, n)
        }
        U3i(t, i, e, s, n) {
            this.R3i(t, i, 0, e, i, 0, 0, n),
            this.R3i(e, i, 0, e, s, 0, n, 0),
            this.R3i(e, s, 0, t, s, 0, 0, -n),
            this.R3i(t, s, 0, t, i, 0, -n, 0)
        }
        N3i(t, i, e, s, n) {
            this.k3i(t, i, 0, e, i, 0, 0, n),
            this.k3i(e, i, 0, e, s, 0, n, 0),
            this.k3i(e, s, 0, t, s, 0, 0, -n),
            this.k3i(t, s, 0, t, i, 0, -n, 0)
        }
        j3i(t, i, e, s, n) {
            this.O3i(t, i, 0, e, i, 0, 0, n),
            this.O3i(e, i, 0, e, s, 0, n, 0),
            this.O3i(e, s, 0, t, s, 0, 0, -n),
            this.O3i(t, s, 0, t, i, 0, -n, 0)
        }
        qr(t) {
            this.AY(t.Yr(), t.Jr(), t.pl(), t.dl())
        }
        Hr(t) {
            const i = BC.fi(t.Zn(), t.tr(), t.lm(), t.el())
              , e = Math.sin(i)
              , s = Math.cos(i)
              , n = .5 * this.Bj
              , r = e * n
              , h = s * n
              , o = this.q2i;
            2 === o ? this.$3i(t, r, h) : 1 === o ? this.z3i(t, r, h) : this.V3i(t, r, h)
        }
        $3i(t, i, e) {
            this.R3i(t.Zn(), t.tr(), 0, t.lm(), t.el(), 0, i, e),
            this.R3i(t.lm(), t.el(), 0, t.il(), t.sl(), 0, e, -i),
            this.R3i(t.il(), t.sl(), 0, t.Fl(), t.El(), 0, -i, -e),
            this.R3i(t.Fl(), t.El(), 0, t.Zn(), t.tr(), 0, -e, i)
        }
        z3i(t, i, e) {
            this.k3i(t.Zn(), t.tr(), 0, t.lm(), t.el(), 0, i, e),
            this.k3i(t.lm(), t.el(), 0, t.il(), t.sl(), 0, e, -i),
            this.k3i(t.il(), t.sl(), 0, t.Fl(), t.El(), 0, -i, -e),
            this.k3i(t.Fl(), t.El(), 0, t.Zn(), t.tr(), 0, -e, i)
        }
        V3i(t, i, e) {
            this.O3i(t.Zn(), t.tr(), 0, t.lm(), t.el(), 0, i, e),
            this.O3i(t.lm(), t.el(), 0, t.il(), t.sl(), 0, e, -i),
            this.O3i(t.il(), t.sl(), 0, t.Fl(), t.El(), 0, -i, -e),
            this.O3i(t.Fl(), t.El(), 0, t.Zn(), t.tr(), 0, -e, i)
        }
        CR(t) {
            this.Bj = t,
            this.K2i[this.K2i.length - 1] = t
        }
        W3i() {
            return this.Bj
        }
        zl(t) {
            if (this.K2i.length >= 100)
                throw new Error("pushed too many line widths - check push/pop pairs");
            this.K2i.push(t),
            this.Bj = t
        }
        Wl() {
            if (this.K2i.length <= 1)
                throw new Error("cannot pop last line width - check push/pop pairs");
            this.K2i.pop(),
            this.Bj = this.K2i.at(-1)
        }
        H3i() {
            this.q2i = 0,
            this.X2i[this.X2i.length - 1] = 0
        }
        K3i() {
            this.q2i = 1,
            this.X2i[this.X2i.length - 1] = 0
        }
        q3i() {
            this.q2i = 2,
            this.X2i[this.X2i.length - 1] = 0
        }
        X3i(t) {
            if (BC.zt(t),
            "butt" === t)
                this.Y3i();
            else if ("square" === t)
                this.Bl();
            else {
                if ("zag" !== t)
                    throw new Error("invalid line cap");
                this.hX()
            }
        }
        Y3i() {
            if (this.X2i.length >= 100)
                throw new Error("pushed too many line caps - check push/pop pairs");
            this.X2i.push(0),
            this.q2i = 0
        }
        Bl() {
            if (this.X2i.length >= 100)
                throw new Error("pushed too many line caps - check push/pop pairs");
            this.X2i.push(1),
            this.q2i = 1
        }
        hX() {
            if (this.X2i.length >= 100)
                throw new Error("pushed too many line caps - check push/pop pairs");
            this.X2i.push(2),
            this.q2i = 2
        }
        $l() {
            if (this.X2i.length <= 1)
                throw new Error("cannot pop last line cap - check push/pop pairs");
            this.X2i.pop(),
            this.q2i = this.X2i.at(-1)
        }
        RR(t) {
            this.Y2i = t,
            this.J2i[this.J2i.length - 1] = t
        }
        J3i() {
            return this.Y2i
        }
        Ul(t) {
            if (this.J2i.length >= 100)
                throw new Error("pushed too many line offsets - check push/pop pairs");
            this.J2i.push(t),
            this.Y2i = t
        }
        Nl() {
            if (this.J2i.length <= 1)
                throw new Error("cannot pop last line offset - check push/pop pairs");
            this.J2i.pop(),
            this.Y2i = this.J2i.at(-1)
        }
        Yn() {
            this.hm(0),
            this.om(0)
        }
        rf(t) {
            const i = t.length / 2;
            if (i < 3)
                throw new Error("need at least 3 points");
            const e = i - 2
              , s = e - 1
              , n = t[0]
              , r = t[1];
            for (let i = 0; i < e; i += 2) {
                const e = 2 * i
                  , h = t[e + 2]
                  , o = t[e + 3]
                  , a = t[e + 4]
                  , l = t[e + 5];
                if (i === s)
                    this.Z3i(n, r, h, o, a, l, a, l);
                else {
                    const i = t[e + 6]
                      , s = t[e + 7];
                    this.Z3i(n, r, h, o, a, l, i, s)
                }
            }
        }
        FR() {
            this.Q3i(!0),
            this.Z2i++
        }
        t4i() {
            return this.Z2i
        }
        i4i() {
            this.Z2i++
        }
        e4i(t) {
            this.Q2i = !!t
        }
        s4i() {
            return this.Q2i
        }
        MU(t) {
            this.t3i = !!t
        }
        n4i() {
            return this.t3i
        }
        r4i() {
            return !1
        }
        hu() {
            return !1
        }
        h4i() {
            BC.kK()
        }
        o4i() {
            BC.kK()
        }
        a4i() {
            BC.kK()
        }
        l4i() {
            return this.h4i() + this.o4i() + this.a4i()
        }
        u4i() {
            return BC.v(BC.ea.ta, this)
        }
    }
}
{
    const QC = self.t;
    QC.ea.c4i = class {
        constructor(t, i) {
            QC.U(t, QC.ea.wx),
            QC.zt(i.name),
            this.Ftt = i.name,
            this.cn = t,
            this.d4i = i.f4i || 0,
            this.p4i = i.m4i || 0,
            this.w4i = !!i.g4i,
            this.y4i = !!i.b4i,
            this.v4i = !!i.S4i,
            this.x4i = !!i.M4i,
            this.E4i = !!i.animated,
            this.C4i = !!i._4i,
            this.T4i = !!i.I4i,
            this.P4i = !1,
            this.G4i = this.w4i || this.C4i || 0 !== this.d4i || 0 !== this.p4i
        }
        he() {
            this.cn = null
        }
        Tn() {
            return this.cn
        }
        La() {
            return this.Ftt
        }
        A4i() {
            return 0 !== this.d4i || 0 !== this.p4i
        }
        R4i() {
            return this.d4i
        }
        k4i() {
            return this.p4i
        }
        O4i() {
            return this.w4i
        }
        Rm() {
            return this.y4i
        }
        D4i() {
            return this.v4i
        }
        F4i() {
            return this.x4i
        }
        L4i() {
            return this.E4i
        }
        B4i() {
            return this.C4i
        }
        U4i() {
            return this.T4i
        }
        N4i() {
            return this.P4i
        }
        j4i() {
            return this.G4i
        }
        $4i() {
            return !1
        }
    }
}
{
    const t_ = self.t
      , i_ = 4096
      , e_ = 4
      , s_ = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"])
      , n_ = {
        timeout: 60
    }
      , r_ = new t_.za(0,0,0,1)
      , h_ = new Set(["left", "center", "right"])
      , o_ = new Set(["top", "center", "bottom"])
      , a_ = new Set(["word", "cjk", "character"])
      , l_ = new Set(["ltr", "rtl"])
      , u_ = new Set;
    function c_(t, i, e, s, n, r) {
        i ? t.strokeRect(e, s, n, r) : t.fillRect(e, s, n, r)
    }
    function d_(t, i) {
        t = t.trim();
        const e = parseFloat(t);
        return isFinite(e) ? t.endsWith("%") ? i * e / 100 : e : 0
    }
    t_.bO && t_.bO.addEventListener("fontload", t => {
        const i = t.font.La();
        for (const t of u_)
            (t.Tx() || t_.Kw(t.z4i(), i)) && t.Uy()
    }
    );
    let f_ = !1
      , p_ = !1;
    t_.ea.ta = class {
        constructor(t, i) {
            t_.U(t, t_.ea.wx),
            t_.kQ(i),
            i = Object.assign({}, n_, i),
            this.cn = t,
            this.V4i = "Arial",
            this.W4i = 16,
            this.H4i = 1,
            this.Iy = 0,
            this.K4i = !1,
            this.q4i = !1,
            this.X4i = "black",
            this.oy = !1,
            this.lli = null,
            this.Y4i = !0,
            this.JS = null,
            this.J4i = new Set,
            this.yy = "left",
            this.xy = "top",
            this.hy = "",
            this.uy = null,
            this.py = t_.v(t_.my),
            this.gy = "word",
            this.Z4i = "ltr",
            this.wy = !1,
            this.by = !1,
            this.Q4i = !1,
            this.My = -1,
            this.Oy = 0,
            this.ny = 0,
            this.ly = 0,
            this.Fx = 0,
            this.Ex = 0,
            this.t5i = 1,
            this.i5i = null,
            this.e5i = null,
            this.s5i = null,
            this.n5i = null,
            this.r5i = -1,
            this.h5i = -1,
            this.o5i = "",
            this.a5i = "",
            this.l5i = "",
            this.u5i = 1,
            this.c5i = 1,
            this.Ty = t => this.Py(t),
            this.tn = null,
            this.d5i = new t_.Rect,
            this.f5i = 1,
            this.p5i = new t_.m_( () => {
                this.m5i(),
                this.w5i(8, 8)
            }
            ,i.timeout),
            this.ia = null,
            this.dn = !1,
            u_.add(this)
        }
        he() {
            this.JS = null,
            this.J4i.clear(),
            this.lli = null,
            this.uy = null,
            this.i5i = null,
            this.e5i = null,
            this.s5i = null,
            this.n5i = null,
            this.Ty = null,
            this.p5i.he(),
            this.ia = null,
            this.m5i(),
            this.py.Ry(),
            this.py = null,
            this.cn = null,
            this.dn = !0,
            u_.delete(this)
        }
        g5i() {
            this.Q4i = !0
        }
        zy() {
            this.g5i(),
            this.by = !0
        }
        Uy() {
            this.zy(),
            this.wy = !0
        }
        Ha(t) {
            if (t = !!t,
            this.oy === t)
                return;
            this.oy = t;
            const i = this.oy ? "alphabetic" : "top";
            this.e5i && (this.e5i.textBaseline = i),
            this.s5i && (this.s5i.textBaseline = i),
            this.Uy()
        }
        Tx() {
            return this.oy
        }
        KS(t) {
            t_.Ef(t, t_.uli),
            this.lli !== t && (this.lli = t,
            this.py.KS(t),
            this.lli && this.lli.Xw() && this.lli.yui().then( () => this.g5i()),
            this.Uy())
        }
        ZS(t) {
            t = !!t,
            this.Y4i !== t && (this.Y4i = t,
            this.g5i())
        }
        al(t) {
            t_.zt(t),
            t || (t = "serif"),
            this.V4i !== t && (this.V4i = t,
            this.Uy())
        }
        z4i() {
            return this.V4i
        }
        sa(t) {
            t_.Ge(t),
            t < .1 && (t = .1),
            this.W4i !== t && (this.W4i = t,
            this.Uy())
        }
        pfe() {
            return this.W4i
        }
        y5i(t) {
            t_.Ge(t),
            this.H4i !== t && (this.H4i = t,
            this.Uy())
        }
        $b(t) {
            t_.Ge(t),
            this.Iy !== t && (this.Iy = t,
            this.zy())
        }
        Rx() {
            return this.Iy
        }
        tC(t) {
            t = !!t,
            this.K4i !== t && (this.K4i = t,
            this.Uy())
        }
        b5i() {
            return this.K4i
        }
        Ba(t) {
            t = !!t,
            this.q4i !== t && (this.q4i = t,
            this.Uy())
        }
        v5i() {
            return this.q4i
        }
        By(t) {
            t_.Ge(t),
            t = Math.floor(t),
            this.My !== t && (this.My = t,
            this.g5i())
        }
        Hy() {
            return this.My
        }
        S5i(t, i) {
            let e = [];
            (this.K4i || i.Sx("b")) && e.push("bold"),
            (this.q4i || i.Sx("i")) && e.push("italic");
            const s = i.jy("size")
              , n = (s ? parseFloat(s.Ly) : this.W4i) * this.H4i;
            t ? e.push(n + "pt") : e.push(n * this.x5i() + "pt");
            let r = this.V4i;
            const h = i.jy("font");
            return h && h.Ly && (r = h.Ly,
            this.JS && !this.J4i.has(r) && (this.JS(r),
            this.J4i.add(r))),
            r && (s_.has(r) ? e.push(r) : e.push('"' + r + '"')),
            e.join(" ")
        }
        Jn(t) {
            t instanceof t_.za && (t = t.Rsi()),
            t_.zt(t),
            this.X4i !== t && (this.X4i = t,
            this.g5i())
        }
        oa(t, i, e) {
            t_.Ge(t),
            t_.Ge(i),
            t_.Ge(e),
            r_.wsi(t, i, e),
            this.Jn(r_)
        }
        aa(t) {
            if (t_.zt(t),
            !h_.has(t))
                throw new Error("invalid horizontal alignment");
            this.yy !== t && (this.yy = t,
            this.zy())
        }
        M5i() {
            return this.yy
        }
        la(t) {
            if (t_.zt(t),
            !o_.has(t))
                throw new Error("invalid vertical alignment");
            this.xy !== t && (this.xy = t,
            this.zy())
        }
        E5i() {
            return this.xy
        }
        Ub(t) {
            if (!a_.has(t))
                throw new Error("invalid word wrap mode");
            this.gy !== t && (this.gy = t,
            this.Uy())
        }
        C5i() {
            return this.gy
        }
        eC(t) {
            if (t_.zt(t),
            !l_.has(t))
                throw new Error("invalid text direction");
            this.Z4i !== t && (this.Z4i = t,
            this.e5i && (this.e5i.direction = this.Z4i),
            this.s5i && (this.s5i.direction = this.Z4i),
            this.Uy())
        }
        _5i() {
            return this.Z4i
        }
        ha(t) {
            t_.zt(t),
            this.hy !== t && (this.hy = t,
            this.Uy())
        }
        iSt() {
            return this.hy
        }
        x5i() {
            return this.f5i * this.t5i * self.devicePixelRatio
        }
        zr(t, i, e) {
            if (t_.Ge(t),
            t_.Ge(i),
            t_.iM(e),
            void 0 === e && (e = 1),
            t <= 0 || t <= 0)
                return;
            if (this.ny === t && this.ly === i && this.t5i === e)
                return;
            const s = this.ny;
            this.ny = t,
            this.ly = i,
            this.t5i = e;
            const n = self.devicePixelRatio;
            this.Fx = this.ny * this.t5i * n,
            this.Ex = this.ly * this.t5i * n;
            const r = Math.max(this.Fx, this.Ex)
              , h = Math.min(this.cn.T5i(), i_);
            let o = 1;
            r > h && (o = h / r,
            this.Fx = Math.min(this.Fx * o, h),
            this.Ex = Math.min(this.Ex * o, h)),
            this.f5i = o,
            this.ny !== s ? this.Uy() : this.zy()
        }
        ns() {
            return this.Fx
        }
        er() {
            return this.Ex
        }
        qS() {
            return this.t5i
        }
        Gx() {
            return this.Ny(),
            this.py._x()
        }
        jx() {
            return this.Ny(),
            this.py.Bli() + this.py.Lx() * (this.Iy + e_) - this.Iy
        }
        I5i() {
            this.Ny();
            let t = 0;
            for (const i of this.py.$y())
                for (const e of i.Yy())
                    t += e.xli();
            return t
        }
        jn() {
            return this.p5i.qd(),
            this.P5i(),
            this.tn
        }
        Wy(t, i) {
            this.Ny();
            const e = this.x5i()
              , s = this.py.$y();
            for (const n of s) {
                const s = n.bli() * e;
                if (i >= n.Xy() - n.er() * e + s && i < n.Xy() + s)
                    for (const i of n.Yy())
                        if (t >= i.Jy() && t < i.Jy() + i.ns() * e)
                            return i
            }
            return null
        }
        *qy(t) {
            this.Ny();
            const i = this.py.$y();
            for (const e of i)
                for (const i of e.Yy()) {
                    const e = i.jy("tag");
                    e && t_.Kw(e.Ly, t) && (yield i)
                }
        }
        Ky(t, i) {
            for (const e of this.qy(t)) {
                if (0 === i)
                    return e;
                --i
            }
            return null
        }
        Qy(t) {
            let i = 0;
            for (const e of this.qy(t))
                ++i;
            return i
        }
        P5i() {
            (!this.tn || this.Q4i || this.by || this.wy) && (this.dn || this.Fx <= 0 || this.Ex <= 0 || (this.Q4i = !1,
            this.G5i()))
        }
        G5i() {
            this.dn || (this.Ny(),
            this.w5i(Math.max(t_.na(Math.ceil(this.Fx)), 128), Math.max(t_.na(Math.ceil(this.Ex)), 64)),
            this.A5i(),
            this.R5i(),
            this.p5i.qd())
        }
        w5i(t, i) {
            this.i5i || (this.i5i = t_.sy(16, 16));
            let e = !1;
            this.r5i === t && this.h5i === i || (this.r5i = t,
            this.h5i = i,
            this.i5i.width = t,
            this.i5i.height = i,
            e = !0),
            this.e5i || (this.e5i = this.i5i.getContext("2d"),
            e = !0),
            e ? (this.e5i.textBaseline = this.oy ? "alphabetic" : "top",
            this.e5i.direction = this.Z4i,
            this.e5i.font = this.o5i,
            this.e5i.fillStyle = this.l5i,
            this.e5i.strokeStyle = this.l5i,
            this.e5i.globalAlpha = this.u5i,
            this.e5i.lineWidth = this.c5i) : this.e5i.clearRect(0, 0, t, i)
        }
        k5i() {
            this.s5i || (this.s5i = t_.sy(16, 16).getContext("2d"),
            this.n5i = t_.sy(16, 16).getContext("2d"),
            this.s5i.textBaseline = this.oy ? "alphabetic" : "top",
            this.n5i.textBaseline = "top",
            this.s5i.direction = this.Z4i,
            this.n5i.direction = this.Z4i)
        }
        O5i(t) {
            this.a5i !== t && (this.a5i = t,
            this.s5i.font = t,
            this.n5i.font = t)
        }
        D5i() {
            if (!f_) {
                f_ = !0,
                this.k5i();
                const t = this.s5i.measureText("test");
                p_ = "number" == typeof t.fontBoundingBoxAscent && "number" == typeof t.fontBoundingBoxDescent
            }
            return p_
        }
        Ny() {
            this.Zy(),
            this.tx()
        }
        Zy() {
            this.wy && (this.k5i(),
            !this.oy || this.uy && this.uy.toString() === this.hy || (this.uy = new t_.ix(this.hy,{
                sx: !0
            })),
            this.py.my(this.oy ? this.uy.nx() : this.hy, this.Ty, this.ny, this.gy, 0),
            this.wy = !1)
        }
        tx() {
            this.by && (this.lx(),
            this.by = !1)
        }
        Py(t) {
            const i = t.wli() ? t._y().join("") : " ";
            this.O5i(this.S5i(!0, t));
            const e = t.jy("size")
              , s = (e ? parseFloat(e.Ly) : this.W4i) * this.H4i
              , n = this.s5i.measureText(i);
            let r = 0;
            if (this.oy && this.D5i()) {
                const t = this.n5i.measureText(i);
                r = n.fontBoundingBoxAscent - t.fontBoundingBoxAscent
            }
            return {
                width: n.width,
                height: (h = s,
                h * (4 / 3)),
                fontBoundingBoxAscent: n.fontBoundingBoxAscent || 0,
                fontBoundingBoxDescent: n.fontBoundingBoxDescent || 0,
                mli: r
            };
            var h
        }
        F5i(t) {
            this.o5i !== t && (this.o5i = t,
            this.e5i.font = t)
        }
        L5i(t) {
            this.l5i !== t && (this.l5i = t,
            this.e5i.fillStyle = t,
            this.e5i.strokeStyle = t)
        }
        B5i(t) {
            this.u5i !== t && (this.u5i = t,
            this.e5i.globalAlpha = t)
        }
        U5i(t) {
            this.c5i !== t && (this.c5i = t,
            this.e5i.lineWidth = t)
        }
        lx() {
            const t = this.x5i()
              , i = (e_ + this.Iy) * t;
            let e = 0;
            const s = this.py.$y();
            if (0 === s.length)
                return;
            for (const t of s) {
                t.ox(NaN),
                t.ux(NaN);
                for (const i of t.Yy())
                    i.ox(NaN),
                    i.ux(NaN)
            }
            const n = this.oy && this.D5i();
            let r = s[0].er() * t;
            if ("center" === this.xy) {
                const h = s.reduce( (e, s) => e + s.er() * t + i, 0) - i;
                e = Math.max(this.Ex / 2 - h / 2, 0),
                n && (r = s[0].vli() * t)
            } else if ("bottom" === this.xy) {
                const r = s.reduce( (e, s) => e + s.er() * t + i, 0) - this.Iy * t
                  , h = n ? s.at(-1).bli() * t : 0;
                e = this.Ex - r - h - 2
            }
            for (let n = 0, h = s.length; n < h; ++n) {
                const h = s[n]
                  , o = h.er() * t
                  , a = e;
                if (this.oy) {
                    if (e += 0 === n ? r : o,
                    n > 0 && e > this.Ex - e_ * t)
                        break
                } else if (n > 0 && e >= this.Ex - o)
                    break;
                a >= 0 && this.mx(h, e, t),
                this.oy || (e += o),
                e += i
            }
        }
        mx(t, i, e) {
            let s = 0;
            "center" === this.yy ? s = Math.floor((this.Fx - t.ns() * e) / 2) : "right" === this.yy && (s = this.Fx - t.ns() * e),
            t.ox(s),
            t.ux(i);
            for (const n of "ltr" === this.Z4i ? t.Yy() : t.Vli())
                this.N5i(n, s, i, e),
                s += n.ns() * e
        }
        N5i(t, i, e, s) {
            const n = t.jy("offsetx");
            i += n ? d_(n.Ly, t.er()) * s : 0;
            const r = t.jy("offsety");
            if (e += r ? d_(r.Ly, t.er()) * s : 0,
            t.Gy()) {
                const i = t.jy("iconoffsety");
                e += i ? d_(i.Ly, t.er()) * s : .2 * t.er() * s
            }
            t.ox(i),
            t.ux(e)
        }
        A5i() {
            this.e5i.imageSmoothingEnabled = this.Y4i,
            this.e5i.imageSmoothingQuality = "high",
            this.Oy = 0;
            const t = this.x5i()
              , i = this.py.$y();
            for (const e of i)
                this.j5i(e, t)
        }
        j5i(t, i) {
            const e = t.Jy()
              , s = t.Xy();
            if (Number.isFinite(e) && Number.isFinite(s))
                for (const e of "ltr" === this.Z4i ? t.Yy() : t.Vli())
                    this.yx(e, i, t.er())
        }
        yx(t, i, e) {
            const s = this.e5i
              , n = t.Jy()
              , r = t.Xy();
            if (!Number.isFinite(n) || !Number.isFinite(r))
                return;
            const h = e / 16;
            let o = t.ns() * i;
            const a = t.er() * i
              , l = t.er() / 16
              , u = (e_ + this.Iy) * i;
            let c = t.wli() ? t._y() : null;
            if (-1 !== this.My) {
                if (this.Oy >= this.My)
                    return;
                t.wli() && this.Oy + c.length > this.My && (c = c.slice(0, this.My - this.Oy),
                o = this.Py(t).width * i),
                this.Oy += t.xli()
            }
            const d = t.jy("background")
              , f = t.Sx("u")
              , p = t.Sx("s");
            if (t.wli() && t_.xx(c) && !d && !f && !p || t.Sx("hide"))
                return;
            const m = t.jy("color")
              , w = t.jy("opacity");
            this.B5i(w ? parseFloat(w.Ly) / 100 : 1),
            d && (this.L5i(d.Ly),
            s.fillRect(n, r - a, o, a + u));
            const g = t.jy("linethickness")
              , y = g ? parseFloat(g.Ly) : 1
              , b = t.Sx("stroke");
            if (b && this.U5i(.5 * l * y * this.x5i()),
            t.wli()) {
                const i = c.join("");
                if (this.F5i(this.S5i(!1, t)),
                !b) {
                    this.U5i(.5 * l * y * this.x5i());
                    const e = t.jy("outlineback");
                    e && (this.L5i(e.Ly),
                    this.$5i(!0, i, n, r, o))
                }
                if (this.L5i(m ? m.Ly : this.X4i),
                this.$5i(b, i, n, r, o),
                !b) {
                    this.U5i(.5 * l * y * this.x5i());
                    const e = t.jy("outline");
                    e && (this.L5i(e.Ly),
                    this.$5i(!0, i, n, r, o))
                }
            } else if (t.Gy() && t.ns() > 0) {
                const i = t.yn(this.lli);
                i && s.drawImage(i, n, r - a, o, a)
            }
            if (this.L5i(m ? m.Ly : this.X4i),
            f && c_(s, b, n, r + i * h, o, i * h * y),
            p) {
                const t = i * l
                  , e = r - a / 4 + t / 2;
                s.fillRect(n, e - t * y / 2, o, t * y)
            }
        }
        $5i(t, i, e, s, n) {
            "rtl" === this.Z4i && (e += n),
            t ? "Gecko" === t_.kt._9t ? this.e5i.strokeText(i, e, s, n) : this.e5i.strokeText(i, e, s) : "Gecko" === t_.kt._9t ? this.e5i.fillText(i, e, s, n) : this.e5i.fillText(i, e, s)
        }
        R5i() {
            this.cn.fn() || (this.tn || (this.tn = this.cn.jR(this.i5i.width, this.i5i.height, {
                yS: !0,
                SS: "high"
            })),
            this.cn.XR(this.i5i, this.tn),
            this.d5i.set(0, 0, this.Fx / this.tn.ns(), this.Ex / this.tn.er()),
            this.ia && this.ia())
        }
        $r() {
            return this.d5i
        }
        m5i() {
            this.tn && (this.cn.fn() || this.cn.mn(this.tn),
            this.tn = null)
        }
        static ks() {
            for (const t of u_)
                t.m5i()
        }
        static z5i() {
            return u_.values()
        }
    }
}
{
    const m_ = globalThis.t
      , w_ = globalThis.assert
      , g_ = 65535;
    function y_(t, i, e) {
        const s = e.Zn()
          , n = e.tr()
          , r = e.lm() - s
          , h = e.el() - n;
        return [s + r * t + (e.Fl() - s) * i, n + h * t + (e.El() - n) * i]
    }
    m_.ea.DE = class {
        constructor(t, i, e) {
            this.R1i = t,
            this.k1i = i,
            this.JYi = e,
            this.Ec = NaN,
            this.zc = NaN,
            this.x1i = NaN,
            this._u = NaN,
            this._v = NaN,
            this.Ec = 0,
            this.zc = 0,
            this.x1i = 0,
            this._u = 0,
            this._v = 0
        }
        GRi(t, i, e, s) {
            this.Ec = t,
            this.zc = i,
            this._u = e,
            this._v = s
        }
        ka() {
            return this.Ec
        }
        Fo(t) {
            this.Ec !== t && (this.Ec = t,
            this.R1i.O1i())
        }
        Ra() {
            return this.zc
        }
        Eo(t) {
            this.zc !== t && (this.zc = t,
            this.R1i.O1i())
        }
        qR() {
            return this.x1i
        }
        Nie(t) {
            this.x1i !== t && (this.x1i = Math.max(t, 0),
            this.R1i.O1i())
        }
        NX() {
            return this._u
        }
        ZX(t) {
            this._u = t
        }
        VX() {
            return this._v
        }
        $X(t) {
            this._v = t
        }
        D1i(t, i, e) {
            [this.Ec,this.zc] = y_(t.Ec, t.zc, i),
            this.x1i = t.x1i,
            this._u = m_.mi(e.Yr(), e.pl(), t._u),
            this._v = m_.mi(e.Jr(), e.dl(), t._v)
        }
        F1i(t, i, e) {
            [this.Ec,this.zc] = y_(t.Ec, t.zc, i),
            this.x1i = t.x1i,
            [this._u,this._v] = y_(t._u, t._v, e)
        }
        oM() {
            return {
                x: this.ka(),
                y: this.Ra(),
                z: this.qR(),
                u: this.NX(),
                v: this.VX()
            }
        }
        L1i(t) {
            this.Fo(t.x),
            this.Eo(t.y),
            t.hasOwnProperty("z") && this.Nie(t.z),
            this.ZX(t.u),
            this.$X(t.v)
        }
        Rte() {
            return this.R1i
        }
        Tle() {
            return this.k1i
        }
        Lle() {
            return this.JYi
        }
    }
    ,
    m_.ea.B1i = class {
        constructor(t, i, e) {
            if (t < 2 || i < 2)
                throw new Error("invalid mesh size");
            this.U1i = t,
            this.N1i = i,
            this.j1i = e || null,
            this.$1i = [],
            this.z1i = 0,
            this.V1i = 0,
            this.W1i = 1,
            this.H1i = 1,
            this.K1i = 0,
            this.q1i = !1,
            this.X1i = [],
            this.Y1i = 0,
            this.J1i = !0;
            const s = t - 1
              , n = i - 1;
            for (let e = 0; e < i; ++e) {
                const i = [];
                for (let r = 0; r < t; ++r) {
                    const t = m_.v(m_.ea.DE, this, r, e)
                      , h = r / s
                      , o = e / n;
                    t.GRi(h, o, h, o),
                    i.push(t)
                }
                this.$1i.push(i)
            }
        }
        he() {
            m_.Io(this.$1i),
            m_.Io(this.X1i)
        }
        Oa() {
            return this.U1i
        }
        Ta() {
            return this.N1i
        }
        _te() {
            return this.j1i
        }
        Z1i() {
            return this.$1i
        }
        O1i() {
            this.q1i = !0,
            this.J1i = !0
        }
        Q1i() {
            if (!this.q1i)
                return;
            let t = 1 / 0
              , i = 1 / 0
              , e = -1 / 0
              , s = -1 / 0
              , n = 0;
            for (const r of this.$1i)
                for (const h of r) {
                    const r = h.ka()
                      , o = h.Ra();
                    t = Math.min(t, r),
                    i = Math.min(i, o),
                    e = Math.max(e, r),
                    s = Math.max(s, o),
                    n = Math.max(n, h.qR())
                }
            this.z1i = t,
            this.V1i = i,
            this.W1i = e,
            this.H1i = s,
            this.K1i = n,
            this.q1i = !1
        }
        g$() {
            return this.Q1i(),
            this.z1i
        }
        _$() {
            return this.Q1i(),
            this.V1i
        }
        S$() {
            return this.Q1i(),
            this.W1i
        }
        b$() {
            return this.Q1i(),
            this.H1i
        }
        t2i() {
            return this.Q1i(),
            this.K1i
        }
        i2i() {
            return this.t2i() > 0
        }
        Pa(t, i) {
            return t = Math.floor(t),
            i = Math.floor(i),
            t < 0 || t >= this.U1i || i < 0 || i >= this.N1i ? null : this.$1i[i][t]
        }
        e2i(t, i, e) {
            m_.U(t, m_.ea.B1i),
            m_.U(i, m_.zn),
            m_.eI(e, m_.Rect, m_.zn);
            const s = e instanceof m_.Rect;
            if (t.Oa() !== this.Oa() || t.Ta() !== this.Ta())
                throw new Error("source mesh wrong size");
            const n = t.$1i
              , r = this.$1i;
            for (let t = 0, h = r.length; t < h; ++t) {
                const h = n[t]
                  , o = r[t];
                for (let t = 0, n = o.length; t < n; ++t) {
                    const n = h[t]
                      , r = o[t];
                    s ? r.D1i(n, i, e) : r.F1i(n, i, e)
                }
            }
            this.J1i = !0
        }
        s2i(t) {
            if (!this.J1i && this.Y1i === t)
                return;
            const i = this.U1i
              , e = this.N1i
              , s = this.X1i
              , n = Math.floor(g_ / i) - 1;
            if (n <= 0)
                throw new Error("mesh too large");
            const r = Math.ceil((e - 1) / n);
            r < s.length && (s.length = r);
            let h = 0;
            for (let o = 0; o < r; ++o) {
                const r = Math.min(n, e - h - 1);
                w_(r > 0, "invalid mesh chunk");
                const a = (r + 1) * i
                  , l = 3 * a
                  , u = 2 * a
                  , c = (i - 1) * r * 6;
                if (o === s.length)
                    s.push({
                        n2i: new Float32Array(l),
                        r2i: new Float32Array(u),
                        h2i: new Uint16Array(c)
                    });
                else {
                    const t = s[o];
                    t.n2i.length !== l && (t.n2i = new Float32Array(l)),
                    t.r2i.length !== u && (t.r2i = new Float32Array(u)),
                    t.h2i.length !== c && (t.h2i = new Uint16Array(c))
                }
                const {n2i: d, r2i: f, h2i: p} = s[o];
                this.o2i(h, r, t, d, f, p),
                h += n
            }
            this.Y1i = t,
            this.J1i = !1
        }
        o2i(t, i, e, s, n, r) {
            const h = this.$1i
              , o = this.U1i;
            let a = 0
              , l = 0
              , u = 0;
            for (let c = t, d = t + i + 1; c < d; ++c) {
                const i = h[c]
                  , f = c + 1
                  , p = c - t
                  , m = p * o
                  , w = (p + 1) * o;
                for (let t = 0, h = i.length; t < h; ++t) {
                    const o = i[t]
                      , c = t + 1;
                    if (s[a++] = o.ka(),
                    s[a++] = o.Ra(),
                    s[a++] = o.qR() + e,
                    n[l++] = o.NX(),
                    n[l++] = o.VX(),
                    c < h && f < d) {
                        const i = t + m
                          , e = c + m
                          , s = c + w
                          , n = t + w;
                        r[u++] = i,
                        r[u++] = e,
                        r[u++] = s,
                        r[u++] = i,
                        r[u++] = s,
                        r[u++] = n
                    }
                }
            }
        }
        $n(t, i) {
            this.s2i(i);
            for (const {n2i: i, r2i: e, h2i: s} of this.X1i)
                t.a2i(i, e, s)
        }
        l2i(t, i) {
            i || (i = (t, i, e) => [t, i, e]);
            const e = this.$1i;
            let s = e[0];
            for (let n = 1, r = e.length; n < r; ++n) {
                const h = e[n];
                let o = s[0]
                  , a = h[0];
                for (let e = 1, l = h.length; e < l; ++e) {
                    const u = s[e]
                      , c = h[e]
                      , [d,f,p] = i(o.ka(), o.Ra(), o.qR())
                      , [m,w,g] = i(u.ka(), u.Ra(), u.qR())
                      , [y,b,v] = i(c.ka(), c.Ra(), c.qR())
                      , [S,x,M] = i(a.ka(), a.Ra(), a.qR());
                    t.u2i(d, f, p, m, w, g),
                    t.u2i(d, f, p, y, b, v),
                    t.u2i(d, f, p, S, x, M),
                    e === l - 1 && t.u2i(m, w, g, y, b, v),
                    n === r - 1 && t.u2i(S, x, M, y, b, v),
                    o = u,
                    a = c
                }
                s = h
            }
        }
        c2i(t) {
            const i = .001
              , e = .99999999
              , s = t.d2i()
              , n = []
              , r = this.Oa() - 1
              , h = this.Ta() - 1
              , o = 1 / r
              , a = 1 / h
              , l = r - 1
              , u = h - 1;
            let c = s[0]
              , d = s[1]
              , f = m_.Ne(Math.floor(c * r), 0, l)
              , p = m_.Ne(Math.floor(d * h), 0, u)
              , m = !0
              , w = 0
              , g = 0
              , y = 0;
            let b = -1;
            const v = () => {
                c = m_.Ne(m_.mi(c, w, y), 0, 1),
                d = m_.Ne(m_.mi(d, g, y), 0, 1),
                n.push(c, d)
            }
            ;
            for (let t = 0, S = s.length; t < S; t += 2) {
                c = s[t],
                d = s[t + 1],
                n.push(c, d),
                f = m_.Ne(Math.floor(c * r), 0, l),
                p = m_.Ne(Math.floor(d * h), 0, u);
                const x = (t + 2) % S;
                for (w = s[x],
                g = s[x + 1],
                b = -1; ; ) {
                    if (n.length > 1e6)
                        throw new Error("Too many mesh poly points");
                    const t = f * o
                      , s = p * a
                      , r = (f + 1) * o
                      , h = (p + 1) * a;
                    if (m = m_.esi(c, d, t, s, r, s, r, h),
                    0 !== b && (y = m_.isi(c, d, w, g, t, s, r, h, -.001),
                    y >= 0 && y <= e))
                        v(),
                        m = !m,
                        b = 0;
                    else if (p > 0 && 2 !== b && (y = m_.isi(c, d, w, g, t, s, r, s, i),
                    y >= 0 && y <= e))
                        v(),
                        p--,
                        m = !1,
                        b = 4;
                    else if (f < l && 3 !== b && (y = m_.isi(c, d, w, g, r, s, r, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f++,
                        m = !1,
                        b = 1;
                    else if (f > 0 && 1 !== b && (y = m_.isi(c, d, w, g, t, s, t, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f--,
                        m = !0,
                        b = 3;
                    else {
                        if (!(p < u && 4 !== b && (y = m_.isi(c, d, w, g, t, h, r, h, i),
                        y >= 0 && y <= e)))
                            break;
                        v(),
                        p++,
                        m = !0,
                        b = 2
                    }
                }
            }
            return m_.v(m_.Jp, n)
        }
        f2i(t, i) {
            const e = this.p2i(t);
            this.m2i(e),
            i.w2i(e)
        }
        p2i(t) {
            const i = []
              , e = t.d2i();
            for (let t = 0, s = e.length; t < s; t += 2) {
                const s = e[t]
                  , n = e[t + 1]
                  , [r,h] = this.g2i(s, n);
                i.push(r, h)
            }
            return i
        }
        g2i(t, i) {
            const e = this.Oa() - 1
              , s = this.Ta() - 1
              , n = 1 / e
              , r = 1 / s
              , h = m_.Ne(Math.floor(t * e), 0, e - 1)
              , o = m_.Ne(Math.floor(i * s), 0, s - 1)
              , a = h * n
              , l = o * r
              , u = (h + 1) * n
              , c = (o + 1) * r
              , d = this.Pa(h, o)
              , f = this.Pa(h + 1, o + 1)
              , p = m_.esi(t, i, a, l, u, l, u, c)
              , m = p ? a + n : a
              , w = p ? l : l + r
              , g = this.Pa(h + (p ? 1 : 0), o + (p ? 0 : 1))
              , [y,b,v] = m_.ssi(t, i, a, l, m, w, u, c);
            return m_.nsi(y, b, v, d.ka(), d.Ra(), d.qR(), g.ka(), g.Ra(), g.qR(), f.ka(), f.Ra(), f.qR())
        }
        m2i(t) {
            const i = []
              , e = 1e-7;
            let s = t[0]
              , n = t[1]
              , r = s - t.at(-2)
              , h = n - t.at(-1);
            for (let o = 0, a = t.length; o < a; o += 2) {
                const l = (o + 2) % a
                  , u = t[l]
                  , c = t[l + 1]
                  , d = u - s
                  , f = c - n
                  , p = Math.abs(d) < e && Math.abs(r) < e && Math.sign(f) === Math.sign(h)
                  , m = Math.abs(f) < e && Math.abs(h) < e && Math.sign(d) === Math.sign(r);
                (!p && !m && Math.abs(d / r - f / h) > .001 || 0 == d && 0 === f) && i.push(s, n),
                s = u,
                n = c,
                r = d,
                h = f
            }
            i.length >= 6 && i.length < t.length && m_.mf(t, i)
        }
        oM() {
            return {
                cols: this.Oa(),
                rows: this.Ta(),
                points: this.$1i.map(t => t.map(t => t.oM()))
            }
        }
        L1i(t) {
            const i = this.Oa()
              , e = this.Ta();
            if (t.cols !== i || t.rows !== e)
                throw new Error("mesh data wrong size");
            const s = t.points;
            for (let t = 0; t < e; ++t) {
                const e = s[t];
                for (let s = 0; s < i; ++s) {
                    this.Pa(s, t).L1i(e[s])
                }
            }
        }
    }
}
{
    const b_ = self.t
      , v_ = self.r_.o_
      , S_ = new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
    b_.ea.V5i = class {
        constructor(t, i, e) {
            if (!S_.has(e))
                throw new Error("invalid uniform type");
            this.j1i = t,
            this.W5i = this.j1i.H5i(),
            this.Ftt = i,
            this.aGt = e,
            this.K5i = "color" === this.aGt,
            this.q5i = this.W5i.getUniformLocation(this.j1i.X5i(), i),
            this.Y5i = !!this.q5i;
            const s = S_.get(e);
            this.TDi = new Float32Array(s),
            this.J5i = new Float32Array(s)
        }
        he() {
            this.j1i = null,
            this.W5i = null,
            this.q5i = null
        }
        Z5i() {
            return this.Y5i
        }
        W7() {
            return this.aGt
        }
        Q5i() {
            return this.K5i
        }
        t6i(t) {
            this.Z5i() && (this.TDi[0] = t,
            this.J5i.set(this.TDi),
            this.W5i.uniform1f(this.q5i, t))
        }
        i6i(t) {
            this.Z5i() && (this.TDi[0] = t,
            this.J5i.set(this.TDi),
            this.W5i.uniform1i(this.q5i, t))
        }
        e6i(t, i) {
            this.Z5i() && (this.TDi[0] = t,
            this.TDi[1] = i,
            this.J5i.set(this.TDi),
            this.W5i.uniform2f(this.q5i, t, i))
        }
        s6i(t, i, e) {
            this.Z5i() && (this.TDi[0] = t,
            this.TDi[1] = i,
            this.TDi[2] = e,
            this.J5i.set(this.TDi),
            this.W5i.uniform3f(this.q5i, t, i, e))
        }
        n6i(t, i, e, s) {
            this.Z5i() && (this.TDi[0] = t,
            this.TDi[1] = i,
            this.TDi[2] = e,
            this.TDi[3] = s,
            this.J5i.set(this.TDi),
            this.W5i.uniform4f(this.q5i, t, i, e, s))
        }
        r6i(t) {
            t = Math.fround(t);
            const i = this.TDi;
            i[0] !== t && (i[0] = t,
            this.W5i.uniform1f(this.q5i, t))
        }
        h6i(t) {
            const i = this.TDi;
            i[0] !== t && (i[0] = t,
            this.W5i.uniform1i(this.q5i, t))
        }
        o6i(t, i) {
            t = Math.fround(t),
            i = Math.fround(i);
            const e = this.TDi;
            e[0] === t && e[1] === i || (e[0] = t,
            e[1] = i,
            this.W5i.uniform2f(this.q5i, t, i))
        }
        a6i(t, i, e) {
            t = Math.fround(t),
            i = Math.fround(i),
            e = Math.fround(e);
            const s = this.TDi;
            s[0] === t && s[1] === i && s[2] === e || (s[0] = t,
            s[1] = i,
            s[2] = e,
            this.W5i.uniform3f(this.q5i, t, i, e))
        }
        l6i(t, i, e, s) {
            t = Math.fround(t),
            i = Math.fround(i),
            e = Math.fround(e),
            s = Math.fround(s);
            const n = this.TDi;
            n[0] === t && n[1] === i && n[2] === e && n[3] === s || (n[0] = t,
            n[1] = i,
            n[2] = e,
            n[3] = s,
            this.W5i.uniform4f(this.q5i, t, i, e, s))
        }
        u6i(t) {
            const i = this.TDi;
            v_.w6t(i, t) || (b_.tii(i, t, 0),
            this.W5i.uniformMatrix4fv(this.q5i, !1, t))
        }
        c6i(t) {
            const i = this.J5i;
            return this.Q5i() ? i[0] === Math.fround(t.xsi()) && i[1] === Math.fround(t.Msi()) && i[2] === Math.fround(t.Esi()) : i[0] === Math.fround(t)
        }
        d6i(t) {
            const i = this.J5i;
            this.Q5i() ? (i[0] = t.xsi(),
            i[1] = t.Msi(),
            i[2] = t.Esi()) : i[0] = t
        }
        f6i(t) {
            return this.J5i[0] === Math.fround(t)
        }
        p6i(t, i) {
            const e = this.J5i;
            return e[0] === Math.fround(t) && e[1] === Math.fround(i)
        }
        m6i(t) {
            this.J5i[0] = t
        }
        w6i(t, i) {
            const e = this.J5i;
            e[0] = t,
            e[1] = i
        }
    }
}
{
    const x_ = self.t
      , M_ = self.r_
      , E_ = (M_.l_,
    M_.o_,
    new Set(["aPos", "aTex", "aColor", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar"]));
    x_.ea.g6i = class extends x_.ea.c4i {
        static async y6i(t, i) {
            const e = t.rot()
              , s = i.src
              , n = i.b6i
              , r = i.name
              , h = e.createShader(e.FRAGMENT_SHADER);
            e.shaderSource(h, s),
            e.compileShader(h);
            const o = e.createShader(e.VERTEX_SHADER);
            e.shaderSource(o, n),
            e.compileShader(o);
            const a = e.createProgram();
            e.attachShader(a, h),
            e.attachShader(a, o),
            e.bindAttribLocation(a, 0, "aPos"),
            e.bindAttribLocation(a, 1, "aTex"),
            e.bindAttribLocation(a, 2, "aColor"),
            e.bindAttribLocation(a, 3, "aPoints"),
            e.linkProgram(a);
            const l = t.v6i();
            if (l ? await t.S6i( () => e.getProgramParameter(a, l.COMPLETION_STATUS_KHR)) : await x_.Jti(5),
            !e.getShaderParameter(h, e.COMPILE_STATUS)) {
                const t = e.getShaderInfoLog(h);
                throw e.deleteShader(h),
                e.deleteShader(o),
                e.deleteProgram(a),
                new Error("Error compiling fragment shader: " + t)
            }
            if (!e.getShaderParameter(o, e.COMPILE_STATUS)) {
                const t = e.getShaderInfoLog(o);
                throw e.deleteShader(h),
                e.deleteShader(o),
                e.deleteProgram(a),
                new Error("Error compiling vertex shader: " + t)
            }
            if (!e.getProgramParameter(a, e.LINK_STATUS)) {
                const t = e.getProgramInfoLog(a);
                throw e.deleteShader(h),
                e.deleteShader(o),
                e.deleteProgram(a),
                new Error("Error linking shader program: " + t)
            }
            const u = x_._oi(e.getProgramInfoLog(a) || "").trim();
            return u && !x_.Eoi(u) && console.info(`[WebGL] Shader program '${r}' compilation log: `, u),
            e.deleteShader(h),
            e.deleteShader(o),
            a
        }
        static async hP(t, i) {
            const e = await x_.ea.g6i.y6i(t, i);
            return new x_.ea.g6i(t,e,i)
        }
        constructor(t, i, e) {
            super(t, e);
            const s = t.rot()
              , n = t.x6i();
            t.Q3i(),
            s.useProgram(i),
            this.W5i = s,
            this.b1i = i,
            this.M6i = "<default-device-transform>" === e.name;
            const r = s.getAttribLocation(i, "aPos")
              , h = s.getAttribLocation(i, "aTex")
              , o = s.getAttribLocation(i, "aColor");
            this.E6i = s.getAttribLocation(i, "aPoints"),
            -1 !== r && (s.bindBuffer(s.ARRAY_BUFFER, t.C6i),
            s.vertexAttribPointer(r, 3, s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(r)),
            -1 !== h && (s.bindBuffer(s.ARRAY_BUFFER, t._6i),
            s.vertexAttribPointer(h, 2, s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(h)),
            -1 !== o && (s.bindBuffer(s.ARRAY_BUFFER, t.T6i),
            s.vertexAttribPointer(o, 4, t.I6i() ? s.HALF_FLOAT : s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(o)),
            -1 !== this.E6i && (s.bindBuffer(s.ARRAY_BUFFER, t.P6i),
            s.vertexAttribPointer(this.E6i, 4, s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(this.E6i)),
            s.bindBuffer(s.ARRAY_BUFFER, null),
            this.G6i = new x_.ea.V5i(this,"matP","mat4"),
            this.A6i = new x_.ea.V5i(this,"matMV","mat4"),
            this.R6i = new x_.ea.V5i(this,"color","vec4"),
            this.k6i = new x_.ea.V5i(this,"samplerFront","sampler"),
            this.O6i = new x_.ea.V5i(this,"pointTexStart","vec2"),
            this.D6i = new x_.ea.V5i(this,"pointTexEnd","vec2"),
            this.F6i = new x_.ea.V5i(this,"zElevation","float"),
            this.L6i = new x_.ea.V5i(this,"tileSize","vec2"),
            this.B6i = new x_.ea.V5i(this,"tileSpacing","vec2"),
            this.U6i = new x_.ea.V5i(this,"color2_","vec4"),
            this.N6i = new x_.ea.V5i(this,"outlineThickness","float"),
            this.j6i = new x_.ea.V5i(this,"samplerBack","sampler"),
            this.$6i = new x_.ea.V5i(this,"samplerDepth","sampler"),
            this.z6i = new x_.ea.V5i(this,"destStart","vec2"),
            this.V6i = new x_.ea.V5i(this,"destEnd","vec2"),
            this.W6i = new x_.ea.V5i(this,"srcStart","vec2"),
            this.H6i = new x_.ea.V5i(this,"srcEnd","vec2"),
            this.K6i = new x_.ea.V5i(this,"srcOriginStart","vec2"),
            this.q6i = new x_.ea.V5i(this,"srcOriginEnd","vec2"),
            this.X6i = new x_.ea.V5i(this,"pixelSize","vec2"),
            this.Y6i = new x_.ea.V5i(this,"seconds","float"),
            this.J6i = new x_.ea.V5i(this,"devicePixelRatio","float"),
            this.Z6i = new x_.ea.V5i(this,"layerScale","float"),
            this.Q6i = new x_.ea.V5i(this,"layerAngle","float"),
            this.t8i = new x_.ea.V5i(this,"layoutStart","vec2"),
            this.i8i = new x_.ea.V5i(this,"layoutEnd","vec2"),
            this.e8i = new x_.ea.V5i(this,"zNear","float"),
            this.s8i = new x_.ea.V5i(this,"zFar","float"),
            this.n8i = !!(this.X6i.Z5i() || this.Y6i.Z5i() || this.j6i.Z5i() || this.z6i.Z5i() || this.V6i.Z5i() || this.W6i.Z5i() || this.H6i.Z5i() || this.K6i.Z5i() || this.q6i.Z5i() || this.J6i.Z5i() || this.Z6i.Z5i() || this.Q6i.Z5i() || this.t8i.Z5i() || this.i8i.Z5i());
            const a = e.parameters || [];
            this.r8i = [],
            this.P4i = this.X6i.Z5i() || this.W6i.Z5i() || this.H6i.Z5i() || this.K6i.Z5i() || this.q6i.Z5i(),
            this.h8i = !1,
            this.o8i = !1,
            this.R6i.n6i(1, 1, 1, 1),
            this.U6i.n6i(1, 1, 1, 1),
            this.k6i.i6i(0),
            this.j6i.i6i(1),
            this.$6i.i6i(2),
            this.O6i.e6i(0, 0),
            this.D6i.e6i(1, 1),
            this.F6i.t6i(0),
            this.L6i.e6i(0, 0),
            this.B6i.e6i(0, 0),
            this.z6i.e6i(0, 0),
            this.V6i.e6i(1, 1),
            this.W6i.e6i(0, 0),
            this.H6i.e6i(0, 0),
            this.K6i.e6i(0, 0),
            this.q6i.e6i(0, 0),
            this.X6i.e6i(0, 0),
            this.J6i.t6i(1),
            this.e8i.t6i(t.fE()),
            this.s8i.t6i(t.uE()),
            this.Z6i.t6i(1),
            this.Q6i.t6i(0),
            this.Y6i.t6i(0),
            this.t8i.e6i(0, 0),
            this.i8i.e6i(0, 0),
            this.N6i.t6i(1);
            for (const t of a) {
                const i = t[0]
                  , e = t[2]
                  , s = new x_.ea.V5i(this,i,e);
                "color" === e ? s.s6i(0, 0, 0) : s.t6i(0),
                this.r8i.push(s)
            }
            this.M6i ? this.a8i(n.l8i) : (this.u8i(n.l8i, !0),
            this.c8i(n.d8i, !0));
            const l = n.f8i;
            s.useProgram(l ? l.b1i : null)
        }
        he() {
            this.W5i.deleteProgram(this.b1i),
            this.b1i = null,
            this.cn.u3i(this),
            this.W5i = null,
            super.he()
        }
        H5i() {
            return this.W5i
        }
        X5i() {
            return this.b1i
        }
        VBt() {
            return this.r8i.length
        }
        p8i(t) {
            return t < 0 || t >= this.r8i.length ? null : this.r8i[t].W7()
        }
        m8i(t) {
            for (let i = 0, e = t.length; i < e; ++i)
                if (!this.r8i[i].c6i(t[i]))
                    return !1;
            return !0
        }
        w8i(t) {
            for (let i = 0, e = t.length; i < e; ++i)
                this.r8i[i].d6i(t[i])
        }
        g8i(t, i, e, s, n, r, h, o, a, l) {
            return !this.j6i.Z5i() && (!(this.X6i.Z5i() && !this.X6i.p6i(n, r)) && (!(this.z6i.Z5i() && !this.z6i.p6i(t.Yr(), t.Jr())) && (!(this.V6i.Z5i() && !this.V6i.p6i(t.pl(), t.dl())) && (!(this.J6i.Z5i() && !this.J6i.f6i(h)) && (!(this.Z6i.Z5i() && !this.Z6i.f6i(o)) && (!(this.Q6i.Z5i() && !this.Q6i.f6i(a)) && (!(this.W6i.Z5i() && !this.W6i.p6i(i.Yr(), i.Jr())) && (!(this.H6i.Z5i() && !this.H6i.p6i(i.pl(), i.dl())) && (!(this.K6i.Z5i() && !this.K6i.p6i(e.Yr(), e.Jr())) && (!(this.q6i.Z5i() && !this.q6i.p6i(e.pl(), e.dl())) && (!(this.t8i.Z5i() && !this.t8i.p6i(s.Yr(), s.Jr())) && (!(this.i8i.Z5i() && !this.i8i.p6i(s.Jr(), s.dl())) && !(this.Y6i.Z5i() && !this.Y6i.f6i(l))))))))))))))
        }
        y8i(t, i, e, s, n, r, h, o, a, l) {
            this.j6i.Z5i() || (this.X6i.Z5i() && this.X6i.w6i(n, r),
            this.z6i.Z5i() && this.z6i.w6i(t.Yr(), t.Jr()),
            this.V6i.Z5i() && this.V6i.w6i(t.pl(), t.dl()),
            this.J6i.Z5i() && this.J6i.m6i(h),
            this.Z6i.Z5i() && this.Z6i.m6i(o),
            this.Q6i.Z5i() && this.Q6i.m6i(a),
            this.W6i.Z5i() && this.W6i.w6i(i.Yr(), i.Jr()),
            this.H6i.Z5i() && this.H6i.w6i(i.pl(), i.dl()),
            this.K6i.Z5i() && this.K6i.w6i(e.Yr(), e.Jr()),
            this.q6i.Z5i() && this.q6i.w6i(e.pl(), e.dl()),
            this.t8i.Z5i() && this.t8i.w6i(s.Yr(), s.Jr()),
            this.i8i.Z5i() && this.i8i.w6i(s.Jr(), s.dl()),
            this.Y6i.Z5i() && this.Y6i.m6i(l))
        }
        u8i(t, i) {
            this.h8i && !i || this.M6i || (this.G6i.Z5i() && this.G6i.u6i(t),
            this.h8i = !0)
        }
        b8i() {
            this.h8i = !1
        }
        c8i(t, i) {
            this.o8i && !i || this.M6i || (this.A6i.Z5i() && this.A6i.u6i(t),
            this.o8i = !0)
        }
        v8i() {
            this.o8i = !1
        }
        a8i(t) {
            if (!this.M6i)
                throw new Error("not device transform shader");
            this.G6i.u6i(t);
            const i = this.cn
              , e = i.ns() / 2
              , s = i.er() / 2
              , n = i.nR(e, s, i.ga(i.er()), e, s, 0, i.er());
            this.A6i.u6i(n)
        }
        S8i(t) {
            this.R6i.Z5i() && this.R6i.l6i(t[0], t[1], t[2], t[3])
        }
        static x8i() {
            return E_
        }
        static M8i(t) {
            return t ? "\n#extension GL_EXT_conservative_depth : enable\nlayout (depth_greater) out highp float gl_FragDepth;\n\t" : ""
        }
        static E8i(t) {
            const i = t ? "highp" : "mediump";
            return ["attribute highp vec3 aPos;", `attribute ${i} vec2 aTex;`, `varying ${i} vec2 vTex;`, "attribute lowp vec4 aColor;", "varying lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPos, 1.0);", "\tvTex = aTex;", "\tvColor = aColor;", "}"].join("\n")
        }
        static C8i(t) {
            const i = t ? "highp" : "mediump";
            return ["#version 300 es", "in highp vec3 aPos;", `in ${i} vec2 aTex;`, `out ${i} vec2 vTex;`, "in lowp vec4 aColor;", "out lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPos, 1.0);", "\tvTex = aTex;", "\tvColor = aColor;", "}"].join("\n")
        }
        static _8i() {
            return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * vColor;", "}"].join("\n")
        }
        static T8i() {
            return ["#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * vColor;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static I8i(t) {
            return ["#version 300 es", x_.ea.g6i.M8i(t), "in mediump vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\toutColor = texture(samplerFront, vTex) * vColor;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static P8i() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "}"].join("\n")
        }
        static G8i() {
            return ["#extension GL_EXT_frag_depth : enable", "varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static A8i(t) {
            return ["#version 300 es", x_.ea.g6i.M8i(t), "in highp vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static R8i(t, i, e, s) {
            let n = "";
            return t >= 2 ? n = "#version 300 es\n" + x_.ea.g6i.M8i(s) : (i && (n = "#extension GL_EXT_frag_depth : enable\n"),
            e && (n += "#extension GL_EXT_shader_texture_lod : enable\n",
            n += "#extension GL_OES_standard_derivatives : enable\n")),
            n + `\nprecision highp float;\n${t >= 2 ? "in" : "varying"} vec2 vTex;\n${t >= 2 ? "out lowp vec4 outColor;" : ""}\n${t >= 2 ? "in" : "varying"} lowp vec4 vColor;\nuniform lowp sampler2D samplerFront;\nuniform vec2 pixelSize;\n\nuniform vec2 tileSize;\nuniform vec2 tileSpacing;\nuniform float outlineThickness;\n\nconst float PI = 3.1415926;\n\nlowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)\n{\n\treturn (a + b + (a - b) * cos(x * PI)) / 2.0;\n}\n\nvec3 randVec3(vec2 seed)\n{\n\treturn vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));\n}\n\nlowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)\n{\n\tvec2 posRandom = tileSize;\n\tfloat angleRandom = outlineThickness;\n\t\n\tvec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;\n\t\n\tfloat angle = angleRandom * rand.z * PI;\n\tfloat sin_a = sin(angle);\n\tfloat cos_a = cos(angle);\n\tfloat aspect = pixelSize.x / pixelSize.y;\n\n\tvec2 mid = tile + vec2(0.5, 0.5);\n\tvec2 dp = uv - mid;\n\tdp.x /= aspect;\n\tvec2 r = vec2(dp.x * cos_a - dp.y * sin_a,\n\t\t\t\t  dp.y * cos_a + dp.x * sin_a);\n\tr.x *= aspect;\n\n\tvec2 p = mid + r + (posRandom * rand.xy / 2.0);\n\t\n\t${t >= 2 ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}\n\t${t < 2 && e ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}\n\t${t < 2 && !e ? "return texture2D(samplerFront, p);" : ""}\n}\n\nvoid main(void) {\n\t\n\t${t < 2 ? "lowp vec4 outColor;" : ""}\n\t\n\tfloat blendMarginX = tileSpacing.x;\n\tfloat blendMarginY = tileSpacing.y;\n\t\n\tvec2 tile = floor(vTex);\n\tvec2 tex = fract(vTex);\n\tvec2 ddx = ${t >= 2 || e ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};\n\tvec2 ddy = ${t >= 2 || e ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};\n\t\n\tvec4 curTile = sampleTile(tile, vTex, ddx, ddy);\n\t\n\tbool inLeftMargin = (tex.x < blendMarginX);\n\tbool inRightMargin = (tex.x > 1.0 - blendMarginX);\n\tbool inTopMargin = (tex.y < blendMarginY);\n\tbool inBottomMargin = (tex.y > 1.0 - blendMarginY);\n\t\n\tif (inLeftMargin)\n\t{\n\t\tlowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;\n\t\tlowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = leftMixedTile;\n\t\t}\n\t}\n\telse if (inRightMargin)\n\t{\n\t\tlowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);\n\t\tlowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = rightMixedTile;\n\t\t}\n\t}\n\telse if (inTopMargin)\n\t{\n\t\tlowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t}\n\telse if (inBottomMargin)\n\t{\n\t\tlowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t}\n\telse\n\t{\n\t\toutColor = curTile;\n\t}\n\t\n\toutColor *= vColor;\n\t${t < 2 ? "gl_FragColor = outColor;" : ""}\n\t${t >= 2 ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}\n\t${t < 2 && i ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}\n}\n`
        }
        static k8i() {
            return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}"].join("\n")
        }
        static O8i() {
            return ["#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}"].join("\n")
        }
        static D8i() {
            return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}"].join("\n")
        }
        static F8i() {
            return ["#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static L8i(t) {
            return ["#version 300 es", x_.ea.g6i.M8i(t), "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static B8i() {
            return ["varying lowp vec4 vColor;", "void main(void) {", "\tgl_FragColor = vColor;", "}"].join("\n")
        }
        static U8i() {
            return ["precision lowp float;", "varying mediump vec2 vTex;", "varying vec4 vColor;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "\tvec3 lower = linearRGB * vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "\tvec3 lower = sRGB/vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "\tvec3 linearGrad = mix(toLinear(vColor.rgb), toLinear(color2_.rgb), vTex.x);", "\tfloat a = mix(vColor.a, color2_.a, vTex.x);", "\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join("\n")
        }
        static N8i() {
            return ["precision lowp float;", "varying highp vec2 vTex;", "varying vec4 vColor;", "void main(void) {", "\thighp float grad = vTex.x / (1.0 - vTex.y);", "\tgl_FragColor = vColor * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);", "}"].join("\n")
        }
        static j8i() {
            return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "\tgl_FragColor = vColor * f;", "}"].join("\n")
        }
        static $8i() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp float f = step(diffSq.x + diffSq.y, 0.25);", "\tgl_FragColor = vColor * f;", "}"].join("\n")
        }
        static z8i() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp float distSq = diffSq.x + diffSq.y;", "\thighp vec2 norm = normalize(diff);", "\thighp vec2 halfNorm = norm * 0.5;", "\thighp float innerF = step(distSq, 0.25);", "\thighp vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "\thighp vec2 innerEdgeSq = innerEdge * innerEdge;", "\thighp float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "\tgl_FragColor = vColor * innerF * outerF;", "}"].join("\n")
        }
        static V8i() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp vec2 norm = normalize(diff);", "\thighp vec2 halfNorm = norm * 0.5;", "\thighp vec2 halfNormSq = halfNorm * halfNorm;", "\thighp vec2 innerEdge = halfNorm - pixelSize * norm;", "\thighp vec2 innerEdgeSq = innerEdge * innerEdge;", "\thighp float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "\tgl_FragColor = vColor * f;", "}"].join("\n")
        }
        static W8i() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp float distSq = diffSq.x + diffSq.y;", "\thighp vec2 norm = normalize(diff);", "\thighp vec2 halfNorm = norm * 0.5;", "\thighp vec2 halfNormSq = halfNorm * halfNorm;", "\thighp vec2 pxNorm = pixelSize * norm;", "\thighp vec2 innerEdge1 = halfNorm - pxNorm;", "\thighp vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "\thighp float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "\thighp vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "\thighp vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "\thighp vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "\thighp vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "\thighp float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "\tgl_FragColor = vColor * innerF * outerF;", "}"].join("\n")
        }
    }
}
{
    const C_ = self.t
      , __ = self.r_
      , T_ = (__.L8t,
    __.o_)
      , I_ = 1
      , P_ = 2
      , G_ = 3
      , A_ = 4
      , R_ = 5
      , k_ = 6
      , O_ = 7
      , D_ = 8
      , F_ = 9
      , L_ = 10
      , B_ = 11
      , U_ = 12
      , N_ = 13
      , j_ = 14
      , $_ = 15
      , z_ = 16
      , V_ = 17
      , W_ = 18
      , H_ = 19
      , K_ = 20
      , q_ = 21
      , X_ = 22
      , Y_ = 23
      , J_ = 24
      , Z_ = 25
      , Q_ = 26
      , tT = 27
      , iT = 28
      , eT = 29
      , sT = 30;
    C_.ea.H8i = class {
        constructor(t) {
            this.wv = t,
            this.d8i = T_.create(),
            this.l8i = T_.create(),
            this.K8i = null,
            this.q8i = null,
            this.X8i = !1,
            this.f8i = null,
            this.Y8i = new C_.Rect,
            this.clearColor = C_.v(C_.za, 0, 0, 0, 0)
        }
    }
    ,
    C_.ea.J8i = class {
        constructor(t) {
            const i = new ArrayBuffer(96);
            this.aGt = 0,
            this.Z8i = t,
            this.W5i = t.wv.rot(),
            this.Q8i = 0,
            this.t7i = 0,
            this.i7i = null,
            this.e7i = new Float32Array(i,0,16),
            this.s7i = new Float32Array(i,64,4),
            this.n7i = new Float32Array(i,80,4),
            this.r7i = []
        }
        h7i(t, i) {
            this.aGt = I_,
            this.Q8i = t,
            this.t7i = i
        }
        o7i() {
            const t = this.W5i;
            t.drawElements(t.TRIANGLES, this.t7i, t.UNSIGNED_SHORT, this.Q8i)
        }
        a7i(t) {
            this.aGt = P_,
            this.i7i = t
        }
        l7i() {
            const t = this.W5i
              , i = this.i7i;
            t.bindTexture(t.TEXTURE_2D, i ? i.u7i() : null)
        }
        c7i(t) {
            this.aGt = K_,
            t.usi(this.s7i, 0)
        }
        d7i() {
            const t = this.s7i
              , i = this.Z8i.f8i;
            i.U6i.Z5i() && i.U6i.l6i(t[0], t[1], t[2], t[3])
        }
        f7i(t, i) {
            this.aGt = G_,
            this.Q8i = t,
            this.t7i = i
        }
        p7i() {
            this.W5i.blendFunc(this.Q8i, this.t7i)
        }
        m7i(t, i, e, s) {
            this.aGt = A_;
            const n = this.s7i;
            n[0] = t,
            n[1] = i,
            n[2] = e,
            n[3] = s
        }
        w7i() {
            const t = this.s7i;
            this.W5i.viewport(t[0], t[1], t[2], t[3])
        }
        g7i(t) {
            this.aGt = R_,
            T_.Qr(this.e7i, t)
        }
        y7i() {
            const t = this.Z8i
              , i = t.wv.T2i
              , e = t.f8i
              , s = this.e7i;
            for (let t = 0, n = i.length; t < n; ++t) {
                const n = i[t];
                n === e ? n.u8i(s, !0) : n.b8i()
            }
            T_.Qr(t.l8i, s)
        }
        b7i(t) {
            this.aGt = k_,
            T_.Qr(this.e7i, t)
        }
        v7i() {
            const t = this.Z8i
              , i = t.wv.T2i
              , e = t.f8i
              , s = this.e7i;
            for (let t = 0, n = i.length; t < n; ++t) {
                const n = i[t];
                n === e ? n.c8i(s, !0) : n.v8i()
            }
            T_.Qr(t.d8i, s)
        }
        S7i(t) {
            this.aGt = O_,
            this.i7i = t
        }
        x7i() {
            const t = this.W5i
              , i = this.i7i
              , e = this.Z8i;
            i ? (e.K8i = i.M7i(),
            e.q8i = i.E7i(),
            e.X8i && e.q8i ? t.bindFramebuffer(t.FRAMEBUFFER, e.q8i) : t.bindFramebuffer(t.FRAMEBUFFER, e.K8i)) : (e.K8i = null,
            e.q8i = null,
            t.bindFramebuffer(t.FRAMEBUFFER, null))
        }
        C7i(t) {
            this.aGt = D_,
            t.usi(this.e7i, 0)
        }
        _7i(t, i, e, s) {
            this.aGt = D_;
            const n = this.e7i;
            n[0] = t,
            n[1] = i,
            n[2] = e,
            n[3] = s
        }
        T7i() {
            const t = this.W5i
              , i = this.e7i
              , e = this.Z8i.clearColor
              , s = i[0]
              , n = i[1]
              , r = i[2]
              , h = i[3];
            e.Isi(s, n, r, h) || (t.clearColor(s, n, r, h),
            e.msi(s, n, r, h)),
            t.clear(t.COLOR_BUFFER_BIT)
        }
        I7i(t) {
            this.aGt = j_,
            t.usi(this.e7i, 0)
        }
        P7i() {
            const t = this.e7i;
            this.Z8i.Y8i.set(t[0], t[1], t[2], t[3])
        }
        G7i(t, i, e) {
            this.aGt = F_,
            this.Q8i = t,
            this.t7i = 1,
            this.e7i[0] = i,
            e.usi(this.s7i, 0)
        }
        A7i() {
            const t = this.W5i
              , i = this.Z8i
              , e = i.wv.G2i;
            t.useProgram(e.b1i),
            e.u8i(i.l8i, !1),
            e.c8i(i.d8i, !1);
            const s = i.Y8i;
            e.O6i.Z5i() && e.O6i.o6i(s.Yr(), s.Jr()),
            e.D6i.Z5i() && e.D6i.o6i(s.pl(), s.dl());
            const n = this.e7i[0];
            if (e.F6i.Z5i() && e.F6i.r6i(n),
            e.R6i.Z5i()) {
                const t = this.s7i;
                e.R6i.l6i(t[0], t[1], t[2], t[3])
            }
            t.drawArrays(t.POINTS, this.Q8i / 4, this.t7i),
            t.useProgram(i.f8i.b1i)
        }
        R7i(t) {
            this.aGt = L_,
            this.i7i = t
        }
        k7i() {
            const t = this.W5i
              , i = this.Z8i
              , e = this.i7i;
            i.f8i = e,
            t.useProgram(e.b1i),
            e.u8i(i.l8i, !1),
            e.c8i(i.d8i, !1)
        }
        O7i() {
            this.aGt = B_
        }
        D7i() {
            const t = this.Z8i.f8i
              , i = this.W5i
              , e = this.e7i
              , s = this.s7i
              , n = this.n7i;
            if (t.j6i.Z5i()) {
                const t = this.Z8i.wv
                  , e = this.i7i;
                t.F7i !== e && (i.activeTexture(i.TEXTURE1),
                i.bindTexture(i.TEXTURE_2D, e ? e.u7i() : null),
                t.F7i = e,
                i.activeTexture(i.TEXTURE0))
            }
            t.X6i.Z5i() && t.X6i.o6i(e[0], e[1]),
            t.z6i.Z5i() && t.z6i.o6i(e[2], e[3]),
            t.V6i.Z5i() && t.V6i.o6i(e[4], e[5]),
            t.J6i.Z5i() && t.J6i.r6i(this.t7i),
            t.Z6i.Z5i() && t.Z6i.r6i(e[6]),
            t.Q6i.Z5i() && t.Q6i.r6i(e[7]),
            t.W6i.Z5i() && t.W6i.o6i(e[12], e[13]),
            t.H6i.Z5i() && t.H6i.o6i(e[14], e[15]),
            t.K6i.Z5i() && t.K6i.o6i(n[0], n[1]),
            t.q6i.Z5i() && t.q6i.o6i(n[2], n[3]),
            t.t8i.Z5i() && t.t8i.o6i(s[0], s[1]),
            t.i8i.Z5i() && t.i8i.o6i(s[2], s[3]),
            t.Y6i.Z5i() && t.Y6i.r6i(this.Q8i)
        }
        L7i() {
            this.aGt = U_
        }
        B7i() {
            const t = this.Z8i.f8i.r8i
              , i = this.r7i;
            for (let e = 0, s = t.length; e < s; ++e) {
                const s = t[e]
                  , n = i[e];
                s.Q5i() ? s.a6i(n.xsi(), n.Msi(), n.Esi()) : s.r6i(n)
            }
        }
        U7i(t) {
            this.aGt = N_,
            this.i7i = t
        }
        N7i() {
            const t = this.W5i
              , i = this.i7i
              , e = this.Z8i.K8i;
            i !== e && t.bindFramebuffer(t.FRAMEBUFFER, i),
            t.invalidateFramebuffer(t.FRAMEBUFFER, [t.COLOR_ATTACHMENT0]),
            i !== e && t.bindFramebuffer(t.FRAMEBUFFER, e)
        }
        j7i(t, i, e) {
            this.aGt = z_;
            const s = this.e7i
              , n = this.Z8i.wv;
            s[0] = t.ns(),
            s[1] = t.er(),
            s[2] = i ? i.ns() : n.ns(),
            s[3] = i ? i.er() : n.er(),
            s[4] = t.DU() ? 1 : 0,
            s[5] = "stretch" === e;
            const r = this.r7i;
            C_.Io(r),
            r.push(t.M7i()),
            r.push(i ? i.M7i() : null)
        }
        $7i() {
            const t = this.e7i
              , i = this.r7i
              , e = this.W5i
              , s = t[0]
              , n = t[1]
              , r = t[2]
              , h = t[3]
              , o = 0 !== t[4]
              , a = 0 !== t[5]
              , l = i[0]
              , u = i[1];
            if (e.bindFramebuffer(e.READ_FRAMEBUFFER, l),
            e.bindFramebuffer(e.DRAW_FRAMEBUFFER, u),
            a)
                e.blitFramebuffer(0, 0, s, n, 0, 0, r, h, e.COLOR_BUFFER_BIT, o ? e.LINEAR : e.NEAREST);
            else {
                const t = Math.min(s, r)
                  , i = Math.min(n, h)
                  , o = Math.max(n - h, 0)
                  , a = Math.max(h - n, 0);
                e.blitFramebuffer(0, o, t, i + o, 0, a, t, i + a, e.COLOR_BUFFER_BIT, e.NEAREST)
            }
        }
        z7i(t) {
            this.aGt = V_,
            this.i7i = t
        }
        V7i() {
            this.i7i.W7i(),
            this.i7i = null
        }
        H7i(t) {
            this.aGt = W_,
            this.i7i = t
        }
        K7i() {
            this.i7i.q7i(),
            this.i7i = null
        }
        X7i(t, i, e) {
            this.aGt = H_;
            const s = this.e7i;
            s[0] = t,
            s[1] = i,
            s[2] = e
        }
        Y7i() {
            const t = this.Z8i.f8i
              , i = this.e7i;
            t.X6i.Z5i() && t.X6i.o6i(i[0], i[1]),
            t.N6i.Z5i() && t.N6i.r6i(i[2])
        }
        J7i(t, i, e, s, n, r, h) {
            this.aGt = $_;
            const o = this.e7i;
            t.usi(o, 0),
            o[4] = 1 / i,
            o[5] = 1 / e,
            o[6] = s / i,
            o[7] = n / e,
            o[8] = r / i,
            o[9] = h / e
        }
        Z7i() {
            const t = this.Z8i.f8i
              , i = this.e7i;
            t.W6i.Z5i() && t.W6i.o6i(i[0], i[1]),
            t.X6i.Z5i() && t.X6i.o6i(i[4], i[5]),
            t.L6i.Z5i() && t.L6i.o6i(i[6], i[7]),
            t.B6i.Z5i() && t.B6i.o6i(i[8], i[9])
        }
        Q7i(t, i, e, s, n, r, h) {
            this.aGt = iT;
            const o = this.e7i;
            o[0] = 1 / t,
            o[1] = 1 / i,
            o[2] = e,
            o[3] = s,
            o[4] = n,
            o[5] = r,
            o[6] = h
        }
        t9i() {
            const t = this.Z8i.f8i
              , i = this.e7i;
            t.X6i.Z5i() && t.X6i.o6i(i[0], i[1]),
            t.L6i.Z5i() && t.L6i.o6i(i[2], i[3]),
            t.N6i.Z5i() && t.N6i.r6i(i[4]),
            t.B6i.Z5i() && t.B6i.o6i(i[5], i[6])
        }
        i9i(t) {
            this.aGt = q_,
            this.Q8i = t ? 1 : 0
        }
        e9i() {
            const t = this.W5i
              , i = 0 !== this.Q8i;
            i || t.depthMask(!0),
            t.clear(t.DEPTH_BUFFER_BIT),
            i || t.depthMask(!1)
        }
        s9i(t) {
            this.aGt = X_,
            this.Q8i = t ? 1 : 0
        }
        n9i() {
            const t = this.W5i;
            0 === this.Q8i ? (t.disable(t.DEPTH_TEST),
            t.depthMask(!1)) : (t.enable(t.DEPTH_TEST),
            t.depthMask(!0))
        }
        r9i(t) {
            this.aGt = Y_,
            this.Q8i = t ? 1 : 0
        }
        h9i() {
            const t = this.W5i
              , i = this.Z8i
              , e = i.wv
              , s = 0 !== this.Q8i;
            i.X8i = s,
            t.activeTexture(t.TEXTURE2),
            s ? (i.q8i && t.bindFramebuffer(t.FRAMEBUFFER, i.q8i),
            t.bindTexture(t.TEXTURE_2D, e.o9i())) : (t.bindTexture(t.TEXTURE_2D, null),
            i.q8i && t.bindFramebuffer(t.FRAMEBUFFER, i.K8i)),
            t.activeTexture(t.TEXTURE0)
        }
        a9i() {
            this.aGt = J_
        }
        l9i() {
            const t = this.W5i;
            t.clear(t.STENCIL_BUFFER_BIT),
            t.enable(t.STENCIL_TEST),
            t.stencilFunc(t.ALWAYS, 1, 1),
            t.stencilOp(t.KEEP, t.KEEP, t.REPLACE),
            t.colorMask(!1, !1, !1, !1)
        }
        u9i() {
            this.aGt = Z_
        }
        c9i() {
            const t = this.W5i;
            t.enable(t.STENCIL_TEST),
            t.colorMask(!0, !0, !0, !0),
            t.stencilFunc(t.EQUAL, 1, 1),
            t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
        }
        d9i() {
            this.aGt = Q_
        }
        f9i() {
            const t = this.W5i;
            t.disable(t.STENCIL_TEST)
        }
        p9i(t, i, e, s, n) {
            this.aGt = tT,
            this.Q8i = t ? 1 : 0;
            const r = this.e7i;
            r[0] = i,
            r[1] = e,
            r[2] = s,
            r[3] = n
        }
        m9i() {
            const t = this.W5i
              , i = this.e7i;
            1 === this.Q8i ? (t.enable(t.SCISSOR_TEST),
            t.scissor(i[0], i[1], i[2], i[3])) : t.disable(t.SCISSOR_TEST)
        }
        w9i(t) {
            this.aGt = eT,
            this.Q8i = t
        }
        g9i() {
            const t = this.W5i
              , i = this.Q8i;
            0 === i ? t.disable(t.CULL_FACE) : (t.enable(t.CULL_FACE),
            1 === i ? t.cullFace(t.BACK) : t.cullFace(t.FRONT))
        }
        y9i(t) {
            this.aGt = sT,
            this.Q8i = t
        }
        b9i() {
            const t = this.W5i;
            t.frontFace(0 === this.Q8i ? t.CW : t.CCW)
        }
        v9i() {
            switch (this.aGt) {
            case 1:
                return void this.o7i();
            case 2:
                return void this.l7i();
            case 3:
                return void this.p7i();
            case 4:
                return void this.w7i();
            case 5:
                return void this.y7i();
            case 6:
                return void this.v7i();
            case 7:
                return void this.x7i();
            case 8:
                return void this.T7i();
            case 9:
                return void this.A7i();
            case 10:
                return void this.k7i();
            case 11:
                return void this.D7i();
            case 12:
                return void this.B7i();
            case 13:
                return void this.N7i();
            case 14:
                return void this.P7i();
            case 15:
                return void this.Z7i();
            case 16:
                return void this.$7i();
            case 17:
                return void this.V7i();
            case 18:
                return void this.K7i();
            case 19:
                return void this.Y7i();
            case 20:
                return void this.d7i();
            case 21:
                return void this.e9i();
            case 22:
                return void this.n9i();
            case 23:
                return void this.h9i();
            case 24:
                return void this.l9i();
            case 25:
                return void this.c9i();
            case 26:
                return void this.f9i();
            case 27:
                return void this.m9i();
            case 28:
                return void this.t9i();
            case 29:
                return void this.g9i();
            case 30:
                return void this.b9i()
            }
        }
    }
}
{
    const nT = self.t
      , rT = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"])
      , hT = new Set(["nearest", "bilinear", "trilinear"])
      , oT = new Set(["default", "low", "high"])
      , aT = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
    function lT(t, i) {
        let e, s, n, r;
        switch (t) {
        case "rgba8":
            e = i.RGBA8,
            s = i.RGBA,
            n = i.RGBA,
            r = i.UNSIGNED_BYTE;
            break;
        case "rgb8":
            e = i.RGB8,
            s = i.RGB,
            n = i.RGB,
            r = i.UNSIGNED_BYTE;
            break;
        case "rgba4":
            e = i.RGBA4,
            s = i.RGBA,
            n = i.RGBA,
            r = i.UNSIGNED_SHORT_4_4_4_4;
            break;
        case "rgb5_a1":
            e = i.RGB5_A1,
            s = i.RGBA,
            n = i.RGBA,
            r = i.UNSIGNED_SHORT_5_5_5_1;
            break;
        case "rgb565":
            e = i.RGB565,
            s = i.RGB,
            n = i.RGB,
            r = i.UNSIGNED_SHORT_5_6_5;
            break;
        default:
            throw new Error("invalid pixel format")
        }
        return {
            S9i: e,
            x9i: s,
            format: n,
            type: r
        }
    }
    const uT = {
        kn: "clamp-to-edge",
        Rn: "clamp-to-edge",
        Mn: "trilinear",
        On: 0,
        M9i: "rgba8",
        yS: !0,
        SS: "default",
        E9i: !0,
        wd: !1,
        width: -1,
        height: -1
    }
      , cT = {
        E9i: !0,
        flipY: !1
    }
      , dT = new Set;
    nT.ea.C9i = class {
        constructor(t) {
            nT.U(t, nT.ea.yU),
            this.cn = t,
            this.tn = null,
            this.Fx = 0,
            this.Ex = 0,
            this._9i = !0,
            this.lC = "clamp-to-edge",
            this.hC = "clamp-to-edge",
            this.T9i = "trilinear",
            this.I9i = 0,
            this.P9i = "rgba8",
            this.G9i = !1,
            this.A9i = "default",
            this.Byi = 0
        }
        R9i(t, i) {
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData || t instanceof ArrayBuffer))
                throw new Error("invalid texture source");
            if (nT.kQ(i),
            i = Object.assign({}, uT, i),
            this.tn)
                throw new Error("already created texture");
            if (nT.zt(i.kn),
            nT.zt(i.Rn),
            nT.zt(i.M9i),
            nT.zt(this.T9i),
            nT.Ge(i.On),
            this.lC = i.kn,
            this.hC = i.Rn,
            this.T9i = i.Mn,
            this.I9i = i.On,
            this.P9i = i.M9i,
            this.G9i = !!i.yS && this.cn.s4i(),
            this.A9i = i.SS,
            !aT.has(this.lC) || !aT.has(this.hC))
                throw new Error("invalid wrap mode");
            if (!hT.has(this.T9i))
                throw new Error("invalid sampling");
            if (!rT.has(this.P9i))
                throw new Error("invalid pixel format");
            if (!oT.has(this.A9i))
                throw new Error("invalid mipmap quality");
            if (this._9i = !0,
            t instanceof ArrayBuffer || null === t || i.wd) {
                if (nT.Ge(i.width),
                nT.Ge(i.height),
                this.Fx = i.width,
                this.Ex = i.height,
                t instanceof ArrayBuffer && t.byteLength !== this.Fx * this.Ex * 4)
                    throw new Error("ArrayBuffer wrong size")
            } else
                this.Fx = t.width,
                this.Ex = t.height;
            if (this.Fx <= 0 || this.Ex <= 0)
                throw new Error("invalid texture data size");
            if (i.wd) {
                const i = nT.sy(this.Fx, this.Ex);
                i.getContext("2d").drawImage(t, 0, 0, this.Fx, this.Ex),
                t = i
            }
            const e = nT.jei(this.Fx) && nT.jei(this.Ex)
              , s = this.cn.T5i();
            if (this.Fx > s || this.Ex > s)
                throw new Error("texture data exceeds maximum texture size");
            const n = this.cn.rot()
              , r = this.cn.k9i();
            this.tn = n.createTexture(),
            n.bindTexture(n.TEXTURE_2D, this.tn),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.E9i),
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1);
            const h = lT(this.P9i, n);
            if (this.cn.gS() || e || !this.O9i())
                if (r >= 2) {
                    let i;
                    i = this.G9i ? Math.floor(Math.log2(Math.max(this.Fx, this.Ex)) + 1) : 1,
                    n.texStorage2D(n.TEXTURE_2D, i, h.S9i, this.Fx, this.Ex),
                    t instanceof ArrayBuffer ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, this.Fx, this.Ex, h.format, h.type, new Uint8Array(t)) : null !== t && n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, h.format, h.type, t)
                } else
                    t instanceof ArrayBuffer ? n.texImage2D(n.TEXTURE_2D, 0, h.x9i, this.Fx, this.Ex, 0, h.format, h.type, new Uint8Array(t)) : null === t ? n.texImage2D(n.TEXTURE_2D, 0, h.x9i, this.Fx, this.Ex, 0, h.format, h.type, null) : n.texImage2D(n.TEXTURE_2D, 0, h.x9i, h.format, h.type, t);
            else {
                if (null === t)
                    throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                if (t instanceof ArrayBuffer && (t = new ImageData(new Uint8ClampedArray(t),this.Fx,this.Ex)),
                t instanceof ImageData) {
                    const i = nT.sy(this.Fx, this.Ex);
                    i.getContext("2d").putImageData(t, 0, 0),
                    t = i
                }
                const i = nT.sy(nT.na(this.Fx), nT.na(this.Ex))
                  , e = i.getContext("2d");
                e.imageSmoothingEnabled = "nearest" !== this.T9i,
                e.drawImage(t, 0, 0, this.Fx, this.Ex, 0, 0, i.width, i.height),
                n.texImage2D(n.TEXTURE_2D, 0, h.x9i, h.format, h.type, i)
            }
            null !== t && this.D9i(n),
            n.bindTexture(n.TEXTURE_2D, null),
            this.cn.F9i(),
            this.Byi = 1,
            dT.add(this)
        }
        L9i(t, i, e) {
            if (nT.Ge(t),
            nT.Ge(i),
            nT.kQ(e),
            e = Object.assign({}, uT, e),
            this.tn)
                throw new Error("already created texture");
            if (nT.zt(e.kn),
            nT.zt(e.Rn),
            nT.zt(e.M9i),
            nT.zt(this.T9i),
            this.lC = e.kn,
            this.hC = e.Rn,
            this.T9i = e.Mn,
            this.P9i = e.M9i,
            this.G9i = !!e.yS && this.cn.s4i(),
            this.A9i = e.SS,
            !aT.has(this.lC) || !aT.has(this.hC))
                throw new Error("invalid wrap mode");
            if (!hT.has(this.T9i))
                throw new Error("invalid sampling");
            if (!rT.has(this.P9i))
                throw new Error("invalid pixel format");
            if (!oT.has(this.A9i))
                throw new Error("invalid mipmap quality");
            this._9i = !1,
            this.Fx = Math.floor(t),
            this.Ex = Math.floor(i);
            const s = nT.jei(this.Fx) && nT.jei(this.Ex)
              , n = this.cn.T5i();
            if (this.Fx <= 0 || this.Ex <= 0)
                throw new Error("invalid texture size");
            if (this.Fx > n || this.Ex > n)
                throw new Error("texture exceeds maximum texture size");
            if (!this.cn.gS() && this.O9i() && !s)
                throw new Error("non-power-of-two tiled textures not supported");
            const r = this.cn.rot()
              , h = this.cn.k9i();
            this.tn = r.createTexture(),
            r.bindTexture(r.TEXTURE_2D, this.tn),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.E9i),
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1);
            const o = lT(this.P9i, r)
              , a = h >= 2 ? o.S9i : o.x9i;
            r.texImage2D(r.TEXTURE_2D, 0, a, this.Fx, this.Ex, 0, o.format, o.type, null),
            this.D9i(r),
            r.bindTexture(r.TEXTURE_2D, null),
            this.cn.F9i(),
            this.Byi = 1,
            dT.add(this)
        }
        B9i(t) {
            if ("default" === this.A9i)
                return this._9i ? t.NICEST : t.FASTEST;
            if ("low" === this.A9i)
                return t.FASTEST;
            if ("high" === this.A9i)
                return t.NICEST;
            throw new Error("invalid mipmap quality")
        }
        O9i() {
            return "clamp-to-edge" !== this.lC || "clamp-to-edge" !== this.hC
        }
        U9i(t, i) {
            if (nT.zt(i),
            "clamp-to-edge" === i)
                return t.CLAMP_TO_EDGE;
            if ("repeat" === i)
                return t.REPEAT;
            if ("mirror-repeat" === i)
                return t.MIRRORED_REPEAT;
            throw new Error("invalid wrap mode")
        }
        D9i(t) {
            const i = nT.jei(this.Fx) && nT.jei(this.Ex);
            if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, this.U9i(t, this.lC)),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, this.U9i(t, this.hC)),
            "nearest" === this.T9i)
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST),
                this.G9i = !1;
            else if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR),
            (i || this.cn.gS()) && this.G9i) {
                t.hint(t.GENERATE_MIPMAP_HINT, this.B9i(t)),
                t.generateMipmap(t.TEXTURE_2D);
                const i = "trilinear" === this.T9i && !this.cn.n4i();
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, i ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR_MIPMAP_NEAREST)
            } else
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR),
                this.G9i = !1;
            const e = this.cn.N9i();
            e && this.I9i > 0 && "nearest" !== this.T9i && t.texParameterf(t.TEXTURE_2D, e.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this.I9i, this.cn.j9i()))
        }
        Pbt(t, i) {
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData))
                throw new Error("invalid texture source");
            if (!this.tn || this.Byi <= 0)
                throw new Error("texture not created");
            if (this._9i)
                throw new Error("cannot update static texture");
            nT.kQ(i),
            i = Object.assign({}, cT, i);
            const e = t.width || t.videoWidth
              , s = t.height || t.videoHeight
              , n = this.cn.k9i()
              , r = this.cn.rot();
            r.bindTexture(r.TEXTURE_2D, this.tn),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.E9i),
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !!i.flipY);
            const h = lT(this.P9i, r)
              , o = n >= 2 ? h.S9i : h.x9i;
            try {
                if (this.Fx === e && this.Ex === s) {
                    const i = nT.jei(this.Fx) && nT.jei(this.Ex);
                    r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, h.format, h.type, t),
                    (i || this.cn.gS()) && this.G9i && (r.hint(r.GENERATE_MIPMAP_HINT, this.B9i(r)),
                    r.generateMipmap(r.TEXTURE_2D))
                } else {
                    this.Fx = e,
                    this.Ex = s;
                    const i = nT.jei(this.Fx) && nT.jei(this.Ex);
                    if (!this.cn.gS() && this.O9i() && !i)
                        throw new Error("non-power-of-two tiled textures not supported");
                    r.texImage2D(r.TEXTURE_2D, 0, o, h.format, h.type, t),
                    (i || this.cn.gS()) && this.G9i && (r.hint(r.GENERATE_MIPMAP_HINT, this.B9i(r)),
                    r.generateMipmap(r.TEXTURE_2D))
                }
            } catch (t) {
                console.error("Error updating WebGL texture: ", t)
            }
            r.bindTexture(r.TEXTURE_2D, null),
            this.cn.F9i()
        }
        ZEt() {
            if (this.Byi > 0)
                throw new Error("texture still has references");
            if (!this.tn)
                throw new Error("already deleted texture");
            dT.delete(this);
            this.cn.rot().deleteTexture(this.tn),
            this.tn = null
        }
        KOt() {
            return !!this.tn
        }
        u7i() {
            return this.tn
        }
        Tn() {
            return this.cn
        }
        $9i() {
            this.Byi++
        }
        z9i() {
            if (this.Byi <= 0)
                throw new Error("no more references");
            this.Byi--
        }
        V9i() {
            return this.Byi
        }
        ns() {
            return this.Fx
        }
        er() {
            return this.Ex
        }
        W9i() {
            return this._9i
        }
        WE() {
            let t = this.Fx * this.Ex;
            switch (this.P9i) {
            case "rgba8":
                t *= 4;
                break;
            case "rgb8":
                t *= 3;
                break;
            case "rgba4":
            case "rgb5_a1":
            case "rgb565":
                t *= 2
            }
            return this.G9i && (t += Math.floor(t / 3)),
            t
        }
        static ks() {
            dT.clear()
        }
        static H9i() {
            return dT.values()
        }
    }
}
{
    const fT = self.t
      , pT = self.assert
      , mT = self.r_
      , wT = (mT.l_,
    mT.o_)
      , gT = new Set(["nearest", "bilinear", "trilinear"])
      , yT = {
        Mn: "trilinear",
        alpha: !0,
        fU: !1,
        K9i: !0,
        q9i: !0,
        X9i: 0
    }
      , bT = new Set;
    fT.ea.Y9i = class {
        constructor(t) {
            fT.U(t, fT.ea.yU),
            this.cn = t,
            this.J9i = null,
            this.Z9i = null,
            this.tn = null,
            this.Q9i = null,
            this.Fx = 0,
            this.Ex = 0,
            this.Ewe = !0,
            this.T9i = "trilinear",
            this.Cwe = !0,
            this.Twe = !1,
            this.Pwe = !0,
            this.Gwe = 0,
            this.Rwe = wT.create(),
            this.GM = 0,
            this.OM = 0,
            this.RM = 0
        }
        Jue(t, i, e) {
            fT.Ge(t),
            fT.Ge(i),
            fT.kQ(e),
            e = Object.assign({}, yT, e);
            const s = this.cn.k9i();
            if (this.tn || this.Q9i)
                throw new Error("already created render target");
            if (this.T9i = e.Mn,
            this.Cwe = !!e.alpha,
            this.Twe = !!e.fU,
            this.Pwe = !!e.K9i,
            this.Ewe = !!e.q9i,
            this.Gwe = e.X9i,
            fT.zt(this.T9i),
            !gT.has(this.T9i))
                throw new Error("invalid sampling");
            if (this.Gwe > 0 && (s < 2 || this.Pwe))
                throw new Error("invalid use of multisampling");
            if (s < 2 && (this.Pwe = !0),
            this.Fx = t,
            this.Ex = i,
            this.Fx <= 0 || this.Ex <= 0)
                throw new Error("invalid render target size");
            this.Owe();
            const n = this.cn.rot();
            if (this.J9i = n.createFramebuffer(),
            this.Twe && (this.Z9i = n.createFramebuffer()),
            this.Pwe) {
                this.tn = this.cn.jR(this.Fx, this.Ex, {
                    Mn: this.T9i,
                    M9i: this.Cwe ? "rgba8" : "rgb8",
                    yS: !1
                });
                const t = this.tn.u7i();
                n.bindFramebuffer(n.FRAMEBUFFER, this.J9i),
                n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0),
                this.Twe && (n.bindFramebuffer(n.FRAMEBUFFER, this.Z9i),
                n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0))
            } else {
                this.Q9i = n.createRenderbuffer(),
                n.bindRenderbuffer(n.RENDERBUFFER, this.Q9i);
                const t = this.Cwe ? n.RGBA8 : n.RGB8;
                if (this.Gwe > 0) {
                    const i = n.getInternalformatParameter(n.RENDERBUFFER, t, n.SAMPLES);
                    if (i && i[0]) {
                        const t = i[0];
                        this.Gwe > t && (this.Gwe = t)
                    } else
                        this.Gwe = 0
                }
                0 === this.Gwe ? n.renderbufferStorage(n.RENDERBUFFER, t, this.Fx, this.Ex) : n.renderbufferStorageMultisample(n.RENDERBUFFER, this.Gwe, t, this.Fx, this.Ex),
                n.bindFramebuffer(n.FRAMEBUFFER, this.J9i),
                n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, this.Q9i),
                this.Twe && (n.bindFramebuffer(n.FRAMEBUFFER, this.Z9i),
                n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, this.Q9i)),
                n.bindRenderbuffer(n.RENDERBUFFER, null)
            }
            const r = this.cn.o9i();
            this.Twe && r && (n.bindFramebuffer(n.FRAMEBUFFER, this.J9i),
            this.cn.Dwe() ? n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, r, 0) : n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r)),
            pT(n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE, "WebGLRenderTarget framebuffer is incomplete"),
            n.bindFramebuffer(n.FRAMEBUFFER, null),
            bT.add(this)
        }
        Fwe(t, i) {
            if (this.Fx === t && this.Ex === i)
                return;
            this.Fx = t,
            this.Ex = i,
            this.Owe();
            const e = this.cn.rot();
            e.bindFramebuffer(e.FRAMEBUFFER, this.J9i),
            this.tn ? this.tn.Pbt(new ImageData(this.Fx,this.Ex)) : (e.bindRenderbuffer(e.RENDERBUFFER, this.Q9i),
            e.renderbufferStorage(e.RENDERBUFFER, this.Cwe ? e.RGBA8 : e.RGB8, this.Fx, this.Ex),
            e.bindRenderbuffer(e.RENDERBUFFER, null));
            const s = this.cn.o9i();
            this.Twe && s && (this.cn.Dwe() ? e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0) : e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, s)),
            pT(e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE, "WebGLRenderTarget framebuffer is incomplete"),
            e.bindFramebuffer(e.FRAMEBUFFER, null)
        }
        ZEt() {
            if (!this.tn && !this.Q9i)
                throw new Error("already deleted render target");
            bT.delete(this);
            const t = this.cn.rot();
            this.tn ? (t.bindFramebuffer(t.FRAMEBUFFER, this.J9i),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0),
            this.Twe && (t.bindFramebuffer(t.FRAMEBUFFER, this.Z9i),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)),
            this.cn.mn(this.tn),
            this.tn = null) : this.Q9i && (t.bindFramebuffer(t.FRAMEBUFFER, this.J9i),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null),
            this.Twe && (t.bindFramebuffer(t.FRAMEBUFFER, this.Z9i),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null)),
            t.deleteRenderbuffer(this.Q9i),
            this.Q9i = null),
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            this.cn.k9i() >= 2 && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null)),
            t.deleteFramebuffer(this.J9i),
            this.Twe && t.deleteFramebuffer(this.Z9i);
            const i = this.cn.x6i();
            i.K8i = null,
            i.q8i = null,
            this.J9i = null
        }
        Owe() {
            this.cn.bR(this.Rwe, this.Fx / this.Ex),
            this.GM = this.cn.r3i(),
            this.OM = this.cn.fE(),
            this.RM = this.cn.uE()
        }
        M7i() {
            return this.J9i
        }
        E7i() {
            return this.Z9i
        }
        Tn() {
            return this.cn
        }
        jn() {
            return this.tn
        }
        Lwe() {
            return this.cn.r3i() === this.GM && this.cn.fE() === this.OM && this.cn.uE() === this.RM || this.Owe(),
            this.Rwe
        }
        DU() {
            return "nearest" !== this.T9i
        }
        Bwe() {
            return this.Cwe
        }
        Uwe() {
            return this.Pwe
        }
        Nwe() {
            return this.Twe
        }
        ns() {
            return this.Fx
        }
        er() {
            return this.Ex
        }
        $we() {
            return this.Ewe
        }
        zwe() {
            return this.Gwe
        }
        Wrt() {
            const t = {
                Mn: this.T9i,
                alpha: this.Cwe,
                K9i: this.Pwe
            };
            return this.Ewe || (t.width = this.Fx,
            t.height = this.Ex),
            t
        }
        Vwe(t) {
            return "nearest" !== (t = Object.assign({}, yT, t)).Mn === this.DU() && (!!t.alpha === this.Bwe() && (!!t.fU === this.Nwe() && (!(this.cn.k9i() >= 2 && !!t.K9i !== this.Uwe()) && ("number" == typeof t.width || "number" == typeof t.height ? !this.$we() && this.ns() === Math.floor(t.width) && this.er() === Math.floor(t.height) : this.$we()))))
        }
        Wwe() {
            return this.tn ? this.tn.u7i() : null
        }
        WE() {
            return this.tn ? this.tn.WE() : this.Fx * this.Ex * (this.Cwe ? 4 : 3)
        }
        static async Hwe(t, i) {
            const e = await t.Kwe(i, !0);
            return await fT.oei(e)
        }
        static ks() {
            bT.clear()
        }
        static qwe() {
            return bT.values()
        }
        static Xwe(t, i) {
            for (const e of bT)
                e.$we() && e.Fwe(t, i)
        }
    }
}
{
    const vT = self.t;
    class ST {
        constructor(t) {
            this.W5i = t.rot(),
            this.Wtt = t.k9i(),
            this.Ywe = t.Jwe(),
            this.Zwe = null,
            this.Fc = !1,
            this.Qwe = !1,
            this.tge = 0,
            1 === this.Wtt ? this.Zwe = this.Ywe.createQueryEXT() : this.Zwe = this.W5i.createQuery()
        }
        he() {
            this.ige(),
            this.W5i = null,
            this.Ywe = null,
            this.Qwe = !1
        }
        ige() {
            this.Zwe && (1 === this.Wtt ? this.Ywe.deleteQueryEXT(this.Zwe) : this.W5i.deleteQuery(this.Zwe),
            this.Zwe = null)
        }
        W7i() {
            if (this.Fc)
                throw new Error("query already active");
            1 === this.Wtt ? this.Ywe.beginQueryEXT(this.Ywe.TIME_ELAPSED_EXT, this.Zwe) : this.W5i.beginQuery(this.Ywe.TIME_ELAPSED_EXT, this.Zwe),
            this.Fc = !0
        }
        q7i() {
            if (!this.Fc)
                throw new Error("query not active");
            1 === this.Wtt ? this.Ywe.endQueryEXT(this.Ywe.TIME_ELAPSED_EXT) : this.W5i.endQuery(this.Ywe.TIME_ELAPSED_EXT),
            this.Fc = !1
        }
        ege() {
            if (!this.Zwe || this.Qwe || this.Fc)
                return;
            let t = !1;
            t = 1 === this.Wtt ? this.Ywe.getQueryObjectEXT(this.Zwe, this.Ywe.QUERY_RESULT_AVAILABLE_EXT) : this.W5i.getQueryParameter(this.Zwe, this.W5i.QUERY_RESULT_AVAILABLE);
            const i = this.W5i.getParameter(this.Ywe.GPU_DISJOINT_EXT);
            t && !i && (1 === this.Wtt ? this.tge = this.Ywe.getQueryObjectEXT(this.Zwe, this.Ywe.QUERY_RESULT_EXT) : this.tge = this.W5i.getQueryParameter(this.Zwe, this.W5i.QUERY_RESULT),
            this.tge /= 1e9,
            this.Qwe = !0),
            (t || i) && this.ige()
        }
        sge() {
            return this.Qwe
        }
        nge() {
            if (!this.Qwe)
                throw new Error("no result available");
            return this.tge
        }
    }
    vT.ea.rge = class {
        constructor(t) {
            this.cn = t,
            this.Z2i = t.t4i(),
            this.Fc = !1,
            this.hge = null,
            this.oge = !1,
            this.age = null,
            this.lge = []
        }
        he() {
            for (const t of this.lge)
                t instanceof ST && t.he();
            vT.Io(this.lge),
            this.hge = null,
            this.age = null,
            this.cn = null
        }
        W7i() {
            if (this.Fc)
                throw new Error("query already active");
            const t = this.cn.uge();
            t.length > 0 ? (this.oge = !0,
            this.hge = t.at(-1),
            this.hge.cge(),
            this.hge.lge.push(this)) : (this.oge = !1,
            this.hge = null),
            this.Fc = !0,
            t.push(this),
            this.dge()
        }
        q7i() {
            if (!this.Fc)
                throw new Error("query not active");
            if (this.cn.uge().pop() !== this)
                throw new Error("can only end most nested query");
            this.Fc = !1,
            this.cge(),
            this.hge && (this.hge.dge(),
            this.hge = null)
        }
        dge() {
            this.age = vT.v(ST, this.cn),
            this.lge.push(this.age),
            this.age.W7i()
        }
        cge() {
            this.age.q7i(),
            this.age = null
        }
        ege() {
            for (const t of this.lge)
                t.ege()
        }
        bMi() {
            return this.oge
        }
        sge() {
            return this.lge.every(t => t.sge())
        }
        nge() {
            return this.lge.reduce( (t, i) => t + i.nge(), 0)
        }
        t4i() {
            return this.Z2i
        }
    }
}
{
    const xT = self.t;
    xT.ea.fge = class {
        constructor(t, i=1e3) {
            this.cn = t,
            this.pge = i,
            this.Jgi = [],
            this.cn.mge(this)
        }
        he() {
            this.Ry(),
            this.cn.wge(this),
            this.cn = null
        }
        Ry() {
            for (const t of this.Jgi)
                t.he();
            xT.Io(this.Jgi)
        }
        gge() {
            const t = new xT.ea.rge(this.cn);
            if (this.Jgi.push(t),
            this.Jgi.length > this.pge) {
                this.Jgi.shift().he()
            }
            return t
        }
        yge(t) {
            for (const i of this.Jgi) {
                if (i.t4i() >= t)
                    return;
                if (i.bMi())
                    return;
                i.ege()
            }
        }
        bge(t, i) {
            if (i <= t)
                return NaN;
            let e = 0;
            for (const s of this.Jgi) {
                if (s.t4i() >= i)
                    break;
                if (!(s.t4i() < t)) {
                    if (!s.sge())
                        return NaN;
                    e += s.nge()
                }
            }
            return e
        }
        vge(t) {
            for (let i = 0, e = this.Jgi.length; i < e; ++i) {
                const e = this.Jgi[i];
                if (!(e.t4i() < t))
                    return void (i > 0 && this.Jgi.splice(0, i));
                e.he()
            }
        }
    }
}
{
    const MT = self.t
      , ET = self.assert
      , CT = self.r_
      , _T = (CT.l_,
    CT.L8t)
      , TT = CT.o_
      , IT = {
        powerPreference: "default",
        dU: !0,
        alpha: !1,
        fU: !1,
        uU: !1,
        pU: 2,
        cU: !1
    }
      , PT = new Set(["default", "low-power", "high-performance"])
      , GT = 65535
      , AT = 6 * GT
      , RT = 8e3
      , kT = RT - 4
      , OT = new MT.zn(0,0,1,0,1,1,0,1)
      , DT = TT.create()
      , FT = TT.create()
      , LT = new MT.zn
      , BT = new MT.Rect;
    let UT = null;
    MT.$M && (self.Sge = function() {
        UT ? UT.xge() : (() => {})("WEBGL_lose_context not supported")
    }
    ,
    self.Mge = function() {
        UT ? UT.Ege() : (() => {})("WEBGL_lose_context not supported")
    }
    );
    const NT = new Set;
    let jT = -1;
    function $T() {
        jT = -1;
        for (const t of NT)
            t.Cge() && (t.resolve(),
            NT.delete(t));
        NT.size > 0 && (jT = self.requestAnimationFrame($T))
    }
    MT.ea.yU = class extends MT.ea.wx {
        constructor(t, i) {
            if (super(i),
            i = Object.assign({}, IT, i),
            MT.zt(i.powerPreference),
            !PT.has(i.powerPreference))
                throw new Error("invalid power preference");
            const e = {
                alpha: !!i.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: i.powerPreference,
                failIfMajorPerformanceCaveat: !!i.cU
            };
            let s = null
              , n = 0;
            if (i.pU >= 2 && (s = t.getContext("webgl2", e),
            n = 2),
            s || (s = t.getContext("webgl", e),
            n = 1),
            !s)
                throw new Error("renderer-unavailable (could not get WebGL context)");
            this.W5i = s,
            this._ge = s.getContextAttributes(),
            this.Tge = s.getParameter(s.VERSION),
            this.Wtt = n,
            this.Ige = _T.create(),
            this.Pge = !1,
            this.Gge = TT.create(),
            this.Age = !!i.fU,
            this.Rge = !(!i.fU || !i.uU),
            this.kge = this.Age,
            this.Oge = !1,
            this.Dge = null,
            this.Fge = !0,
            this.Lge = 0,
            this.Bge = 0,
            this.C6i = null,
            this._6i = null,
            this.T6i = null,
            this.Uge = null,
            this.P6i = null,
            this.Nge = this.Wtt >= 2 && void 0 !== globalThis.Float16Array,
            this.jge = new Float32Array(3 * GT),
            this.$ge = new Uint16Array(AT),
            this.zge = new Float32Array(2 * GT),
            this.Vge = this.Nge ? new globalThis.Float16Array(4 * GT) : new Float32Array(4 * GT),
            this.Wge = new Float32Array(4 * RT),
            this.Hge = 0,
            this.Kge = 0,
            this.qge = 0,
            this.Xge = null,
            this.Yge = null,
            this.Jge = [],
            this.Zge = 0,
            this.Qge = 0,
            this.tye = null,
            this.iye = 0,
            this.Z8i = MT.v(MT.ea.H8i, this),
            this.sye = MT.v(MT.za, 1, 1, 1, 1),
            this.nye = null,
            this.F7i = null,
            this.rye = 0,
            this.hye = 0,
            this.oye = new MT.Rect,
            this.aye = MT.v(MT.Rect, 0, 0, -1, -1),
            this.lye = 0,
            this.uye = 0,
            this.cye = 0,
            this.dye = -1,
            this.fye = 0,
            this.pye = 0,
            this.mye = "(unavailable)",
            this.wye = "(unavailable)",
            this.gye = [],
            this.yye = !1,
            this.bye = null,
            this.vye = null,
            this.Sye = null,
            this.xye = null,
            this.Mye = null,
            this.Eye = null,
            this.Cye = null,
            this._ye = 0,
            this.Tye = !!i.dU,
            this.Ywe = null,
            this.Iye = new Set,
            this.Pye = []
        }
        r4i() {
            return !0
        }
        async vU() {
            super.vU();
            const t = this.W5i;
            this.sye.msi(1, 1, 1, 1),
            this.nye = null,
            this.F7i = null,
            this.Hge = 0,
            this.Kge = 0,
            this.qge = 0,
            MT.Io(this.Jge),
            this.Zge = 0,
            this.Qge = 0,
            this.Xge = null,
            this.tye = null,
            this.oye.set(0, 0, 1, 1),
            this.iye = 0;
            const i = this.Z8i;
            i.f8i = null,
            i.K8i = null,
            i.q8i = null,
            i.clearColor.msi(0, 0, 0, 0),
            i.Y8i.set(0, 0, 1, 1),
            t.clearColor(0, 0, 0, 0),
            t.clear(t.COLOR_BUFFER_BIT),
            t.enable(t.BLEND),
            t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA),
            this.rye = t.ONE,
            this.hye = t.ONE_MINUS_SRC_ALPHA,
            this.Gye(t),
            t.cullFace(t.BACK),
            t.disable(t.CULL_FACE),
            this.uye = 0,
            t.frontFace(t.CW),
            this.cye = 0,
            t.disable(t.STENCIL_TEST),
            t.disable(t.DITHER),
            this.Age ? (t.enable(t.DEPTH_TEST),
            t.depthMask(!0),
            t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST),
            t.depthMask(!1)),
            this.kge = this.Age,
            this.Oge = !1,
            this.P6i = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this.P6i),
            t.bufferData(t.ARRAY_BUFFER, this.Wge.byteLength, t.DYNAMIC_DRAW),
            this.C6i = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this.C6i),
            t.bufferData(t.ARRAY_BUFFER, this.jge.byteLength, t.DYNAMIC_DRAW),
            this._6i = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this._6i),
            t.bufferData(t.ARRAY_BUFFER, this.zge.byteLength, t.DYNAMIC_DRAW),
            this.T6i = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this.T6i),
            t.bufferData(t.ARRAY_BUFFER, this.Vge.byteLength, t.DYNAMIC_DRAW),
            this.Uge = t.createBuffer(),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.Uge),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.$ge.byteLength, t.DYNAMIC_DRAW),
            t.activeTexture(t.TEXTURE0),
            t.bindTexture(t.TEXTURE_2D, null),
            this.dye = t.getParameter(t.MAX_TEXTURE_SIZE);
            const e = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);
            this.fye = e[0],
            this.pye = e[1],
            this.pye > 2048 && (this.pye = 2048),
            this.gye = t.getSupportedExtensions();
            const s = t.getExtension("WEBGL_debug_renderer_info");
            if (s && (this.mye = t.getParameter(s.UNMASKED_VENDOR_WEBGL),
            this.wye = t.getParameter(s.UNMASKED_RENDERER_WEBGL)),
            this.bye = t.getExtension("KHR_parallel_shader_compile"),
            this.Wtt >= 2 && ("Chromium" !== MT.kt._9t || MT.kt.C9t >= 135) && (this.Sye = t.getExtension("EXT_conservative_depth")),
            MT.$M && (UT = t.getExtension("WEBGL_lose_context")),
            this.Tye && (1 === this.k9i() ? this.Ywe = t.getExtension("EXT_disjoint_timer_query") : this.Ywe = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")),
            this.vye = t.getExtension("EXT_texture_filter_anisotropic"),
            this.vye ? this._ye = t.getParameter(this.vye.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : this._ye = 0,
            this.k9i() < 2 && this.Age && this.Rge && (this.xye = t.getExtension("WEBGL_depth_texture"),
            !this.xye))
                throw new Error("no depth texture support");
            this.k9i() < 2 && (this.Mye = t.getExtension("EXT_frag_depth"),
            this.Eye = t.getExtension("OES_standard_derivatives"),
            this.Cye = t.getExtension("EXT_shader_texture_lod"));
            const n = MT.ea.g6i
              , r = n.E8i(!1);
            let h = n._8i()
              , o = r
              , a = n.D8i()
              , l = n.k8i()
              , u = n.P8i()
              , c = n.E8i(!0)
              , d = !1;
            this.Age && (this.k9i() < 2 ? this.Mye && (h = n.T8i(),
            a = n.F8i(),
            u = n.G8i(),
            d = !0) : (o = n.C8i(),
            h = n.I8i(this.Aye()),
            a = n.L8i(this.Aye()),
            l = n.O8i(),
            u = n.A8i(this.Aye()),
            c = n.C8i(!0)));
            const f = n.R8i(this.k9i(), d, this.Eye && this.Cye, this.Aye())
              , p = this.k9i() >= 2 ? n.C8i() : r
              , m = [[h, o, "<default>"], [h, o, "<default-device-transform>"], [a, l, "<point>"], [n.B8i(), r, "<fill>"], [n.U8i(), r, "<lineargradient>"], [n.N8i(), r, "<penumbra>"], [n.$8i(), r, "<hardellipse>"], [n.z8i(), r, "<hardellipseoutline>"], [n.V8i(), r, "<smoothellipse>"], [n.W8i(), r, "<smoothellipseoutline>"], [n.j8i(), r, "<smoothline>"], [u, c, "<tilemap>"], [f, p, "<tilerandomization>"]]
              , w = await Promise.all(m.map(t => this.Rye({
                src: t[0],
                b6i: t[1],
                name: t[2]
            })));
            this.P2i = w[0],
            this.Yge = w[1],
            this.G2i = w[2],
            this.k2i = w[3],
            this.O2i = w[4],
            this.D2i = w[5],
            this.F2i = w[6],
            this.L2i = w[7],
            this.B2i = w[8],
            this.U2i = w[9],
            this.N2i = w[10],
            this.A2i = w[11],
            this.R2i = w[12],
            this.Wr()
        }
        async Rye(t) {
            const i = await MT.ea.g6i.hP(this, t);
            return this.l3i(i),
            i
        }
        kye() {
            this.Xge = null
        }
        zr(t, i, e) {
            if (this.Fx === t && this.Ex === i && !e)
                return;
            this.Q3i();
            const s = this.W5i
              , n = this.Z8i;
            this.Fx = t,
            this.Ex = i,
            this.Oye(0, 0, t, i),
            this.bR(this.Gge, t / i),
            this.eR(this.Gge),
            this.Yge && (s.useProgram(this.Yge.X5i()),
            this.Yge.a8i(this.x2i),
            this.Xge = this.Yge,
            this.Z8i.f8i = this.Yge),
            s.bindTexture(s.TEXTURE_2D, null),
            s.activeTexture(s.TEXTURE1),
            s.bindTexture(s.TEXTURE_2D, null),
            s.activeTexture(s.TEXTURE0),
            this.nye = null,
            this.F7i = null,
            this.Age && this.Fge && this.Dye(this.Fx, this.Ex),
            this.tye && this.tye.Fwe(this.Fx, this.Ex),
            s.bindFramebuffer(s.FRAMEBUFFER, null),
            this.tye = null,
            n.K8i = null,
            n.q8i = null
        }
        Dye(t, i) {
            const e = this.W5i;
            this.Dge && this.Lge === t && this.Bge === i || (this.Rge ? (this.Dge && e.deleteTexture(this.Dge),
            this.Dge = e.createTexture(),
            e.bindTexture(e.TEXTURE_2D, this.Dge),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            this.k9i() >= 2 ? e.texImage2D(e.TEXTURE_2D, 0, e.DEPTH24_STENCIL8, t, i, 0, e.DEPTH_STENCIL, e.UNSIGNED_INT_24_8, null) : this.xye ? e.texImage2D(e.TEXTURE_2D, 0, e.DEPTH_STENCIL, t, i, 0, e.DEPTH_STENCIL, this.xye.UNSIGNED_INT_24_8_WEBGL, null) : ET(!1, "no depth texture support"),
            e.bindTexture(e.TEXTURE_2D, null)) : (this.Dge && e.deleteRenderbuffer(this.Dge),
            this.Dge = e.createRenderbuffer(),
            e.bindRenderbuffer(e.RENDERBUFFER, this.Dge),
            e.renderbufferStorage(e.RENDERBUFFER, this.Wtt >= 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL, t, i),
            e.bindRenderbuffer(e.RENDERBUFFER, null)),
            this.Lge = t,
            this.Bge = i)
        }
        Fye(t, i) {
            this.Age && (this.Fge = !1,
            this.Dye(t, i))
        }
        Lye() {
            this.Age && (this.Fge = !0,
            this.Dye(this.Fx, this.Ex))
        }
        Oye(t, i, e, s) {
            const n = this.Ige;
            if (n[0] === t && n[1] === i && n[2] === e && n[3] === s)
                return;
            this.Bye().m7i(t, i, e, s),
            _T.set(n, t, i, e, s),
            this.Qge = 0
        }
        uR(t) {
            super.uR(t),
            this.bR(this.Gge, this.Fx / this.Ex)
        }
        _R(t) {
            super._R(t),
            this.bR(this.Gge, this.Fx / this.Ex)
        }
        SR(t) {
            super.SR(t),
            this.bR(this.Gge, this.Fx / this.Ex)
        }
        eR(t) {
            if (TT.w6t(this.x2i, t))
                return;
            this.Bye().g7i(t),
            TT.Qr(this.x2i, t),
            this.Qge = 0,
            this.Pge = !0
        }
        Uye() {
            let t, i, e;
            const s = this.tye;
            null === s ? (t = this.Gge,
            i = this.ns(),
            e = this.er()) : (t = s.Lwe(),
            i = s.ns(),
            e = s.er()),
            this.eR(t),
            this.Oye(0, 0, i, e)
        }
        rR(t) {
            if (TT.w6t(this.M2i, t))
                return;
            this.Bye().b7i(t),
            TT.Qr(this.M2i, t),
            this.Qge = 0,
            this.Pge = !0
        }
        Nye() {
            this.Pge = !1
        }
        jye() {
            return this.Pge
        }
        x6i() {
            return this.Z8i
        }
        Bye() {
            const t = this.Jge;
            return this.Zge === t.length && t.push(new MT.ea.J8i(this.Z8i)),
            t[this.Zge++]
        }
        Q3i() {
            0 !== this.Zge && (this.fn() || (this.$ye(),
            this.zye(),
            this.Zge = 0,
            this.Hge = 0,
            this.Kge = 0,
            this.qge = 0,
            this.Qge = 0))
        }
        $ye() {
            const t = this.W5i;
            this.Hge > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this.C6i),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.jge.subarray(0, 3 * this.Hge)),
            t.bindBuffer(t.ARRAY_BUFFER, this._6i),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.zge.subarray(0, 2 * this.Hge)),
            t.bindBuffer(t.ARRAY_BUFFER, this.T6i),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.Vge.subarray(0, 4 * this.Hge))),
            this.Kge > 0 && (t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.Uge),
            t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, this.$ge.subarray(0, this.Kge))),
            this.qge > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this.P6i),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.Wge.subarray(0, this.qge)))
        }
        zye() {
            const t = this.Jge;
            for (let i = 0, e = this.Zge; i < e; ++i)
                t[i].v9i()
        }
        wh() {
            return this.sye.Ix()
        }
        rr(t, i, e, s) {
            const n = this.sye;
            n.Isi(t, i, e, s) || (n.msi(t, i, e, s),
            this.$2i = null,
            2 === this.Qge && (this.Qge = 0))
        }
        Uo(t) {
            const i = this.sye;
            i.Ix() !== t && (i.vx(t),
            this.$2i = null,
            2 === this.Qge && (this.Qge = 0))
        }
        Jn(t) {
            const i = this.sye;
            i.equals(t) || (i.set(t),
            this.$2i = null,
            2 === this.Qge && (this.Qge = 0))
        }
        Nr() {
            this.rr(1, 1, 1, 1)
        }
        qn() {
            return this.sye
        }
        hr(t) {
            if (t === this.nye)
                return;
            ET(!t || !this.tye || t !== this.tye.jn(), "setting texture to current render texture");
            this.Bye().a7i(t),
            this.nye = t,
            this.Qge = 0
        }
        F9i() {
            this.nye = null
        }
        mb(t) {
            const i = this.C3i(t);
            this.Vye(i[0], i[1])
        }
        Wye(t) {
            const i = this.I3i(t);
            this.Vye(i.M3i, i.E3i)
        }
        Vye(t, i) {
            if (t === this.rye && i === this.hye)
                return;
            this.Bye().f7i(t, i),
            this.rye = t,
            this.hye = i,
            this.Qge = 0,
            this.$2i = null
        }
        Hye() {
            return this.rye === this.W5i.ONE && this.hye === this.W5i.ONE_MINUS_SRC_ALPHA
        }
        sr() {
            this.Vye(this.W5i.ONE, this.W5i.ONE_MINUS_SRC_ALPHA)
        }
        Kye() {
            this.Vye(this.W5i.SRC_ALPHA, this.W5i.ONE_MINUS_SRC_ALPHA)
        }
        hm(t) {
            if (this.uye === t)
                return;
            this.Bye().w9i(t),
            this.uye = t,
            this.Qge = 0,
            this.$2i = null
        }
        qye() {
            return this.uye
        }
        om(t) {
            if (this.cye === t)
                return;
            this.Bye().y9i(t),
            this.cye = t,
            this.Qge = 0,
            this.$2i = null
        }
        Xye() {
            return this.cye
        }
        Yye() {
            this.Vye(this.W5i.ONE, this.W5i.ZERO)
        }
        Rect(t) {
            this.RY(t.Yr(), t.Jr(), t.pl(), t.dl())
        }
        RY(t, i, e, s) {
            this.Z3i(t, i, e, i, e, s, t, s)
        }
        Jye(t, i) {
            if ((this.Hge + t > GT || this.Kge + i > AT) && this.Q3i(),
            1 === this.Qge)
                this.Jge[this.Zge - 1].t7i += i;
            else {
                this.Bye().h7i(2 * this.Kge, i),
                this.Qge = 1
            }
        }
        Zye() {
            const t = this.Hge;
            let i = this.Kge;
            this.Kge += 6;
            const e = this.$ge;
            e[i++] = t,
            e[i++] = t + 1,
            e[i++] = t + 2,
            e[i++] = t,
            e[i++] = t + 2,
            e[i] = t + 3
        }
        zn(t) {
            this.Dl(t, OT)
        }
        Z3i(t, i, e, s, n, r, h, o) {
            this.Jye(4, 6),
            this.Zye();
            const a = this.jge
              , l = this.Hge;
            this.Hge += 4;
            let u = 3 * l;
            const c = this.W2i + this.H2i;
            a[u++] = t,
            a[u++] = i,
            a[u++] = c,
            a[u++] = e,
            a[u++] = s,
            a[u++] = c,
            a[u++] = n,
            a[u++] = r,
            a[u++] = c,
            a[u++] = h,
            a[u++] = o,
            a[u] = c,
            OT.usi(this.zge, 2 * l),
            this.sye.Csi(this.Vge, 4 * l)
        }
        ur(t, i) {
            this.Jye(4, 6),
            this.Zye();
            const e = this.Hge;
            this.Hge += 4,
            t.Uni(this.jge, 3 * e, this.W2i + this.H2i),
            i.lni(this.zge, 2 * e),
            this.sye.Csi(this.Vge, 4 * e)
        }
        Dl(t, i) {
            this.Jye(4, 6),
            this.Zye();
            const e = this.Hge;
            this.Hge += 4,
            t.Uni(this.jge, 3 * e, this.W2i + this.H2i),
            i.usi(this.zge, 2 * e),
            this.sye.Csi(this.Vge, 4 * e)
        }
        Qye(t, i, e) {
            this.Jye(4, 6),
            this.Zye();
            const s = this.Hge;
            this.Hge += 4,
            t.Uni(this.jge, 3 * s, this.W2i + this.H2i),
            i.usi(this.zge, 2 * s),
            this.Vge.set(e, 4 * s)
        }
        Sm(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.Jye(4, 6),
            this.Zye();
            const f = this.jge
              , p = this.Hge;
            this.Hge += 4;
            let m = 3 * p;
            const w = this.W2i + this.H2i;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.lni(this.zge, 2 * p),
            this.sye.Csi(this.Vge, 4 * p)
        }
        Vm(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.Jye(4, 6),
            this.Zye();
            const f = this.jge
              , p = this.Hge;
            this.Hge += 4;
            let m = 3 * p;
            const w = this.W2i + this.H2i;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.usi(this.zge, 2 * p),
            this.sye.Csi(this.Vge, 4 * p)
        }
        tbe(t, i, e, s, n, r, h, o, a, l, u, c, d, f) {
            this.Jye(4, 6),
            this.Zye();
            const p = this.jge
              , m = this.Hge;
            this.Hge += 4;
            let w = 3 * m;
            const g = this.W2i + this.H2i;
            p[w++] = t,
            p[w++] = i,
            p[w++] = g + e,
            p[w++] = s,
            p[w++] = n,
            p[w++] = g + r,
            p[w++] = h,
            p[w++] = o,
            p[w++] = g + a,
            p[w++] = l,
            p[w++] = u,
            p[w] = g + c,
            d.usi(this.zge, 2 * m),
            this.Vge.set(f, 4 * m)
        }
        a2i(t, i, e, s) {
            if (t.length % 3 != 0)
                throw new Error("vertex buffer length not multiple of 3");
            if (t.length > 3 * GT)
                throw new Error(`too many vertices (${t.length / 3}, limit ${GT})`);
            if (e.length % 3 != 0)
                throw new Error("index buffer length not multiple of 3");
            if (e.length > AT)
                throw new Error(`too many indices (${e.length}, limit ${AT})`);
            this.Jye(t.length, e.length);
            const n = this.Hge;
            this.jge.set(t, 3 * n),
            this.zge.set(i, 2 * n);
            const r = this.$ge;
            if (0 === n)
                r.set(e, this.Kge);
            else {
                let t = this.Kge;
                for (let i = 0, s = e.length; i < s; ++i)
                    r[t++] = e[i] + n
            }
            const h = this.Vge;
            if (void 0 !== s)
                h.set(s, 4 * n);
            else {
                const i = this.sye
                  , e = i.xsi()
                  , s = i.Msi()
                  , r = i.Esi()
                  , o = i.Ix();
                let a = 4 * n;
                for (let i = 0, n = t.length; i < n; ++i)
                    h[a++] = e,
                    h[a++] = s,
                    h[a++] = r,
                    h[a++] = o
            }
            this.Hge += t.length / 3,
            this.Kge += e.length
        }
        ibe(t, i) {
            this.JR(0),
            TT.Qr(DT, this.x2i),
            TT.Qr(FT, this.M2i),
            this.Uye();
            const [e,s] = this.ebe(this.tye)
              , n = this.nR(0, 0, this.ga(s), 0, 0, 0, s);
            if (this.rR(n),
            "crop" === t && this.tye && i) {
                const t = this.Fx / 2
                  , e = this.Ex / 2
                  , s = i.ns()
                  , n = i.er()
                  , r = this.tye.ns()
                  , h = this.tye.er()
                  , o = Math.min(r, s)
                  , a = Math.min(h, n)
                  , l = Math.max(n - h, 0)
                  , u = Math.max(h - n, 0);
                BT.set(-t, e - u, -t + o, e - a - u),
                LT.Zr(BT),
                BT.set(0, l, o, a + l),
                BT.xm(s, n),
                this.ur(LT, BT)
            } else {
                const t = e / 2
                  , i = s / 2;
                this.RY(-t, i, t, -i)
            }
            this.eR(DT),
            this.rR(FT)
        }
        sc(t) {
            if (this.oye.equals(t))
                return;
            this.oye.Qr(t);
            this.Bye().I7i(t),
            this.Qge = 0
        }
        rc() {}
        ou(t, i, e, s) {
            this.qge >= kT && this.Q3i();
            let n = this.qge;
            const r = this.W2i + this.H2i;
            if (2 === this.Qge && this.iye === r)
                this.Jge[this.Zge - 1].t7i++;
            else {
                this.Bye().G7i(n, r, this.sye),
                this.Qge = 2,
                this.iye = r
            }
            const h = this.Wge;
            h[n++] = t,
            h[n++] = i,
            h[n++] = e,
            h[n++] = s,
            this.qge = n
        }
        dm(t) {
            if (this.Xge === t)
                return;
            this.Bye().R7i(t),
            this.Xge = t,
            this.Qge = 0,
            this.$2i = null
        }
        pm() {
            return this.Xge
        }
        sbe() {
            this.dm(this.Yge)
        }
        nbe(t) {
            this.Bye().c7i(t),
            this.Qge = 0
        }
        rbe(t, i, e=1) {
            this.Bye().X7i(t, i, e),
            this.Qge = 0
        }
        SI(t, i, e, s, n, r, h) {
            if (this.Xge !== this.A2i)
                throw new Error("must set tilemap fill mode first");
            this.Bye().J7i(t, i, e, s, n, r, h),
            this.Qge = 0
        }
        gC(t, i, e, s, n, r, h) {
            if (this.Xge !== this.R2i)
                throw new Error("must set tile randomization mode first");
            this.Bye().Q7i(t, i, e, s, n, r, h),
            this.Qge = 0
        }
        hbe(t, i, e, s, n, r, h, o, a, l, u) {
            const c = this.Xge;
            if (u %= 10800,
            !c.n8i || c.g8i(i, e, s, n, r, h, o, a, l, u))
                return;
            const d = this.Bye();
            d.O7i(),
            c.y8i(i, e, s, n, r, h, o, a, l, u);
            const f = d.e7i;
            f[0] = r,
            f[1] = h,
            i.usi(f, 2),
            f[6] = a,
            f[7] = l,
            e.usi(f, 12);
            const p = d.s7i;
            n.usi(p, 0);
            const m = p[1];
            p[1] = p[3],
            p[3] = m,
            s.usi(d.n7i, 0),
            d.Q8i = u,
            d.t7i = o,
            c.j6i.Z5i() ? (ET(!t || !this.tye || t !== this.tye, "Warning: setting texture1 to current render texture"),
            d.i7i = t ? t.jn() : null) : d.i7i = null,
            this.Qge = 0
        }
        obe(t) {
            const i = this.Xge;
            if (0 === t.length || i.m8i(t))
                return;
            const e = this.Bye();
            e.L7i(),
            i.w8i(t),
            MT.mf(e.r7i, t),
            this.Qge = 0
        }
        abe(t, i, e, s) {
            this.Bye()._7i(t, i, e, s),
            this.Qge = 0
        }
        Ry(t) {
            this.Bye().C7i(t),
            this.Qge = 0
        }
        ke() {}
        FR() {
            super.FR(),
            this.W5i.flush()
        }
        lbe() {
            if (!this.Age || !this.tye || !this.tye.Nwe())
                return;
            this.Bye().i9i(this.kge),
            this.Qge = 0
        }
        kR(t) {
            if (t = !!t,
            this.kge === t)
                return;
            if (!this.Age)
                return;
            this.kge = t;
            this.Bye().s9i(t),
            this.Qge = 0
        }
        ube() {
            return this.kge
        }
        o9i() {
            return this.Dge
        }
        Dwe() {
            return this.Rge
        }
        cbe(t) {
            if (t = !!t,
            !this.Rge)
                return;
            if (this.Oge === t)
                return;
            if (t && this.ube())
                throw new Error("depth still enabled");
            this.Oge = t;
            this.Bye().r9i(t),
            this.Qge = 0
        }
        dbe(t, i, e, s, n=0) {
            if (t = Math.floor(t),
            i = Math.floor(i),
            e = Math.floor(e),
            s = Math.floor(s),
            this.aye.hni(t, i, e, s))
                return;
            this.aye.Cu(t, i, e, s);
            i = (n || this.ebe(this.fbe())[1]) - i - s;
            this.Bye().p9i(!0, t, i, e, s),
            this.Qge = 0
        }
        pbe() {
            if (-1 === this.aye.pl())
                return;
            this.aye.set(0, 0, -1, -1);
            this.Bye().p9i(!1, 0, 0, 0, 0),
            this.Qge = 0
        }
        mbe() {
            for (const t of this.Iye)
                t.yge(this.Z2i)
        }
        fn() {
            return !this.W5i || this.W5i.isContextLost() || this.yye
        }
        ks() {
            super.e3i(),
            MT.ea.C9i.ks(),
            MT.ea.Y9i.ks(),
            MT.ea.ta.ks();
            for (const t of this.Iye)
                t.Ry();
            this.gye = [],
            this.Ywe = null,
            this.bye = null,
            this.Sye = null,
            this.vye = null,
            this.xye = null,
            this.Mye = null,
            this.Eye = null,
            this.Cye = null,
            this._ye = 0,
            this.mye = "(unavailable)",
            this.wye = "(unavailable)",
            this.Xge = null,
            this.Yge = null,
            this.Dge = null;
            for (const t of this.j2i.values())
                t.ks()
        }
        async MS() {
            this.yye = !0,
            await this.vU(),
            this.yye = !1;
            for (const t of this.j2i.values())
                t.MS(this);
            this.zr(this.Fx, this.Ex, !0)
        }
        Pn(t, i) {
            if (this.fn())
                throw new Error("context lost");
            this.Q3i();
            const e = MT.v(MT.ea.C9i, this);
            return e.R9i(t, i),
            e
        }
        async In(t, i) {
            if (this.fn())
                throw new Error("context lost");
            if (i = Object.assign({}, i),
            MT.QL.O9t) {
                let e = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply"
                });
                const s = i.kn && "clamp-to-edge" !== i.kn || i.Rn && "clamp-to-edge" !== i.Rn
                  , n = MT.jei(e.width) && MT.jei(e.height);
                return this.gS() || n || !s ? i.E9i = !1 : MT.QL.D9t ? (e = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply",
                    resizeWidth: MT.na(e.width),
                    resizeHeight: MT.na(e.height)
                }),
                i.E9i = !1) : e = await createImageBitmap(t, {
                    premultiplyAlpha: "none"
                }),
                await MT.lre( () => this.Pn(e, i))
            }
            if (t instanceof Blob) {
                if ("undefined" == typeof Image)
                    throw new Error("texture upload variant not supported in worker");
                const i = await MT.bS(t);
                t = i
            }
            return await MT.lre( () => this.Pn(t, i))
        }
        jR(t, i, e) {
            this.Q3i();
            const s = MT.v(MT.ea.C9i, this);
            return s.L9i(t, i, e),
            s
        }
        XR(t, i, e) {
            this.Q3i(),
            i.Pbt(t, e)
        }
        mn(t) {
            t && (t.z9i(),
            t.V9i() > 0 || (this.Q3i(),
            t === this.nye && (this.W5i.bindTexture(this.W5i.TEXTURE_2D, null),
            this.nye = null),
            t === this.F7i && (this.W5i.activeTexture(this.W5i.TEXTURE1),
            this.W5i.bindTexture(this.W5i.TEXTURE_2D, null),
            this.W5i.activeTexture(this.W5i.TEXTURE0),
            this.F7i = null),
            t.ZEt()))
        }
        TU(t) {
            MT.kQ(t);
            let i = this.Fx
              , e = this.Ex
              , s = !0;
            if (t && ("number" == typeof t.width && (i = Math.floor(t.width),
            s = !1),
            "number" == typeof t.height && (e = Math.floor(t.height),
            s = !1)),
            i <= 0 || e <= 0)
                throw new Error("invalid size");
            this.Q3i();
            const n = MT.v(MT.ea.Y9i, this);
            return n.Jue(i, e, Object.assign({
                q9i: s
            }, t)),
            this.tye = null,
            this.Z8i.K8i = null,
            this.Z8i.q8i = null,
            n
        }
        AR(t, i=!0) {
            if (t === this.tye)
                return;
            t && t.$we() && t.Fwe(this.Fx, this.Ex);
            this.Bye().S7i(t),
            this.tye = t,
            this.Qge = 0,
            i && this.Uye()
        }
        fbe() {
            return this.tye
        }
        ebe(t) {
            return t ? [t.ns(), t.er()] : [this.Fx, this.Ex]
        }
        wbe(t, i="stretch") {
            if (ET(t !== this.tye, "copying render target to itself"),
            this.Wtt < 2 || this.tye && this.tye.zwe() > 0)
                this.Yye(),
                this.Nr(),
                this.gbe(t, i);
            else {
                this.Bye().j7i(t, this.tye, i),
                this.Qge = 0
            }
        }
        gbe(t, i="stretch") {
            ET(t !== this.tye, "drawing render target to itself");
            const e = t.jn();
            if (!e)
                throw new Error("not a texture-backed render target");
            this.hr(e),
            this.ibe(i, e)
        }
        ybe(t) {
            if (this.Wtt < 2)
                return;
            this.Bye().U7i(t.M7i()),
            this.Qge = 0
        }
        bbe(t) {
            this.AR(null),
            this.Q3i();
            const i = t.jn();
            i === this.nye && (this.W5i.bindTexture(this.W5i.TEXTURE_2D, null),
            this.nye = null),
            i === this.F7i && (this.W5i.activeTexture(this.W5i.TEXTURE1),
            this.W5i.bindTexture(this.W5i.TEXTURE_2D, null),
            this.W5i.activeTexture(this.W5i.TEXTURE0),
            this.F7i = null),
            t.ZEt()
        }
        async Kwe(t, i, e) {
            this.Q3i();
            const s = this.tye;
            let n, r, h;
            t ? (n = t.ns(),
            r = t.er(),
            h = t.M7i()) : (n = this.ns(),
            r = this.er(),
            h = null);
            let o = 0
              , a = 0
              , l = n
              , u = r;
            if (e) {
                o = MT.Ne(Math.floor(e.Yr()), 0, n - 1),
                a = MT.Ne(Math.floor(e.Jr()), 0, r - 1);
                let t = e.width();
                t = 0 === t ? n - o : MT.Ne(Math.floor(t), 0, n - o);
                let i = e.height();
                i = 0 === i ? r - a : MT.Ne(Math.floor(i), 0, r - a),
                l = t,
                u = i,
                a = r - (a + u)
            }
            const c = this.W5i;
            c.bindFramebuffer(c.FRAMEBUFFER, h);
            const d = () => {
                c.bindFramebuffer(c.FRAMEBUFFER, null),
                this.tye = null,
                this.Z8i.K8i = null,
                this.Z8i.q8i = null,
                this.AR(s)
            }
            ;
            let f;
            if (!i && this.k9i() >= 2) {
                c.bindFramebuffer(c.READ_FRAMEBUFFER, h);
                const t = c.createBuffer()
                  , i = l * u * 4
                  , e = c.PIXEL_PACK_BUFFER;
                c.bindBuffer(e, t),
                c.bufferData(e, i, c.STREAM_READ),
                c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, 0),
                c.bindFramebuffer(c.READ_FRAMEBUFFER, null),
                c.bindBuffer(e, null),
                d();
                const s = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this.S6i( () => c.getSyncParameter(s, c.SYNC_STATUS) === c.SIGNALED),
                c.deleteSync(s),
                f = new ImageData(l,u),
                c.bindBuffer(e, t),
                c.getBufferSubData(e, 0, new Uint8Array(f.data.buffer), 0, i),
                c.bindBuffer(e, null),
                c.deleteBuffer(t)
            } else
                f = new ImageData(l,u),
                c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, new Uint8Array(f.data.buffer)),
                d();
            return f
        }
        vbe() {
            this.kR(!0);
            this.Bye().a9i(),
            this.Qge = 0,
            this.lye = 1
        }
        Sbe() {
            this.kR(!1);
            this.Bye().u9i(),
            this.Qge = 0,
            this.lye = 2
        }
        xbe() {
            return 2 === this.lye
        }
        Mbe() {
            this.kR(!0);
            this.Bye().d9i(),
            this.Qge = 0,
            this.lye = 0
        }
        Ebe(t) {
            if (!this.Cbe())
                return;
            this.Bye().z7i(t),
            this.Qge = 0
        }
        _be(t) {
            if (!this.Cbe())
                return;
            this.Bye().H7i(t),
            this.Qge = 0
        }
        S6i(t) {
            const i = new Promise(i => NT.add({
                resolve: i,
                Cge: t
            }));
            return -1 === jT && (jT = self.requestAnimationFrame($T)),
            i
        }
        h4i() {
            return this.Fx * this.Ex * (this._ge.alpha ? 4 : 3)
        }
        o4i() {
            let t = 0;
            for (const i of MT.ea.Y9i.qwe())
                i.jn() || (t += i.WE());
            return t
        }
        a4i() {
            let t = 0;
            for (const i of MT.ea.C9i.H9i())
                t += i.WE();
            return t
        }
        Tbe() {
            return this.Tge
        }
        k9i() {
            return this.Wtt
        }
        I6i() {
            return this.Nge
        }
        NBt() {
            return "webgl" + this.k9i()
        }
        gS() {
            return this.k9i() >= 2
        }
        T5i() {
            return this.dye
        }
        uu() {
            return this.fye
        }
        cu() {
            return this.pye
        }
        Ibe() {
            return this.mye
        }
        Pbe() {
            return this.wye
        }
        Gbe() {
            if (this.k9i() >= 2)
                return "webgl2";
            {
                const t = [];
                return this.Mye && t.push("EXT_frag_depth"),
                this.Eye && t.push("OES_standard_derivatives"),
                this.Cye && t.push("EXT_shader_texture_lod"),
                t.length > 0 ? "webgl1:" + t.join(",") : "webgl1:none"
            }
        }
        Abe() {
            return this.gye
        }
        Cbe() {
            return !!this.Ywe
        }
        Jwe() {
            return this.Ywe
        }
        v6i() {
            return this.bye
        }
        Aye() {
            return !!this.Sye
        }
        N9i() {
            return this.vye
        }
        j9i() {
            return this._ye
        }
        mge(t) {
            this.Iye.add(t)
        }
        wge(t) {
            this.Iye.delete(t)
        }
        uge() {
            return this.Pye
        }
        rot() {
            return this.W5i
        }
        Gye(t) {
            this.x3i([["normal", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["additive", t.ONE, t.ONE], ["xor", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["copy", t.ONE, t.ZERO], ["destination-over", t.ONE_MINUS_DST_ALPHA, t.ONE], ["source-in", t.DST_ALPHA, t.ZERO], ["destination-in", t.ZERO, t.SRC_ALPHA], ["source-out", t.ONE_MINUS_DST_ALPHA, t.ZERO], ["destination-out", t.ZERO, t.ONE_MINUS_SRC_ALPHA], ["source-atop", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], ["destination-atop", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]])
        }
        Rbe() {
            return this.u4i()
        }
    }
}
{
    const zT = self.t
      , VT = self.r_
      , WT = (VT.l_,
    VT.o_)
      , HT = self.assert
      , KT = self.GPUBufferUsage
      , qT = self.GPUShaderStage
      , XT = (self.GPUMapMode,
    self.GPUTextureUsage)
      , YT = {
        powerPreference: "default",
        fU: !1,
        cU: !1,
        kbe: !1,
        Obe: !1,
        uU: !1,
        Dbe: !0
    }
      , JT = 65535
      , ZT = 6 * JT
      , QT = Math.floor(JT / 4)
      , tI = JT
      , iI = 4 * QT - 16
      , eI = 1
      , sI = 2
      , nI = 4
      , rI = 8
      , hI = 16
      , oI = 32
      , aI = 64
      , lI = 128
      , uI = 256
      , cI = 512
      , dI = 1024
      , fI = 2048
      , pI = 4096
      , mI = 8192
      , wI = 16384
      , gI = 32768
      , yI = 65536
      , bI = 1 << 17
      , vI = 1 << 18
      , SI = 1 << 19
      , xI = 1 << 20
      , MI = 1 << 21
      , EI = 1 << 22
      , CI = 1 << 23
      , _I = 1 << 24
      , TI = 1 << 25
      , II = 1 << 26
      , PI = 1 << 27
      , GI = 1 << 28
      , AI = 1 << 29
      , RI = 1 << 30
      , kI = 1
      , OI = hI | oI | mI | aI | lI | uI
      , DI = OI | rI | eI
      , FI = OI | wI
      , LI = cI | dI | fI | pI
      , BI = 2
      , UI = 4
      , NI = 2
      , jI = 4
      , $I = new zT.zn(0,0,1,0,1,1,0,1)
      , zI = zT.v(zT.uX)
      , VI = zT.v(zT.Rect)
      , WI = (zT.v(zT.Rect),
    zT.v(zT.zn));
    zT.ea.wU = class extends zT.ea.wx {
        constructor(t) {
            super(t),
            this.Fbe = null,
            this.Lbe = null,
            this.Bbe = null,
            this.Ube = null,
            this.q_ = null,
            this.Nbe = null,
            this.jbe = "",
            this.$be = null,
            this.zbe = null,
            this.Vbe = 0,
            this.Wbe = 0,
            this.Hbe = WT.create(),
            this.Dge = null,
            this.Kbe = null,
            this.qbe = null,
            this.Xbe = null,
            this.Ybe = null,
            this.Jbe = null,
            this.Lge = 0,
            this.Bge = 0,
            this.Zbe = null,
            this.Qbe = null,
            this.tve = null,
            this.ive = null,
            this.C6i = null,
            this._6i = null,
            this.eve = null,
            this.T6i = null,
            this.Uge = null,
            this.sve = null,
            this.P6i = null,
            this.nve = zT.ea.hve.rve(),
            this.ove = zT.ea.hve.ave(),
            this.lve = null,
            this.uve = null,
            this.cve = zT.ea.hve.dve(),
            this.fve = zT.ea.hve.pve(),
            this.mve = null,
            this.wve = null,
            this.gve = zT.ea.hve.yve(),
            this.bve = zT.ea.hve.vve(),
            this.Sve = null,
            this.xve = null,
            this.Mve = null,
            this.jge = new Float32Array(3 * JT),
            this.zge = new Float32Array(2 * JT),
            this.Eve = new Uint32Array(JT),
            this.Vge = null,
            this.$ge = new Uint16Array(ZT),
            this.Wge = new Float32Array(4 * QT),
            this.Hge = 0,
            this.Kge = 0,
            this.Cve = 0,
            this._ve = zT.v(zT.za, 1, 1, 1, 1),
            this.qge = 0,
            this.Tve = zT.v(zT.ea.Ive, this),
            this.Pve = gI,
            this.Gve = 0,
            this.Ave = 0,
            this.Rve = 0,
            this.kve = 0,
            this.Ove = 0,
            this.Dve = 0,
            this.Fve = 0,
            this.Lve = 0,
            this.Bve = 0,
            this.Uve = zT.v(zT.Rect, 0, 0, 0, 0),
            this.Nve = zT.v(zT.za, 1, 1, 1, 1),
            this.jve = zT.v(zT.za, 1, 1, 1, 1),
            this.$ve = zT.v(zT.Rect, 0, 0, 0, 0),
            this.zve = 0,
            this.Vve = "",
            this.Wve = null,
            this.Hve = null,
            this.Kve = null,
            this.qve = null,
            this.Xve = null,
            this.Yve = null,
            this.Jve = null,
            this.Zve = null,
            this.Qve = null,
            this.tSe = null,
            this.iSe = null,
            this.eSe = null,
            this.sSe = null,
            this.nSe = new Set,
            this.rSe = new Set,
            this.dye = 8192,
            this.hSe = null,
            this.oSe = null,
            this.aSe = null,
            this.lSe = null,
            this.uSe = 0,
            this.cSe = 0,
            this.dSe = 0,
            this.fSe = 0,
            this.pSe = null,
            this.mSe = null,
            this.wSe = new Map,
            this.gSe = null,
            this.ySe = null,
            this.bSe = [],
            this.vSe = null,
            this.tye = null,
            this.SSe = !1,
            this.xSe = !1,
            this.Rge = !1,
            this.MSe = null,
            this.ESe = !1,
            this.CSe = -1,
            this._Se = -1,
            this.TSe = new Set,
            this._U = null,
            this.bU = null,
            this.Gye()
        }
        hu() {
            return !0
        }
        ISe(t, i) {
            i ? this.Pve |= t : this.Pve &= ~t
        }
        PSe(t) {
            return 0 !== (this.Pve & t)
        }
        GSe(t, i) {
            i ? this.Gve |= t : this.Gve &= ~t
        }
        ASe(t) {
            return 0 !== (this.Gve & t)
        }
        async hP(t, i) {
            if (i = Object.assign({}, YT, i),
            !navigator.gpu)
                throw new Error("renderer-unavailable (WebGPU not supported)");
            i.fU && (this.Pve |= SI),
            i.Dbe && (this.Pve |= yI),
            this.SSe = !!i.kbe,
            this.xSe = !!i.Obe,
            this.Fbe = {},
            this.Rge = !(!i.fU || !i.uU),
            "default" !== i.powerPreference && (this.Fbe.powerPreference = i.powerPreference),
            this.q_ = t,
            await this.RSe(i.cU)
        }
        async RSe(t) {
            for (this.Ube = null,
            await this.kSe(t); !this.Ube; )
                this.Lbe = null,
                await this.kSe(t);
            await this.vU()
        }
        async kSe(t) {
            if (!this.Lbe) {
                if (this.Lbe = await navigator.gpu.requestAdapter(this.Fbe),
                !this.Lbe)
                    throw new Error("renderer-unavailable (no WebGPU adapter available)");
                if (t && (this.Lbe.isFallbackAdapter || this.Lbe.info.isFallbackAdapter))
                    throw new Error("renderer-unavailable (WebGPU provided fallback adapter)");
                if ("adreno-7xx" === this.Lbe.info.architecture)
                    throw new Error("WebGPU disabled on adreno-7xx devices - see https://issues.chromium.org/issues/329702056")
            }
            const i = [];
            if (this.Lbe.features.has("timestamp-query") && i.push("timestamp-query"),
            this.Lbe.features.has("shader-f16") && i.push("shader-f16"),
            this.Ube = await this.Lbe.requestDevice({
                requiredFeatures: i,
                requiredLimits: {
                    maxTextureDimension2D: this.Lbe.limits.maxTextureDimension2D
                }
            }),
            !this.Ube)
                return null;
            this.dye = this.Ube.limits.maxTextureDimension2D,
            this.ISe(PI, this.Ube.features.has("timestamp-query")),
            this.ISe(GI, this.Ube.features.has("shader-f16")),
            this.ISe(AI, this.PSe(GI) && void 0 !== globalThis.Float16Array),
            this.Ube.lost.then(t => this.OSe(t)),
            this.ISe(gI, !1)
        }
        async OSe(t) {
            console.log("[WebGPU] Device lost: ", t),
            super.e3i(),
            this.Tve.ks(),
            zT.ea.DSe.ks(),
            zT.ea.FSe.ks(),
            zT.ea.ta.ks(),
            this.jbe = "",
            this.$be = null,
            this.zbe = null,
            this.Dge = null,
            this.qbe = null,
            this.Kbe = null,
            this.Xbe = null,
            this.Ybe = null,
            this.Jbe = null,
            this.C6i = null,
            this._6i = null,
            this.eve = null,
            this.T6i = null,
            this.Uge = null,
            this.sve = null,
            this.P6i = null,
            this.Zbe = null,
            this.Qbe = null,
            this.tve = null,
            this.ive = null,
            this.Hve = null,
            this.Wve = null,
            this.eSe = null,
            this.Kve = null,
            this.qve = null,
            this.Xve = null,
            this.hSe = null,
            this.lSe = null,
            this.Yve = null,
            this.Jve = null,
            this.Zve = null,
            this.Qve = null,
            this.tSe = null,
            this.iSe = null,
            this.oSe = null,
            this.aSe = null,
            this.vSe = null,
            this.tye = null,
            this.sSe = null,
            this.MSe = null,
            this.pSe = null,
            this.mSe = null,
            this.nSe.clear(),
            this.rSe.clear(),
            this.wSe.clear();
            for (const t of this.j2i.values())
                t.ks();
            this.Ube = null,
            this.Lbe = null,
            this.Bbe = null,
            this.Pve |= gI,
            this._U && this._U(),
            await this.RSe();
            for (const t of this.j2i.values())
                t.MS(this);
            this.zr(this.Fx, this.Ex, !0),
            this.bU && this.bU()
        }
        async vU() {
            super.vU();
            const t = this.Ube;
            this.jbe = navigator.gpu.getPreferredCanvasFormat(),
            this.$be = null,
            this.zbe = null;
            let i = XT.RENDER_ATTACHMENT;
            this.SSe && (i |= XT.TEXTURE_BINDING),
            this.xSe && (i |= XT.COPY_SRC),
            this.jbe.startsWith("rgba8") || this.jbe.startsWith("bgra8") ? this.Vve = this.jbe : this.Vve = "rgba8unorm",
            this.Pve &= SI | PI | GI | AI | yI,
            this.Pve |= LI,
            this.Gve = 0,
            this.PSe(SI) && (this.Pve |= xI | MI | II),
            this.Hge = 0,
            this.Kge = 0,
            this.uSe = 0,
            this.dSe = 0,
            this.fSe = 0,
            this.cSe = 0,
            this._ve.msi(1, 1, 1, 1),
            this.Nve.msi(1, 1, 1, 1),
            this.jve.msi(1, 1, 1, 1),
            this.Vge = this.I6i() ? new globalThis.Float16Array(4 * tI) : new Float32Array(4 * tI),
            this.lve = new ArrayBuffer(this.ove),
            this.uve = new Float32Array(this.lve),
            this.mve = new ArrayBuffer(this.fve),
            this.wve = new Float32Array(this.mve),
            this.Sve = new ArrayBuffer(this.bve),
            this.xve = new Float32Array(this.Sve),
            this.Mve = new Uint32Array(this.Sve),
            this.C6i = t.createBuffer({
                label: "vertexbuffer",
                size: this.jge.byteLength,
                usage: KT.VERTEX | KT.COPY_DST
            }),
            this._6i = t.createBuffer({
                label: "texcoordbuffer",
                size: this.zge.byteLength,
                usage: KT.VERTEX | KT.COPY_DST
            }),
            this.eve = t.createBuffer({
                label: "texindexbuffer",
                size: this.Eve.byteLength,
                usage: KT.VERTEX | KT.COPY_DST
            }),
            this.T6i = t.createBuffer({
                label: "colorbuffer",
                size: this.Vge.byteLength,
                usage: KT.VERTEX | KT.COPY_DST
            }),
            this.Uge = t.createBuffer({
                label: "indexbuffer",
                size: this.$ge.byteLength,
                usage: KT.INDEX | KT.COPY_DST
            }),
            this.sve = t.createBuffer({
                label: "pointsindexbuffer",
                size: 6 * QT * 2,
                usage: KT.INDEX,
                mappedAtCreation: !0
            });
            const e = this.sve.getMappedRange();
            this.LSe(e),
            this.sve.unmap(),
            this.P6i = t.createBuffer({
                label: "pointbuffer",
                size: this.Wge.byteLength,
                usage: KT.VERTEX | KT.STORAGE | KT.COPY_DST
            }),
            this.Wve = t.createBindGroupLayout({
                label: "bufferbindgrouplayout",
                entries: [{
                    binding: 0,
                    visibility: qT.VERTEX,
                    buffer: {
                        type: "uniform",
                        minBindingSize: this.ove
                    }
                }, {
                    binding: 1,
                    visibility: qT.FRAGMENT,
                    buffer: {
                        type: "uniform",
                        minBindingSize: this.fve
                    }
                }, {
                    binding: 3,
                    visibility: qT.VERTEX,
                    buffer: {
                        type: "read-only-storage",
                        minBindingSize: this.Wge.byteLength
                    }
                }, {
                    binding: 4,
                    visibility: qT.FRAGMENT,
                    buffer: {
                        type: "uniform",
                        minBindingSize: this.bve
                    }
                }, {
                    binding: 5,
                    visibility: qT.FRAGMENT,
                    buffer: {
                        type: "uniform"
                    }
                }]
            });
            const s = []
              , n = zT.ea.USe.BSe();
            for (let t = 0; t < n; ++t)
                s.push({
                    binding: 2 * t,
                    visibility: qT.FRAGMENT,
                    sampler: {
                        type: "filtering"
                    }
                }, {
                    binding: 2 * t + 1,
                    visibility: qT.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d"
                    }
                });
            this.Kve = t.createBindGroupLayout({
                label: "texturebindgrouplayout",
                entries: s
            }),
            this.qve = t.createBindGroupLayout({
                label: "backtexturebindgrouplayout",
                entries: [{
                    binding: 0,
                    visibility: qT.FRAGMENT,
                    sampler: {
                        type: "non-filtering"
                    }
                }, {
                    binding: 1,
                    visibility: qT.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d"
                    }
                }]
            }),
            this.Xve = t.createBindGroupLayout({
                label: "depthtexturebindgrouplayout",
                entries: [{
                    binding: 0,
                    visibility: qT.FRAGMENT,
                    sampler: {
                        type: "non-filtering"
                    }
                }, {
                    binding: 1,
                    visibility: qT.FRAGMENT,
                    texture: {
                        sampleType: "depth",
                        viewDimension: "2d"
                    }
                }]
            }),
            this.hSe = t.createPipelineLayout({
                bindGroupLayouts: [this.Wve, this.Kve, this.qve, this.Xve]
            });
            const r = zT.ea.hve
              , h = this.NSe()
              , o = this.I6i();
            this.oSe = t.createShaderModule({
                label: "<default vertex module>",
                code: r.jSe(r.E8i(o), h)
            }),
            this.oSe.getCompilationInfo().then(t => r.$Se("<default>", "vertex", t)),
            this.aSe = t.createShaderModule({
                label: "<normalized vertex module>",
                code: r.jSe(r.zSe(o), h)
            }),
            this.aSe.getCompilationInfo().then(t => r.$Se("<normalized>", "vertex", t));
            const a = await Promise.all([r.hP(this, {
                name: "<default>",
                src: r.VSe(!1, o),
                WSe: r.VSe(!0, o),
                b6i: r.HSe(o),
                KSe: r.qSe(o)
            }), r.hP(this, {
                name: "<single-texture-fill>",
                src: r.XSe(!1, o),
                WSe: r.XSe(!0, o),
                b6i: r.HSe(o),
                KSe: r.qSe(o)
            }), r.hP(this, {
                name: "<generate-mipmap>",
                src: r.YSe(),
                b6i: r.JSe()
            }), r.hP(this, {
                name: "<point>",
                src: r.ZSe(!1),
                WSe: r.ZSe(!0),
                b6i: r.QSe()
            }), r.hP(this, {
                name: "<tilemap>",
                src: r.txe(!1),
                WSe: r.txe(!0)
            }), r.hP(this, {
                name: "<fill>",
                src: r.ixe()
            }), r.hP(this, {
                name: "<lineargradient>",
                src: r.exe()
            }), r.hP(this, {
                name: "<penumbra>",
                src: r.sxe()
            }), r.hP(this, {
                name: "<hardellipse>",
                src: r.nxe()
            }), r.hP(this, {
                name: "<hardellipseoutline>",
                src: r.rxe()
            }), r.hP(this, {
                name: "<smoothellipse>",
                src: r.hxe()
            }), r.hP(this, {
                name: "<smoothellipseoutline>",
                src: r.oxe()
            }), r.hP(this, {
                name: "<tilerandomization>",
                src: r.R8i(!1),
                WSe: r.R8i(!0)
            }), r.hP(this, {
                name: "<smoothline>",
                src: r.axe()
            })]);
            this.P2i = a[0],
            this.mSe = a[1],
            this.pSe = a[2],
            this.G2i = a[3],
            this.A2i = a[4],
            this.k2i = a[5],
            this.O2i = a[6],
            this.D2i = a[7],
            this.F2i = a[8],
            this.L2i = a[9],
            this.B2i = a[10],
            this.U2i = a[11],
            this.R2i = a[12],
            this.N2i = a[13];
            for (const t of a)
                this.l3i(t);
            0 !== (this.Pve & yI) ? (this.Pve |= bI | vI,
            this.lSe = this.P2i) : this.lSe = this.mSe,
            this.sSe = this.pSe.lxe(),
            this.Zbe = t.createBuffer({
                label: "vertexuniformbuffer",
                size: this.ove,
                usage: KT.UNIFORM | KT.COPY_DST
            }),
            this.Qbe = t.createBuffer({
                label: "fragmentuniformbuffer",
                size: this.fve,
                usage: KT.UNIFORM | KT.COPY_DST
            }),
            this.tve = t.createBuffer({
                label: "fragmentc3paramsuniformbuffer",
                size: this.bve,
                usage: KT.UNIFORM | KT.COPY_DST
            }),
            this.ive = t.createBuffer({
                label: "fragmentdefaultcustomparamsbuffer",
                size: 16,
                usage: KT.UNIFORM | KT.COPY_DST
            }),
            this.kve = 0,
            this.Ove = this.ove,
            this.uxe(),
            this.cxe(),
            this.dxe(),
            this.Dve = 0,
            this.Fve = this.fve,
            this.fxe(),
            this.pxe(),
            this.Hve = this.mxe(this.ive),
            this.eSe = this.Hve;
            const l = zT.sy(32, 32);
            l.getContext("2d"),
            this.Yve = await this.In(l),
            this.Jve = null,
            this.Zve = this.Yve.wxe(),
            this.Cve = 0,
            this.Qve = null,
            this.tSe = this.Yve.gxe(),
            this.Yve.yxe(),
            this.Kbe = this.Ube.createTexture({
                label: "nulldepthbuffer",
                size: [8, 8, 1],
                format: this.bxe(),
                usage: XT.TEXTURE_BINDING
            }),
            this.Xbe = this.Kbe.createView({
                label: "nulldepthbufferview",
                aspect: "depth-only"
            }),
            this.Jbe = this.Ube.createBindGroup({
                label: "nulldepthbufferbindgroup",
                layout: this.Xve,
                entries: [{
                    binding: 0,
                    resource: this.vxe({
                        Mn: "nearest"
                    })
                }, {
                    binding: 1,
                    resource: this.Xbe
                }]
            }),
            this.iSe = this.Jbe,
            this.vSe = zT.v(zT.ea.FSe, this, !0),
            this.vSe.jn().Sxe(i, this.jbe),
            this.tye = this.vSe,
            this.xxe(),
            this.Bbe = this.Lbe.info,
            this.Nbe || (this.Nbe = this.q_.getContext("webgpu")),
            this.Nbe.configure({
                device: t,
                format: this.jbe,
                usage: i,
                alphaMode: "premultiplied"
            })
        }
        mxe(t) {
            return this.Ube.createBindGroup({
                layout: this.Wve,
                entries: [{
                    binding: 0,
                    resource: {
                        buffer: this.Zbe
                    }
                }, {
                    binding: 1,
                    resource: {
                        buffer: this.Qbe
                    }
                }, {
                    binding: 3,
                    resource: {
                        buffer: this.P6i
                    }
                }, {
                    binding: 4,
                    resource: {
                        buffer: this.tve
                    }
                }, {
                    binding: 5,
                    resource: {
                        buffer: t
                    }
                }]
            })
        }
        LSe(t) {
            HT(t.byteLength % 12 == 0, "wrong size index buffer");
            const i = new Uint16Array(t);
            let e = 0
              , s = i.length
              , n = 0;
            for (; e < s; )
                i[e++] = n,
                i[e++] = n + 1,
                i[e++] = n + 2,
                i[e++] = n,
                i[e++] = n + 2,
                i[e++] = n + 3,
                n += 4
        }
        Mxe() {
            return this.Ube
        }
        Exe() {
            return this.oSe
        }
        Cxe() {
            return this.aSe
        }
        async Rye(t) {
            const i = await zT.ea.hve.hP(this, t);
            return this.l3i(i),
            i
        }
        NBt() {
            return "webgpu"
        }
        _xe() {
            return this.jbe
        }
        bxe() {
            return "depth24plus-stencil8"
        }
        Txe() {
            return this.$be
        }
        Ixe() {
            return this.zbe
        }
        Pxe() {
            return this.SSe
        }
        Gxe() {
            return this.xSe
        }
        Axe() {
            return this.hSe
        }
        Rxe() {
            return this.Kve
        }
        kxe() {
            return this.qve
        }
        Oxe() {
            return this.Vve
        }
        T5i() {
            return this.dye
        }
        fn() {
            return this.PSe(gI)
        }
        Cbe() {
            return this.PSe(PI)
        }
        NSe() {
            return this.PSe(GI)
        }
        I6i() {
            return this.PSe(AI)
        }
        h4i() {
            const t = this.ns() * this.er();
            let i = t * zT.ea.DSe.Dxe(this.jbe);
            return this.Fxe() && (i += t * zT.ea.DSe.Dxe(this.bxe())),
            i
        }
        o4i() {
            let t = 0;
            for (const i of zT.ea.FSe.qwe())
                i.Lxe() || (t += i.jn().WE());
            return t
        }
        a4i() {
            let t = 0;
            for (const i of zT.ea.DSe.H9i())
                i.Bxe() || (t += i.WE());
            return t
        }
        gS() {
            return !0
        }
        Uxe() {
            return this.Tve
        }
        zr(t, i, e) {
            (this.Fx !== t || this.Ex !== i || e) && (this.Q3i(),
            this.Fx = t,
            this.Ex = i,
            this.Vbe = t,
            this.Wbe = i,
            this.vSe.Owe(),
            this.eR(this.vSe.Lwe()),
            this.tye && this.tye.Fwe(this.Fx, this.Ex),
            this.PSe(SI) && this.PSe(II) && this.Dye(t, i))
        }
        Dye(t, i) {
            if (this.Dge) {
                if (this.Lge === t && this.Bge === i)
                    return;
                this.Dge.destroy()
            }
            let e = XT.RENDER_ATTACHMENT;
            this.Rge && (e |= XT.TEXTURE_BINDING),
            this.Dge = this.Ube.createTexture({
                label: "depthbuffer",
                size: [t, i, 1],
                format: this.bxe(),
                usage: e
            }),
            this.qbe = this.Dge.createView({
                label: "depthbufferview"
            }),
            this.Rge && (this.Ybe = this.Ube.createBindGroup({
                label: "depthbufferbindgroup",
                layout: this.Xve,
                entries: [{
                    binding: 0,
                    resource: this.vxe({
                        Mn: "nearest"
                    })
                }, {
                    binding: 1,
                    resource: this.Dge.createView({
                        label: "depthbufferview",
                        aspect: "depth-only"
                    })
                }]
            })),
            this.Lge = t,
            this.Bge = i
        }
        Fye(t, i) {
            this.Fxe() && (this.ISe(II, !1),
            this.Dye(t, i))
        }
        Lye() {
            this.Fxe() && (this.ISe(II, !0),
            this.Dye(this.Fx, this.Ex))
        }
        eR(t) {
            WT.w6t(this.x2i, t) || (WT.Qr(this.x2i, t),
            this.uxe())
        }
        Uye() {
            this.eR(this.tye.Lwe())
        }
        rR(t) {
            WT.w6t(this.M2i, t) || (WT.Qr(this.M2i, t),
            this.uxe())
        }
        Nye() {
            this.GSe(kI, !1)
        }
        jye() {
            return this.ASe(kI)
        }
        Pn(t, i) {
            if (zT.GC(t),
            t && !zT.ea.DSe.Nxe(t)) {
                const i = t.width || t.videoWidth
                  , e = t.height || t.videoHeight
                  , s = zT.sy(i, e);
                s.getContext("2d").drawImage(t, 0, 0, i, e),
                t = s
            }
            this.Q3i();
            const e = zT.v(zT.ea.DSe, this);
            return e.Jue(t, i),
            e
        }
        async In(t, i) {
            if (zT.ea.DSe.Nxe(t))
                return this.Pn(t, i);
            {
                if (!zT.QL.O9t)
                    throw new Error("no support for ImageBitmapOptions");
                const e = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply"
                });
                return this.Pn(e, i)
            }
        }
        vxe(t) {
            const i = t.kn || "clamp-to-edge"
              , e = t.Rn || "clamp-to-edge"
              , s = t.Mn;
            let n = t.On || 0;
            "trilinear" !== s && (n = 0);
            const r = `${i},${e},${s},${n}`;
            let h = this.wSe.get(r);
            if (h)
                return h;
            const o = {
                addressModeU: i,
                addressModeV: e,
                magFilter: "nearest",
                minFilter: "nearest",
                mipmapFilter: "nearest"
            };
            return "bilinear" !== s && "trilinear" !== s || (o.magFilter = "linear",
            o.minFilter = "linear"),
            "trilinear" === s && (o.mipmapFilter = "linear",
            n > 1 && (o.maxAnisotropy = n)),
            h = this.Ube.createSampler(o),
            this.wSe.set(r, h),
            h
        }
        lxe() {
            return this.sSe
        }
        jR(t, i, e) {
            this.Q3i();
            const s = zT.v(zT.ea.DSe, this);
            return s.L9i(t, i, e),
            s
        }
        XR(t, i, e) {
            return i.Pbt(t, e)
        }
        mn(t) {
            t && (t.z9i(),
            t.V9i() > 0 || (this.fn() || (this.Q3i(),
            this.Jve === t && this.hr(null),
            this.Qve === t && this.jxe(null)),
            t.ZEt()))
        }
        $xe(t, i) {
            this.fn() || (i ? this.nSe.add(t) : this.nSe.delete(t))
        }
        zxe(t, i) {
            i ? this.rSe.add(t) : this.rSe.delete(t)
        }
        Vxe(t) {
            const i = [t]
              , e = zT.ea.USe.BSe();
            for (const t of this.rSe)
                t.he();
            for (const s of this.nSe) {
                if (i.length >= e)
                    break;
                s !== t && i.push(s)
            }
            i.length < 2 || zT.v(zT.ea.USe, this, i)
        }
        ke() {
            this.Wxe()
        }
        Hxe() {
            this.Wxe()
        }
        Wxe() {
            this.$be = this.Nbe.getCurrentTexture(),
            this.zbe = this.$be.createView({
                label: "swapchaintextureview"
            }),
            this.vSe.jn().Kxe()
        }
        FR() {
            null === this.ySe && this.vSe.qxe() && this.Xxe(),
            super.FR(),
            this.Tve.Yxe(this.Z2i),
            this.vSe.jn().Jxe(),
            this.$be = null,
            this.zbe = null
        }
        xxe() {
            this.gSe = this.Ube.createCommandEncoder(),
            this.Pve &= ~wI
        }
        Zxe(t) {
            if (!this.Cbe())
                throw new Error("GPU profiling not supported");
            if (this.MSe)
                throw new Error("already started frame timing");
            return this.ESe = !1,
            this.TSe.clear(),
            this.MSe = zT.v(zT.ea.Qxe, this, t),
            this.MSe
        }
        tMe(t, i) {
            if (this.Cbe()) {
                if (!this.MSe)
                    throw new Error("not started frame timing");
                if (t < 0 || i < 0 || t === i)
                    throw new Error("invalid timestamp index");
                this.iMe(),
                this.ESe = !0,
                this.CSe = t,
                this._Se = i
            }
        }
        eMe() {
            this.ESe && (this.iMe(),
            this.ESe = !1)
        }
        Jye(t, i) {
            if (this.Hge + t > JT || this.Kge + i > ZT)
                this.Q3i();
            else if (0 !== (this.Pve & eI))
                return void (this.Rve += i);
            null === this.ySe && this.Xxe(),
            this.Pve |= eI,
            this.Ave = this.Kge,
            this.Rve = i
        }
        Zye() {
            const t = this.Hge;
            let i = this.Kge;
            this.Kge += 6;
            const e = this.$ge;
            e[i++] = t,
            e[i++] = t + 1,
            e[i++] = t + 2,
            e[i++] = t,
            e[i++] = t + 2,
            e[i] = t + 3
        }
        sMe() {
            const t = this.Pve;
            if (0 === (t & eI))
                return;
            const i = this.ySe;
            if (0 !== (t & hI)) {
                const e = this.tye;
                i.setViewport(0, 0, e.ns(), e.er(), 0, 1),
                0 !== (t & sI) ? i.setIndexBuffer(this.sve, "uint16") : i.setIndexBuffer(this.Uge, "uint16"),
                i.setVertexBuffer(0, this.C6i),
                i.setVertexBuffer(1, this._6i),
                i.setVertexBuffer(2, this.T6i),
                i.setVertexBuffer(3, this.eve),
                0 !== (t & (CI | _I)) && i.setStencilReference(1),
                0 !== (t & nI) && this.nMe(i, this.Uve, e)
            }
            if (0 !== (t & oI)) {
                let e = 0;
                0 !== (t & RI) ? e = 4 : 0 !== (t & CI) ? e = 2 : 0 !== (t & _I) ? e = 3 : (t & (xI | MI)) === (xI | MI) && (e = 1),
                i.setPipeline(this.lSe.rMe(this.uSe, e, this.dSe, this.fSe, this.cSe))
            }
            if (0 !== (t & mI) && i.setBindGroup(0, this.eSe),
            0 !== (t & aI) && i.setBindGroup(1, this.Zve),
            0 !== (t & lI) && i.setBindGroup(2, this.tSe),
            0 !== (t & uI) && i.setBindGroup(3, this.iSe),
            0 !== (t & rI)) {
                const e = this.tye;
                0 !== (t & nI) ? this.nMe(i, this.Uve, e) : i.setScissorRect(0, 0, e.ns(), e.er())
            }
            i.drawIndexed(this.Rve, 1, this.Ave, 0, 0),
            this.Pve &= ~DI
        }
        nMe(t, i, e) {
            const s = e.ns()
              , n = e.er();
            let r = zT.Ne(i.Yr(), 0, s)
              , h = zT.Ne(i.Jr(), 0, n)
              , o = zT.Ne(i.pl(), r, s)
              , a = zT.Ne(i.dl(), h, n);
            Number.isNaN(r) && (r = 0),
            Number.isNaN(h) && (h = 0),
            Number.isNaN(o) && (o = s),
            Number.isNaN(a) && (a = n),
            t.setScissorRect(r, h, o - r, a - h)
        }
        Xxe() {
            HT(!this.ySe, "expected no render pass");
            const t = this.Pve;
            0 !== (t & LI) && this.hMe();
            let i = null;
            i = 0 !== (t & CI) ? this.oMe() : 0 !== (t & _I) ? this.aMe() : this.lMe(),
            this.ySe = this.gSe.beginRenderPass(i),
            this.Pve |= FI
        }
        lMe() {
            const t = this.Pve
              , i = this.tye
              , e = {
                colorAttachments: [{
                    view: i.uMe(),
                    loadOp: i.qxe() ? "clear" : "load",
                    clearValue: i.cMe().toJSON(),
                    storeOp: "store"
                }]
            };
            return this.dMe(e),
            i.fMe(!1),
            (t & (MI | xI)) === (MI | xI) && (e.depthStencilAttachment = {
                view: this.qbe,
                depthLoadOp: 0 !== (t & EI) ? "clear" : "load",
                depthClearValue: 1,
                depthStoreOp: "store",
                stencilLoadOp: "clear",
                stencilClearValue: 0,
                stencilStoreOp: "discard"
            },
            this.Pve &= ~EI),
            e
        }
        oMe() {
            const t = this.Pve
              , i = {
                colorAttachments: [],
                depthStencilAttachment: {
                    view: this.qbe,
                    depthLoadOp: 0 !== (t & EI) ? "clear" : "load",
                    depthClearValue: 1,
                    depthStoreOp: "store",
                    stencilLoadOp: 0 !== (t & TI) ? "clear" : "load",
                    stencilClearValue: 0,
                    stencilStoreOp: "store"
                }
            };
            return this.dMe(i),
            this.Pve &= ~(EI | TI),
            i
        }
        aMe() {
            const t = this.tye
              , i = {
                colorAttachments: [{
                    view: t.uMe(),
                    loadOp: t.qxe() ? "clear" : "load",
                    clearValue: t.cMe().toJSON(),
                    storeOp: "store"
                }],
                depthStencilAttachment: {
                    view: this.qbe,
                    depthReadOnly: !0,
                    stencilReadOnly: !0
                }
            };
            return this.dMe(i),
            t.fMe(!1),
            i
        }
        dMe(t) {
            if (!this.ESe)
                return;
            const i = {
                querySet: this.MSe.pMe(),
                endOfPassWriteIndex: this._Se
            };
            this.TSe.has(this.CSe) || (i.beginningOfPassWriteIndex = this.CSe,
            this.TSe.add(this.CSe)),
            t.timestampWrites = i
        }
        mMe(t) {
            if (!t.qxe())
                return;
            this.iMe();
            this.gSe.beginRenderPass({
                colorAttachments: [{
                    view: t.uMe(),
                    loadOp: "clear",
                    clearValue: t.cMe().toJSON(),
                    storeOp: "store"
                }]
            }).end(),
            this.Pve |= wI,
            t.fMe(!1)
        }
        iMe() {
            null !== this.ySe && (this.sMe(),
            this.ySe.end(),
            this.ySe = null)
        }
        Q3i(t=!1) {
            this.iMe(),
            this.MSe && t && (this.MSe.wMe(this.gSe),
            this.Pve |= wI),
            0 !== (this.Pve & wI) && (this.bSe.push(this.gSe.finish()),
            this.xxe()),
            0 !== this.bSe.length && (this.$ye(),
            this.Ube.queue.submit(this.bSe),
            zT.Io(this.bSe),
            this.Tve.gMe(),
            this.MSe && t && (this.MSe.yMe(),
            this.MSe = null))
        }
        $ye() {
            const t = this.Ube.queue;
            if (this.Hge > 0) {
                const i = this.Hge;
                t.writeBuffer(this.C6i, 0, this.jge.buffer, 0, 3 * i * jI),
                t.writeBuffer(this._6i, 0, this.zge.buffer, 0, 2 * i * jI),
                0 !== (this.Pve & yI) && t.writeBuffer(this.eve, 0, this.Eve.buffer, 0, i * UI);
                const e = this.I6i() ? NI : jI;
                t.writeBuffer(this.T6i, 0, this.Vge.buffer, 0, 4 * i * e),
                this.Hge = 0
            }
            this.Kge > 0 && (t.writeBuffer(this.Uge, 0, this.$ge.buffer, 0, this.Kge * BI),
            this.Kge = 0),
            this.qge > 0 && (t.writeBuffer(this.P6i, 0, this.Wge.buffer, 0, this.qge * jI),
            this.qge = 0)
        }
        uxe() {
            this.Pve |= cI,
            this.Gve |= kI,
            this.bMe(this.nve.transform)
        }
        cxe() {
            const t = this.nve.vMe;
            this.$ve.usi(this.uve, t.offset / 4),
            this.bMe(t)
        }
        dxe() {
            const t = this.nve.SMe;
            this.uve[t.offset / 4] = this.zve,
            this.bMe(t)
        }
        bMe(t) {
            const i = t.offset
              , e = t.end;
            0 !== (this.Pve & dI) ? (this.kve = Math.min(this.kve, i),
            this.Ove = Math.max(this.Ove, e)) : (this.Pve |= dI,
            this.kve = i,
            this.Ove = e,
            this.iMe())
        }
        fxe() {
            this.xMe(this.Nve, this.cve.MMe)
        }
        pxe() {
            this.xMe(this.jve, this.cve.EMe)
        }
        xMe(t, i) {
            t.usi(this.wve, i.offset / 4),
            this.CMe(i)
        }
        _Me(t, i) {
            t.usi(this.wve, i.offset / 4),
            this.CMe(i)
        }
        CMe(t) {
            const i = t.offset
              , e = t.end;
            0 !== (this.Pve & fI) ? (this.Dve = Math.min(this.Dve, i),
            this.Fve = Math.max(this.Fve, e)) : (this.Pve |= fI,
            this.Dve = i,
            this.Fve = e,
            this.iMe())
        }
        TMe(t, i) {
            this.xve[i.offset / 4] !== Math.fround(t) && (this.xve[i.offset / 4] = t,
            this.IMe(i))
        }
        PMe(t, i) {
            this.Mve[i.offset / 4] !== t && (this.Mve[i.offset / 4] = t,
            this.IMe(i))
        }
        GMe(t, i) {
            t.hsi(this.xve, i.offset / 4) || (t.usi(this.xve, i.offset / 4),
            this.IMe(i))
        }
        IMe(t) {
            const i = t.offset
              , e = t.end;
            0 !== (this.Pve & pI) ? (this.Lve = Math.min(this.Lve, i),
            this.Bve = Math.max(this.Bve, e)) : (this.Pve |= pI,
            this.Lve = i,
            this.Bve = e,
            this.iMe())
        }
        hMe() {
            const t = this.Pve;
            0 !== (t & cI) && (WT.multiply(this.Hbe, this.x2i, this.M2i),
            this.uve.set(this.Hbe, this.nve.transform.offset / 4)),
            0 !== (t & dI) && this.Tve.AMe(this.gSe, this.Zbe, this.lve, this.kve, this.Ove - this.kve),
            0 !== (t & fI) && this.Tve.AMe(this.gSe, this.Qbe, this.mve, this.Dve, this.Fve - this.Dve),
            0 !== (t & pI) && this.Tve.AMe(this.gSe, this.tve, this.Sve, this.Lve, this.Bve - this.Lve),
            this.Pve = t & ~LI | wI
        }
        TU(t) {
            zT.kQ(t);
            let i = this.Fx
              , e = this.Ex
              , s = !0;
            if (t && ("number" == typeof t.width && (i = Math.floor(t.width),
            s = !1),
            "number" == typeof t.height && (e = Math.floor(t.height),
            s = !1)),
            i <= 0 || e <= 0)
                throw new Error("invalid size");
            this.Q3i();
            const n = zT.v(zT.ea.FSe, this);
            return n.Jue(i, e, Object.assign({
                q9i: s
            }, t)),
            n
        }
        AR(t, i=!0) {
            null === t && (t = this.vSe),
            this.tye !== t && (this.iMe(),
            this.tye = t,
            this.ISe(MI, t.Nwe()),
            t.$we() && !t.Lxe() && t.Fwe(this.Fx, this.Ex),
            i && this.Uye())
        }
        ybe(t) {}
        fbe() {
            return this.tye === this.vSe ? null : this.tye
        }
        ebe(t) {
            return null === t ? [this.Fx, this.Ex] : [t.ns(), t.er()]
        }
        RMe() {
            return this.vSe
        }
        bbe(t) {
            this.Q3i(),
            this.tye === t && this.AR(null);
            const i = t.jn();
            this.Jve === i && this.hr(null),
            this.Qve === i && this.jxe(null),
            t.ZEt()
        }
        async Kwe(t, i, e) {
            this.mMe(t),
            this.Q3i(),
            null === t && (t = this.vSe);
            const s = this.Ube
              , n = t.ns()
              , r = t.er();
            let h = 0
              , o = 0
              , a = n
              , l = r;
            if (e) {
                h = zT.Ne(Math.floor(e.Yr()), 0, n - 1),
                o = zT.Ne(Math.floor(e.Jr()), 0, r - 1);
                let t = e.width();
                t = 0 === t ? n - h : zT.Ne(Math.floor(t), 0, n - h);
                let i = e.height();
                i = 0 === i ? r - o : zT.Ne(Math.floor(i), 0, r - o),
                a = t,
                l = i
            }
            const u = s.createCommandEncoder()
              , c = t.jn();
            let d = c.u7i()
              , f = null;
            "rgba8unorm" === c.kMe() ? c.OMe() || zT.Mti() : (f = this.DMe(c, "rgba8unorm", u),
            d = f);
            const p = 4 * a
              , m = 256 * Math.ceil(p / 256)
              , w = s.createBuffer({
                size: m * l,
                usage: KT.MAP_READ | KT.COPY_DST
            });
            u.copyTextureToBuffer({
                texture: d,
                origin: [h, o, 0]
            }, {
                buffer: w,
                bytesPerRow: m
            }, [a, l, 1]);
            const g = u.finish();
            s.queue.submit([g]),
            f && f.destroy(),
            await w.mapAsync(self.GPUMapMode.READ);
            const y = w.getMappedRange().slice(0);
            let b;
            if (m === p)
                b = new ImageData(new Uint8ClampedArray(y),a,l);
            else {
                const t = new ArrayBuffer(p * l)
                  , i = new Uint8Array(t);
                for (let t = 0; t < l; ++t) {
                    const e = t * m
                      , s = t * p;
                    i.set(new Uint8Array(y,e,p), s)
                }
                b = new ImageData(new Uint8ClampedArray(t),a,l)
            }
            return w.destroy(),
            b
        }
        DMe(t, i, e) {
            const s = this.Ube
              , n = t.ns()
              , r = t.er();
            if (t.kMe() === i)
                throw new Error("no conversion necessary");
            t.Uwe() || zT.Mti();
            const h = s.createTexture({
                size: [n, r, 1],
                format: i,
                usage: XT.COPY_SRC | XT.RENDER_ATTACHMENT
            })
              , o = this.pSe.lxe(i)
              , a = o.getBindGroupLayout(0)
              , l = this.vxe({
                Mn: "nearest"
            })
              , u = t.u7i().createView({
                baseMipLevel: 0,
                mipLevelCount: 1
            })
              , c = h.createView({
                baseMipLevel: 0,
                mipLevelCount: 1
            })
              , d = e.beginRenderPass({
                colorAttachments: [{
                    view: c,
                    loadOp: "clear",
                    clearValue: [0, 0, 0, 0],
                    storeOp: "store"
                }]
            })
              , f = s.createBindGroup({
                layout: a,
                entries: [{
                    binding: 0,
                    resource: l
                }, {
                    binding: 1,
                    resource: u
                }]
            });
            return d.setPipeline(o),
            d.setBindGroup(0, f),
            d.draw(4),
            d.end(),
            h
        }
        kR(t) {
            0 !== (this.Pve & SI) && (t = !!t,
            0 !== (this.Pve & xI) !== t && (0 !== (this.Pve & MI) && this.iMe(),
            this.ISe(xI, t)))
        }
        ube() {
            return this.PSe(xI)
        }
        Fxe() {
            return this.PSe(SI)
        }
        cbe(t) {
            if (!this.Rge)
                return;
            if (t && this.ube())
                throw new Error("depth still enabled");
            const i = t ? this.Ybe : this.Jbe;
            this.iSe !== i && (this.sMe(),
            this.iSe = i,
            this.Pve |= uI)
        }
        Ry(t) {
            this.iMe(),
            this.tye.fMe(!0),
            this.tye.cMe().set(t)
        }
        abe(t, i, e, s) {
            this.iMe(),
            this.tye.fMe(!0),
            this.tye.cMe().msi(t, i, e, s)
        }
        lbe() {
            (this.Pve & (SI | MI)) === (SI | MI) && (this.iMe(),
            this.Pve |= EI)
        }
        dbe(t, i, e, s) {
            t = Math.floor(t),
            i = Math.floor(i),
            e = Math.floor(e),
            s = Math.floor(s),
            0 !== (this.Pve & nI) && this.Uve.hni(t, i, e, s) || (this.sMe(),
            this.Pve |= nI | rI,
            this.Uve.Cu(t, i, e, s))
        }
        pbe() {
            0 !== (this.Pve & nI) && (this.sMe(),
            this.Pve &= ~nI,
            this.Pve |= rI)
        }
        c3i() {
            return 0 !== (this.Pve & yI) ? this.P2i : this.mSe
        }
        Wr() {
            this.dm(this.c3i())
        }
        dm(t) {
            if (this.lSe !== t) {
                if (t === this.P2i && 0 === (this.Pve & yI))
                    throw new Error("cannot set multitexture fill program when multitexturing not allowed");
                this.sMe(),
                this.lSe = t,
                this.$2i = null,
                this.Pve |= oI,
                this.FMe(t === this.P2i)
            }
        }
        pm() {
            return this.lSe
        }
        FMe(t) {
            if (t = !!t,
            0 !== (this.Pve & bI) === t)
                return;
            this.ISe(bI, t);
            const i = null === this.Jve ? this.Yve : this.Jve;
            this.LMe(i)
        }
        BMe(t) {
            t = !!t,
            0 !== (this.Pve & vI) !== t && (this.sMe(),
            this.ISe(vI, t),
            this.ISe(oI, !0))
        }
        UMe(t) {
            t = !!t,
            0 !== (this.Pve & RI) !== t && (this.sMe(),
            this.ISe(RI, t),
            this.Pve |= oI)
        }
        NMe() {
            return this.PSe(RI)
        }
        hr(t) {
            t !== this.Jve && (this.Jve = t,
            null === t && (t = this.Yve),
            this.LMe(t))
        }
        LMe(t) {
            if (0 !== (this.Pve & bI)) {
                const i = t.jMe();
                if (null !== i)
                    return this.$Me(i),
                    this.Cve = t.zMe(),
                    void this.BMe(!0)
            }
            this.$Me(t.wxe()),
            this.Cve = 0,
            this.BMe(!1)
        }
        $Me(t) {
            t !== this.Zve && (this.sMe(),
            this.Zve = t,
            this.Pve |= aI)
        }
        VMe(t) {
            this.Jve === t && (this.sMe(),
            this.Zve = t.wxe(),
            this.Pve |= aI)
        }
        WMe(t) {
            if (this.Zve !== t)
                return;
            this.sMe();
            const i = null === this.Jve ? this.Yve : this.Jve;
            this.Zve = i.wxe(),
            this.Cve = 0,
            this.Pve |= aI
        }
        jxe(t) {
            t !== this.Qve && (this.Qve = t,
            null === t && (t = this.Yve),
            this.sMe(),
            this.tSe = t.gxe(),
            this.Pve |= lI)
        }
        HMe(t, i, e, s, n, r) {
            const h = t.KMe()
              , o = i.KMe();
            if (0 === (h & XT.COPY_SRC))
                throw new Error("source texture missing COPY_SRC usage");
            if (0 === (o & XT.COPY_DST))
                throw new Error("destination texture missing COPY_DST usage");
            if (t === i)
                throw new Error("invalid destination");
            const a = Math.min(t.ns(), i.ns())
              , l = Math.min(t.er(), i.er());
            n = Math.min(n, a - e),
            r = Math.min(r, l - s),
            n <= 0 || r <= 0 || (this.iMe(),
            this.gSe.copyTextureToTexture({
                texture: t.u7i(),
                origin: [e, s]
            }, {
                texture: i.u7i(),
                origin: [e, s]
            }, [n, r]),
            this.Pve |= wI)
        }
        qMe(t) {
            return t >= 2 ? 4 : 1
        }
        XMe(t) {
            t = this.qMe(t),
            this.cSe !== t && (this.sMe(),
            this.cSe = t,
            this.Pve |= oI)
        }
        mb(t) {
            t !== this.uSe && (this.sMe(),
            this.uSe = t,
            this.$2i = null,
            this.Pve |= oI)
        }
        Wye(t) {
            this.mb(this.P3i(t))
        }
        sr() {
            this.mb(0)
        }
        Yye() {
            this.mb(3)
        }
        rr(t, i, e, s) {
            const n = this._ve;
            n.Isi(t, i, e, s) || (n.msi(t, i, e, s),
            this.$2i = null)
        }
        Uo(t) {
            const i = this._ve;
            i.Ix() !== t && (i.vx(t),
            this.$2i = null)
        }
        wh() {
            return this._ve.Ix()
        }
        Jn(t) {
            const i = this._ve;
            i.equals(t) || (i.set(t),
            this.$2i = null)
        }
        Nr() {
            this.rr(1, 1, 1, 1)
        }
        qn() {
            return this._ve
        }
        hm(t) {
            t !== this.dSe && (this.sMe(),
            this.dSe = t,
            this.$2i = null,
            this.Pve |= oI)
        }
        qye() {
            return this.dSe
        }
        om(t) {
            t !== this.fSe && (this.sMe(),
            this.fSe = t,
            this.$2i = null,
            this.Pve |= oI)
        }
        Xye() {
            return this.fSe
        }
        Rect(t) {
            this.RY(t.Yr(), t.Jr(), t.pl(), t.dl())
        }
        RY(t, i, e, s) {
            this.Z3i(t, i, e, i, e, s, t, s)
        }
        YMe(t) {
            const i = this.Eve
              , e = this.Cve;
            i[t++] = e,
            i[t++] = e,
            i[t++] = e,
            i[t] = e
        }
        zn(t) {
            this.Dl(t, $I)
        }
        Z3i(t, i, e, s, n, r, h, o) {
            this.Jye(4, 6),
            this.Zye();
            const a = this.jge
              , l = this.Hge;
            this.Hge += 4;
            let u = 3 * l;
            const c = this.W2i + this.H2i;
            a[u++] = t,
            a[u++] = i,
            a[u++] = c,
            a[u++] = e,
            a[u++] = s,
            a[u++] = c,
            a[u++] = n,
            a[u++] = r,
            a[u++] = c,
            a[u++] = h,
            a[u++] = o,
            a[u] = c,
            $I.usi(this.zge, 2 * l),
            0 !== (this.Pve & vI) && this.YMe(l),
            this._ve.Csi(this.Vge, 4 * l)
        }
        ur(t, i) {
            this.Jye(4, 6),
            this.Zye();
            const e = this.Hge;
            this.Hge += 4,
            t.Uni(this.jge, 3 * e, this.W2i + this.H2i),
            i.lni(this.zge, 2 * e),
            0 !== (this.Pve & vI) && this.YMe(e),
            this._ve.Csi(this.Vge, 4 * e)
        }
        Dl(t, i) {
            this.Jye(4, 6),
            this.Zye();
            const e = this.Hge;
            this.Hge += 4,
            t.Uni(this.jge, 3 * e, this.W2i + this.H2i),
            i.usi(this.zge, 2 * e),
            0 !== (this.Pve & vI) && this.YMe(e),
            this._ve.Csi(this.Vge, 4 * e)
        }
        Qye(t, i, e) {
            this.Jye(4, 6),
            this.Zye();
            const s = this.Hge;
            this.Hge += 4,
            t.Uni(this.jge, 3 * s, this.W2i + this.H2i),
            i.usi(this.zge, 2 * s),
            0 !== (this.Pve & vI) && this.YMe(s),
            this.Vge.set(e, 4 * s)
        }
        Sm(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.Jye(4, 6),
            this.Zye();
            const f = this.jge
              , p = this.Hge;
            this.Hge += 4;
            let m = 3 * p;
            const w = this.W2i + this.H2i;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.lni(this.zge, 2 * p),
            0 !== (this.Pve & vI) && this.YMe(p),
            this._ve.Csi(this.Vge, 4 * p)
        }
        Vm(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.Jye(4, 6),
            this.Zye();
            const f = this.jge
              , p = this.Hge;
            this.Hge += 4;
            let m = 3 * p;
            const w = this.W2i + this.H2i;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.usi(this.zge, 2 * p),
            0 !== (this.Pve & vI) && this.YMe(p),
            this._ve.Csi(this.Vge, 4 * p)
        }
        tbe(t, i, e, s, n, r, h, o, a, l, u, c, d, f) {
            this.Jye(4, 6),
            this.Zye();
            const p = this.jge
              , m = this.Hge;
            this.Hge += 4;
            let w = 3 * m;
            const g = this.W2i + this.H2i;
            p[w++] = t,
            p[w++] = i,
            p[w++] = g + e,
            p[w++] = s,
            p[w++] = n,
            p[w++] = g + r,
            p[w++] = h,
            p[w++] = o,
            p[w++] = g + a,
            p[w++] = l,
            p[w++] = u,
            p[w] = g + c,
            d.usi(this.zge, 2 * m),
            0 !== (this.Pve & vI) && this.YMe(m),
            this.Vge.set(f, 4 * m)
        }
        a2i(t, i, e, s) {
            if (t.length % 3 != 0)
                throw new Error("vertex buffer length not multiple of 3");
            if (t.length > 3 * JT)
                throw new Error(`too many vertices (${t.length / 3}, limit ${JT})`);
            if (e.length % 3 != 0)
                throw new Error("index buffer length not multiple of 3");
            if (e.length > ZT)
                throw new Error(`too many indices (${e.length}, limit ${ZT})`);
            this.Jye(t.length, e.length);
            const n = this.Hge;
            this.jge.set(t, 3 * n),
            this.zge.set(i, 2 * n),
            0 !== (this.Pve & vI) && this.Eve.fill(this.Cve, n, n + t.length);
            const r = this.$ge;
            if (0 === n)
                r.set(e, this.Kge);
            else {
                let t = this.Kge;
                for (let i = 0, s = e.length; i < s; ++i)
                    r[t++] = e[i] + n
            }
            const h = this.Vge;
            if (void 0 !== s)
                h.set(s, 4 * n);
            else {
                const i = this._ve
                  , e = i.xsi()
                  , s = i.Msi()
                  , r = i.Esi()
                  , o = i.Ix();
                let a = 4 * n;
                for (let i = 0, n = t.length; i < n; ++i)
                    h[a++] = e,
                    h[a++] = s,
                    h[a++] = r,
                    h[a++] = o
            }
            this.Hge += t.length / 3,
            this.Kge += e.length
        }
        sc(t) {
            this.$ve.equals(t) || (this.$ve.Qr(t),
            this.cxe());
            const i = this.W2i + this.H2i;
            this.zve !== i && (this.zve = i,
            this.dxe()),
            this.jve.equals(this._ve) || (this.jve.Qr(this._ve),
            this.pxe()),
            this.dm(this.d3i()),
            this.Rve = 0,
            this.Pve |= sI | hI
        }
        rc() {
            this.Rve > 0 && this.sMe(),
            this.Pve &= ~sI,
            this.Pve |= hI
        }
        ou(t, i, e, s) {
            let n = this.qge;
            n > iI && (this.Q3i(),
            n = 0),
            0 !== (this.Pve & eI) ? this.Rve += 6 : (null === this.ySe && this.Xxe(),
            this.Pve |= eI,
            this.Ave = n / 4 * 6,
            this.Rve = 6);
            const r = this.Wge;
            r[n++] = t,
            r[n++] = i,
            r[n++] = e,
            r[n++] = s,
            this.qge = n
        }
        nbe(t) {
            this.Nve.equals(t) || (this.Nve.Qr(t),
            this.fxe())
        }
        rbe(t, i, e=1) {
            const s = this.cve
              , n = this.wve;
            zI.set(t, i),
            zI.hsi(n, s.JMe.offset / 4) || this._Me(zI, s.JMe),
            n[s.ZMe.offset / 4] !== Math.fround(e) && (n[s.ZMe.offset / 4] = e,
            this.CMe(s.ZMe))
        }
        SI(t, i, e, s, n, r, h) {
            const o = this.cve
              , a = this.wve;
            t.hsi(a, o.QMe.offset / 4) || (t.usi(a, o.QMe.offset / 4),
            this.CMe(o.QMe)),
            zI.set(s / i, n / e),
            zI.hsi(a, o.tEe.offset / 4) || this._Me(zI, o.tEe),
            zI.set(r / i, h / e),
            zI.hsi(a, o.iEe.offset / 4) || this._Me(zI, o.iEe)
        }
        gC(t, i, e, s, n, r, h) {
            const o = this.cve
              , a = this.wve;
            zI.set(e, s),
            zI.hsi(a, o.tEe.offset / 4) || this._Me(zI, o.tEe),
            a[o.ZMe.offset / 4] !== Math.fround(n) && (a[o.ZMe.offset / 4] = n,
            this.CMe(o.ZMe)),
            zI.set(r, h),
            zI.hsi(a, o.iEe.offset / 4) || this._Me(zI, o.iEe)
        }
        hbe(t, i, e, s, n, r, h, o, a, l, u) {
            const c = this.gve
              , d = this.lSe;
            u %= 10800,
            d.B4i() && (HT(null === t || this.tye.jn() !== t, "setting back texture to current render target"),
            this.jxe(t)),
            d.eEe() && (this.GMe(i, c.sEe),
            this.GMe(e, c.QMe),
            this.GMe(s, c.nEe),
            this.GMe(n, c.rEe)),
            this.TMe(o, c.devicePixelRatio),
            this.TMe(a, c.hEe),
            this.TMe(l, c.oEe),
            this.TMe(u, c.Yoi),
            this.TMe(this.fE(), c.aEe),
            this.TMe(this.uE(), c.lEe)
        }
        obe(t) {
            zT.Ef(t, zT.ea.uEe),
            t && (t.z$() && (this.iMe(),
            t.cEe(this.gSe)),
            this.dEe(t.fEe()))
        }
        pEe(t) {
            this.PMe(t ? 1 : 0, this.gve.mEe)
        }
        dEe(t) {
            t !== this.eSe && (this.sMe(),
            this.eSe = t,
            this.Pve |= mI)
        }
        wEe(t) {
            this.eSe === t && this.dEe(this.Hve)
        }
        wbe(t) {
            if (HT(t !== this.tye, "copying render target to itself"),
            t.qxe())
                return this.tye.fMe(!0),
                void this.tye.cMe().set(t.cMe());
            t.zwe() >= 2 && this.tye.zwe() < 2 ? this.gEe(t) : (this.abe(0, 0, 0, 0),
            this.Yye(),
            this.Nr(),
            this.gbe(t))
        }
        gbe(t) {
            HT(t !== this.tye, "drawing render target to itself"),
            this.mMe(t);
            const i = t.jn();
            this.hr(i),
            this.ibe()
        }
        ibe() {
            const t = this.NMe();
            t || this.UMe(!0),
            this.JR(0);
            const i = WI
              , e = VI;
            i.set(0, -1, 0, -1, 2, 1, 0, 1),
            e.set(0, -1, 2, 1),
            this.ur(i, e),
            t || this.UMe(!1)
        }
        gEe(t) {
            this.mMe(t),
            this.iMe();
            this.gSe.beginRenderPass({
                colorAttachments: [{
                    view: t.jn().uMe(),
                    resolveTarget: this.tye.jn().uMe(),
                    loadOp: "load",
                    storeOp: "store"
                }]
            }).end(),
            this.Pve |= wI
        }
        vbe() {
            this.iMe(),
            this.kR(!0),
            this.Pve |= CI | TI
        }
        Sbe() {
            this.iMe(),
            this.kR(!1),
            this.Pve &= ~CI,
            this.Pve |= _I
        }
        xbe() {
            return this.PSe(_I)
        }
        Mbe() {
            this.iMe(),
            this.kR(!0),
            this.Pve &= ~_I
        }
        Gye() {
            this.x3i([["normal", "one", "one-minus-src-alpha"], ["additive", "one", "one"], ["xor", "one", "one-minus-src-alpha"], ["copy", "one", "zero"], ["destination-over", "one-minus-dst-alpha", "one"], ["source-in", "dst-alpha", "zero"], ["destination-in", "zero", "src-alpha"], ["source-out", "one-minus-dst-alpha", "zero"], ["destination-out", "zero", "one-minus-src-alpha"], ["source-atop", "dst-alpha", "one-minus-src-alpha"], ["destination-atop", "one-minus-dst-alpha", "src-alpha"]])
        }
        yEe() {
            return this.Lbe ? [...this.Lbe.features] : []
        }
        bEe() {
            return this.Bbe
        }
        vEe() {
            const t = this.Bbe;
            if (!t)
                return "unknown/unknown";
            const i = t.vendor || "unknown"
              , e = t.architecture || "unknown"
              , s = [];
            t.device && s.push(t.device),
            t.description && s.push(t.description),
            t.type && s.push(t.type),
            t.backend && s.push(t.backend);
            return i + "/" + e + (s.length > 0 ? ` (${s.join(", ")})` : "")
        }
    }
}
{
    const HI = self.t
      , KI = !0;
    HI.ea.Ive = class {
        constructor(t) {
            HI.U(t, HI.ea.wU),
            this.cn = t,
            this.SEe = new Map,
            this.xEe = [],
            this.MEe = [],
            this.EEe = [],
            this.CEe = 0,
            this._Ee = 0,
            this.TEe = 0,
            this.IEe = 0,
            this.PEe = 0,
            this.GEe = 0
        }
        Tn() {
            return this.cn
        }
        ks() {
            this.SEe.clear(),
            HI.Io(this.xEe),
            HI.Io(this.MEe),
            HI.Io(this.EEe)
        }
        AEe(t) {
            return Math.max(HI.na(t), 16)
        }
        REe(t) {
            this.PEe++;
            const i = this.AEe(t);
            if (KI) {
                const t = this.SEe.get(i);
                if (void 0 !== t && t.length > 0) {
                    const e = t.pop();
                    return e.kEe(),
                    0 === t.length && this.SEe.delete(i),
                    e
                }
            }
            return this.CEe++,
            this._Ee += i,
            this.TEe++,
            HI.v(HI.ea.OEe, this, i)
        }
        DEe(t) {
            this.GEe++;
            const i = t.zo()
              , e = this.SEe.get(i);
            void 0 === e ? this.SEe.set(i, [t]) : e.push(t)
        }
        FEe(t) {
            this.EEe.push(t)
        }
        gMe() {
            for (const t of this.xEe)
                t.LEe();
            HI.Io(this.xEe);
            for (const t of this.MEe)
                this.CEe--,
                this._Ee -= t.zo(),
                t.he();
            HI.Io(this.MEe);
            for (const t of this.EEe)
                t.destroy();
            HI.Io(this.EEe)
        }
        Yxe(t) {
            t % 30 == 0 && this.BEe(t)
        }
        BEe(t) {
            for (const [i,e] of this.SEe.entries()) {
                let s = 0;
                for (let i = 0, n = e.length; i < n; ++i) {
                    const n = e[i];
                    n.UEe(t) ? (this.CEe--,
                    this._Ee -= n.zo(),
                    n.he(),
                    this.IEe++) : (e[s] = n,
                    ++s)
                }
                0 === s ? this.SEe.delete(i) : HI.To(e, s)
            }
            this.NEe()
        }
        AMe(t, i, e, s, n) {
            const r = this.REe(n)
              , h = r.ymi()
              , o = h.getMappedRange(0, n);
            new Uint8Array(o).set(new Uint8Array(e,s,n)),
            h.unmap(),
            t.copyBufferToBuffer(h, 0, i, s, n),
            KI ? this.xEe.push(r) : (r.jEe(),
            this.MEe.push(r))
        }
        NEe() {
            this.TEe = 0,
            this.IEe = 0,
            this.PEe = 0,
            this.GEe = 0
        }
    }
}
{
    const qI = self.t
      , XI = self.GPUBufferUsage
      , YI = self.GPUMapMode
      , JI = self.assert
      , ZI = 0
      , QI = 1
      , tP = 2;
    qI.ea.OEe = class {
        constructor(t, i) {
            qI.U(t, qI.ea.Ive),
            this.Tve = t,
            this.pwi = QI,
            this.$c = i,
            this.Jgi = this.Tn().Mxe().createBuffer({
                mappedAtCreation: !0,
                size: i,
                usage: XI.COPY_SRC | XI.MAP_WRITE
            }),
            this.$Ee = 0
        }
        Tn() {
            return this.Tve.Tn()
        }
        zEe() {
            return this.pwi
        }
        zo() {
            return this.$c
        }
        ymi() {
            return this.Jgi
        }
        kEe() {
            JI(this.pwi === ZI, "expected buffer available"),
            this.pwi = QI
        }
        async LEe() {
            JI(this.pwi === QI, "expected buffer in use"),
            this.pwi = tP;
            try {
                await this.Jgi.mapAsync(YI.WRITE)
            } catch (t) {
                return void (() => {})("[WebGPU] Error recycling buffer, assuming device was lost: ", t)
            }
            this.Tn().fn() || (this.pwi = ZI,
            this.$Ee = this.Tn().t4i(),
            this.Tve.DEe(this))
        }
        jEe() {
            this.pwi = ZI
        }
        UEe(t) {
            return this.$Ee <= t - 25
        }
        he() {
            JI(this.pwi === ZI, "cannot destroy buffer"),
            this.Jgi.destroy(),
            this.Jgi = null,
            this.Tve = null
        }
    }
}
{
    const iP = self.t
      , eP = self.assert
      , sP = self.GPUBufferUsage;
    iP.ea.uEe = class {
        constructor(t) {
            iP.U(t, iP.ea.hve),
            eP(t.VEe() > 0, "no custom params");
            const i = t.Tn();
            this.b1i = t,
            this.WEe = t.VEe(),
            this.HEe = new ArrayBuffer(this.WEe),
            this.KEe = new Float32Array(this.HEe),
            this.qEe = !1,
            this.Jgi = i.Mxe().createBuffer({
                size: this.WEe,
                usage: sP.UNIFORM | sP.COPY_DST
            }),
            this.XEe = i.mxe(this.Jgi)
        }
        he() {
            this.Tn().wEe(this.XEe),
            this.Tn().Uxe().FEe(this.Jgi),
            this.Jgi = null,
            this.b1i = null,
            this.HEe = null,
            this.KEe = null,
            this.XEe = null
        }
        Tn() {
            return this.b1i.Tn()
        }
        X5i() {
            return this.b1i
        }
        fEe() {
            return this.XEe
        }
        Xne(t, i) {
            const e = this.b1i.YEe(t)
              , s = e.type
              , n = e.offset / 4
              , r = this.KEe;
            if ("color" === s) {
                if (i.Psi(r, n))
                    return;
                i._si(r, n),
                this.qEe = !0
            } else {
                if ("float" !== s && "percent" !== s)
                    throw new Error(`unexpected shader param type '${s}'`);
                if (r[n] === Math.fround(i))
                    return;
                r[n] = i,
                this.qEe = !0
            }
        }
        z$() {
            return this.qEe
        }
        cEe(t) {
            this.Tn().Uxe().AMe(t, this.Jgi, this.HEe, 0, this.WEe),
            this.qEe = !1
        }
    }
}
{
    const nP = self.t
      , rP = 4
      , hP = 2
      , oP = 4
      , aP = 2 * rP
      , lP = 4 * rP;
    function uP(t) {
        for (const i of Object.values(t))
            i.end = i.offset + i.size
    }
    const cP = "\nstruct Uniforms {\n\ttransform\t\t: mat4x4<f32>,\n\tpointTexStart\t: vec2<f32>,\n\tpointTexEnd\t\t: vec2<f32>,\n\tzElevation\t\t: f32\n};\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n"
      , dP = {
        transform: {
            offset: 0,
            size: 16 * rP,
            end: 0
        },
        vMe: {
            offset: 64,
            size: lP,
            end: 0
        },
        JEe: {
            offset: 64,
            size: aP,
            end: 0
        },
        ZEe: {
            offset: 72,
            size: aP,
            end: 0
        },
        SMe: {
            offset: 80,
            size: rP,
            end: 0
        }
    };
    uP(dP);
    const fP = dP.SMe.end
      , pP = "\nstruct Uniforms {\n\tcolor2\t\t\t\t: vec4<f32>,\n\tpointColor \t\t\t: vec4<f32>,\n\ttileSize\t\t\t: vec2<f32>,\n\ttileSpacing\t\t\t: vec2<f32>,\n\tsrcRectStart\t\t: vec2<f32>,\n\tsrcRectEnd\t\t\t: vec2<f32>,\n\tpixelSize\t\t\t: vec2<f32>,\n\toutlineThickness\t: f32\n};\n@binding(1) @group(0) var<uniform> uniforms : Uniforms;\n"
      , mP = {
        MMe: {
            offset: 0,
            size: lP,
            end: 0
        },
        EMe: {
            offset: 16,
            size: lP,
            end: 0
        },
        tEe: {
            offset: 32,
            size: aP,
            end: 0
        },
        iEe: {
            offset: 40,
            size: aP,
            end: 0
        },
        QMe: {
            offset: 48,
            size: lP,
            end: 0
        },
        QEe: {
            offset: 48,
            size: aP,
            end: 0
        },
        tCe: {
            offset: 56,
            size: aP,
            end: 0
        },
        JMe: {
            offset: 64,
            size: aP,
            end: 0
        },
        ZMe: {
            offset: 72,
            size: rP,
            end: 0
        }
    };
    uP(mP);
    const wP = mP.ZMe.end
      , gP = "\nstruct C3Params {\n\tsrcStart\t\t\t: vec2<f32>,\n\tsrcEnd\t\t\t\t: vec2<f32>,\n\tsrcOriginStart\t\t: vec2<f32>,\n\tsrcOriginEnd\t\t: vec2<f32>,\n\tlayoutStart\t\t\t: vec2<f32>,\n\tlayoutEnd\t\t\t: vec2<f32>,\n\tdestStart\t\t\t: vec2<f32>,\n\tdestEnd\t\t\t\t: vec2<f32>,\n\tdevicePixelRatio\t: f32,\n\tlayerScale\t\t\t: f32,\n\tlayerAngle\t\t\t: f32,\n\tseconds\t\t\t\t: f32,\n\tzNear\t\t\t\t: f32,\n\tzFar\t\t\t\t: f32,\n\tisSrcTexRotated\t\t: u32\n};\n@binding(4) @group(0) var<uniform> c3Params : C3Params;\n\nfn c3_srcToNorm(p : vec2<f32>) -> vec2<f32>\n{\n\treturn (p - c3Params.srcStart) / (c3Params.srcEnd - c3Params.srcStart);\n}\n\nfn c3_normToSrc(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p, c3Params.srcEnd - c3Params.srcStart, c3Params.srcStart);\n}\n\nfn c3_clampToSrc(p : vec2<f32>) -> vec2<f32>\n{\n\treturn clamp(p, min(c3Params.srcStart, c3Params.srcEnd), max(c3Params.srcStart, c3Params.srcEnd));\n}\n\nfn c3_srcOriginToNorm(p : vec2<f32>) -> vec2<f32>\n{\n\treturn (p - c3Params.srcOriginStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart);\n}\n\nfn c3_normToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p, c3Params.srcOriginEnd - c3Params.srcOriginStart, c3Params.srcOriginStart);\n}\n\nfn c3_clampToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n\treturn clamp(p, min(c3Params.srcOriginStart, c3Params.srcOriginEnd), max(c3Params.srcOriginStart, c3Params.srcOriginEnd));\n}\n\nfn c3_getLayoutPos(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p - c3Params.srcOriginStart, (c3Params.layoutEnd - c3Params.layoutStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart), c3Params.layoutStart);\n}\n\nfn c3_srcToDest(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p - c3Params.srcStart, (c3Params.destEnd - c3Params.destStart) / (c3Params.srcEnd - c3Params.srcStart), c3Params.destStart);\n}\n\nfn c3_clampToDest(p : vec2<f32>) -> vec2<f32>\n{\n\treturn clamp(p, min(c3Params.destStart, c3Params.destEnd), max(c3Params.destStart, c3Params.destEnd));\n}\n\nfn c3_linearizeDepth(depthSample : f32) -> f32\n{\n\treturn c3Params.zNear * c3Params.zFar / (c3Params.zFar + depthSample * (c3Params.zNear - c3Params.zFar));\n}\n"
      , yP = ["srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "c3_srcToNorm", "c3_normToSrc", "c3_clampToSrc", "c3_srcOriginToNorm", "c3_normToSrcOrigin", "c3_clampToSrcOrigin", "c3_getLayoutPos", "c3_srcToDest"]
      , bP = ["layoutStart", "layoutEnd", "destStart", "destEnd", "c3_clampToDest"]
      , vP = {
        QMe: {
            offset: 0,
            size: lP,
            end: 0
        },
        iCe: {
            offset: 0,
            size: aP,
            end: 0
        },
        eCe: {
            offset: 8,
            size: aP,
            end: 0
        },
        nEe: {
            offset: 16,
            size: lP,
            end: 0
        },
        sCe: {
            offset: 16,
            size: aP,
            end: 0
        },
        nCe: {
            offset: 24,
            size: aP,
            end: 0
        },
        rEe: {
            offset: 32,
            size: lP,
            end: 0
        },
        rCe: {
            offset: 32,
            size: aP,
            end: 0
        },
        hCe: {
            offset: 40,
            size: aP,
            end: 0
        },
        sEe: {
            offset: 48,
            size: lP,
            end: 0
        },
        oCe: {
            offset: 48,
            size: aP,
            end: 0
        },
        aCe: {
            offset: 56,
            size: aP,
            end: 0
        },
        devicePixelRatio: {
            offset: 64,
            size: rP,
            end: 0
        },
        hEe: {
            offset: 68,
            size: rP,
            end: 0
        },
        oEe: {
            offset: 72,
            size: rP,
            end: 0
        },
        Yoi: {
            offset: 76,
            size: rP,
            end: 0
        },
        aEe: {
            offset: 80,
            size: rP,
            end: 0
        },
        lEe: {
            offset: 84,
            size: rP,
            end: 0
        },
        mEe: {
            offset: 88,
            size: oP,
            end: 0
        }
    };
    uP(vP);
    const SP = vP.mEe.end;
    function xP(t) {
        return `\nstruct FragmentInput {\n\t@location(1) fragUV : vec2<f32>,\n\t@location(2) fragColor : vec4<${t ? "f16" : "f32"}>,\n\t@builtin(position) fragPos : vec4<f32>\n};\n\nfn c3_getBackUV(fragPos : vec2<f32>, texBack : texture_2d<f32>) -> vec2<f32>\n{\n\treturn fragPos / vec2<f32>(textureDimensions(texBack));\n}\n\nfn c3_getDepthUV(fragPos : vec2<f32>, texDepth : texture_depth_2d) -> vec2<f32>\n{\n\treturn fragPos / vec2<f32>(textureDimensions(texDepth));\n}\n`
    }
    const MP = "\nstruct FragmentOutput {\n\t@location(0) color : vec4<f32>\n};\n"
      , EP = new Map([["float", 4], ["percent", 4], ["color", 12]])
      , CP = new Map([["float", 4], ["percent", 4], ["color", 16]])
      , _P = "\nfn c3_premultiply(c : vec4<f32>) -> vec4<f32>\n{\n\treturn vec4<f32>(c.rgb * c.a, c.a);\n}\n\nfn c3_unpremultiply(c : vec4<f32>) -> vec4<f32>\n{\n\tif (c.a == 0.0)\n\t{\n\t\treturn vec4<f32>(0.0);\n\t}\n\t\n\treturn vec4<f32>(c.rgb / c.a, c.a);\n}\n\nfn c3_grayscale(rgb : vec3<f32>) -> f32\n{\n\treturn dot(rgb, vec3<f32>(0.299, 0.587, 0.114));\n}\n\nfn c3_getPixelSize(t : texture_2d<f32>) -> vec2<f32>\n{\n\treturn vec2<f32>(1.0) / vec2<f32>(textureDimensions(t));\n}\n\nfn c3_clamp2(v : vec2<f32>, l : f32, u : f32) -> vec2<f32>\n{\n\treturn clamp(v, vec2<f32>(l), vec2<f32>(u));\n}\n\nfn c3_mod(x : f32, y : f32) -> f32\n{\n\treturn x - y * floor(x / y);\n}\n\nfn c3_mod2(x : vec2<f32>, y : vec2<f32>) -> vec2<f32>\n{\n\treturn x - y * floor(x / y);\n}\n\nfn c3_RGBtoHSL(color : vec3<f32>) -> vec3<f32>\n{\n\tvar hsl : vec3<f32> = vec3<f32>(0.0);\n\t\n\tvar fmin : f32 = min(min(color.r, color.g), color.b);\n\tvar fmax : f32 = max(max(color.r, color.g), color.b);\n\tvar delta : f32 = fmax - fmin;\n\n\thsl.z = (fmax + fmin) / 2.0;\n\n\tif (delta == 0.0)\n\t{\n\t\thsl.x = 0.0;\n\t\thsl.y = 0.0;\n\t}\n\telse \n\t{\n\t\tif (hsl.z < 0.5)\n\t\t{\n\t\t\thsl.y = delta / (fmax + fmin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\n\t\t}\n\t\t\n\t\tvar dR : f32 = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n\t\tvar dG : f32 = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n\t\tvar dB : f32 = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n\t\tif (color.r == fmax)\n\t\t{\n\t\t\thsl.x = dB - dG;\n\t\t}\n\t\telse if (color.g == fmax)\n\t\t{\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\n\t\t}\n\t\telse if (color.b == fmax)\n\t\t{\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\n\t\t}\n\n\t\tif (hsl.x < 0.0)\n\t\t{\n\t\t\thsl.x = hsl.x + 1.0;\n\t\t}\n\t\telse if (hsl.x > 1.0)\n\t\t{\n\t\t\thsl.x = hsl.x - 1.0;\n\t\t}\n\t}\n\n\treturn hsl;\n}\n\nfn c3_hueToRGB(f1 : f32, f2 : f32, hue_ : f32) -> f32\n{\n\tvar hue : f32 = hue_;\n\tif (hue < 0.0)\n\t{\n\t\thue = hue + 1.0;\n\t}\n\telse if (hue > 1.0)\n\t{\n\t\thue = hue - 1.0;\n\t}\n\t\t\n\tvar ret : f32;\n\t\n\tif ((6.0 * hue) < 1.0)\n\t{\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\n\t}\n\telse if ((2.0 * hue) < 1.0)\n\t{\n\t\tret = f2;\n\t}\n\telse if ((3.0 * hue) < 2.0)\n\t{\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n\t}\n\telse\n\t{\n\t\tret = f1;\n\t}\n\t\n\treturn ret;\n}\n\nfn c3_HSLtoRGB(hsl : vec3<f32>) -> vec3<f32>\n{\n\tvar rgb : vec3<f32> = vec3<f32>(hsl.z);\n\t\n\tif (hsl.y != 0.0)\n\t{\n\t\tvar f2 : f32;\n\t\t\n\t\tif (hsl.z < 0.5)\n\t\t{\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\t\t}\n\t\t\t\n\t\tvar f1 : f32 = 2.0 * hsl.z - f2;\n\t\t\n\t\trgb.r = c3_hueToRGB(f1, f2, hsl.x + (1.0 / 3.0));\n\t\trgb.g = c3_hueToRGB(f1, f2, hsl.x);\n\t\trgb.b = c3_hueToRGB(f1, f2, hsl.x - (1.0 / 3.0));\n\t}\n\t\n\treturn rgb;\n}\n";
    function TP(t, i, e, s, n) {
        return t << 10 | i << 7 | e << 5 | s << 4 | n
    }
    nP.ea.hve = class extends nP.ea.c4i {
        constructor(t, i) {
            if (super(t, i),
            this.lCe = i.uCe,
            this.cCe = i.dCe,
            this.fCe = i.pCe,
            this.aSe = i.mCe,
            this.wCe = new Map,
            this.gCe = new Map,
            this.yCe = !1,
            this.bCe = !1,
            this.p9t = [],
            this.vCe = 0,
            i.parameters) {
                let t = 0;
                for (const e of i.parameters) {
                    const i = e[2];
                    if (!EP.has(i))
                        throw new Error(`unrecognized effect param type '${i}'`);
                    const s = EP.get(i)
                      , n = CP.get(i)
                      , r = t % n;
                    0 !== r && (t += n - r),
                    this.p9t.push({
                        type: i,
                        offset: t,
                        size: s,
                        end: t + s
                    }),
                    t += s
                }
                this.vCe = 16 * Math.ceil(t / 16)
            }
        }
        static async hP(t, i) {
            const e = t.Mxe()
              , s = i.name
              , n = t.NSe()
              , r = t.I6i()
              , h = i.src
              , o = nP.ea.hve.SCe(h, n, r)
              , a = e.createShaderModule({
                label: s,
                code: o
            });
            let l, u = null;
            if (i.WSe) {
                const t = nP.ea.hve.SCe(i.WSe, n, r);
                u = e.createShaderModule({
                    label: s,
                    code: t
                })
            }
            a.getCompilationInfo().then(t => nP.ea.hve.$Se(s, "fragment", t));
            const c = nP.ea.hve.jSe(i.b6i, n);
            let d;
            c ? (l = e.createShaderModule({
                label: s,
                code: c
            }),
            l.getCompilationInfo().then(t => nP.ea.hve.$Se(s, "vertex", t))) : l = t.Exe();
            const f = nP.ea.hve.jSe(i.KSe, n);
            f ? (d = e.createShaderModule({
                label: s,
                code: f
            }),
            d.getCompilationInfo().then(t => nP.ea.hve.$Se(s, "vertex (norm)", t))) : d = t.Cxe();
            const p = nP.v(nP.ea.hve, t, Object.assign({
                uCe: a,
                dCe: u,
                pCe: l,
                mCe: d
            }, i));
            if (p.P4i = h.includes("%%C3PARAMS_STRUCT%%") && yP.some(t => h.includes(t)),
            p.yCe = p.P4i || h.includes("%%C3PARAMS_STRUCT%%") && bP.some(t => h.includes(t)),
            p.bCe = h.includes("%%C3PARAMS_STRUCT%%") && h.includes("isSrcTexRotated"),
            "<generate-mipmap>" !== s) {
                const i = p.xCe(0, 0, 0, 0, 0);
                let e = null;
                t.Fxe() && (e = p.xCe(0, 1, 0, 0, 0));
                const [s,n] = await Promise.all([i, e]);
                p.wCe.set(TP(0, 0, 0, 0, 0), s),
                n && p.wCe.set(TP(0, 1, 0, 0, 0), n)
            }
            return p
        }
        static MCe(t, i) {
            if (!t)
                return t;
            let e = "";
            return e = i ? "enable f16;\nalias f16or32 = f16;\n" : "alias f16or32 = f32;\n",
            e + t
        }
        static SCe(t, i, e) {
            return t = nP.ea.hve.MCe(t, i),
            nP.joi(t, {
                "%%SAMPLERFRONT_BINDING%%": "@binding(0) @group(1)",
                "%%TEXTUREFRONT_BINDING%%": "@binding(1) @group(1)",
                "%%SAMPLERBACK_BINDING%%": "@binding(0) @group(2)",
                "%%TEXTUREBACK_BINDING%%": "@binding(1) @group(2)",
                "%%SAMPLERDEPTH_BINDING%%": "@binding(0) @group(3)",
                "%%TEXTUREDEPTH_BINDING%%": "@binding(1) @group(3)",
                "%%SHADERPARAMS_BINDING%%": "@binding(5) @group(0)",
                "%%FRAGMENTINPUT_STRUCT%%": xP(e),
                "%%FRAGMENTOUTPUT_STRUCT%%": MP,
                "%%C3PARAMS_STRUCT%%": gP,
                "%%C3_UTILITY_FUNCTIONS%%": _P
            })
        }
        static jSe(t, i) {
            return nP.ea.hve.MCe(t, i)
        }
        static $Se(t, i, e) {
            for (const s of e.messages) {
                const e = `[WebGPU] Message (${s.type}) compiling ${i} shader '${t}': ${s.message} (line ${s.lineNum}, pos ${s.linePos})`;
                "error" === s.type ? console.error(e) : "warning" === s.type ? (() => {})(e) : console.log(e)
            }
        }
        he() {
            this.lCe = null,
            this.cCe = null,
            this.fCe = null,
            this.aSe = null,
            this.wCe.clear(),
            this.gCe.clear(),
            super.he()
        }
        Mxe() {
            return this.cn.Mxe()
        }
        Axe() {
            return this.cn.Axe()
        }
        Tn() {
            return this.cn
        }
        eEe() {
            return this.yCe
        }
        $4i() {
            return this.bCe
        }
        VBt() {
            return this.p9t.length
        }
        p8i(t) {
            return t < 0 || t >= this.p9t.length ? null : this.p9t[t].type
        }
        VEe() {
            return this.vCe
        }
        YEe(t) {
            return this.p9t[t]
        }
        ECe(t, i, e, s, n) {
            const r = this.cn
              , h = r.I6i()
              , [o,a] = r.C3i(t);
            let l = "none";
            switch (e) {
            case 1:
                l = "back";
                break;
            case 2:
                l = "front"
            }
            const u = {
                label: `${this.La()} blendMode ${t} variant ${i} multisampleCount ${n}`,
                layout: this.Axe(),
                primitive: {
                    cullMode: l,
                    frontFace: 0 === s ? "cw" : "ccw"
                },
                vertex: {
                    module: 4 === i ? this.aSe : this.fCe,
                    entryPoint: "main",
                    buffers: [{
                        arrayStride: 3 * rP,
                        attributes: [{
                            shaderLocation: 0,
                            offset: 0,
                            format: "float32x3"
                        }]
                    }, {
                        arrayStride: 2 * rP,
                        attributes: [{
                            shaderLocation: 1,
                            offset: 0,
                            format: "float32x2"
                        }]
                    }, {
                        arrayStride: 4 * (h ? hP : rP),
                        attributes: [{
                            shaderLocation: 2,
                            offset: 0,
                            format: h ? "float16x4" : "float32x4"
                        }]
                    }, {
                        arrayStride: oP,
                        attributes: [{
                            shaderLocation: 3,
                            offset: 0,
                            format: "uint32"
                        }]
                    }]
                },
                fragment: {
                    module: this.lCe,
                    entryPoint: "main",
                    targets: [{
                        format: r._xe(),
                        blend: {
                            color: {
                                srcFactor: o,
                                dstFactor: a
                            },
                            alpha: {
                                srcFactor: o,
                                dstFactor: a
                            }
                        }
                    }]
                }
            };
            if (n >= 2 && (u.multisample = {
                count: n
            }),
            1 === i)
                u.fragment.module = this.cCe || this.lCe,
                u.depthStencil = {
                    format: r.bxe(),
                    depthWriteEnabled: !0,
                    depthCompare: "less-equal"
                };
            else if (2 === i) {
                u.fragment.module = this.cCe || this.lCe,
                u.fragment.targets = [];
                const t = {
                    compare: "always",
                    failOp: "keep",
                    depthFailOp: "keep",
                    passOp: "replace"
                };
                u.depthStencil = {
                    format: r.bxe(),
                    depthWriteEnabled: !0,
                    depthCompare: "less-equal",
                    stencilFront: t,
                    stencilBack: t,
                    stencilReadMask: 1,
                    stencilWriteMask: 1
                }
            } else if (3 === i) {
                u.fragment.module = this.cCe || this.lCe;
                const t = {
                    compare: "equal",
                    failOp: "keep",
                    depthFailOp: "keep",
                    passOp: "keep"
                };
                u.depthStencil = {
                    format: r.bxe(),
                    depthWriteEnabled: !1,
                    depthCompare: "always",
                    stencilFront: t,
                    stencilBack: t,
                    stencilReadMask: 1,
                    stencilWriteMask: 0
                }
            }
            return u
        }
        CCe(t, i, e, s, n) {
            return this.Mxe().createRenderPipeline(this.ECe(t, i, e, s, n))
        }
        xCe(t, i, e, s, n) {
            return this.Mxe().createRenderPipelineAsync(this.ECe(t, i, e, s, n))
        }
        rMe(t, i, e, s, n) {
            const r = TP(t, i, e, s, n);
            let h = this.wCe.get(r);
            return h || (h = this.CCe(t, i, e, s, n),
            this.wCe.set(r, h),
            h)
        }
        static rve() {
            return dP
        }
        static ave() {
            return 16 * Math.ceil(fP / 16)
        }
        static dve() {
            return mP
        }
        static pve() {
            return 16 * Math.ceil(wP / 16)
        }
        static yve() {
            return vP
        }
        static vve() {
            return 16 * Math.ceil(SP / 16)
        }
        static E8i(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\t${cP}\n\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\toutput.Position = uniforms.transform * vec4<f32>(input.position, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.fragColor = input.color;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\treturn output;\n\t\t}`
        }
        static zSe(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p = input.position;\n\t\t\tp.y = 1.0 - p.y;\n\t\t\toutput.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\toutput.fragColor = input.color;\n\t\t\treturn output;\n\t\t}`
        }
        static HSe(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\t${cP}\n\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\toutput.Position = uniforms.transform * vec4<f32>(input.position, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.fragColor = input.color;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\treturn output;\n\t\t}`
        }
        static qSe(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p = input.position;\n\t\t\tp.y = 1.0 - p.y;\n\t\t\toutput.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.fragColor = input.color;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\treturn output;\n\t\t}`
        }
        static VSe(t, i) {
            return `\n\t\t@binding(0) @group(1) var sampler0 : sampler;\n\t\t@binding(1) @group(1) var texture0 : texture_2d<f32>;\n\t\t@binding(2) @group(1) var sampler1 : sampler;\n\t\t@binding(3) @group(1) var texture1 : texture_2d<f32>;\n\t\t@binding(4) @group(1) var sampler2 : sampler;\n\t\t@binding(5) @group(1) var texture2 : texture_2d<f32>;\n\t\t@binding(6) @group(1) var sampler3 : sampler;\n\t\t@binding(7) @group(1) var texture3 : texture_2d<f32>;\n\t\t@binding(8) @group(1) var sampler4 : sampler;\n\t\t@binding(9) @group(1) var texture4 : texture_2d<f32>;\n\t\t@binding(10) @group(1) var sampler5 : sampler;\n\t\t@binding(11) @group(1) var texture5 : texture_2d<f32>;\n\t\t@binding(12) @group(1) var sampler6 : sampler;\n\t\t@binding(13) @group(1) var texture6 : texture_2d<f32>;\n\t\t@binding(14) @group(1) var sampler7 : sampler;\n\t\t@binding(15) @group(1) var texture7 : texture_2d<f32>;\n\t\t@binding(16) @group(1) var sampler8 : sampler;\n\t\t@binding(17) @group(1) var texture8 : texture_2d<f32>;\n\t\t@binding(18) @group(1) var sampler9 : sampler;\n\t\t@binding(19) @group(1) var texture9 : texture_2d<f32>;\n\t\t@binding(20) @group(1) var sampler10 : sampler;\n\t\t@binding(21) @group(1) var texture10 : texture_2d<f32>;\n\t\t@binding(22) @group(1) var sampler11 : sampler;\n\t\t@binding(23) @group(1) var texture11 : texture_2d<f32>;\n\t\t@binding(24) @group(1) var sampler12 : sampler;\n\t\t@binding(25) @group(1) var texture12 : texture_2d<f32>;\n\t\t@binding(26) @group(1) var sampler13 : sampler;\n\t\t@binding(27) @group(1) var texture13 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i ? "f16" : "f32"}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32,\n\t\t\t${t ? "@builtin(position) fragPos: vec4<f32>" : ""}\n\t\t};\n\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar texXy : vec2<f32> = input.fragUV.xy;\n\t\t\tvar texIndex : u32 = input.texIndex;\n\t\t\tvar c : vec4<f32>;\n\n\t\t\tlet dx = dpdx(texXy);\n\t\t\tlet dy = dpdy(texXy);\n\t\t\t\n\t\t\tif (texIndex <= 6)\n\t\t\t{\n\t\t\t\tif (texIndex <= 2)\n\t\t\t\t{\n\t\t\t\t\tif (texIndex == 0)\t\t\t{\tc = textureSampleGrad(texture0, sampler0, texXy, dx, dy);\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 1)\t\t{\tc = textureSampleGrad(texture1, sampler1, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture2, sampler2, texXy, dx, dy);\t}\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (texIndex <= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 3)\t\t{\tc = textureSampleGrad(texture3, sampler3, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture4, sampler4, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex <= 5)\t\t{\tc = textureSampleGrad(texture5, sampler5, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture6, sampler6, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (texIndex <= 9)\n\t\t\t\t{\n\t\t\t\t\tif (texIndex == 7)\t\t\t{\tc = textureSampleGrad(texture7, sampler7, texXy, dx, dy);\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 8)\t\t{\tc = textureSampleGrad(texture8, sampler8, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture9, sampler9, texXy, dx, dy);\t}\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (texIndex <= 11)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 10)\t\t{\tc = textureSampleGrad(texture10, sampler10, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture11, sampler11, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 12)\t\t{\tc = textureSampleGrad(texture12, sampler12, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture13, sampler13, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutput.color = c * vec4<f32>(input.fragColor);\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static XSe(t, i) {
            return `\n\t\t@binding(0) @group(1) var sampler0 : sampler;\n\t\t@binding(1) @group(1) var texture0 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i ? "f16" : "f32"}>,\n\t\t\t${t ? "@builtin(position) fragPos: vec4<f32>" : ""}\n\t\t};\n\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = textureSample(texture0, sampler0, input.fragUV) * vec4<f32>(input.fragColor);\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static JSe() {
            return "\n\t\tstruct VertexInput {\n\t\t\t@builtin(vertex_index) VertexIndex : u32\n\t\t};\n\t\t\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(0) fragUV : vec2<f32>\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\n\t\t\tvar pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n\t\t\t\tvec2<f32>(-1.0, 1.0),\n\t\t\t\tvec2<f32>(1.0, 1.0),\n\t\t\t\tvec2<f32>(-1.0, -1.0),\n\t\t\t\tvec2<f32>(1.0, -1.0));\n\t\t\t\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p : vec2<f32> = pos[input.VertexIndex];\n\t\t\toutput.Position = vec4<f32>(p, 0.0, 1.0);\n\t\t\toutput.fragUV = p / 2.0 + 0.5;\n\t\t\treturn output;\n\t\t}"
        }
        static YSe() {
            return "\n\t\t@binding(0) @group(0) var sampler0 : sampler;\n\t\t@binding(1) @group(0) var texture0 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(0) fragUV : vec2<f32>\n\t\t};\n\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>\n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = textureSample(texture0, sampler0, vec2<f32>(input.fragUV.x, 1.0 - input.fragUV.y));\n\t\t\treturn output;\n\t\t}"
        }
        lxe(t) {
            t || (t = this.cn.Oxe());
            let i = this.gCe.get(t);
            return i || (i = this.Mxe().createRenderPipeline({
                label: "<mipmap generator>",
                layout: "auto",
                vertex: {
                    module: this.fCe,
                    entryPoint: "main"
                },
                primitive: {
                    topology: "triangle-strip",
                    stripIndexFormat: "uint16"
                },
                fragment: {
                    module: this.lCe,
                    entryPoint: "main",
                    targets: [{
                        format: t,
                        blend: {
                            color: {
                                srcFactor: "one",
                                dstFactor: "zero"
                            },
                            alpha: {
                                srcFactor: "one",
                                dstFactor: "zero"
                            }
                        }
                    }]
                }
            }),
            this.gCe.set(t, i)),
            i
        }
        static QSe() {
            return `\n\t\t${cP}\n\n\t\tstruct PointData {\n\t\t\tdata : array<vec4<f32>>\n\t\t};\n\t\t@binding(3) @group(0) var<storage> pointBuffer : PointData;\n\n\t\tstruct VertexInput {\n\t\t\t@builtin(vertex_index) VertexIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(0) fragUV : vec2<f32>,\n\t\t\t@location(1) pointOpacity : f32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\n\t\t\tvar normPos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n\t\t\t\tvec2<f32>(-0.5, -0.5),\n\t\t\t\tvec2<f32>(0.5, -0.5),\n\t\t\t\tvec2<f32>(0.5, 0.5),\n\t\t\t\tvec2<f32>(-0.5, 0.5));\n\t\t\t\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p : vec2<f32> = normPos[input.VertexIndex % u32(4)];\n\t\t\tvar pointData : vec4<f32> = pointBuffer.data[input.VertexIndex / u32(4)];\n\n\t\t\tvar size : f32 = pointData.z;\n\t\t\toutput.Position = uniforms.transform * vec4<f32>(p * size + pointData.xy, uniforms.zElevation, 1.0);\n\t\t\toutput.pointOpacity = pointData.w;\n\n\t\t\tvar pointTexMin : vec2<f32> = min(uniforms.pointTexStart, uniforms.pointTexEnd);\n\t\t\tvar pointTexMax : vec2<f32> = max(uniforms.pointTexStart, uniforms.pointTexEnd);\n\t\t\tvar pn : vec2<f32> = p + vec2<f32>(0.5, 0.5);\n\t\t\tvar pointCoord : vec2<f32> = select(vec2<f32>(1.0 - pn.y, pn.x), pn, uniforms.pointTexEnd.x > uniforms.pointTexStart.x);\n\n\t\t\toutput.fragUV = mix(pointTexMin, pointTexMax, pointCoord);\n\t\t\treturn output;\n\t\t}`
        }
        static ZSe(t) {
            return `\n\t\t${pP}\n\n\t\t%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;\n\t\t%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(0) fragUV : vec2<f32>,\n\t\t\t@location(1) pointOpacity : f32,\n\t\t\t@builtin(position) fragPos : vec4<f32>\n\t\t};\n\t\t\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = textureSample(texture0, sampler0, input.fragUV) * uniforms.pointColor * input.pointOpacity;\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static txe(t) {
            return `\n\t\t${pP}\n\n\t\t%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;\n\t\t%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar halfPixelSize : vec2<f32> = vec2<f32>(0.5, 0.5) / vec2<f32>(textureDimensions(texture0));\n\n\t\t\tvar tile : vec2<f32> = floor(input.fragUV);\n\t\t\tvar tex : vec2<f32> = fract(input.fragUV);\n\t\t\tvar tileOrigin : vec2<f32> = uniforms.srcRectStart + tile * (uniforms.tileSize + uniforms.tileSpacing);\n\t\t\tvar lowerBound : vec2<f32> = tileOrigin + halfPixelSize;\n\t\t\tvar upperBound : vec2<f32> = tileOrigin + uniforms.tileSize - halfPixelSize;\n\n\t\t\toutput.color = textureSampleLevel(texture0, sampler0, clamp(tex, lowerBound, upperBound), 0.0) * vec4<f32>(input.fragColor);\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static R8i(t) {
            return `\n${pP}\n\n%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;\n%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;\n\n%%FRAGMENTINPUT_STRUCT%%\n\nstruct FragmentOutput {\n\t@location(0) color : vec4<f32>,\n\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n};\n\n%%C3_UTILITY_FUNCTIONS%%\n\nconst PI : f32 = 3.1415926;\n\nfn cospVec4(a : vec4<f32>, b : vec4<f32>, x : f32) -> vec4<f32>\n{\n\treturn (a + b + (a - b) * cos(x * PI)) / 2.0;\n}\n\nfn randVec3(seed : vec2<f32>) -> vec3<f32>\n{\n\treturn vec3<f32>(\n\t\tfract(sin(dot(seed.xy, vec2<f32>(12.9898,78.233))) * 43758.5453),\n\t\tfract(sin(dot(seed.yx, vec2<f32>(12.9898,-78.233))) * 43758.5453),\n\t\tfract(sin(dot(seed.xy, vec2<f32>(-12.9898,-78.233))) * 43758.5453));\n}\n\nfn sampleTile(tile : vec2<f32>, uv : vec2<f32>, ddx : vec2<f32>, ddy : vec2<f32>) -> vec4<f32>\n{\n\tvar posRandom = uniforms.tileSize;\n\tvar angleRandom = uniforms.outlineThickness;\n\tvar pixelSize = c3_getPixelSize(texture0);\n\t\n\tvar rand = (randVec3(round(tile)) - 0.5) * 2.0;\n\t\n\tvar angle = angleRandom * rand.z * PI;\n\tvar sin_a = sin(angle);\n\tvar cos_a = cos(angle);\n\tvar aspect = pixelSize.x / pixelSize.y;\n\n\tvar mid = tile + vec2<f32>(0.5, 0.5);\n\tvar dp = uv - mid;\n\tdp.x /= aspect;\n\tvar r = vec2<f32>(dp.x * cos_a - dp.y * sin_a,\n\t\t\t\t\t  dp.y * cos_a + dp.x * sin_a);\n\tr.x *= aspect;\n\n\tvar p = mid + r + (posRandom * rand.xy / 2.0);\n\t\n\treturn textureSampleGrad(texture0, sampler0, p, ddx, ddy);\n}\n\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\n\tvar output : FragmentOutput;\n\t\n\tvar blendMarginX = uniforms.tileSpacing.x;\n\tvar blendMarginY = uniforms.tileSpacing.y;\n\t\n\tvar tile = floor(input.fragUV);\n\tvar tex = fract(input.fragUV);\n\tvar ddx = dpdx(input.fragUV);\n\tvar ddy = dpdy(input.fragUV);\n\t\n\tvar curTile = sampleTile(tile, input.fragUV, ddx, ddy);\n\t\n\tvar inLeftMargin = (tex.x < blendMarginX);\n\tvar inRightMargin = (tex.x > 1.0 - blendMarginX);\n\tvar inTopMargin = (tex.y < blendMarginY);\n\tvar inBottomMargin = (tex.y > 1.0 - blendMarginY);\n\t\n\tif (inLeftMargin)\n\t{\n\t\tvar leftTile = sampleTile(tile + vec2<f32>(-1.0, 0.0), input.fragUV, ddx, ddy);\n\t\tvar leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;\n\t\tvar leftMixedTile = cospVec4(leftTile, curTile, leftMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tvar topTile =     sampleTile(tile + vec2<f32>(0.0,  -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topLeftTile = sampleTile(tile + vec2<f32>(-1.0, -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tvar bottomTile =     sampleTile(tile + vec2<f32>(0.0,  1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomLeftTile = sampleTile(tile + vec2<f32>(-1.0, 1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutput.color = leftMixedTile;\n\t\t}\n\t}\n\telse if (inRightMargin)\n\t{\n\t\tvar rightTile = sampleTile(tile + vec2(1.0, 0.0), input.fragUV, ddx, ddy);\n\t\tvar rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);\n\t\tvar rightMixedTile = cospVec4(curTile, rightTile, rightMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tvar topTile =      sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topRightTile = sampleTile(tile + vec2<f32>(1.0, -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tvar bottomTile =      sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomRightTile = sampleTile(tile + vec2<f32>(1.0, 1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutput.color = rightMixedTile;\n\t\t}\n\t}\n\telse if (inTopMargin)\n\t{\n\t\tvar topTile = sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);\n\t\toutput.color = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t}\n\telse if (inBottomMargin)\n\t{\n\t\tvar bottomTile = sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);\n\t\toutput.color = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t}\n\telse\n\t{\n\t\toutput.color = curTile;\n\t}\n\t\n\toutput.color *= vec4<f32>(input.fragColor);\n\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\treturn output;\n}\n`
        }
        static ixe() {
            return "\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = vec4<f32>(input.fragColor);\n\t\t\treturn output;\n\t\t}"
        }
        static exe() {
            return `\n\t\t${pP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\tfn fromLinear(linearRGB : vec3<f32>) -> vec3<f32>\n\t\t{\n\t\t\tvar cutoff : vec3<bool> = (linearRGB < vec3<f32>(0.0031308));\n\t\t\tvar higher : vec3<f32> = vec3<f32>(1.055) * pow(abs(linearRGB), vec3<f32>(1.0/2.4)) - 0.055;\n\t\t\tvar lower : vec3<f32> = linearRGB * 12.92;\n\t\t\treturn select(higher, lower, cutoff);\n\t\t}\n\n\t\tfn toLinear(sRGB : vec3<f32>) -> vec3<f32>\n\t\t{\n\t\t\tvar cutoff : vec3<bool> = (sRGB < vec3<f32>(0.04045));\n\t\t\tvar higher : vec3<f32> = pow(abs((sRGB + 0.055) / 1.055), vec3<f32>(2.4));\n\t\t\tvar lower : vec3<f32> = sRGB / 12.92;\n\t\t\treturn select(higher, lower, cutoff);\n\t\t}\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar linearGrad : vec3<f32> = mix(toLinear(vec3<f32>(input.fragColor.rgb)), toLinear(uniforms.color2.rgb), vec3<f32>(input.fragUV.x));\n\n\t\t\tvar a : f32 = mix(f32(input.fragColor.a), uniforms.color2.a, input.fragUV.x);\n\t\t\toutput.color = vec4<f32>(fromLinear(linearGrad) * a, a);\n\t\t\treturn output;\n\t\t}\n\t\t`
        }
        static sxe() {
            return `\n\t\t${pP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar grad : f32 = input.fragUV.x / (1.0 - input.fragUV.y);\n\t\t\toutput.color = vec4<f32>(input.fragColor) * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);\n\t\t\treturn output;\n\t\t}\n\t\t`
        }
        static nxe() {
            return "\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\n\t\t\tvar f : f32 = step(diffSq.x + diffSq.y, 0.25);\n\n\t\t\toutput.color = vec4<f32>(input.fragColor) * f;\n\t\t\treturn output;\n\t\t}"
        }
        static rxe() {
            return `\n\t\t${pP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\t\t\tvar distSq : f32 = diffSq.x + diffSq.y;\n\t\t\tvar norm : vec2<f32> = normalize(diff);\n\t\t\tvar halfNorm : vec2<f32> = norm * 0.5;\n\n\t\t\tvar innerF : f32 = step(distSq, 0.25);\n\n\t\t\tvar innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm * uniforms.outlineThickness;\n\t\t\tvar innerEdgeSq : vec2<f32> = innerEdge * innerEdge;\n\t\t\tvar outerF : f32 = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\t\t\t\n\t\t\toutput.color = vec4<f32>(input.fragColor) * innerF * outerF;\n\t\t\treturn output;\n\t\t}`
        }
        static hxe() {
            return `\n\t\t${pP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\t\t\tvar norm : vec2<f32> = normalize(diff);\n\t\t\tvar halfNorm : vec2<f32> = norm * 0.5;\n\t\t\tvar halfNormSq : vec2<f32> = halfNorm * halfNorm;\n\n\t\t\tvar innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm;\n\t\t\tvar innerEdgeSq : vec2<f32> = innerEdge * innerEdge;\n\n\t\t\tvar f : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\n\t\t\toutput.color = vec4<f32>(input.fragColor) * f;\n\t\t\treturn output;\n\t\t}`
        }
        static oxe() {
            return `\n\t\t${pP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\t\t\tvar distSq : f32 = diffSq.x + diffSq.y;\n\t\t\tvar norm : vec2<f32> = normalize(diff);\n\t\t\tvar halfNorm : vec2<f32> = norm * 0.5;\n\t\t\tvar halfNormSq : vec2<f32> = halfNorm * halfNorm;\n\n\t\t\tvar pxNorm : vec2<f32> = uniforms.pixelSize * norm;\n\t\t\tvar innerEdge1 : vec2<f32> = halfNorm - pxNorm;\n\t\t\tvar innerEdge1Sq : vec2<f32> = innerEdge1 * innerEdge1;\n\n\t\t\tvar innerF : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\n\t\t\tvar innerEdge2 : vec2<f32> = halfNorm - pxNorm * uniforms.outlineThickness;\n\t\t\tvar innerEdge2Sq : vec2<f32> = innerEdge2 * innerEdge2;\n\t\t\tvar innerEdge3 : vec2<f32> = halfNorm - pxNorm * (uniforms.outlineThickness + 1.0);\n\t\t\tvar innerEdge3Sq : vec2<f32> = innerEdge3 * innerEdge3;\n\n\t\t\tvar outerF : f32 = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\t\t\t\n\t\t\toutput.color = vec4<f32>(input.fragColor) * innerF * outerF;\n\t\t\treturn output;\n\t\t}`
        }
        static axe() {
            return "\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar f : f32 = 1.0 - abs(input.fragUV.y - 0.5) * 2.0;\n\t\t\toutput.color = vec4<f32>(input.fragColor) * f;\n\t\t\treturn output;\n\t\t}"
        }
    }
}
{
    const IP = self.t
      , PP = new Set(["nearest", "bilinear", "trilinear"])
      , GP = new Set(["clamp-to-edge", "repeat", "mirror-repeat"])
      , AP = self.GPUTextureUsage
      , RP = {
        kn: "clamp-to-edge",
        Rn: "clamp-to-edge",
        Mn: "trilinear",
        On: 0,
        yS: !0,
        _Ce: !1,
        K9i: !1,
        kU: !1,
        TCe: !1,
        X9i: 0,
        width: -1,
        height: -1
    }
      , kP = [[1, ["r8unorm", "r8snorm", "r8uint", "r8sint", "stencil8"]], [2, ["r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "depth16unorm"]], [3, ["depth24plus"]], [4, ["r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2uint", "rgb10a2unorm", "rg11b10ufloat", "depth24plus-stencil8", "depth32float"]], [8, ["rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float"]], [16, ["rgba32uint", "rgba32sint", "rgba32float"]], [5, ["depth32float-stencil8"]]]
      , OP = new Map;
    for (const [LP,BP] of kP)
        for (const UP of BP)
            OP.set(UP, LP);
    const DP = new Set
      , FP = {
        E9i: !0,
        flipY: !1
    };
    IP.ea.DSe = class {
        constructor(t, i) {
            this.cn = t,
            this.tn = null,
            this.oqi = "",
            this.ICe = null,
            this.PCe = null,
            this.GCe = null,
            this.ACe = null,
            this.Fx = 0,
            this.Ex = 0,
            this._9i = !0,
            this.lC = "clamp-to-edge",
            this.hC = "clamp-to-edge",
            this.T9i = "trilinear",
            this.I9i = 0,
            this.G9i = !1,
            this.Byi = 0,
            this.RCe = !1,
            this.Pwe = !1,
            this.kCe = !1,
            this.OCe = !1,
            this.Gwe = 0,
            this.DCe = 0,
            this.FCe = !0,
            this.LCe = null,
            this.BCe = 0,
            this.UCe = !!i,
            this.UCe && (this.oqi = this.cn._xe(),
            this.RCe = !0,
            this.Pwe = !0,
            this.PCe = this.cn.vxe({
                Mn: "nearest"
            }))
        }
        NCe(t) {
            if (IP.zt(t.kn),
            IP.zt(t.Rn),
            IP.Ge(t.On),
            this.lC = t.kn,
            this.hC = t.Rn,
            this.T9i = t.Mn,
            this.I9i = t.On,
            this.G9i = !!t.yS && this.cn.s4i() && "nearest" !== t.Mn,
            this.RCe = !!t._Ce,
            this.Pwe = !!t.K9i,
            this.kCe = !!t.kU,
            this.OCe = !!t.TCe,
            this.Gwe = this.cn.qMe(t.X9i),
            !PP.has(this.T9i))
                throw new Error("invalid sampling");
            if (!GP.has(this.lC) || !GP.has(this.hC))
                throw new Error("invalid wrap mode");
            if (this.Gwe >= 2 && this.Pwe)
                throw new Error("invalid use of multisampling");
            "nearest" === this.T9i && (this.I9i = 0),
            this.PCe = this.cn.vxe({
                kn: this.lC,
                Rn: this.hC,
                Mn: this.T9i,
                On: this.I9i
            }),
            this.jCe(),
            this.Byi = 1
        }
        jCe() {
            const t = this.cn
              , i = t.Mxe();
            this.DCe = 0,
            this.RCe ? (this.DCe = AP.RENDER_ATTACHMENT,
            this.Pwe && (this.DCe |= AP.TEXTURE_BINDING),
            this.OCe && (this.DCe |= AP.COPY_DST),
            this.oqi = this.cn._xe()) : (this.DCe = AP.COPY_DST | AP.TEXTURE_BINDING,
            this.oqi = this.cn.Oxe()),
            this.kCe && (this.DCe |= AP.COPY_SRC),
            this.tn = i.createTexture({
                size: [this.Fx, this.Ex, 1],
                mipLevelCount: this.$Ce(),
                format: this.oqi,
                usage: this.DCe,
                sampleCount: this.Gwe >= 2 ? this.Gwe : 1
            }),
            this.ICe = this.tn.createView();
            const e = []
              , s = IP.ea.USe.BSe();
            for (let t = 0; t < s; ++t)
                e.push({
                    binding: 2 * t,
                    resource: this.PCe
                }, {
                    binding: 2 * t + 1,
                    resource: this.ICe
                });
            this.RCe && !this.Pwe || (this.GCe = i.createBindGroup({
                layout: t.Rxe(),
                entries: e
            }),
            this.ACe = i.createBindGroup({
                layout: t.kxe(),
                entries: [{
                    binding: 0,
                    resource: this.cn.vxe({
                        Mn: "nearest"
                    })
                }, {
                    binding: 1,
                    resource: this.ICe
                }]
            })),
            this.zCe() && this.$xe(!0),
            DP.add(this)
        }
        VCe() {
            DP.delete(this),
            this.LCe && this.LCe.he(),
            this.$xe(!1),
            this.tn.destroy(),
            this.tn = null,
            this.ICe = null,
            this.GCe = null,
            this.ACe = null
        }
        static Nxe(t) {
            return t instanceof ImageBitmap || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas
        }
        static WCe(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || t instanceof ImageData
        }
        HCe(t) {
            return [t.width || t.videoWidth, t.height || t.videoHeight]
        }
        Jue(t, i) {
            if (t && !IP.ea.DSe.Nxe(t))
                throw new TypeError("invalid texture source");
            if (IP.kQ(i),
            i = Object.assign({}, RP, i),
            this.tn)
                throw new Error("already created texture");
            if (this._9i = !0,
            t) {
                const [i,e] = this.HCe(t);
                this.Fx = i,
                this.Ex = e
            } else if (IP.Ge(i.width),
            IP.Ge(i.height),
            this.Fx = i.width,
            this.Ex = i.height,
            this.Fx <= 0 || this.Ex <= 0)
                throw new Error("invalid texture size");
            if (this.NCe(i),
            this.RCe || this.Pwe)
                throw new Error("static texture cannot be render target");
            t && this.KCe(t)
        }
        KCe(t, i=!0) {
            if (this.G9i)
                this.qCe(t, this.$Ce(), i);
            else {
                const e = this.cn.Mxe()
                  , s = e.createCommandEncoder()
                  , n = e.createTexture({
                    size: [this.Fx, this.Ex, 1],
                    mipLevelCount: 1,
                    format: this.oqi,
                    usage: AP.COPY_SRC | AP.COPY_DST | AP.RENDER_ATTACHMENT
                });
                this.XCe(n, t, 0, i),
                s.copyTextureToTexture({
                    texture: n,
                    mipLevel: 0
                }, {
                    texture: this.tn,
                    mipLevel: 0
                }, [this.Fx, this.Ex, 1]),
                e.queue.submit([s.finish()]),
                n.destroy()
            }
        }
        XCe(t, i, e, s=!0) {
            const [n,r] = this.HCe(i);
            this.cn.Mxe().queue.copyExternalImageToTexture({
                source: i
            }, {
                texture: t,
                mipLevel: e,
                premultipliedAlpha: !!s
            }, [n, r, 1])
        }
        $Ce() {
            return this.G9i ? Math.floor(Math.log2(Math.max(this.Fx, this.Ex)) + 1) : 1
        }
        qCe(t, i, e=!0) {
            const s = this.cn.Mxe()
              , n = s.createTexture({
                size: [this.Fx, this.Ex, 1],
                mipLevelCount: this.$Ce(),
                format: this.oqi,
                usage: AP.COPY_DST | AP.COPY_SRC | AP.TEXTURE_BINDING | AP.RENDER_ATTACHMENT
            })
              , r = this.cn.lxe()
              , h = r.getBindGroupLayout(0)
              , o = this.cn.vxe({
                Mn: "bilinear"
            })
              , a = s.createCommandEncoder();
            this.XCe(n, t, 0, e),
            a.copyTextureToTexture({
                texture: n,
                mipLevel: 0
            }, {
                texture: this.tn,
                mipLevel: 0
            }, [this.Fx, this.Ex, 1]);
            const l = [];
            for (let t = 0; t < i; ++t)
                l.push(n.createView({
                    baseMipLevel: t,
                    mipLevelCount: 1
                }));
            let u = this.Fx
              , c = this.Ex;
            for (let t = 1; t < i; ++t) {
                u /= 2,
                c /= 2;
                const i = Math.max(Math.floor(u), 1)
                  , e = Math.max(Math.floor(c), 1)
                  , d = a.beginRenderPass({
                    colorAttachments: [{
                        view: l[t],
                        loadOp: "clear",
                        clearValue: [0, 0, 0, 0],
                        storeOp: "store"
                    }]
                })
                  , f = s.createBindGroup({
                    layout: h,
                    entries: [{
                        binding: 0,
                        resource: o
                    }, {
                        binding: 1,
                        resource: l[t - 1]
                    }]
                });
                d.setPipeline(r),
                d.setBindGroup(0, f),
                d.draw(4),
                d.end(),
                a.copyTextureToTexture({
                    texture: n,
                    mipLevel: t
                }, {
                    texture: this.tn,
                    mipLevel: t
                }, [i, e, 1])
            }
            s.queue.submit([a.finish()]),
            n.destroy()
        }
        L9i(t, i, e) {
            if (IP.Ge(t),
            IP.Ge(i),
            IP.kQ(e),
            e = Object.assign({}, RP, e),
            this.tn)
                throw new Error("already created texture");
            this._9i = !1,
            this.Fx = t,
            this.Ex = i,
            this.NCe(e)
        }
        async Pbt(t, i) {
            if (!IP.ea.DSe.Nxe(t) && !IP.ea.DSe.WCe(t))
                throw new Error("invalid texture source");
            if (!this.tn || this.Byi <= 0)
                throw new Error("texture not created");
            if (this._9i)
                throw new Error("cannot update static texture");
            if (IP.kQ(i),
            i = Object.assign({}, FP, i),
            (IP.ea.DSe.WCe(t) || i.flipY || !i.E9i) && (t = await createImageBitmap(t, {
                premultiplyAlpha: i.E9i ? "premultiply" : "none",
                imageOrientation: i.flipY ? "flipY" : "none"
            }),
            !this.tn))
                return;
            this.cn.Q3i();
            const [e,s] = this.HCe(t);
            this.Fx === e && this.Ex === s || (this.VCe(),
            this.Fx = e,
            this.Ex = s,
            this.jCe(),
            this.cn.VMe(this)),
            this.KCe(t, i.E9i)
        }
        ZEt() {
            if (this.Byi > 0)
                throw new Error("texture still has references");
            if (!this.tn)
                throw new Error("already deleted texture");
            this.VCe()
        }
        yxe() {
            this.FCe = !1,
            this.$xe(!1)
        }
        zCe() {
            return this._9i && this.FCe && !this.RCe
        }
        $xe(t) {
            this.cn.$xe(this, t)
        }
        YCe(t, i) {
            if (this.LCe)
                throw new Error("already in a group");
            this.LCe = t,
            this.BCe = i,
            this.$xe(!1)
        }
        JCe() {
            this.LCe = null,
            this.BCe = 0,
            this.zCe() && this.$xe(!0)
        }
        wxe() {
            return this.GCe
        }
        gxe() {
            return this.ACe
        }
        jMe() {
            return null !== this.LCe ? this.LCe.ZCe() : this.zCe() ? (this.cn.Vxe(this),
            null !== this.LCe ? this.LCe.ZCe() : null) : null
        }
        zMe() {
            return this.BCe
        }
        ns() {
            return this.UCe ? this.cn.ns() : this.Fx
        }
        er() {
            return this.UCe ? this.cn.er() : this.Ex
        }
        Tn() {
            return this.cn
        }
        u7i() {
            return this.tn
        }
        uMe() {
            return this.ICe
        }
        kMe() {
            return this.oqi
        }
        vxe() {
            return this.PCe
        }
        Sn() {
            return this.T9i
        }
        DU() {
            return "nearest" !== this.T9i
        }
        Bxe() {
            return this.RCe
        }
        Uwe() {
            return this.Pwe
        }
        OMe() {
            return this.kCe
        }
        $9i() {
            this.Byi++
        }
        z9i() {
            if (this.Byi <= 0)
                throw new Error("no more references");
            this.Byi--
        }
        V9i() {
            return this.Byi
        }
        KMe() {
            return this.DCe
        }
        Sxe(t, i) {
            this.DCe = t,
            this.oqi = i
        }
        Kxe() {
            const t = this.cn
              , i = t.Mxe();
            this.tn = t.Txe(),
            this.ICe = t.Ixe(),
            t.Pxe() && (this.ACe = i.createBindGroup({
                layout: t.kxe(),
                entries: [{
                    binding: 0,
                    resource: this.PCe
                }, {
                    binding: 1,
                    resource: this.ICe
                }]
            }))
        }
        Jxe() {
            this.tn = null,
            this.ICe = null,
            this.ACe = null
        }
        WE() {
            let t = this.ns() * this.er() * IP.ea.DSe.Dxe(this.kMe());
            return this.G9i && (t += Math.floor(t / 3)),
            t
        }
        static ks() {}
        static H9i() {
            return DP.values()
        }
        static Dxe(t) {
            const i = OP.get(t);
            return "number" == typeof i ? i : NaN
        }
    }
}
{
    const NP = self.t;
    NP.ea.USe = class {
        constructor(t, i) {
            if (NP.RH(i),
            i.length < 2)
                throw new Error("invalid multi-texture group");
            this.cn = t,
            this.QCe = i,
            this.t_e = null;
            for (let t = 0, e = i.length; t < e; ++t)
                i[t].YCe(this, t);
            i.length < NP.ea.USe.BSe() && this.cn.zxe(this, !0),
            this.i_e()
        }
        he() {
            this.cn.zxe(this, !1);
            for (const t of this.QCe)
                t.JCe();
            this.e_e(),
            NP.Io(this.QCe),
            this.cn = null
        }
        i_e() {
            this.e_e();
            const t = this.cn.Mxe()
              , i = []
              , e = NP.ea.USe.BSe();
            for (let t = 0; t < e; ++t) {
                const e = this.QCe[Math.min(t, this.QCe.length - 1)];
                i.push({
                    binding: 2 * t,
                    resource: e.vxe()
                }, {
                    binding: 2 * t + 1,
                    resource: e.uMe()
                })
            }
            this.t_e = t.createBindGroup({
                layout: this.cn.Rxe(),
                entries: i
            })
        }
        e_e() {
            null !== this.t_e && this.cn.WMe(this.t_e),
            this.t_e = null
        }
        ZCe() {
            return this.t_e
        }
        static BSe() {
            return 14
        }
    }
}
{
    const jP = self.t
      , $P = self.r_
      , zP = ($P.l_,
    $P.o_)
      , VP = {
        Mn: "trilinear",
        alpha: !0,
        fU: !1,
        K9i: !0,
        kU: !1,
        TCe: !1,
        q9i: !0,
        X9i: 0
    }
      , WP = new Set;
    jP.ea.FSe = class {
        constructor(t, i) {
            jP.U(t, jP.ea.wU),
            this.cn = t,
            this.s_e = !!i,
            this.Twe = !!i && t.Fxe(),
            this.n_e = null,
            this.Ewe = !0,
            this.Gwe = 0,
            this.r_e = !1,
            this.h_e = jP.v(jP.za),
            this.Rwe = zP.create(),
            this.GM = 0,
            this.OM = 0,
            this.RM = 0,
            this.s_e && (this.n_e = jP.v(jP.ea.DSe, t, !0))
        }
        Jue(t, i, e) {
            if (jP.Ge(t),
            jP.Ge(i),
            jP.kQ(e),
            e = Object.assign({}, VP, e),
            self.assert(!this.s_e, "do not create backbuffer"),
            this.n_e)
                throw new Error("already created render target");
            if (this.Twe = !!e.fU,
            this.Ewe = !!e.q9i,
            this.Gwe = this.cn.qMe(e.X9i),
            this.Gwe >= 2 && e.K9i)
                throw new Error("invalid use of multisampling");
            this.n_e = this.cn.jR(t, i, {
                Mn: e.Mn,
                yS: !1,
                _Ce: !0,
                K9i: e.K9i,
                kU: e.kU,
                TCe: e.TCe,
                X9i: this.Gwe
            }),
            this.Owe(),
            WP.add(this)
        }
        ZEt() {
            WP.delete(this),
            this.n_e.VCe(),
            this.n_e = null,
            this.cn = null
        }
        Fwe(t, i) {
            if (t === this.ns() && i === this.er())
                return;
            const e = this.n_e.Sn()
              , s = this.n_e.Uwe()
              , n = this.n_e.OMe();
            this.n_e.VCe(),
            this.n_e = null,
            this.n_e = this.cn.jR(t, i, {
                Mn: e,
                yS: !1,
                _Ce: !0,
                K9i: s,
                kU: n
            }),
            this.Owe()
        }
        uMe() {
            return this.s_e ? this.cn.Ixe() : this.n_e.uMe()
        }
        Owe() {
            this.cn.bR(this.Rwe, this.ns() / this.er()),
            this.GM = this.cn.r3i(),
            this.OM = this.cn.fE(),
            this.RM = this.cn.uE()
        }
        $we() {
            return this.Ewe
        }
        Lxe() {
            return this.s_e
        }
        Nwe() {
            return this.Twe
        }
        ns() {
            return this.s_e ? this.cn.ns() : this.n_e.ns()
        }
        er() {
            return this.s_e ? this.cn.er() : this.n_e.er()
        }
        jn() {
            if (this.n_e)
                return this.n_e;
            throw new Error("no texture")
        }
        Tn() {
            return this.cn
        }
        zwe() {
            return this.Gwe
        }
        Lwe() {
            return this.cn.r3i() === this.GM && this.cn.fE() === this.OM && this.cn.uE() === this.RM || this.Owe(),
            this.Rwe
        }
        DU() {
            return this.n_e.DU()
        }
        Uwe() {
            return this.n_e.Uwe()
        }
        OMe() {
            return this.n_e.OMe()
        }
        Vwe(t) {
            return "nearest" !== (t = Object.assign({}, VP, t)).Mn === this.DU() && (!!t.K9i === this.Uwe() && (!!t.kU === this.OMe() && (!!t.fU === this.Nwe() && ("number" == typeof t.width || "number" == typeof t.height ? !this.$we() && this.ns() === Math.floor(t.width) && this.er() === Math.floor(t.height) : this.$we()))))
        }
        fMe(t) {
            this.r_e = !!t
        }
        qxe() {
            return this.r_e
        }
        cMe() {
            return this.h_e
        }
        static ks() {}
        static qwe() {
            return WP.values()
        }
    }
}
{
    const HP = self.t;
    HP.ea.Qxe = class {
        constructor(t, i) {
            HP.U(t, HP.ea.wU),
            HP.Ge(i),
            this.cn = t,
            this.Z2i = this.cn.t4i(),
            this.o_e = i;
            const e = this.cn.Mxe();
            this.a_e = e.createQuerySet({
                count: this.o_e,
                type: "timestamp"
            });
            const s = self.GPUBufferUsage;
            this.l_e = e.createBuffer({
                size: this.u_e(),
                usage: s.QUERY_RESOLVE | s.COPY_SRC
            }),
            this.c_e = e.createBuffer({
                size: this.u_e(),
                usage: s.COPY_DST | s.MAP_READ
            }),
            this.tge = null
        }
        u_e() {
            return 8 * this.o_e
        }
        pMe() {
            return this.a_e
        }
        wMe(t) {
            t.resolveQuerySet(this.a_e, 0, this.o_e, this.l_e, 0),
            t.copyBufferToBuffer(this.l_e, 0, this.c_e, 0, this.u_e())
        }
        async yMe() {
            const t = this.u_e();
            await this.c_e.mapAsync(self.GPUMapMode.READ, 0, t);
            const i = this.c_e.getMappedRange(0, t);
            this.tge = new BigUint64Array(i.slice(0)),
            this.c_e.destroy(),
            this.c_e = null,
            this.l_e.destroy(),
            this.l_e = null,
            this.a_e.destroy(),
            this.a_e = null
        }
        sge() {
            return null !== this.tge
        }
        nge() {
            if (!this.tge)
                throw new Error("not yet got result");
            return this.tge
        }
        t4i() {
            return this.Z2i
        }
    }
}
{
    const KP = self.t
      , qP = {
        d_e: null,
        KW: null,
        BW: null,
        getTime: null,
        ZW: null
    };
    KP.ea.VW = class {
        constructor(t) {
            t = Object.assign({}, qP, t),
            KP.tot(t.d_e),
            KP.nu(t.KW),
            KP.nu(t.BW),
            KP.nu(t.getTime),
            KP.nu(t.ZW),
            this.f_e = t.d_e,
            this.p_e = t.KW,
            this.m_e = t.BW,
            this.w_e = t.getTime,
            this.g_e = t.ZW,
            this.y_e = null,
            this.b_e = new Set
        }
        v_e(t) {
            this.b_e.add(t)
        }
        S_e(t) {
            this.b_e.delete(t)
        }
        ks() {
            this.y_e = null;
            for (const t of this.b_e)
                t.ks()
        }
        x_e(t) {
            return this.f_e ? this.f_e(t) : [t.ns(), t.er()]
        }
        fbe(t) {
            return this.p_e(t)
        }
        M_e(t, i) {
            this.m_e(t, i)
        }
        BV() {
            return this.w_e()
        }
        qut(t) {
            this.g_e(t)
        }
        E_e(t, i, e) {
            return i = Math.floor(i),
            e = Math.floor(e),
            !this.y_e || this.y_e.ns() === i && this.y_e.er() === e || (t.mn(this.y_e),
            this.y_e = null),
            null === this.y_e && (this.y_e = t.Pn(null, {
                width: i,
                height: e,
                Mn: "nearest",
                yS: !1
            })),
            this.y_e
        }
    }
}
{
    const XP = self.t
      , YP = self.assert
      , JP = self.r_.o_
      , ZP = XP.v(XP.Rect)
      , QP = XP.v(XP.Rect)
      , tG = XP.v(XP.Rect)
      , iG = XP.v(XP.Rect)
      , eG = JP.create()
      , sG = JP.create()
      , nG = {
        C_e: null,
        __e: null,
        T_e: null,
        I_e: !1
    }
      , rG = {
        P_e: null,
        G_e: !1,
        A_e: !1,
        R_e: !1,
        k_e: !1,
        O_e: !1,
        D_e: !1
    };
    XP.ea.F_e = class {
        constructor(t, i) {
            XP.U(t, XP.ea.VW),
            i = Object.assign({}, nG, i),
            XP.nu(i.C_e),
            XP.tot(i.__e),
            XP.nu(i.T_e),
            this.xyi = t,
            this.L_e = i.C_e,
            this.B_e = i.__e,
            this.U_e = i.T_e,
            this.N_e = null,
            this.j_e = [],
            this.$_e = [],
            this.vWi = [],
            this.z_e = !1,
            this.S1i = 0,
            this.V_e = !1,
            this.W_e = !1,
            this.H_e = !1,
            this.K_e = !1,
            this.q_e = !1,
            this.X_e = !1,
            this.Pge = !1,
            this.Y_e = !1,
            this.J_e = !1,
            this.Z_e = !1,
            this.Q_e = !1,
            this.tTe = !1,
            this.iTe = 0,
            this.eTe = [null, null, null],
            this.sTe = !!i.I_e,
            this.nTe = 0,
            this.rTe = 0,
            this.hTe = 0,
            this.oTe = 0,
            this.aTe = null,
            this.lTe = null,
            this.uTe = XP.v(XP.Rect),
            this.cTe = XP.v(XP.Rect),
            this.dTe = XP.v(XP.Rect),
            this.fTe = XP.v(XP.Rect),
            this.pTe = XP.v(XP.Rect),
            this.vo = 1,
            this.mTe = 1,
            this.wTe = 0,
            this.Fe = 0,
            this.gTe = null,
            this.yTe = null,
            this.bTe = 0,
            this.vTe = 0,
            this.STe = 0,
            this.xTe = 0,
            this.MTe = !1,
            this.Rwe = JP.create(),
            this.ETe = JP.create(),
            this.xyi.v_e(this)
        }
        he() {
            this.xyi.S_e(this),
            XP.Io(this.vWi),
            XP.Io(this.j_e),
            XP.Io(this.$_e),
            this.aTe = null,
            this.lTe = null,
            this.L_e = null,
            this.B_e = null,
            this.U_e = null
        }
        ks() {
            this.z_e = !0,
            XP.Io(this.vWi),
            XP.Io(this.j_e),
            XP.Io(this.$_e)
        }
        CTe() {
            return this.z_e
        }
        _Te(t, i) {
            if (XP.RH(t),
            XP.kQ(i),
            i = Object.assign({}, rG, i),
            XP.Io(this.vWi),
            this.nTe = 0,
            this.rTe = 0,
            this.V_e = !1,
            this.W_e = !1,
            this.H_e = !1,
            this.K_e = !1,
            this.q_e = !1,
            this.X_e = !1,
            this.iTe = 0,
            this.tTe = !!i.k_e,
            this.Q_e = !!i.D_e,
            this.z_e = !1,
            XP.mf(this.j_e, t),
            0 === t.length)
                return;
            if (i.P_e) {
                if (XP.RH(i.P_e),
                i.P_e.length !== t.length)
                    throw new Error("incorrect indexMap length");
                XP.mf(this.$_e, i.P_e)
            } else {
                XP.Io(this.$_e);
                for (let i = 0, e = t.length; i < e; ++i)
                    this.$_e.push(i)
            }
            for (const i of t)
                this.nTe += i.R4i(),
                this.rTe += i.k4i(),
                i.L4i() && (this.V_e = !0),
                i.U4i() && (this.W_e = !0),
                i.B4i() && (this.H_e = !0),
                i.O4i() && (this.K_e = !0),
                i.$4i() && (this.q_e = !0);
            this.X_e = this.TTe(t[0].Tn());
            const e = this.ITe(t[0], i)
              , s = this.PTe(t.at(-1), i);
            if (1 === t.length && !e && !s)
                return void (this.Z_e = !0);
            this.Z_e = !1;
            let n = 0;
            e && (this.iTe = 1,
            this.vWi.push(XP.v(XP.ea.F_e.ATe.GTe, this, -1, 1)),
            n = 1);
            for (let i = 0, r = t.length; i < r; ++i)
                if (0 !== i || e) {
                    let t = 1 === n ? 2 : 1;
                    i !== r - 1 || s || (t = 0),
                    this.iTe = Math.max(this.iTe, t),
                    this.vWi.push(XP.v(XP.ea.F_e.ATe.RTe, this, n, t, i)),
                    n = t
                } else
                    this.iTe = 1,
                    this.vWi.push(XP.v(XP.ea.F_e.ATe.kTe, this, -1, 1, i)),
                    n = 1;
            s && this.vWi.push(XP.v(XP.ea.F_e.ATe.OTe, this, n, 0))
        }
        ITe(t, i) {
            return !!(i.G_e || t.Rm() || i.R_e && !t.F4i() || t.U4i() && !this.Q_e || 0 !== this.nTe || 0 !== this.rTe) || (t.Tn().r4i() ? t.B4i() && (i.O_e || i.k_e) || t.N4i() && i.k_e : t.B4i() && !this.X_e && i.O_e)
        }
        PTe(t, i) {
            return !!i.A_e || (t.Tn().r4i() ? t.B4i() || t.O4i() : (t.B4i() || t.O4i()) && this.DTe())
        }
        TTe(t) {
            return t.hu() && this.H_e && !this.K_e
        }
        FTe(t, i, e) {
            XP.U(t, XP.ea.wx),
            XP.IL(e),
            t.hu() && null === i && (i = t.RMe()),
            this.gTe = i,
            this.aTe = e.LTe || null,
            this.lTe = e.BTe || null,
            this.S1i = e.UTe || 0,
            this.vo = e.devicePixelRatio || 1,
            this.mTe = e.hEe || 1,
            this.wTe = e.oEe || 0,
            this.Fe = "number" == typeof e.time ? e.time : this.xyi.BV(),
            this.Pge = !1,
            t.Nye(),
            this.V_e && this.NTe();
            let s = !1;
            if (this.jTe() && (this.$Te(t, e),
            s = !0,
            this.yTe = this.xyi.E_e(t, this.hTe, this.oTe),
            ZP.Qr(this.cTe),
            ZP.vni(),
            t.hu() && t.mMe(this.gTe),
            t.HMe(this.gTe.jn(), this.yTe, ZP.Yr(), ZP.Jr(), ZP.width(), ZP.height())),
            this.Z_e)
                this.zTe(t, e);
            else if (YP(this.vWi.length > 0, "expected some steps"),
            s || this.$Te(t, e),
            0 !== this.dTe.width() || 0 !== this.dTe.height()) {
                t.sr(),
                t.Yn(),
                t.Nr(),
                t.$R(0),
                t.JR(0),
                this.N_e = e.VTe || null,
                this.bTe = e.WTe || 0,
                this.vTe = e.HTe || 0,
                this.STe = e.KTe || 0,
                this.xTe = e.qTe || 0,
                this.MTe = !!e.XTe,
                this.YTe(t),
                this.eTe[0] = i,
                this.eTe[1] = this.iTe >= 1 ? this.JTe() : null,
                this.eTe[2] = 2 === this.iTe ? this.JTe() : null;
                for (const i of this.vWi) {
                    const e = this.ZTe(i.QTe())
                      , s = this.ZTe(i.tIe());
                    t.hu() ? i.iIe(t, e, s) : i.eIe(t, e, s)
                }
                t.hr(null),
                this.eTe[1] && this.sIe(this.eTe[1]),
                this.eTe[2] && this.sIe(this.eTe[2]),
                this.eTe.fill(null),
                this.nIe(t),
                this.gTe = null,
                this.yTe = null,
                this.aTe = null,
                this.lTe = null,
                this.N_e = null
            }
        }
        $Te(t, i) {
            const [e,s] = this.xyi.x_e(t);
            this.rIe(t, e, s),
            this.hIe(i)
        }
        rIe(t, i, e) {
            if (i <= 0 || e <= 0)
                throw new Error("invalid draw size");
            this.hTe === i && this.oTe === e || this.oIe(t, i, e, 0, 0, this.Rwe, this.ETe),
            this.hTe = i,
            this.oTe = e
        }
        oIe(t, i, e, s, n, r, h) {
            const o = i / 2 + s
              , a = e / 2 + n;
            t.bR(r, i / e);
            const l = t.nR(o, a, t.ga(e), o, a, 0, e);
            JP.Qr(h, l)
        }
        hIe(t) {
            this.uTe.Qr(t.rEe),
            t.aIe ? this.cTe.Qr(t.aIe) : this.cTe.set(0, 0, this.hTe, this.oTe),
            this.dTe.Qr(this.cTe),
            this.dTe.xm(this.hTe, this.oTe);
            const i = this.mTe * this.vo;
            this.cTe.Kp(this.nTe * i, this.rTe * i),
            this.pTe.Qr(this.cTe),
            this.pTe.xm(this.hTe, this.oTe),
            this.cTe.Sni(0, 0, this.hTe, this.oTe),
            this.fTe.Qr(this.cTe),
            this.fTe.xm(this.hTe, this.oTe)
        }
        YTe(t) {
            if (this.Y_e = t.ube(),
            this.J_e = t.xbe(),
            this.Q_e)
                t.kR(!1),
                this.W_e && t.cbe(!0);
            else {
                if (ZP.Qr(this.cTe),
                t.r4i()) {
                    const t = this.mTe * this.vo;
                    ZP.Kp(Math.max(this.nTe, 1) * t, Math.max(this.rTe, 1) * t),
                    ZP.vni(),
                    ZP.Ne(0, 0, this.hTe, this.oTe)
                } else
                    ZP.vni();
                t.dbe(ZP.Yr(), ZP.Jr(), ZP.width(), ZP.height(), this.oTe)
            }
        }
        lIe(t) {
            t.Nr(),
            this.Q_e || (this.J_e && t.Mbe(),
            t.kR(!1),
            this.W_e && t.cbe(!0)),
            t.hu() && t.UMe(!0)
        }
        nIe(t) {
            t.cbe(!1),
            this.J_e && t.Sbe(),
            t.kR(this.Y_e),
            this.Q_e || t.pbe(),
            t.hu() && t.UMe(!1),
            this.Pge = t.jye()
        }
        uIe() {
            this.pTe.Ne(0, 0, 1, 1)
        }
        ZTe(t) {
            return t < 0 ? null : this.eTe[t]
        }
        JTe() {
            return this.xyi.fbe(this)
        }
        cIe() {
            return this.gTe
        }
        sIe(t) {
            this.xyi.M_e(t, this)
        }
        dIe(t) {
            return this.j_e[t]
        }
        fIe(t) {
            this.N_e ? this.N_e(this, t, () => this.L_e(t, this)) : this.L_e(t, this),
            this.Z_e || this.lIe(t)
        }
        pIe(t) {
            if (this.Q_e)
                return !0;
            if (0 !== this.bTe || 0 !== this.vTe || 0 !== this.STe || 0 !== this.xTe)
                return !1;
            const [i,e] = t.ebe(t.fbe());
            return i === this.hTe && e === this.oTe
        }
        mIe(t, i) {
            let e = this.Rwe
              , s = this.ETe;
            if (i && !this.pIe(t)) {
                let i, n;
                e = eG,
                s = sG,
                0 !== this.STe && 0 !== this.xTe ? [i,n] = [this.STe, this.xTe] : [i,n] = t.ebe(t.fbe()),
                this.oIe(t, i, n, this.bTe, this.vTe, e, s),
                this.Q_e || t.pbe()
            }
            t.eR(e),
            t.rR(s)
        }
        NTe() {
            this.xyi.qut(this)
        }
        wIe(t, i) {
            return this.U_e(this.$_e[t], i)
        }
        gIe(t, i) {
            let e = this.pTe
              , s = this.fTe
              , n = this.dTe;
            t.r4i() && (QP.Qr(e),
            QP.pni(1),
            e = QP,
            tG.Qr(s),
            tG.pni(1),
            s = tG,
            iG.Qr(n),
            iG.pni(1),
            n = iG),
            this.yIe(t, i, s, n, e, 1 / this.hTe, 1 / this.oTe)
        }
        bIe(t, i) {
            let e = this.fTe
              , s = this.dTe
              , n = 1 / this.hTe
              , r = 1 / this.oTe;
            if (this.B_e) {
                let {vIe: t, SIe: i, xIe: h} = this.B_e(this.aTe);
                t || (ZP.set(0, 0, 0, 0),
                t = ZP),
                i || (i = this.hTe),
                h || (h = this.oTe),
                e = t,
                s = t,
                n = 1 / i,
                r = 1 / h
            } else
                t.r4i() && (tG.Qr(e),
                tG.pni(1),
                e = tG,
                iG.Qr(s),
                iG.pni(1),
                s = iG);
            let h = this.pTe;
            t.r4i() && (h = QP,
            h.Qr(this.pTe),
            h.pni(1)),
            this.yIe(t, i, e, s, h, n, r),
            t.hu() && this.q_e && t.pEe(this.tTe)
        }
        MIe(t) {
            return this.H_e ? t.hu() ? this.jTe() ? this.yTe : this.gTe.jn() : this.gTe : null
        }
        yIe(t, i, e, s, n, r, h) {
            t.hbe(this.MIe(t), n, e, s, this.uTe, r, h, this.vo, this.mTe, this.wTe, this.Fe),
            t.obe(this.wIe(i, t))
        }
        zTe(t, i) {
            const e = this.j_e[0]
              , s = t.ube()
              , n = e.U4i();
            n && (t.kR(!1),
            t.cbe(!0),
            this.pTe.set(0, 0, 1, 1),
            this.dTe.set(0, 0, 1, 1)),
            t.dm(e),
            t.mb(this.S1i),
            t.AR(this.gTe),
            t.Yn();
            let r = 0
              , h = 1;
            if (this.dTe.set(0, 0, 1, 1),
            e.N4i() && this.B_e) {
                const {vIe: t, SIe: i, xIe: e} = this.B_e(this.aTe);
                t && this.dTe.Qr(t),
                r = Number.isFinite(i) ? 1 / i : 0,
                h = Number.isFinite(e) ? 1 / e : 0
            } else {
                const [i,e] = this.xyi.x_e(t);
                r = 1 / i,
                h = 1 / e
            }
            i.rEe ? this.uTe.Qr(i.rEe) : this.uTe.set(0, 0, 0, 0),
            t.hbe(this.MIe(t), this.pTe, this.dTe, this.dTe, this.uTe, r, h, this.vo, this.mTe, this.wTe, this.Fe),
            t.obe(this.wIe(0, t)),
            t.hu() && this.q_e && t.pEe(this.tTe),
            t.$R(0),
            this.fIe(t),
            n && (t.cbe(!1),
            t.kR(s))
        }
        jTe() {
            return this.X_e
        }
        DTe() {
            return !this.X_e
        }
        EIe() {
            return this.H_e
        }
        CIe() {
            return !!this.Z_e && !this.jTe()
        }
        _Ie() {
            return this.Q_e
        }
        TIe() {
            return this.aTe
        }
        XW() {
            return this.lTe
        }
        IIe() {
            return this.S1i
        }
        PIe() {
            return this.MTe
        }
        jye() {
            return this.Pge
        }
        GIe() {
            return this.cTe
        }
        AIe() {
            return this.fTe
        }
        RIe() {
            return this.sTe
        }
        async kIe(t, i, e) {}
    }
}
{
    const hG = self.t;
    hG.ea.F_e.ATe = class {
        constructor(t, i, e, s=-1) {
            this.OIe = t,
            this.DIe = i,
            this.FIe = e,
            this.oGt = s
        }
        LIe() {
            return this.OIe
        }
        QTe() {
            return this.DIe
        }
        tIe() {
            return this.FIe
        }
        ZC() {
            return this.oGt
        }
        X5i() {
            return this.LIe().dIe(this.ZC())
        }
        eIe(t, i, e) {
            hG.kK()
        }
        iIe(t, i, e) {
            hG.kK()
        }
    }
}
{
    const oG = self.t;
    oG.ea.F_e.ATe.GTe = class extends oG.ea.F_e.ATe {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        eIe(t, i, e) {
            const s = this.LIe();
            t.sr(),
            t.Yn(),
            t.Wr(),
            t.AR(e, s.PIe()),
            t.abe(0, 0, 0, 0),
            s.fIe(t),
            s.uIe()
        }
        iIe(t, i, e) {
            const s = this.LIe();
            t.sr(),
            t.Yn(),
            t.Wr(),
            t.AR(e, !1),
            t.abe(0, 0, 0, 0),
            s.fIe(t),
            s.uIe()
        }
    }
}
{
    const aG = self.t
      , lG = aG.v(aG.Rect)
      , uG = aG.v(aG.zn);
    aG.ea.F_e.ATe.OTe = class extends aG.ea.F_e.ATe {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        eIe(t, i, e) {
            const s = this.LIe();
            t.Wr(),
            t.AR(e),
            s.mIe(t, !0),
            t.mb(s.IIe()),
            t.hr(i.jn()),
            uG.Zr(s.GIe()),
            lG.Qr(s.AIe()),
            lG.pni(1),
            t.ur(uG, lG),
            s.RIe() && t.ybe(i)
        }
        iIe(t, i, e) {
            const s = this.LIe();
            t.Wr(),
            t.AR(e, !1),
            s.pIe(t) ? uG.Zr(s.AIe()) : (t.UMe(!1),
            s.mIe(t, !0),
            uG.Zr(s.GIe())),
            t.jxe(null),
            t.mb(s.IIe()),
            t.hr(i.jn()),
            s._Ie() ? t.ibe() : t.ur(uG, s.AIe())
        }
    }
}
{
    const cG = self.t;
    cG.ea.F_e.ATe.kTe = class extends cG.ea.F_e.ATe {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        eIe(t, i, e) {
            const s = this.LIe();
            t.AR(e, s.PIe()),
            t.abe(0, 0, 0, 0),
            t.Yye(),
            t.dm(this.X5i()),
            s.bIe(t, this.ZC()),
            s.fIe(t),
            s.uIe()
        }
        iIe(t, i, e) {
            const s = this.LIe();
            t.AR(e, !1),
            t.abe(0, 0, 0, 0),
            t.Yye(),
            t.dm(this.X5i()),
            s.bIe(t, this.ZC()),
            s.fIe(t),
            s.uIe()
        }
    }
}
{
    const dG = self.t
      , fG = dG.v(dG.Rect)
      , pG = dG.v(dG.zn);
    dG.ea.F_e.ATe.RTe = class extends dG.ea.F_e.ATe {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        eIe(t, i, e) {
            const s = this.LIe();
            t.AR(e);
            const n = 0 === this.tIe();
            n ? t.mb(s.IIe()) : (t.abe(0, 0, 0, 0),
            t.Yye()),
            t.dm(this.X5i()),
            s.gIe(t, this.ZC()),
            t.hr(i.jn()),
            s.mIe(t, n),
            pG.Zr(s.GIe()),
            fG.Qr(s.AIe()),
            fG.pni(1),
            t.ur(pG, fG),
            s.RIe() && t.ybe(i)
        }
        iIe(t, i, e) {
            const s = this.LIe();
            t.AR(e, !1);
            0 === this.tIe() ? (t.mb(s.IIe()),
            t.jxe(null),
            s.pIe(t) ? pG.Zr(s.AIe()) : (t.UMe(!1),
            s.mIe(t, !0),
            pG.Zr(s.GIe()))) : (t.abe(0, 0, 0, 0),
            t.Yye(),
            pG.Zr(s.AIe())),
            t.dm(this.X5i()),
            s.gIe(t, this.ZC()),
            t.hr(i.jn()),
            s._Ie() ? t.ibe() : t.ur(pG, s.AIe())
        }
    }
}
{
    const mG = self.t;
    mG.dQ = {},
    mG.dQ.BIe = 44902,
    mG.dQ.UIe = "stable",
    mG.dQ.NIe = !0,
    mG.dQ.URL = {
        jIe: "https://www.construct.net/",
        $Ie: {
            games: "make-games",
            animation: "animation-software"
        },
        zIe: "",
        VIe: "https://www.construct.net",
        WIe: "https://www.construct.net/about",
        HIe: "https://www.construct.net/register",
        KIe: "https://www.construct.net/privacy-policy",
        bQ: "https://www.construct.net/game-assets",
        qIe: {
            games: "https://www.construct.net/make-games/manuals/construct-3",
            animation: "https://www.construct.net/animation-software/manual"
        },
        mQ: "",
        XIe: "getting-started/using-an-account",
        YIe: "releases/",
        JIe: "https://www.construct.net/profile/edit",
        ZIe: "https://www.construct.net/profile/licenses",
        QIe: "https://www.construct.net/make-games/buy-construct-3",
        tPe: "https://www.construct.net/store/checkout?editor=1",
        iPe: "https://www.construct.net/make-games/features",
        uQ: "https://www.construct.net/tutorials",
        ePe: "https://www.construct.net/tutorials/beginners-guide-to-construct-3-1",
        bLt: "https://www.construct.net/make-games/manuals/construct-3/scripting/guides/using-typescript",
        sPe: "https://www.construct.net/community",
        nPe: "https://www.construct.net/forum",
        rPe: "https://www.construct.net/blogs",
        Lme: "https://www.construct.net/make-games/addons",
        hPe: "https://www.construct.net/make-games/showcase",
        oPe: "https://www.construct.net/free-online-games",
        aPe: "https://github.com/Scirra/Construct-bugs",
        lPe: "https://github.com/Scirra/Construct-feature-requests",
        uPe: "https://www.construct.net/forum/construct-3/translations-11/how-to-help-translate-construc-128475"
    },
    mG.dQ.cPe = function(t) {
        mG.dQ.URL.zIe = mG.dQ.URL.jIe + mG.dQ.URL.$Ie[t] + "/",
        mG.dQ.URL.mQ = mG.dQ.URL.qIe[t]
    }
    ,
    mG.dPe = function(t) {
        mG.Ge(t);
        const i = t % 100;
        let e = "r" + Math.floor(t / 100);
        return 0 !== i && (e += "." + i),
        e
    }
    ,
    mG.fPe = function(t) {
        return mG.Aoi(mG.dPe(t), ".", "-")
    }
    ,
    mG.pPe = function(t) {
        mG.zt(t),
        (t = t.toLowerCase().trim()).startsWith("r") && (t = t.substr(1));
        const i = t.split(".");
        let e = -1;
        return 1 === i.length ? e = 100 * parseInt(i[0], 10) : 2 === i.length && (e = 100 * parseInt(i[0], 10) + parseInt(i[1], 10)),
        isFinite(e) || (e = -1),
        e
    }
    ,
    mG.dQ.mPe = mG.dPe(mG.dQ.BIe),
    mG.dQ.wPe = mG.fPe(mG.dQ.BIe)
}
globalThis.t.Qs.g_.gPe = {
    yPe: [{
        id: "main",
        size: "1fr",
        name: "Main area",
        devicePixelRatio: 1,
        popup: !1,
        type: "Pane",
        activeTab: null,
        layout: {
            tabSide: !1,
            size: 1920,
            id: "middle",
            isHorizontal: !0,
            children: [{
                id: "propertiesBar",
                size: "320px",
                fixedSize: !0,
                name: "Properties",
                devicePixelRatio: 1,
                popup: !1,
                type: "CaptionPane",
                activeTab: null,
                caption: "Properties",
                side: "left",
                docked: !0
            }, {
                id: "",
                size: "1fr",
                name: "middle2",
                devicePixelRatio: 1,
                type: "DockingPane",
                activeTab: null,
                side: "",
                docked: !0,
                layout: {
                    tabSide: !1,
                    size: 1024,
                    id: "middle3",
                    isHorizontal: !1,
                    children: [{
                        id: "midPane",
                        size: "1fr",
                        name: "Mid pane",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "",
                        docked: !0,
                        layout: {
                            tabSide: "top",
                            children: []
                        }
                    }, {
                        id: "assetBrowserBar",
                        size: "250px",
                        name: "Asset Browser",
                        devicePixelRatio: 1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Asset Browser",
                        side: "bottom",
                        docked: !0
                    }]
                }
            }, {
                id: "",
                size: "320px",
                fixedSize: !0,
                name: "middle2",
                devicePixelRatio: 1,
                type: "DockingPane",
                activeTab: null,
                side: "right",
                docked: !0,
                layout: {
                    tabSide: !1,
                    size: 1024,
                    id: "middle3",
                    isHorizontal: !1,
                    children: [{
                        id: "projectBar",
                        size: "487px",
                        name: "Project",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Project",
                        side: "top",
                        docked: !0
                    }, {
                        id: "",
                        size: "487px",
                        name: "middle4",
                        devicePixelRatio: 1,
                        type: "TabPane",
                        activeTab: null,
                        side: "bottom",
                        docked: !0,
                        layout: {
                            tabSide: "bottom",
                            children: [{
                                id: "layersBar",
                                size: "487px",
                                name: "Layers",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !0,
                                caption: "Layers",
                                side: "bottom",
                                docked: !0
                            }, {
                                id: "tilemapBar",
                                size: "487px",
                                name: "Tilemap",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !1,
                                caption: "Tilemap",
                                side: "bottom",
                                docked: !0
                            }]
                        }
                    }]
                }
            }]
        }
    }],
    bPe: [{
        id: "main",
        size: "1fr",
        name: "Main area",
        devicePixelRatio: 1,
        popup: !1,
        type: "Pane",
        activeTab: null,
        layout: {
            tabSide: !1,
            size: 1920,
            id: "middle",
            isHorizontal: !0,
            children: [{
                id: "propertiesBar",
                size: "320px",
                fixedSize: !0,
                name: "Properties",
                devicePixelRatio: 1,
                popup: !1,
                type: "CaptionPane",
                activeTab: null,
                caption: "Properties",
                side: "left",
                docked: !0
            }, {
                id: "midPane",
                size: "1fr",
                name: "Mid pane",
                devicePixelRatio: 1,
                popup: !1,
                type: "TabPane",
                activeTab: null,
                side: "",
                docked: !0,
                layout: {
                    tabSide: "top",
                    children: []
                }
            }, {
                size: "300px",
                fixedSize: !0,
                name: "middle2",
                devicePixelRatio: 1,
                popup: !1,
                type: "DockingPane",
                activeTab: null,
                side: "right",
                docked: !0,
                layout: {
                    tabSide: !1,
                    size: 974,
                    id: "middle3",
                    isHorizontal: !1,
                    children: [{
                        id: "projectBar",
                        size: "487px",
                        name: "Project",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Project",
                        side: "top",
                        docked: !0
                    }, {
                        size: "300px",
                        name: "middle4",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "bottom",
                        docked: !0,
                        layout: {
                            tabSide: "bottom",
                            children: [{
                                id: "layersBar",
                                size: "300px",
                                name: "Layers",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !0,
                                caption: "Layers",
                                side: "bottom",
                                docked: !0
                            }, {
                                id: "tilemapBar",
                                size: "300px",
                                name: "Tilemap",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !1,
                                caption: "Tilemap",
                                side: "bottom",
                                docked: !0
                            }]
                        }
                    }]
                }
            }]
        }
    }],
    vPe: [{
        id: "main",
        size: "1fr",
        name: "Main area",
        devicePixelRatio: 1,
        popup: !1,
        type: "Pane",
        activeTab: null,
        layout: {
            tabSide: !1,
            size: 883,
            id: "middle",
            isHorizontal: !1,
            children: [{
                id: "",
                size: "1fr",
                name: "(no name)",
                devicePixelRatio: 1,
                popup: !1,
                type: "Pane",
                activeTab: null,
                layout: {
                    tabSide: !1,
                    size: 1309,
                    id: "middle",
                    isHorizontal: !0,
                    children: [{
                        id: "propertiesBar",
                        size: "320px",
                        fixedSize: !0,
                        name: "Properties",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Properties",
                        side: "left",
                        docked: !0
                    }, {
                        id: "midPane",
                        size: "1fr",
                        name: "Mid pane",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "",
                        docked: !0,
                        layout: {
                            tabSide: "top",
                            children: []
                        }
                    }, {
                        id: "",
                        size: "300px",
                        fixedSize: !0,
                        name: "middle2",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "right",
                        docked: !0,
                        layout: {
                            tabSide: "bottom",
                            children: [{
                                id: "projectBar",
                                size: "300px",
                                name: "Project",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !0,
                                caption: "Project",
                                side: "right",
                                docked: !0
                            }, {
                                id: "layersBar",
                                size: "300px",
                                name: "Layers",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !1,
                                caption: "Layers",
                                side: "right",
                                docked: !0
                            }]
                        }
                    }]
                }
            }, {
                id: "",
                size: "250px",
                name: "middle2",
                devicePixelRatio: 1,
                type: "TabPane",
                activeTab: null,
                side: "bottom",
                docked: !0,
                layout: {
                    tabSide: "bottom",
                    children: [{
                        id: "timelineBar",
                        size: "250px",
                        name: "Timeline",
                        devicePixelRatio: 1,
                        type: "CaptionPane",
                        activeTab: !0,
                        caption: "Timeline",
                        side: "bottom",
                        docked: !0
                    }, {
                        id: "assetBrowserBar",
                        size: "250px",
                        name: "Asset Browser",
                        devicePixelRatio: 1,
                        type: "CaptionPane",
                        activeTab: !1,
                        caption: "Asset Browser",
                        side: "bottom",
                        docked: !0
                    }]
                }
            }]
        }
    }]
};
{
    const wG = self.t
      , gG = (wG.bW(import.meta.url),
    "workers/")
      , yG = "dispatchWorker.js"
      , bG = "jobWorker.js";
    class vG extends wG.Me {
        constructor() {
            super(),
            this.SPe = wG.S9t.y9t("oneworker") ? 1 : Math.min(wG.hardwareConcurrency, 16),
            this.xPe = null,
            this.MPe = [],
            this.EPe = new Map,
            this.CPe = 0,
            this._Pe = !1,
            this.TPe = !1,
            this.IPe = !1,
            this.zzt = null,
            this.vzt = null
        }
        Ro() {
            if (this._Pe)
                throw new Error("already initialised");
            return wG.lU("JobSchedulerInit"),
            this.xPe = new Worker(gG + yG),
            this.xPe.addEventListener("message", t => this.PPe(t)),
            this.GPe(),
            this._Pe = !0,
            this.zzt = new Promise( (t, i) => {
                this.vzt = t
            }
            ),
            this.zzt
        }
        GPe() {
            const t = new Worker(gG + bG);
            t.addEventListener("message", t => this.APe(t));
            const i = new MessageChannel;
            this.xPe.postMessage({
                type: "_addJobWorker",
                port: i.port1
            }, [i.port1]),
            t.postMessage({
                type: "init",
                number: this.MPe.length,
                port: i.port2
            }, [i.port2]),
            this.TPe = !0,
            this.MPe.push(t)
        }
        BIt(t, i, e, s, n) {
            if (wG.zt(t),
            wG.ML(i),
            wG.D_t(e),
            wG.tot(s),
            wG.Ef(n, wG.Nfi),
            !this._Pe)
                throw new Error("not yet initialised");
            e || (e = []);
            const r = this.CPe++
              , h = {
                type: t,
                jobId: r,
                params: i,
                transferables: e
            }
              , o = new Promise( (t, i) => {
                this.EPe.set(r, {
                    resolve: t,
                    RPe: s,
                    reject: i,
                    kPe: !1
                })
            }
            );
            return n && n.jfi( () => this.OPe(r)),
            this.xPe.postMessage(h, e),
            this.DPe(),
            o
        }
        OPe(t) {
            wG.Ge(t);
            const i = this.EPe.get(t);
            i && (i.kPe = !0,
            i.resolve = null,
            i.RPe = null,
            i.reject = null,
            this.xPe.postMessage({
                type: "_cancel",
                jobId: t
            }))
        }
        PPe(t) {
            const i = t.data
              , e = i.type;
            if ("error" !== e)
                throw new Error(`unknown message from dispatch worker '${e}'`);
            console.error("[Dispatch worker] Error: " + i.error)
        }
        APe(t) {
            const i = t.data
              , e = i.type
              , s = i.jobId;
            switch (e) {
            case "result":
                this.FPe(s, i.result);
                break;
            case "progress":
                this.LPe(s, i.progress);
                break;
            case "error":
                this.BPe(s, i.error);
                break;
            case "ready":
                this.UPe();
                break;
            default:
                throw new Error(`unknown message from worker '${e}'`)
            }
        }
        FPe(t, i) {
            const e = this.EPe.get(t);
            if (!e)
                throw new Error("invalid job ID");
            e.kPe || e.resolve(i),
            this.EPe.delete(t)
        }
        LPe(t, i) {
            const e = this.EPe.get(t);
            if (!e)
                throw new Error("invalid job ID");
            !e.kPe && e.RPe && e.RPe(i)
        }
        BPe(t, i) {
            const e = this.EPe.get(t);
            if (!e)
                throw new Error("invalid job ID");
            e.kPe || e.reject(i),
            this.EPe.delete(t)
        }
        UPe() {
            this.TPe = !1,
            this.vzt && (this.vzt(),
            this.vzt = null,
            this.zzt = null,
            wG.OU("JobSchedulerInit")),
            this.DPe()
        }
        DPe() {
            if (!(this.MPe.length >= this.SPe || this.TPe || this.IPe || this.EPe.size <= this.MPe.length))
                try {
                    this.GPe()
                } catch (t) {
                    this.IPe = !0,
                    console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this.MPe.length} so far)`, t)
                }
        }
    }
    wG.HIt = wG.v(vG)
}
{
    const SG = self.t;
    globalThis.NPe = class extends SG.Me {
        constructor() {
            super(),
            this.jPe = null
        }
        Bk() {
            SG.kK()
        }
        W7() {
            SG.kK()
        }
        La() {
            SG.kK()
        }
        nse() {
            SG.kK()
        }
        a6() {
            SG.kK()
        }
        Hot() {
            SG.kK()
        }
        $Pe() {
            SG.kK()
        }
        fae() {
            SG.kK()
        }
        zPe(t) {
            this.jPe = t
        }
        VPe() {
            return this.jPe
        }
    }
}
{
    const xG = self.t;
    xG.ii = class extends xG.Me {
        constructor() {
            super(),
            this.WPe = new.target,
            this.hi = null,
            this.m = null,
            this.HPe = null
        }
        he() {
            this.WPe = null,
            this.hi = null,
            this.m = null
        }
        KPe(t) {
            xG.U(t, self.Plugin),
            this.hi = t
        }
        $a() {
            return this.hi
        }
        qPe(t) {
            xG.nu(t),
            this.WPe = t
        }
        XPe() {
            return this.WPe
        }
        YPe(t) {
            xG.U(t, self.si),
            this.m = t
        }
        GetInfo() {
            if (!this.m)
                throw new Error("plugin must set info");
            return this.m
        }
        Pf(t) {
            xG.zt(t),
            this.HPe = t
        }
        JPe() {
            return this.HPe
        }
        md() {
            return this.hi.md()
        }
        Cn() {
            return this.$a().Cn()
        }
        OL(t) {
            return xG.U(t, self.s_),
            xG.v(this.XPe().G, this, t)
        }
        ri() {
            const t = self.app;
            let i = [["instance-wait-for-signal", "timer"]];
            for (const [e,s] of i)
                this.hi.ZPe(e) && this.hi.ci(e).ai(t.oi(s))
        }
        Pi(t, i) {
            xG.zt(t),
            xG.nu(i),
            this.hi.ki(t).see(i)
        }
        CS() {}
    }
}
{
    const MG = self.t;
    MG.Ai = class extends MG.Me {
        constructor(t, i) {
            MG.U(t, MG.ii),
            MG.U(i, window.s_),
            super(),
            this.QPe = t,
            this.Ps = i,
            this.tGe = null,
            this.iGe = null
        }
        he() {
            this.tGe && (self.app.Us().removeEventListener("renderercontextlost", this.tGe),
            this.tGe = null),
            this.iGe && (self.app.Us().removeEventListener("renderercontextrestored", this.iGe),
            this.iGe = null),
            this.QPe = null,
            this.Ps = null,
            MG.he(this)
        }
        TC(t) {
            return MG.U(t, window.PC),
            MG.v(this.gd().XPe().Instance, this, t)
        }
        Ds() {
            return this.Ps
        }
        gd() {
            return this.QPe
        }
        $a() {
            return this.QPe.$a()
        }
        Cn() {
            return this.Ds().Cn()
        }
        VC() {}
        Vs() {
            this.tGe || (this.tGe = () => this.ks(),
            this.iGe = () => this.MS(),
            self.app.Us().addEventListener("renderercontextlost", this.tGe),
            self.app.Us().addEventListener("renderercontextrestored", this.iGe))
        }
        ks() {}
        MS() {}
        cC() {
            return null
        }
        uC() {
            return "clamp-to-edge"
        }
        pC() {
            return "clamp-to-edge"
        }
    }
}
{
    const EG = self.t
      , CG = EG.v(EG.Rect, 0, 0, 1, 1)
      , _G = EG.v(EG.zn);
    _G.Zr(CG),
    EG.Fi = class extends EG.Me {
        constructor(t, i) {
            EG.U(t, EG.Ai),
            EG.U(i, window.PC),
            super(),
            this.Zs = t,
            this.Ie = i,
            this.Bn = !1,
            this.eGe = !1,
            this.sGe = !1,
            this.nGe = CG,
            this.rGe = _G,
            this.tGe = null,
            this.iGe = null
        }
        he() {
            this.tGe && (self.app.Us().removeEventListener("renderercontextlost", this.tGe),
            this.tGe = null),
            this.iGe && (self.app.Us().removeEventListener("renderercontextrestored", this.iGe),
            this.iGe = null),
            this.Zs = null,
            this.Ie = null,
            EG.he(this)
        }
        Dv() {}
        Wm() {
            return this.Zs
        }
        Ds() {
            return this.Zs.Ds()
        }
        gd() {
            return this.Zs.gd()
        }
        $a() {
            return this.Zs.$a()
        }
        Ei() {}
        Fb() {}
        ib(t) {}
        ue(t, i) {}
        nb(t, i, e) {}
        xM(t, i) {}
        N(t, i) {
            return !1
        }
        Cn() {
            return this.Ie.Cn()
        }
        Gs() {
            return this.Ie
        }
        Pr() {}
        Gm() {
            return !1
        }
        _m() {
            EG.kK()
        }
        jm() {
            EG.kK()
        }
        Lm() {
            return null
        }
        WS() {
            const t = this.Ie.hGe();
            if (t && t.oGe()) {
                const i = t.BRi();
                return [i.ns(), i.er()]
            }
            return [100, 100]
        }
        NS() {
            const t = this.Ie.hGe();
            return t && t.oGe() ? t.$r() : null
        }
        aGe() {
            const t = this.Ie.hGe();
            return t && t.oGe() ? t.Al() : null
        }
        iC() {
            const t = this.Ie.hGe();
            return !!t && t.vut()
        }
        Rm() {
            return !1
        }
        Ga() {
            return this.aGe()
        }
        dr() {
            return !1
        }
        mr(t) {
            EG.kK()
        }
        $n(t, i) {
            EG.kK()
        }
        Dm() {
            return null
        }
        eb(t, i) {
            const e = i.Ur
              , s = this.Ie
              , n = s.Za()
              , r = s.Yl()
              , h = s.ld()
              , o = h.xf();
            for (let i = 0; i < o; i++) {
                const [s,o] = n.fd(e, h.$I(i), h.XI(i), r)
                  , [a,l] = n.fd(e, h.$I(i + 1), h.XI(i + 1), r);
                t.Va(s, o, a, l)
            }
        }
        jn(t) {
            if (EG.Ef(t, self.zf),
            !t)
                return null;
            let i = t.lGe();
            return i ? (this.nGe = t.$r(),
            this.rGe = t.Al(),
            i) : (this.Bn || (this.eGe = !0,
            t.uGe().then(t => {
                this.eGe = !1
            }
            ).catch(t => {
                console.error("Error loading texture:", t),
                this.sGe = !0
            }
            )),
            null)
        }
        $r() {
            return this.nGe
        }
        Al() {
            return this.rGe
        }
        km() {
            return this.sGe
        }
        pr() {}
        Nn(t) {
            EG.zt(t);
            let i = 0
              , e = 0;
            switch (t) {
            case "top-left":
                break;
            case "top":
                i = .5;
                break;
            case "top-right":
                i = 1;
                break;
            case "left":
                e = .5;
                break;
            case "center":
                i = .5,
                e = .5;
                break;
            case "right":
                i = 1,
                e = .5;
                break;
            case "bottom-left":
                e = 1;
                break;
            case "bottom":
                i = .5,
                e = 1;
                break;
            case "bottom-right":
                i = 1,
                e = 1;
                break;
            default:
                throw new Error("invalid origin")
            }
            this.Ie.Gl(i),
            this.Ie._l(e)
        }
        hM() {
            return null
        }
        cM(t) {
            EG.kK()
        }
        dM(t) {}
        Vs() {
            this.tGe || (this.tGe = () => this.ks(),
            this.iGe = () => this.MS(),
            self.app.Us().addEventListener("renderercontextlost", this.tGe),
            self.app.Us().addEventListener("renderercontextrestored", this.iGe))
        }
        ks() {}
        MS() {}
    }
}
{
    const TG = self.t;
    TG.Tl = class extends TG.Fi {
        constructor(t, i) {
            super(t, i),
            this.cGe = !1,
            this.dGe = () => this.ce()
        }
        he() {
            this.pe(!1),
            this.dGe = null
        }
        Ei() {
            this.Ie.me("live-preview") && this.pe(!0)
        }
        fGe() {
            self.app.addEventListener("livepreviewstop", this.dGe)
        }
        pGe() {
            self.app.removeEventListener("livepreviewstop", this.dGe)
        }
        pe(t) {
            if (t = !!t,
            this.cGe !== t)
                if (self.app.CP() && t)
                    self.app.RP(this.Cn(), 10);
                else if (this.cGe = t,
                this.cGe) {
                    this.fGe(),
                    this.ye();
                    this.Ie.rz().yA(!0)
                } else {
                    this.Pe(),
                    this.pGe();
                    const t = this.Ie.yg()
                      , i = t ? t.cb() : null;
                    if (i) {
                        if (!i.hb() && !i.mGe() && !this.Ie.wGe()) {
                            this.Ie.rz().yA(!1)
                        }
                    } else if (!this.Ie.wGe()) {
                        this.Ie.rz().yA(!1)
                    }
                }
        }
        de() {
            return this.cGe
        }
        ye() {}
        Pe() {}
        ce() {
            this.pe(!1),
            this.Ie.A("live-preview", !1)
        }
    }
}
{
    const IG = self.t
      , PG = self.lang
      , GG = new Set(["integer", "float", "percent", "angle", "text", "longtext", "check", "color", "font", "combo", "animation", "link", "group", "info", "object", "projectfile"])
      , AG = new Set(["for-each-instance", "once-for-type", "for-single-instance-or-type"])
      , RG = new WeakMap;
    window.i = class t {
        constructor(t, i, e) {
            if (IG.zt(t),
            IG.zt(i),
            !GG.has(t))
                throw new Error(`invalid property type '${t}'`);
            if (!i)
                throw new Error("property id cannot be empty");
            if (this.bht = {
                initialValue: null,
                Jm: 1,
                $m: null,
                gs: null,
                bs: "for-each-instance",
                items: null,
                yt: null,
                Tr: null,
                se: !0,
                minValue: null,
                maxValue: null,
                Z: "all",
                hidden: !1,
                $: !0,
                D: !1,
                Ml: null,
                filter: ""
            },
            IG.Wft(e) ? (this.bht = Object.assign(this.bht, e),
            "color" === t && IG.B9(e.initialValue) && (this.bht.initialValue = new IG.za,
            this.bht.initialValue.lu(e.initialValue))) : "color" === t && IG.B9(e) ? (this.bht.initialValue = new IG.za,
            this.bht.initialValue.lu(e)) : this.bht.initialValue = e,
            !("text" !== t && "longtext" !== t || void 0 !== this.bht.initialValue && null !== this.bht.initialValue)) {
                const t = PG(`.${i}.initial-value`);
                t === IG.p.tci ? this.bht.initialValue = "" : this.bht.initialValue = t
            }
            if (void 0 === this.bht.initialValue && (this.bht.initialValue = null),
            this.aGt = t,
            this.Rdi = i,
            IG.tot(this.bht.yt),
            this.Ftt = PG(`.${i}.name`),
            this.$Oi = PG(`.${i}.desc`),
            this.gGe = "",
            "link" === this.aGt && (this.gGe = PG(`.${i}.link-text`)),
            this.yGe = [],
            this.bGe = new Map,
            "object" !== this.aGt && "projectfile" !== this.aGt || (this.bht.initialValue = -1),
            this.vGe = "",
            this.SGe = "",
            "combo" === this.aGt) {
                IG.RH(this.bht.items);
                for (let t of this.bht.items)
                    IG.zt(t),
                    this.bGe.set(t, this.yGe.length),
                    this.yGe.push({
                        value: t,
                        displayName: PG(`.${i}.items.${t}`)
                    })
            }
            this.xGe()
        }
        xGe() {
            if (IG.Ge(this.bht.Jm),
            "link" === this.aGt && (IG.nu(this.bht.gs),
            IG.tot(this.bht.$m),
            !AG.has(this.bht.bs)))
                throw new Error(`invalid link callback type '${this.bht.bs}'`);
            switch (this.aGt) {
            case "integer":
            case "float":
            case "percent":
            case "angle":
                IG.Ck(this.bht.initialValue);
                break;
            case "text":
            case "longtext":
            case "font":
                IG.zt(this.bht.initialValue);
                break;
            case "check":
                this.bht.initialValue = !!this.bht.initialValue;
                break;
            case "animation":
                if (null !== this.bht.initialValue)
                    throw new Error("do not specify initial value for 'animation' property");
                this.bht.initialValue = "";
                break;
            case "color":
                IG.U(this.bht.initialValue, IG.za);
                break;
            case "combo":
                if (IG.zt(this.bht.initialValue),
                !this.bht.items.includes(this.bht.initialValue))
                    throw new Error("combo property initial value not in items list");
                break;
            case "link":
            case "group":
                break;
            case "info":
                IG.nu(this.bht.Tr)
            }
        }
        W7() {
            return this.aGt
        }
        Bk() {
            return this.Rdi
        }
        La() {
            return this.Ftt
        }
        UC() {
            return this.bht.initialValue
        }
        kre() {
            return this.bht.yt
        }
        nse() {
            return this.$Oi
        }
        Ere() {
            if ("combo" !== this.aGt)
                throw new Error("not a combo property type");
            return this.yGe
        }
        MGe(t) {
            if (IG.zt(t),
            "combo" !== this.aGt)
                throw new Error("not a combo property type");
            for (let i of this.yGe)
                if (i.value === t)
                    return !0;
            return !1
        }
        wM(t) {
            if (IG.zt(t),
            "combo" !== this.aGt)
                throw new Error("not a combo property type");
            for (let i of this.yGe)
                if (i.value === t)
                    return i.displayName;
            throw new Error("invalid combo item value")
        }
        EGe(t) {
            if (IG.zt(t),
            "combo" !== this.aGt)
                throw new Error("not a combo property type");
            let i = this.bGe.get(t);
            if (void 0 === i)
                throw new Error("invalid combo item value");
            return i
        }
        Gae() {
            if ("link" !== this.aGt)
                throw new Error("not a link property type");
            return this.gGe
        }
        Sae() {
            if ("link" !== this.aGt)
                throw new Error("not a link property type");
            return this.bht.gs
        }
        Pae() {
            if ("link" !== this.aGt)
                throw new Error("not a link property type");
            return this.bht.bs
        }
        jae() {
            if ("info" !== this.aGt)
                throw new Error("not an info property type");
            return this.bht.Tr
        }
        Yv() {
            if (!this.gDi())
                throw new Error("not a numeric property type");
            return null !== this.bht.minValue
        }
        Jv() {
            if (!this.gDi())
                throw new Error("not a numeric property type");
            return this.bht.minValue
        }
        Ire() {
            if (!this.gDi())
                throw new Error("not a numeric property type");
            return null !== this.bht.maxValue
        }
        $re() {
            if (!this.gDi())
                throw new Error("not a numeric property type");
            return this.bht.maxValue
        }
        gDi() {
            return "integer" === this.aGt || "float" === this.aGt || "percent" === this.aGt || "angle" === this.aGt
        }
        mre() {
            const t = this.aGt;
            return !!this.bht.D && ("integer" === t || "float" === t || "percent" === t || "angle" === t || "text" === t || "longtext" === t || "check" === t || "combo" === t || "animation" === t || "color" === t)
        }
        Pre() {
            return this.bht.se
        }
        gre() {
            return self.app.CGe(this.bht.Z)
        }
        fae() {
            return this.bht.hidden
        }
        _Ge(t) {
            IG.zt(t),
            this.vGe = t
        }
        TGe() {
            return this.vGe
        }
        Nae() {
            if ("object" !== this.aGt)
                throw new Error("not an object property type");
            return this.bht.Ml
        }
        Mae() {
            if ("projectfile" !== this.aGt)
                throw new Error("not a projectfile property type");
            return this.bht.filter
        }
        IGe(t) {
            IG.zt(t),
            this.SGe = t
        }
        PGe() {
            return this.SGe
        }
        xae() {
            if ("link" !== this.aGt)
                throw new Error("not a link property type");
            return this.bht.$m
        }
        Zne() {
            return "integer" === this.aGt || "float" === this.aGt || "percent" === this.aGt || "angle" === this.aGt || "text" === this.aGt
        }
        eie() {
            if ("integer" !== this.aGt && "float" !== this.aGt)
                throw new Error("property does not support a drag speed multiplier");
            return this.bht.Jm
        }
        n1t() {
            return !("link" === this.aGt || "group" === this.aGt || "info" === this.aGt)
        }
        bre() {
            return !!this.bht.$
        }
        static GGe(i) {
            const e = RG.get(i);
            if (e)
                return e;
            const s = i.W7()
              , n = i.Bk();
            let r = i.AGe();
            if (IG.Wft(r)) {
                if (r = Object.assign({}, {
                    initialValue: null,
                    dragSpeedMultiplier: 1,
                    items: null,
                    minValue: null,
                    maxValue: null,
                    linkCallback: null,
                    callbackType: "for-each-instance",
                    infoCallback: null,
                    allowedPluginIds: null,
                    interpolatable: !1,
                    filter: null
                }, r),
                r = {
                    initialValue: r.initialValue,
                    Jm: r.dragSpeedMultiplier,
                    items: r.items,
                    minValue: r.minValue,
                    maxValue: r.maxValue,
                    gs: r.linkCallback,
                    bs: r.callbackType,
                    Tr: r.infoCallback,
                    Ml: r.allowedPluginIds,
                    D: r.interpolatable,
                    filter: r.filter
                },
                "link" === s)
                    if ("for-each-instance" === r.bs) {
                        const t = r.gs;
                        r.gs = i => t(i.RGe())
                    } else {
                        if ("once-for-type" !== r.bs)
                            throw new Error("invalid callbackType");
                        {
                            const t = r.gs;
                            r.gs = i => t(i.kGe())
                        }
                    }
                if ("info" === s) {
                    const t = r.Tr;
                    r.Tr = i => t(i.ud().RGe())
                }
            }
            const h = new t(s,n,r);
            return RG.set(i, h),
            h
        }
    }
}
{
    const kG = self.t
      , OG = new Set(["3d", "data-and-storage", "html-elements", "general", "input", "media", "monetisation", "platform-specific", "web", "other"])
      , DG = new Set(["object", "world"])
      , FG = new Set(["", "module"]);
    window.si = class extends kG.Me {
        constructor(t) {
            kG.zt(t),
            super(),
            this.Rdi = t,
            this.Ftt = "",
            this.$Oi = "",
            this.Wtt = "1.0.0.0",
            this.OGe = !1,
            this.DGe = "general",
            this.FGe = "",
            this.LGe = "http://",
            this.BGe = "object",
            this.UGe = "icon.svg",
            this.NGe = "image/svg+xml",
            this.jGe = "",
            this.$Ge = ["c3runtime/plugin.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"],
            this.zGe = [],
            this.sEi = !1,
            this.VGe = !1,
            this.WGe = !1,
            this.HGe = !1,
            this.KGe = "",
            this.qGe = !1,
            this.vf = null,
            this.XGe = !1,
            this.YGe = !1,
            this.upi = !1,
            this.JGe = !1,
            this.ZGe = !1,
            this.QGe = !1,
            this.tAe = !1,
            this.iAe = !1,
            this.eAe = !1,
            this.sAe = !1,
            this.nAe = !1,
            this.y4i = !1,
            this.rAe = !0,
            this.hAe = !0,
            this.oAe = "",
            this.aAe = !0,
            this.lAe = !1,
            this.uAe = !1,
            this.cAe = !1,
            this.dAe = !1,
            this.fAe = !1,
            this.pAe = !1,
            this.mAe = !1,
            this.wAe = !1,
            this.gAe = !1,
            this.yAe = !1,
            this.bAe = !1,
            this.vAe = !1,
            this.SAe = {},
            this.jLi = [],
            this.xAe = new Map,
            this.MAe = [],
            this.EAe = [],
            this.CAe = [],
            this._Ae = [],
            this.TAe = !1,
            this.IAe = "",
            this.PAe = [],
            this.GAe = {
                M: "",
                objectType: "",
                ftt: ""
            },
            this.AAe = [],
            this.RAe = new Map
        }
        Wxt() {
            return this.Rdi
        }
        I(t) {
            kG.zt(t),
            this.Ftt = t
        }
        La() {
            return this.Ftt
        }
        k(t) {
            kG.zt(t),
            this.$Oi = t
        }
        nse() {
            return this.$Oi
        }
        P(t) {
            kG.zt(t),
            this.Wtt = t,
            this.OGe = !0
        }
        a6() {
            return this.Wtt
        }
        kAe() {
            return this.OGe
        }
        S(t) {
            kG.zt(t),
            "form-controls" === t && (t = "html-elements"),
            this.DGe = t
        }
        OAe() {
            return this.DGe
        }
        B(t) {
            kG.zt(t),
            this.FGe = t
        }
        rse() {
            return this.FGe
        }
        L(t) {
            kG.zt(t),
            this.LGe = self.app.Ene(t)
        }
        foe() {
            return this.LGe
        }
        Ui(t) {
            kG.zt(t),
            this.BGe = t
        }
        Ek() {
            return this.BGe
        }
        m0(t, i) {
            kG.zt(t),
            kG.zt(i),
            this.UGe = t,
            this.NGe = i
        }
        DAe() {
            return this.UGe
        }
        FAe() {
            return this.NGe
        }
        Bi(t) {
            this.sEi = !!t
        }
        Q$() {
            return this.sEi
        }
        Hi(t) {
            this.VGe = !!t
        }
        zz() {
            return this.VGe
        }
        Xi(t) {
            this.WGe = !!t
        }
        Qie() {
            return this.WGe
        }
        Wi(t) {
            this.HGe = !!t
        }
        ih() {
            return this.HGe
        }
        yb(t) {
            kG.zt(t),
            this.KGe = t
        }
        LAe() {
            return this.KGe
        }
        yC(t) {
            kG.zt(t),
            this.oAe = t
        }
        BAe() {
            return this.oAe
        }
        yl(t) {
            this.aAe = !!t
        }
        UAe() {
            return this.aAe
        }
        Cf(t) {
            this.qGe = !!t
        }
        sh() {
            return this.qGe
        }
        Mf(t) {
            if (kG.RH(t),
            0 === t.length)
                throw new Error("expected non-empty array");
            this.vf = t
        }
        S7() {
            return Array.isArray(this.vf)
        }
        NAe() {
            return this.vf
        }
        aC(t) {
            this.YGe = !!t
        }
        jAe() {
            return this.YGe
        }
        Il(t) {
            this.XGe = !!t
        }
        $Ae() {
            return this.XGe
        }
        bb(t) {
            this.upi = !!t
        }
        DAt() {
            return this.upi
        }
        bC(t) {
            this.JGe = !!t
        }
        rd() {
            return this.JGe
        }
        Or(t) {
            this.ZGe = !!t
        }
        $Pe() {
            return this.ZGe
        }
        zAe(t) {
            this.QGe = !!t
        }
        VAe() {
            return this.QGe
        }
        WAe(t) {
            this.tAe = !!t
        }
        HAe() {
            return this.tAe
        }
        ni(t) {
            this.iAe = !!t
        }
        poe() {
            return this.iAe
        }
        Ni(t) {
            this.eAe = !!t
        }
        UA() {
            return this.eAe
        }
        ua(t) {
            this.nAe = !!t
        }
        KAe() {
            return this.nAe
        }
        $i(t) {
            this.sAe = !!t
        }
        Uoe() {
            return this.sAe
        }
        Yi(t) {
            this.y4i = !!t
        }
        Rm() {
            return this.y4i
        }
        qAe(t) {
            this.rAe = !!t
        }
        XAe() {
            return this.rAe
        }
        K(t) {
            this.hAe = !!t
        }
        bre() {
            return this.hAe
        }
        Ji() {
            this.lAe = !0
        }
        YAe() {
            return this.lAe
        }
        qi() {
            this.uAe = !0
        }
        JAe() {
            return this.uAe
        }
        Ki() {
            this.cAe = !0
        }
        ZAe() {
            return this.cAe
        }
        Qi() {
            this.dAe = !0
        }
        QAe() {
            return this.dAe
        }
        Zi() {
            this.fAe = !0
        }
        tRe() {
            return this.fAe
        }
        Lr() {
            this.pAe = !0
        }
        iRe() {
            return this.pAe
        }
        Dr() {
            this.mAe = !0
        }
        eRe() {
            return this.mAe
        }
        Ar() {
            this.wAe = !0
        }
        sRe() {
            return this.wAe
        }
        Fr(t) {
            this.SAe = t
        }
        nRe() {
            return this.SAe
        }
        ds() {
            this.gAe = !0
        }
        rRe() {
            return this.gAe
        }
        Ca() {
            this.yAe = !0
        }
        hRe() {
            return this.yAe
        }
        Of() {
            this.bAe = !0
        }
        oRe() {
            return this.bAe
        }
        fs() {
            this.vAe = !0
        }
        aRe() {
            return this.vAe
        }
        O(t) {
            kG.RH(t),
            kG.mf(this.jLi, t),
            this.xAe.clear();
            for (const t of this.jLi)
                this.xAe.set(t.Bk(), t)
        }
        yre() {
            return this.jLi
        }
        Na(t) {
            return kG.zt(t),
            this.xAe.get(t) ?? null
        }
        lRe(t) {
            return kG.zt(t),
            this.xAe.has(t)
        }
        wr(t) {
            const i = kG.v(self.uRe, t);
            return this.MAe.push(i),
            i
        }
        cRe() {
            return this.MAe
        }
        dRe(t) {
            const i = kG.v(self.fRe, t);
            return this.EAe.push(i),
            i
        }
        pRe() {
            return this.EAe
        }
        vt(t) {
            this.CAe.push(kG.v(self.mRe, t))
        }
        wRe() {
            return this.CAe
        }
        gRe(t) {
            const i = [];
            for (const e of this.CAe)
                "inline-script" === e.W7() ? (() => {})(`[Addon SDK] Addon ID '${t.Bk()}' uses an "inline-script" dependency '${e.s0()}'. This is not supported in the addon SDK v2 - use an additional runtime script instead.`) : i.push(e);
            this.CAe = i
        }
        hl(t, i="") {
            if (kG.zt(t),
            t.startsWith("http:"))
                throw new Error("cannot use insecure remote script dependency, use HTTPS");
            if (!FG.has(i))
                throw new Error("invalid type");
            this._Ae.push({
                url: t,
                type: i
            })
        }
        yRe() {
            return this._Ae
        }
        bRe(t) {
            this.TAe = !!t
        }
        vRe() {
            return this.TAe
        }
        SRe(t, i) {
            if (kG.zt(t),
            !t)
                throw new Error("invalid component id");
            kG.RH(i),
            this.IAe = t,
            this.PAe = i
        }
        xRe() {
            return {
                MRe: this.IAe,
                ERe: this.PAe
            }
        }
        CRe(t) {
            this.$Ge = t.slice(0)
        }
        Ke(t) {
            kG.zt(t),
            this.$Ge.push(t)
        }
        _Re() {
            const t = this.$Ge.slice(0);
            return this.jGe && !t.includes(this.jGe) && t.push(this.jGe),
            t
        }
        TRe(t) {
            kG.zt(t),
            this.jGe = t
        }
        IRe() {
            return this.jGe
        }
        br(t) {
            this.zGe = t.slice(0)
        }
        PRe() {
            return this.zGe
        }
        C(t) {
            kG.IL(t),
            kG.gL(t.M),
            kG.gL(t.objectType),
            kG.gL(t.ftt),
            t.M && (this.GAe.M = t.M),
            t.objectType && (this.GAe.objectType = t.objectType),
            t.ftt && (this.GAe.ftt = t.ftt)
        }
        GRe() {
            return this.GAe
        }
        T(t) {
            kG.RH(t),
            this.AAe = t
        }
        ARe() {
            return this.AAe
        }
        Da(t, i) {
            kG.zt(t),
            kG.RH(i),
            this.RAe.set(t, i)
        }
        RRe(t) {
            return this.RAe.get(t)
        }
        kRe() {
            if (!this.Rdi)
                throw new Error("id can not be empty");
            if (!this.Ftt)
                throw new Error("name can not be empty");
            if (this.Ftt === kG.p.tci)
                throw new Error(`failed to load addon name language string for addon '${this.Rdi}' - check the base key in the language file JSON is the lowercased plugin ID: "${this.Rdi.toLowerCase()}"`);
            if (!OG.has(this.DGe) && ("system" !== this.DGe || "system" !== this.Rdi))
                throw new Error(`invalid plugin category '${this.DGe}'`);
            if (!this.FGe)
                throw new Error("must specify author");
            if (!DG.has(this.BGe))
                throw new Error(`invalid plugin type '${this.BGe}'`);
            if (this.LGe && !this.LGe.startsWith("http://") && !this.LGe.startsWith("https://"))
                throw new Error("help URL must begin with http:// or https://");
            if ("world" === this.BGe && this.iAe)
                throw new Error("plugin type 'world' cannot also be single-global");
            if ("object" === this.BGe && this.eAe)
                throw new Error("plugin type 'object' cannot support effects");
            if (this.VGe) {
                if ("object" === this.BGe)
                    throw new Error("plugin type 'object' cannot also be rotatable");
                if (this.iAe)
                    throw new Error("single-global plugins cannot also be rotatable")
            }
            if (this.sEi) {
                if ("object" === this.BGe)
                    throw new Error("plugin type 'object' cannot also be resizable");
                if (this.iAe)
                    throw new Error("single-global plugins cannot also be resizable")
            }
            if (this.HGe) {
                if ("object" === this.BGe)
                    throw new Error("plugin type 'object' cannot have a texture");
                if (this.iAe)
                    throw new Error("single-global plugins cannot have a texture")
            } else if (this.KGe)
                throw new Error("cannot specify default image URL if not using image");
            if (this.qGe) {
                if ("object" === this.BGe)
                    throw new Error("plugin type 'object' cannot have animations");
                if (this.iAe)
                    throw new Error("single-global plugins cannot have animations")
            } else if (this.S7())
                throw new Error("fixed animations mode requires animations");
            if (this.HGe && this.qGe)
                throw new Error("plugin cannot specify both texture and animations");
            if (this.YGe && !this.HGe && !this.qGe)
                throw new Error("plugin cannot be tiled if it doesn't use texture or animations");
            if ("object" === this.BGe && (this.lAe || this.uAe || this.cAe || this.dAe || this.fAe))
                throw new Error("plugin type 'object' cannot use common ACEs");
            kG.QH(this.jLi, self.i);
            let t = new Set;
            for (let i of this.jLi) {
                let e = i.Bk();
                if (t.has(e))
                    throw new Error(`duplicate plugin property ID '${e}'`);
                t.add(e)
            }
            if (!this.iAe && this.PAe.length > 0)
                throw new Error("wrapper export properties require plugin to be single-global");
            if (!this.PAe.every(i => t.has(i)))
                throw new Error("invalid wrapper export property id")
        }
    }
}
{
    const LG = self.t
      , BG = LG.bW(import.meta.url)
      , UG = LG.IW(BG.URL);
    LG.p.MW(UG + "lang"),
    LG.ORe = function(t, i) {
        LG.U(t, self.DRe),
        LG.U(i, self.si),
        LG.p.u("plugins._common"),
        t.FRe(!0);
        const e = self.app
          , s = e.oi("effect")
          , n = e.oi("instance-variable")
          , r = e.oi("layers")
          , h = e.oi("z-order")
          , o = e.oi("template")
          , a = i.nRe();
        let l;
        i.ZAe() && (t.S("angle"),
        t.LRe({
            id: "is-within-angle",
            c2id: -11,
            scriptName: "AngleWithin",
            params: [{
                id: "within",
                type: "number",
                initialValue: .5
            }, {
                id: "angle",
                type: "number"
            }]
        }),
        t.LRe({
            id: "is-clockwise-from",
            c2id: -12,
            scriptName: "IsClockwiseFrom",
            params: [{
                id: "angle",
                type: "number"
            }]
        }),
        t.LRe({
            id: "is-between-angles",
            c2id: -13,
            scriptName: "IsBetweenAngles",
            params: [{
                id: "first-angle",
                type: "number"
            }, {
                id: "second-angle",
                type: "number",
                initialValue: 45
            }]
        }),
        t.BRe({
            id: "set-angle",
            c2id: -8,
            scriptName: "SetAngle",
            params: [{
                id: "angle",
                type: "number"
            }]
        }),
        t.BRe({
            id: "rotate-clockwise",
            c2id: -18,
            scriptName: "RotateClockwise",
            params: [{
                id: "degrees",
                type: "number"
            }]
        }),
        t.BRe({
            id: "rotate-counter-clockwise",
            c2id: -19,
            scriptName: "RotateCounterclockwise",
            params: [{
                id: "degrees",
                type: "number"
            }]
        }),
        t.BRe({
            id: "rotate-toward-angle",
            c2id: -20,
            scriptName: "RotateTowardAngle",
            params: [{
                id: "degrees",
                type: "number"
            }, {
                id: "angle",
                type: "number"
            }]
        }),
        t.BRe({
            id: "rotate-toward-position",
            c2id: -21,
            scriptName: "RotateTowardPosition",
            params: [{
                id: "degrees",
                type: "number"
            }, {
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-angle-toward-position",
            c2id: -22,
            scriptName: "SetTowardPosition",
            params: [{
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }]
        }),
        t.URe({
            id: "angle",
            c2id: -5,
            expressionName: "Angle",
            returnType: "number"
        })),
        i.QAe() && (t.S("appearance"),
        t.LRe({
            id: "is-visible",
            c2id: -9,
            scriptName: "IsVisible"
        }),
        t.LRe({
            id: "compare-opacity",
            c2id: -10,
            scriptName: "CompareOpacity",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "opacity",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-visible",
            c2id: -15,
            scriptName: "SetVisible",
            params: [{
                id: "visibility",
                type: "combo",
                items: ["invisible", "visible", "toggle"],
                initialValue: "visible"
            }]
        }),
        t.BRe({
            id: "set-opacity",
            c2id: -16,
            scriptName: "SetOpacity",
            params: [{
                id: "opacity",
                type: "number",
                initialValue: 100
            }]
        }),
        i.Uoe() && (t.BRe({
            id: "set-default-color",
            scriptName: "SetDefaultColor",
            params: [{
                id: "color",
                type: "number",
                initialValue: "rgbEx(0, 0, 0)"
            }]
        }),
        t.URe({
            id: "color-value",
            expressionName: "ColorValue",
            returnType: "number"
        })),
        t.URe({
            id: "opacity",
            c2id: -7,
            expressionName: "Opacity",
            returnType: "number"
        })),
        i.UA() && (t.S("appearance"),
        t.LRe({
            id: "is-effect-enabled",
            scriptName: "IsEffectEnabled",
            hideInSimplifiedMode: !0,
            params: [{
                id: "effect",
                type: "objecteffect"
            }]
        }).ai(s),
        t.BRe({
            id: "set-effect-enabled",
            c2id: -27,
            scriptName: "SetEffectEnabled",
            hideInSimplifiedMode: !0,
            params: [{
                id: "mode",
                type: "combo",
                items: ["disable", "enable"]
            }, {
                id: "effect",
                type: "objecteffect"
            }]
        }).ai(s),
        t.BRe({
            id: "set-effect-parameter",
            c2id: -28,
            scriptName: "SetEffectParam",
            hideInSimplifiedMode: !0,
            params: [{
                id: "effect",
                type: "objecteffect"
            }, {
                id: "parameter-index",
                type: "number"
            }, {
                id: "value",
                type: "number"
            }]
        }).ai(s)),
        i.poe() || (t.S("instance-variables"),
        t.LRe({
            id: "compare-instance-variable",
            c2id: -7,
            scriptName: "CompareInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "comparison",
                type: "cmp"
            }, {
                id: "value",
                type: "any"
            }]
        }).ai(n),
        t.LRe({
            id: "is-boolean-instance-variable-set",
            c2id: -8,
            scriptName: "IsBoolInstanceVarSet",
            params: [{
                id: "instance-variable",
                type: "instancevarbool"
            }]
        }).ai(n),
        t.LRe({
            id: "pick-highestlowest",
            c2id: -20,
            scriptName: "PickInstVarHiLow",
            params: [{
                id: "which",
                type: "combo",
                items: ["lowest", "highest"]
            }, {
                id: "instance-variable",
                type: "instancevar"
            }],
            isStatic: !0,
            isInvertible: !1
        }).ai(n),
        t.BRe({
            id: "set-instvar-value",
            c2id: -10,
            scriptName: "SetInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "value",
                type: "any"
            }]
        }).ai(n),
        t.BRe({
            id: "add-to-instvar",
            c2id: -11,
            scriptName: "AddInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "value",
                type: "any",
                initialValue: 1
            }]
        }).ai(n),
        t.BRe({
            id: "subtract-from-instvar",
            c2id: -12,
            scriptName: "SubInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "value",
                type: "any",
                initialValue: 1
            }]
        }).ai(n),
        t.BRe({
            id: "set-boolean-instvar",
            c2id: -13,
            scriptName: "SetBoolInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevarbool"
            }, {
                id: "value",
                type: "combo",
                items: ["false", "true"],
                initialValue: "true"
            }]
        }).ai(n),
        t.BRe({
            id: "toggle-boolean-instvar",
            c2id: -14,
            scriptName: "ToggleBoolInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevarbool"
            }]
        }).ai(n),
        t.S("misc"),
        t.LRe({
            id: "pick-by-unique-id",
            c2id: -14,
            scriptName: "PickByUID",
            hideInSimplifiedMode: !0,
            params: [{
                id: "unique-id",
                type: "number"
            }],
            isStatic: !0
        }),
        t.LRe({
            id: "has-tags",
            scriptName: "HasTags",
            params: [{
                id: "tags",
                type: "objectinsttags"
            }],
            hideInSimplifiedMode: !0
        }),
        t.LRe({
            id: "on-created",
            c2id: -18,
            scriptName: "OnCreated",
            isTrigger: !0
        }),
        t.LRe({
            id: "on-destroyed",
            c2id: -19,
            scriptName: "OnDestroyed",
            isTrigger: !0
        }),
        t.BRe({
            id: "destroy",
            c2id: -9,
            scriptName: "Destroy"
        }),
        t.BRe({
            id: "change-tags",
            params: [{
                id: "action",
                type: "combo",
                items: ["add", "remove"]
            }, {
                id: "tags",
                type: "objectinsttags"
            }],
            scriptName: "ChangeTags",
            hideInSimplifiedMode: !0
        }),
        t.URe({
            id: "count",
            c2id: -6,
            expressionName: "Count",
            returnType: "number"
        }),
        t.URe({
            id: "pickedcount",
            c2id: -14,
            expressionName: "PickedCount",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "uid",
            c2id: -9,
            expressionName: "UID",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "iid",
            c2id: -13,
            expressionName: "IID",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        "object" !== i.Ek() && (t.BRe({
            id: "set-from-json",
            c2id: -30,
            scriptName: "LoadFromJsonString",
            hideInSimplifiedMode: !0,
            params: [{
                id: "json",
                type: "string"
            }]
        }),
        t.URe({
            id: "asjson",
            c2id: -19,
            expressionName: "AsJSON",
            hideInSimplifiedMode: !0,
            returnType: "string"
        })),
        t.URe({
            id: "objecttypename",
            expressionName: "ObjectTypeName",
            hideInSimplifiedMode: !0,
            returnType: "string"
        }),
        t.URe({
            id: "get-tags",
            expressionName: "Tags",
            returnType: "string",
            hideInSimplifiedMode: !0
        }),
        t.URe({
            id: "get-tags-count",
            expressionName: "TagsCount",
            returnType: "number",
            hideInSimplifiedMode: !0
        }),
        t.URe({
            id: "get-tag-at",
            expressionName: "TagAt",
            returnType: "string",
            params: [{
                id: "index",
                type: "number"
            }],
            hideInSimplifiedMode: !0
        }),
        t.LRe({
            id: "on-instance-signal",
            scriptName: "OnInstanceSignal",
            isTrigger: !0,
            canDebug: !1,
            params: [{
                id: "tag",
                type: "string",
                autocompleteId: "instance-signal"
            }]
        }),
        t.BRe({
            id: "instance-signal",
            scriptName: "InstanceSignal",
            params: [{
                id: "tag",
                type: "string",
                autocompleteId: "instance-signal"
            }]
        }),
        t.BRe({
            id: "instance-wait-for-signal",
            scriptName: "InstanceWaitForSignal",
            isStatic: !0,
            canBailOut: !0,
            params: [{
                id: "tag",
                type: "string",
                autocompleteId: "instance-signal"
            }]
        })),
        i.YAe() && (t.S("size-position"),
        t.LRe({
            id: "compare-x",
            c2id: -1,
            scriptName: "CompareX",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "x-co-ordinate",
                type: "number"
            }]
        }),
        t.LRe({
            id: "compare-y",
            c2id: -2,
            scriptName: "CompareY",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "y-co-ordinate",
                type: "number"
            }]
        }),
        t.LRe({
            id: "is-on-screen",
            c2id: -3,
            scriptName: "IsOnScreen"
        }),
        t.LRe({
            id: "is-outside-layout",
            c2id: -4,
            scriptName: "IsOutsideLayout"
        }),
        t.LRe({
            id: "pick-nearestfurthest",
            c2id: -15,
            scriptName: "PickDistance",
            params: [{
                id: "which",
                type: "combo",
                items: ["nearest", "furthest"]
            }, {
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }],
            isStatic: !0,
            isInvertible: !1
        }),
        t.BRe({
            id: "set-x",
            c2id: -1,
            scriptName: "SetX",
            params: [{
                id: "x",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-y",
            c2id: -2,
            scriptName: "SetY",
            params: [{
                id: "y",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-position",
            c2id: -3,
            scriptName: "SetPos",
            params: [{
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-position-to-another-object",
            c2id: -4,
            scriptName: "SetPosToObject",
            params: [{
                id: "object",
                type: "object"
            }, {
                id: "image-point-optional",
                type: "any"
            }]
        }),
        i.ZAe() && t.BRe({
            id: "move-forward",
            c2id: -17,
            scriptName: "MoveForward",
            params: [{
                id: "distance",
                type: "number",
                initialValue: 1
            }]
        }),
        t.BRe({
            id: "move-at-angle",
            c2id: -23,
            scriptName: "MoveAtAngle",
            params: [{
                id: "angle",
                type: "number"
            }, {
                id: "distance",
                type: "number",
                initialValue: 1
            }]
        }),
        t.URe({
            id: "x",
            c2id: -1,
            expressionName: "X",
            returnType: "number"
        }),
        t.URe({
            id: "y",
            c2id: -2,
            expressionName: "Y",
            returnType: "number"
        }),
        t.S("time"),
        t.URe({
            id: "dt",
            c2id: -8,
            expressionName: "dt",
            returnType: "number"
        })),
        i.JAe() && (t.S("size-position"),
        t.LRe({
            id: "compare-width",
            c2id: -5,
            scriptName: "CompareWidth",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "width",
                type: "number"
            }]
        }),
        t.LRe({
            id: "compare-height",
            c2id: -6,
            scriptName: "CompareHeight",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "height",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-width",
            c2id: -5,
            scriptName: "SetWidth",
            params: [{
                id: "width",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-height",
            c2id: -6,
            scriptName: "SetHeight",
            params: [{
                id: "height",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-size",
            c2id: -7,
            scriptName: "SetSize",
            params: [{
                id: "width",
                type: "number"
            }, {
                id: "height",
                type: "number"
            }]
        }),
        t.URe({
            id: "width",
            c2id: -3,
            expressionName: "Width",
            returnType: "number"
        }),
        t.URe({
            id: "height",
            c2id: -4,
            expressionName: "Height",
            returnType: "number"
        }),
        t.URe({
            id: "bboxleft",
            c2id: -15,
            expressionName: "BBoxLeft",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "bboxtop",
            c2id: -16,
            expressionName: "BBoxTop",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "bboxright",
            c2id: -17,
            expressionName: "BBoxRight",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "bboxbottom",
            c2id: -18,
            expressionName: "BBoxBottom",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "bboxmidx",
            expressionName: "BBoxMidX",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "bboxmidy",
            expressionName: "BBoxMidY",
            hideInSimplifiedMode: !0,
            returnType: "number"
        })),
        i.tRe() && (t.S("z-order"),
        t.LRe({
            id: "is-on-layer",
            c2id: -16,
            scriptName: "IsOnLayer",
            params: [{
                id: "layer",
                type: "layer"
            }]
        }).ai(r),
        t.LRe({
            id: "pick-topbottom",
            c2id: -17,
            scriptName: "PickTopBottom",
            params: [{
                id: "which",
                type: "combo",
                items: ["top", "bottom"]
            }],
            isStatic: !0
        }).ai(h),
        t.BRe({
            id: "move-to-top",
            c2id: -24,
            scriptName: "MoveToTop"
        }).ai(h),
        t.BRe({
            id: "move-to-bottom",
            c2id: -25,
            scriptName: "MoveToBottom"
        }).ai(h),
        t.BRe({
            id: "move-to-layer",
            c2id: -26,
            scriptName: "MoveToLayer",
            params: [{
                id: "layer",
                type: "layer"
            }]
        }).ai(r),
        t.BRe({
            id: "move-to-object",
            c2id: -29,
            scriptName: "ZMoveToObject",
            params: [{
                id: "where",
                type: "combo",
                items: ["in-front", "behind"]
            }, {
                id: "object",
                type: "object"
            }]
        }).ai(h),
        t.URe({
            id: "layernumber",
            c2id: -10,
            expressionName: "LayerNumber",
            returnType: "number"
        }).ai(r),
        t.URe({
            id: "layername",
            c2id: -11,
            expressionName: "LayerName",
            returnType: "string"
        }).ai(r),
        t.URe({
            id: "zindex",
            c2id: -12,
            expressionName: "ZIndex",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }).ai(h),
        i.Qie() && (t.LRe({
            id: "compare-z-elevation",
            scriptName: "CompareZElevation",
            hideInSimplifiedMode: !0,
            params: [{
                id: "which",
                type: "combo",
                items: ["z-elevation", "total-z-elevation"]
            }, {
                id: "comparison",
                type: "cmp"
            }, {
                id: "z-elevation",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-z-elevation",
            scriptName: "SetZElevation",
            hideInSimplifiedMode: !0,
            params: [{
                id: "z",
                type: "number"
            }]
        }),
        t.URe({
            id: "z-elevation",
            expressionName: "ZElevation",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "total-z-elevation",
            expressionName: "TotalZElevation",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }))),
        i.oRe() && (t.S("collisions"),
        t.LRe({
            id: "on-collision-with-another-object",
            c2id: 0,
            scriptName: "OnCollision",
            params: [{
                id: "object",
                type: "object"
            }],
            isFakeTrigger: !0,
            canDebug: !0,
            isStatic: !0,
            highlight: !0
        }),
        t.LRe({
            id: "is-overlapping-another-object",
            c2id: 1,
            scriptName: "IsOverlapping",
            params: [{
                id: "object",
                type: "object"
            }]
        }),
        t.LRe({
            id: "is-overlapping-at-offset",
            c2id: 9,
            scriptName: "IsOverlappingOffset",
            hideInSimplifiedMode: !0,
            params: [{
                id: "object",
                type: "object"
            }, {
                id: "offset-x",
                type: "number"
            }, {
                id: "offset-y",
                type: "number"
            }]
        })),
        i.rRe() && (t.S("hierarchy"),
        t.LRe({
            id: "on-hierarchy-ready",
            scriptName: "OnHierarchyReady",
            isTrigger: !0
        }),
        t.LRe({
            id: "has-parent",
            scriptName: "HasParent",
            hideInSimplifiedMode: !0
        }),
        t.LRe({
            id: "has-children",
            scriptName: "HasChildren",
            hideInSimplifiedMode: !0
        }),
        t.LRe({
            id: "pick-parent",
            scriptName: "PickParent",
            isStatic: !0,
            isInvertible: !1,
            hideInSimplifiedMode: !0,
            params: [{
                id: "parent",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "which",
                type: "combo",
                items: ["own", "all", "top"]
            }]
        }),
        t.LRe({
            id: "pick-children",
            scriptName: "PickChildren",
            isStatic: !0,
            isInvertible: !1,
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "which",
                type: "combo",
                items: ["own", "all", "bottom"]
            }]
        }),
        t.LRe({
            id: "pick-nth-child",
            scriptName: "PickNthChild",
            isStatic: !0,
            isInvertible: !1,
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "index-type",
                type: "combo",
                items: ["all", "filtered"]
            }, {
                id: "instance",
                type: "number"
            }]
        }),
        t.LRe({
            id: "compare-child-count",
            scriptName: "CompareChildCount",
            hideInSimplifiedMode: !0,
            params: [{
                id: "which",
                type: "combo",
                items: ["own", "all"]
            }, {
                id: "comparison",
                type: "cmp"
            }, {
                id: "count",
                type: "number"
            }]
        }),
        t.BRe({
            id: "add-child",
            scriptName: "AddChild",
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "transform-x",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-y",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-w",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-h",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-a",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-o",
                type: "boolean",
                initialValue: "false"
            }, {
                id: "transform-z-elevation",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-visibility",
                type: "boolean",
                initialValue: "false"
            }, {
                id: "destroy-with-parent",
                type: "boolean"
            }]
        }),
        t.BRe({
            id: "remove-child",
            scriptName: "RemoveChild",
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }]
        }),
        t.BRe({
            id: "remove-from-parent",
            scriptName: "RemoveFromParent",
            hideInSimplifiedMode: !0
        }),
        t.URe({
            id: "parent-uid",
            expressionName: "ParentUID",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "child-count",
            expressionName: "ChildCount",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "all-child-count",
            expressionName: "AllChildCount",
            hideInSimplifiedMode: !0,
            returnType: "number"
        })),
        i.hRe() && (t.S("mesh"),
        t.BRe({
            id: "set-mesh-size",
            scriptName: "SetMeshSize",
            hideInSimplifiedMode: !0,
            params: [{
                id: "cols",
                type: "number"
            }, {
                id: "rows",
                type: "number"
            }]
        }),
        t.BRe({
            id: "set-mesh-point",
            scriptName: "SetMeshPoint",
            hideInSimplifiedMode: !0,
            params: [{
                id: "col",
                type: "number"
            }, {
                id: "row",
                type: "number"
            }, {
                id: "mode",
                type: "combo",
                items: ["absolute", "relative"]
            }, {
                id: "posx",
                type: "number"
            }, {
                id: "posy",
                type: "number"
            }, {
                id: "z-elevation",
                type: "number"
            }, {
                id: "texx",
                type: "number",
                initialValue: "-1"
            }, {
                id: "texy",
                type: "number",
                initialValue: "-1"
            }]
        }),
        t.URe({
            id: "mesh-columns",
            expressionName: "MeshColumns",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.URe({
            id: "mesh-rows",
            expressionName: "MeshRows",
            hideInSimplifiedMode: !0,
            returnType: "number"
        })),
        i.iRe() && (t.S("html-element"),
        t.LRe({
            id: "is-visible",
            scriptName: "IsVisible"
        }),
        l = {
            id: "set-visible",
            scriptName: "SetVisible",
            params: [{
                id: "visibility",
                type: "combo",
                items: ["invisible", "visible", "toggle"]
            }]
        },
        a.hasOwnProperty("set-visible") && (l.c2id = a["set-visible"]),
        t.BRe(l),
        l = {
            id: "set-css-style",
            scriptName: "SetCSSStyle",
            hideInSimplifiedMode: !0,
            params: [{
                id: "property-name",
                type: "string",
                initialValue: '"border"'
            }, {
                id: "value",
                type: "string",
                initialValue: '"1px solid red"'
            }]
        },
        a.hasOwnProperty("set-css-style") && (l.c2id = a["set-css-style"]),
        t.BRe(l),
        t.BRe({
            id: "set-elem-attribute",
            scriptName: "SetElemAttribute",
            hideInSimplifiedMode: !0,
            params: [{
                id: "attribute-name",
                type: "string"
            }, {
                id: "attribute-value",
                type: "any",
                initialValue: '""'
            }]
        }),
        t.BRe({
            id: "remove-elem-attribute",
            scriptName: "RemoveElemAttribute",
            hideInSimplifiedMode: !0,
            params: [{
                id: "attribute-name",
                type: "string"
            }]
        })),
        i.eRe() && (t.S("html-element"),
        t.LRe({
            id: "is-focused",
            scriptName: "IsFocused"
        }),
        l = {
            id: "set-focused",
            scriptName: "SetFocus",
            hideInSimplifiedMode: !0
        },
        a.hasOwnProperty("set-focused") && (l.c2id = a["set-focused"]),
        t.BRe(l),
        l = {
            id: "set-unfocused",
            scriptName: "SetBlur",
            hideInSimplifiedMode: !0
        },
        a.hasOwnProperty("set-unfocused") && (l.c2id = a["set-unfocused"]),
        t.BRe(l)),
        i.sRe() && (t.S("html-element"),
        t.LRe({
            id: "is-enabled",
            scriptName: "IsEnabled"
        }),
        l = {
            id: "set-enabled",
            scriptName: "SetEnabled",
            params: [{
                id: "mode",
                type: "combo",
                items: ["disabled", "enabled"]
            }]
        },
        a.hasOwnProperty("set-enabled") && (l.c2id = a["set-enabled"]),
        t.BRe(l)),
        i.aRe() && (t.S("template"),
        t.URe({
            id: "template-name",
            expressionName: "TemplateName",
            returnType: "string"
        }).ai(o)),
        LG.p.j(),
        t.FRe(!1)
    }
}
{
    const NG = self.t
      , jG = self.i
      , $G = self.Yfi
      , zG = (new Set(["default", "npm", "pgb"]),
    new Set(["all", "android", "ios", "windows"]))
      , VG = {
        id: "",
        version: "",
        platform: "all"
    };
    class WG {
        constructor(t, i) {
            NG.zt(t),
            NG.zt(i),
            this.Ftt = t,
            this.$fi = i
        }
        NRe() {
            return ""
        }
        Ade() {
            return ""
        }
        Ft(t) {
            return this.$fi
        }
        La() {
            return this.Ftt
        }
        Gzi() {
            return !0
        }
        wMe(t) {
            return NG.U(t, self.jw),
            [this.La(), this.Ft(t)]
        }
    }
    class HG extends WG {
        constructor(t, i, e) {
            NG.U(e, jG),
            NG.U(t, NG.ii),
            super(i, ""),
            this.jRe = e,
            this.hi = t,
            this.$Re = !1
        }
        NRe() {
            return this.hi.$a().La()
        }
        Ade() {
            return this.jRe.La()
        }
        zRe() {
            this.$Re = !0
        }
        Gzi() {
            return !this.$Re
        }
        Ft(t) {
            return t.VRe(this.hi).js(this.jRe.Bk())
        }
    }
    class KG extends WG {
        constructor(t, i, e, s) {
            super(e, s),
            this.hi = t,
            this.WRe = i
        }
        NRe() {
            return this.hi.$a().La()
        }
        HRe() {
            return this.WRe.HRe()
        }
        wMe(t) {
            return NG.U(t, self.jw),
            [this.La(), this.Ft(t), this.HRe()]
        }
    }
    window.uRe = class extends NG.Me {
        constructor(t) {
            if (super(),
            t = Object.assign({}, VG, t),
            NG.zt(t.id),
            NG.zt(t.version),
            NG.zt(t.platform),
            NG.D_t(t.KRe),
            !t.id)
                throw new Error("id cannot be empty");
            if (!zG.has(t.platform))
                throw new Error("invalid platform");
            let i = t.ftt;
            if (i instanceof window.SDK.IPluginBase && (i = t.ftt.qRe()),
            NG.Ef(i, NG.ii),
            this.Rdi = t.id,
            this.Wtt = t.version,
            this.XRe = t.platform,
            this.YRe = [],
            this.JRe = [],
            t.KRe)
                for (const e of t.KRe) {
                    NG.RH(e);
                    let[t,s] = e;
                    s instanceof window.SDK.PluginProperty && (s = jG.GGe(s)),
                    this.yr(i, t, s)
                }
        }
        Wxt() {
            return this.Rdi
        }
        a6() {
            return this.Wtt
        }
        Hot() {
            return this.dmt
        }
        HRe() {
            return this.XRe
        }
        ZRe(t) {
            if (NG.U(t, self.jw),
            this.YRe.length > 0) {
                const i = [];
                for (const e of this.YRe) {
                    const s = e.wMe(t);
                    if (e.Gzi()) {
                        const t = s[1].toString();
                        if (!("" !== t.trim() || t && NG.Eoi(t)))
                            return $G.qfi(self.h_("ui.export.cordova-variable-required", e.Ade(), e.NRe()))
                    }
                    i.push(s)
                }
                return $G.Ok(i)
            }
            return $G.Ok(null)
        }
        QRe(t) {
            if (NG.U(t, self.jw),
            this.JRe.length > 0) {
                const i = [];
                for (const e of this.JRe)
                    i.push(e.wMe(t));
                return $G.Ok(i)
            }
            return $G.Ok(null)
        }
        yr(t, i, e) {
            NG.U(t, NG.ii),
            NG.U(e, jG),
            NG.zt(i);
            const s = NG.v(HG, t, i, e);
            return this.YRe.push(s),
            s
        }
        Sr(t, i, e) {
            NG.U(t, NG.ii),
            NG.zt(i),
            NG.zt(e);
            const s = NG.v(KG, t, this, i, e);
            return this.JRe.push(s),
            s
        }
        tke(t, i) {
            NG.zt(t),
            NG.zt(i);
            const e = NG.v(WG, t, i);
            return this.YRe.push(e),
            e
        }
        $a() {
            return this.hi
        }
    }
}
{
    const qG = self.t
      , XG = new Set(["all", "android", "ios"])
      , YG = {
        src: "",
        target: "",
        platform: "all"
    };
    window.fRe = class extends qG.Me {
        constructor(t) {
            if (super(),
            t = Object.assign({}, YG, t),
            qG.zt(t.src),
            qG.zt(t.target),
            qG.zt(t.platform),
            !XG.has(t.platform))
                throw new Error("invalid platform");
            this.ike = t.src,
            this.fqi = t.target,
            this.XRe = t.platform
        }
        eke() {
            return this.ike
        }
        ske() {
            return this.fqi
        }
        HRe() {
            return this.XRe
        }
    }
}
{
    const JG = self.t
      , ZG = new Set(["copy-to-output", "inline-script", "external-script", "external-dom-script", "external-runtime-script", "external-css", "wrapper-extension"])
      , QG = new Set(["", "module"])
      , tA = {
        filename: "",
        Vt: "",
        nke: "",
        type: "copy-to-output",
        platform: "all"
    };
    window.mRe = class extends JG.Me {
        constructor(t) {
            if (super(),
            t = Object.assign({}, tA, t),
            JG.zt(t.filename),
            JG.gL(t.Vt),
            JG.gL(t.nke),
            JG.zt(t.type),
            JG.zt(t.platform),
            !t.filename)
                throw new Error("filename cannot be empty");
            if (!QG.has(t.nke))
                throw new Error("invalid script type");
            if (!ZG.has(t.type))
                throw new Error("invalid dependency type");
            if (!t.platform)
                throw new Error("platform cannot be empty");
            if (this.N_i = t.filename,
            this.rke = t.Vt,
            this.hke = t.nke,
            this.aGt = t.type,
            this.XRe = t.platform,
            "external-script" === this.aGt && (this.aGt = "external-dom-script"),
            !this.rke)
                if (this.aGt.endsWith("-script"))
                    this.rke = "application/javascript";
                else if ("external-css" === this.aGt)
                    this.rke = "text/css";
                else {
                    if ("wrapper-extension" !== this.aGt)
                        throw new Error(`file dependency '${this.N_i}' must specify a fileType`);
                    this.rke = "application/octet-stream"
                }
        }
        s0() {
            return this.N_i
        }
        oke() {
            return this.rke
        }
        ake() {
            return this.hke
        }
        W7() {
            return this.aGt
        }
        HRe() {
            return this.XRe
        }
    }
}
{
    const iA = self.t
      , eA = "#00768E"
      , sA = new Set(["CORDOVAIAP", "IAP", "Multiplayer", "admob", "advert", "pubcenter", "iad", "XboxLive", "InstantGames"]);
    window.Plugin = class extends globalThis.NPe {
        constructor(t, i) {
            iA.U(t, iA.ii),
            super(),
            this.T0i = t,
            this.m = this.T0i.GetInfo(),
            this.lke = iA.v(self.DRe),
            this.dmt = i.source,
            this.$Ge = new Map,
            this.uke = null,
            this.uOi = null,
            this.cOi = null,
            this.dOi = null,
            this.cke = null,
            this.dke = null,
            this.fke = null,
            this.pke = null,
            this.m.kRe(),
            this.T0i.KPe(this),
            i.mke && (this.uke = iA.v(iA.Qs.YRi, self.app, null, {
                name: "plugin-" + this.Bk(),
                color: eA,
                wOi: i.mke
            }))
        }
        he() {
            this.T0i.he(),
            this.T0i = null,
            this.m = null,
            this.lke.he(),
            this.lke = null,
            this.$Ge.clear()
        }
        wke(t) {
            iA.IL(t),
            iA.ORe(this.lke, this.m),
            iA.p.u("plugins." + this.Bk().toLowerCase());
            const i = !!this.m.$Pe();
            i && iA.p.Mr(!1);
            for (let[i,e] of Object.entries(t)) {
                if ("$schema" === i)
                    continue;
                this.lke.S(i);
                let t = e.conditions
                  , s = e.actions
                  , n = e.expressions;
                if (t)
                    for (let i of t)
                        this.lke.LRe(i);
                if (s)
                    for (let t of s)
                        this.lke.BRe(t);
                if (n)
                    for (let t of n)
                        this.lke.URe(t)
            }
            i && iA.p.Mr(!0),
            this.lke.gke(),
            iA.p.j(),
            this.T0i.ri(),
            this.yke()
        }
        yke() {
            const t = []
              , i = []
              , e = [];
            this.rRe() && (t.push(["has-parent", "scene-graph"], ["has-children", "scene-graph"], ["pick-parent", "scene-graph"], ["pick-children", "scene-graph"], ["pick-nth-child", "scene-graph"], ["compare-child-count", "scene-graph"]),
            i.push(["add-child", "scene-graph"], ["remove-child", "scene-graph"], ["remove-from-parent", "scene-graph"]),
            e.push(["parent-uid", "scene-graph"], ["child-count", "scene-graph"], ["all-child-count", "scene-graph"])),
            this.hRe() && (i.push(["set-mesh-size", "mesh"], ["set-mesh-point", "mesh"]),
            e.push(["mesh-columns", "mesh"], ["mesh-rows", "mesh"]));
            const s = self.app;
            for (const [i,e] of t)
                this.li(i).ai(s.oi(e));
            for (const [t,e] of i)
                this.ci(t).ai(s.oi(e));
            for (const [t,i] of e)
                this.ui(t).ai(s.oi(i))
        }
        Bk() {
            return this.m.Wxt()
        }
        W7() {
            return "plugin"
        }
        La() {
            return this.m.La()
        }
        nse() {
            return this.m.nse()
        }
        a6() {
            return this.m.a6()
        }
        bke() {
            return 1
        }
        OAe() {
            return this.m.OAe()
        }
        rse() {
            return this.m.rse()
        }
        foe() {
            return this.m.foe()
        }
        Hot() {
            return this.dmt
        }
        Ek() {
            return this.m.Ek()
        }
        zz() {
            return this.m.zz()
        }
        Q$() {
            return this.m.Q$()
        }
        poe() {
            return this.m.poe()
        }
        Qie() {
            return this.m.Qie()
        }
        UAe() {
            return this.m.UAe()
        }
        vke() {
            return "html-elements" === this.OAe()
        }
        ih() {
            return this.m.ih()
        }
        Ske() {
            return null
        }
        xke() {
            return Promise.resolve([])
        }
        sh() {
            return this.m.sh()
        }
        S7() {
            return this.m.S7()
        }
        NAe() {
            return this.m.NAe()
        }
        jAe() {
            return this.m.jAe()
        }
        $Ae() {
            return this.m.$Ae()
        }
        DAt() {
            return this.m.DAt()
        }
        rd() {
            return this.m.rd()
        }
        $Pe() {
            return this.m.$Pe()
        }
        Mke() {
            this.m.Or(!0)
        }
        VAe() {
            return this.m.VAe()
        }
        HAe() {
            return this.m.HAe()
        }
        fae() {
            return this.$Pe() || this.HAe() && !self.app.Eke()
        }
        UA() {
            return this.m.UA()
        }
        KAe() {
            return this.m.KAe()
        }
        Uoe() {
            return this.m.Uoe()
        }
        Rm() {
            return this.m.Rm()
        }
        LA() {
            return !this.poe()
        }
        WA() {
            return !this.poe() && "world" === this.Ek()
        }
        Cke() {
            return "object" === this.Ek() && !this.poe()
        }
        YAe() {
            return this.m.YAe()
        }
        JAe() {
            return this.m.JAe()
        }
        ZAe() {
            return this.m.ZAe()
        }
        QAe() {
            return this.m.QAe()
        }
        tRe() {
            return this.m.tRe()
        }
        iRe() {
            return this.m.iRe()
        }
        eRe() {
            return this.m.eRe()
        }
        sRe() {
            return this.m.sRe()
        }
        rRe() {
            return this.m.rRe()
        }
        EP() {
            return this.rRe()
        }
        hRe() {
            return this.m.hRe()
        }
        aT() {
            return this.hRe()
        }
        oRe() {
            return this.m.oRe()
        }
        aRe() {
            return this.m.aRe()
        }
        yre() {
            return this.m.yre()
        }
        Na(t) {
            iA.zt(t);
            const i = this.m.Na(t);
            if (!i)
                throw new Error(`plugin property id '${t}' not found`);
            return i
        }
        lRe(t) {
            return iA.zt(t),
            this.m.lRe(t)
        }
        cRe() {
            return this.m.cRe()
        }
        pRe() {
            return this.m.pRe()
        }
        _ke() {
            return this.m.vRe()
        }
        xRe() {
            return this.m.xRe()
        }
        ez() {
            return this.T0i
        }
        Tke() {
            return `plugins/${this.Bk()}/`
        }
        Ike() {
            return iA.Abi.wvi() + this.Tke()
        }
        Pke() {
            return !!this.IRe()
        }
        IRe() {
            return this.m.IRe()
        }
        async Gke(t, i) {
            iA.kK()
        }
        async Ake(t, i, e) {
            iA.kK()
        }
        wRe() {
            return this.m.wRe()
        }
        yRe() {
            return this.m.yRe()
        }
        GRe() {
            return this.m.GRe()
        }
        ARe() {
            return this.m.ARe()
        }
        XAe() {
            return this.m.XAe() && "dev" !== this.Hot()
        }
        bre() {
            return this.m.bre()
        }
        r1i() {
            iA.kK()
        }
        FAe() {
            return this.m.FAe()
        }
        Rke() {
            return "image/svg+xml" === this.FAe()
        }
        kke() {
            !this.uke && this.Rke() && (this.uke = iA.v(iA.Qs.YRi, self.app, this.r1i(), {
                name: "plugin-" + this.Bk(),
                color: eA
            }))
        }
        md() {
            if (this.kke(),
            !this.uke)
                throw new Error("no svg icon");
            return this.uke.$ii()
        }
        uP() {
            return this.uOi || (this.kke(),
            this.uke ? this.uOi = this.uke.uP() : this.uOi = iA.Qs.d0.ski(this.r1i(), self.app.m4(), {
                wd: this.Rke()
            })),
            this.uOi
        }
        M8() {
            return this.cOi || (this.kke(),
            this.uke ? this.cOi = this.uke.M8() : this.cOi = iA.Qs.d0.ski(this.r1i(), self.app.Oq(), {
                wd: this.Rke()
            })),
            this.cOi
        }
        COi() {
            return this.dOi || (this.kke(),
            this.uke ? this.dOi = this.uke.COi() : this.dOi = iA.Qs.d0.ski(this.r1i(), self.app.s8(), {
                wd: this.Rke()
            })),
            this.dOi
        }
        eNi(t) {
            switch (iA.zt(t),
            t) {
            case "small":
                return this.uP();
            case "medium":
                return this.M8();
            case "large":
                return this.COi();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        Oke() {
            return this.cke || (this.cke = iA.Qs.d0.hP(null, self.app.m4(), {
                name: this.Bk() + "-family"
            }),
            this.cke.Yme(),
            this.cke.Zme([this.uP(), {
                icon: self.app.oi("family-overlay-mask"),
                type: "mask"
            }, self.app.oi("family-overlay")])),
            this.cke
        }
        Dke() {
            return this.dke || (this.dke = iA.Qs.d0.hP(null, self.app.Oq(), {
                name: this.Bk() + "-family"
            }),
            this.dke.Yme(),
            this.dke.Zme([this.M8(), {
                icon: self.app.u0("family-overlay-mask"),
                type: "mask"
            }, self.app.u0("family-overlay")])),
            this.dke
        }
        Fke() {
            return this.fke || (this.fke = iA.Qs.d0.hP(null, self.app.s8(), {
                name: this.Bk() + "-family"
            }),
            this.fke.Yme(),
            this.fke.Zme([this.COi(), {
                icon: self.app.s1i("family-overlay-mask"),
                type: "mask"
            }, self.app.s1i("family-overlay")])),
            this.fke
        }
        RRe(t) {
            return this.m.RRe(t)
        }
        li(t) {
            return iA.zt(t),
            this.lke.li(t)
        }
        Lke(t) {
            return iA.Ge(t),
            this.lke.Lke(t)
        }
        M4t() {
            return this.lke.M4t()
        }
        I7t() {
            return this.lke.I7t()
        }
        ZPe(t) {
            return this.lke.ZPe(t)
        }
        ci(t) {
            return iA.zt(t),
            this.lke.ci(t)
        }
        Bke(t) {
            return iA.Ge(t),
            this.lke.Bke(t)
        }
        actions() {
            return this.lke.actions()
        }
        xQt() {
            return this.lke.xQt()
        }
        ui(t) {
            return iA.zt(t),
            this.lke.ui(t)
        }
        Uke(t) {
            return iA.Ge(t),
            this.lke.Uke(t)
        }
        ki(t) {
            return iA.zt(t),
            this.lke.ki(t)
        }
        Nke(t) {
            return iA.zt(t),
            !!this.ki(t)
        }
        jke() {
            return this.lke.jke()
        }
        $ke() {
            return this.lke.$ke()
        }
        zke(t) {
            if (iA.zt(t),
            "conditions" === t)
                return this.M4t();
            if ("actions" === t)
                return this.actions();
            if ("expressions" === t)
                return this.jke();
            throw new Error("invalid ace type")
        }
        OL(t, i) {
            if (iA.U(t, self.jw),
            iA.gL(i),
            this.poe() && t.vUt().has(this))
                throw new Error("single-global plugin already in project");
            if (i) {
                if (i = self.i_.hW(i, !0),
                t.gUt(i))
                    throw new Error(`object type name '${i}' already used`)
            } else
                i = t.eL(this.La());
            let e = iA.v(self.s_, t, this, i);
            return e.Zs = this.T0i.OL(e),
            this.poe() && e.Vke(),
            this.UAe() || "worker" !== t.Dse() || t.Wke("auto"),
            e
        }
        Hke() {
            return !sA.has(this.Bk())
        }
        static Kke(t, i) {
            const e = (iA.Jvt(t) ? t.qke : t.La()).toLowerCase()
              , s = (iA.Jvt(i) ? i.qke : i.La()).toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const nA = self.t
      , rA = ["c3runtime/plugin.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"];
    window.Xke = class extends self.Plugin {
        constructor(t, i) {
            if (nA.U(t, nA.ii),
            super(t, i),
            nA.q8t()) {
                const t = this.m._Re();
                nA.lAt(t, new Set(rA)),
                t.unshift("c3runtime/runtime.js"),
                this.m.CRe(t)
            }
            this.$It = "",
            i.path && (this.$It = new URL(i.path,nA.Vgt()).toString(),
            t.Pf(this.$It)),
            this.pke = null;
            const e = this.m.LAe();
            if (this.m.ih() && e && nA._4(e).then(t => this.pke = t).catch(t => console.error("Error loading default image: ", t)),
            this.m.S7())
                for (const t of this.m.NAe())
                    nA._4(t.If).then(i => t.Yke = i).catch(t => console.error("Error loading default image: ", t));
            this.Jke = null;
            const s = this.m.BAe();
            s && (this.Jke = nA.O4(s).catch(t => console.error("Error loading default data: ", t)))
        }
        he() {
            this.pke = null,
            this.Jke = null,
            super.he()
        }
        Ske() {
            return this.pke
        }
        xke() {
            return this.Jke ? this.Jke : super.xke()
        }
        Zke() {
            return this.m._Re().map(t => this.$It + t)
        }
        async Qke(t, i, e, s) {
            return await Promise.all(e.map(async e => {
                if ("preview" === t)
                    return this.$It + e;
                {
                    const t = this.Ike() + e
                      , n = this.Tke() + e;
                    i.set(t, null);
                    const r = await this.tOe(e);
                    return i.set(t, r),
                    s ? t : n
                }
            }
            ))
        }
        async Gke(t, i) {
            return await this.Qke(t, i, this.m.PRe(), !0)
        }
        async Ake(t, i, e) {
            return await this.Qke(t, i, this.m._Re(), !1)
        }
        async tOe(t) {
            nA.zt(t);
            const i = this.$Ge.get(t);
            if (i)
                return i;
            const e = await fetch(this.$It + t)
              , s = await e.text();
            return this.$Ge.set(t, s),
            s
        }
        r1i() {
            return this.$It + this.m.DAe()
        }
        JOt() {
            return this.$It
        }
        iOe(t) {
            return this.$It + t
        }
        eOe(t) {
            return this.iOe(t)
        }
        a6() {
            return nA.dQ.mPe
        }
    }
}
{
    const hA = self.t
      , oA = new Set([1, 2]);
    window.sOe = class extends self.Plugin {
        constructor(t, i) {
            t instanceof window.SDK.IPluginBase && (t = t.qRe()),
            hA.U(t, hA.ii),
            super(t, i);
            const e = i.nOe;
            if (this.Ett = i.files,
            this.rOe = new Map,
            this.hOe = e["sdk-version"] ?? 1,
            !oA.has(this.hOe))
                throw new Error(`addon ID '${this.Bk()}' specifies invalid SDK version ${this.hOe}`);
            this.hOe >= 2 && (this.m.kAe() && (() => {})(`[Addon SDK] Addon ID '${this.Bk()}' called SetVersion(). This is ignored in the Addon SDK v2 and the version set in addon.json is used instead. Remove the call to SetVersion() to clear this warning.`),
            this.m.P(e.version),
            this.m.yl(e["supports-worker-mode"] ?? !0),
            this.m.gRe(this),
            this.m.IRe() || this.oOe()),
            this.aOe = i.lOe,
            this.pke = null;
            const s = this.m.LAe();
            this.m.ih() && s && (this.pke = this.uOe(s))
        }
        wke(t) {
            super.wke(t);
            for (const t of [...this.M4t(), ...this.actions()])
                if (!t.cOe())
                    for (const i of t.parameters()) {
                        if (!i.dOe(this.bke()))
                            throw new Error(`Addon '${this.Bk()}' ACE '${t.Bk()}' uses "${i.W7()}" parameter which is not supported in the SDK. Refer to the SDK documentation for supported types. Note support for condition/action variadic parameters has been removed - see: https://www.construct.net/forum/construct-3/plugin-sdk-10/variadic-parameters-removed-143189`);
                        this.bke() < 2 && i.fOe()
                    }
        }
        he() {
            this.Ett = null,
            this.pke = null,
            super.he()
        }
        bke() {
            return this.hOe
        }
        Ske() {
            return this.pke
        }
        Pke() {
            return this.bke() >= 2 && super.Pke()
        }
        oOe() {
            const t = "c3runtime/main.js";
            if (!this.Ett.hasOwnProperty(t)) {
                const i = this.m._Re().map(t => `import "./${t.startsWith("c3runtime/") ? t.substr(10) : t}";`).join("\n");
                this.Ett[t] = new Blob([i],{
                    type: "application/javascript"
                })
            }
            this.m.TRe(t)
        }
        Zke() {
            return this.m._Re().map(t => this.iOe(t))
        }
        async Gke(t, i) {
            return await Promise.all(this.m.PRe().map(async t => {
                const e = this.Ike() + t;
                i.set(e, null);
                const s = await this.tOe(t);
                return i.set(e, s),
                e
            }
            ))
        }
        Ake(t, i, e) {
            return this.hOe >= 2 ? this.pOe(t, e) : this.mOe(t, i)
        }
        async mOe(t, i) {
            const e = this.m.wRe().filter(t => "inline-script" === t.W7()).map(t => t.s0());
            return hA.Oo(e, this.m._Re()),
            await Promise.all(e.map(async t => {
                const e = this.Tke() + t
                  , s = hA.Abi.wvi() + e;
                i.set(s, null);
                const n = await this.tOe(t);
                return i.set(s, n),
                e
            }
            ))
        }
        async pOe(t, i) {
            return await Promise.all(this.m._Re().map(async t => {
                const e = await this.tOe(t)
                  , s = this.Ike() + t;
                i.set(s, e)
            }
            )),
            []
        }
        async tOe(t) {
            hA.zt(t);
            const i = this.$Ge.get(t);
            if (i)
                return i;
            self.assert(this.Ett.hasOwnProperty(t), `missing addon '${this.Bk()}' plugin runtime file`);
            const e = await hA.Ist(this.Ett[t]);
            return this.$Ge.set(t, e),
            e
        }
        r1i() {
            const t = this.m.DAe();
            try {
                return this.iOe(t)
            } catch (i) {
                return console.error(`Error loading addon '${this.Bk()}' icon: `, i),
                t
            }
        }
        iOe(t) {
            let i = this.rOe.get(t);
            if (i)
                return i;
            const e = this.Ett[t];
            if (!e)
                throw new Error(`addon '${this.Bk()}' missing file '${t}'`);
            return i = URL.createObjectURL(e),
            this.rOe.set(t, i),
            i
        }
        uOe(t) {
            const i = this.Ett[t];
            if (!i)
                throw new Error(`addon '${this.Bk()}' missing file '${t}'`);
            return i
        }
        eOe(t) {
            return this.uOe(t)
        }
        wOe() {
            return this.Ett._c3addon
        }
        async gOe() {
            if ("dev" !== this.Hot() || !this.aOe)
                return;
            this.$Ge.clear();
            const t = Object.keys(this.aOe)
              , i = new Map;
            try {
                await Promise.all(t.map(async t => {
                    const e = this.aOe[t]
                      , s = await hA._4(e);
                    i.set(t, s)
                }
                ))
            } catch (t) {
                return void console.error(`Error reloading developer addon '${this.Bk()}' files: `, t)
            }
            for (const [t,e] of i)
                this.Ett[t] = e,
                this.rOe.has(t) && (URL.revokeObjectURL(this.rOe.get(t)),
                this.rOe.delete(t))
        }
    }
}
{
    const aA = self.t
      , lA = aA.bW(import.meta.url);
    aA.IW(lA.URL);
    class uA extends aA.Event.v_ {
        constructor() {
            super(),
            this.rOi = null
        }
        bEt(t) {
            return this.rOi = t,
            this.yrt()
        }
        async yrt() {
            const t = new aA.Event("load");
            t.app = this.rOi,
            await this.ufi(t);
            const i = new aA.Event("afterload");
            await this.ufi(i)
        }
        Di(t, i) {
            aA.zt(t),
            aA.nu(i),
            aA.bme.yOe("plugin", t, i)
        }
        ed(t, i) {
            return aA.zt(t),
            aA.Ef(i, self.jw),
            aA.bme.ed("plugin", t, i)
        }
        bOe(t, i) {
            return aA.zt(t),
            aA.Ef(i, self.jw),
            aA.bme.bOe("plugin", t, i)
        }
        vOe(t) {
            return aA.bme.vOe("plugin", t)
        }
        *plugins(t, i) {
            aA.Ef(t, self.jw);
            for (const e of aA.bme.addons("plugin", t, i)) {
                if (!aA.Jvt(e)) {
                    if ("system" === e.Bk())
                        continue;
                    if (aA.q8t() && e.VAe())
                        continue
                }
                yield e
            }
        }
        SOe() {
            return this.ed("system")
        }
    }
    aA.Li = aA.v(uA),
    aA.ei = {}
}
{
    const cA = self.t;
    cA.h = class extends cA.Me {
        constructor() {
            super(),
            this.WPe = new.target,
            this.xOe = null,
            this.m = null,
            this.HPe = null
        }
        he() {
            this.WPe = null,
            this.xOe = null,
            this.m = null
        }
        MOe(t) {
            cA.U(t, self.EOe),
            this.xOe = t
        }
        wre() {
            return this.xOe
        }
        qPe(t) {
            cA.nu(t),
            this.WPe = t
        }
        XPe() {
            return this.WPe
        }
        YPe(t) {
            cA.U(t, self.V),
            this.m = t
        }
        GetInfo() {
            if (!this.m)
                throw new Error("behavior must set info");
            return this.m
        }
        Pf(t) {
            cA.zt(t),
            this.HPe = t
        }
        JPe() {
            return this.HPe
        }
        COe(t) {
            return cA.U(t, self.qte),
            cA.v(this.XPe().G, this, t)
        }
    }
}
{
    const dA = self.t;
    dA.R = class extends dA.Me {
        constructor(t, i) {
            dA.U(t, dA.h),
            dA.U(i, window.qte),
            super(),
            this._Oe = t,
            this.TOe = i
        }
        he() {
            dA.he(this)
        }
        TC(t) {
            return dA.U(t, window.IOe),
            dA.v(this.POe().XPe().Instance, this, t)
        }
        QBt() {
            return this.TOe
        }
        sre() {
            return this.TOe.sre()
        }
        POe() {
            return this._Oe
        }
        wre() {
            return this._Oe.wre()
        }
    }
}
{
    const fA = self.t;
    fA.W = class extends fA.Me {
        constructor(t, i) {
            fA.U(t, fA.R),
            fA.U(i, window.IOe),
            super(),
            this.Zs = t,
            this.q = i,
            this.Ie = this.q.nd()
        }
        he() {
            fA.he(this)
        }
        Ei() {}
        ue(t, i) {}
        N(t, i) {
            return !1
        }
    }
}
{
    const pA = self.t;
    pA.le = class extends pA.W {
        constructor(t, i) {
            pA.U(t, pA.R),
            pA.U(i, window.IOe),
            super(t, i),
            this.cGe = !1,
            this.Ce = null,
            this.rF = null,
            this.YF = t => this.Se(t.dt),
            this.dGe = () => this.ce()
        }
        he() {
            this.pe(!1),
            this.YF = null,
            this.dGe = null
        }
        fGe() {
            self.app.addEventListener("livepreviewstop", this.dGe),
            this.rF.addEventListener("beforerender", this.YF)
        }
        pGe() {
            this.rF && this.rF.removeEventListener("beforerender", this.YF),
            self.app.removeEventListener("livepreviewstop", this.dGe)
        }
        pe(t) {
            t = !!t;
            let i = self.app.Us().PE();
            if (i || (t = !1),
            this.cGe !== t)
                if (self.app.CP() && t)
                    self.app.RP(i.Cn(), 10);
                else if (this.cGe = t,
                this.Ie.hh(this.cGe),
                this.cGe) {
                    this.Ce = this.Ie.wg(),
                    this.rF = i,
                    this.fGe(),
                    this.ye();
                    this.Ie.rz().yA(!0)
                } else {
                    this.Pe(),
                    this.Ie.Ig(this.Ce),
                    this.Ce = null,
                    this.pGe(),
                    this.rF = null;
                    const t = this.Ie.yg()
                      , i = t ? t.cb() : null;
                    if (i) {
                        if (!i.hb() && !i.mGe() && !this.Ie.wGe()) {
                            this.Ie.rz().yA(!1)
                        }
                    } else if (!this.Ie.wGe()) {
                        this.Ie.rz().yA(!1)
                    }
                }
        }
        de() {
            return this.cGe
        }
        ye() {}
        Pe() {}
        ce() {
            this.pe(!1),
            this.q.A("live-preview", !1)
        }
        Se(t) {
            pA.kK()
        }
    }
}
{
    const mA = self.t
      , wA = new Set(["attributes", "general", "movements", "other"])
      , gA = new Set(["", "module"]);
    window.V = class extends mA.Me {
        constructor(t) {
            mA.zt(t),
            super(),
            this.Rdi = t,
            this.Ftt = "",
            this.$Oi = "",
            this.Wtt = "1.0.0.0",
            this.OGe = !1,
            this.DGe = "general",
            this.FGe = "",
            this.LGe = "http://",
            this.UGe = "icon.svg",
            this.NGe = "image/svg+xml",
            this.jGe = "",
            this.$Ge = ["c3runtime/behavior.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"],
            this.zGe = [],
            this.GOe = !1,
            this.ZGe = !1,
            this.QGe = !1,
            this.tAe = !1,
            this.rAe = !0,
            this.hAe = !0,
            this.aAe = !0,
            this.jLi = [],
            this.xAe = new Map,
            this.CAe = [],
            this._Ae = [],
            this.GAe = {
                M: "",
                Tee: "",
                behavior: ""
            },
            this.AAe = []
        }
        Wxt() {
            return this.Rdi
        }
        I(t) {
            mA.zt(t),
            this.Ftt = t
        }
        La() {
            return this.Ftt
        }
        k(t) {
            mA.zt(t),
            this.$Oi = t
        }
        nse() {
            return this.$Oi
        }
        P(t) {
            mA.zt(t),
            this.Wtt = t,
            this.OGe = !0
        }
        a6() {
            return this.Wtt
        }
        kAe() {
            return this.OGe
        }
        S(t) {
            mA.zt(t),
            this.DGe = t
        }
        OAe() {
            return this.DGe
        }
        B(t) {
            mA.zt(t),
            this.FGe = t
        }
        rse() {
            return this.FGe
        }
        m0(t, i) {
            mA.zt(t),
            mA.zt(i),
            this.UGe = t,
            this.NGe = i
        }
        DAe() {
            return this.UGe
        }
        FAe() {
            return this.NGe
        }
        L(t) {
            mA.zt(t),
            this.LGe = self.app.Ene(t)
        }
        foe() {
            return this.LGe
        }
        H(t) {
            this.GOe = !!t
        }
        AOe() {
            return this.GOe
        }
        Or(t) {
            this.ZGe = !!t
        }
        $Pe() {
            return this.ZGe
        }
        zAe(t) {
            this.QGe = !!t
        }
        VAe() {
            return this.QGe
        }
        WAe(t) {
            this.tAe = !!t
        }
        HAe() {
            return this.tAe
        }
        O(t) {
            mA.RH(t),
            mA.mf(this.jLi, t),
            this.xAe.clear();
            for (const t of this.jLi)
                this.xAe.set(t.Bk(), t)
        }
        yre() {
            return this.jLi
        }
        Na(t) {
            return mA.zt(t),
            this.xAe.get(t) ?? null
        }
        lRe(t) {
            return mA.zt(t),
            this.xAe.has(t)
        }
        vt(t) {
            this.CAe.push(mA.v(self.mRe, t))
        }
        wRe() {
            return this.CAe
        }
        gRe(t) {
            const i = [];
            for (const e of this.CAe)
                "inline-script" === e.W7() ? (() => {})(`[Addon SDK] Addon ID '${t.Bk()}' uses an "inline-script" dependency '${e.s0()}'. This is not supported in the addon SDK v2 - use an additional runtime script instead.`) : i.push(e);
            this.CAe = i
        }
        hl(t, i="") {
            if (mA.zt(t),
            t.startsWith("http:"))
                throw new Error("cannot use insecure remote script dependency, use HTTPS");
            if (!gA.has(i))
                throw new Error("invalid type");
            this._Ae.push({
                url: t,
                type: i
            })
        }
        yRe() {
            return this._Ae
        }
        qAe(t) {
            this.rAe = !!t
        }
        XAe() {
            return this.rAe
        }
        K(t) {
            this.hAe = !!t
        }
        bre() {
            return this.hAe
        }
        yl(t) {
            this.aAe = !!t
        }
        UAe() {
            return this.aAe
        }
        CRe(t) {
            this.$Ge = t.slice(0)
        }
        Ke(t) {
            mA.zt(t),
            this.$Ge.push(t)
        }
        _Re() {
            const t = this.$Ge.slice(0);
            return this.jGe && !t.includes(this.jGe) && t.push(this.jGe),
            t
        }
        TRe(t) {
            mA.zt(t),
            this.jGe = t
        }
        IRe() {
            return this.jGe
        }
        br(t) {
            this.zGe = t.slice(0)
        }
        PRe() {
            return this.zGe
        }
        C(t) {
            mA.IL(t),
            mA.gL(t.M),
            mA.gL(t.Tee),
            mA.gL(t.behavior),
            t.M && (this.GAe.M = t.M),
            t.Tee && (this.GAe.Tee = t.Tee),
            t.behavior && (this.GAe.behavior = t.behavior)
        }
        GRe() {
            return this.GAe
        }
        T(t) {
            mA.RH(t),
            this.AAe = t
        }
        ARe() {
            return this.AAe
        }
        kRe() {
            if (!this.Rdi)
                throw new Error("id can not be empty");
            if (!this.Ftt)
                throw new Error("name can not be empty");
            if (!wA.has(this.DGe))
                throw new Error(`invalid behavior category '${this.DGe}'`);
            if (!this.FGe)
                throw new Error("must specify author");
            if (this.LGe && !this.LGe.startsWith("http://") && !this.LGe.startsWith("https://"))
                throw new Error("help URL must begin with http:// or https://");
            mA.QH(this.jLi, self.i);
            let t = new Set;
            for (let i of this.jLi) {
                let e = i.Bk();
                if (t.has(e))
                    throw new Error(`duplicate behavior property ID '${e}'`);
                t.add(e)
            }
        }
    }
}
{
    const yA = self.t
      , bA = "#D04100";
    window.EOe = class extends globalThis.NPe {
        constructor(t, i) {
            yA.U(t, yA.h),
            super(),
            this.T0i = t,
            this.m = this.T0i.GetInfo(),
            this.lke = yA.v(self.DRe),
            this.dmt = i.source,
            this.$Ge = new Map,
            this.uke = null,
            this.uOi = null,
            this.cOi = null,
            this.dOi = null,
            this.m.kRe(),
            this.T0i.MOe(this),
            i.mke && (this.uke = yA.v(yA.Qs.YRi, self.app, null, {
                name: "behavior-" + this.Bk(),
                color: bA,
                wOi: i.mke
            }))
        }
        he() {
            this.T0i.he(),
            this.T0i = null,
            this.m = null,
            this.lke.he(),
            this.lke = null,
            this.$Ge.clear()
        }
        wke(t) {
            yA.IL(t),
            yA.p.u("behaviors." + this.Bk().toLowerCase());
            const i = !!this.m.$Pe();
            i && yA.p.Mr(!1);
            for (let[i,e] of Object.entries(t)) {
                if ("$schema" === i)
                    continue;
                this.lke.S(i);
                let t = e.conditions
                  , s = e.actions
                  , n = e.expressions;
                if (t)
                    for (let i of t)
                        this.lke.LRe(i);
                if (s)
                    for (let t of s)
                        this.lke.BRe(t);
                if (n)
                    for (let t of n)
                        this.lke.URe(t)
            }
            i && yA.p.Mr(!0),
            this.lke.gke(),
            yA.p.j()
        }
        Bk() {
            return this.m.Wxt()
        }
        W7() {
            return "behavior"
        }
        La() {
            return this.m.La()
        }
        nse() {
            return this.m.nse()
        }
        a6() {
            return this.m.a6()
        }
        bke() {
            return 1
        }
        OAe() {
            return this.m.OAe()
        }
        rse() {
            return this.m.rse()
        }
        foe() {
            return this.m.foe()
        }
        Hot() {
            return this.dmt
        }
        AOe() {
            return this.m.AOe()
        }
        $Pe() {
            return this.m.$Pe()
        }
        Mke() {
            this.m.Or(!0)
        }
        VAe() {
            return this.m.VAe()
        }
        HAe() {
            return this.m.HAe()
        }
        fae() {
            return this.$Pe() || this.HAe() && !self.app.Eke()
        }
        UAe() {
            return this.m.UAe()
        }
        yre() {
            return this.m.yre()
        }
        Na(t) {
            yA.zt(t);
            const i = this.m.Na(t);
            if (!i)
                throw new Error(`behavior property id '${t}' not found`);
            return i
        }
        lRe(t) {
            return yA.zt(t),
            this.m.lRe(t)
        }
        ez() {
            return this.T0i
        }
        Tke() {
            return `behaviors/${this.Bk()}/`
        }
        Ike() {
            return yA.Abi.wvi() + this.Tke()
        }
        Pke() {
            return !!this.IRe()
        }
        IRe() {
            return this.m.IRe()
        }
        async Gke(t, i) {
            yA.kK()
        }
        async Ake(t, i, e) {
            yA.kK()
        }
        wRe() {
            return this.m.wRe()
        }
        yRe() {
            return this.m.yRe()
        }
        GRe() {
            return this.m.GRe()
        }
        ARe() {
            return this.m.ARe()
        }
        XAe() {
            return this.m.XAe() && "dev" !== this.Hot()
        }
        bre() {
            return this.m.bre()
        }
        FAe() {
            return this.m.FAe()
        }
        Rke() {
            return "image/svg+xml" === this.FAe()
        }
        kke() {
            !this.uke && this.Rke() && (this.uke = yA.v(yA.Qs.YRi, self.app, this.r1i(), {
                name: "behavior-" + this.Bk(),
                color: bA
            }))
        }
        uP() {
            return this.uOi || (this.kke(),
            this.uke ? this.uOi = this.uke.uP() : this.uOi = yA.Qs.d0.ski(this.r1i(), self.app.m4(), {
                wd: this.Rke()
            })),
            this.uOi
        }
        M8() {
            return this.cOi || (this.kke(),
            this.uke ? this.cOi = this.uke.M8() : this.cOi = yA.Qs.d0.ski(this.r1i(), self.app.Oq(), {
                wd: this.Rke()
            })),
            this.cOi
        }
        COi() {
            return this.dOi || (this.kke(),
            this.uke ? this.dOi = this.uke.COi() : this.dOi = yA.Qs.d0.ski(this.r1i(), self.app.s8(), {
                wd: this.Rke()
            })),
            this.dOi
        }
        eNi(t) {
            switch (yA.zt(t),
            t) {
            case "small":
                return this.uP();
            case "medium":
                return this.M8();
            case "large":
                return this.COi();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        li(t) {
            return yA.zt(t),
            this.lke.li(t)
        }
        Lke(t) {
            return yA.Ge(t),
            this.lke.Lke(t)
        }
        M4t() {
            return this.lke.M4t()
        }
        I7t() {
            return this.lke.I7t()
        }
        ci(t) {
            return yA.zt(t),
            this.lke.ci(t)
        }
        Bke(t) {
            return yA.Ge(t),
            this.lke.Bke(t)
        }
        actions() {
            return this.lke.actions()
        }
        xQt() {
            return this.lke.xQt()
        }
        ui(t) {
            return yA.zt(t),
            this.lke.ui(t)
        }
        Uke(t) {
            return yA.Ge(t),
            this.lke.Uke(t)
        }
        ki(t) {
            return yA.zt(t),
            this.lke.ki(t)
        }
        jke() {
            return this.lke.jke()
        }
        $ke() {
            return this.lke.$ke()
        }
        zke(t) {
            if (yA.zt(t),
            "conditions" === t)
                return this.M4t();
            if ("actions" === t)
                return this.actions();
            if ("expressions" === t)
                return this.jke();
            throw new Error("invalid ace type")
        }
        COe(t, i) {
            if (yA.U(t, self.i_),
            yA.zt(i),
            i = self.i_.hW(i, !0),
            t.$a().Nke(i)) {
                const e = new Error("expression name collision");
                throw e.type = "expression-name-collision",
                e.ROe = "behavior",
                e.KJ = t,
                e.name = i,
                e
            }
            if (t.kOe(i))
                throw new Error(`behavior type name '${i}' already in namespace`);
            let e = yA.v(self.qte, t, this, i);
            e.Zs = this.T0i.COe(e);
            const s = t.Cn();
            return this.UAe() || "worker" !== s.Dse() || s.Wke("auto"),
            e
        }
        static OOe(t, i) {
            const e = (yA.Jvt(t) ? t.qke : t.La()).toLowerCase()
              , s = (yA.Jvt(i) ? i.qke : i.La()).toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const vA = self.t
      , SA = ["c3runtime/behavior.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"];
    window.DOe = class extends self.EOe {
        constructor(t, i) {
            if (vA.U(t, vA.h),
            super(t, i),
            vA.q8t()) {
                const t = this.m._Re();
                vA.lAt(t, new Set(SA)),
                t.unshift("c3runtime/runtime.js"),
                this.m.CRe(t)
            }
            this.$It = "",
            i.path && (this.$It = new URL(i.path,vA.Vgt()).toString(),
            t.Pf(this.$It))
        }
        he() {
            super.he()
        }
        Zke() {
            return this.m._Re().map(t => this.$It + t)
        }
        async Qke(t, i, e, s) {
            return await Promise.all(e.map(async e => {
                if ("preview" === t)
                    return this.$It + e;
                {
                    const t = this.Ike() + e
                      , n = this.Tke() + e;
                    i.set(t, null);
                    const r = await this.tOe(e);
                    return i.set(t, r),
                    s ? t : n
                }
            }
            ))
        }
        async Gke(t, i) {
            return await this.Qke(t, i, this.m.PRe(), !0)
        }
        async Ake(t, i, e) {
            return await this.Qke(t, i, this.m._Re(), !1)
        }
        async tOe(t) {
            vA.zt(t);
            const i = this.$Ge.get(t);
            if (i)
                return i;
            const e = await fetch(this.$It + t)
              , s = await e.text();
            return this.$Ge.set(t, s),
            s
        }
        r1i() {
            return this.$It + this.m.DAe()
        }
        JOt() {
            return this.$It
        }
        iOe(t) {
            return this.$It + t
        }
        eOe(t) {
            return this.iOe(t)
        }
        a6() {
            return vA.dQ.mPe
        }
    }
}
{
    const xA = self.t
      , MA = new Set([1, 2]);
    window.FOe = class extends self.EOe {
        constructor(t, i) {
            t instanceof window.SDK.IBehaviorBase && (t = t.LOe()),
            xA.U(t, xA.h),
            super(t, i);
            const e = i.nOe;
            if (this.Ett = i.files,
            this.rOe = new Map,
            this.hOe = i.nOe["sdk-version"] ?? 1,
            !MA.has(this.hOe))
                throw new Error(`addon ID '${this.Bk()}' specifies invalid SDK version ${this.hOe}`);
            this.hOe >= 2 && (this.m.kAe() && (() => {})(`[Addon SDK] Addon ID '${this.Bk()}' called SetVersion(). This is ignored in the Addon SDK v2 and the version set in addon.json is used instead. Remove the call to SetVersion() to clear this warning.`),
            this.m.P(e.version),
            this.m.yl(e["supports-worker-mode"] ?? !0),
            this.m.gRe(this),
            this.m.IRe() || this.oOe()),
            this.aOe = i.lOe
        }
        wke(t) {
            super.wke(t);
            for (const t of [...this.M4t(), ...this.actions()])
                if (!t.cOe())
                    for (const i of t.parameters()) {
                        if (!i.dOe(this.bke()))
                            throw new Error(`Addon '${this.Bk()}' ACE '${t.Bk()}' uses "${i.W7()}" parameter which is not supported in the SDK. Refer to the SDK documentation for supported types. Note support for condition/action variadic parameters has been removed - see: https://www.construct.net/forum/construct-3/plugin-sdk-10/variadic-parameters-removed-143189`);
                        this.bke() < 2 && i.fOe()
                    }
        }
        he() {
            this.Ett = null,
            super.he()
        }
        bke() {
            return this.hOe
        }
        Pke() {
            return this.bke() >= 2 && super.Pke()
        }
        oOe() {
            const t = "c3runtime/main.js";
            if (!this.Ett.hasOwnProperty(t)) {
                const i = this.m._Re().map(t => `import "./${t.startsWith("c3runtime/") ? t.substr(10) : t}";`).join("\n");
                this.Ett[t] = new Blob([i],{
                    type: "application/javascript"
                })
            }
            this.m.TRe(t)
        }
        Zke() {
            return this.m._Re().map(t => this.iOe(t))
        }
        async Gke(t, i) {
            return await Promise.all(this.m.PRe().map(async t => {
                const e = this.Ike() + t;
                i.set(e, null);
                const s = await this.tOe(t);
                return i.set(e, s),
                e
            }
            ))
        }
        Ake(t, i, e) {
            return this.hOe >= 2 ? this.pOe(t, e) : this.mOe(t, i)
        }
        async mOe(t, i) {
            const e = this.m.wRe().filter(t => "inline-script" === t.W7()).map(t => t.s0());
            return xA.Oo(e, this.m._Re()),
            await Promise.all(e.map(async t => {
                const e = this.Tke() + t
                  , s = xA.Abi.wvi() + e;
                i.set(s, null);
                const n = await this.tOe(t);
                return i.set(s, n),
                e
            }
            ))
        }
        async pOe(t, i) {
            return await Promise.all(this.m._Re().map(async t => {
                const e = await this.tOe(t)
                  , s = this.Ike() + t;
                i.set(s, e)
            }
            )),
            []
        }
        async tOe(t) {
            xA.zt(t);
            const i = this.$Ge.get(t);
            if (i)
                return i;
            self.assert(this.Ett.hasOwnProperty(t), `missing addon '${this.Bk()}' plugin runtime file`);
            const e = await xA.Ist(this.Ett[t]);
            return this.$Ge.set(t, e),
            e
        }
        r1i() {
            return this.iOe(this.m.DAe())
        }
        iOe(t) {
            let i = this.rOe.get(t);
            if (i)
                return i;
            const e = this.Ett[t];
            if (!e)
                throw new Error(`addon '${this.Bk()}' missing file '${t}'`);
            return i = URL.createObjectURL(e),
            this.rOe.set(t, i),
            i
        }
        uOe(t) {
            const i = this.Ett[t];
            if (!i)
                throw new Error(`addon '${this.Bk()}' missing file '${t}'`);
            return i
        }
        eOe(t) {
            return this.uOe(t)
        }
        wOe() {
            return this.Ett._c3addon
        }
        async gOe() {
            if ("dev" !== this.Hot() || !this.aOe)
                return;
            this.$Ge.clear();
            const t = Object.keys(this.aOe)
              , i = new Map;
            try {
                await Promise.all(t.map(async t => {
                    const e = this.aOe[t]
                      , s = await xA._4(e);
                    i.set(t, s)
                }
                ))
            } catch (t) {
                return void console.error(`Error reloading developer addon '${this.Bk()}' files: `, t)
            }
            for (const [t,e] of i)
                this.Ett[t] = e,
                this.rOe.has(t) && (URL.revokeObjectURL(this.rOe.get(t)),
                this.rOe.delete(t))
        }
    }
}
{
    const EA = self.t
      , CA = EA.bW(import.meta.url);
    EA.IW(CA.URL);
    class _A extends EA.Event.v_ {
        constructor() {
            super(),
            this.rOi = null
        }
        bEt(t) {
            return this.rOi = t,
            this.yrt()
        }
        async yrt() {
            const t = new EA.Event("load");
            t.app = this.rOi,
            await this.ufi(t);
            const i = new EA.Event("afterload");
            await this.ufi(i)
        }
        _(t, i) {
            EA.zt(t),
            EA.nu(i),
            EA.bme.yOe("behavior", t, i)
        }
        ed(t, i) {
            return EA.zt(t),
            EA.Ef(i, self.jw),
            EA.bme.ed("behavior", t, i)
        }
        bOe(t, i) {
            return EA.zt(t),
            EA.Ef(i, self.jw),
            EA.bme.bOe("behavior", t, i)
        }
        vOe(t) {
            return EA.bme.vOe("behavior", t)
        }
        *BOe(t, i) {
            EA.Ef(t, self.jw);
            for (const e of EA.bme.addons("behavior", t, i))
                !EA.Jvt(e) && EA.q8t() && e.VAe() || (yield e)
        }
    }
    EA.F = EA.v(_A),
    EA.o = {}
}
{
    const TA = self.t
      , IA = self.lang
      , PA = self.assert
      , GA = new Set(["3d", "blend", "color", "distortion", "mask", "normal-mapping", "other", "tiling"])
      , AA = new Set;
    window.SW = class t extends globalThis.NPe {
        constructor(t, i, e, s, n, r) {
            if (super(),
            TA.zt(t),
            TA.IL(i),
            TA.gL(e),
            TA.gL(s),
            TA.gL(n),
            TA.kQ(r),
            TA.zt(i.id),
            TA.zt(i.category),
            TA.zt(i.author),
            TA.gL(i.version),
            TA.D_t(i["supported-renderers"]),
            TA.kQ(i["extend-box"]),
            i["extend-box"] && (TA.Ge(i["extend-box"].horizontal),
            TA.Ge(i["extend-box"].vertical)),
            TA.RH(i.parameters),
            !GA.has(i.category))
                throw new Error("invalid category");
            this.$It = t,
            this.dmt = "built-in",
            this.Rdi = i.id,
            this.DGe = i.category,
            this.FGe = i.author,
            this.Wtt = i.version || "1.0.0.0",
            this.y4i = !!i["must-predraw"],
            this.C4i = !!i["blends-background"],
            this.T4i = !!i["uses-depth"],
            this.w4i = !!i["cross-sampling"],
            this.v4i = !!i["preserves-opaqueness"],
            this.x4i = !!i["supports-3d-direct-rendering"],
            this.E4i = !!i.animated,
            this.d4i = 0,
            this.p4i = 0,
            this.ZGe = !!i["is-deprecated"],
            this.Ett = null,
            this.aOe = null;
            const h = i["supported-renderers"];
            if (this.UOe = !h || h.includes("webgl"),
            this.NOe = h && h.includes("webgl2"),
            this.jOe = h && h.includes("webgpu"),
            i["extend-box"] && (this.d4i = i["extend-box"].horizontal,
            this.p4i = i["extend-box"].vertical),
            this.$Oe = e,
            this.zOe = s,
            this.VOe = n,
            this.UOe && !this.$Oe)
                throw new Error(`effect ${this.Rdi} supports WebGL but has empty GLSL content`);
            if (this.NOe && !this.zOe)
                throw new Error(`effect ${this.Rdi} supports WebGL2 but has empty GLSL content`);
            if (this.jOe && !this.VOe)
                throw new Error(`effect ${this.Rdi} supports WebGPU but has empty WGSL content`);
            if (this.C4i && this.T4i)
                throw new Error(`effect ${this.Rdi} cannot specify both background blending and depth`);
            this.b1i = null,
            this.WOe = null,
            this.HOe = i.parameters,
            this.p9t = [],
            this.Ftt = "",
            this.$Oi = "",
            this.Att = !1,
            r && (this.dmt = r.source,
            this.Ett = r.files,
            this.aOe = r.lOe)
        }
        he() {
            this.$Oe = "",
            this.zOe = "",
            this.VOe = "",
            this.b1i && (this.b1i.he(),
            this.b1i = null),
            this.Ett = null
        }
        static async ski(i, e) {
            TA.zt(i),
            TA.zt(e),
            TA.p.MW(`${i}${e}\\lang`);
            const s = await TA.O4(`${i}${e}\\${e}.json`)
              , n = s["supported-renderers"]
              , r = !n || n.includes("webgl")
              , h = n && n.includes("webgl2")
              , o = n && n.includes("webgpu");
            let a = ""
              , l = ""
              , u = "";
            return r && (a = await TA.Bii(`${i}${e}\\${e}.fx`)),
            h && (l = await TA.Bii(`${i}${e}\\${e}.webgl2.fx`)),
            o && (u = await TA.Bii(`${i}${e}\\${e}.wgsl`)),
            TA.v(t, i, s, a, l, u)
        }
        bEt() {
            if (this.Att)
                throw new Error("effect already ready");
            TA.p.u("effects." + this.Rdi.toLowerCase()),
            this.Ftt = IA(".name"),
            this.$Oi = IA(".description"),
            TA.p.u(".parameters");
            for (const t of this.HOe) {
                const i = new self.i(t.type,t.id,{
                    initialValue: t["initial-value"],
                    D: t.interpolatable
                })
                  , e = t.uniform;
                if (TA.ea.g6i.x8i().has(e))
                    throw new Error(`[Effects] Effect '${this.Rdi}' parameter '${t.id}' specifices a uniform '${e}', but this name is reserved for internal use by Construct. Please use a different uniform name.`);
                i._Ge(e),
                t.hasOwnProperty("c2id") && i.IGe(t.c2id),
                this.p9t.push(i)
            }
            TA.Io(this.HOe),
            TA.p.j(),
            TA.p.j(),
            this.Att = !0
        }
        W7() {
            return "effect"
        }
        Bk() {
            return this.Rdi
        }
        La() {
            return this.Ftt
        }
        nse() {
            return this.$Oi
        }
        OAe() {
            return this.DGe
        }
        rse() {
            return this.FGe
        }
        a6() {
            return "built-in" === this.Hot() ? TA.dQ.mPe : this.Wtt
        }
        KOe() {
            return this.UOe
        }
        qOe() {
            return this.NOe
        }
        Zse() {
            return this.jOe
        }
        Hot() {
            return this.dmt
        }
        $Pe() {
            return this.ZGe
        }
        fae() {
            return this.$Pe()
        }
        Rm() {
            return this.y4i
        }
        B4i() {
            return this.C4i
        }
        U4i() {
            return this.T4i
        }
        O4i() {
            return this.w4i
        }
        D4i() {
            return this.v4i
        }
        F4i() {
            return this.x4i
        }
        L4i() {
            return this.E4i
        }
        R4i() {
            return this.d4i
        }
        k4i() {
            return this.p4i
        }
        A4i() {
            return 0 !== this.d4i || 0 !== this.p4i
        }
        bre() {
            return !0
        }
        Wne() {
            return this.p9t
        }
        XOe(t) {
            TA.zt(t);
            for (let i of this.p9t)
                if (i.Bk() === t)
                    return i;
            return null
        }
        YOe(t) {
            TA.zt(t);
            for (let i of this.p9t)
                if ("color" === i.W7()) {
                    let e = i.PGe().split(",").indexOf(t);
                    if (e >= 0)
                        return {
                            Ly: i,
                            component: e
                        }
                } else if (i.PGe() === t)
                    return {
                        Ly: i
                    };
            return null
        }
        ile(t) {
            TA.zt(t);
            let i = this.XOe(t);
            if (!i)
                throw new Error(`effect parameter id '${t}' not found`);
            return i
        }
        JOe() {
            return PA(this.UOe, "shader does not support WebGL"),
            this.$Oe
        }
        ZOe() {
            return PA(this.NOe, "shader does not support WebGL 2"),
            this.zOe
        }
        QOe() {
            return PA(this.jOe, "shader does not support WebGPU"),
            this.VOe
        }
        JOt() {
            return this.$It
        }
        tDe() {
            if (this.b1i)
                return Promise.resolve(this.b1i);
            if (this.WOe)
                return this.WOe;
            const t = this.p9t.map(t => [t.TGe(), 0, t.W7()]);
            return this.WOe = (async () => {
                try {
                    const i = await self.app.fS();
                    let e = ""
                      , s = "";
                    if (i.hu()) {
                        if (!this.Zse())
                            throw new Error(`shader '${this.Bk()}' does not support WebGPU`);
                        e = this.QOe()
                    } else if (this.qOe() && i.k9i() >= 2)
                        e = this.ZOe(),
                        s = TA.ea.g6i.C8i();
                    else {
                        if (!this.KOe())
                            throw new Error(`shader '${this.Bk()}' does not support WebGL 1`);
                        e = this.JOe(),
                        s = TA.ea.g6i.E8i()
                    }
                    const n = await i.Rye({
                        src: e,
                        b6i: s,
                        name: this.Bk(),
                        _4i: this.B4i(),
                        I4i: this.U4i(),
                        f4i: this.R4i(),
                        m4i: this.k4i(),
                        g4i: this.O4i(),
                        b4i: this.Rm(),
                        S4i: this.D4i(),
                        M4i: this.F4i(),
                        animated: this.L4i(),
                        parameters: t
                    });
                    return AA.add(this),
                    this.b1i = n,
                    this.WOe = null,
                    this.b1i
                } catch (t) {
                    console.error(`Failed to compile '${this.Bk()}' shader program: `, t),
                    this.b1i = null
                }
            }
            )(),
            this.WOe
        }
        X5i() {
            return this.b1i
        }
        static FU() {
            for (const t of AA)
                t.b1i = null
        }
        static async KU() {
            await Promise.all([...AA].map(t => t.tDe()))
        }
        async iDe(t, i) {
            TA.U(t, self.eDe),
            TA.zt(i);
            const e = t instanceof self.i_ ? t : null;
            if (e) {
                if (e.$a().Nke(i)) {
                    const t = new Error("expression name collision");
                    throw t.type = "expression-name-collision",
                    t.ROe = "effect",
                    t.KJ = e,
                    t.name = i,
                    t
                }
                if (e.kOe(i))
                    throw new Error(`effect type name '${i}' already in namespace`)
            }
            return await this.tDe(),
            TA.v(self.Tte, t, this, i)
        }
        static sDe(t, i) {
            const e = (TA.Jvt(t) ? t.qke : t.La()).toLowerCase()
              , s = (TA.Jvt(i) ? i.qke : i.La()).toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
        wOe() {
            return this.Ett._c3addon
        }
        nDe(t) {
            const i = t.split("\n").map(t => t.trim())
              , e = [];
            for (const t of i)
                t && "//" !== t.substr(0, 2) && e.push(t);
            return e.join("\n")
        }
        rDe() {
            return this.KOe() ? this.nDe(this.JOe()) : ""
        }
        hDe() {
            return this.qOe() ? this.nDe(this.ZOe()) : ""
        }
        oDe() {
            return this.Zse() ? this.nDe(this.QOe()) : ""
        }
        aDe() {
            const t = [];
            for (const i of this.p9t)
                t.push([i.TGe(), 0, i.W7()]);
            return t
        }
        HC(t) {
            return {
                glsl: this.rDe(),
                glslWebGL2: this.hDe(),
                wgsl: this.oDe(),
                blendsBackground: this.B4i(),
                usesDepth: this.U4i(),
                extendBoxHorizontal: this.R4i(),
                extendBoxVertical: this.k4i(),
                crossSampling: this.O4i(),
                mustPreDraw: this.Rm(),
                preservesOpaqueness: this.D4i(),
                supports3dDirectRendering: this.F4i(),
                animated: this.L4i(),
                parameters: this.aDe()
            }
        }
        async gOe() {
            if ("dev" !== this.Hot() || !this.aOe)
                return;
            const t = ["effect.fx", "effect.webgl2.fx", "effect.wgsl"]
              , i = new Map;
            try {
                await Promise.all(t.map(async t => {
                    const e = this.aOe[t];
                    if (!e)
                        return;
                    const s = await TA.Bii(e);
                    i.set(t, s)
                }
                ))
            } catch (t) {
                return void console.error(`Error reloading developer addon '${this.Bk()}' files: `, t)
            }
            for (const [t,e] of i)
                this.Ett[t] = new Blob([e]),
                "effect.fx" === t ? this.$Oe = e : "effect.webgl2.fx" === t ? this.zOe = e : "effect.wgsl" === t && (this.VOe = e)
        }
    }
}
{
    const RA = self.t
      , kA = self.SW
      , OA = "effects/";
    class DA extends RA.Event.v_ {
        constructor() {
            super(),
            this.rOi = null,
            this.lDe = !1,
            this.uDe = 0,
            this.cDe = 0
        }
        ed(t, i) {
            return RA.zt(t),
            RA.Ef(i, self.jw),
            RA.bme.ed("effect", t, i)
        }
        bOe(t, i) {
            return RA.zt(t),
            RA.Ef(i, self.jw),
            RA.bme.bOe("effect", t, i)
        }
        async yrt() {
            RA.q8t() ? await this.dDe() : await this.fDe()
        }
        fDe() {
            if (this.lDe)
                throw new Error("already loaded effects");
            this.lDe = !0;
            let t = OA;
            return RA.O4(t + "defaultEffectList.json").then(i => {
                let e = i.defaultEffects;
                this.cDe = e.length;
                let s = [];
                for (let i of e)
                    s.push(kA.ski(t, i));
                return RA.lii(s, (t, i) => this.pDe(t, i))
            }
            ).then(t => {
                for (let i of t)
                    RA.bme.mDe(i.Bk(), i)
            }
            )
        }
        dDe() {
            if (this.lDe)
                throw new Error("already loaded effects");
            this.lDe = !0,
            this.cDe = 1;
            const t = OA;
            return RA.O4(t + "allEffects.json").then(t => {
                this.uDe = 1;
                for (const i of t.all) {
                    const t = RA.v(kA, "", i.json, i.glsl, i.glslWebGL2, i.wgsl);
                    RA.bme.mDe(t.Bk(), t)
                }
            }
            )
        }
        pDe(t, i) {
            this.uDe = t
        }
        wDe() {
            return this.uDe
        }
        gDe() {
            return this.cDe
        }
        bEt(t) {
            this.rOi = t,
            RA.bme.yDe()
        }
        effects(t, i) {
            return RA.Ef(t, self.jw),
            RA.bme.addons("effect", t, i)
        }
    }
    RA.bDe = RA.v(DA)
}
window.SDK = {},
window.SDK.Plugins = {},
window.SDK.Behaviors = {},
window.SDK.Gfx = {},
window.SDK.UI = {};
{
    const FA = self.t;
    class LA {
        constructor() {}
        PushContext(t) {
            FA.p.u(t)
        }
        PopContext() {
            FA.p.j()
        }
        Get(t) {
            return FA.p.qs(t)
        }
    }
    window.SDK.Lang = new LA
}
{
    const BA = self.t;
    window.SDK.Rect = class {
        constructor(t, i, e, s) {
            this.vOt = null,
            t instanceof BA.Rect ? this.vOt = t : this.vOt = BA.v(BA.Rect, t, i, e, s)
        }
        set(t, i, e, s) {
            this.vOt.set(t, i, e, s)
        }
        copy(t) {
            BA.U(t, window.SDK.Rect),
            this.vOt.Qr(t.vOt)
        }
        clone() {
            const t = new window.SDK.Rect;
            return t.copy(this),
            t
        }
        setLeft(t) {
            this.vOt.rY(t)
        }
        getLeft() {
            return this.vOt.Yr()
        }
        setTop(t) {
            this.vOt.oY(t)
        }
        getTop() {
            return this.vOt.Jr()
        }
        setRight(t) {
            this.vOt.Mx(t)
        }
        getRight() {
            return this.vOt.pl()
        }
        setBottom(t) {
            this.vOt.lY(t)
        }
        getBottom() {
            return this.vOt.dl()
        }
        width() {
            return this.vOt.width()
        }
        height() {
            return this.vOt.height()
        }
        midX() {
            return this.vOt.fl()
        }
        midY() {
            return this.vOt.ml()
        }
        offset(t, i) {
            this.vOt.offset(t, i)
        }
        inflate(t, i) {
            this.vOt.Kp(t, i)
        }
        deflate(t, i) {
            this.vOt.Kr(t, i)
        }
        multiply(t, i) {
            this.vOt.multiply(t, i)
        }
        divide(t, i) {
            this.vOt.xm(t, i)
        }
        clamp(t, i, e, s) {
            this.vOt.Ne(t, i, e, s)
        }
        normalize() {
            this.vOt.normalize()
        }
        intersectsRect(t) {
            return BA.U(t, window.SDK.Rect),
            this.vOt.nc(t.vOt)
        }
        containsPoint(t, i) {
            return this.vOt.nB(t, i)
        }
    }
}
{
    const UA = self.t;
    window.SDK.Quad = class {
        constructor(t, i, e, s, n, r, h, o) {
            this.vDe = null,
            t instanceof UA.zn ? this.vDe = t : this.vDe = UA.v(UA.zn, t, i, e, s, n, r, h, o)
        }
        set(t, i, e, s, n, r, h, o) {
            this.vDe.set(t, i, e, s, n, r, h, o)
        }
        setRect(t, i, e, s) {
            this.vDe.Ll(t, i, e, s)
        }
        copy(t) {
            UA.U(t, window.SDK.Quad),
            this.vDe.Qr(t.vDe)
        }
        setTlx(t) {
            this.vDe.Om(t)
        }
        getTlx() {
            return this.vDe.Zn()
        }
        setTly(t) {
            this.vDe.Tm(t)
        }
        getTly() {
            return this.vDe.tr()
        }
        setTrx(t) {
            this.vDe.Ani(t)
        }
        getTrx() {
            return this.vDe.lm()
        }
        setTry(t) {
            this.vDe.Rni(t)
        }
        getTry() {
            return this.vDe.el()
        }
        setBrx(t) {
            this.vDe.kni(t)
        }
        getBrx() {
            return this.vDe.il()
        }
        setBry(t) {
            this.vDe.Oni(t)
        }
        getBry() {
            return this.vDe.sl()
        }
        setBlx(t) {
            this.vDe.Dni(t)
        }
        getBlx() {
            return this.vDe.Fl()
        }
        setBly(t) {
            this.vDe.Fni(t)
        }
        getBly() {
            return this.vDe.El()
        }
        offset(t, i) {
            this.vDe.offset(t, i)
        }
        setFromRect(t) {
            UA.U(t, window.SDK.Rect),
            this.vDe.Zr(t.vOt)
        }
        setFromRotatedRect(t, i) {
            UA.U(t, window.SDK.Rect),
            this.vDe.cr(t.vOt, i)
        }
        getBoundingBox(t) {
            UA.U(t, window.SDK.Rect),
            this.vDe.Nni(t.vOt)
        }
        containsPoint(t, i) {
            return this.vDe.nB(t, i)
        }
        midX() {
            return this.vDe.fl()
        }
        midY() {
            return this.vDe.ml()
        }
        intersectsSegment(t, i, e, s) {
            return this.vDe.jni(t, i, e, s)
        }
        intersectsQuad(t) {
            return UA.U(t, window.SDK.Quad),
            this.vDe.$ni(t.vDe)
        }
    }
}
{
    const NA = self.t;
    window.SDK.Color = class {
        constructor(t, i, e, s) {
            this.Co = null,
            t instanceof NA.za ? this.Co = t : this.Co = NA.v(NA.za, t, i, e, s)
        }
        setRgb(t, i, e) {
            this.Co.wsi(t, i, e)
        }
        setRgba(t, i, e, s) {
            this.Co.msi(t, i, e, s)
        }
        copy(t) {
            NA.U(t, window.SDK.Color),
            this.Co.set(t.Co)
        }
        copyRgb(t) {
            NA.U(t, window.SDK.Color),
            this.Co.Ua(t.Co)
        }
        setR(t) {
            this.Co.bsi(t)
        }
        getR(t) {
            return this.Co.xsi()
        }
        setG(t) {
            this.Co.vsi(t)
        }
        getG(t) {
            return this.Co.Msi()
        }
        setB(t) {
            this.Co.Ssi(t)
        }
        getB(t) {
            return this.Co.Esi()
        }
        setA(t) {
            this.Co.vx(t)
        }
        getA(t) {
            return this.Co.Ix()
        }
        clone() {
            const t = new window.SDK.Color;
            return t.copy(this),
            t
        }
        equals(t) {
            return NA.U(t, window.SDK.Color),
            this.Co.equals(t.Co)
        }
        equalsIgnoringAlpha(t) {
            return NA.U(t, window.SDK.Color),
            this.Co.wle(t.Co)
        }
        equalsRgb(t, i, e) {
            return this.Co.Tsi(t, i, e)
        }
        equalsRgba(t, i, e, s) {
            return this.Co.Isi(t, i, e, s)
        }
        premultiply() {
            this.Co.Ol()
        }
        unpremultiply() {
            this.Co.Gsi()
        }
    }
}
{
    const jA = self.t
      , $A = new WeakMap;
    window.SDK.IZipFile = class {
        constructor(t) {
            jA.U(t, jA.u7),
            $A.set(this, t)
        }
        PathExists(t) {
            return $A.get(this).obi(t)
        }
        GetFileList() {
            return [...$A.get(this).lbi()]
        }
        GetFirstEntryWithExtension(t) {
            const i = $A.get(this).xct(t);
            return i ? new window.SDK.IZipFileEntry(i) : null
        }
        GetEntry(t) {
            const i = $A.get(this).Ict(t);
            return i ? new window.SDK.IZipFileEntry(i) : null
        }
        ReadText(t) {
            return $A.get(this).ubi(window.SDK.IZipFileEntry.Wfi(t))
        }
        ReadJson(t) {
            return $A.get(this).fbi(window.SDK.IZipFileEntry.Wfi(t))
        }
        ReadBlob(t) {
            return $A.get(this).Gct(window.SDK.IZipFileEntry.Wfi(t))
        }
    }
}
{
    const zA = self.t
      , VA = new WeakMap;
    window.SDK.IZipFileEntry = class {
        constructor(t) {
            VA.set(this, t)
        }
        static Wfi(t) {
            return zA.U(t, window.SDK.IZipFileEntry),
            VA.get(t)
        }
    }
}
{
    const WA = self.t;
    WA.SDe = class extends WA.ii {
        constructor(t) {
            super(),
            WA.U(t, window.SDK.IPluginBase),
            this.xDe = t
        }
        he() {
            this.xDe.Release(),
            this.xDe = null,
            super.he()
        }
        OL(t) {
            WA.U(t, self.s_);
            let i = this.XPe().Type;
            !i && this.$a().bke() >= 2 && (i = globalThis.SDK.ITypeBase);
            return WA.v(i, this.xDe, t.EDe()).MDe(this, t)
        }
    }
}
{
    const HA = self.t;
    HA.CDe = class extends HA.Ai {
        constructor(t, i, e) {
            super(t, i),
            HA.U(e, window.SDK.ITypeBase),
            this._De = e
        }
        TC(t) {
            HA.U(t, window.PC);
            const i = "world" === this.Ps.$a().Ek() ? window.SDK.IWorldInstance : window.SDK.IObjectInstance;
            let e = this.gd().XPe().Instance;
            !e && this.$a().bke() >= 2 && (e = globalThis.SDK.IInstanceBase);
            return HA.v(e, this._De, new i(t)).TDe(this, t)
        }
        kGe() {
            return this._De
        }
    }
}
{
    const KA = self.t;
    KA.IDe = class extends KA.Fi {
        constructor(t, i, e) {
            KA.U(e, window.SDK.IInstanceBase),
            super(t, i),
            this.PDe = e,
            this.GDe = null,
            KA.Bm(this.Ie, self.ig) && (this.GDe = t => this.Gw(t),
            self.app.addEventListener("timelineeditablechange", this.GDe))
        }
        RGe() {
            return this.PDe
        }
        he() {
            this.GDe && self.app.removeEventListener("timelineeditablechange", this.GDe),
            this.GDe = null,
            this.PDe.Release(),
            super.he()
        }
        Ei() {
            this.PDe.OnCreate()
        }
        Fb() {
            this.PDe.OnAfterCreate()
        }
        ue(t, i) {
            i && i instanceof KA.za && (i = new window.SDK.Color(i.xsi(),i.Msi(),i.Esi(),i.Ix())),
            this.PDe.OnPropertyChanged(t, i)
        }
        nb(t, i, e) {
            let s;
            i && i instanceof KA.za && (i = new window.SDK.Color(i.xsi(),i.Msi(),i.Esi(),i.Ix())),
            !0 === e.rb ? s = "relative" : !0 === e.absolute && (s = "absolute"),
            this.PDe.OnTimelinePropertyChanged(t, i, {
                resultMode: s
            })
        }
        Gw(t) {
            const i = t.timeline
              , e = i.Cn();
            this.Cn() === e && (e.Xw() || e.lb() === i && i.ob(this.Ie) && (i.hb() || this.PDe.OnExitTimelineEditMode()))
        }
        N(t, i) {
            return this.PDe.LoadC2Property(t, i)
        }
    }
}
{
    const qA = self.t;
    qA.ADe = class extends qA.IDe {
        constructor(t, i, e) {
            qA.U(e, window.SDK.IWorldInstanceBase),
            super(t, i, e)
        }
        $n(t, i) {
            this.PDe.Draw(self.app.Us().RU(), i.KM)
        }
        Pr() {
            this.PDe.OnPlacedInLayout()
        }
        Gm() {
            return this.PDe.IsOriginalSizeKnown()
        }
        _m() {
            return this.PDe.GetOriginalWidth()
        }
        jm() {
            return this.PDe.GetOriginalHeight()
        }
        dr() {
            return this.PDe.HasDoubleTapHandler()
        }
        mr() {
            this.PDe.OnDoubleTap()
        }
    }
}
{
    const XA = globalThis.t;
    XA.RDe = class extends XA.h {
        constructor(t) {
            super(),
            XA.U(t, globalThis.SDK.IBehaviorBase),
            this.kDe = t
        }
        he() {
            this.kDe.Release(),
            this.kDe = null,
            super.he()
        }
        COe(t) {
            XA.U(t, globalThis.qte);
            let i = this.XPe().Type;
            !i && this.wre().bke() >= 2 && (i = globalThis.SDK.IBehaviorTypeBase);
            return XA.v(i, this.kDe, new globalThis.SDK.IBehaviorType(t)).ODe(this, t)
        }
    }
}
{
    const YA = self.t;
    YA.DDe = class extends YA.R {
        constructor(t, i, e) {
            super(t, i),
            YA.U(e, window.SDK.IBehaviorTypeBase),
            this.FDe = e
        }
        TC(t) {
            YA.U(t, window.IOe);
            let i = this.POe().XPe().Instance;
            !i && this.wre().bke() >= 2 && (i = globalThis.SDK.IBehaviorInstanceBase);
            return YA.v(i, this.FDe, new window.SDK.IBehaviorInstance(t)).LDe(this, t)
        }
    }
}
{
    const JA = self.t;
    JA.BDe = class extends JA.W {
        constructor(t, i, e) {
            super(t, i),
            JA.U(e, window.SDK.IBehaviorInstanceBase),
            this.UDe = e
        }
        NDe() {
            return this.UDe
        }
        he() {
            this.UDe.Release(),
            super.he()
        }
        Ei() {
            this.UDe.OnCreate()
        }
        ue(t, i) {
            i && i instanceof JA.za && (i = new window.SDK.Color(i.xsi(),i.Msi(),i.Esi(),i.Ix())),
            this.UDe.OnPropertyChanged(t, i)
        }
    }
}
{
    const ZA = self.t
      , QA = new WeakMap;
    window.SDK.IPluginBase = class {
        constructor(t) {
            ZA.zt(t),
            this._class = new.target;
            const i = ZA.v(self.si, t);
            this._info = new window.SDK.IPluginInfo(i);
            const e = ZA.v(ZA.SDe, this);
            e.qPe(this._class),
            e.YPe(i),
            QA.set(this, e)
        }
        Release() {
            this._class = null,
            this._info = null
        }
        qRe() {
            return QA.get(this)
        }
        static Register(t, i) {
            ZA.zt(t),
            ZA.nu(i),
            ZA.Li.addEventListener("load", e => {
                ZA.Li.Di(t, i)
            }
            )
        }
    }
}
{
    const tR = self.t
      , iR = new WeakMap;
    window.SDK.IPluginInfo = class {
        constructor(t) {
            tR.U(t, self.si),
            iR.set(this, t)
        }
        SetName(t) {
            iR.get(this).I(t)
        }
        SetDescription(t) {
            iR.get(this).k(t)
        }
        SetVersion(t) {
            iR.get(this).P(t)
        }
        SetCategory(t) {
            iR.get(this).S(t)
        }
        SetAuthor(t) {
            iR.get(this).B(t)
        }
        SetHelpUrl(t) {
            iR.get(this).L(t)
        }
        SetPluginType(t) {
            iR.get(this).Ui(t)
        }
        SetIcon(t, i) {
            iR.get(this).m0(t, i)
        }
        SetIsResizable(t) {
            iR.get(this).Bi(t)
        }
        SetIsRotatable(t) {
            iR.get(this).Hi(t)
        }
        SetSupportsZElevation(t) {
            iR.get(this).Xi(t)
        }
        SetHasImage(t) {
            iR.get(this).Wi(t)
        }
        SetDefaultImageURL(t) {
            iR.get(this).yb(t)
        }
        SetHasAnimations(t) {
            iR.get(this).Cf(t)
        }
        SetIsTiled(t) {
            iR.get(this).aC(t)
        }
        SetIsFont(t) {
            iR.get(this).bb(t)
        }
        SetHasTilemap(t) {
            iR.get(this).bC(t)
        }
        SetIsDeprecated(t) {
            iR.get(this).Or(t)
        }
        SetIsSingleGlobal(t) {
            iR.get(this).ni(t)
        }
        SetSupportsEffects(t) {
            iR.get(this).Ni(t)
        }
        SetMustPreDraw(t) {
            iR.get(this).Yi(t)
        }
        SetIs3D(t) {
            iR.get(this).ua(t)
        }
        SetSupportsColor(t) {
            iR.get(this).$i(t)
        }
        SetCanBeBundled(t) {
            iR.get(this).qAe(t)
        }
        SetUsesJquery(t) {
            (() => {})("[SDK] SetUsesJquery() is deprecated and no longer has any effect")
        }
        AddCommonPositionACEs() {
            iR.get(this).Ji()
        }
        AddCommonSizeACEs() {
            iR.get(this).qi()
        }
        AddCommonAngleACEs() {
            iR.get(this).Ki()
        }
        AddCommonAppearanceACEs() {
            iR.get(this).Qi()
        }
        AddCommonZOrderACEs() {
            iR.get(this).Zi()
        }
        AddCommonSceneGraphACEs() {
            iR.get(this).ds()
        }
        SetProperties(t) {
            iR.get(this).O(t.map(t => self.i.GGe(t)))
        }
        AddCordovaPluginReference(t) {
            iR.get(this).wr({
                id: t.id,
                version: t.version || "",
                source: t.source || "default",
                platform: t.platform || "all",
                ftt: t.plugin,
                KRe: t.variables
            })
        }
        AddCordovaResourceFile(t) {
            iR.get(this).dRe({
                src: t.src,
                target: t.target || "",
                platform: t.platform || "all"
            })
        }
        AddFileDependency(t) {
            iR.get(this).vt({
                filename: t.filename,
                Vt: t.fileType || "",
                nke: t.scriptType || "",
                type: t.type,
                platform: t.platform || "all"
            })
        }
        AddRemoteScriptDependency(t, i="") {
            iR.get(this).hl(t, i)
        }
        SetSupportedRuntimes() {
            (() => {})("[SDK] SetSupportedRuntimes() is deprecated and no longer has any effect")
        }
        SetRuntimeModuleMainScript(t) {
            iR.get(this).TRe(t)
        }
        AddC3RuntimeScript(t) {
            iR.get(this).Ke(t)
        }
        SetC3RuntimeScripts(t) {
            iR.get(this).CRe(t)
        }
        SetDOMSideScripts(t) {
            iR.get(this).br(t)
        }
        SetAndroidXEnabled(t) {
            (() => {})("[SDK] SetAndroidXEnabled() is deprecated and no longer has any effect")
        }
        SetGooglePlayServicesEnabled(t) {
            iR.get(this).bRe(t)
        }
        SetWrapperExportProperties(t, i) {
            iR.get(this).SRe(t, i)
        }
        SetScriptInterfaceNames(t) {
            iR.get(this).C({
                M: t.instance,
                objectType: t.objectType,
                ftt: t.plugin
            })
        }
        SetTypeScriptDefinitionFiles(t) {
            iR.get(this).T(t)
        }
    }
}
window.SDK.PluginProperty = class {
    constructor(t, i, e) {
        this.aGt = t,
        this.Rdi = i,
        this.bht = e
    }
    W7() {
        return this.aGt
    }
    Bk() {
        return this.Rdi
    }
    AGe() {
        return this.bht
    }
}
;
{
    const eR = self.t
      , sR = new WeakMap;
    window.SDK.ITypeBase = class {
        constructor(t, i) {
            this._sdkPlugin = t,
            this._objectType = i
        }
        MDe(t, i) {
            const e = eR.v(eR.CDe, t, i, this);
            return sR.set(this, e),
            e
        }
        GetObjectType() {
            return this._objectType
        }
    }
}
{
    const nR = self.t
      , rR = new WeakMap;
    window.SDK.IInstanceBase = class {
        constructor(t, i) {
            this._sdkType = t,
            this._inst = i
        }
        TDe(t, i) {
            const e = nR.v(nR.IDe, t, i, this);
            return this.lMi(e),
            e
        }
        lMi(t) {
            rR.set(this, t)
        }
        Release() {}
        OnCreate() {}
        OnAfterCreate() {}
        OnPropertyChanged(t, i) {}
        OnTimelinePropertyChanged(t, i, e) {}
        OnExitTimelineEditMode() {}
        LoadC2Property(t, i) {
            return !1
        }
        GetObjectType() {
            return this._sdkType.GetObjectType()
        }
        GetProject() {
            return this._inst.GetProject()
        }
        GetInstance() {
            return this._inst
        }
    }
}
{
    const hR = self.t
      , oR = (new WeakMap,
    new window.SDK.Rect(0,0,1,1));
    window.SDK.IWorldInstanceBase = class extends window.SDK.IInstanceBase {
        constructor(t, i) {
            super(t, i),
            this._isLoadingTexture = !1,
            this._isWebGLTextureLoading = !1,
            this._hadWebGLTextureError = !1,
            this._webGLTexRect = oR,
            this._onWebGLContextLost = null
        }
        TDe(t, i) {
            const e = hR.v(hR.ADe, t, i, this);
            return this.lMi(e),
            e
        }
        Draw(t, i) {
            hR.kK()
        }
        OnPlacedInLayout() {}
        GetTexture(t) {
            if (hR.Ef(t, window.SDK.IAnimationFrame),
            !t)
                return null;
            const i = t.GetCachedWebGLTexture();
            return i ? (this._webGLTexRect = t.GetTexRect(),
            i) : (this._isLoadingTexture || (this._isWebGLTextureLoading = !0,
            t.LoadWebGLTexture().then(t => {
                this._isWebGLTextureLoading = !1
            }
            ).catch(t => {
                console.error("Error loading texture:", t),
                this._hadWebGLTextureError = !0
            }
            )),
            null)
        }
        GetTexRect() {
            return this._webGLTexRect
        }
        HadTextureError() {
            return this._hadWebGLTextureError
        }
        IsOriginalSizeKnown() {
            return !1
        }
        GetOriginalWidth() {
            hR.kK()
        }
        GetOriginalHeight() {
            hR.kK()
        }
        HasDoubleTapHandler() {
            return !1
        }
        OnDoubleTap() {
            hR.kK()
        }
    }
}
{
    const aR = self.t
      , lR = new WeakMap;
    window.SDK.IBehaviorBase = class {
        constructor(t) {
            aR.zt(t),
            this._class = new.target;
            const i = aR.v(self.V, t);
            this._info = new window.SDK.IBehaviorInfo(i);
            const e = aR.v(aR.RDe, this);
            e.qPe(this._class),
            e.YPe(i),
            lR.set(this, e)
        }
        Release() {
            this._class = null,
            this._info = null
        }
        LOe() {
            return lR.get(this)
        }
        static Register(t, i) {
            aR.zt(t),
            aR.nu(i),
            aR.F.addEventListener("load", e => {
                aR.F._(t, i)
            }
            )
        }
    }
}
{
    const uR = self.t
      , cR = new WeakMap;
    window.SDK.IBehaviorInfo = class {
        constructor(t) {
            uR.U(t, self.V),
            cR.set(this, t)
        }
        SetName(t) {
            cR.get(this).I(t)
        }
        SetDescription(t) {
            cR.get(this).k(t)
        }
        SetVersion(t) {
            cR.get(this).P(t)
        }
        SetCategory(t) {
            cR.get(this).S(t)
        }
        SetAuthor(t) {
            cR.get(this).B(t)
        }
        SetHelpUrl(t) {
            cR.get(this).L(t)
        }
        SetIcon(t, i) {
            cR.get(this).m0(t, i)
        }
        SetIsOnlyOneAllowed(t) {
            cR.get(this).H(t)
        }
        SetIsDeprecated(t) {
            cR.get(this).Or(t)
        }
        SetCanBeBundled(t) {
            cR.get(this).qAe(t)
        }
        SetProperties(t) {
            cR.get(this).O(t.map(t => self.i.GGe(t)))
        }
        AddCordovaPluginReference(t) {
            cR.get(this).wr({
                id: t.id,
                version: t.version || "",
                source: t.source || "default",
                platform: t.platform || "all"
            })
        }
        AddFileDependency(t) {
            cR.get(this).vt({
                filename: t.filename,
                Vt: t.fileType || "",
                nke: t.scriptType || "",
                type: t.type,
                platform: t.platform || "all"
            })
        }
        AddRemoteScriptDependency(t, i="") {
            cR.get(this).hl(t, i)
        }
        SetRuntimeModuleMainScript(t) {
            cR.get(this).TRe(t)
        }
        AddC3RuntimeScript(t) {
            cR.get(this).Ke(t)
        }
        SetC3RuntimeScripts(t) {
            cR.get(this).CRe(t)
        }
        SetSupportedRuntimes() {
            (() => {})("[SDK] SetSupportedRuntimes() is deprecated and no longer has any effect")
        }
        SetScriptInterfaceNames(t) {
            cR.get(this).C({
                M: t.instance,
                Tee: t.behaviorType,
                behavior: t.behavior
            })
        }
        SetTypeScriptDefinitionFiles(t) {
            cR.get(this).T(t)
        }
    }
}
{
    const dR = self.t
      , fR = new WeakMap;
    window.SDK.IBehaviorTypeBase = class {
        constructor(t, i) {
            this._sdkBehavior = t,
            this._behaviorType = i
        }
        ODe(t, i) {
            const e = dR.v(dR.DDe, t, i, this);
            return fR.set(this, e),
            e
        }
    }
}
{
    const pR = self.t
      , mR = new WeakMap;
    window.SDK.IBehaviorInstanceBase = class {
        constructor(t, i) {
            this._sdkBehaviorType = t,
            this._behaviorInstance = i
        }
        LDe(t, i) {
            const e = pR.v(pR.BDe, t, i, this);
            return mR.set(this, e),
            e
        }
        Release() {}
        OnCreate() {}
        OnPropertyChanged(t, i) {}
        GetBehaviorInstance() {
            return this._behaviorInstance
        }
        GetSdkBehaviorType() {
            return this._sdkBehaviorType
        }
    }
}
{
    const wR = self.t
      , gR = new WeakMap;
    window.SDK.IObjectClass = class {
        constructor(t) {
            wR.U(t, window.i_),
            gR.set(this, t)
        }
        static Wfi(t) {
            return wR.U(t, window.SDK.IObjectClass),
            gR.get(t)
        }
        GetProject() {
            return gR.get(this).Cn().jDe()
        }
        GetName() {
            return gR.get(this).La()
        }
        Delete() {
            gR.get(this).XT()
        }
    }
}
{
    const yR = self.t
      , bR = new WeakMap;
    window.SDK.IObjectType = class extends window.SDK.IObjectClass {
        constructor(t) {
            yR.U(t, window.s_),
            super(t),
            bR.set(this, t)
        }
        static Wfi(t) {
            return yR.U(t, window.SDK.IObjectType),
            bR.get(t)
        }
        GetImage() {
            return bR.get(this).bn().$De()
        }
        EditImage() {
            yR.Qs.Ks.qs("AnimationsEditor").Js(bR.get(this))
        }
        GetAnimations() {
            return [...bR.get(this).Qde()].map(t => t.zDe())
        }
        EditAnimations() {
            this.EditImage()
        }
        async AddAnimation(t, i, e, s) {
            yR.gL(t);
            const n = bR.get(this)
              , r = yR.v(self.Fg, n, t || "Animation 1")
              , h = r.zDe();
            return await h.AddFrame(i, e, s),
            n.TL().WL(r),
            h
        }
        CreateWorldInstance(t) {
            const i = bR.get(this).Rk(window.SDK.ILayer.Wfi(t));
            return i.Ei(),
            i.Pr(),
            new window.SDK.IWorldInstance(i)
        }
        GetAllInstances() {
            return [...bR.get(this).Ls()].map(t => new window.SDK.IWorldInstance(t))
        }
        IsInContainer() {
            return bR.get(this).kB()
        }
        GetContainer() {
            const t = bR.get(this).WB();
            return t ? t.VDe() : null
        }
        CreateContainer(t) {
            return bR.get(this).Jre(t.map(t => bR.get(t))).VDe()
        }
    }
}
{
    const vR = self.t
      , SR = new WeakMap;
    window.SDK.IFamily = class extends window.SDK.IObjectClass {
        constructor(t) {
            vR.U(t, window.Zl),
            super(t),
            SR.set(this, t)
        }
        GetMembers() {
            return [...SR.get(this).eh()].map(t => t.EDe())
        }
        SetMembers(t) {
            const i = SR.get(this)
              , e = [];
            for (const s of t) {
                const t = window.SDK.IObjectClass.Wfi(s);
                if (!i.AL(t, !1))
                    throw new Error(`object type '${t.La()}' incompatible with family '${i.La()}`);
                e.push(t)
            }
            i.rUt(e)
        }
    }
}
{
    const xR = self.t
      , MR = new WeakMap;
    window.SDK.IObjectInstance = class {
        constructor(t) {
            xR.U(t, window.PC),
            MR.set(this, t)
        }
        static Wfi(t) {
            return xR.U(t, window.SDK.IObjectInstance),
            MR.get(t)
        }
        GetProject() {
            return MR.get(this).Cn().jDe()
        }
        GetObjectType() {
            return MR.get(this).Ds().EDe()
        }
        GetExternalSdkInstance() {
            const t = MR.get(this).ud();
            return t instanceof xR.IDe ? t.RGe() : null
        }
        GetUID() {
            return MR.get(this).au()
        }
        GetPropertyValue(t) {
            let i = MR.get(this).js(t);
            return i && i instanceof xR.za && (i = new window.SDK.Color(i.xsi(),i.Msi(),i.Esi(),i.Ix())),
            i
        }
        GetTimelinePropertyValue(t) {
            let i = MR.get(this).me(t);
            return i && i instanceof xR.za && (i = new window.SDK.Color(i.xsi(),i.Msi(),i.Esi(),i.Ix())),
            i
        }
        SetPropertyValue(t, i) {
            i && i instanceof window.SDK.Color && (i = new xR.za(i.getR(),i.getG(),i.getB(),i.getA())),
            MR.get(this).A(t, i)
        }
    }
}
{
    const ER = self.t
      , CR = new WeakMap;
    window.SDK.IWorldInstance = class extends window.SDK.IObjectInstance {
        constructor(t) {
            ER.U(t, window.ig),
            super(t),
            CR.set(this, t)
        }
        GetBoundingBox() {
            return CR.get(this).WDe()
        }
        GetQuad() {
            return CR.get(this).HDe()
        }
        GetColor() {
            return CR.get(this).KDe()
        }
        GetOpacity() {
            return CR.get(this).wh()
        }
        SetOpacity(t) {
            CR.get(this).Uo(t)
        }
        SetX(t) {
            CR.get(this).Fo(t)
        }
        GetX() {
            return CR.get(this).ka()
        }
        SetY(t) {
            CR.get(this).Eo(t)
        }
        GetY() {
            return CR.get(this).Ra()
        }
        SetXY(t, i) {
            const e = CR.get(this);
            e.Fo(t),
            e.Eo(i)
        }
        SetZElevation(t) {
            CR.get(this).Nie(t)
        }
        GetZElevation() {
            return CR.get(this).qR()
        }
        GetTotalZElevation() {
            return CR.get(this).Yl()
        }
        SetWidth(t) {
            CR.get(this).Cb(t)
        }
        GetWidth() {
            return CR.get(this).ns()
        }
        SetHeight(t) {
            CR.get(this).Ib(t)
        }
        GetHeight() {
            return CR.get(this).er()
        }
        SetSize(t, i) {
            CR.get(this).zr(t, i)
        }
        SetOriginX(t) {
            CR.get(this).Gl(t)
        }
        GetOriginX() {
            return CR.get(this).Hf()
        }
        SetOriginY(t) {
            CR.get(this)._l(t)
        }
        GetOriginY() {
            return CR.get(this).Wf()
        }
        SetOrigin(t, i) {
            CR.get(this).Bf(t, i)
        }
        GetAngle() {
            return CR.get(this).es()
        }
        SetAngle(t) {
            CR.get(this).Bo(t)
        }
        GetLayer() {
            return CR.get(this).Za().qDe()
        }
        GetLayout() {
            return CR.get(this).td().XDe()
        }
        ApplyBlendMode(t) {
            CR.get(this).Xn(window.SDK.Gfx.IWebGLRenderer.Wfi(t))
        }
    }
}
{
    const _R = self.t
      , TR = new WeakMap;
    window.SDK.IAnimation = class {
        constructor(t) {
            _R.U(t, window.Fg),
            TR.set(this, t)
        }
        GetName() {
            return TR.get(this).La()
        }
        GetObjectType() {
            return TR.get(this).Ds().EDe()
        }
        GetFrames() {
            return [...TR.get(this).frames()].map(t => t.$De())
        }
        async AddFrame(t, i, e) {
            _R.Ef(t, Blob),
            _R.iM(i),
            _R.iM(e);
            const s = TR.get(this)
              , n = _R.v(self.zf, s.Ds(), s);
            return s.lW(n),
            t ? "number" == typeof i && "number" == typeof e ? n.oW(t, i, e) : await n.YDe(t) : await n.JDe(i, e),
            n.$De()
        }
        SetSpeed(t) {
            TR.get(this).ZDe(t)
        }
        GetSpeed() {
            return TR.get(this).Og()
        }
        SetLooping(t) {
            TR.get(this).QDe(!!t)
        }
        IsLooping() {
            return TR.get(this).Pg()
        }
        SetPingPong(t) {
            TR.get(this).Ahe(!!t)
        }
        IsPingPong() {
            return TR.get(this).Tg()
        }
        SetRepeatCount(t) {
            TR.get(this).Mhe(t)
        }
        GetRepeatCount() {
            return TR.get(this).kg()
        }
        SetRepeatTo(t) {
            TR.get(this).tFe(t)
        }
        GetRepeatTo() {
            return TR.get(this).Vg()
        }
        Delete() {
            const t = TR.get(this);
            if (t.Ds().iFe() < 2)
                throw new Error("cannot delete last animation");
            t.XT()
        }
    }
}
{
    const IR = self.t
      , PR = new WeakMap;
    window.SDK.IAnimationFrame = class {
        constructor(t) {
            IR.U(t, window.zf),
            PR.set(this, t)
        }
        GetObjectType() {
            return PR.get(this).Ds().EDe()
        }
        GetWidth() {
            return PR.get(this).ns()
        }
        GetHeight() {
            return PR.get(this).er()
        }
        GetCachedWebGLTexture() {
            return window.SDK.Gfx.IWebGLTexture.eFe(PR.get(this).lGe())
        }
        GetTexRect() {
            return PR.get(this).sFe()
        }
        async LoadWebGLTexture() {
            const t = await PR.get(this).uGe();
            return window.SDK.Gfx.IWebGLTexture.eFe(t)
        }
        GetBlob() {
            return PR.get(this).lS()
        }
        ReplaceBlobAndDecode(t) {
            return PR.get(this).bct(t)
        }
        SetDuration(t) {
            PR.get(this).Awi(t)
        }
        GetDuration() {
            return PR.get(this).Mg()
        }
        GetOriginX() {
            return PR.get(this).Hf()
        }
        SetOriginX(t) {
            PR.get(this).Gl(t)
        }
        GetOriginY() {
            return PR.get(this).Wf()
        }
        SetOriginY(t) {
            PR.get(this)._l(t)
        }
        AddImagePoint(t, i, e) {
            return PR.get(this).rFe(t, i, e).nFe()
        }
        GetImagePoints() {
            return [...PR.get(this).Bri()].map(t => t.nFe())
        }
        GetCollisionPoly() {
            return PR.get(this).hFe()
        }
        Delete() {
            const t = PR.get(this);
            if (t.kw().Qm() < 2)
                throw new Error("cannot delete last animation frame");
            t.XT()
        }
    }
}
{
    const GR = self.t
      , AR = new WeakMap;
    window.SDK.IImagePoint = class {
        constructor(t) {
            GR.U(t, window.oFe),
            AR.set(this, t)
        }
        GetAnimationFrame() {
            return AR.get(this).qw().$De()
        }
        GetName() {
            return AR.get(this).La()
        }
        SetName(t) {
            AR.get(this).I(t)
        }
        GetX() {
            return AR.get(this).ka()
        }
        SetX(t) {
            AR.get(this).Fo(t)
        }
        GetY() {
            return AR.get(this).Ra()
        }
        SetY(t) {
            return AR.get(this).Eo(t)
        }
    }
}
{
    const RR = self.t
      , kR = new WeakMap;
    window.SDK.ICollisionPoly = class {
        constructor(t) {
            RR.U(t, window.Jp),
            kR.set(this, t)
        }
        Reset() {
            kR.get(this).qd()
        }
        IsDefault() {
            return kR.get(this).sv()
        }
        GetPoints() {
            return kR.get(this).aFe()
        }
        SetPoints(t) {
            if (RR.RH(t),
            t.length < 6 || t.length % 2 != 0)
                throw new Error("invalid points array");
            kR.get(this).Vhi(t)
        }
    }
}
{
    const OR = self.t
      , DR = new WeakMap;
    window.SDK.IContainer = class {
        constructor(t) {
            OR.U(t, window.lFe),
            DR.set(this, t)
        }
        IsActive() {
            return DR.get(this).tc()
        }
        GetMembers() {
            return [...DR.get(this).eh()].map(t => t.EDe())
        }
        SetSelectMode(t) {
            DR.get(this).qre(t)
        }
        GetSelectMode() {
            return DR.get(this).Rz()
        }
        RemoveObjectType(t) {
            const i = DR.get(this)
              , e = window.SDK.IObjectClass.Wfi(t);
            i.Lre(e)
        }
    }
}
{
    const FR = self.t
      , LR = new WeakMap;
    window.SDK.IBehaviorType = class {
        constructor(t) {
            FR.U(t, window.qte),
            LR.set(this, t)
        }
        GetProject() {
            return LR.get(this).Cn().jDe()
        }
        GetName() {
            return LR.get(this).La()
        }
    }
}
{
    const BR = self.t
      , UR = new WeakMap;
    window.SDK.IBehaviorInstance = class {
        constructor(t) {
            BR.U(t, window.IOe),
            UR.set(this, t)
        }
        GetProject() {
            return UR.get(this).Cn().jDe()
        }
        GetPropertyValue(t) {
            let i = UR.get(this).js(t);
            return i && i instanceof BR.za && (i = new window.SDK.Color(i.xsi(),i.Msi(),i.Esi(),i.Ix())),
            i
        }
        SetPropertyValue(t, i) {
            i && i instanceof window.SDK.Color && (i = new BR.za(i.getR(),i.getG(),i.getB(),i.getA())),
            UR.get(this).A(t, i)
        }
        GetObjectInstance() {
            const t = UR.get(this).nd();
            return t instanceof self.ig ? new window.SDK.IWorldInstance(t) : new window.SDK.IObjectInstance(t)
        }
        GetExternalSdkInstance() {
            const t = UR.get(this).ud();
            return t instanceof BR.BDe ? t.NDe() : null
        }
    }
}
{
    const NR = self.t
      , jR = new WeakMap;
    window.SDK.IProject = class {
        constructor(t) {
            NR.U(t, window.jw),
            jR.set(this, t)
        }
        GetName() {
            return jR.get(this).La()
        }
        GetRuntime() {
            return (() => {})("[SDK] IProject.GetRuntime() is deprecated and always returns 'c3'"),
            "c3"
        }
        GetSystemType() {
            return jR.get(this).JQt().EDe()
        }
        GetSingleGlobalObjectType(t) {
            NR.zt(t);
            const i = jR.get(this).uFe(t);
            return i ? i.EDe() : null
        }
        async CreateObjectType(t, i) {
            const e = jR.get(this)
              , s = NR.Li.ed(t, e).OL(e, e.eL(i));
            return await s.JDe(),
            e.xL().WL(s),
            s.EDe()
        }
        CreateFamily(t, i) {
            if (NR.gL(t),
            NR.QH(i, window.SDK.IObjectType),
            !i.length)
                throw new Error("no family members provided");
            const e = jR.get(this);
            t = (t = self.i_.hW(t || "", !0)) ? e.eL(t) : e.aUt();
            const s = window.SDK.IObjectType.Wfi(i[0]).$a()
              , n = NR.v(self.Zl, e, s, t);
            return n.rUt(i.map(t => window.SDK.IObjectType.Wfi(t))),
            e.hUt(n),
            n.cFe()
        }
        GetObjectTypeByName(t) {
            NR.zt(t);
            const i = jR.get(this).GL(t);
            return i ? i.EDe() : null
        }
        GetFamilyByName(t) {
            NR.zt(t);
            const i = jR.get(this).RL(t);
            return i ? i.cFe() : null
        }
        GetObjectClassByName(t) {
            NR.zt(t);
            const i = jR.get(this).dFe(t);
            return i instanceof self.s_ ? i.EDe() : i instanceof self.Zl ? i.cFe() : null
        }
        GetObjectClassBySID(t) {
            NR.Ge(t);
            const i = jR.get(this).Ql(t);
            return i instanceof self.s_ ? i.EDe() : i instanceof self.Zl ? i.cFe() : null
        }
        GetInstanceByUID(t) {
            NR.Ge(t);
            const i = jR.get(this).fFe(t);
            return i ? i instanceof self.ig ? new window.SDK.IWorldInstance(i) : new window.SDK.IObjectInstance(i) : null
        }
        AddOrReplaceProjectFile(t, i, e="general") {
            jR.get(this).pFe(e).fW(t, i)
        }
        GetProjectFileByName(t) {
            NR.zt(t);
            const i = jR.get(this).lq(t);
            return i ? i.mFe() : null
        }
        GetProjectFileByExportPath(t) {
            NR.zt(t);
            const i = jR.get(this).wFe(t);
            return i ? i.mFe() : null
        }
        ShowImportAudioDialog(t) {
            const i = jR.get(this);
            NR.Qs.Ks.qs("ImportAudio").Y7(t, i, document.body)
        }
        EnsureFontLoaded(t) {
            return jR.get(this).$S(t)
        }
        UndoPointChangeObjectInstancesProperty(t, i) {
            t = Array.isArray(t) ? t.map(t => window.SDK.IObjectInstance.Wfi(t)) : [window.SDK.IObjectInstance.Wfi(t)],
            jR.get(this).Ya(new self.qa.Ja(t,i))
        }
    }
}
{
    const $R = self.t
      , zR = new WeakMap;
    window.SDK.ILayout = class {
        constructor(t) {
            $R.U(t, window.g_),
            zR.set(this, t)
        }
        GetName() {
            return zR.get(this).La()
        }
        GetProject() {
            return zR.get(this).Cn().jDe()
        }
        GetEventSheet() {
            const t = zR.get(this).GT();
            return t ? t.gFe() : null
        }
        GetAllLayers() {
            return [...zR.get(this).tA()].map(t => t.qDe())
        }
    }
}
{
    const VR = self.t
      , WR = new WeakMap;
    window.SDK.ILayer = class {
        constructor(t) {
            VR.U(t, window.t_),
            WR.set(this, t)
        }
        static Wfi(t) {
            return VR.U(t, window.SDK.ILayer),
            WR.get(t)
        }
        GetName() {
            return WR.get(this).La()
        }
        GetLayout() {
            return WR.get(this).td().XDe()
        }
    }
}
{
    const HR = self.t
      , KR = new WeakMap;
    window.SDK.IProjectFile = class {
        constructor(t) {
            HR.U(t, window.e0),
            KR.set(this, t)
        }
        GetName() {
            return KR.get(this).La()
        }
        GetProject() {
            return KR.get(this).Cn().jDe()
        }
        GetBlob() {
            return KR.get(this).lS()
        }
    }
}
{
    const qR = self.t
      , XR = new WeakMap;
    window.SDK.IEventSheet = class {
        constructor(t) {
            qR.U(t, window.UQ),
            XR.set(this, t)
        }
        GetName() {
            return XR.get(this).La()
        }
        GetProject() {
            return XR.get(this).Cn().jDe()
        }
        GetRoot() {
            return XR.get(this).rz().yFe()
        }
    }
}
{
    const YR = self.t
      , JR = new WeakMap;
    window.SDK.IEventParentRow = class {
        constructor(t) {
            YR.U(t, window.BKt),
            JR.set(this, t)
        }
        async AddEventBlock() {
            const t = JR.get(this)
              , i = YR.v(self._Bt, t);
            return await t.WH(i),
            i.yFe()
        }
    }
}
{
    const ZR = self.t
      , QR = new WeakMap;
    function tk(t) {
        if ("string" == typeof t)
            return t;
        if ("number" == typeof t)
            return t.toString();
        if (t && t instanceof window.SDK.IObjectClass)
            return window.SDK.IObjectClass.Wfi(t);
        throw TypeError("unsupported event parameter")
    }
    window.SDK.IEventBlock = class extends window.SDK.IEventParentRow {
        constructor(t) {
            ZR.U(t, window._Bt),
            super(t),
            QR.set(this, t)
        }
        AddCondition(t, i, e, s) {
            if (ZR.U(t, window.SDK.IObjectClass),
            ZR.zt(e),
            ZR.D_t(s),
            !ZR.aM(i))
                throw new Error("value passed for reserved parameter");
            const n = QR.get(this)
              , r = window.SDK.IObjectClass.Wfi(t)
              , h = r.$a().li(e)
              , o = ZR.v(self.HYt, n, r, null, h);
            for (const t of o.parameters()) {
                const i = t.ZC();
                if (i >= s.length)
                    throw new RangeError("not enough parameters passed");
                t.Set(tk(s[i]))
            }
            n.CQt(o)
        }
        AddAction(t, i, e, s) {
            if (ZR.U(t, window.SDK.IObjectClass),
            ZR.zt(e),
            ZR.D_t(s),
            !ZR.aM(i))
                throw new Error("value passed for reserved parameter");
            const n = QR.get(this)
              , r = window.SDK.IObjectClass.Wfi(t)
              , h = r.$a().ci(e)
              , o = ZR.v(self.jQt, n, r, null, h);
            for (const t of o.parameters()) {
                const i = t.ZC();
                if (i >= s.length)
                    throw new RangeError("not enough parameters passed");
                t.Set(tk(s[i]))
            }
            n.hQt(o)
        }
    }
}
{
    const ik = self.t
      , ek = new WeakMap;
    window.SDK.Gfx.IWebGLRenderer = class {
        constructor(t) {
            ek.set(this, t)
        }
        static Wfi(t) {
            return ek.get(t)
        }
        SetAlphaBlend() {
            ek.get(this).sr()
        }
        SetColorFillMode() {
            ek.get(this).nr()
        }
        SetTextureFillMode() {
            ek.get(this).Wr()
        }
        SetSmoothLineFillMode() {
            ek.get(this).Hl()
        }
        SetColorRgba(t, i, e, s) {
            ek.get(this).rr(t, i, e, s)
        }
        SetColor(t) {
            ik.U(t, window.SDK.Color),
            ek.get(this).Jn(t.Co)
        }
        SetOpacity(t) {
            ek.get(this).Uo(t)
        }
        ResetColor() {
            ek.get(this).Nr()
        }
        SetCurrentZ(t) {
            ek.get(this).JR(t)
        }
        GetCurrentZ() {
            return ek.get(this).A3i()
        }
        Rect(t) {
            ik.U(t, window.SDK.Rect),
            ek.get(this).Rect(t.vOt)
        }
        Rect2(t, i, e, s) {
            ek.get(this).RY(t, i, e, s)
        }
        Quad(t) {
            ik.U(t, window.SDK.Quad),
            ek.get(this).zn(t.vDe)
        }
        Quad2(t, i, e, s, n, r, h, o) {
            ek.get(this).Z3i(t, i, e, s, n, r, h, o)
        }
        Quad3(t, i) {
            ik.U(t, window.SDK.Quad),
            ik.U(i, window.SDK.Rect),
            ek.get(this).ur(t.vDe, i.vOt)
        }
        Quad4(t, i) {
            ik.U(t, window.SDK.Quad),
            ik.U(i, window.SDK.Quad),
            ek.get(this).Dl(t.vDe, i.vDe)
        }
        Quad3D(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            ik.U(d, window.SDK.Rect),
            ek.get(this).Sm(t, i, e, s, n, r, h, o, a, l, u, c, d.vOt)
        }
        Quad3D2(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            ik.U(d, window.SDK.Quad),
            ek.get(this).Vm(t, i, e, s, n, r, h, o, a, l, u, c, d.vDe)
        }
        ConvexPoly(t) {
            ik.RH(t),
            ek.get(this).rf(t)
        }
        Line(t, i, e, s) {
            ek.get(this).Va(t, i, e, s)
        }
        TexturedLine(t, i, e, s, n, r) {
            ek.get(this).D3i(t, i, e, s, n, r)
        }
        LineRect(t, i, e, s) {
            ek.get(this).AY(t, i, e, s)
        }
        LineRect2(t) {
            ik.U(t, window.SDK.Rect),
            ek.get(this).qr(t.vOt)
        }
        LineQuad(t) {
            ik.U(t, window.SDK.Quad),
            ek.get(this).Hr(t.vDe)
        }
        PushLineWidth(t) {
            ek.get(this).zl(t)
        }
        PopLineWidth() {
            ek.get(this).Wl()
        }
        PushLineCap(t) {
            ek.get(this).X3i(t)
        }
        PopLineCap() {
            ek.get(this).$l()
        }
        SetTexture(t) {
            const i = window.SDK.Gfx.IWebGLTexture;
            ik.Ef(t, i),
            ek.get(this).hr(t ? i.Wfi(t) : null)
        }
        CreateWebGLText() {
            const t = ek.get(this).u4i();
            return new window.SDK.Gfx.IWebGLText(t)
        }
        CreateRendererText() {
            const t = ek.get(this).u4i();
            return new window.SDK.Gfx.IWebGLText(t)
        }
        CreateDynamicTexture(t, i, e) {
            const s = {
                kn: (e = e || {}).wrapX || "clamp-to-edge",
                Rn: e.wrapY || "clamp-to-edge",
                Mn: e.sampling || "trilinear",
                M9i: e.pixelFormat || "rgba8",
                yS: !e.hasOwnProperty("mipMap") || !!e.mipMap,
                SS: e.mipMapQuality || "default"
            };
            e.isTiled && ("repeat-x" !== e.tileType && "repeat" !== e.tileType && e.tileType || (s.kn = "repeat"),
            "repeat-y" !== e.tileType && "repeat" !== e.tileType && e.tileType || (s.Rn = "repeat"));
            const n = ek.get(this).jR(t, i, s);
            return window.SDK.Gfx.IWebGLTexture.eFe(n)
        }
        UpdateTexture(t, i, e) {
            e = e || {};
            const s = window.SDK.Gfx.IWebGLTexture;
            ik.Ef(i, s);
            const n = s.Wfi(i);
            ek.get(this).XR(t, n, {
                E9i: !!e.premultiplyAlpha
            })
        }
        DeleteTexture(t) {
            const i = window.SDK.Gfx.IWebGLTexture;
            ik.Ef(t, i);
            const e = i.Wfi(t);
            ek.get(this).mn(e)
        }
        DrawMesh(t, i, e) {
            ek.get(this).a2i(t, i, e)
        }
    }
}
{
    const sk = new WeakMap;
    window.SDK.Gfx.IDrawParams = class {
        constructor(t) {
            sk.set(this, t)
        }
        GetDt() {
            return sk.get(this).dt
        }
        GetLayoutView() {
            return sk.get(this).Ur._W()
        }
    }
}
{
    const nk = self.t
      , rk = new WeakMap
      , hk = new WeakMap;
    window.SDK.Gfx.IWebGLTexture = class {
        constructor(t) {
            nk.eI(t, nk.ea.C9i, nk.ea.DSe),
            rk.set(this, t),
            hk.set(t, this)
        }
        static eFe(t) {
            if (!t)
                return null;
            const i = hk.get(t);
            return i || new window.SDK.Gfx.IWebGLTexture(t)
        }
        static Wfi(t) {
            return nk.U(t, window.SDK.Gfx.IWebGLTexture),
            rk.get(t)
        }
        GetWidth() {
            return rk.get(this).ns()
        }
        GetHeight() {
            return rk.get(this).er()
        }
    }
}
{
    const ok = self.t
      , ak = new WeakMap;
    window.SDK.Gfx.IWebGLText = class {
        constructor(t) {
            ok.U(t, ok.ea.ta),
            ak.set(this, t)
        }
        Release() {
            ak.get(this).he()
        }
        SetFontName(t) {
            ak.get(this).al(t)
        }
        SetFontSize(t) {
            ak.get(this).sa(t)
        }
        SetLineHeight(t) {
            ak.get(this).$b(t)
        }
        SetBold(t) {
            ak.get(this).tC(t)
        }
        SetItalic(t) {
            ak.get(this).Ba(t)
        }
        SetColor(t) {
            ok.U(t, window.SDK.Color),
            ak.get(this).Jn(t.Co)
        }
        SetColorRgb(t, i, e) {
            ak.get(this).oa(t, i, e)
        }
        SetHorizontalAlignment(t) {
            ak.get(this).aa(t)
        }
        SetVerticalAlignment(t) {
            ak.get(this).la(t)
        }
        SetWordWrapMode(t) {
            ak.get(this).Ub(t)
        }
        SetText(t) {
            ak.get(this).ha(t)
        }
        SetSize(t, i, e) {
            ak.get(this).zr(t, i, e)
        }
        GetTexture() {
            const t = ak.get(this).jn();
            return t ? window.SDK.Gfx.IWebGLTexture.eFe(t) : null
        }
        GetTexRect() {
            return new window.SDK.Rect(ak.get(this).$r())
        }
        SetTextureUpdateCallback(t) {
            ak.get(this).ia = t
        }
        ReleaseTexture() {
            ak.get(this).m5i()
        }
        GetTextWidth() {
            return ak.get(this).Gx()
        }
        GetTextHeight() {
            return ak.get(this).jx()
        }
    }
}
{
    const lk = self.t
      , uk = new WeakMap;
    window.SDK.UI.ILayoutView = class {
        constructor(t) {
            lk.U(t, window.y_),
            uk.set(this, t)
        }
        GetProject() {
            return uk.get(this).Cn().jDe()
        }
        GetZoomFactor() {
            return uk.get(this).ra()
        }
        LayoutToClientDeviceX(t) {
            return uk.get(this).OE(t)
        }
        LayoutToClientDeviceY(t) {
            return uk.get(this).CE(t)
        }
        SetDeviceTransform(t) {
            return uk.get(this).nl(window.SDK.Gfx.IWebGLRenderer.Wfi(t))
        }
        SetDefaultTransform(t) {
            return uk.get(this).rl(window.SDK.Gfx.IWebGLRenderer.Wfi(t))
        }
        Refresh() {
            uk.get(this).qM()
        }
        GetLayout() {
            return uk.get(this).td().XDe()
        }
        GetActiveLayer() {
            return uk.get(this).rT().qDe()
        }
    }
}
{
    const ck = self.t;
    new WeakMap;
    window.SDK.UI.Util = class {
        static ShowLongTextPropertyDialog(t, i) {
            const e = ck.Qs.Ks.qs("LongTextPropertyDialog");
            return e.Wa(i),
            e.Xa(t)
        }
        static AddDragDropFileImportHandler(t, i) {
            self.app.bFe(t, i)
        }
    }
}
{
    const dk = self.t
      , fk = self.lang;
    window.vFe = class extends globalThis.NPe {
        constructor(t, i) {
            super(),
            this.Rdi = t.id,
            this.Ftt = t.name,
            this.Wtt = t.version,
            this.FGe = t.author,
            this.NGe = t["icon-type"] || "image/svg+xml",
            this.UGe = "",
            this.SFe = t.website,
            this.LGe = self.app.Ene(t.documentation),
            this.$Oi = t.description,
            this.xFe = t.stylesheets,
            this.dmt = i.source,
            this.Ett = i.files,
            this.MFe = [],
            this.EFe = [],
            this.uke = null,
            this.uOi = null,
            this.cOi = null,
            this.dOi = null,
            "built-in" === this.dmt && dk.q8t() && (this.Ftt = fk(`themes.${this.Rdi}.name`),
            this.$Oi = fk(`themes.${this.Rdi}.description`))
        }
        he() {
            this.Ett = null,
            this.UGe && (URL.revokeObjectURL(this.UGe),
            this.UGe = "");
            for (const t of this.MFe)
                URL.revokeObjectURL(t);
            dk.Io(this.MFe),
            super.he()
        }
        CFe() {
            if (!this.MFe.length)
                for (const t of this.xFe)
                    this.MFe.push(URL.createObjectURL(this.Ett[t]))
        }
        _Fe(t) {
            return new Promise( (i, e) => {
                const s = document.createElement("link");
                s.rel = "stylesheet",
                s.onload = () => i(s),
                s.onerror = e,
                s.href = t,
                s.setAttribute("data-theme", this.Bk()),
                document.head.appendChild(s)
            }
            )
        }
        async _Si() {
            const t = [];
            this.CFe();
            for (const i of this.MFe)
                t.push(this._Fe(i).then(t => this.EFe.push(t)));
            await Promise.all(t),
            dk.Qs.wP.jSi()
        }
        async TFe() {
            const t = [];
            for (let i = 0, e = this.MFe.length; i < e; ++i) {
                const e = this.MFe[i]
                  , s = this.EFe[i];
                t.push(this.IFe(e, s))
            }
            await Promise.all(t),
            dk.Qs.wP.jSi()
        }
        async IFe(t, i) {
            const e = await this._Fe(t);
            dk.Qs.UO(i);
            const s = this.EFe.indexOf(i);
            self.assert(s >= 0, "cannot find stylesheet element"),
            this.EFe[s] = e
        }
        tMi() {
            return this.CFe(),
            this.MFe.slice(0)
        }
        Bk() {
            return this.Rdi
        }
        W7() {
            return "theme"
        }
        La() {
            return this.Ftt
        }
        nse() {
            return this.$Oi
        }
        a6() {
            return this.Wtt
        }
        rse() {
            return this.FGe
        }
        foe() {
            return this.LGe
        }
        Hot() {
            return this.dmt
        }
        $Pe() {
            return !1
        }
        fae() {
            return this.$Pe()
        }
        bre() {
            return !0
        }
        PFe() {
            return "image/svg+xml" === this.FAe() ? "icon.svg" : "icon.png"
        }
        r1i() {
            return this.UGe || (this.UGe = URL.createObjectURL(this.Ett[this.PFe()])),
            this.UGe
        }
        FAe() {
            return this.NGe
        }
        Rke() {
            return "image/svg+xml" === this.FAe()
        }
        kke() {
            !this.uke && this.Rke() && (this.uke = dk.v(dk.Qs.YRi, self.app, this.r1i(), {
                name: "theme-" + this.Bk()
            }))
        }
        uP() {
            return this.uOi || (this.kke(),
            this.uke ? this.uOi = this.uke.uP() : this.uOi = dk.Qs.d0.ski(this.r1i(), self.app.m4(), {
                wd: this.Rke()
            })),
            this.uOi
        }
        M8() {
            return this.cOi || (this.kke(),
            this.uke ? this.cOi = this.uke.M8() : this.cOi = dk.Qs.d0.ski(this.r1i(), self.app.Oq(), {
                wd: this.Rke()
            })),
            this.cOi
        }
        COi() {
            return this.dOi || (this.kke(),
            this.uke ? this.dOi = this.uke.COi() : this.dOi = dk.Qs.d0.ski(this.r1i(), self.app.s8(), {
                wd: this.Rke()
            })),
            this.dOi
        }
        eNi(t) {
            switch (dk.zt(t),
            t) {
            case "small":
                return this.uP();
            case "medium":
                return this.M8();
            case "large":
                return this.COi();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        wOe() {
            return this.Ett._c3addon
        }
        static sDe(t, i) {
            let e = t.La().toLowerCase()
              , s = i.La().toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const pk = self.t
      , mk = self.lang
      , wk = pk.bW(import.meta.url)
      , gk = pk.IW(wk.URL);
    pk.p.MW(gk + "lang");
    const yk = new Set(["start-page-only", "project-file"]);
    window.GFe = class extends globalThis.NPe {
        constructor(t, i) {
            if (super(),
            this.Rdi = t.id,
            this.Ftt = "",
            this.$Oi = "",
            this.Wtt = t.version,
            this.FGe = t.author,
            this.NGe = t["icon-type"] || "image/svg+xml",
            this.UGe = "",
            this.SFe = t.website,
            this.AFe = t["default-ui-layout"] || "games",
            this.RFe = t["example-browser-tags"] || [],
            this.kFe = t["starting-point"],
            !yk.has(this.kFe))
                throw new Error(`addon '${this.Rdi}' specifies invalid starting point '${this.kFe}'`);
            this.OFe = t["starting-project-file"],
            this.$It = i.path,
            this.dmt = i.source,
            this.Ett = i.files;
            const e = t["tour-file-list"];
            if (!Array.isArray(e))
                throw new Error(`addon '${this.Rdi}' missing "tour-file-list" array`);
            for (const t of e) {
                if (this.Ett.hasOwnProperty(t))
                    throw new Error(`addon '${this.Rdi}' "tour-file-list" specifies duplicate filename '${t}'`);
                this.Ett[t] = null
            }
            this.uke = null,
            this.uOi = null,
            this.cOi = null,
            this.dOi = null,
            this.Att = !1,
            this.wTi = !1,
            this.DFe = null,
            this.FFe = 1
        }
        he() {
            this.Ett = null,
            this.UGe && (URL.revokeObjectURL(this.UGe),
            this.UGe = ""),
            super.he()
        }
        bEt() {
            if (this.Att)
                throw new Error("tour already ready");
            pk.p.u(this.LFe()),
            this.Ftt = mk(".name"),
            this.$Oi = mk(".description"),
            pk.p.j(),
            this.Att = !0
        }
        async yrt() {
            if (this.wTi)
                return;
            if (await Promise.all(Object.keys(this.Ett).map(async t => {
                if (this.Ett[t])
                    return;
                if (pk.q8t() && t.endsWith("/en-US.json"))
                    return;
                const i = await pk._4(this.$It + t);
                this.Ett[t] = i
            }
            )),
            pk.q8t() || (pk.bme.BFe(this.Rdi, this.Ett, "tourLang/"),
            await pk.p.yrt()),
            !this.Ett.hasOwnProperty("tour.json"))
                throw new Error(`tour addon '${this.Rdi}' missing tour.json file`);
            const t = (await pk.Qii(this.Ett["tour.json"])).sections;
            if (!Array.isArray(t))
                throw new Error('missing "sections" array in tour addon');
            if (this.DFe = t.map(t => pk.v(self.UFe, this, t)),
            0 === this.DFe.length)
                throw new Error("tour sections array is empty");
            this.wTi = !0
        }
        Bk() {
            return this.Rdi
        }
        W7() {
            return "tour"
        }
        LFe() {
            return `tours.${this.Rdi.toLowerCase()}`
        }
        La() {
            return this.Ftt
        }
        nse() {
            return this.$Oi
        }
        a6() {
            return this.Wtt
        }
        rse() {
            return this.FGe
        }
        NFe() {
            return this.SFe
        }
        jFe() {
            return this.RFe
        }
        $Fe() {
            return this.$It + "thumbnail.webp"
        }
        zFe() {
            return this.kFe
        }
        VFe() {
            if ("project-file" !== this.zFe())
                throw new Error("invalid starting point");
            const t = this.Ett[this.OFe];
            if (!t)
                throw new Error("missing starting project file");
            return t
        }
        Hot() {
            return this.dmt
        }
        WFe() {
            return this.AFe
        }
        $Pe() {
            return !1
        }
        fae() {
            return this.$Pe()
        }
        HFe() {
            return this.FFe++
        }
        KFe() {
            return this.FFe - 1
        }
        qFe() {
            return this.DFe.values()
        }
        *XFe() {
            for (const t of this.qFe())
                yield*t.cVi()
        }
        bre() {
            return !0
        }
        PFe() {
            return "image/svg+xml" === this.FAe() ? "icon.svg" : "icon.png"
        }
        r1i() {
            return this.UGe || (this.UGe = URL.createObjectURL(this.Ett[this.PFe()])),
            this.UGe
        }
        FAe() {
            return this.NGe
        }
        Rke() {
            return "image/svg+xml" === this.FAe()
        }
        kke() {
            !this.uke && this.Rke() && (this.uke = pk.v(pk.Qs.YRi, self.app, this.r1i(), {
                name: "tour-" + this.Bk()
            }))
        }
        uP() {
            return this.uOi || (this.kke(),
            this.uke ? this.uOi = this.uke.uP() : this.uOi = pk.Qs.d0.ski(this.r1i(), self.app.m4(), {
                wd: this.Rke()
            })),
            this.uOi
        }
        M8() {
            return this.cOi || (this.kke(),
            this.uke ? this.cOi = this.uke.M8() : this.cOi = pk.Qs.d0.ski(this.r1i(), self.app.Oq(), {
                wd: this.Rke()
            })),
            this.cOi
        }
        COi() {
            return this.dOi || (this.kke(),
            this.uke ? this.dOi = this.uke.COi() : this.dOi = pk.Qs.d0.ski(this.r1i(), self.app.s8(), {
                wd: this.Rke()
            })),
            this.dOi
        }
        eNi(t) {
            switch (pk.zt(t),
            t) {
            case "small":
                return this.uP();
            case "medium":
                return this.M8();
            case "large":
                return this.COi();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        wOe() {
            return this.Ett._c3addon
        }
        YFe(t) {
            return pk.zt(t),
            this.Ett[t] || null
        }
        static sDe(t, i) {
            let e = t.La().toLowerCase()
              , s = i.La().toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const bk = self.t;
    window.UFe = class extends bk.Me {
        constructor(t, i) {
            if (bk.U(t, self.GFe),
            bk.IL(i),
            super(),
            !Array.isArray(i.steps))
                throw new Error('missing "steps" array in section');
            if (this.JFe = t,
            this.Rdi = i.id,
            this._gi = self.lang(this.LFe() + ".title"),
            this.vWi = i.steps.map(t => self.ZFe.hP(this, t)).flat(),
            0 === this.vWi.length)
                throw new Error("tour section steps array is empty")
        }
        LFe() {
            return `${this.JFe.LFe()}.sections.${this.Rdi}`
        }
        QFe() {
            return this.JFe
        }
        Bk() {
            return this.Rdi
        }
        cVi() {
            return this.vWi.values()
        }
    }
}
{
    const vk = self.t
      , Sk = self.lang;
    window.tLe = class extends vk.Me {
        constructor(t, i) {
            if (super(),
            this.iLe = t,
            this.Rdi = i.id,
            this.eLe = i["analytics-milestone"] || "",
            "string" != typeof this.Rdi)
                throw new Error("tour step missing 'id' property")
        }
        sLe() {
            throw new Error(`invalid tour step '${this.Bk()}' in section '${this.nLe().Bk()}'`)
        }
        nLe() {
            return this.iLe
        }
        QFe() {
            return this.nLe().QFe()
        }
        LFe() {
            return `${this.QFe().LFe()}.steps.${this.Rdi}`
        }
        rLe(t) {
            return Sk(this.LFe() + t)
        }
        hLe(t) {
            const i = this.rLe(t);
            return i === vk.p.tci ? null : i
        }
        oLe(t) {
            const i = this.rLe(t);
            return i === vk.p.tci ? Sk(t) : i
        }
        Bk() {
            return this.Rdi
        }
        aLe() {
            return this.eLe
        }
    }
}
{
    const xk = self.t;
    let Mk = null;
    function Ek() {
        if (!Mk) {
            const t = self.lLe
              , i = self.ZFe;
            Mk = new Map([["show-message", i.uLe], ["click-button", i.cLe], ["select-menu-item", i.dLe], ["create-object-type", i.OL], ["rename-object-type", i.fLe], ["wait-for-place-object", i.pLe], ["import-image", i.mLe], ["modify-image", i.wLe], ["get-to-dialog", i.gLe], ["pick-create-object-type", i.yLe], ["pick-timeline-instance", i.bLe], ["pick-add-behavior", i.vLe], ["pick-event-object", i.SLe], ["pick-event-ac", i.xLe], ["enter-parameter", i.MLe], ["enter-script", i.ELe], ["edit-layout-view", i.CLe], ["wait", i.Jti], ["select-project-bar-item", i._Le], ["change-property", i.Qte], ["create-default-new-project", t.TLe], ["create-singleglobal-object", t.ILe], ["create-object-with-image", t.PLe], ["add-behaviors", t.GLe], ["add-event", t.CKt], ["add-action", t.hQt]])
        }
        return Mk
    }
    window.ZFe = class extends self.tLe {
        constructor(t, i, e={}) {
            if (super(t, i),
            this.ALe = this.QFe().HFe(),
            this.RLe = e.message || this.rLe(".text"),
            this.kLe = i.links || [],
            this.OLe = [],
            this.RLe.includes("[tip")) {
                const t = t => () => this.rLe(`.text-tip${t + 1}`);
                for (let i = 0; i < 9; ++i)
                    this.OLe.push(t(i))
            }
        }
        static hP(t, i) {
            xk.U(t, self.UFe),
            xk.IL(i);
            const e = i["step-type"]
              , s = Ek().get(e);
            if (!s)
                throw new Error(`invalid step-type '${e}'`);
            const n = xk.v(s, t, i);
            return n instanceof self.lLe ? n.DLe() : n
        }
        FLe() {
            xk.kK()
        }
        LLe() {
            return this.ALe
        }
        BLe() {
            return 1 === this.LLe()
        }
        ULe() {
            return this.LLe() === this.QFe().KFe()
        }
        NLe() {
            return xk.v(xk.ix, this.RLe, {
                AU: !0,
                links: this.kLe.map(t => self.app.jLe(t, "GuidedTour-" + this.QFe().Bk(), this.Bk())),
                uai: this.OLe
            })
        }
        $Le() {
            return "string" == typeof this.RLe && this.RLe !== xk.p.tci
        }
        zLe() {
            return !1
        }
    }
}
window.ZFe.uLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.$Le() || this.sLe()
    }
    FLe() {
        return self.VLe.uLe
    }
    zLe() {
        return !0
    }
}
,
window.ZFe.cLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.OFi = i.button,
        this.WLe = !!i["can-skip"],
        this.HLe = i["event-tag"],
        this.KLe = i.menu,
        this.Mri = i.items,
        this.qLe = i["created-event-tag"],
        this.$Le() && "string" == typeof this.OFi || this.sLe()
    }
    XLe() {
        return this.OFi
    }
    YLe() {
        return this.WLe
    }
    JLe() {
        return this.HLe
    }
    ZLe() {
        return this.KLe
    }
    Swt() {
        return this.Mri
    }
    QLe() {
        return this.qLe
    }
    FLe() {
        return self.VLe.cLe
    }
}
;
{
    const Ck = new Set(["layout-view-context-menu", "animations-editor-imagepoints"]);
    window.ZFe.dLe = class extends self.ZFe {
        constructor(t, i, e={}) {
            super(t, i, e),
            this.KLe = i.menu,
            this.Mri = i.items,
            this.$Le() && "string" == typeof this.KLe && Ck.has(this.KLe) && Array.isArray(this.Mri) || this.sLe()
        }
        ZLe() {
            return this.KLe
        }
        Swt() {
            return this.Mri
        }
        FLe() {
            return self.VLe.dLe
        }
    }
}
window.ZFe.OL = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.$Le() || this.sLe()
    }
    FLe() {
        return self.VLe.OL
    }
}
;
{
    const _k = self.t;
    window.ZFe.fLe = class extends self.ZFe {
        constructor(t, i, e={}) {
            super(t, i, e),
            this.tBe = i["object-type-tag"],
            this.iBe = e.eBe || this.rLe(".desired-name"),
            this.$Le() && "string" == typeof this.tBe && this.iBe && this.iBe !== _k.p.tci || this.sLe()
        }
        sBe() {
            return this.tBe
        }
        nBe() {
            return this.iBe
        }
        FLe() {
            return self.VLe.fLe
        }
    }
}
window.ZFe.pLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.rBe = i["instance-tag"],
        this.$Z = 0,
        this.JZ = 0;
        const s = i["initial-size"];
        Array.isArray(s) && (2 !== s.length && this.sLe(),
        this.$Z = s[0],
        this.JZ = s[1]),
        this.$Le() || this.sLe()
    }
    FLe() {
        return self.VLe.pLe
    }
    hBe() {
        return this.rBe
    }
    oBe() {
        return 0 !== this.$Z || 0 !== this.JZ
    }
    aBe() {
        return this.$Z
    }
    lBe() {
        return this.JZ
    }
}
;
{
    const Tk = self.t;
    window.ZFe.mLe = class extends self.ZFe {
        constructor(t, i, e={}) {
            if (super(t, i, e),
            this.Un = i.image,
            this.uBe = i["collision-poly"] || "",
            this.$Le() && "string" == typeof this.Un || this.sLe(),
            this.wki = this.QFe().YFe(this.Un),
            !this.wki)
                throw new Error(`import image step file '${this.Un}' missing`)
        }
        cBe() {
            return Tk.zti(this.Un)
        }
        lS() {
            return this.wki
        }
        _I() {
            return this.uBe
        }
        FLe() {
            return self.VLe.mLe
        }
    }
}
window.ZFe.wLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.$Le() || this.sLe()
    }
    FLe() {
        return self.VLe.wLe
    }
}
;
{
    const Ik = self.t
      , Pk = new Set(["behaviors"]);
    window.ZFe.gLe = class extends self.ZFe {
        constructor(t, i, e={}) {
            super(t, i, e),
            Ik.p.u("tours._common.go-to-dialog.behaviors"),
            this.RLe = e.message || this.oLe(".text"),
            Ik.p.j(),
            this.nbt = i.dialog,
            this.tBe = i["object-type-tag"],
            this.$Le() && "string" == typeof this.nbt && Pk.has(this.nbt) || this.sLe()
        }
        pbt() {
            return this.nbt
        }
        sBe() {
            return this.tBe
        }
        FLe() {
            return self.VLe.gLe
        }
    }
}
window.ZFe.yLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.hi = i.plugin,
        this.tBe = i["object-type-tag"],
        this.dBe = e.fBe || this.hLe(".assign-name"),
        this.$Le() && "string" == typeof this.hi || this.sLe()
    }
    $a() {
        return this.hi
    }
    FLe() {
        return self.VLe.yLe
    }
    sBe() {
        return this.tBe
    }
    pBe() {
        return this.dBe
    }
}
,
window.ZFe.bLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.rBe = i["instance-tag"],
        this.$Le() && "string" == typeof this.rBe || this.sLe()
    }
    hBe() {
        return this.rBe
    }
    FLe() {
        return self.VLe.bLe
    }
}
,
window.ZFe.vLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.xOe = i.behavior,
        this.mBe = i["behavior-type-tag"],
        this.$Le() && "string" == typeof this.xOe || this.sLe()
    }
    FLe() {
        return self.VLe.vLe
    }
    wre() {
        return this.xOe
    }
    wBe() {
        return this.mBe
    }
}
,
window.ZFe.SLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.tBe = i["object-type-tag"],
        this.HLe = i["event-tag"],
        this.$Le() && "string" == typeof this.tBe || this.sLe()
    }
    sBe() {
        return this.tBe
    }
    JLe() {
        return this.HLe
    }
    FLe() {
        return self.VLe.SLe
    }
}
,
window.ZFe.xLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.gBe = i["ac-id"],
        this.$Le() && "string" == typeof this.gBe || this.sLe()
    }
    yBe() {
        return this.gBe
    }
    FLe() {
        return self.VLe.xLe
    }
}
;
{
    const Gk = self.t;
    window.ZFe.MLe = class extends self.ZFe {
        constructor(t, i, e={}) {
            super(t, i, e),
            this.bBe = i["param-id"],
            this.vBe = e.SBe || i["param-value"] || this.rLe(".param-value"),
            this.RLe = e.message || this.hLe(".text") || self.h_("tours._common.enter-parameter.text", this.vBe),
            this.xBe = e.MBe || this.hLe(".text2") || self.lang("tours._common.enter-parameter.pick-object"),
            this.$Le() && "string" == typeof this.bBe && this.vBe && this.vBe !== Gk.p.tci || this.sLe()
        }
        EBe() {
            return this.bBe
        }
        ole() {
            return this.vBe
        }
        FLe() {
            return self.VLe.MLe
        }
        CBe() {
            return Gk.v(Gk.ix, this.xBe, {
                AU: !0
            })
        }
    }
}
self.t;
window.ZFe.ELe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.HLe = i["event-tag"],
        this._Be = null,
        new RegExp(i["script-regex"]),
        i["script-regex"] ? this._Be = new RegExp(i["script-regex"]) : i["space-separated-script-regexes"] && (this._Be = new RegExp(i["space-separated-script-regexes"].join("\\s*"))),
        this.RLe = e.message || this.rLe(".text"),
        this.$Le() && "string" == typeof this.HLe && this._Be || this.sLe()
    }
    JLe() {
        return this.HLe
    }
    TBe() {
        return this._Be
    }
    FLe() {
        return self.VLe.ELe
    }
    zLe() {
        return !0
    }
}
;
window.ZFe.CLe = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.IBe = i["allow-context-menu-items"] || [],
        this.PBe = i["message-position"] || "",
        this.$Le() || this.sLe()
    }
    GBe() {
        return this.IBe
    }
    ABe() {
        return this.PBe
    }
    FLe() {
        return self.VLe.CLe
    }
}
,
window.ZFe.Jti = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.Fe = i.time
    }
    BV() {
        return this.Fe
    }
    FLe() {
        return self.VLe.Jti
    }
}
,
window.ZFe._Le = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.RBe = i["item-tag"],
        this.$Le() && "string" == typeof this.RBe || this.sLe()
    }
    kBe() {
        return this.RBe
    }
    FLe() {
        return self.VLe._Le
    }
}
,
window.ZFe.Qte = class extends self.ZFe {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.OBe = i["show-properties-tag"],
        this.DBe = i["property-id"],
        this.FBe = i["set-value-tag"],
        this.$Le() && "string" == typeof this.DBe || this.sLe()
    }
    LBe() {
        return this.OBe
    }
    BBe() {
        return this.DBe
    }
    UBe() {
        return this.FBe
    }
    FLe() {
        return self.VLe.Qte
    }
}
;
{
    const Ak = self.t;
    window.lLe = class extends self.tLe {
        constructor(t, i) {
            super(t, i),
            this.vWi = [],
            this.NBe = !0
        }
        DLe() {
            return this.vWi
        }
        jBe(t, i, e, s) {
            return this.NBe && (this.NBe = !1,
            e || (e = {}),
            e["analytics-milestone"] = this.aLe()),
            Ak.v(t, this.nLe(), Object.assign({
                id: this.Bk() + i
            }, e), s)
        }
    }
}
{
    const Rk = self.t
      , kk = self.ZFe;
    window.lLe.TLe = class extends self.lLe {
        constructor(t, i) {
            super(t, i),
            Rk.p.u("tours._common.create-default-new-project");
            const e = this.oLe(".start-page-message")
              , s = this.oLe(".create-button-message");
            Rk.p.j(),
            this.vWi = [this.jBe(kk.cLe, "-sp", {
                button: "start-page-new-project"
            }, {
                message: e
            }), this.jBe(kk.cLe, "-create", {
                button: "new-project-dialog-create"
            }, {
                message: s
            })]
        }
    }
}
{
    const Ok = self.t
      , Dk = self.ZFe;
    window.lLe.ILe = class extends self.lLe {
        constructor(t, i) {
            super(t, i);
            const e = i.plugin;
            "string" != typeof e && this.sLe();
            const s = i["object-type-tag"];
            Ok.p.u("tours._common.create-object-with-image");
            const n = this.oLe(".create-message")
              , r = this.oLe(".pick-message");
            Ok.p.j();
            const h = this.hLe(".assign-name")
              , o = this.hLe(".desired-name");
            this.vWi = [this.jBe(Dk.OL, "-create", null, {
                message: n
            }), this.jBe(Dk.yLe, "-pick", {
                plugin: e,
                "object-type-tag": s
            }, {
                message: r,
                fBe: h
            })],
            o && this.vWi.push(this.jBe(Dk.fLe, "-rename", {
                "object-type-tag": s
            }, {
                message: this.rLe(".rename-message"),
                eBe: o
            }))
        }
    }
}
{
    const Fk = self.t
      , Lk = self.ZFe;
    window.lLe.PLe = class extends self.lLe {
        constructor(t, i) {
            super(t, i);
            const e = i.plugin
              , s = i.image;
            "string" == typeof e && "string" == typeof s || this.sLe();
            const n = i["object-type-tag"]
              , r = i["instance-tag"]
              , h = i["initial-size"];
            Fk.p.u("tours._common.create-object-with-image");
            const o = this.oLe(".create-message")
              , a = this.oLe(".pick-message")
              , l = this.oLe(".place-message")
              , u = this.oLe(".import-image-message")
              , c = this.oLe(".close-message");
            Fk.p.j();
            const d = this.hLe(".assign-name")
              , f = this.hLe(".desired-name");
            this.vWi = [this.jBe(Lk.OL, "-create", null, {
                message: o
            }), this.jBe(Lk.yLe, "-pick", {
                plugin: e,
                "object-type-tag": n
            }, {
                message: a,
                fBe: d
            }), this.jBe(Lk.pLe, "-place", {
                "instance-tag": r,
                "initial-size": h
            }, {
                message: l
            }), this.jBe(Lk.mLe, "-import-image", {
                image: s
            }, {
                message: u
            }), this.jBe(Lk.cLe, "-close", {
                button: "animations-editor-close"
            }, {
                message: c
            })],
            f && this.vWi.push(this.jBe(Lk.fLe, "-rename", {
                "object-type-tag": n
            }, {
                message: this.rLe(".rename-message"),
                eBe: f
            }))
        }
    }
}
{
    const Bk = self.t
      , Uk = self.ZFe;
    window.lLe.GLe = class extends self.lLe {
        constructor(t, i) {
            super(t, i);
            const e = i["object-type-tag"]
              , s = i.behaviors;
            "string" == typeof e && Array.isArray(s) || this.sLe(),
            Bk.p.u("tours._common.add-behaviors");
            const n = this.oLe(".add-edit-behaviors")
              , r = this.oLe(".add-button-first")
              , h = this.oLe(".add-button-next")
              , o = this.oLe(".close-behaviors-dialog");
            Bk.p.j(),
            this.vWi = [this.jBe(Uk.gLe, "-getto", {
                dialog: "behaviors",
                "object-type-tag": e
            }, {
                message: n
            })];
            let a = 0;
            for (const t of s) {
                const i = t.behavior
                  , e = t["behavior-type-tag"];
                "string" != typeof i && this.sLe(),
                this.vWi.push(this.jBe(Uk.cLe, "-add", {
                    button: "behaviors-dialog-add"
                }, {
                    message: 0 === a ? r : h
                })),
                this.vWi.push(this.jBe(Uk.vLe, "-pick", {
                    behavior: i,
                    "behavior-type-tag": e
                }, {
                    message: this.rLe(`.pick-behavior-${a}`)
                })),
                ++a
            }
            this.vWi.push(this.jBe(Uk.cLe, "-close", {
                button: "behaviors-dialog-close"
            }, {
                message: o
            }))
        }
    }
}
{
    const Nk = self.t
      , jk = self.ZFe;
    window.lLe.CKt = class extends self.lLe {
        constructor(t, i) {
            super(t, i);
            const e = i["event-tag"]
              , s = i["object-type-tag"]
              , n = i["ac-id"]
              , r = i.params;
            "string" == typeof s && "string" == typeof n || this.sLe(),
            Nk.p.u("tours._common.add-event");
            const h = this.oLe(".click-add-link")
              , o = this.oLe(".pick-object")
              , a = this.oLe(".pick-condition")
              , l = this.oLe(".params-done");
            if (Nk.p.j(),
            this.vWi = [this.jBe(jk.cLe, "-add", {
                button: "event-sheet-add-event-link"
            }, {
                message: h
            }), this.jBe(jk.SLe, "-object", {
                "object-type-tag": s,
                "event-tag": e
            }, {
                message: o
            }), this.jBe(jk.xLe, "-condition", {
                "ac-id": n
            }, {
                message: a
            })],
            Array.isArray(r) && r.length > 0)
                for (const t of r) {
                    const i = t.id;
                    "string" != typeof i && this.sLe(),
                    this.vWi.push(this.jBe(jk.MLe, "-param-" + i, {
                        "param-id": i
                    }, {
                        SBe: t.value || this.rLe(`.${i}-value`),
                        message: this.hLe(`.${i}-text`),
                        MBe: this.hLe(`.${i}-text2`)
                    }))
                }
            this.vWi.push(this.jBe(jk.cLe, "-done", {
                button: "parameters-dialog-done",
                "can-skip": !0
            }, {
                message: l
            }))
        }
    }
}
{
    const $k = self.t
      , zk = self.ZFe;
    window.lLe.hQt = class extends self.lLe {
        constructor(t, i) {
            super(t, i);
            const e = i["event-tag"]
              , s = i["object-type-tag"]
              , n = i["ac-id"]
              , r = i.params;
            "string" == typeof e && "string" == typeof s && "string" == typeof n || this.sLe(),
            $k.p.u("tours._common.add-action");
            const h = this.oLe(".click-add-link")
              , o = this.oLe(".pick-object")
              , a = this.oLe(".pick-action")
              , l = this.oLe(".params-done");
            if ($k.p.j(),
            this.vWi = [this.jBe(zk.cLe, "-add", {
                button: "add-action-link",
                "event-tag": e
            }, {
                message: h
            }), this.jBe(zk.SLe, "-object", {
                "object-type-tag": s
            }, {
                message: o
            }), this.jBe(zk.xLe, "-action", {
                "ac-id": n
            }, {
                message: a
            })],
            Array.isArray(r) && r.length > 0)
                for (const t of r) {
                    const i = t.id;
                    "string" != typeof i && this.sLe(),
                    this.vWi.push(this.jBe(zk.MLe, "-param-" + i, {
                        "param-id": i
                    }, {
                        SBe: t.value || this.rLe(`.${i}-value`),
                        message: this.hLe(`.${i}-text`),
                        MBe: this.hLe(`.${i}-text2`)
                    }))
                }
            this.vWi.push(this.jBe(zk.cLe, "-done", {
                button: "parameters-dialog-done",
                "can-skip": !0
            }, {
                message: l
            }))
        }
    }
}
{
    const Vk = self.t
      , Wk = self.lang
      , Hk = self.Xke
      , Kk = self.sOe
      , qk = self.DOe
      , Xk = self.FOe
      , Yk = self.SW
      , Jk = "c3-addon-files"
      , Zk = "c3-addon-list"
      , Qk = "c3-dev-addon-list"
      , tO = "c3-remembered-addons"
      , iO = new Set(["plugin", "behavior", "effect", "theme", "tour"])
      , eO = new Set(["plugin", "behavior"])
      , sO = new Set(["conditions", "actions", "expressions"])
      , nO = {
        plugin: "plugins/",
        behavior: "behaviors/"
    }
      , rO = {
        plugin: ["plugin.js", "type.js", "instance.js"],
        behavior: ["behavior.js", "type.js", "instance.js"]
    }
      , hO = {
        plugin: {
            "built-in": Hk,
            addon: Kk,
            project: Kk,
            dev: Kk
        },
        behavior: {
            "built-in": qk,
            addon: Xk,
            project: Xk,
            dev: Xk
        },
        effect: {
            "built-in": Yk,
            addon: Yk,
            project: Yk,
            dev: Yk
        }
    };
    class oO extends Vk.Event.v_ {
        constructor() {
            super(),
            this.rOi = null,
            this.$Be = !1,
            this.zBe = null,
            this.VBe = null,
            this.WBe = null,
            this.HBe = null,
            this.KBe = null,
            this.qBe = {
                plugin: new Map,
                behavior: new Map,
                effect: new Map,
                theme: new Map,
                tour: new Map
            },
            this.XBe = new Map,
            this.YBe = null,
            this.JBe = 0,
            this.ZBe = 0
        }
        QBe() {
            return this.$Be
        }
        mDe(t, i) {
            const e = {
                uMi: null,
                source: "built-in",
                path: null,
                M: i,
                tUe: null,
                mke: null,
                files: null
            };
            this.qBe.effect.set(t, e)
        }
        async iUe(t) {
            this.rOi = t,
            this.$Be = "animation" !== t.bne() && Vk.S9t.y9t("safe-mode"),
            await Promise.all([this.eUe(), this.sUe("theme")]),
            await Vk.p.yrt()
        }
        async nUe() {
            await Promise.all([this.rUe(), this.sUe("tour")])
        }
        hUe() {
            for (const t of this.qBe.tour.values())
                t.M && t.M.bEt()
        }
        async yrt() {
            let t;
            t = Vk.q8t() ? this.oUe() : this.aUe(),
            await Promise.all([t, this.lUe()]),
            this.uUe()
        }
        aUe() {
            return Promise.all([this.cUe("plugin"), this.cUe("behavior")])
        }
        async cUe(t) {
            const i = (await Vk.O4(nO[t] + t + "List.json"))[t + "List"]
              , e = [];
            for (const [s,n] of Object.entries(i)) {
                const i = n.productTypes || "all";
                self.app.CGe(i) && e.push(this.dUe(t, n, s, "dev"))
            }
            return Promise.all(e)
        }
        oUe() {
            return Promise.all([this.fUe("plugin"), this.fUe("behavior")])
        }
        async fUe(t) {
            const i = nO[t]
              , e = Vk.O4(i + "allAces.json")
              , s = Vk.O4(i + "allSvgIcons.json")
              , n = Vk.O4(i + t + "List.json")
              , r = i + "allEditor" + ("plugin" === t ? "Plugins" : "Behaviors") + ".js";
            await Vk.DYt(r);
            const h = (await n)[t + "List"]
              , o = [];
            for (const [i,e] of Object.entries(h)) {
                const s = e.productTypes || "all";
                self.app.CGe(s) && o.push(this.dUe(t, e, i, "release"))
            }
            await Promise.all(o);
            const a = await e;
            for (const [i,e] of Object.entries(a))
                this.qBe[t].get(i).tUe = e;
            const l = await s;
            for (const [i,e] of Object.entries(l))
                this.qBe[t].get(i).mke = e
        }
        async dUe(t, i, e, s) {
            const n = nO[t] + i.path + "/";
            Vk.p.MW(n + "lang");
            let r = {
                uMi: null,
                source: "built-in",
                path: n,
                M: null,
                tUe: null,
                mke: null,
                files: null
            };
            if (this.qBe[t].set(e, r),
            "dev" === s) {
                const e = [];
                e.push(Vk.O4(n + "aces.json").then(t => r.tUe = t));
                const s = i.editorScripts || rO[t];
                for (const t of s)
                    e.push(Vk.DYt(n + t));
                await Promise.all(e)
            }
            this.ZBe++
        }
        async lUe() {
            self.app.Bme() && (await Promise.all([this.sUe("plugin"), this.sUe("behavior"), this.sUe("effect")]),
            await Vk.p.yrt())
        }
        sUe(t) {
            const i = this.pUe(t).then(i => Promise.all(i.map(i => this.mUe(t, i))))
              , e = this.wUe(t).then(i => Promise.all(Object.entries(i).map(i => this.gUe(t, i[0], i[1]))));
            return Promise.all([i, e])
        }
        async eUe() {
            const t = await fetch(Vk.Vgt() + "theme/defaultThemeList.json");
            if (!t.ok)
                throw new Error("unable to load theme list");
            const i = (await t.json()).themes;
            return Promise.all(i.map(t => this.yUe(t)))
        }
        yUe(t) {
            return Vk.zt(t),
            this.gUe("theme", t, Vk.Vgt() + "theme/" + t + "/addon.json", !0)
        }
        async rUe() {
            const t = await fetch(Vk.Vgt() + "tours/defaultToursList.json");
            if (!t.ok)
                throw new Error("unable to load tours list");
            const i = (await t.json()).tours
              , e = [];
            for (const [t,s] of Object.entries(i)) {
                const i = s.productTypes || "all";
                self.app.CGe(i) && e.push(this.bUe(t))
            }
            await Promise.all(e)
        }
        bUe(t) {
            return Vk.zt(t),
            this.gUe("tour", t, Vk.Vgt() + "tours/" + t + "/addon.json", !0)
        }
        async mUe(t, i, e, s) {
            Vk.zt(t),
            Vk.zt(i);
            let n = null;
            if (e ? (n = this.XBe.get(e),
            n || (n = {
                plugin: new Map,
                behavior: new Map,
                effect: new Map
            },
            this.XBe.set(e, n))) : n = this.qBe,
            n[t].has(i))
                throw new Error(`duplicate addon id '${i}'`);
            const r = e ? Promise.resolve(s) : Vk.bme.vUe(t, i)
              , h = await r;
            if (!h)
                return void console.error(`[Addons] Missing addon file for ${t} '${i}' - addon not loaded. Try reinstalling the addon.`);
            const o = await Vk.Qii(h["addon.json"])
              , a = o["sdk-version"] ?? 1;
            if (("effect" === t || a >= 2) && o.hasOwnProperty("min-construct-version")) {
                const t = Vk.pPe(o["min-construct-version"]);
                if (t > Vk.dQ.BIe)
                    return void console.error(`[Addons] Addon '${i}' cannot be loaded in this version of Construct. The addon specifies a minimum Construct version of ${Vk.dPe(t)}, and you are currently using ${Vk.dQ.mPe}.`)
            }
            const l = {
                uMi: null,
                source: e ? "project" : "addon",
                path: null,
                M: null,
                nOe: o,
                tUe: null,
                mke: null,
                files: h,
                Iw: e || null
            };
            n[t].set(i, l),
            this.JBe++,
            await this.SUe(t, l, this.$Be),
            this.ZBe++
        }
        async gUe(t, i, e, s) {
            Vk.zt(t),
            Vk.zt(i),
            Vk.zt(e);
            const n = Vk.IW(e)
              , r = this.qBe;
            if (r[t].has(i))
                throw new Error(`duplicate addon id '${i}'`);
            const h = await Vk.O4(e)
              , o = h["sdk-version"] ?? 1;
            if (("effect" === t || o >= 2) && h.hasOwnProperty("min-construct-version")) {
                const t = Vk.pPe(h["min-construct-version"]);
                if (t > Vk.dQ.BIe)
                    return void console.error(`[Addons] Addon '${i}' cannot be loaded in this version of Construct. The addon specifies a minimum Construct version of ${Vk.dPe(t)}, and you are currently using ${Vk.dQ.mPe}.`)
            }
            const a = {
                uMi: null,
                source: s ? "built-in" : "dev",
                path: n,
                M: null,
                nOe: h,
                tUe: null,
                mke: null,
                files: {},
                lOe: {},
                Iw: null
            };
            if (r[t].set(i, a),
            this.JBe++,
            h.id !== i)
                throw new Error(`addon.json specifies id '${h.id}' but expected id '${i}'; uninstall addons before changing the id`);
            if (!h.hasOwnProperty("file-list"))
                throw new Error(`developer addon '${i}' is missing 'file-list' in addon.json - check the SDK documentation`);
            await Promise.all(h["file-list"].map(async i => {
                if ("tour" === t && Vk.q8t() && i.endsWith("/en-US.json"))
                    return;
                const e = await Vk._4(n + i);
                a.files[i] = e,
                a.lOe[i] = n + i
            }
            )),
            await this.SUe(t, a, s && Vk.p.Eui() || this.$Be),
            s || console.log(`[Addons] Loaded developer ${t} '${i}' from ${e}`),
            this.ZBe++
        }
        SUe(t, i, e) {
            const s = []
              , n = i.nOe
              , r = n.id;
            if ("theme" === t)
                i.M = Vk.v(self.vFe, n, i);
            else if ("tour" === t)
                try {
                    i.M = Vk.v(self.GFe, n, i)
                } catch (t) {
                    console.error(`Error loading guided tour addon '${r}': `, t),
                    i.M = null
                }
            else if ("effect" === t) {
                if (!this.$Be) {
                    if (!i.files["addon.json"])
                        throw new Error("effect addon missing file: addon.json");
                    s.push((async () => {
                        const t = await Vk.Qii(i.files["addon.json"])
                          , e = t["supported-renderers"]
                          , s = !e || e.includes("webgl")
                          , n = e && e.includes("webgl2")
                          , r = e && e.includes("webgpu");
                        if (s && !i.files["effect.fx"])
                            throw new Error("effect addon missing file: effect.fx");
                        if (n && !i.files["effect.webgl2.fx"])
                            throw new Error("effect addon missing file: effect.webgl2.fx");
                        if (r && !i.files["effect.wgsl"])
                            throw new Error("effect addon missing file: effect.wgsl");
                        let h = ""
                          , o = ""
                          , a = "";
                        s && (h = await Vk.Ist(i.files["effect.fx"])),
                        n && (o = await Vk.Ist(i.files["effect.webgl2.fx"])),
                        r && (a = await Vk.Ist(i.files["effect.wgsl"])),
                        i.M = Vk.v(self.SW, "", t, h, o, a, i)
                    }
                    )())
                }
            } else if (!this.$Be) {
                const e = n["editor-scripts"];
                for (const n of e) {
                    if (!i.files.hasOwnProperty(n))
                        throw new Error(`cannot find addon '${r}' "editor-scripts" file '${n}'`);
                    const e = URL.createObjectURL(i.files[n]);
                    s.push(Vk.DYt(e).then(i => i.setAttribute("data-comment", t + "-" + r)))
                }
                if (!i.files["aces.json"])
                    throw new Error("addon missing file: aces.json");
                s.push(Vk.Qii(i.files["aces.json"]).then(t => i.tUe = t))
            }
            return e || this.BFe(r, i.files, "lang/"),
            Promise.all(s)
        }
        BFe(t, i, e) {
            const s = `${e}en-US.json`;
            if (!i.hasOwnProperty(s))
                throw new Error(`cannot find required en-US.json language file in addon '${t}'`);
            const n = URL.createObjectURL(i[s]);
            Vk.p.Pui(n);
            const r = self.app.X7();
            if ("en-US" !== r) {
                const t = `${e}${r}.json`;
                if (i.hasOwnProperty(t)) {
                    const e = URL.createObjectURL(i[t]);
                    Vk.p.Gui(e)
                }
            }
        }
        xUe(t) {
            Vk.Ef(t, self.jw),
            this.YBe = t
        }
        yOe(t, i, e) {
            let s;
            if (Vk.zt(i),
            Vk.nu(e),
            s = this.YBe ? this.XBe.get(this.YBe)[t].get(i) : this.qBe[t].get(i),
            !s)
                throw new Error(`Failed to register addon ID '${i}' because no addon with that ID is loaded. It may have previously been installed with a different ID, or the ID in plugin.js may not match the one specified in addon.json. Uninstall addons before changing their ID. Loaded addon IDs are: ${[...this.qBe[t].keys()].join(", ")}`);
            if (s.uMi)
                throw new Error(`already registered addon id '${i}'`);
            if (s.uMi = e,
            !this.$Be && !s.tUe)
                throw new Error(`addon '${i}' missing aces.json`)
        }
        MUe() {
            const t = new Set;
            for (const i of eO)
                for (const [e,s] of this.qBe[i])
                    s.uMi || (t.add(e),
                    this.qBe[i].delete(e));
            if (t.size) {
                const i = [...t];
                let e;
                e = i.length > 10 ? i.slice(0, 10).join(", ") + "... (" + (i.length - 10) + " more)" : i.join(", "),
                self.app.XGi("AddonsFailedLoad", e);
                Vk.Qs.Ks.qs("OK").Xa(new Vk.ix(self.h_("ui.errors.failed-to-load-addons", e),{
                    AU: !0
                }))
            }
        }
        wDe() {
            return this.ZBe
        }
        gDe() {
            return this.JBe
        }
        EUe(t, i, e) {
            let s;
            if (Vk.zt(t),
            Vk.zt(i),
            e) {
                const n = this.XBe.get(e);
                n && (s = n[t].get(i))
            }
            if (s || (s = this.qBe[t].get(i)),
            !s)
                return null;
            if ("effect" !== t && !s.M && (!this.$Be || "addon" !== s.source && "dev" !== s.source)) {
                const e = Vk.v(hO[t][s.source], Vk.v(s.uMi), s);
                try {
                    e.wke(s.tUe)
                } catch (e) {
                    console.error(`[Construct] Error loading addon '${i}': `, e),
                    this.qBe[t].delete(i)
                }
                s.M = e
            }
            return s
        }
        ed(t, i, e) {
            const s = this.EUe(t, i, e);
            if (!s)
                throw new Error(`cannot find ${t} with id '${i}'`);
            return s.M
        }
        bOe(t, i, e) {
            return !!this.EUe(t, i, e)
        }
        vOe(t, i) {
            Vk.zt(t);
            let e = [];
            if (i) {
                if (this.XBe.get(i))
                    for (const s of this.qBe[t].keys())
                        e.push(Vk.lre( () => this.EUe(t, s, i)))
            }
            for (const i of this.qBe[t].keys())
                e.push(Vk.lre( () => this.EUe(t, i, null)));
            return Promise.all(e)
        }
        async CUe(t, i) {
            return await Vk.lre( () => this.EUe(t, i).M)
        }
        *addons(t, i, e) {
            Vk.zt(t);
            const s = new Set;
            if (i) {
                const e = this.XBe.get(i);
                if (e)
                    for (const i of e[t].values()) {
                        const t = i.M;
                        if (!t)
                            throw new Error("must load all addons before iterating");
                        t.fae() || (s.add(t.Bk()),
                        yield t)
                    }
            }
            for (const [i,n] of this.qBe[t].entries()) {
                const r = n.M;
                if (!r) {
                    if (this.$Be) {
                        e && (yield{
                            _Ue: t,
                            qke: i,
                            TUe: n.nOe["sdk-version"] ?? 1,
                            source: n.source
                        });
                        continue
                    }
                    if ("tour" === t)
                        continue;
                    throw new Error("must load all addons before iterating")
                }
                !e && r.fae() || s.has(r.Bk()) || self.app.HA() && !r.bre() || (yield r)
            }
        }
        *IUe(t) {
            Vk.zt(t);
            for (const [i,e] of this.qBe[t].entries())
                "addon" === e.source && (yield i)
        }
        yDe() {
            for (const t of this.qBe.effect.values())
                t.M && t.M.bEt()
        }
        PUe() {
            return this.zBe ? Promise.resolve(this.zBe) : (this.WBe || (this.WBe = Promise.all([localforage.getItem(Zk), localforage.getItem(Qk)]).then(t => (this.zBe = t[0],
            this.VBe = t[1],
            this.WBe = null,
            this.zBe))),
            this.WBe)
        }
        async pUe(t) {
            Vk.zt(t);
            const i = await this.PUe();
            return i && i[t] ? i[t] : []
        }
        async wUe(t) {
            return Vk.zt(t),
            await this.PUe(),
            this.VBe && this.VBe[t] ? this.VBe[t] : {}
        }
        GUe() {
            return this.HBe || (this.HBe = localforage.foi({
                name: Jk
            })),
            this.HBe
        }
        vUe(t, i) {
            return this.GUe().getItem(t + "-" + i)
        }
        AUe(t) {
            if (!0 !== t["is-c3-addon"])
                throw new Error("not a C3 addon");
            if (!iO.has(t.type))
                throw new Error("invalid addon type");
            if (!(t.name && t.id && t.version && t.author && t.website && t.documentation && t.description))
                throw new Error("invalid addon json")
        }
        async RUe(t, i, e, s=!1, n=!1) {
            Vk.U(t, Blob),
            Vk.Ef(i, self.jw),
            Vk.mGt(e);
            const r = !!i
              , h = new Vk.u7;
            try {
                await h._ct(t);
                const o = h.Ict("addon.json");
                if (!o)
                    throw new Error("missing addon.json");
                const a = await h.fbi(o);
                this.AUe(a);
                const l = a.id
                  , u = a.type
                  , c = a["sdk-version"] ?? 1;
                if (s && ("plugin" === u || "behavior" === u) && c < 2)
                    return !1;
                if (("effect" === u || c >= 2) && a.hasOwnProperty("min-construct-version")) {
                    const t = Vk.pPe(a["min-construct-version"]);
                    if (t > Vk.dQ.BIe) {
                        const i = new Error("min-version");
                        throw i.kUe = t,
                        i
                    }
                }
                if (!r && this.bOe(u, l)) {
                    if (!n) {
                        const t = Vk.Qs.Ks.qs("Confirm")
                          , i = this.qBe[u].get(l).M
                          , e = i ? i.a6() : "(unknown)"
                          , s = a.version;
                        Vk.p.u("ui.update-addon-prompt");
                        const n = t.Xa({
                            caption: Wk(".caption"),
                            message: self.e_(".message", e, s),
                            _nt: Wk(".update"),
                            bnt: Wk("common.cancel")
                        });
                        Vk.p.j();
                        if (null === await n)
                            return
                    }
                    await this.OUe(u, l, "addon")
                }
                let d = !1;
                r && (d = await this.DUe(t));
                let f = null;
                if (d || n)
                    f = "allowed";
                else {
                    const t = Vk.Qs.Ks.qs("AddonConfirmInstall");
                    f = await t.Xa(a, r, e)
                }
                if (null === f) {
                    if (r)
                        throw new Error("addon install failed");
                    return !1
                }
                if ("remember" === f)
                    try {
                        await this.FUe(t)
                    } catch (t) {
                        console.error("Error remembering addon: ", t)
                    }
                let p = t;
                r && Vk.ptt(t) && (p = await Vk.qii(t));
                const m = {
                    _c3addon: p
                }
                  , w = [];
                for (const t of h.abi())
                    w.push(h.Gct(t).then(i => m[t.filename] = i));
                if (await Promise.all(w),
                r)
                    return await this.mUe(u, l, i, m),
                    !0;
                {
                    const t = this.GUe();
                    try {
                        await t.setItem(u + "-" + l, m);
                        let i = await localforage.getItem(Zk);
                        return i ? (i.theme || (i.theme = []),
                        i.tour || (i.tour = [])) : i = {
                            plugin: [],
                            behavior: [],
                            effect: [],
                            theme: [],
                            tour: []
                        },
                        i[u].includes(l) ? !1 : (i[u].push(l),
                        await localforage.setItem(Zk, i),
                        !0)
                    } catch (t) {
                        return self.app._we(t),
                        !1
                    }
                }
            } finally {
                h.Sct()
            }
        }
        async LUe(t, i, e) {
            if (Vk.zt(t),
            Vk.IL(i),
            Vk.mGt(e),
            !self.app.Tme())
                throw new Error("developer mode not enabled");
            const s = i.id
              , n = i.type
              , r = i["sdk-version"] ?? 1;
            if (this.bOe(n, s))
                throw new Error(`addon id '${s}' already installed`);
            if (("effect" === n || r >= 2) && i.hasOwnProperty("min-construct-version")) {
                const t = Vk.pPe(i["min-construct-version"]);
                if (t > Vk.dQ.BIe) {
                    console.error(`[Construct] Cannot install dev mode addon: the minimum Construct version required is ${Vk.dPe(t)}, and you are currently using ${Vk.dQ.mPe}.`);
                    const i = new Error("min-version");
                    throw i.kUe = t,
                    i
                }
            }
            if (("plugin" === n || "behavior" === n) && r < 2) {
                const t = Vk.Qs.Ks.qs("OK");
                await t.Xa(Vk.v(Vk.ix, "This addon is a plugin or behavior using the Addon SDK v1. Support for this will be removed in future. Please consider updating to the Addon SDK v2. [a1]Learn more[/a1]", {
                    links: ["https://www.construct.net/en/forum/construct-3/plugin-sdk-10/addon-sdk-v2-182122"]
                }))
            }
            let h = await localforage.getItem(Qk);
            if (h || (h = {}),
            h[n] || (h[n] = {}),
            h[n].hasOwnProperty(s))
                throw new Error(`dev addon '${s}' already installed; uninstall it first to reinstall`);
            h[n][s] = t;
            try {
                await localforage.setItem(Qk, h)
            } catch (t) {
                self.app._we(t)
            }
        }
        OUe(t, i, e) {
            return "dev" === e ? this.BUe(t, i) : this.UUe(t, i)
        }
        async UUe(t, i) {
            const e = this.GUe();
            try {
                await e.removeItem(t + "-" + i)
            } catch (t) {
                (() => {})("Error removing addon files: ", t)
            }
            const s = await localforage.getItem(Zk);
            if (s) {
                Vk.sii(s[t], i);
                try {
                    await localforage.setItem(Zk, s)
                } catch (t) {
                    self.app._we(t)
                }
            }
        }
        async BUe(t, i) {
            const e = await localforage.getItem(Qk);
            if (!e || !e[t])
                return;
            delete e[t][i];
            try {
                await localforage.setItem(Qk, e)
            } catch (t) {
                self.app._we(t)
            }
        }
        NUe(t) {
            const i = this.XBe.get(t);
            i && (this.jUe(i.plugin),
            this.jUe(i.behavior),
            this.jUe(i.effect),
            this.XBe.delete(t))
        }
        jUe(t) {
            for (const i of t.values())
                i.M && i.M.he();
            t.clear()
        }
        async FUe(t) {
            const i = await Vk.zii(t)
              , e = await Vk.Crypto.Xni(i);
            let s = await localforage.getItem(tO);
            s || (s = []),
            s.includes(e) || (s.push(e),
            await localforage.setItem(tO, s))
        }
        async DUe(t) {
            const i = await Vk.zii(t)
              , e = await Vk.Crypto.Xni(i);
            let s = await localforage.getItem(tO);
            return !!s && s.includes(e)
        }
        $Ue(t) {
            Vk.U(t, self.jw);
            const i = this.XBe.get(t);
            if (i)
                for (const t of i.effect.values())
                    t.M.bEt()
        }
        async zUe() {
            Vk.lU("PreParseACDisplayTexts"),
            await Promise.all([this.VUe("plugin"), this.VUe("behavior")]),
            Vk.OU("PreParseACDisplayTexts")
        }
        VUe(t) {
            Vk.zt(t);
            const i = [];
            for (const e of this.qBe[t].values())
                this.$Be && !e.M || (self.assert(e.M, "expected addon instance to be created by now"),
                i.push(Vk.lre( () => this.WUe(e.M))));
            return Promise.all(i)
        }
        WUe(t) {
            return Promise.all([...t.M4t(), ...t.actions()].map(t => Vk.lre( () => t.HUe())))
        }
        async KUe() {
            const t = self.app.aU().theme;
            t && this.bOe("theme", t) && (this.KBe = this.ed("theme", t),
            await this.KBe._Si())
        }
        async qUe() {
            const t = self.app.aU().theme;
            t && this.bOe("theme", t) && (this.KBe = this.ed("theme", t),
            await this.KBe.TFe(),
            await self.app.e1i())
        }
        Qxi() {
            return this.KBe
        }
        XUe(t) {
            return iO.has(t)
        }
        uUe() {
            self.C3SDK_ListAddonIDs = t => {
                this.YUe(t)
            }
            ,
            self.C3SDK_ListACEIDs = (t, i, e) => {
                this.JUe(t, i, e)
            }
        }
        async YUe(t) {
            if (iO.has(t)) {
                await this.vOe(t),
                console.log(`[SDK] Listing all installed ${t} IDs:`);
                for (const i of this.addons(t))
                    console.log(`"${i.Bk()}" (${i.La()})`)
            } else
                (() => {})(`Invalid addon type: passed '${t}', must be one of: ${[...iO].join(",")}`)
        }
        async JUe(t, i, e) {
            if (!eO.has(t))
                return void (() => {})(`Invalid addon type: passed '${t}', must be one of: ${[...eO].join(",")}`);
            if ("string" != typeof i)
                return void (() => {})(`Invalid addon ID: expected string, got '${typeof i}'`);
            if (!this.bOe(t, i))
                return void (() => {})(`No '${t}' with ID '${i}' found`);
            if (!sO.has(e))
                return void (() => {})(`Invalid ACE type: passed '${e}', must be one of: ${[...sO].join(",")}`);
            const s = this.ed(t, i);
            for (const t of s.zke(e)) {
                let i;
                i = t instanceof self.ZUe ? t.QUe() : t.tNe();
                let e = `"${t.Bk()}" (${i})`;
                if (t.iNe()) {
                    e += " - params: ";
                    const i = [];
                    for (let e = 0, s = t.VBt(); e < s; ++e) {
                        const s = t.qBt(e);
                        i.push(`${s.Bk()} (${s.W7()})`)
                    }
                    console.log(e, i)
                } else
                    console.log(e)
            }
        }
    }
    Vk.bme = Vk.v(oO)
}
{
    const aO = self.t
      , lO = self.lang
      , uO = self.h_
      , cO = aO.bW(import.meta.url)
      , dO = cO.getElementById("aboutDialog")
      , fO = aO.IW(cO.URL);
    aO.p.MW(fO + "lang");
    const pO = "About"
      , mO = aO.Qs.Fk.eNe = class extends aO.Qs.Ks {
        constructor() {
            super(dO),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.sNe = this.Pet("localStorageQuota"),
            this.nNe = this.Pet("localStoragePersistent"),
            this.rNe = this.Pet("requestPersistentStorage"),
            this.rNe.onclick = () => this.hNe(),
            this.Pet("viewReleaseNotes").onclick = () => self.app.pQ(aO.dQ.URL.zIe + aO.dQ.URL.YIe + aO.dQ.wPe, "ReleaseNotes"),
            this.Pet("viewAccountInfo").onclick = function() {
                aO.Qs.Ks.qs("AccountInfo").Xa(self.app.uq("useraccount"))
            }
            ,
            this.Pet("aboutShowPlatformInfo").onclick = function() {
                aO.Qs.Ks.qs("PlatformInfo").Xa()
            }
            ,
            this.Pet("aboutShowLegalInfo").onclick = function() {
                aO.Qs.Ks.qs("LegalInfo").Xa()
            }
            ,
            this.Pet("aboutShowLicenseAgreement").onclick = function() {
                aO.Qs.Ks.qs("EULA").Xa()
            }
            ,
            this.Pet("aboutShowBundledGameLicense").onclick = function() {
                aO.Qs.Ks.qs("BundledContentLicense").Xa()
            }
            ,
            this.Pet("privacyPolicy").onclick = function() {
                aO.Qs.Ks.qs("PrivacyPolicy").Xa()
            }
            ;
            const t = aO.Qs.wP.Ibi()
              , i = this.Pet("aboutDialogC3logo");
            let e = "";
            "animation" === self.app.bne() ? (i.classList.add("animation"),
            e = t ? "loader/calogo-darkbg.svg" : "loader/calogo-lightbg.svg") : (i.classList.add("games"),
            e = t ? "loader/c3logo-darkbg.svg" : "loader/c3logo-lightbg.svg"),
            i.src = e,
            i.alt = lO("ui.start-page.construct-logo")
        }
        $et() {
            const t = self.app;
            aO.p.u("ui.dialogs.about"),
            this.o_i.textContent = lO("common.ok"),
            this.Wa(lO(".caption")),
            this.Pet("c3versioninfo").textContent = uO(".release-number-" + t.oNe(), aO.dQ.mPe),
            this.Pet("viewReleaseNotes").textContent = uO(".view-release-notes", aO.dQ.mPe),
            this.Pet("aboutShowPlatformInfo").textContent = lO(".platform-information"),
            this.Pet("accountHeader").textContent = lO(".account-header"),
            this.Pet("viewAccountInfo").textContent = lO(".view-account-information"),
            this.Pet("localStorageHeader").textContent = lO(".local-storage-header"),
            this.rNe.textContent = lO(".request-persistent-storage"),
            this.Pet("aboutConstructHeader").textContent = lO(".about-construct-header"),
            this.Pet("officialWebsite").textContent = lO(".official-website"),
            this.Pet("editorCredit").textContent = lO(".editor-credit"),
            this.Pet("websiteCredit").textContent = lO(".website-credit"),
            this.Pet("designCredit").textContent = lO(".design-credit"),
            this.Pet("thanksCredit").textContent = lO(".thanks-credit"),
            this.Pet("aboutShowLicenseAgreement").textContent = lO(".eula"),
            this.Pet("aboutShowBundledGameLicense").textContent = lO(".bundled-project-license"),
            this.Pet("privacyPolicy").textContent = lO(".privacy-policy"),
            this.Pet("aboutShowLegalInfo").textContent = lO(".legal-information"),
            this.Pet("timeSpentInEditorLabel").textContent = lO(".time-spent-in-editor"),
            this.Pet("thanksNote").textContent = lO(".thanks-note"),
            aO.wQ(this.Pet("quote"), self.Iet(".quote")),
            this.Pet("mainWebsiteLink").onclick = () => t.pQ(aO.dQ.URL.VIe, "AboutDialog", "OfficialWebsite");
            const i = this.Pet("storageCleanup");
            i.textContent = lO(".storage-cleanup"),
            i.onclick = () => {
                aO.Qs.Ks.qs("StorageCleanup").Xa()
            }
            ;
            const e = this.Pet("aboutUsLink");
            e.textContent = lO(".about-us"),
            e.onclick = () => t.pQ(aO.dQ.URL.WIe, "AboutDialog", "AboutUs");
            const s = this.Pet("helpLink");
            s.textContent = lO(".help"),
            s.onclick = () => t.pQ(aO.dQ.URL.mQ, "AboutDialog", "Help");
            const n = this.Pet("forumsLink");
            n.textContent = lO(".forums"),
            n.onclick = () => t.pQ(aO.dQ.URL.nPe, "AboutDialog", "Forum");
            const r = this.Pet("tutorialsLink");
            r.textContent = lO(".tutorials"),
            r.onclick = () => t.pQ(aO.dQ.URL.uQ, "AboutDialog", "Tutorials");
            const h = this.Pet("addonExchangeLink");
            h.textContent = lO(".get-addons"),
            h.onclick = () => t.pQ(aO.dQ.URL.Lme, "AboutDialog", "Addons");
            const o = this.Pet("contributeTranslationsLink");
            o.textContent = lO(".contribute-translations"),
            o.onclick = () => t.pQ(aO.dQ.URL.uPe, "AboutDialog", "ContributeTranslations");
            const a = this.Pet("suggestFeaturesLink");
            a.textContent = lO(".suggest-features"),
            a.onclick = () => t.pQ(aO.dQ.URL.lPe);
            const l = this.Pet("reportIssuesLink");
            l.textContent = lO(".report-issues"),
            l.onclick = () => t.pQ(aO.dQ.URL.aPe),
            aO.p.j()
        }
        Xa(t) {
            return this.aNe(),
            this.lNe(),
            super.Xa(t)
        }
        aNe() {
            aO.QL.V9t ? (this.sNe.textContent = lO("common.ellipsis"),
            navigator.storage.estimate().then(t => {
                const i = t.quota
                  , e = t.usage
                  , s = Math.round(1e3 * e / i) / 10;
                this.sNe.textContent = uO("ui.dialogs.about.storage-usage", aO.Woi(e), aO.Woi(i), s)
            }
            ).catch(t => {
                (() => {})("Error estimating storage usage: ", t),
                this.sNe.textContent = lO("ui.dialogs.about.storage-usage-unavailable")
            }
            )) : this.sNe.textContent = lO("ui.dialogs.about.storage-usage-unavailable"),
            aO.QL.z9t ? (this.nNe.textContent = "",
            this.nNe.classList.remove("storagePersisted"),
            this.nNe.classList.remove("storageNotPersisted"),
            this.rNe.setAttribute("hidden", ""),
            navigator.storage.persisted().then(t => {
                t ? (this.nNe.classList.add("storagePersisted"),
                this.nNe.textContent = lO("ui.dialogs.about.storage-persisted")) : (this.nNe.classList.add("storageNotPersisted"),
                this.nNe.textContent = lO("ui.dialogs.about.storage-not-persisted-prefix"),
                this.rNe.removeAttribute("hidden"))
            }
            )) : this.nNe.textContent = lO("ui.dialogs.about.storage-status-unavailable")
        }
        lNe() {
            localforage.getItem("c3-time-spent-in-editor").then(t => {
                "number" != typeof t && (t = 0);
                const i = this.Pet("timeSpentInEditor");
                i.textContent = t >= 31536e5 ? "Very clever." : aO.Joi(t, {
                    Yoi: !1
                })
            }
            )
        }
        hNe() {
            navigator.storage.persist().then(t => {
                if (this.aNe(),
                !t) {
                    aO.Qs.Ks.qs("OK").Xa(lO("ui.dialogs.about.persistent-storage-denied"))
                }
            }
            )
        }
        xO() {}
    }
    ;
    aO.Qs.mk.iit.addEventListener("load", () => {
        aO.Qs.Ks.rit(pO, mO)
    }
    )
}
{
    const wO = self.t
      , gO = self.lang
      , yO = wO.bW(import.meta.url)
      , bO = yO.getElementById("addonConfirmInstallDialog")
      , vO = wO.IW(yO.URL);
    wO.p.MW(vO + "lang");
    const SO = "AddonConfirmInstall"
      , xO = wO.Qs.Fk.uNe = class extends wO.Qs.Ks {
        constructor() {
            super(bO),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.cNe = this.Pet("dontAskAgain"),
            this.dNe = !1,
            wO.v(wO.Qs._q, self.app.u0("warning"), this.Pet("iconWrap"))
        }
        $et() {
            wO.p.u("ui.dialogs.addonConfirmInstall"),
            this.Wa(gO(".caption")),
            wO.wQ(this.Pet("headerText"), wO.v(wO.ix, gO(".header-text"), {
                AU: !0
            })),
            this.Pet("addonNameLabel").textContent = gO(".name"),
            this.Pet("addonVersionLabel").textContent = gO(".version"),
            this.Pet("addonTypeLabel").textContent = gO(".type"),
            this.Pet("addonAuthorLabel").textContent = gO(".author"),
            this.Pet("addonWebsiteLabel").textContent = gO(".website"),
            this.Pet("addonDocumentationLabel").textContent = gO(".documentation"),
            this.Pet("addonDescriptionLabel").textContent = gO(".description"),
            this.Pet("dontAskAgainLabel").textContent = gO(".dont-ask-again"),
            this.o_i.textContent = gO(".install"),
            this.FMt.textContent = gO("common.cancel"),
            wO.p.j()
        }
        Xa(t, i, e) {
            wO.IL(t),
            wO.p.u("ui.dialogs.addonConfirmInstall"),
            this.Pet("addonName").textContent = t.name,
            this.Pet("addonVersion").textContent = t.version,
            this.Pet("addonType").textContent = gO(".type-" + t.type),
            this.Pet("addonAuthor").textContent = t.author;
            const s = this.Pet("addonWebsite");
            s.textContent = t.website,
            s.href = t.website;
            const n = this.Pet("addonDocumentation");
            return n.textContent = t.documentation,
            n.href = t.documentation,
            this.Pet("addonDescription").textContent = t.description,
            this.cNe.checked = !1,
            this.dNe = i,
            this.Pet("dontAskAgainWrap").style.display = i ? "" : "none",
            wO.p.j(),
            super.Xa(e)
        }
        xet() {
            this.sW(!this.dNe || this.cNe.checked ? "remember" : "forget")
        }
        xO() {}
    }
    ;
    wO.Qs.mk.iit.addEventListener("load", () => {
        wO.Qs.Ks.rit(SO, xO)
    }
    )
}
{
    const MO = self.t
      , EO = self.lang
      , CO = MO.bW(import.meta.url)
      , _O = CO.getElementById("addonUpdateReviewDialog")
      , TO = MO.IW(CO.URL);
    MO.p.MW(TO + "lang");
    const IO = "AddonUpdateReview"
      , PO = MO.Qs.Fk.fNe = class extends MO.Qs.Ks {
        constructor() {
            super(_O),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.iVt = this.Pet("updateReviewContent")
        }
        $et() {
            const t = MO.p.Yue("ui.dialogs.addonUpdateReview");
            this.o_i.textContent = t(".update"),
            this.FMt.textContent = EO("common.cancel")
        }
        Xa(t, i) {
            MO.RH(t);
            const e = MO.p.Yue("ui.dialogs.addonUpdateReview");
            return MO.wQ(this.Pet("headerWrap"), MO.v(MO.ix, e.UHt(".header.review-details", null, t.length) + "\n" + e(".header.bundled-addons-note"), {
                AU: !0
            })),
            this.pNe(t),
            super.Xa(i)
        }
        pNe(t) {
            for (const i of t) {
                const t = document.createElement("div");
                t.classList.add("addonUpdateWrap"),
                MO.wQ(t, this.mNe(i)),
                this.iVt.appendChild(t)
            }
        }
        mNe(t) {
            const i = MO.p.Yue("ui.dialogs.addonUpdateReview")
              , {version: e, wNe: s, gNe: n, yNe: r} = t.VPe();
            let h = `[h2]${t.La()}[/h2]\n`;
            h += i.dme(".current-version", t.a6()) + "\n",
            h += i.dme(".update-version", e) + "\n",
            h += i.dme(".published-date", s.toLocaleString(self.app.X7(), {
                day: "numeric",
                month: "long",
                year: "numeric"
            })),
            r && (h += `\n[a1]${i(".visit-addon-page")}[/a1]`);
            for (let t = n.length - 1; t >= 0; --t) {
                const e = n[t];
                h += `\n\n[h3]${i.dme(".changes", e.version)}[/h3]\n`,
                h += e.bNe
            }
            return MO.v(MO.ix, h, {
                AU: !0,
                links: r ? [r] : []
            })
        }
        xO() {
            MO.Qs.L6(this.iVt)
        }
    }
    ;
    MO.Qs.mk.iit.addEventListener("load", () => {
        MO.Qs.Ks.rit(IO, PO)
    }
    )
}
{
    const GO = self.t
      , AO = GO.bW(import.meta.url)
      , RO = AO.getElementById("bundledContentLicenseDialog")
      , kO = (GO.IW(AO.URL),
    "BundledContentLicense")
      , OO = GO.Qs.Fk.vNe = class extends GO.Qs.Ks {
        constructor() {
            super(RO),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet()
        }
        $et() {
            this.o_i.textContent = self.lang("common.close-dialog")
        }
        Xa(t) {
            return super.Xa(t)
        }
        xO() {}
    }
    ;
    GO.Qs.mk.iit.addEventListener("load", () => {
        GO.Qs.Ks.rit(kO, OO)
    }
    )
}
{
    const DO = self.t
      , FO = DO.bW(import.meta.url)
      , LO = FO.getElementById("eulaDialog")
      , BO = (DO.IW(FO.URL),
    "EULA")
      , UO = DO.Qs.Fk.SNe = class extends DO.Qs.Ks {
        constructor() {
            super(LO),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet()
        }
        $et() {
            this.o_i.textContent = self.lang("common.close-dialog")
        }
        Xa(t) {
            return super.Xa(t)
        }
        xO() {}
    }
    ;
    DO.Qs.mk.iit.addEventListener("load", () => {
        DO.Qs.Ks.rit(BO, UO)
    }
    )
}
{
    const NO = self.t
      , jO = self.lang
      , $O = NO.bW(import.meta.url)
      , zO = $O.getElementById("exportSelectPlatformDialog")
      , VO = NO.IW($O.URL);
    NO.p.MW(VO + "lang");
    const WO = "ExportSelectPlatform"
      , HO = new Map([["animation", 0], ["web", 1], ["apps", 2], ["mobile", 3], ["desktop", 4], ["mobile-and-desktop", 5], ["console", 6], ["other", 7], ["deprecated", 8]]);
    function KO(t, i) {
        return HO.get(t[0]) - HO.get(i[0])
    }
    const qO = NO.Qs.Fk.xNe = class extends NO.Qs.Ks {
        constructor() {
            super(zO),
            this.EMt = this.Pet("nextButton"),
            this.EMt.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et();
            let t = this.Pet("exportPlatformIconView");
            this.X6 = NO.v(NO.Qs.Fk.Y6, t),
            this.X6.addEventListener("itemselect", t => this.fNi(t.item)),
            this.X6.addEventListener("itemdoubletap", t => this.y3(t.item)),
            this.MNe = this.Pet("exportPlatformDescription"),
            this.uCt = null
        }
        $et() {
            NO.p.u("ui.dialogs.exportSelectPlatform"),
            this.Wa(jO(".caption")),
            this.EMt.textContent = jO("common.next"),
            this.FMt.textContent = jO("common.cancel");
            const t = this.Pet("helpLink");
            t.textContent = jO("common.help"),
            t.onclick = () => self.app.FT("overview/publishing-projects", "ExportSelectPlatformDialog"),
            NO.p.j()
        }
        Xa(t, i) {
            NO.U(t, self.jw),
            this.uCt = t;
            let e = super.Xa(i);
            return NO.Abi.yrt().then( () => this.ENe()).catch(t => {
                console.error("Error loading exporters: ", t);
                NO.Qs.Ks.qs("OK").Xa(jO("ui.dialogs.exportSelectPlatform.error-loading-exporters"))
            }
            ),
            e
        }
        ENe() {
            const t = NO.Abi
              , i = new Map;
            for (const e of t.CNe()) {
                let t = {
                    _Ne: e,
                    TNe: -1
                }
                  , s = e.OAe();
                i.has(s) ? i.get(s).push(t) : i.set(s, [t]);
                const n = e.INe();
                for (let r = 0, h = n.length; r < h; ++r)
                    t = {
                        _Ne: e,
                        TNe: r
                    },
                    s = n[r].OAe(),
                    i.has(s) ? i.get(s).push(t) : i.set(s, [t])
            }
            const e = [...i];
            e.sort(KO);
            for (const [t,i] of e) {
                const e = jO("model.exporter-category." + t);
                i.sort( (t, i) => self.GNe.PNe(t._Ne, i._Ne));
                const s = this.X6.Doe(e);
                for (const t of i) {
                    const i = t._Ne
                      , e = t.TNe;
                    if (-1 === e)
                        s._A(i.COi(i.if()), i.La(), {
                            _Ne: i,
                            tag: i.if(),
                            description: i.nse()
                        });
                    else {
                        const t = i.INe()[e];
                        s._A(i.COi(t.if()), t.La(), {
                            _Ne: i,
                            tag: t.if(),
                            description: i.ANe(t.if(), t.nse())
                        })
                    }
                }
            }
        }
        xet() {
            const t = this.X6.Eit();
            if (!t)
                return;
            const i = t.Do();
            this.sW(i)
        }
        xO() {
            this.X6.Ry(),
            this.uCt = null
        }
        fNi(t) {
            t ? (this.EMt.removeAttribute("disabled"),
            NO.wQ(this.MNe, t.Do().description)) : this.EMt.setAttribute("disabled", "")
        }
        y3(t) {
            this.xet()
        }
    }
    ;
    NO.Qs.mk.iit.addEventListener("load", () => {
        NO.Qs.Ks.rit(WO, qO)
    }
    )
}
{
    const XO = self.t
      , YO = self.lang
      , JO = XO.bW(import.meta.url)
      , ZO = JO.getElementById("exportStandardOptionsDialog")
      , QO = XO.IW(JO.URL);
    XO.p.MW(QO + "lang");
    const tD = "ExportStandardOptions"
      , iD = XO.Qs.Fk.RNe = class extends XO.Qs.Ks {
        constructor() {
            super(ZO),
            this.EMt = this.Pet("nextButton"),
            this.EMt.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.kNe = this.oyt("exportDeduplicateImages"),
            this.ONe = this.oyt("exportLosslessImageFormat"),
            this.DNe = this.oyt("exportLossyImageFormat"),
            this.FNe = this.oyt("exportOptimizeImages"),
            this.LNe = this.oyt("exportMinifyMode"),
            this.BNe = this.Pet("offlineSupportWrap"),
            this.UNe = this.oyt("exportOfflineSupport"),
            this.uCt = null,
            this.ONe.value = "webp",
            this.DNe.value = "webp"
        }
        $et() {
            XO.p.u("ui.dialogs.exportStandardOptions"),
            this.Wa(YO(".caption")),
            this.EMt.textContent = YO("common.next"),
            this.FMt.textContent = YO("common.cancel");
            const t = this.Pet("helpLink");
            t.textContent = YO("common.help"),
            t.onclick = () => self.app.FT("overview/publishing-projects", "ExportStandardOptionsDialog"),
            this.Pet("imageHeader").textContent = YO(".image-options"),
            this.Pet("exportDeduplicateImagesLabel").textContent = YO(".deduplicate-images"),
            this.Pet("exportLosslessImageFormatLabel").textContent = YO(".lossless-format"),
            this.Pet("exportLossyImageFormatLabel").textContent = YO(".lossy-format"),
            this.Pet("exportOptimizeImagesLabel").textContent = YO(".optimize-images"),
            this.Pet("scriptHeader").textContent = YO(".script-options"),
            XO.p.u(".minify-script"),
            this.Pet("exportMinifyScriptDescription").textContent = YO(".description"),
            this.Pet("exportMinifyModeLabel").textContent = YO(".mode.label");
            for (let t = 0, i = this.LNe.options.length; t < i; ++t) {
                const i = this.LNe.options[t];
                i.textContent = YO(".mode." + i.value)
            }
            XO.p.j(),
            this.Pet("otherHeader").textContent = YO(".other-options"),
            this.Pet("exportOfflineSupportLabel").textContent = YO(".offline-support.label"),
            XO.wQ(this.Pet("offlineSupportDescription"), XO.v(XO.ix, YO(".offline-support.description"), {
                links: [ () => self.app.pQ("https://www.construct.net/tutorials/offline-games-construct-8", "ExportOfflineSupportLearnMore")]
            })),
            XO.p.j()
        }
        Xa(t, i) {
            this.uCt = t.Iw;
            const e = t.NNe
              , s = super.Xa(i);
            XO.p.u("ui.dialogs.exportStandardOptions.minify-script");
            let n = YO(".description");
            const r = [];
            return this.uCt.mLt() && (n += " " + YO(".advanced-note"),
            r.push( () => self.app.FT("scripting/guides/advanced-minification", "ExportMinifyAdvancedLearnMore"))),
            XO.wQ(this.Pet("exportMinifyScriptDescription"), XO.v(XO.ix, n, {
                links: r
            })),
            XO.p.j(),
            this.BNe.style.display = e.jNe() ? "" : "none",
            this.UNe.checked = !0,
            localforage.getItem("export-std-options").then(t => {
                t && (this.kNe.checked = t.deduplicateImages,
                this.ONe.value = t.losslessFormat,
                this.DNe.value = t.lossyFormat,
                this.FNe.checked = t.optimizeImages || t.recompressImages,
                this.LNe.value = t.minifyMode2 ?? "none",
                this.UNe.checked = "boolean" != typeof t.offlineSupport || t.offlineSupport)
            }
            ).catch(XO.wS),
            s
        }
        async xet() {
            const t = self.app;
            "none" !== this.LNe.value && await t.$T() ? t.RP(this.uCt, 28) : (localforage.setItem("export-std-options", {
                deduplicateImages: this.kNe.checked,
                losslessFormat: this.ONe.value,
                lossyFormat: this.DNe.value,
                optimizeImages: this.FNe.checked,
                minifyMode2: this.LNe.value,
                offlineSupport: this.UNe.checked
            }).catch(XO.wS),
            this.sW({
                $Ne: this.kNe.checked,
                zNe: this.ONe.value,
                VNe: this.DNe.value,
                WNe: this.FNe.checked,
                HNe: this.LNe.value,
                KNe: this.UNe.checked
            }))
        }
        xO() {
            this.uCt = null
        }
    }
    ;
    XO.Qs.mk.iit.addEventListener("load", () => {
        XO.Qs.Ks.rit(tD, iD)
    }
    )
}
{
    const eD = self.t
      , sD = self.lang
      , nD = self.h_
      , rD = self.e_
      , hD = eD.bW(import.meta.url)
      , oD = hD.getElementById("exportStatsDialog")
      , aD = eD.IW(hD.URL);
    eD.p.MW(aD + "lang");
    const lD = "ExportStats"
      , uD = eD.Qs.Fk.qNe = class extends eD.Qs.Ks {
        constructor() {
            super(oD),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.XNe = null
        }
        $et() {
            this.o_i.textContent = sD("common.done")
        }
        Xa(t, i) {
            eD.IL(t),
            eD.U(t.YNe, self.vvi);
            const e = t.YNe
              , s = e.Cn()
              , n = e.Wrt();
            this.XNe = n,
            eD.p.u("ui.dialogs.exportStats"),
            this.Wa(sD(".caption")),
            eD.wQ(this.Pet("exportDurationMessage"), rD(".duration-message", eD.Joi(Math.round(n.JNe / 1e3)))),
            eD.wQ(this.Pet("scriptSizeInfo"), this.ZNe(n)),
            eD.wQ(this.Pet("dataSizeInfo"), this.QNe(n)),
            eD.wQ(this.Pet("imageSizeInfo"), this.tje(n)),
            eD.wQ(this.Pet("deduplicationInfo"), this.ije(n)),
            eD.wQ(this.Pet("audioSizeInfo"), this.eje(s));
            let r = (n.sje || n.nje || n.rje) + (n.hje || n.oje) + n.aje + s.lje() + s.uje() + (t.cje || 0)
              , h = s.uje();
            t.dje ? h = NaN : s.Ise() || (h += s.lje()),
            eD.wQ(this.Pet("overallSizeInfo"), this.fje(r, h)),
            eD.wQ(this.Pet("overallSizeSummary"), rD(".overall-size-summary", eD.Woi(r))),
            eD.p.j();
            const o = this.Pet("customSizeInfo");
            return t.pje ? (eD.wQ(o, t.pje),
            o.style.display = "") : o.style.display = "none",
            super.Xa(i)
        }
        ZNe(t) {
            let i = ""
              , e = t.rje
              , s = t.sje;
            if ("none" === t.HNe)
                i = rD(".script-size-no-minify", eD.Woi(e), s ? eD.Woi(s) : sD(".not-applicable"));
            else {
                let n = t.nje;
                i = rD(".script-size-minified", eD.Woi(e), eD.Woi(n), s ? eD.Woi(s) : sD(".not-applicable"))
            }
            return i
        }
        QNe(t) {
            let i = t.oje
              , e = t.hje;
            return rD(".data-file-size", eD.Woi(i), e ? eD.Woi(e) : sD(".not-applicable"))
        }
        tje(t) {
            return rD(t.WNe ? ".optimized-image-size-message" : ".unoptimized-image-size-message", eD.Woi(t.aje))
        }
        ije(t) {
            let i = "";
            return i = t.$Ne ? rD(".deduplication-message", t.mje, eD.Woi(t.wje)) : rD(".no-deduplication-message"),
            i
        }
        eje(t) {
            return rD(".audio-size", eD.Woi(t.lje()), eD.Woi(t.uje()))
        }
        fje(t, i) {
            return new eD.ix(nD(".overall-size", eD.Woi(t), isNaN(i) ? sD(".not-applicable") : eD.Woi(t - i)),{
                links: [ () => self.app.FT("tips-and-guides/download-size", "ExportStatsDialog")]
            })
        }
        xO() {
            this.XNe = null
        }
    }
    ;
    eD.Qs.mk.iit.addEventListener("load", () => {
        eD.Qs.Ks.rit(lD, uD)
    }
    )
}
{
    const cD = self.t
      , dD = self.Yfi
      , fD = self.lang
      , pD = self.h_
      , mD = cD.bW(import.meta.url)
      , wD = mD.getElementById("fileListDialog")
      , gD = "FileList"
      , yD = cD.IW(mD.URL)
      , bD = ["DROPBOX", "ONE DRIVE", "GOOGLE DRIVE", "LOCAL STORAGE"]
      , vD = new Set
      , SD = ["NAME_ASC", "NAME_DEC", "DATE_ASC", "DATE_DEC", "SIZE_ASC", "SIZE_DEC"];
    let xD = !1;
    function MD(t, i) {
        return cD.zt(t),
        cD.zt(i),
        cD.Qs.Ks.qs("Confirm").Xa({
            caption: t,
            message: i
        }, wD)
    }
    function ED(t) {
        return cD.zt(t),
        cD.Qs.Ks.qs("OK").Xa(t, wD)
    }
    cD.p.MW(yD + "lang");
    const CD = cD.Qs.Fk.gje = class extends cD.Qs.Ks {
        constructor() {
            super(wD),
            cD.p.u("ui.dialogs.fileList");
            const t = cD.Qs.v2
              , i = t => self.app.oi(t);
            this.e2 = cD.v(t, this.Oet(), this);
            const e = t.vwe(28);
            this.i2 = this.e2.S2("horizontalToolbar", e, [t.C2("refresh", i("reload"), fD(".refresh"), () => this.A0(!0)), t.C2("add folder", i("add-folder"), fD(".add-folder"), () => this.yje()), t.C2("upload", i("cloud-upload"), fD(".upload"), () => this.bje()), t.C2("up", i("up-arrow"), fD(".up"), () => this.vje()), t.YA(!1, "dividerA", !1), t.O2("service", [{
                value: "",
                label: fD(".selectService"),
                selected: !0,
                disabled: !0
            }, {
                value: "DROPBOX",
                label: "Dropbox"
            }, {
                value: "ONE DRIVE",
                label: "OneDrive"
            }, {
                value: "GOOGLE DRIVE",
                label: "Google Drive"
            }], fD(".service"), t => this.Sje(t), !1, !0), t.C2("logout", i("account-logout"), fD(".logout"), () => this.xje()), t.YA(!1, "dividerB", !1), t.R2("filter", "", fD(".search"), t => this.Mje(t), !1, !0)]),
            this.Eje = SD[0],
            this.e2.g_();
            let s = this.e2.X0()
              , n = cD.v(cD.Qs.hEt)
              , r = document.createElement("input")
              , h = document.createElement("button")
              , o = cD.v(cD.Qs.Fk.Table, s, {
                $qi: !1
            })
              , a = document.createElement("div")
              , l = document.createElement("span");
            this.MVi = {
                service: this.i2.c2("service"),
                search: this.i2.c2("filter"),
                upload: this.i2.c2("upload"),
                refresh: this.i2.c2("refresh"),
                add: this.i2.c2("add folder"),
                up: this.i2.c2("up"),
                Cje: this.i2.c2("dividerA"),
                _je: this.i2.c2("dividerB"),
                Tje: this.i2.c2("logout"),
                Ije: s,
                table: o,
                Pje: n,
                filename: r,
                Gje: h
            },
            this.Aje = ["root"],
            this.MVi.table.Aet().Get("icon", 20, "").Get("name", 160, fD(".name")).Get("date", 120, fD(".dateModified")).jet("size", fD(".size")),
            this.k_().setAttribute("loading", ""),
            l.textContent = fD(".filename"),
            a.className = "tray",
            s.appendChild(n.element),
            a.appendChild(l),
            a.appendChild(r),
            a.appendChild(h),
            this.fCi().appendChild(a),
            this.Wgi = cD.v(cD.Rf, cD._f.Gf(self.app, "settingschange", () => this.hjt()), cD._f.Gf(cD.sF, "afterload", () => this.hjt()), cD._f.Gf(o, "rowcontextmenu", t => this.sFt(t)), cD._f.Gf(o, "rowselected", t => this.Rje(t.Eet)), cD._f.Gf(o, "rowdoubletapped", t => this.kje(t)), cD._f.Gf(h, "pointerdown", t => this.Oje(t)), cD._f.Gf(r, "input", () => this.Dje(r.value))),
            this.dpt = null,
            this.Fje = null,
            this.Lje = null,
            this.Bje = !1,
            this.qqi = new Map,
            this.Uje = !1,
            this.Nje = null,
            this.jje = null,
            this.$je = null,
            this.zje = null,
            this.Vje = null,
            this.MVi.table.eP(!1),
            this.MVi.Pje.aEt(),
            cD.p.j("ui.dialogs.fileList"),
            this.hjt()
        }
        hjt() {
            const t = self.app.aU();
            this.Uje = t.cloudCache || !1
        }
        Wje() {
            this.exi({
                service: "LOCAL STORAGE" === this.Fje ? this.Lje : this.Fje,
                table: this.MVi.table.S5(),
                sort: this.Eje
            })
        }
        Hje(t, i) {
            self.assert(SD.includes(t), "invalid sort mode"),
            this.Eje !== t && (this.Eje = t,
            i || (this.A0(),
            this.Wje()))
        }
        Kje() {
            const t = this.nxi()
              , i = t && t.service
              , e = t && t.table
              , s = t && t.sort;
            i && !this.Fje && this.Sje(i, !0),
            s && this.Hje(s, !0),
            e && this.MVi.table.Q3(e)
        }
        Mje(t) {
            cD.zt(t),
            t = t.trim().toLowerCase();
            for (let i of this.qqi.entries())
                i[0].name.toLowerCase().includes(t) ? i[1].eP(!0) : (i[1] === this.Nje && this.qje(),
                i[1].eP(!1))
        }
        Sje(t, i) {
            if (!t)
                return this.MVi.service.m2(0),
                void (this.Fje = null);
            cD.zt(t),
            this.Fje !== t && bD.includes(t) && (this.Aje.length = 1,
            this.MVi.service.iKi(t),
            this.Fje = t,
            vD.has(t) || (vD.add(t),
            self.app.XGi("CloudSave", this.Fje)),
            i || (this.A0(),
            this.Wje()))
        }
        Dje(t) {
            cD.zt(t);
            const i = this.Xje(t.toLowerCase());
            if (i.zfi()) {
                const e = i.Wfi();
                for (const i of this.qqi.entries())
                    if (i[0].name.toLowerCase() === e)
                        return this.Rje(i[1], t),
                        i
            }
            this.Nje ? (this.Nje.vvt(),
            "OPEN" === this.dpt && this.Yje(!1),
            this.Nje = null,
            this.jje = null) : "SAVE" === this.dpt && this.Yje(0 !== t.length)
        }
        vje() {
            this.Aje.length > 1 && (this.Aje.pop(),
            this.A0())
        }
        async yje() {
            const t = this.Jje()
              , i = cD.Qs.Ks.qs("Input");
            cD.p.u("ui.dialogs.fileList.add-folder-dialog");
            const e = {
                caption: fD(".caption"),
                message: fD(".message"),
                label: fD(".label"),
                _Ti: "New folder"
            };
            cD.p.j();
            const s = await i.Xa(e);
            if (null === s || 0 === s)
                return;
            const n = this.Xje(s, !0);
            if (!n.zfi())
                return ED(n.Hfi());
            {
                this.Zje(fD("ui.dialogs.fileList.creatingFolder"));
                const i = n.Wfi();
                try {
                    await self.Xue.Qje(i, t, this.Fje),
                    this.A0()
                } catch (t) {
                    return ED(fD("ui.dialogs.fileList.failedCreatingFolder"))
                }
                this.t$e()
            }
        }
        async bje() {
            const t = await cD.Qs.ZCi.i_i(".c3p", null, !1, !1, "cloud-upload");
            if (null === t)
                return;
            const i = this.Jje()
              , e = this.Xje(t.name);
            if (e.Vfi())
                return void ED(e.Hfi());
            const s = e.Wfi();
            this.Zje(fD("ui.dialogs.fileList.uploading"));
            try {
                let e = null
                  , n = null;
                for (const t of this.qqi.keys())
                    if (t.name.toLowerCase() === s) {
                        e = t;
                        break
                    }
                if (e) {
                    if (!await MD(fD("ui.dialogs.fileList.overwriteFile"), pD("ui.dialogs.fileList.confirmOverwrite", e.name)))
                        return;
                    n = e.id
                }
                try {
                    await self.Xue.i$e(t, n, s, i, this.Fje),
                    this.A0()
                } catch (t) {
                    throw t.message
                }
            } catch (t) {
                this.t$e(),
                ED(t)
            }
        }
        e$e(t) {
            t && "folder" == t.type && (this.Aje.push(t.id),
            this.A0())
        }
        s$e(t, i) {
            const e = t.shift();
            for (const s of i)
                if (s.id == e)
                    return t.length > 0 ? this.s$e(t, s.children) : s.children;
            throw new Error("Invalid location")
        }
        async n$e(t) {
            const i = this.Jje()
              , e = this.Fje;
            for (const s of t) {
                if (i != this.Jje())
                    return;
                if (e != this.Fje)
                    return;
                if (!this.lbt)
                    return;
                if ("folder" === s.type)
                    try {
                        await self.Xue.Hri(e, !1, s.id)
                    } catch (t) {
                        return void console.error(`Failed to preload child entries of "${i}": `, t)
                    }
            }
        }
        async A0(t) {
            if (this.Fje) {
                let i = this.MVi.filename.value;
                this.Zje(pD("ui.dialogs.fileList.getFiles", cD.Zoi(this.Fje)));
                try {
                    const e = this.Jje()
                      , s = await self.Xue.Hri(this.Fje, t, e);
                    this.Uje && this.n$e(s),
                    this.r$e();
                    const n = new Set([".c3p", ".capx"]);
                    for (const t of this.h$e(s)) {
                        if ("folder" !== t.type && !n.has(t.ext))
                            continue;
                        const i = this.Bji(t);
                        this.qqi.set(t, i)
                    }
                    this.Dje(i),
                    this.t$e()
                } catch (t) {
                    console.error(t),
                    this.o$e(t)
                }
            }
        }
        a$e(t, i) {
            if (t.type === i.type) {
                const e = t.name.toLowerCase()
                  , s = i.name.toLowerCase();
                return e > s ? 1 : s > e ? -1 : 0
            }
            return "file" === t.type ? 1 : -1
        }
        l$e(t, i) {
            if (t.type === i.type) {
                const e = new Date(t.date || 0).getTime() - new Date(i.date || 0).getTime();
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }
            return "file" === t.type ? 1 : -1
        }
        u$e(t, i) {
            if (t.type === i.type) {
                const e = t.size - i.size;
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }
            return "file" === t.type ? 1 : -1
        }
        h$e(t) {
            switch (this.Eje) {
            case "NAME_ASC":
                return t.sort( (t, i) => this.a$e(t, i));
            case "NAME_DEC":
                return t.sort( (t, i) => this.a$e(i, t));
            case "DATE_ASC":
                return t.sort( (t, i) => this.l$e(t, i));
            case "DATE_DEC":
                return t.sort( (t, i) => this.l$e(i, t));
            case "SIZE_ASC":
                return t.sort( (t, i) => this.u$e(t, i));
            case "SIZE_DEC":
                return t.sort( (t, i) => this.u$e(i, t))
            }
        }
        async xje() {
            if (this.Fje) {
                this.Zje(pD("ui.dialogs.fileList.logging-out", cD.Zoi(this.Fje))),
                this.r$e();
                try {
                    await self.Xue.c$e(this.Fje),
                    this.Zje(null, !0)
                } catch (t) {
                    this.o$e(t)
                }
                this.Sje("")
            }
        }
        o$e(t) {
            let i;
            i = "string" == typeof t ? t : fD("ui.dialogs.fileList.failedToRefresh"),
            this.MVi.refresh.I2(!0),
            this.MVi.upload.I2(!0),
            this.MVi.up.I2(!1),
            this.MVi.add.I2(!1),
            this.MVi.service.I2(!0),
            this.MVi.table.eP(!1),
            this.MVi.search.I2(!1),
            this.MVi.Pje.eP(!0),
            this.d$e(i),
            this.k_().setAttribute("loading", ""),
            this.MVi.Pje.aEt()
        }
        Zje(t, i) {
            i ? t = fD("ui.dialogs.fileList.pleaseSelectService") : cD.zt(t),
            this.MVi.Tje.I2(!1),
            this.MVi.upload.I2(!1),
            this.MVi.refresh.I2(!1),
            this.MVi.up.I2(!1),
            this.MVi.add.I2(!1),
            this.MVi.service.I2(i),
            this.MVi.table.eP(!1),
            this.MVi.search.I2(!1),
            this.MVi.Pje.eP(!0),
            this.d$e(t),
            this.k_().setAttribute("loading", ""),
            i ? this.MVi.Pje.aEt() : this.MVi.Pje._0i()
        }
        t$e() {
            this.MVi.table.eP(!0),
            this.MVi.up.I2(this.Aje.length > 1),
            this.MVi.add.I2(!0),
            this.MVi.refresh.I2(!0),
            this.MVi.upload.I2(!0),
            this.MVi.service.I2(!0),
            this.MVi.search.I2(!0),
            this.MVi.Pje.eP(!1),
            this.MVi.Tje.I2(!0),
            this.k_().removeAttribute("loading")
        }
        qje() {
            this.Nje && (this.Nje.vvt(),
            this.Yje(!1),
            this.Nje = null,
            this.jje = null)
        }
        Rje(t, i) {
            if (this.Nje === t)
                return;
            this.qje();
            const e = t.Do();
            e && "file" == e.type && (this.Yje(!0),
            this.MVi.filename.value = i || e.name,
            this.Nje = t,
            this.jje = e,
            t._5())
        }
        kje(t) {
            this.Oje(t)
        }
        sFt(t) {
            const i = t.Eet
              , e = cD.v(cD.Qs.EA, this.MVi.Ije)
              , s = i.Do();
            s && ("file" == s.type ? e._A(null, fD("ui.dialogs.fileList.downloadFile"), () => this.f$e(i)) : e._A(null, fD("ui.dialogs.fileList.open"), () => this.e$e(s))),
            "name" === t.eSt && (e._A(null, fD("ui.dialogs.fileList.sortNameAscending"), () => this.Hje("NAME_ASC")),
            e._A(null, fD("ui.dialogs.fileList.sortNameDescending"), () => this.Hje("NAME_DEC"))),
            "date" === t.eSt && (e._A(null, fD("ui.dialogs.fileList.sortDateAscending"), () => this.Hje("DATE_ASC")),
            e._A(null, fD("ui.dialogs.fileList.sortDateDescending"), () => this.Hje("DATE_DEC"))),
            "size" === t.eSt && (e._A(null, fD("ui.dialogs.fileList.sortSizeAscending"), () => this.Hje("SIZE_ASC")),
            e._A(null, fD("ui.dialogs.fileList.sortSizeDescending"), () => this.Hje("SIZE_DEC"))),
            e._A(null, fD("ui.dialogs.fileList.deleteFile"), () => this.p$e(i)),
            e._A(null, fD("ui.dialogs.fileList.renameFile"), () => this.m$e(i)),
            e.NT(t.clientX, t.clientY)
        }
        async p$e(t) {
            const i = t.Do();
            if (!i)
                return;
            if (!await MD(fD("ui.dialogs.fileList.deleteFile"), pD("ui.dialogs.fileList.confirmDelete", i.name)))
                return;
            this.Zje(fD("ui.dialogs.fileList.deletingFile"));
            const e = this.Jje(i);
            try {
                await self.Xue.XT(i.id, e, this.Fje);
                let s = this.MVi.filename.value;
                this.jje === i && (this.jje = null,
                t.vvt(),
                this.Nje = null),
                this.qqi.delete(i),
                this.MVi.table.wvt(t),
                this.Dje(s),
                !this.jje && s && (this.MVi.filename.value = s,
                this.Yje(!0))
            } catch (t) {
                (() => {})("failed to delete file", t),
                ED(pD("ui.dialogs.fileList.failedDelete", i.name))
            } finally {
                this.t$e()
            }
        }
        Yje(t) {
            this.MVi.Gje.disabled = !t
        }
        Jje() {
            const t = this.Aje.length;
            return this.Aje[t - 1]
        }
        f$e(t) {
            let i = t.Do();
            self.Xue.gLt(i.name, i.id, this.Fje)
        }
        w$e(t, i) {
            const e = t.Do()
              , s = "file" == e.type;
            e.id = i.id,
            e.name = i.name,
            e.date = i.date;
            const n = i.name
              , r = new Date(i.date).toLocaleString(self.app.X7(), {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "numeric",
                minute: "numeric"
            })
              , h = s ? isNaN(e.size) ? fD("ui.dialogs.fileList.unknown") : cD.Woi(e.size) : e.children.length.toString();
            t.sit("name").ha(n),
            t.sit("date").ha(r),
            t.sit("size").ha(h)
        }
        async m$e(t) {
            const i = t.Do();
            if (!i)
                return;
            const e = t.sit("name")
              , s = e.iSt()
              , n = "folder" == i.type
              , r = this.Jje(i);
            let h = await e.mnt();
            if (null == h || h === s)
                return;
            const o = this.Xje(h, n);
            if (o.Vfi())
                return ED(o.Hfi());
            const a = o.Wfi();
            try {
                if (!await MD(fD("ui.dialogs.fileList.renameFile"), pD("ui.dialogs.fileList.confirmRename", i.name, a)))
                    return;
                this.Zje(fD("ui.dialogs.fileList.renamingFile"));
                const e = await self.Xue.wnt(i.id, r, this.Fje, a);
                this.w$e(t, e),
                this.jje === i && (this.jje = null,
                t.vvt(),
                this.Nje = null);
                const s = this.MVi.filename.value;
                this.Dje(s),
                !this.jje && s && (this.MVi.filename.value = s,
                this.Yje(!1))
            } catch (t) {
                (() => {})("Failed to rename file", t),
                ED(pD("ui.dialogs.fileList.failedRename", i.name, a))
            } finally {
                this.t$e()
            }
        }
        LCi(...t) {
            return this.Wje(),
            this.zje && (this.zje(null),
            this.zje = null),
            super.LCi(...t)
        }
        xet() {
            cD.Qs.EA.JF() || this.Oje()
        }
        _et() {
            this.ph()
        }
        Oje(t) {
            if (t) {
                const i = t.Eet
                  , e = i && i.Do();
                if (e && "folder" == e.type)
                    return void this.e$e(e)
            }
            "SAVE" === this.dpt ? this.g$e() : this.y$e()
        }
        y$e() {
            this.jje && "file" == this.jje.type && (this.zje && this.zje([this.Fje, this.jje]),
            this.ph())
        }
        g$e() {
            if (this.jje && "file" == this.jje.type) {
                if (".capx" === this.jje.ext)
                    return void ED(fD("ui.dialogs.fileList.cannotSaveCAPX"));
                MD(fD("ui.dialogs.fileList.overwriteFile"), pD("ui.dialogs.fileList.confirmOverwrite", this.jje.name)).then(t => {
                    t && (this.zje && this.zje([this.Fje, this.jje.name, this.jje.id, this.jje.parent]),
                    this.ph())
                }
                )
            } else {
                const t = this.Jje()
                  , i = this.Xje(this.MVi.filename.value);
                if (i.Vfi())
                    return ED(i.Hfi());
                this.zje && this.zje([this.Fje, i.Wfi(), null, t]),
                this.ph()
            }
        }
        b$e(t) {
            cD.Qs.Ks.qs("OK").Xa(t, this.MVi.Ije)
        }
        Xje(t, i) {
            let e, s = t.trim(), n = /\.([^.]*)$/;
            if (0 === s.length)
                return dD.qfi(fD("ui.dialogs.fileList.filenameNone"));
            if (e = /([\\/:\*\?"<>\|])/i.exec(s))
                return dD.qfi(pD("ui.dialogs.fileList.filenameIllegalCharacter", e[1]));
            if (e = /^(nul|prn|con|lpt[0-9]|com[0-9])(\.|$)/i.exec(s))
                return dD.qfi(pD("ui.dialogs.fileList.filenameReservedName", e[1]));
            if (e = /^\./.exec(s))
                return dD.qfi(fD("ui.dialogs.fileList.filenamePrivate"));
            if (!i) {
                if (e = n.exec(s),
                e && "c3p" !== e[1])
                    return dD.qfi(pD("ui.dialogs.fileList.filenameExtension", e[1]));
                e || (s += ".c3p")
            }
            return dD.Ok(s)
        }
        ph() {
            this.r$e(),
            this.Pct()
        }
        r$e() {
            this.qje(),
            this.MVi.table.Ry(),
            this.qqi.clear(),
            this.MVi.search.Svt("")
        }
        Bji(t) {
            const i = "file" == t.type;
            let e;
            e = i ? "file" : t.isShared ? "shared-folder" : "open-folder";
            const s = self.app.oi(e);
            let n = ""
              , r = "";
            return i && (n = isNaN(t.size) ? fD("ui.dialogs.fileList.unknown") : cD.Woi(t.size)),
            t.date && (r = new Date(t.date).toLocaleString(self.app.X7(), {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "numeric",
                minute: "numeric"
            })),
            this.MVi.table.Wet(t).Xet("icon", s).jVt("name", t.name).Yet("date", r).Yet("size", n)
        }
        fpt(t) {
            if (cD.zt(t),
            "SAVE" == t)
                this.MVi.Gje.textContent = fD("ui.dialogs.fileList.save"),
                this.Wa(fD("ui.dialogs.fileList.saveProject"));
            else {
                if ("OPEN" != t)
                    throw new Error("Invalid file list mode selected");
                this.MVi.Gje.textContent = fD("ui.dialogs.fileList.open"),
                this.Wa(fD("ui.dialogs.fileList.openProject")),
                this.MVi.filename.value = ""
            }
            this.dpt = t
        }
        d$e(t) {
            cD.zt(t),
            this.MVi.Pje.rEt = t
        }
        v$e(t) {
            t ? this.Bje ? this.A0() : (this.Bje = !0,
            this.Lje = this.Fje,
            this.Sje("LOCAL STORAGE"),
            this.MVi.refresh.eP(!1),
            this.MVi.Cje.eP(!1),
            this.MVi._je.eP(!1),
            this.MVi.service.eP(!1),
            this.MVi.Tje.eP(!1)) : (this.Bje && (this.Bje = !1,
            this.Sje(null),
            this.MVi.refresh.eP(!0),
            this.MVi.Cje.eP(!0),
            this.MVi._je.eP(!0),
            this.MVi.service.eP(!0),
            this.MVi.Tje.eP(!0)),
            this.Fje ? this.A0() : this.Lje ? (this.Sje(this.Lje),
            this.Lje = null) : this.Zje(null, !0))
        }
        S$e(t, i) {
            return this.Vje = null,
            new Promise(i => {
                this.Kje(),
                this.v$e(t),
                this.zje = i,
                this.fpt("OPEN"),
                t ? this.x$e().then( () => this.Xa()) : this.Xa()
            }
            )
        }
        M$e(t, i, e) {
            cD.gL(t);
            const s = self.app.nI()
              , n = s.hHt()
              , r = s.uHt();
            return this.Vje = "cloud" === n ? r : null,
            new Promise(e => {
                this.MVi.filename.value = t,
                this.Kje(),
                this.v$e(i),
                this.zje = e,
                this.fpt("SAVE"),
                i ? this.x$e().then( () => this.Xa()) : this.Xa()
            }
            )
        }
        Omt() {
            this.Kje()
        }
        x$e() {
            return xD ? Promise.resolve() : cD.QL.z9t ? navigator.storage.persisted().then(t => {
                if (xD = !!t,
                !xD)
                    return this.hNe()
            }
            ) : Promise.resolve()
        }
        hNe() {
            return new Promise(t => {
                let i = cD.Qs.Ks.qs("Confirm");
                i.Xa({
                    message: self.Iet("ui.dialogs.fileList.request-persistence")
                }).then(i => {
                    i || t()
                }
                ),
                i.Pii = () => {
                    const i = navigator.storage.persist().then(t => {
                        if (xD = !!t,
                        !1 === t)
                            return cD.Qs.Ks.qs("OK").Xa(fD("ui.dialogs.fileList.declined-persistence"))
                    }
                    );
                    t(i)
                }
            }
            )
        }
    }
    ;
    cD.Qs.mk.iit.addEventListener("load", () => {
        cD.Qs.Ks.rit(gD, CD)
    }
    )
}
{
    const _D = self.t
      , TD = _D.bW(import.meta.url)
      , ID = TD.getElementById("iframeDialog")
      , PD = _D.IW(TD.URL);
    _D.p.MW(PD + "lang");
    const GD = "iframe"
      , AD = _D.Qs.Fk.E$e = class extends _D.Qs.Ks {
        constructor() {
            super(ID),
            this.C$e = null,
            this.uCt = null
        }
        $et() {}
        lQ(t, i) {
            _D.gL(t);
            const e = super.lQ(i);
            return this.C$e = this.FO().createElement("iframe"),
            this.C$e.className = "dialogiframe",
            this.C$e.setAttribute("allowfullscreen", "true"),
            this.C$e.setAttribute("scrolling", "no"),
            this.C$e.setAttribute("noresize", "noresize"),
            t && (this.C$e.src = t),
            this.C$e.style.pointerEvents = "",
            this.Oet().appendChild(this.C$e),
            e
        }
        _$e(t) {
            _D.U(t, self.jw),
            this.uCt = t
        }
        VMi() {
            this.T$e()
        }
        YMi() {
            this.I$e()
        }
        $Mi() {
            this.T$e()
        }
        XMi() {
            this.I$e()
        }
        T$e() {
            this.C$e.style.pointerEvents = "none"
        }
        I$e() {
            this.C$e.style.pointerEvents = ""
        }
        P$e() {
            return this.C$e
        }
        xet() {
            this._et()
        }
        _et() {
            _D.Abi.G$e() && _D.Abi.k$e().R$e().A$e(this.uCt)
        }
        xO() {
            this.C$e && (this.C$e.src = "",
            _D.Qs.UO(this.C$e),
            this.C$e = null),
            this.uCt = null
        }
    }
    ;
    _D.Qs.mk.iit.addEventListener("load", () => {
        _D.Qs.Ks.rit(GD, AD)
    }
    )
}
{
    const RD = self.t
      , kD = self.lang
      , OD = self.h_
      , DD = RD.bW(import.meta.url)
      , FD = DD.getElementById("loginDialog")
      , LD = RD.IW(DD.URL);
    RD.p.MW(LD + "lang");
    const BD = "Login"
      , UD = "https://account.construct.net"
      , ND = "https://accountbeta.construct.net";
    let jD = null
      , $D = !1
      , zD = null
      , VD = null
      , WD = null;
    function HD(t) {
        const i = t.type
          , e = RD.Qs.Ks.qs("Login")
          , s = self.app.uq("useraccount");
        if ("cancel" === i)
            e.Pct();
        else if ("init" === i)
            $D = !0,
            RD.Qs.UO(e.O$e),
            RD.p.u("ui.dialogs.login"),
            jD({
                type: "lang",
                username: kD(".username"),
                password: kD(".password"),
                "keep-me-logged-in": kD(".keep-me-logged-in"),
                cancel: kD("common.cancel"),
                "log-in": kD(".log-in")
            }),
            RD.p.j(),
            jD({
                type: "auto-login"
            });
        else if ("login-error" === i)
            e.D$e("ManualLoginFailed"),
            e.F$e();
        else if ("login-ok" === i)
            e.D$e("ManualLoginOK"),
            zD(t),
            e.tc() && e.sW(!0);
        else if ("auto-login-ok" === i)
            zD(t);
        else if ("profile-picture" === i)
            s.L$e(t);
        else if ("auto-login-skipped" === i)
            s.B$e(t);
        else if ("auto-login-error" === i) {
            const i = t.reason;
            console.info("[Account] Auto-login failed: " + i),
            e.D$e(i ? "AutoLoginFailed-" + i : "AutoLoginFailed"),
            s.U$e(i || "fetch-error")
        } else if ("access-code-ok" === i)
            s.N$e(t);
        else if ("access-code-error" === i) {
            const i = t.reason;
            console.info("[Account] Access code failed: " + i),
            self.app.j$e() || e.D$e("AccessCodeFailed-" + i),
            s.$$e(i)
        } else
            "get-token-result" === i ? (VD && VD(t.data),
            VD = null,
            WD = null) : "get-token-error" === i ? (WD && WD(),
            VD = null,
            WD = null) : (() => {})("[Account] Invalid message from iframe")
    }
    const KD = RD.Qs.Fk.z$e = class extends RD.Qs.Ks {
        constructor() {
            super(FD),
            this.ght.setAttribute("always-active", ""),
            this.O$e = this.Pet("loginOverlayContent"),
            this.V$e = this.Pet("overlayHeader"),
            this.W$e = this.Pet("overlayMessage"),
            this.H$e = this.Pet("overlayProgress"),
            this.V$e.textContent = kD("ui.dialogs.login.please-wait")
        }
        async K$e(t) {
            if (zD)
                throw new Error("security exception");
            RD.nu(t),
            zD = t;
            const i = self.app
              , e = i.q$e() ? ND : UD
              , s = new URL(e + "/login")
              , n = new URLSearchParams(s.search);
            n.append("theme", i.aU().theme || "default"),
            n.append("lang", i.X7()),
            n.append("productType", i.bne()),
            s.search = n.toString(),
            RD.wQ(this.W$e, RD.v(RD.ix, OD("ui.dialogs.login.login-unavailable-message", e), {
                links: [e + "/test"]
            })),
            window.setTimeout( () => {
                $D || (i.uq("useraccount").X$e(),
                this.W$e.removeAttribute("hidden"),
                this.V$e.textContent = kD("ui.dialogs.login.login-unavailable-header"),
                RD.Qs.UO(this.H$e))
            }
            , 5e3);
            try {
                const t = await RD.kii({
                    src: s.toString(),
                    Oii: e,
                    sandbox: "allow-scripts allow-forms allow-same-origin allow-popups allow-storage-access-by-user-activation",
                    parent: this.Oet(),
                    Dii: t => HD(t.data)
                });
                t.Qa.setAttribute("scrolling", "no"),
                t.Qa.style.display = "",
                t.Qa.style.border = "0",
                jD = t.Fii
            } catch (t) {
                console.error("Failed to load account iframe: ", t)
            }
        }
        $et() {
            RD.p.u("ui.dialogs.login"),
            this.Wa(kD(".caption")),
            RD.p.j()
        }
        Xa(t) {
            return super.Xa(t)
        }
        xet() {}
        async F$e() {
            this.Pct(),
            await RD.Qs.mk.PMi(),
            RD.p.u("ui.dialogs.login.failed-prompt");
            const t = RD.Qs.Ks.qs("Confirm");
            t.Pii = () => {
                RD.Qs.Ks.qs("Login").Xa()
            }
            ,
            t.Xa({
                caption: kD(".caption"),
                message: kD(".message"),
                _nt: kD(".try-again")
            }),
            RD.p.j()
        }
        Y$e() {
            this.D$e("ManualLogout"),
            jD && jD({
                type: "logout"
            })
        }
        J$e() {
            return $D
        }
        Z$e(t, i) {
            if (RD.zt(t),
            RD.gL(i),
            !$D)
                throw new Error("login service unavailable");
            jD({
                type: "access-code",
                code: t,
                privateKey: i
            })
        }
        static Q$e() {
            return $D ? new Promise( (t, i) => {
                VD = t,
                WD = i,
                jD({
                    type: "get-token"
                })
            }
            ) : Promise.reject("login service unavailable")
        }
        VMi() {
            this.T$e()
        }
        YMi() {
            this.I$e()
        }
        $Mi() {
            this.T$e()
        }
        XMi() {
            this.I$e()
        }
        T$e() {
            const t = this.Oet().querySelector("iframe");
            t && (t.style.pointerEvents = "none")
        }
        I$e() {
            const t = this.Oet().querySelector("iframe");
            t && (t.style.pointerEvents = "")
        }
        D$e(t) {
            self.app.XGi("Account", t)
        }
        xO() {
            jD && jD({
                type: "clear"
            })
        }
    }
    ;
    RD.Qs.mk.iit.addEventListener("load", () => {
        RD.Qs.Ks.rit(BD, KD);
        RD.Qs.Ks.qs("Login").YCi()
    }
    )
}
{
    const qD = self.t
      , XD = self.lang
      , YD = qD.bW(import.meta.url)
      , JD = YD.getElementById("newProjectDialog")
      , ZD = qD.IW(YD.URL);
    qD.p.MW(ZD + "lang");
    const QD = "NewProject"
      , tF = qD.Qs.Fk.tze = class extends qD.Qs.Ks {
        constructor() {
            super(JD),
            this.ize = YD.getElementById("npProjectNameInput"),
            this.eze = YD.getElementById("npPresetSelect"),
            this.sze = YD.getElementById("npViewportWidthInput"),
            this.nze = YD.getElementById("npViewportHeightInput"),
            this.rze = this.Pet("viewportAspectRatio"),
            this.hze = YD.getElementById("npOrientationSelect"),
            this.oze = YD.getElementById("npStartWithSelect"),
            this.aze = YD.getElementById("npPixelArtCheck"),
            this.lze = () => this.uze(),
            this.eze.onchange = () => this.cze(),
            this.sze.onchange = this.lze,
            this.nze.onchange = this.lze,
            this.dze = null,
            this.fze = null,
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et()
        }
        $et() {
            qD.p.u("ui.dialogs.newProject"),
            this.Wa(XD(".caption")),
            this.ize.placeholder = XD(".new-project-name"),
            this.Pet("projectNameLabel").textContent = XD(".project-name-label"),
            this.Pet("presetLabel").textContent = XD(".preset-label"),
            this.Pet("viewportSizeLabel").textContent = XD(".viewport-size-label"),
            this.Pet("viewportSizeSeparator").textContent = XD(".viewport-size-separator"),
            this.Pet("orientationLabel").textContent = XD(".orientations-label"),
            this.Pet("startWithLabel").textContent = XD(".start-with-label"),
            this.Pet("pixelArtLabel").textContent = XD(".pixel-art-label"),
            this.o_i.textContent = XD(".create"),
            this.FMt.textContent = XD("common.cancel");
            const t = this.Pet("helpLink");
            t.textContent = XD("common.help"),
            t.onclick = () => self.app.FT("interface/dialogs/new-project", "NewProjectDialog"),
            qD.p.u(".presets");
            for (let t = 0, i = this.eze.options.length; t < i; ++t) {
                const i = this.eze.options[t];
                i.textContent = XD("." + i.value)
            }
            qD.p.j(),
            qD.p.u(".orientations");
            for (let t = 0, i = this.hze.options.length; t < i; ++t) {
                const i = this.hze.options[t];
                i.textContent = XD("." + i.value)
            }
            qD.p.j(),
            qD.p.u(".start-with");
            for (let t = 0, i = this.oze.options.length; t < i; ++t) {
                const i = this.oze.options[t];
                i.textContent = XD("." + i.value)
            }
            qD.p.j(),
            qD.p.j()
        }
        Xa(t) {
            const i = super.Xa(t)
              , e = self.app;
            return e.XGi("NewProject", "NewProjectDialogOpened"),
            this.pze(),
            this.dze = qD.cwi(this.sze, this.lze),
            this.fze = qD.cwi(this.nze, this.lze),
            this.Pet("startWithRow").style.display = e.HA() ? "none" : "",
            e.Mmt() && localforage.getItem("new-project-options").then(t => {
                if (t) {
                    if (this.eze.value = t.preset,
                    this.sze.value = t.viewportWidth,
                    this.nze.value = t.viewportHeight,
                    this.uze(),
                    this.hze.value = t.orientations,
                    !e.HA()) {
                        let i = t.startWith;
                        "script" === i && (i = "javascript"),
                        this.oze.value = i
                    }
                    this.aze.checked = t.pixelArtMode
                }
            }
            ).catch(qD.wS),
            i
        }
        pze() {
            this.ize.value = "",
            this.eze.value = "sd-landscape-16-9",
            this.cze(),
            this.oze.value = "event-sheet",
            this.aze.checked = !1
        }
        xet() {
            if (this.Fxi())
                return;
            const t = self.app
              , i = qD.Uti(this.ize.value) || XD("ui.dialogs.newProject.new-project-name")
              , e = parseInt(this.sze.value, 10)
              , s = parseInt(this.nze.value, 10);
            if (e < 2 || e > 32768 || !isFinite(e))
                return qD.p.u("ui.dialogs.newProject.errors"),
                qD.Qs.Fk.Uk.NT(this.sze, "warning", XD(".invalid-width"), XD(".invalid-width-desc")),
                void qD.p.j();
            if (s < 2 || s > 32768 || !isFinite(s))
                return qD.p.u("ui.dialogs.newProject.errors"),
                qD.Qs.Fk.Uk.NT(this.nze, "warning", XD(".invalid-height"), XD(".invalid-height-desc")),
                void qD.p.j();
            const n = this.sW(!0)
              , r = t.HA() ? "event-sheet" : this.oze.value;
            return t.XGi("NewProject", "NewProjectDialogOK-" + r),
            t.mze(t => {
                t.I(i),
                t.Vse(e),
                t.Ase(s),
                t.Lse(this.hze.value),
                this.aze.checked && (t.Bse(!0),
                t.Fse("letterbox-integer-scale"),
                t.qse("low"),
                t.Use("nearest"));
                const n = t.wze();
                n.Cb(2 * t.HO()),
                n.Ib(2 * t.ma())
            }
            , r),
            t.Mmt() && localforage.setItem("new-project-options", {
                preset: this.eze.value,
                viewportWidth: e,
                viewportHeight: s,
                orientations: this.hze.value,
                startWith: r,
                pixelArtMode: this.aze.checked
            }).catch(qD.wS),
            n
        }
        _et() {
            return self.app.XGi("NewProject", "NewProjectDialogCancel"),
            this.Pct()
        }
        xO() {
            this.dze.Ff(),
            this.dze = null,
            this.fze.Ff(),
            this.fze = null
        }
        cze() {
            const t = this.eze.value;
            if (this.aze.checked = "retro-style" === t,
            "retro-style" === t)
                this.sze.value = 320,
                this.nze.value = 180,
                this.hze.value = "any";
            else if ("sd-landscape-4-3" === t)
                this.sze.value = 640,
                this.nze.value = 480,
                this.hze.value = "landscape";
            else if ("sd-portrait-4-3" === t)
                this.sze.value = 480,
                this.nze.value = 640,
                this.hze.value = "portrait";
            else if ("sd-landscape-16-9" === t)
                this.sze.value = 854,
                this.nze.value = 480,
                this.hze.value = "landscape";
            else if ("sd-portrait-16-9" === t)
                this.sze.value = 480,
                this.nze.value = 854,
                this.hze.value = "portrait";
            else if ("720p-landscape" === t)
                this.sze.value = 1280,
                this.nze.value = 720,
                this.hze.value = "landscape";
            else if ("720p-portrait" === t)
                this.sze.value = 720,
                this.nze.value = 1280,
                this.hze.value = "portrait";
            else if ("1080p-landscape" === t)
                this.sze.value = 1920,
                this.nze.value = 1080,
                this.hze.value = "landscape";
            else if ("1080p-portrait" === t)
                this.sze.value = 1080,
                this.nze.value = 1920,
                this.hze.value = "portrait";
            else if ("4k-landscape" === t)
                this.sze.value = 3840,
                this.nze.value = 2160,
                this.hze.value = "landscape";
            else {
                if ("4k-portrait" !== t)
                    throw new Error("unknown preset");
                this.sze.value = 2160,
                this.nze.value = 3840,
                this.hze.value = "portrait"
            }
            this.uze()
        }
        uze() {
            const t = parseInt(this.sze.value, 10)
              , i = parseInt(this.nze.value, 10);
            t < 2 || i < 2 || t > 32768 || i > 32768 || !isFinite(t) || !isFinite(i) || (this.rze.textContent = self.h_("common.aspect-ratio", ...qD.Cse(t, i)))
        }
    }
    ;
    qD.Qs.mk.iit.addEventListener("load", () => {
        qD.Qs.Ks.rit(QD, tF)
    }
    )
}
{
    const iF = self.t
      , eF = self.lang
      , sF = iF.bW(import.meta.url)
      , nF = sF.getElementById("welcomeTourDialog")
      , rF = iF.IW(sF.URL);
    iF.p.MW(rF + "lang");
    const hF = "WelcomeTour"
      , oF = iF.Qs.Fk.gze = class extends iF.Qs.Ks {
        constructor() {
            super(nF),
            this.yze = this.Pet("tourButton"),
            this.yze.onclick = () => this.xet(),
            this.bze = this.Pet("noThanksLink"),
            this.bze.onclick = () => this._et(),
            this.nEi = !1,
            this.vze = !1
        }
        $et() {
            iF.p.u("ui.dialogs.welcomeTour"),
            this.bze.textContent = eF(".no-thanks"),
            this.Wa(eF(".caption")),
            this.Pet("welcomeMessage").textContent = eF(".welcome-title"),
            iF.wQ(this.Pet("welcomeText"), self.Iet("animation" === self.app.bne() ? ".animate-welcome-text" : ".welcome-text")),
            this.yze.textContent = eF(".tour-button-text") + " " + iF.xJt.qai,
            iF.p.j()
        }
        Xa(t) {
            return this.D$e("Show"),
            this.yze.disabled = !1,
            super.Xa(t)
        }
        D$e(t) {
            self.app.XGi("WelcomeTourDialog", t)
        }
        async xet() {
            if (this.vze)
                return;
            this.vze = !0,
            this.yze.disabled = !0,
            this.D$e("OK-StartTour"),
            await self.app.Dde(!0);
            const t = iF.bme.ed("tour", "animation" === self.app.bne() ? "startWithTimelines" : "makeAPlatformGame");
            await self.app.yme().gme(t),
            this.sW()
        }
        _et() {
            this.vze || (this.vze = !0,
            this.D$e("Cancel"),
            this.Pct())
        }
    }
    ;
    iF.Qs.mk.iit.addEventListener("load", () => {
        iF.Qs.Ks.rit(hF, oF)
    }
    )
}
{
    const aF = self.t
      , lF = self.lang
      , uF = self.e_
      , cF = aF.bW(import.meta.url)
      , dF = cF.getElementById("accountInfoDialog")
      , fF = aF.IW(cF.URL);
    aF.p.MW(fF + "lang");
    const pF = "AccountInfo"
      , mF = new Set(["personal", "gamejam", "access-code", "educational", "startupbusiness", "business"])
      , wF = aF.Qs.Fk.Sze = class extends aF.Qs.Ks {
        constructor() {
            super(dF),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.xze = 256,
            this.Mze = this.Pet("profilePictureWrap"),
            this.Mze.style.width = this.xze + "px",
            this.Mze.style.height = this.xze + "px",
            this.Eze = "",
            this.Cze = null,
            this.Pet("registerAccount").onclick = () => this._ze(),
            this.Pet("loginLink").onclick = () => this.Tze(),
            this.Pet("editProfile").onclick = () => this.Ize()
        }
        $et() {
            aF.p.u("ui.dialogs.accountInfo"),
            this.o_i.textContent = lF("common.close-dialog"),
            this.Wa(lF(".caption")),
            this.Pet("registerAccount").textContent = lF(".register-account"),
            this.Pet("loginLink").textContent = lF(".log-in"),
            this.Pet("editProfile").textContent = lF(".edit-profile"),
            this.Pet("freeLimitHeader").textContent = lF(".free-section-header"),
            this.Pet("maxEventsLabel").textContent = lF(".max-events-label"),
            this.Pet("maxLayersLabel").textContent = lF(".max-layers-label"),
            this.Pet("maxEffectsLabel").textContent = lF(".max-effects-label"),
            this.Pet("maxWebFontsLabel").textContent = lF(".max-webfonts-label"),
            this.Pet("maxJsLineCountLabel").textContent = lF(".max-js-line-count-label"),
            this.Pet("freeLimitUseAccount").textContent = lF(".free-limit-register-account"),
            this.Pet("licenseThankyou").textContent = lF(".license-thankyou");
            const t = self.app
              , i = this.Pet("guestHelpLink");
            i.textContent = lF("common.help"),
            i.onclick = () => t.FT(aF.dQ.URL.XIe, "AccountInfoDialog", "GuestHelp");
            const e = this.Pet("accountHelpLink");
            e.textContent = lF("common.help"),
            e.onclick = () => t.FT(aF.dQ.URL.XIe, "AccountInfoDialog", "AccountHelp");
            const s = this.Pet("yourLicenses");
            s.textContent = lF(".your-licenses"),
            s.onclick = () => t.pQ(aF.dQ.URL.ZIe, "AccountInfoDialog", "YourLicenses"),
            aF.p.j()
        }
        Xa(t, i) {
            this.Cze = t;
            const e = super.Xa(i);
            return this.Pze(),
            e
        }
        Pze() {
            aF.p.u("ui.dialogs.accountInfo");
            const t = self.app;
            if (this.Pet("usernameTitle").textContent = this.Cze.Gze(),
            this.Pet("guestSection").style.display = this.Cze.Gme() ? "none" : "",
            this.Pet("accountSection").style.display = this.Cze.Gme() ? "" : "none",
            this.Pet("freeLimitsSection").style.display = t.CP() ? "" : "none",
            this.Pet("freeLimitUseAccount").style.display = this.Cze.Gme() ? "none" : "",
            this.Pet("accessCodeSection").style.display = t.j$e() ? "" : "none",
            this.Cze.Gme() && this.Cze.Aze()) {
                this.Pet("offlineSection").style.display = "";
                const i = new Date(1e3 * t.Rze())
                  , e = i - Date.now();
                aF.wQ(this.Pet("offlineText"), uF(".offline-mode", i.toLocaleDateString(t.X7(), {
                    weekday: "long",
                    day: "numeric",
                    month: "long",
                    year: "numeric"
                }), e > 0 ? aF.Joi(e / 1e3, {
                    Yoi: !1
                }) : lF("common.time.a-short-while")))
            } else
                this.Pet("offlineSection").style.display = "none";
            aF.Qs.L6(this.Mze);
            const i = this.Pet("licenseBadge");
            i.classList.remove("licenseBadgeFree"),
            i.classList.remove("licenseBadgeLicensed");
            const e = this.Pet("licenseThankyou")
              , s = this.Pet("gameJamSection");
            if (t.CP())
                i.classList.add("licenseBadgeFree"),
                i.textContent = lF(".license-type.free-edition"),
                e.style.display = "none",
                s.style.display = "none",
                this.Pet("maxEventsCount").textContent = t.l3t(),
                this.Pet("maxLayersCount").textContent = t.gnt(),
                this.Pet("maxEffectsCount").textContent = t.kze(),
                this.Pet("maxWebFontsCount").textContent = t.ILt(),
                this.Pet("maxJsLineCount").textContent = t.Vbi();
            else {
                const n = t.Oze();
                i.classList.add("licenseBadgeLicensed"),
                e.style.display = "gamejam" === n ? "none" : "",
                s.style.display = "gamejam" === n ? "" : "none";
                const r = mF.has(n) ? n : "other";
                if (i.textContent = lF(".license-type." + r),
                "gamejam" === n) {
                    const i = new Date(1e3 * t.Rze())
                      , e = i - Date.now();
                    aF.wQ(this.Pet("gameJamText"), uF(".gamejam-info", i.toLocaleDateString(t.X7(), {
                        weekday: "long",
                        day: "numeric",
                        month: "long",
                        year: "numeric"
                    }), e > 0 ? aF.Joi(e / 1e3, {
                        Yoi: !1
                    }) : lF("common.time.a-short-while")))
                } else if ("access-code" === n) {
                    const i = new Date(1e3 * t.Rze())
                      , e = i - Date.now();
                    aF.wQ(this.Pet("accessCodeText"), uF(".access-code-info", i.toLocaleDateString(t.X7(), {
                        weekday: "long",
                        day: "numeric",
                        month: "long",
                        year: "numeric"
                    }), e > 0 ? aF.Joi(e / 1e3, {
                        Yoi: !1
                    }) : lF("common.time.a-short-while")))
                }
            }
            this.Cze.Dze().then(t => {
                this.Eze = URL.createObjectURL(t);
                const i = new Image;
                i.src = this.Eze,
                i.style.width = this.xze + "px",
                i.style.height = this.xze + "px",
                i.alt = lF("user-account.user-avatar"),
                this.Mze.appendChild(i)
            }
            ).catch(t => {
                console.error("Error decoding profile picture: ", t)
            }
            ),
            aF.p.j()
        }
        _ze() {
            this.Cze.a3t(),
            this._et()
        }
        Tze() {
            this.Cze.c3t(),
            this._et()
        }
        Ize() {
            self.app.pQ(aF.dQ.URL.JIe, "EditProfile"),
            this._et()
        }
        xO() {
            this.Cze = null,
            this.Eze && (URL.revokeObjectURL(this.Eze),
            this.Eze = ""),
            aF.Qs.L6(this.Mze)
        }
    }
    ;
    aF.Qs.mk.iit.addEventListener("load", () => {
        aF.Qs.Ks.rit(pF, wF)
    }
    )
}
{
    const gF = self.t
      , yF = self.lang
      , bF = self.h_
      , vF = gF.bW(import.meta.url)
      , SF = vF.getElementById("cordovaBuildReportDialog")
      , xF = gF.IW(vF.URL);
    gF.p.MW(xF + "lang");
    const MF = "CordovaBuildReport"
      , EF = gF.Qs.Fk.Fze = class extends gF.Qs.Ks {
        constructor() {
            super(SF),
            this.MVi = {
                ok: this.Pet("okButton"),
                download: this.Pet("downloadBuiltProject"),
                archive: this.Pet("viewArchive"),
                message: this.Pet("buildFinishedMessage")
            },
            this.MVi.ok.onclick = t => this.xet(),
            this.MVi.download.onclick = t => this.c7(),
            this.MVi.archive.onclick = t => this.Lze(),
            this.Bze = "",
            this.N_i = "",
            this.wki = null
        }
        xO() {
            this.Bze = "",
            this.N_i = "",
            this.wki = null
        }
        $et() {
            gF.p.u("ui.dialogs.cordovaBuildReport");
            const t = this.MVi;
            t.ok.textContent = yF("common.ok"),
            t.message.textContent = yF(".build-finished"),
            t.download.textContent = bF(".download-link", this.N_i),
            t.archive.textContent = yF(".view-archive-manager"),
            this.Wa(bF(".caption", this.Bze)),
            gF.wQ(this.Pet("tutorialLink"), new gF.ix(yF(".tutorial-link"),{
                links: [self.app.jLe("https://www.construct.net/tutorials/how-to-publish-mobile-apps-26")]
            })),
            gF.p.j()
        }
        Xa(t, i, e, s) {
            return gF.zt(t),
            gF.zt(i),
            gF.U(e, Blob),
            this.Bze = t,
            this.N_i = i,
            this.wki = e,
            this.$et(),
            super.Xa(s)
        }
        Lze() {
            gF.Qs.Ks.qs("ArchiveManager").Xa()
        }
        c7() {
            gF.g7(this.N_i, this.wki)
        }
    }
    ;
    gF.Qs.mk.iit.addEventListener("load", () => {
        gF.Qs.Ks.rit(MF, EF)
    }
    )
}
{
    const CF = self.t
      , _F = self.lang
      , TF = self.h_
      , IF = CF.bW(import.meta.url)
      , PF = IF.getElementById("cordovaOptionsDialog")
      , GF = CF.IW(IF.URL);
    CF.p.MW(GF + "lang");
    const AF = "CordovaOptions"
      , RF = !1
      , kF = CF.Qs.Fk.Uze = class extends CF.Qs.Ks {
        constructor() {
            super(PF),
            this.Nze = {
                jze: this.$ze(),
                properties: this.zze(),
                Vze: this.Wze()
            },
            this.Hze = this.Kze(),
            this.XRe = null
        }
        $ze() {
            const t = this.Pet("generalSection")
              , i = this.Pet("generalHeading");
            let e, s, n, r, h;
            {
                const t = this.Pet("androidVersion")
                  , i = t.children[0]
                  , s = t.children[1];
                CF.ibt(i),
                CF.ibt(s),
                e = {
                    element: t,
                    label: i,
                    input: s
                }
            }
            {
                const t = this.Pet("androidTargetVersion")
                  , i = t.children[0]
                  , e = t.children[1];
                CF.ibt(i),
                CF.ibt(e),
                s = {
                    element: t,
                    label: i,
                    qze: e
                }
            }
            {
                const t = this.Pet("iosVersion")
                  , i = t.children[0]
                  , e = t.children[1];
                CF.ibt(i),
                CF.ibt(e),
                n = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            {
                const t = this.Pet("androidTarget")
                  , i = t.children[0]
                  , e = t.children[1];
                CF.ibt(i),
                CF.ibt(e),
                e.addEventListener("change", t => {
                    const i = e.value
                      , s = this.Xze(i);
                    this.Yze(s)
                }
                ),
                r = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            {
                const t = this.Pet("iosTarget")
                  , i = t.children[0]
                  , e = t.children[1];
                CF.ibt(i),
                CF.ibt(e),
                h = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            return {
                container: t,
                title: i,
                Jze: e,
                Zze: s,
                Qze: r,
                tVe: n,
                iVe: h
            }
        }
        zze() {
            const t = this.Pet("propertiesSection")
              , i = this.Pet("propertiesHeading")
              , e = {
                element: this.Pet("whitelist"),
                label: null,
                input: null
            };
            e.label = e.element.children[0],
            e.input = e.element.children[1],
            CF.ibt(e.label, "span"),
            CF.ibt(e.input, "input");
            const s = {
                element: this.Pet("versionCode"),
                label: null,
                input: null
            };
            s.label = s.element.children[0],
            s.input = s.element.children[1],
            CF.ibt(s.label, "span"),
            CF.ibt(s.input, "input");
            const n = {
                element: this.Pet("appLicenseKey"),
                label: null,
                input: null
            };
            n.label = n.element.children[0],
            n.input = n.element.children[1],
            CF.ibt(n.label, "span"),
            CF.ibt(n.input, "input");
            const r = {
                element: this.Pet("hideStatusBar"),
                label: null,
                input: null
            };
            r.input = r.element.children[1],
            r.label = r.element.children[2],
            CF.ibt(r.label, "span"),
            CF.ibt(r.input, "input");
            const h = {
                element: this.Pet("vibratePermission"),
                label: null,
                input: null
            };
            h.input = h.element.children[1],
            h.label = h.element.children[2],
            CF.ibt(h.label, "span"),
            CF.ibt(h.input, "input");
            const o = {
                element: this.Pet("cameraPermission"),
                label: null,
                input: null
            };
            o.input = o.element.children[1],
            o.label = o.element.children[2],
            CF.ibt(o.label, "span"),
            CF.ibt(o.input, "input");
            const a = {
                element: this.Pet("microphonePermission"),
                label: null,
                input: null
            };
            a.input = a.element.children[1],
            a.label = a.element.children[2],
            CF.ibt(a.label, "span"),
            CF.ibt(a.input, "input");
            const l = {
                element: this.Pet("useAssetPack"),
                label: null,
                input: null
            };
            return l.input = l.element.children[1],
            l.label = l.element.children[2],
            CF.ibt(l.label, "span"),
            CF.ibt(l.input, "input"),
            {
                container: t,
                title: i,
                eVe: e,
                sVe: s,
                nVe: n,
                rVe: r,
                hVe: h,
                oVe: o,
                aVe: a,
                lVe: l
            }
        }
        Wze() {
            const t = this.Pet("signingSection")
              , i = this.Pet("propertyHeading");
            let e, s, n, r, h;
            {
                const t = this.Pet("keystore")
                  , i = t.children[0];
                let s;
                CF.ibt(i);
                {
                    const e = t.children[1];
                    CF.ibt(i);
                    const n = e.children[0]
                      , r = e.children[1];
                    CF.ibt(n),
                    CF.ibt(r),
                    s = {
                        element: e,
                        input: n,
                        label: r
                    }
                }
                const n = t.children[2]
                  , r = t.children[4]
                  , h = t.children[5];
                CF.ibt(n),
                CF.ibt(r),
                CF.ibt(h),
                r.addEventListener("click", t => CF.Qs.Ks.qs("CreateKeystoreDialog").Xa()),
                h.addEventListener("click", i => {
                    s.input.value = null,
                    t.removeAttribute("keystore-selected")
                }
                ),
                s.input.addEventListener("change", i => {
                    const e = s.input.files;
                    e[0] ? (t.setAttribute("keystore-selected", ""),
                    n.textContent = e[0].name) : (t.removeAttribute("keystore-selected"),
                    n.textContent = "")
                }
                ),
                e = {
                    element: t,
                    title: i,
                    select: s,
                    name: n,
                    create: r,
                    clear: h
                }
            }
            {
                const t = this.Pet("keyalias")
                  , i = t.children[0]
                  , e = t.children[1];
                CF.ibt(i),
                CF.ibt(e),
                s = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            {
                const t = this.Pet("passwordVisible")
                  , i = t.children[1]
                  , e = t.children[2];
                CF.ibt(e),
                CF.ibt(i),
                n = {
                    element: t,
                    input: i,
                    label: e
                }
            }
            {
                const t = this.Pet("keystorePassword")
                  , i = t.children[0]
                  , e = t.children[1];
                CF.ibt(i),
                CF.ibt(e),
                r = {
                    element: t,
                    input: e,
                    label: i
                }
            }
            {
                const t = this.Pet("keyPassword")
                  , i = t.children[0]
                  , e = t.children[1];
                CF.ibt(i),
                CF.ibt(e),
                h = {
                    element: t,
                    input: e,
                    label: i
                }
            }
            return n.input.addEventListener("change", t => {
                const i = n.input.checked ? "text" : "password";
                r.input.type = i,
                h.input.type = i
            }
            ),
            {
                container: t,
                title: i,
                uVe: e,
                cVe: s,
                dVe: n,
                fVe: r,
                pVe: h
            }
        }
        Kze() {
            const t = this.Pet("helpLink")
              , i = this.Pet("nextButton")
              , e = this.Pet("cancelButton");
            return t.addEventListener("click", t => self.app.FT("interface/dialogs/cordova-options", "CordovaOptionsDialog")),
            i.addEventListener("click", t => this.xet()),
            e.addEventListener("click", t => this._et()),
            {
                mVe: t,
                wVe: i,
                Stt: e
            }
        }
        $et() {
            this.gVe(),
            this.yVe(),
            this.bVe(),
            this.vVe()
        }
        Xze(t) {
            return 0 === t.indexOf("signed")
        }
        SVe(t) {
            const i = t.indexOf("-");
            return i > -1 ? t.slice(i + 1) : t
        }
        gVe() {
            const t = (t, i) => t.textContent = _F(i)
              , i = this.Nze.jze;
            CF.p.u("ui.dialogs.cordovaOptions"),
            t(i.title, ".general"),
            t(i.Jze.label, ".min-version"),
            t(i.Zze.label, ".target-version"),
            t(i.Qze.label, ".android-build"),
            t(i.tVe.label, ".min-version"),
            t(i.iVe.label, ".ios-build"),
            CF.p.u(".builds");
            const e = i.Qze.input;
            t(e.item(0), ".cordova-project"),
            t(e.item(1), ".android-studio-project"),
            t(e.item(2), ".debug-apk"),
            t(e.item(3), ".unsigned-release-apk"),
            t(e.item(4), ".unsigned-app-bundle"),
            t(e.item(5), ".signed-debug-apk"),
            t(e.item(6), ".signed-release-apk"),
            t(e.item(7), ".signed-app-bundle");
            const s = i.iVe.input;
            t(s.item(0), ".cordova-project"),
            t(s.item(1), ".xcode-project"),
            CF.p.j(),
            CF.p.j()
        }
        yVe() {
            const t = (t, i) => t.textContent = _F(i)
              , i = this.Nze.properties;
            CF.p.u("ui.dialogs.cordovaOptions"),
            t(i.title, ".properties"),
            t(i.eVe.label, ".url-whitelist"),
            t(i.rVe.label, ".hide-status-bar"),
            t(i.sVe.label, ".android-version-code"),
            t(i.hVe.label, ".permissions.vibrate"),
            t(i.oVe.label, ".permissions.camera"),
            t(i.aVe.label, ".permissions.microphone"),
            CF.p.j()
        }
        bVe() {
            const t = (t, i) => t.textContent = _F(i)
              , i = this.Nze.Vze;
            CF.p.u("ui.dialogs.cordovaOptions"),
            t(i.title, ".signing"),
            t(i.uVe.select.label, ".choose"),
            t(i.uVe.create, ".create"),
            t(i.uVe.clear, ".clear"),
            t(i.uVe, ".keystore"),
            t(i.cVe.label, ".key-alias"),
            t(i.dVe.label, ".show-passwords"),
            t(i.fVe.label, ".keystore-password"),
            t(i.pVe.label, ".key-password"),
            CF.p.j()
        }
        vVe() {
            CF.p.u("ui.dialogs.cordovaOptions"),
            this.Wa(_F(".caption"));
            const t = (t, i) => t.textContent = _F(i)
              , i = this.Hze;
            t(i.mVe, "common.help"),
            t(i.wVe, "common.next"),
            t(i.Stt, "common.cancel"),
            CF.p.j()
        }
        xVe(t) {
            var i, e;
            i = this.Nze.properties.container,
            e = t,
            i.style.display = e ? "" : "none"
        }
        Yze(t) {
            const i = this.Nze.Vze;
            var e, s;
            e = i.container,
            s = t,
            e.style.display = s ? "" : "none",
            t || (i.pVe.input.value = "",
            i.fVe.input.value = "",
            i.cVe.input.value = "",
            i.uVe.select.input.value = null,
            i.uVe.name.textContent = "",
            i.uVe.element.removeAttribute("keystore-selected"))
        }
        MVe() {
            const t = this.Nze.jze.Qze
              , i = t.input.value
              , e = "" === t.element.style.display
              , s = this.Xze(i);
            this.Yze(e && s)
        }
        async EVe(t, i, e) {
            CF.zt(t),
            CF.zt(i),
            CF.mGt(e);
            const s = "android" !== t
              , n = "ios" !== t
              , r = await this.CVe(i);
            return this._Ve(r),
            this.XRe = t,
            this.TVe(n, s, !1, !1),
            this.xVe(!1),
            this.MVe(),
            super.Xa(e)
        }
        async Xa(t, i) {
            CF.IL(t);
            const e = t.platform
              , s = t.version
              , n = !!t.IVe;
            CF.zt(e),
            CF.zt(s),
            CF.mGt(i);
            const r = "android" === e
              , h = "ios" === e
              , o = await this.CVe(s);
            if (this._Ve(o),
            this.XRe = e,
            this.TVe(r, h, !0, !0),
            this.xVe(!0),
            this.MVe(),
            h) {
                const t = this.Nze.jze.tVe.input;
                n ? (CF.Qs.eit(t.options[0], "disabled", n),
                "1500" === t.value && (t.value = "1600")) : CF.Qs.eit(t.options[0], "disabled", !1)
            }
            return super.Xa(i)
        }
        async CVe(t) {
            CF.zt(t);
            const i = await localforage.getItem("cordova-export-options") || {}
              , e = this.PVe(t);
            return {
                androidVersion: Math.max(parseInt(i.androidVersion) || 700, 700),
                androidTarget: "cordova",
                iosVersion: Math.max(i.iosVersion || 1500, 1500),
                iosTarget: "cordova",
                hideStatusBar: i.hideStatusBar || !1,
                permissionVibrate: i.permissionVibrate || !1,
                permissionCamera: i.permissionCamera || !1,
                permissionMicrophone: i.permissionMicrophone || !1,
                whitelist: "http://*/* https://*/*",
                versionCode: e,
                useAssetPack: i.useAssetPack || !1,
                generateAssetManifest: i.generateAssetManifest || !1,
                assetPackLocation: ""
            }
        }
        PVe(t) {
            CF.zt(t);
            const i = /^(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?$/.exec(t);
            if (!i)
                throw new Error("Invalid version number");
            return 100 * (100 * (100 * +i[1] + (+i[2] || 0)) + (+i[3] || 0)) + (+i[4] || 0)
        }
        GVe(t) {
            if ("number" !== t.type)
                throw new Error("Invalid type on input");
            const i = t.min ? parseFloat(t.min) : -1 / 0
              , e = t.max ? parseFloat(t.max) : 1 / 0;
            if (i > e)
                throw new Error("Invalid min/max on input");
            const s = parseFloat(t.value);
            return isNaN(s) || s < i || s > e
        }
        AVe() {
            const t = this.Nze.properties
              , i = this.Nze.jze;
            return {
                androidVersion: i.Jze.input.value,
                androidTarget: i.Qze.input.value,
                iosVersion: i.tVe.input.value,
                iosTarget: i.iVe.input.value,
                hideStatusBar: t.rVe.input.checked,
                permissionVibrate: t.hVe.input.checked,
                permissionCamera: t.oVe.input.checked,
                permissionMicrophone: t.aVe.input.checked,
                whitelist: t.eVe.input.value,
                versionCode: t.sVe.input.value,
                useAssetPack: t.lVe.input.checked,
                licenseKey: t.nVe.input.value,
                keystore: null,
                alias: null,
                ksPassword: null,
                kPassword: null
            }
        }
        RVe(t) {
            const i = this.Nze.Vze;
            return t.keystore = i.uVe.select.input.files[0],
            t.alias = i.cVe.input.value,
            t.ksPassword = i.fVe.input.value,
            t.kPassword = i.pVe.input.value || i.fVe.input.value,
            t
        }
        kVe(t) {
            if (!t.keystore)
                throw new Error("Please specify the keystore.");
            if (!t.alias)
                throw new Error("Please specify the alias.");
            if (!t.ksPassword)
                throw new Error("Please specify the keystore password.")
        }
        _Ve(t) {
            const {jze: i, properties: e} = this.Nze;
            i.Jze.input.value = t.androidVersion;
            const s = CF.FVe.DVe.OVe();
            i.Zze.qze.textContent = TF("ui.dialogs.cordovaOptions.android-target-version-info", s.Jze, s.LVe),
            i.tVe.input.value = t.iosVersion,
            e.sVe.input.value = t.versionCode,
            e.rVe.input.checked = t.hideStatusBar,
            e.oVe.input.checked = t.permissionCamera,
            e.hVe.input.checked = t.permissionVibrate,
            e.aVe.input.checked = t.permissionMicrophone,
            e.eVe.input.value = t.whitelist
        }
        TVe(t, i, e, s) {
            const n = (t, i) => t.style.display = i ? "" : "none"
              , r = this.Nze.jze;
            n(r.Qze.element, t),
            n(r.Zze.element, t),
            n(r.Jze.element, s && t),
            n(r.iVe.element, i),
            n(r.tVe.element, s && i);
            const h = this.Nze.properties;
            n(h.lVe.element, RF && t),
            n(h.nVe.element, RF && t),
            n(h.sVe.element, t);
            const o = r.Qze.input.options
              , a = r.iVe.input.options;
            e ? (o[0].removeAttribute("hidden"),
            a[0].removeAttribute("hidden")) : (o[0].setAttribute("hidden", ""),
            0 == o.selectedIndex && (o.selectedIndex = 1),
            a[0].setAttribute("hidden", ""),
            0 == a.selectedIndex && (a.selectedIndex = 1))
        }
        xet() {
            if (this.GVe(this.Nze.properties.sVe.input)) {
                return void CF.Qs.Ks.qs("OK").Xa(self.Iet("ui.dialogs.cordovaOptions.invalid-version-code"))
            }
            const t = this.AVe()
              , i = "ios" !== this.XRe
              , e = t.androidTarget
              , s = this.Xze(e)
              , n = i && s;
            if (localforage.setItem("cordova-export-options", t).catch(t => self.app._we(t)),
            n) {
                const i = this.RVe(t);
                try {
                    this.kVe(i)
                } catch (t) {
                    return void (() => {})(t)
                }
            }
            this.sW(t)
        }
        xO() {}
    }
    ;
    CF.Qs.mk.iit.addEventListener("load", () => {
        CF.Qs.Ks.rit(AF, kF)
    }
    )
}
{
    const OF = self.t
      , DF = self.lang
      , FF = OF.bW(import.meta.url)
      , LF = FF.getElementById("archiveManagerDialog")
      , BF = OF.IW(FF.URL)
      , UF = "C3_Archive_Manager"
      , NF = 10;
    OF.p.MW(BF + "lang");
    const jF = "ArchiveManager"
      , $F = OF.Qs.Ks.BVe = class extends OF.Qs.Ks {
        constructor() {
            super(LF),
            this.e2 = OF.v(OF.Qs.v2, LF, this),
            OF.p.u("ui.dialogs.archive-manager");
            const t = OF.Qs.v2.vwe(28)
              , i = self.app;
            this.Wa(DF(".caption")),
            this.i2 = this.e2.S2("horizontalToolbar", t, [OF.Qs.v2.C2("upload", i.oi("add"), DF(".toolbar.upload"), () => this.bje(), !1), OF.Qs.v2.C2("download", i.oi("download"), DF(".toolbar.download"), () => this.c7(), !0), OF.Qs.v2.YA(), OF.Qs.v2.C2("delete", i.oi("delete"), DF(".toolbar.delete"), () => this.ZEt(), !0), OF.Qs.v2.YA(), OF.Qs.v2.C2("build", i.oi("build"), DF(".toolbar.build"), () => this.UVe(), !0)]),
            this.lDe = !1,
            this.NVe = !1,
            this.e2.g_();
            const e = this.e2.X0()
              , s = OF.v(OF.Qs.Fk.Table, e, {
                $qi: !1
            });
            this.fCt = null,
            this.Qyi = new Map,
            this.MVi = {
                upload: this.i2.c2("upload"),
                download: this.i2.c2("download"),
                delete: this.i2.c2("delete"),
                jVe: this.i2.c2("build"),
                Ije: e,
                table: s
            },
            s.Aet().Get("project", 150, DF(".columns.project")).Get("version", 50, DF(".columns.version")).Get("exporter", 80, DF(".columns.exporter")).Get("created", 130, DF(".columns.created")).Get("type", 150, DF(".columns.type")).jet("size", DF(".columns.size")),
            s.ket(),
            s.addEventListener("rowcontextmenu", t => this.gO(t)),
            s.addEventListener("rowselected", t => this.$Ve(t.Eet)),
            s.addEventListener("rowunselected", t => this.zVe(t.Eet)),
            OF.p.j()
        }
        async bje() {
            if (await self.app.$T())
                return void self.app.RP(null, 21);
            const t = new OF.Qs.ZCi;
            let i = await t.Xa(".zip");
            if (null === i)
                return;
            const e = new OF.u7;
            let s;
            try {
                await e._ct(i);
                const t = e.Ict("config.json");
                s = await e.fbi(t)
            } catch (t) {
                console.error("Error processing zip file: ", t),
                e.Sct();
                return void OF.Qs.Ks.qs("OK").Xa(DF("ui.dialogs.archive-manager.error.invalid-file"))
            }
            const n = s.android
              , r = s.ios;
            let h = null;
            if (n && r)
                h = "c2";
            else if (n)
                h = "android";
            else {
                if (!r) {
                    return void OF.Qs.Ks.qs("OK").Xa(DF("ui.dialogs.archive-manager.error.invalid-file"))
                }
                h = "ios"
            }
            if ("c2" == h)
                try {
                    i = await this.VVe(i, e, JSON.stringify(s))
                } catch (t) {
                    console.error("Error processing zip file: ", t);
                    return void OF.Qs.Ks.qs("OK").Xa(DF("ui.dialogs.archive-manager.error.invalid-file"))
                }
            return e.Sct(),
            this.WVe(i, s.name, h, "cordova", Date.now(), i.name, s.version)
        }
        async VVe(t, i, e) {
            const s = OF.Qs.Ks.qs("Progress");
            s.Xa("");
            try {
                const s = OF.FVe.DVe.dQ.HVe(e);
                if (s.KVe()) {
                    const t = new Map;
                    for (const e of i.abi()) {
                        const s = await i.Gct(e);
                        t.set(e.filename, s)
                    }
                    s.qVe(!1),
                    s.XVe("cordova-plugin-statusbar", null),
                    s.XVe("cordova-plugin-fullscreen", null),
                    t.set("config.json", s.YVe());
                    const e = t.get("www/c2runtime.js");
                    if (!e)
                        throw new Error("Unable to find runtime");
                    return t.set("www/c2runtime.js", new Blob([e, this.JVe()]), {
                        type: e.type
                    }),
                    await i.f7(t)
                }
                return t
            } finally {
                s.sW()
            }
        }
        JVe() {
            return ';\n(function () {\nvar previousWidth = -1;\nvar previousHeight = -1;\n\nfunction tick ()\n{\n\trequestAnimationFrame(tick);\n\n\tvar isPortrait = window.innerWidth < window.innerHeight;\n\n\tvar height = isPortrait ? window["screen"]["height"] : window["screen"]["width"];\n\tvar width = isPortrait ? window["screen"]["width"] : window["screen"]["height"];\n\n\tif (previousHeight == height && previousWidth == width)\n\t\treturn;\n\n\tpreviousHeight = height;\n\tpreviousWidth = width;\n\n\tvar docStyle = document["documentElement"].style;\n\tvar bodyStyle = document["body"].style;\n\n\tif (height && width)\n\t{\n\t\tbodyStyle["height"] = docStyle["height"] = height + "px";\n\t\tbodyStyle["width"] = docStyle["width"] = width + "px";\n\t}\n}\n\nfunction enterFullscreen ()\n{\n\t// ios - hide statusbar\n\tif (typeof window["StatusBar"] === "object")\n\t\twindow["StatusBar"]["hide"]();\n\n\t// android - hide status and nav bar\n\tif (typeof window["AndroidFullScreen"] === "object")\n\t\twindow["AndroidFullScreen"]["immersiveMode"]();\n}\n\ndocument.addEventListener("deviceready", function () {\n\tvar ua = navigator.userAgent;\n\tvar isMicrosoftEdge = /edge\\//i.test(ua);\n\tvar isIE = (/msie/i.test(ua) || /trident/i.test(ua) || /iemobile/i.test(ua)) && !isMicrosoftEdge;\n\tvar isiPhone = (/iphone/i.test(ua) || /ipod/i.test(ua)) && !isIE && !isMicrosoftEdge;\t// treat ipod as an iphone; IE mobile masquerades as iPhone\n\n\tenterFullscreen();\n\tif (isiPhone && window["screen"])\n\t\ttick();\n});\n})();'
        }
        c7() {
            if (!this.fCt)
                throw new Error("No entry selected");
            OF.g7(this.fCt.filename, this.fCt.blob)
        }
        ZEt() {
            if (!this.fCt)
                throw new Error("No entry selected");
            const t = this.fCt;
            this.fCt = null,
            this.ZVe().then( () => {
                this.Qyi.delete(t.uid),
                this.QVe(),
                this.tWe()
            }
            )
        }
        async UVe() {
            if (await self.app.$T())
                return void self.app.RP(null, 21);
            const t = this.fCt;
            if (!t)
                throw new Error("No entry selected");
            const i = t.blob
              , e = t.project
              , s = t.exporter
              , n = t.version
              , r = OF.Qs.Ks.qs("CordovaOptions");
            let h;
            if (h = "ios" === s ? {
                iosTarget: "project"
            } : await r.EVe(s, n),
            !h)
                return;
            const o = {};
            return "c2" != s && "android" != s || (o.android = h.androidTarget),
            "c2" != s && "ios" != s || (o.ios = h.iosTarget),
            o.android && 0 === o.android.indexOf("signed") && (o.sign = await this.iWe(h)),
            this.Pct(),
            this.eWe(i, e, s, o, n)
        }
        gO() {}
        $Ve(t) {
            this.fCt = t.Do();
            const i = "cordova" === this.fCt.type;
            this.MVi.jVe.I2(i && !this.NVe),
            this.MVi.download.I2(!0),
            this.MVi.delete.I2(!0)
        }
        zVe() {
            this.fCt = null,
            this.MVi.jVe.I2(!1),
            this.MVi.download.I2(!1),
            this.MVi.delete.I2(!1)
        }
        $et() {}
        sWe(t, i) {
            if ("cordova" === i)
                return "Cordova Project";
            if ("android" === t) {
                const t = i.indexOf("-")
                  , e = 0 === i.indexOf("signed");
                switch (t > -1 ? i.slice(t + 1) : i) {
                case "signed":
                    return "Signed Release APK";
                case "project":
                    return "Android Studio Project";
                case "debug":
                    return e ? "Signed Debug APK" : "Debug APK";
                case "release":
                    return e ? "Signed Release APK" : "Unsigned Release APK";
                case "bundle":
                    return e ? "Signed App Bundle" : "Unsigned App Bundle"
                }
            }
            return "ios" === t && "project" === i ? "Xcode Project" : OF.Zoi(i)
        }
        nWe() {
            return localforage.getItem(UF).catch( () => {}
            ).then(t => {
                this.lDe = !0,
                t = t || [];
                for (const i of t) {
                    let t = this.Qyi.get(i.uid);
                    t || (this.Qyi.set(i.uid, i),
                    t = i),
                    i.saved = !0
                }
            }
            )
        }
        async ZVe() {
            await OF.Abi.yrt(),
            this.lDe || await this.nWe()
        }
        async QVe() {
            if (!this.lDe)
                throw new Error("Local entries not loaded");
            const t = Array.from(this.Qyi.values());
            try {
                await localforage.setItem(UF, t);
                for (const t of this.Qyi.values())
                    t.saved = !0
            } catch (t) {}
        }
        rWe(t) {
            self.app._we(t, DF("ui.dialogs.archive-manager.error.storage-fail"))
        }
        tWe() {
            const t = this.MVi.table;
            t.Ry();
            const i = Array.from(this.Qyi.values()).sort( (t, i) => i.created - t.created);
            for (const e of i) {
                const i = e.project
                  , s = "ios" == e.exporter ? "iOS" : OF.Zoi(e.exporter)
                  , n = new Date(e.created).toLocaleString(self.app.X7(), {
                    day: "numeric",
                    month: "short",
                    year: "numeric",
                    hour: "numeric",
                    minute: "numeric"
                })
                  , r = this.sWe(e.exporter, e.type)
                  , h = OF.Woi(e.size)
                  , o = e.version;
                t.Wet(e).Yet("project", i).Yet("version", o).Yet("exporter", s).Yet("created", n).Yet("type", r).Yet("size", h)
            }
        }
        async iWe(t) {
            OF.U(t.keystore, Blob),
            OF.zt(t.alias),
            OF.zt(t.ksPassword),
            OF.zt(t.kPassword);
            const i = await OF.zii(t.keystore)
              , e = new Uint8Array(i);
            return {
                keystore: OF.xei(e),
                ksPassword: t.ksPassword,
                kPassword: t.kPassword,
                alias: t.alias
            }
        }
        async WVe(t, i, e, s, n, r, h) {
            OF.U(t, Blob),
            OF.zt(i),
            OF.zt(e),
            OF.zt(s),
            OF.Ge(n),
            OF.zt(h);
            const o = {
                project: i,
                exporter: e,
                created: n,
                type: s,
                size: t.size,
                saved: !1,
                filename: r,
                blob: t,
                version: h,
                uid: OF.tai()
            };
            if (this.Qyi.set(o.uid, o),
            await this.ZVe(),
            this.Qyi.size > NF) {
                const t = Array.from(this.Qyi.values()).sort( (t, i) => i.created - t.created);
                for (; t.length > NF; ) {
                    const i = t.pop();
                    this.Qyi.delete(i.uid)
                }
            }
            return await this.QVe(),
            this.tc() && this.tWe(),
            o
        }
        async eWe(t, i, e, s, n) {
            let r, h;
            OF.U(t, Blob),
            OF.zt(i),
            OF.zt(e),
            OF.J1(s),
            OF.zt(n),
            this.hWe(),
            "c2" == e ? (r = "multiple",
            h = `${i}.multiple`) : (r = s[e],
            h = `${i}.${e}.${r}`),
            s.android && 0 === s.android.indexOf("signed") && (s.android = s.android.slice(7));
            const o = OF.v(OF.Qs.Ks.BVe.oWe, t, h, s);
            try {
                const t = await o.aWe();
                this.lWe(),
                this.uWe(t, i, e, r, n);
                OF.Qs.Ks.qs("CordovaBuildReport").Xa(i, t.name, t)
            } catch (t) {
                this.lWe(t)
            }
        }
        async cWe(t, i, e, s, n, r) {
            OF.U(t, Blob),
            OF.zt(i),
            OF.zt(e),
            OF.zt(s),
            OF.zt(n),
            OF.ML(r),
            this.hWe();
            const h = {
                [e]: s,
                sign: r
            }
              , o = `${i}.${e}.${s}`;
            h.android && 0 === h.android.indexOf("signed") && (h.android = h.android.slice(7));
            const a = OF.v(OF.Qs.Ks.BVe.oWe, t, o, h);
            try {
                const t = await a.aWe();
                this.lWe(),
                this.uWe(t, i, e, s, n);
                OF.Qs.Ks.qs("CordovaBuildReport").Xa(i, t.name, t)
            } catch (t) {
                this.lWe(t)
            }
        }
        dWe(t) {
            OF.U(t, self.vvi);
            const i = t.Cn()
              , e = t.Wrt()
              , s = e.fWe
              , n = e.tag
              , r = i.La()
              , h = Date.now()
              , o = i.a6();
            return s ? this.WVe(s, r, n, "zip", h, `${r}.${n}.zip`, o) : Promise.resolve()
        }
        pWe(t) {
            OF.U(t, self.vvi);
            const i = t.Cn()
              , e = t.Wrt()
              , s = e.fWe
              , n = e.tag
              , r = i.La()
              , h = Date.now()
              , o = i.a6();
            return this.WVe(s, r, n, "cordova", h, `${r}.${n}.cordova.zip`, o)
        }
        uWe(t, i, e, s, n) {
            OF.M4(t),
            OF.zt(i),
            OF.zt(e),
            OF.zt(s),
            OF.zt(n);
            const r = Date.now();
            return this.WVe(t, i, e, s, r, t.name, n)
        }
        async mWe(t) {
            OF.U(t, self.vvi);
            const i = t.Cn()
              , e = t.Wrt()
              , s = e.fWe
              , n = e.tag
              , r = e.wWe.cordova
              , h = i.La()
              , o = i.a6();
            let a;
            if ("android" === n && (a = r.androidTarget),
            "ios" === n && (a = r.iosTarget),
            "cordova" === a) {
                this.pWe(t);
                OF.Qs.Ks.qs("CordovaExportReport").Xa(t)
            } else {
                let t = null;
                0 === a.indexOf("signed") && (t = await this.iWe(r)),
                await this.cWe(s, h, n, a, o, t)
            }
        }
        gWe() {
            return this.NVe
        }
        hWe() {
            if (this.NVe)
                throw new Error("Already building");
            this.MVi.jVe.I2(!1),
            this.NVe = !0
        }
        lWe(t=null) {
            if (this.NVe = !1,
            null !== t) {
                OF.p.u("ui.dialogs.archive-manager.error");
                const i = DF(".build-fail")
                  , e = DF(".build-failure-message");
                if (OF.p.j(),
                t instanceof Error) {
                    return OF.Qs.Ks.qs("ShellOutput").Xa(i, e, t.message)
                }
                if ("string" == typeof t) {
                    return OF.Qs.Ks.qs("ShellOutput").Xa(i, e, t)
                }
                return OF.Qs.Ks.qs("OK").Xa(i)
            }
        }
        async Xa(t) {
            return await this.ZVe(),
            this.tWe(),
            super.Xa(t)
        }
        LCi() {
            super.LCi()
        }
        xet() {}
        _et() {
            super._et()
        }
        static yWe() {
            return UF
        }
    }
    ;
    OF.Qs.mk.iit.addEventListener("load", function() {
        OF.Qs.Ks.rit(jF, $F)
    })
}
{
    const zF = self.t
      , VF = zF.p.Yue("ui.build-service-status")
      , WF = new Map([["Waiting to build", "waiting-to-build"], ["Preparing project", "preparing-project"], ["Building Android", "building-android"], ["Building iOS", "building-ios"], ["Compressing builds", "compressing-builds"], ["Project uploaded successfully", "upload-complete"], ["Connection restored", "connection-restored"], ["Build complete, beginning transfer", "build-complete"]]);
    function HF(t) {
        const i = WF.get(t);
        return i ? VF("." + i) : t
    }
    const KF = "wss://build.construct.net/"
      , qF = 5
      , XF = 5e3
      , YF = Symbol("init")
      , JF = Symbol("uploading")
      , ZF = Symbol("downloading");
    zF.Qs.Ks.BVe.oWe = class {
        constructor(t, i, e) {
            const s = !!e.ios
              , n = !!e.android;
            this.Ngi = null,
            this.bWe = null,
            this.vWe = null,
            this.SWe = t,
            this.xWe = 0,
            this.MWe = 1,
            this.pwi = YF,
            this.EWe = null,
            this.CWe = i,
            this._We = null,
            this.TWe = null,
            this.IWe = null,
            this.PWe = !1,
            this.GWe = e,
            this.XRe = null,
            this.mo = null,
            this.AWe = -1,
            n && s ? this.XRe = "c2" : n ? this.XRe = "android" : s && (this.XRe = "ios"),
            this.aGt = e[this.XRe] || null,
            this.RWe = qF,
            this.kWe = VF(".prefix");
            let r = zF.Qs.Fk
              , h = zF.v(r.YKi);
            this.hqi = h,
            this.OWe = zF.v(r.aqi, h, this.kWe + VF(".transfer-progress")),
            this.DWe = zF.v(r.dqi, h, "")
        }
        he() {
            -1 !== this.AWe && (clearTimeout(this.AWe),
            this.AWe = -1),
            this.TWe && this.TWe.Ff(),
            this.IWe && this.IWe.Ff(),
            this.TWe = null,
            this.IWe = null,
            this.Ngi && (this.Ngi.Ggt(),
            this.Ngi = null),
            this.bWe = null,
            this.vWe = null,
            this.SWe = null,
            this.OWe.FR(),
            this.hqi.he(),
            this.hqi = null,
            this.OWe = null,
            this.DWe = null
        }
        FWe() {
            return `${this.XRe}${this.aGt ? "-" + this.aGt : ""}`
        }
        XGi(t) {
            self.app.XGi("BuildService", t + "-" + this.FWe())
        }
        async ke() {
            this.XGi("StartedBuild"),
            await this.LWe(this.SWe),
            await Promise.all([this.BWe(), this.UWe().then(t => this.NWe())])
        }
        async aWe() {
            try {
                await this.ke(),
                this.XGi("BuildCompleted");
                const t = this.CWe + this._We;
                return zF.Mct(this.vWe, t)
            } catch (t) {
                throw this.XGi("BuildFailed"),
                t
            } finally {
                this.he()
            }
        }
        jWe() {
            this.RWe--,
            this.PWe = !1,
            this.TWe && (this.TWe.Ff(),
            this.TWe = null),
            this.RWe > 0 ? (this.$We(VF(".lost-connection")),
            -1 !== this.AWe && clearTimeout(this.AWe),
            this.AWe = setTimeout( () => this.zWe(), XF)) : this.mo()
        }
        VWe() {
            this.$We(VF(".connected-to-server")),
            this.PWe = !0,
            this.TWe = zF._f.Gf(this.Ngi, "close", () => this.jWe())
        }
        async zWe() {
            try {
                await this.Ngi.iyi(),
                await this.WWe()
            } catch (t) {
                return void (() => {})(t)
            }
        }
        L_i() {
            this.OWe.uqi(this.xWe / this.MWe)
        }
        $We(t) {
            t = HF(t),
            console.log(`${this.kWe} ${t}`),
            this.DWe && this.DWe.ha(`${this.kWe} ${t}`)
        }
        async NWe() {
            const t = this.bWe;
            for (this.pwi = JF; t.length > 0; ) {
                const i = t.shift();
                try {
                    const e = 0 === t.length;
                    await this.Ngi.pyi(e ? "END" : "CNK", i),
                    this.xWe += i.length,
                    this.L_i()
                } catch (e) {
                    throw t.unshift(i),
                    e
                }
            }
            this.OWe.FR()
        }
        async LWe() {
            this.MWe = this.SWe.size;
            const t = await zF.zii(this.SWe);
            this.bWe = await zF.Sei(t, Uint8Array, 65536)
        }
        BWe() {
            return this.Ngi = zF.v(zF.WebSocket, KF),
            this.IWe = zF._f.Gf(this.Ngi, "open", () => this.VWe()),
            this.Ngi.eyi("STS", t => this.$We(t)),
            this.HWe()
        }
        HWe() {
            return this.Ngi.ayi("SRT", t => {
                this.pwi = ZF,
                this.vWe = [],
                this.MWe = t.size,
                this._We = t.ext || ".zip"
            }
            ),
            this.Ngi.hyi("RES", t => {
                this.vWe.push(t),
                this.xWe += t.length,
                this.L_i()
            }
            ),
            new Promise( (t, i) => {
                this.mo = () => i("Cannot connect to build server"),
                this.Ngi.eyi("ERR", i),
                this.Ngi.eyi("DON", t)
            }
            )
        }
        async UWe(t) {
            this.$We(VF(".connecting"));
            try {
                return await this.KWe(t)
            } catch (t) {
                if (!(t instanceof zF.Event && "close" === t.type))
                    throw t;
                (() => {})("no connection")
            }
            let i = 1;
            for (; i < qF; ) {
                await zF.Jti(XF);
                try {
                    return await this.Ngi.iyi(),
                    void await this.KWe(t)
                } catch (t) {
                    if (!(t instanceof zF.Event && "close" === t.type))
                        throw t;
                    i++
                }
            }
            this.mo()
        }
        async KWe(t) {
            const i = Object.assign({}, this.GWe);
            t && (i.uuid = t);
            const e = self.app;
            i.pt = e.bne(),
            i.rc = e.oNe(),
            i.lh = e.qWe();
            const s = this.Ngi
              , [n,r] = await Promise.all([s.cyi("RDY"), s.byi("CRT", i)]);
            this.EWe = n
        }
        async WWe() {
            let t = this.EWe;
            await this.UWe(this.EWe),
            t !== this.EWe ? (await this.LWe(),
            await this.NWe()) : this.pwi === JF && await this.NWe()
        }
        static async XWe(t) {
            const i = await zF.WebSocket.Syi(KF);
            try {
                await i.byi("KEY", t);
                const e = await Promise.race([Promise.all([i.fyi("RES"), i.cyi("INF")]), i.cyi("ERR")]);
                if ("string" == typeof e)
                    throw new Error(e);
                const s = /Certificate fingerprints\:[\s\S]+SHA1: ([^\n]+)/m.exec(e[1]);
                return [new Blob([e[0]]), s ? s[1] : "FAIL SIGNATURE"]
            } finally {
                i.Ggt()
            }
        }
    }
}
{
    const QF = self.t
      , tL = self.lang
      , iL = QF.bW(import.meta.url)
      , eL = iL.getElementById("audioPreviewDialog")
      , sL = QF.IW(iL.URL);
    QF.p.MW(sL + "lang");
    const nL = "AudioPreview"
      , rL = QF.Qs.Fk.YWe = class extends QF.Qs.Ks {
        constructor() {
            super(eL),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.JWe = null,
            this.ZWe = ""
        }
        $et() {
            this.o_i.textContent = tL("common.close-dialog"),
            this.Wa(tL("ui.dialogs.audioPreview.caption"))
        }
        async Xa(t, i) {
            const e = this.Oet()
              , s = document.createElement("h3");
            s.textContent = self.h_("ui.dialogs.audioPreview.audio-title", this.QWe(t), this.tHe(t), this.iHe(t));
            const n = document.createElement("audio");
            return n.src = await this.eHe(t),
            n.controls = !0,
            n.autoplay = !0,
            this.JWe = n,
            e.appendChild(s),
            e.appendChild(n),
            super.Xa(i)
        }
        tHe(t) {
            return QF.Bm(t, globalThis.e0) ? t.cst().gpi() : QF.MimeType.Chi(t).gpi()
        }
        QWe(t) {
            return QF.Bm(t, globalThis.e0) ? t.s0() : t.name
        }
        iHe(t) {
            return QF.Bm(t, globalThis.e0) ? QF.Woi(t.lS().size) : QF.Woi(t.size)
        }
        async eHe(t) {
            return QF.Bm(t, globalThis.e0) ? t.SLt() : (this.ZWe = URL.createObjectURL(t),
            this.ZWe)
        }
        xO() {
            QF.Qs.L6(this.Oet()),
            this.JWe.pause(),
            this.JWe = null,
            this.ZWe && URL.revokeObjectURL(this.ZWe),
            this.ZWe = ""
        }
    }
    ;
    QF.Qs.mk.iit.addEventListener("load", () => {
        QF.Qs.Ks.rit(nL, rL)
    }
    )
}
{
    const hL = self.t
      , oL = self.lang
      , aL = hL.bW(import.meta.url)
      , lL = aL.getElementById("chooseKeyDialog")
      , uL = hL.IW(aL.URL);
    hL.p.MW(uL + "lang");
    const cL = "ChooseKey"
      , dL = hL.Qs.Fk.sHe = class extends hL.Qs.Ks {
        constructor() {
            super(lL),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.nHe = this.Pet("chooseKeyDisplay"),
            this.rHe = this.Pet("chooseKeyDropdown"),
            this.rHe.addEventListener("change", () => this.hHe()),
            this.pG = t => this.wG(t),
            this.oHe = -1
        }
        $et() {
            hL.p.u("ui.dialogs.chooseKey"),
            this.o_i.textContent = oL("common.ok"),
            this.FMt.textContent = oL("common.cancel"),
            this.Wa(oL(".caption")),
            this.Pet("chooseKeyNumLockNote").textContent = oL(".num-lock-note"),
            this.Pet("chooseKeyOrUseDropdownNote").textContent = oL(".or-use-dropdown-note"),
            this.rHe.item(0).textContent = oL(".dropdown-none"),
            this.rHe.item(1).textContent = hL.Mk.Idi(13),
            this.rHe.item(2).textContent = hL.Mk.Idi(27),
            hL.p.j()
        }
        Xa(t, i) {
            hL.iM(t),
            this.oHe = -1,
            this.nHe.textContent = oL("ui.dialogs.chooseKey.no-key-placeholder"),
            this.o_i.setAttribute("disabled", ""),
            this.rHe.selectedIndex = 0,
            t >= 0 && this.aHe(t);
            let e = super.Xa(i);
            return this.lHe(),
            e
        }
        lHe() {
            this.FO().addEventListener("keydown", this.pG, !0)
        }
        uHe() {
            this.FO().removeEventListener("keydown", this.pG, !0)
        }
        wG(t) {
            t.preventDefault(),
            t.stopPropagation();
            let i = t.which;
            13 !== i ? 27 !== i ? this.aHe(i) : this._et() : this.xet()
        }
        aHe(t) {
            this.oHe = t,
            this.o_i.removeAttribute("disabled"),
            this.nHe.textContent = hL.Mk.Idi(t)
        }
        hHe() {
            let t = parseInt(this.rHe.value, 10);
            t >= 0 && this.aHe(t)
        }
        xet() {
            this.uHe(),
            this.oHe >= 0 && this.sW(this.oHe)
        }
        _et() {
            return this.uHe(),
            super._et()
        }
        cHe() {
            return this.o_i
        }
        dHe() {
            return this.nHe
        }
        xO() {}
    }
    ;
    hL.Qs.mk.iit.addEventListener("load", () => {
        hL.Qs.Ks.rit(cL, dL)
    }
    )
}
{
    const fL = self.t
      , pL = fL.bW(import.meta.url)
      , mL = pL.getElementById("crashReportDialog")
      , wL = (fL.IW(pL.URL),
    "CrashReport");
    let gL = !1
      , yL = !1;
    function bL(t) {
        const i = t.reason;
        if (i) {
            if ("string" == typeof i)
                return i;
            if (void 0 !== self.qUt && i instanceof self.qUt)
                return i.MBt() + ": " + i.zUt();
            if ("string" == typeof i.message && (i.message || i.stack || i.error && i.error.stack)) {
                const t = i.stack || (i.error ? i.error.stack : null);
                return "Error: " + i.message + (t ? " @ " + t : "")
            }
            if (i instanceof Event)
                return `Event '${i.type}'` + (i.name ? ` (${i.name})` : "") + ": " + i.toString();
            {
                let e = i.toString();
                if (e.startsWith("[object ")) {
                    let s = {}
                      , n = 0;
                    for (const [t,e] of Object.entries(i)) {
                        if (n >= 3)
                            break;
                        s[t] = e,
                        ++n
                    }
                    let r = e;
                    try {
                        r = JSON.stringify(s)
                    } catch (t) {}
                    r.length > 250 && (r = r.substr(0, 250)),
                    e = r
                }
                return e
            }
        }
        return "" + i
    }
    function vL(t) {
        if (!t)
            return !1;
        if ("string" == typeof t.filename) {
            const i = t.filename.toLowerCase();
            if (i.includes("safari-extension://") || i.includes("chrome-extension://"))
                return !0
        }
        if (t.error && "string" == typeof t.error.stack) {
            const i = t.error.stack.toLowerCase();
            if (i.includes("safari-extension://") || i.includes("chrome-extension://"))
                return !0
        }
        if ("string" == typeof t.message) {
            if (t.message.toLowerCase().startsWith("script error") && !t.filename && 0 === t.lineno)
                return !0;
            if (t.message.toLowerCase().includes("webkit.messagehandlers"))
                return !0;
            if (t.message.includes("ResizeObserver"))
                return !0;
            if (t.message.includes("3rdparty/monaco/") && t.message.includes("importScripts"))
                return !0
        }
        return !1
    }
    function SL(t) {
        if (!t)
            return !1;
        if (t.reason && "string" == typeof t.reason.stack) {
            if (t.reason.stack.toLowerCase().includes("3rdparty/monaco/"))
                return !0
        }
        return !1
    }
    const xL = fL.Qs.Fk.fHe = class extends fL.Qs.Ks {
        constructor() {
            super(mL),
            this.pHe = this.Pet("copyButton"),
            this.pHe.onclick = () => this.mHe(),
            this.wHe = this.Pet("saveButton"),
            this.wHe.onclick = () => this.gHe(),
            this.yHe = this.Pet("reloadButton"),
            this.yHe.onclick = () => location.reload(!0),
            this.bHe = this.Pet("reportContent"),
            this.BGt = fL.v(fL.Qs._q, self.app.s1i("error"), this.Pet("iconWrap"))
        }
        $et() {}
        Xa(t, i, e) {
            const s = self.app;
            let n = `<h3>Error report information</h3>\n\t\t<p>\n\t\t<strong>Type:</strong> ${t}<br/>`;
            if ("unhandled exception" === t) {
                const t = i.error ? i.error.stack : null;
                s.XGi("Crash", "UnhandledException"),
                s.vHe("Unhandled exception: " + t),
                n += `\n\t\t\t<strong>File:</strong> ${i.filename}, line ${i.lineno}, col ${i.colno}<br/>\n\t\t\t<strong>Message:</strong> ${i.message}<br/>\n\t\t\t<strong>Stack:</strong> ${t}<br/>\n\t\t\t`
            } else if ("unhandled rejection" === t) {
                const t = bL(i);
                let e = t;
                s.XGi("Crash", "UnhandledRejection"),
                n += `<strong>Reason:</strong> ${t}<br/>`,
                i.reason && i.reason.stack && (n += `<strong>Stack:</strong> ${i.reason.stack}<br/>`,
                e += "\n" + i.reason.stack),
                s.vHe("Unhandled rejection: " + e)
            } else
                s.XGi("Crash", "AssertFail"),
                s.vHe("Assert fail: " + i.message + "\n" + i.stack),
                n += `\n\t\t\t<strong>Message:</strong> ${i.message}<br/>\n\t\t\t<strong>Stack:</strong> ${i.stack}<br/>\n\t\t\t`;
            n += `<strong>Construct version:</strong> ${fL.dQ.mPe}<br/>\n\t\t<strong>URL:</strong> ${location.href}<br/>\n\t\t<strong>Date:</strong> ${(new Date).toString()}<br/>\n\t\t<strong>Uptime:</strong> ${Math.round(performance.now() / 100) / 10} s\n\t\t</p>`;
            try {
                fL.Qs.Ks.qs("PlatformInfo").SHe(!0).then(t => {
                    n += t,
                    this.bHe.innerHTML = n,
                    this.bHe.scrollTop = 0
                }
                ).catch(t => {
                    n += "Unable to collect further diagnostic information because a promise rejection occurred while trying to collect it.",
                    this.bHe.innerHTML = n,
                    this.bHe.scrollTop = 0
                }
                )
            } catch (t) {
                n += "Unable to collect further diagnostic information because an exception was thrown while trying to collect it.",
                this.bHe.innerHTML = n,
                this.bHe.scrollTop = 0
            }
            0 === s.h0() && this.wHe.setAttribute("disabled", "");
            let r = super.Xa(e);
            return fL.Qs.Tvi.TOi(),
            r
        }
        xet() {}
        _et() {}
        xO() {
            fL.Qs.L6(this.iVt)
        }
        OEi(t) {
            t.preventDefault()
        }
        mHe() {
            let t = document.createRange();
            t.selectNodeContents(this.bHe);
            let i = window.getSelection();
            i.removeAllRanges(),
            i.addRange(t),
            document.execCommand("copy")
        }
        gHe() {
            self.app.xHe()
        }
        static MHe() {
            return gL
        }
        static EHe() {
            window.addEventListener("error", t => {
                if (vL(t))
                    return void (() => {})("Ignored external unhandled exception: ", t);
                if (gL || yL)
                    return;
                gL = !0;
                fL.Qs.Ks.qs("CrashReport").Xa("unhandled exception", t, document.body)
            }
            ),
            window.addEventListener("unhandledrejection", t => {
                if (SL(t))
                    return void (() => {})("Ignored external unhandled rejection: ", t);
                if (gL || yL)
                    return;
                gL = !0;
                fL.Qs.Ks.qs("CrashReport").Xa("unhandled rejection", t, document.body)
            }
            ),
            window.addEventListener("beforeunload", () => yL = !0, !0),
            window.addEventListener("unload", () => yL = !0, !0)
        }
    }
    ;
    fL.Qs.mk.iit.addEventListener("load", () => {
        fL.Qs.Ks.rit(wL, xL)
    }
    )
}
{
    const ML = self.t
      , EL = self.lang
      , CL = ML.bW(import.meta.url)
      , _L = CL.getElementById("createKeystoreDialog")
      , TL = ML.IW(CL.URL);
    ML.p.MW(TL + "lang");
    const IL = "CreateKeystoreDialog"
      , PL = ML.Qs.Fk.CHe = class extends ML.Qs.Ks {
        constructor() {
            super(_L),
            this.MVi = {
                name: this._He("name"),
                unit: this._He("unit"),
                THe: this._He("organisation"),
                city: this._He("city"),
                state: this._He("state"),
                country: this._He("country"),
                IHe: this._He("alias"),
                validity: this._He("validity"),
                password: this._He("password"),
                PHe: this._He("passwordConfirm"),
                GHe: this._He("passwordVisible")
            },
            this.MVi.GHe.addEventListener("change", () => {
                const t = !this.MVi.GHe.value ? "password" : "text";
                this.MVi.password.type = t,
                this.MVi.PHe.type = t
            }
            ),
            this.AHe = this.Pet("helpLink"),
            this.AHe.onclick = () => self.app.FT("interface/dialogs/cordova-options", "CreateKeystoreDialog"),
            this.EMt = this.Pet("nextButton"),
            this.EMt.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et()
        }
        _He(t) {
            const i = this.Pet(t)
              , e = this.Pet(t + "Label");
            let s = !1;
            return {
                get value() {
                    return "checkbox" == i.type ? i.checked : i.value
                },
                set value(t) {
                    "checkbox" == i.type ? i.checked = !!t : i.value = t
                },
                set label(t) {
                    e.textContent = t
                },
                get hidden() {
                    return s
                },
                set hidden(t) {
                    s = !!t;
                    const n = s ? "none" : "";
                    i.style.display = n,
                    e.style.display = n
                },
                set type(t) {
                    i.type = t
                },
                set placeholder(t) {
                    i.placeholder = t
                },
                addEventListener: (t, e, s) => ML._f.Gf(i, t, e, s)
            }
        }
        Xa(t) {
            return this.MVi.name.value = "",
            this.MVi.unit.value = "",
            this.MVi.THe.value = "",
            this.MVi.city.value = "",
            this.MVi.state.value = "",
            this.MVi.country.value = "",
            this.MVi.IHe.value = "",
            this.MVi.validity.value = 25,
            this.MVi.password.value = "",
            this.MVi.PHe.value = "",
            super.Xa(t)
        }
        AVe() {
            return {
                name: this.MVi.name.value.trim(),
                unit: this.MVi.unit.value.trim(),
                organisation: this.MVi.THe.value.trim(),
                city: this.MVi.city.value.trim(),
                state: this.MVi.state.value.trim(),
                country: this.MVi.country.value.trim(),
                alias: this.MVi.IHe.value.trim(),
                validity: +this.MVi.validity.value,
                password: this.MVi.password.value,
                passwordConfirm: this.MVi.PHe.value,
                keyPassword: this.MVi.password.value,
                keyPasswordConfirm: this.MVi.PHe.value
            }
        }
        xGe() {
            const t = this.AVe()
              , i = "ui.dialogs.createKeystoreDialog.validation";
            if (!t.name)
                throw EL(i + ".name");
            if (!t.unit)
                throw EL(i + ".unit");
            if (!t.organisation)
                throw EL(i + ".organisation");
            if (!t.city)
                throw EL(i + ".city");
            if (!t.state)
                throw EL(i + ".state");
            if (2 !== t.country.length)
                throw EL(i + ".country");
            if (!t.alias)
                throw EL(i + ".alias");
            if (isNaN(t.validity) || t.validity < 1 || t.validity > 100)
                throw EL(i + ".validity");
            if (!t.password || t.password.length < 6)
                throw EL(i + ".password");
            if (!t.passwordConfirm)
                throw EL(i + ".password-confirm");
            if (t.password !== t.passwordConfirm)
                throw EL(i + ".password-match");
            return t
        }
        $et() {
            ML.p.u("ui.dialogs.createKeystoreDialog"),
            this.Wa(EL(".caption")),
            this.EMt.textContent = EL(".create"),
            this.FMt.textContent = EL("common.cancel"),
            this.AHe.textContent = EL("common.help"),
            this.MVi.name.placeholder = EL(".placeholder.name"),
            this.MVi.name.label = EL(".label.name"),
            this.MVi.unit.placeholder = EL(".placeholder.unit"),
            this.MVi.unit.label = EL(".label.unit"),
            this.MVi.THe.placeholder = EL(".placeholder.organisation"),
            this.MVi.THe.label = EL(".label.organisation"),
            this.MVi.city.placeholder = EL(".placeholder.city"),
            this.MVi.city.label = EL(".label.city"),
            this.MVi.state.placeholder = EL(".placeholder.state"),
            this.MVi.state.label = EL(".label.state"),
            this.MVi.country.placeholder = EL(".placeholder.country"),
            this.MVi.country.label = EL(".label.country"),
            this.MVi.IHe.placeholder = EL(".placeholder.alias"),
            this.MVi.IHe.label = EL(".label.alias"),
            this.MVi.password.placeholder = EL(".placeholder.password"),
            this.MVi.password.label = EL(".label.password"),
            this.MVi.PHe.placeholder = EL(".placeholder.password-confirm"),
            this.MVi.PHe.label = EL(".label.password-confirm"),
            this.MVi.validity.label = EL(".label.validity"),
            this.MVi.GHe.label = EL(".label.show-passwords"),
            ML.p.j()
        }
        async xet() {
            const t = ML.Qs.Ks.qs("Progress");
            try {
                const i = this.xGe();
                i.validity *= 365,
                await super.xet(),
                t.Xa(EL("ui.dialogs.createKeystoreDialog.creating-keystore"));
                const [e,s] = await ML.Qs.Ks.BVe.oWe.XWe(i);
                t.sW(),
                await ML.Qs.Ks.qs("CreateKeystoreReportDialog").Xa(e, s)
            } catch (i) {
                t.sW();
                const e = ML.Qs.Ks.qs("ShellOutput");
                ML.p.u("ui.dialogs.createKeystoreDialog.failure");
                const s = EL(".caption")
                  , n = EL(".message");
                return ML.p.j(),
                i instanceof Error ? e.Xa(s, n, i.message) : e.Xa(s, n, i.toString())
            }
        }
    }
    ;
    ML.Qs.mk.iit.addEventListener("load", () => {
        ML.Qs.Ks.rit(IL, PL)
    }
    )
}
{
    const GL = self.t
      , AL = self.Iet
      , RL = "CreateKeystoreReportDialog"
      , kL = GL.bW(import.meta.url)
      , OL = kL.getElementById(RL)
      , DL = GL.IW(kL.URL);
    GL.p.MW(DL + "lang");
    const FL = GL.Qs.Fk.RHe = class extends GL.Qs.Ks {
        constructor() {
            super(OL),
            this.kHe = null,
            this.OHe = null,
            this.DHe = this.Pet("downloadKeystore"),
            this.PEi = this.Pet("okButton"),
            this.PEi.onclick = () => this.sW()
        }
        Xa(t, i, e) {
            GL.U(t, Blob),
            GL.zt(i),
            GL.mGt(e),
            this.kHe = t,
            this.OHe = URL.createObjectURL(t),
            this.DHe.href = this.OHe,
            GL.p.u("ui.dialogs.create-keystore-report-dialog");
            return this.Oet().querySelectorAll("p")[5].innerHTML = self.e_(".signature", i).FXt(),
            GL.p.j(),
            super.Xa(e)
        }
        $et() {
            GL.p.u("ui.dialogs.create-keystore-report-dialog");
            const t = this.Oet().querySelectorAll("p");
            t[0].innerHTML = AL(".keep-it-safe").FXt(),
            t[1].innerHTML = AL(".we-dont-store-it").FXt(),
            t[2].innerHTML = AL(".google-play-app-signing").FXt(),
            t[3].innerHTML = AL(".more-information").FXt(),
            this.DHe.textContent = AL(".download-keystore").FXt(),
            this.Wa(self.lang(".caption")),
            GL.p.j()
        }
        sW() {
            URL.revokeObjectURL(this.OHe),
            this.kHe = null,
            this.OHe = null,
            super.sW()
        }
    }
    ;
    GL.Qs.mk.iit.addEventListener("load", () => {
        GL.Qs.Ks.rit(RL, FL)
    }
    )
}
{
    const LL = self.t
      , BL = self.lang
      , UL = LL.bW(import.meta.url)
      , NL = UL.getElementById("fullscreenPromptDialog")
      , jL = LL.IW(UL.URL);
    LL.p.MW(jL + "lang");
    const $L = "FullscreenPrompt"
      , zL = LL.Qs.Fk.FHe = class extends LL.Qs.Ks {
        constructor() {
            super(NL),
            this.o_i = this.Pet("goFullscreen"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.LHe = this.Pet("fullscreenMessage")
        }
        $et() {
            LL.p.u("ui.dialogs.fullscreen-prompt"),
            this.Wa(BL(".caption")),
            this.LHe.textContent = BL(".message"),
            this.o_i.textContent = BL(".go-fullscreen"),
            this.FMt.textContent = BL(".continue"),
            LL.p.j()
        }
        xet() {
            super.xet(),
            self.app.XGi("MobileFullscreenPrompt", "Accepted"),
            LL.Ime(document.documentElement)
        }
        _et() {
            super._et(),
            self.app.XGi("MobileFullscreenPrompt", "Declined")
        }
    }
    ;
    LL.Qs.mk.iit.addEventListener("load", () => {
        LL.Qs.Ks.rit($L, zL)
    }
    )
}
{
    const VL = self.t
      , WL = VL.bW(import.meta.url)
      , HL = WL.getElementById("legalInfoDialog")
      , KL = (VL.IW(WL.URL),
    "LegalInfo")
      , qL = VL.Qs.Fk.BHe = class extends VL.Qs.Ks {
        constructor() {
            super(HL),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet()
        }
        $et() {
            this.o_i.textContent = self.lang("common.close-dialog")
        }
        Xa(t) {
            return super.Xa(t)
        }
        xO() {}
    }
    ;
    VL.Qs.mk.iit.addEventListener("load", () => {
        VL.Qs.Ks.rit(KL, qL)
    }
    )
}
{
    const XL = self.t
      , YL = XL.bW(import.meta.url)
      , JL = YL.getElementById("memoryInfoDialog")
      , ZL = (XL.IW(YL.URL),
    "MemoryInfo")
      , QL = 2e3;
    function tB(t) {
        let i = t / 1048576;
        return XL.bT(i, 100)
    }
    const iB = XL.Qs.Fk.UHe = class extends XL.Qs.Ks {
        constructor() {
            super(JL),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.iVt = this.Pet("memoryInfoContent"),
            this.NHe = -1,
            this.jHe = () => this.tqi()
        }
        $et() {}
        Xa(t) {
            return this.tqi(),
            this.NHe = window.setInterval(this.jHe, QL),
            super.Xa(t)
        }
        async tqi() {
            let t = await self.app.fS()
              , i = 0
              , e = 0;
            for (let t of XL.ea.C9i.H9i()) {
                let s = t.WE();
                i += s,
                t.W9i() && (e += s)
            }
            let s = t.h4i();
            for (let t of XL.ea.Y9i.qwe())
                s += t.WE();
            let n = t.h4i() + t.o4i()
              , r = t.l4i()
              , h = self.app.Us().WE()
              , o = 0
              , a = 0;
            performance.memory && (o = performance.memory.$He || 0,
            a = performance.memory.zHe || 0);
            let l = 0
              , u = 0;
            for (let t of self.VHe.all())
                l += t.WHe(),
                u += t.HHe();
            let c = 0;
            for (let t of XL.Qs.vRi.all())
                c += t.WE();
            let d = XL.cii()
              , f = r + h + o + l + u + c + d
              , p = `<p>This view automatically refreshes. Note Construct is not able to determine memory usage of everything in the browser process. These values should be treated as estimated minimums.</p>\n\t\t\n\t\t<h3>Totals</h3>\n\t\t<p>\n\t\t<strong>WebGL memory:</strong> ${tB(r)} MB<br/>\n\t\t<strong>Layout view tabs:</strong> ${tB(h)} MB<br/>\n\t\t<strong>JS memory:</strong> ${tB(o)} MB<br/>\n\t\t<strong>Images:</strong> ${tB(l + u)} MB<br/>\n\t\t<strong>Icons:</strong> ${tB(c)} MB<br/>\n\t\t<strong>Library:</strong> ${tB(d)} MB<br/>\n\t\t<strong>Grand total: ${tB(f)} MB</strong>\n\t\t</p>\n\t\t\n\t\t<h3>WebGL memory</h3>\n\t\t<p>\n\t\t<strong>Texture memory usage:</strong> ${tB(i)} MB<br/>\n\t\tOf which static textures: ${tB(e)} MB (${0 === i ? 0 : Math.round(100 * e / i)}%)<br/>\n\t\t<strong>Render targets</strong> (including textures): ${tB(s)} MB<br/>\n\t\tExluding textures: ${tB(n)} MB<br/>\n\t\t</p>\n\t\t\n\t\t<h3>Javascript memory</h3>\n\t\t<p><strong>Used JS heap size:</strong> `;
            p += -1 === o ? "<em>unavailable</em>" : tB(o) + " MB",
            p += "<br/>\n\t\tTotal JS heap size: ",
            p += -1 === a ? "<em>unavailable</em>" : tB(a) + " MB",
            p += `</p>\n\t\t<h3>Images</h3>\n\t\t<p>\n\t\t<strong>Compressed images:</strong> ${tB(l)} MB<br/>\n\t\t<strong>Decompressed images:</strong> ${tB(u)} MB<br/>\n\t\t<strong>Icons:</strong> ${tB(c)} MB\n\t\t</p>`,
            this.iVt.innerHTML = p
        }
        xO() {
            XL.Qs.L6(this.iVt),
            window.clearInterval(this.NHe),
            this.NHe = -1
        }
    }
    ;
    XL.Qs.mk.iit.addEventListener("load", () => {
        XL.Qs.Ks.rit(ZL, iB)
    }
    )
}
{
    const eB = self.t
      , sB = self.lang
      , nB = eB.bW(import.meta.url)
      , rB = nB.getElementById("platformInfoDialog")
      , hB = (eB.IW(nB.URL),
    "PlatformInfo");
    let oB = !1
      , aB = 0
      , lB = 0
      , uB = "";
    function cB() {
        if (oB)
            return;
        const t = self.app.Dei();
        aB = t.sampleRate,
        lB = t.destination.maxChannelCount,
        uB = t.destination.channelInterpretation || "(unavailable)",
        oB = !0,
        t.close && t.close()
    }
    const dB = eB.Qs.Fk.KHe = class extends eB.Qs.Ks {
        constructor() {
            super(rB),
            this.o_i = this.Pet("okButton"),
            this.o_i.textContent = sB("common.ok"),
            this.o_i.onclick = () => this.xet(),
            this.pHe = this.Pet("copy"),
            this.pHe.textContent = sB("common.copy"),
            this.pHe.onclick = () => this.qHe(),
            this.iVt = this.Pet("platformInfoContent")
        }
        $et() {}
        async SHe(t) {
            const i = {
                XHe: !1,
                persisted: !1,
                YHe: !1,
                usage: 0,
                JHe: 0
            }
              , e = [];
            return eB.QL.z9t && e.push(navigator.storage.persisted().then(t => {
                i.XHe = !0,
                i.persisted = t
            }
            ).catch(t => {
                (() => {})("Error requesting persistent storage: ", t),
                i.XHe = !1
            }
            )),
            eB.QL.V9t && e.push(navigator.storage.estimate().then(t => {
                i.YHe = !0,
                i.usage = t.usage,
                i.JHe = t.quota
            }
            ).catch(t => {
                (() => {})("Error estimating storage usage: ", t),
                i.YHe = !1
            }
            )),
            await Promise.all(e),
            await this.ZHe(i, t)
        }
        async ZHe(t, i) {
            const e = self.app;
            let s = "(unavailable, defaulting to 2)";
            "number" == typeof navigator.hardwareConcurrency && navigator.hardwareConcurrency > 0 && (s = navigator.hardwareConcurrency);
            let n = "(unavailable)";
            "number" == typeof navigator.deviceMemory && navigator.deviceMemory > 0 && (n = navigator.deviceMemory + " GB"),
            await eB.kt.I9t();
            let r = `<h3>Platform information</h3>\n\t\t<p>\n\t\t<strong>Product:</strong> Construct ${"animation" === e.bne() ? "Animate" : "3"} ${eB.dQ.mPe} (${e.oNe(!0)})<br/>\n\t\t<strong>Browser:</strong> ${eB.kt._r} ${eB.kt.E9t}<br/>\n\t\t<strong>Browser engine:</strong> ${eB.kt._9t}<br/>\n\t\t<strong>Context:</strong> ${eB.kt.Mme}<br/>\n\t\t<strong>Operating system:</strong> ${eB.kt.OS} ${eB.kt.M9t}<br/>\n\t\t<strong>Device type:</strong> ${eB.kt.FG ? "desktop" : "mobile"}<br/>\n\t\t<strong>Device pixel ratio:</strong> ${self.devicePixelRatio}<br/>\n\t\t<strong><abbr title="Number of hardware threads supported by the device, which can be different to the number of physical cores.">Logical CPU cores</abbr>:</strong> ${s}<br/>\n\t\t<strong>Approx. device memory:</strong> ${n}<br/>\n\t\t<strong>User agent:</strong> ${navigator.userAgent}<br/>\n\t\t<strong>Language setting:</strong> ${e.X7()}\n\t\t</p>`
              , h = null;
            try {
                h = await e.fS()
            } catch (t) {}
            if (!i) {
                if (r += "<h3>Local storage</h3>\n\t\t\t<p>",
                t.YHe) {
                    const i = Math.round(1e3 * t.usage / t.JHe) / 10;
                    r += `\n\t\t\t\t<strong>Storage quota (approx):</strong> ${eB.Woi(t.JHe)}<br/>\n\t\t\t\t<strong>Storage usage (approx):</strong> ${eB.Woi(t.usage)} (${i}%)<br/>\n\t\t\t\t`
                } else
                    r += "\n\t\t\t\t<strong>Storage quota (approx):</strong> (status unavailable)<br/>\n\t\t\t\t<strong>Storage usage (approx):</strong> (status unavailable)<br/>\n\t\t\t\t";
                t.XHe ? r += `\n\t\t\t\t<strong>Persistant storage:</strong> ${t.persisted ? "Yes" : "No"}\n\t\t\t\t` : r += "\n\t\t\t\t<strong>Persistant storage:</strong> (status unavailable)\n\t\t\t\t",
                r += "</p>",
                r += "<h3>Browser support notes</h3>\n\t\t\t<p>This list contains missing features that are not required, but could improve performance or user experience if supported.</p>\n\t\t\t<ul>";
                let i = "";
                "Firefox" === eB.kt._r && (i += '<li>Rendering multiple on-screen Layout Views is slow in Firefox due to <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1163426">bug 1163426</a></li>'),
                CSS.supports("contain", "content") || (i += "<li>CSS containment is not supported. Editor performance may be significantly degraded.</li>"),
                eB.QL.R9t || (i += "<li>The &lt;dialog&gt; element is not supported. A polyfill is in use.</li>"),
                eB.QL.F9t || (i += "<li>The Clipboard API is not supported. Some clipboard features may be unavailable."),
                eB.QL.A9t || (i += "<li>Web Animations are not supported. Animations are disabled.</li>"),
                void 0 === Intl.PluralRules && (i += "<li>This browser does not support pluralisation rules. Plural forms may not be correct.</li>"),
                e.iN() || (i += "<li>UI effects are disabled in settings.</li>"),
                h && h.r4i() && h.k9i() < 2 && (i += "<li>WebGL 2+ is not supported. Rendering quality and features may be affected.</li>"),
                h && h.n4i() && (i += `<li>${h.r4i() ? "WebGL" : "WebGPU"} indicates a major performance caveat. It is probably using software rendering.</li>`),
                h || (i += "<li><strong>Failed to create WebGL renderer. Layout views cannot be opened.</strong></li>"),
                eB.QL.ImageBitmap || (i += "<li>ImageBitmap is not supported. Texture loading performance may be degraded.</li>"),
                eB.QL.ImageBitmap && !eB.QL.O9t && (i += "<li>ImageBitmapOptions is not supported. Texture loading performance may be degraded.</li>"),
                eB.QL.k9t || (i += "<li>Idle callbacks are not supported. Background loading performance may be degraded.</li>"),
                "undefined" == typeof InputDeviceCapabilities && (i += "<li>Determining input device capabilities is not supported.</li>"),
                eB.QL.z9t || (i += "<li>Persistent storage is not available. Local storage could be deleted by the browser.</li>"),
                eB.QL.V9t || (i += "<li>Storage quota estimate is unavailable.</li>"),
                CSS.supports("cursor", "-webkit-image-set(url(cursor.png) 1x), crosshair") || CSS.supports("cursor", "image-set(url(cursor.png) 1x), crosshair") || (i += "<li>image-set() is not supported. Mouse cursors may appear with reduced quality."),
                i || (i = "<li>Nothing is missing. Everything is OK!</li>"),
                r += i,
                r += "</ul>"
            }
            if (h)
                if (h.r4i()) {
                    const t = new Set(h.Abe());
                    if (r += `<h3>WebGL information</h3>\n\t\t\t\t<p>\n\t\t\t\t<strong>Version string:</strong> ${h.Tbe()}<br/>\n\t\t\t\t<strong>Numeric version:</strong> ${h.k9i()}<br/>\n\t\t\t\t<strong>Supports <abbr title="non-power-of-two">NPOT</abbr> textures:</strong> ${h.gS() ? "yes" : "partial"}<br/>\n\t\t\t\t<strong>Supports GPU profiling:</strong> ${h.Cbe() ? "yes" : "no"}<br/>\n\t\t\t\t<strong>Vendor:</strong> ${h.Ibe()}<br/>\n\t\t\t\t<strong>Renderer:</strong> ${h.Pbe()}<br/>\n\t\t\t\t<strong><abbr title="Indicates a performance problem such as use of a software renderer instead of graphics hardware.">Major performance caveat:</strong> ${h.n4i() ? "yes" : "no"}<br/>\n\t\t\t\t<strong>Maximum texture size:</strong> ${h.T5i()}<br/>\n\t\t\t\t<strong>Point size range:</strong> ${h.uu()} to ${h.cu()}<br/>\n\t\t\t\t<strong>Extensions:</strong>`,
                    i)
                        r += " " + [...t].join(", ") + "</p>";
                    else {
                        r += "</p><ul>";
                        for (const i of t)
                            r += `<li>${i}</li>`;
                        r += "</ul>"
                    }
                } else {
                    const t = h.yEe();
                    t.sort();
                    const e = h.bEe();
                    if (r += `<h3>WebGPU information</h3>\n\t\t\t\t<p>\n\t\t\t\t<strong>Renderer:</strong> WebGPU<br/>\n\t\t\t\t<strong>Supports GPU profiling:</strong> ${h.Cbe() ? "yes" : "no"}<br/>\n\t\t\t\t<strong><abbr title="Indicates a performance problem such as use of a software renderer instead of graphics hardware.">Major performance caveat:</strong> ${h.n4i() ? "yes" : "no"}<br/>\n\t\t\t\t<strong>Maximum texture size:</strong> ${h.T5i()}<br/>\n\t\t\t\t<strong>Adapter vendor:</strong> \t\t${e && e.vendor || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter architecture:</strong>\t${e && e.architecture || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter device:</strong>\t\t${e && e.device || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter description:</strong>\t${e && e.description || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter type:</strong>\t\t\t${e && e.type || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter backend:</strong>\t\t${e && e.backend || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter features:</strong>`,
                    i)
                        r += " " + t.join(", ") + "</p>";
                    else {
                        r += "</p><ul>";
                        for (const i of t)
                            r += `<li>${i}</li>`;
                        r += "</ul>"
                    }
                }
            else
                r += "<h3>WebGL information</h3>\n\t\t\t<p><strong>Failed to create WebGL renderer. Try installing any available software updates.</strong></p>";
            if (!i) {
                cB(),
                r += `<h3>Audio information</h3>\n\t\t\t<p>\n\t\t\t<strong>System sample rate:</strong> ${aB} Hz<br/>\n\t\t\t<strong>Output channels:</strong> ${lB}</br>\n\t\t\t<strong>Output interpretation:</strong> ${uB}<br/>\n\t\t\t<strong>Supported decode formats:</strong></p><ul>`;
                const t = new Audio
                  , i = [["webm", "WebM"], ["mp4", "MPEG-4"]]
                  , e = [["opus", "Opus"], ["vorbis", "Vorbis"], ["mp4a.40.2", "AAC"]];
                for (const [s,n] of i)
                    for (const [i,h] of e) {
                        const e = `audio/${s};codecs=${i}`;
                        t.canPlayType(e) && (r += `<li>${n} ${h} (${e})</li>`)
                    }
                if (t.canPlayType("audio/mpeg") && (r += "<li>MP3 (audio/mpeg)</li>"),
                t.canPlayType("audio/flac") && (r += "<li>FLAC (audio/flac)</li>"),
                t.canPlayType("audio/wav;codecs=1") && (r += "<li>PCM WAV (audio/wav;codecs=1)</li>"),
                r += "</ul>\n\t\t\t<p>\n\t\t\t<strong>Supported encode formats:</strong> ",
                "undefined" == typeof MediaRecorder || void 0 === MediaRecorder.isTypeSupported)
                    r += "<em>(encoding not supported)</em></p>";
                else {
                    r += "</p><ul>";
                    for (const [t,s] of i)
                        for (const [i,n] of e) {
                            const e = `audio/${t};codecs=${i}`;
                            MediaRecorder.isTypeSupported(e) && (r += `<li>${s} ${n} (${e})</li>`)
                        }
                    MediaRecorder.isTypeSupported("audio/mpeg") && (r += "<li>MP3 (audio/mpeg)</li>"),
                    MediaRecorder.isTypeSupported("audio/flac") && (r += "<li>FLAC (audio/flac)</li>"),
                    MediaRecorder.isTypeSupported("audio/wav;codecs=1") && (r += "<li>PCM WAV (audio/wav;codecs=1)</li>"),
                    r += "</ul>"
                }
                r += "<h3>Video information</h3>\n\t\t\t<p>\n\t\t\t<strong>Supported decode formats:</strong></p><ul>";
                const s = document.createElement("video")
                  , n = [["av01.0.00M.08", "AV1"], ["vp9", "VP9"], ["vp8", "VP8"], ["hev1.1.2.L93.B0", "H.265"], ["avc1.420034", "H.264"]];
                for (const [t,e] of i)
                    for (const [i,h] of n) {
                        const n = `video/${t};codecs=${i}`;
                        s.canPlayType(n) && (r += `<li>${e} ${h} (${n})</li>`)
                    }
                if (r += "</ul>\n\t\t\t<p>\n\t\t\t<strong>Supported encode formats:</strong> ",
                "undefined" == typeof MediaRecorder || void 0 === MediaRecorder.isTypeSupported)
                    r += "<em>(encoding not supported)</em></p>";
                else {
                    r += "</p><ul>";
                    for (const [t,e] of i)
                        for (const [i,s] of n) {
                            const n = `video/${t};codecs=${i}`;
                            MediaRecorder.isTypeSupported(n) && (r += `<li>${e} ${s} (${n})</li>`)
                        }
                    r += "</ul>"
                }
            }
            return r
        }
        Xa(t) {
            return this.SHe().then(t => this.iVt.innerHTML = t),
            super.Xa(t)
        }
        qHe() {
            const t = document.createRange();
            t.selectNodeContents(this.iVt);
            const i = window.getSelection();
            i.removeAllRanges(),
            i.addRange(t),
            document.execCommand("copy")
        }
        xO() {
            eB.Qs.L6(this.iVt)
        }
    }
    ;
    eB.Qs.mk.iit.addEventListener("load", () => {
        eB.Qs.Ks.rit(hB, dB)
    }
    )
}
{
    const fB = self.t
      , pB = fB.bW(import.meta.url)
      , mB = pB.getElementById("privacyPolicyDialog")
      , wB = (fB.IW(pB.URL),
    "PrivacyPolicy")
      , gB = fB.Qs.Fk.QHe = class extends fB.Qs.Ks {
        constructor() {
            super(mB),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.Pet("eula").onclick = function() {
                fB.Qs.Ks.qs("EULA").Xa()
            }
        }
        $et() {
            this.o_i.textContent = self.lang("common.close-dialog")
        }
        Xa(t) {
            return super.Xa(t)
        }
        xO() {}
    }
    ;
    fB.Qs.mk.iit.addEventListener("load", () => {
        fB.Qs.Ks.rit(wB, gB)
    }
    )
}
{
    const yB = self.t
      , bB = yB.bW(import.meta.url)
      , vB = bB.getElementById("shellOutputDialog")
      , SB = yB.IW(bB.URL);
    yB.p.MW(SB + "lang");
    const xB = "ShellOutput"
      , MB = ["rgb(0, 0, 0)", "rgb(194, 54, 33)", "rgb(37, 188, 36)", "rgb(173, 173, 39)", "rgb(73, 46, 225)", "rgb(211, 56, 211)", "rgb(51, 187, 200)", "rgb(203, 204, 205)"]
      , EB = yB.Qs.Fk.tKe = class extends yB.Qs.Ks {
        constructor() {
            super(vB),
            this.iKe = this.Pet("shell-block"),
            this.eKe = this.Pet("shell-message"),
            this.sKe = this.Pet("shell-summary")
        }
        $et() {
            this.sKe.textContent = self.lang("ui.dialogs.shell-output.build-log")
        }
        Xa(t, i, e, s) {
            yB.zt(t),
            yB.zt(i),
            yB.zt(e),
            yB.mGt(s),
            this.eKe.textContent = i;
            const n = this.iKe;
            let r = 0
              , h = null;
            yB.Qs.L6(n),
            this.Wa(t),
            e.replace(/\[(\d+)m/g, (t, i, e, s) => {
                const o = s.slice(r, e)
                  , a = document.createElement("span");
                h && (a.style.color = h),
                a.textContent = o,
                n.appendChild(a),
                0 == i && h && (h = null),
                i > 29 && i < 38 && (h = MB[i - 30]),
                r = e + t.length
            }
            );
            const o = e.slice(r)
              , a = document.createElement("span");
            h && (a.style.color = h),
            a.textContent = o,
            n.appendChild(a),
            super.Xa(s)
        }
    }
    ;
    yB.Qs.mk.iit.addEventListener("load", () => {
        yB.Qs.Ks.rit(xB, EB)
    }
    )
}
{
    const CB = self.t
      , _B = self.lang
      , TB = self.Iet
      , IB = self.n_
      , PB = CB.bW(import.meta.url)
      , GB = PB.getElementById("storageCleanupDialog")
      , AB = CB.IW(PB.URL);
    CB.p.MW(AB + "lang");
    const RB = "StorageCleanup"
      , kB = CB.Qs.Fk.nKe = class extends CB.Qs.Ks {
        constructor() {
            super(GB),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.FMt = this.Pet("cancelButton"),
            this.FMt.onclick = () => this._et(),
            this.rKe = this.Pet("scanningWrap"),
            this.hKe = this.Pet("readyWrap"),
            this.oKe = this.Pet("storageUsageHeader"),
            this.aKe = this.Pet("clearExportManagerStorage"),
            this.lKe = this.Pet("clearExportManagerStorageLabel"),
            this.uKe = this.Pet("clearExampleProjectsStorage"),
            this.cKe = this.Pet("clearExampleProjectsStorageLabel"),
            this.dKe = this.Pet("clearNwjsStorage"),
            this.fKe = this.Pet("clearNwjsStorageLabel"),
            this.pKe = this.Pet("clearLinuxCefStorage"),
            this.mKe = this.Pet("clearLinuxCefStorageLabel"),
            this.wKe = this.Pet("clearC3Storage"),
            this.gKe = this.Pet("clearC3StorageLabel"),
            this.yKe = this.Pet("localBrowserSavesInfo"),
            this.bKe = this.Pet("clearBrowserCacheInfo"),
            this.vKe = this.Pet("privateBrowsingInfo"),
            this.SKe = this.Pet("systemCleanupInfo"),
            "animation" === self.app.bne() && (this.Pet("nwjswrap").style.display = "none",
            this.Pet("linuxcefwrap").style.display = "none"),
            this.xKe = new Map
        }
        $et() {
            CB.p.u("ui.dialogs.storageCleanup"),
            this.Wa(_B(".caption")),
            this.o_i.textContent = _B(".clear-storage"),
            this.FMt.textContent = _B("common.cancel");
            const t = this.Pet("helpLink");
            t.textContent = _B("common.help"),
            t.onclick = () => self.app.FT("interface/dialogs/storage-cleanup", "StorageCleanupHelp"),
            this.rKe.textContent = _B(".scanning-storage"),
            CB.wQ(this.Pet("clearExportManagerStorageTip"), TB(".export-manager.tip")),
            CB.wQ(this.Pet("clearExampleProjectsStorageTip"), TB(".example-projects.tip")),
            CB.wQ(this.Pet("clearNwjsStorageTip"), TB(".nwjs.tip")),
            CB.wQ(this.Pet("clearLinuxCefStorageTip"), TB(".linux-cef.tip")),
            CB.wQ(this.Pet("clearC3StorageTip"), TB(".c3-offline.tip")),
            CB.p.u(".more-options"),
            CB.wQ(this.Pet("moreOptionsHeader"), TB(".header")),
            CB.wQ(this.Pet("moreOptionsText"), TB(".description")),
            CB.wQ(this.yKe, TB(".local-browser-saves")),
            CB.wQ(this.bKe, TB(".clear-browser-cache")),
            CB.wQ(this.vKe, TB(".private-browsing")),
            CB.wQ(this.SKe, TB(".system-storage-cleanup")),
            CB.p.j(),
            CB.p.j()
        }
        Xa(t) {
            "browser" !== CB.kt.Mme && (this.bKe.style.display = "none",
            this.vKe.style.display = "none"),
            self.Xue.MKe().then(t => {
                t && (this.yKe.style.display = "none")
            }
            ).catch(t => console.error("[Storage cleanup] Error checking local browser storage: ", t));
            const i = super.Xa(t);
            return self.app.XGi("StorageCleanupDialog", "Shown"),
            this.o_i.setAttribute("disabled", ""),
            this.rKe.style.display = "",
            this.hKe.style.display = "none",
            this.EKe(),
            i
        }
        async EKe() {
            await Promise.all([this.CKe(), this._Ke(), this.TKe(), this.IKe(), this.PKe(), this.GKe()]),
            this.AKe()
        }
        async CKe() {
            if (CB.QL.V9t)
                try {
                    const t = await navigator.storage.estimate()
                      , i = t.quota
                      , e = t.usage
                      , s = Math.round(1e3 * e / i) / 10;
                    CB.wQ(this.oKe, self.e_("ui.dialogs.storageCleanup.storage-usage-header", CB.Woi(e), CB.Woi(i), s))
                } catch (t) {
                    return (() => {})("Error estimating storage usage: ", t),
                    void (this.oKe.style.display = "none")
                }
            else
                this.oKe.style.display = "none"
        }
        async _Ke() {
            await self.app.Dde(),
            await CB.Abi.yrt();
            let t = 0
              , i = 0;
            try {
                const e = self.kKe.RKe()
                  , s = await e.keys()
                  , n = s.indexOf(self.kKe.OKe());
                n >= 0 && s.splice(n, 1);
                const r = await Promise.all(s.map(t => e.getItem(t)));
                t = r.length,
                i = r.reduce( (t, i) => t + i.size, 0),
                this.xKe.set("nwjs", {
                    DKe: i,
                    FKe: t,
                    delete: () => Promise.all(s.map(t => e.removeItem(t)))
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning NW.js storage: ", t),
                self.app.XGi("StorageCleanupDialog", "ScanError-nwjs:" + t)
            }
            CB.wQ(this.fKe, IB("ui.dialogs.storageCleanup.nwjs.label", {
                LHt: !0
            }, t, CB.Woi(i))),
            this.dKe.checked = !0
        }
        async TKe() {
            await self.app.Dde(),
            await CB.Abi.yrt();
            let t = 0
              , i = 0;
            try {
                const e = self.LKe.RKe()
                  , s = await e.keys()
                  , n = s.indexOf(self.LKe.OKe());
                n >= 0 && s.splice(n, 1);
                const r = await Promise.all(s.map(t => e.getItem(t)));
                t = r.length,
                i = r.reduce( (t, i) => t + i.size, 0),
                this.xKe.set("linux-cef", {
                    DKe: i,
                    FKe: t,
                    delete: () => Promise.all(s.map(t => e.removeItem(t)))
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning Linux CEF storage: ", t),
                self.app.XGi("StorageCleanupDialog", "ScanError-LinuxCEF:" + t)
            }
            CB.wQ(this.mKe, IB("ui.dialogs.storageCleanup.linux-cef.label", {
                LHt: !0
            }, t, CB.Woi(i))),
            this.pKe.checked = !0
        }
        async IKe() {
            let t = 0
              , i = 0;
            try {
                const e = CB.Qs.Ks.BVe.yWe()
                  , s = await localforage.getItem(e);
                if (s)
                    for (const e of s)
                        e.blob && (t++,
                        i += e.blob.size);
                this.xKe.set("export-manager", {
                    DKe: i,
                    FKe: t,
                    delete: () => localforage.removeItem(e)
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning export manager storage: ", t),
                self.app.XGi("StorageCleanupDialog", "ScanError-exports:" + t)
            }
            CB.wQ(this.lKe, IB("ui.dialogs.storageCleanup.export-manager.label", {
                LHt: !0
            }, t, CB.Woi(i))),
            this.aKe.checked = !0
        }
        async PKe() {
            let t = 0
              , i = 0;
            try {
                const e = []
                  , s = await caches.keys();
                await Promise.all(s.map(async s => {
                    const n = await caches.open(s)
                      , r = (await n.keys()).filter(t => /example-?projects\/(.*)\.c3p/i.test(t.url));
                    t += r.length;
                    const h = await Promise.all(r.map(async t => {
                        const i = await n.match(t);
                        return (await i.blob()).size
                    }
                    ));
                    i += h.reduce( (t, i) => t + i, 0),
                    e.push( () => Promise.all(r.map(t => n.delete(t))))
                }
                )),
                this.xKe.set("example-projects", {
                    DKe: i,
                    FKe: t,
                    delete: () => Promise.all(e.map(t => t()))
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning example projects storage: ", t),
                self.app.XGi("StorageCleanupDialog", "ScanError-exampleprojs:" + t)
            }
            CB.wQ(this.cKe, IB("ui.dialogs.storageCleanup.example-projects.label", {
                LHt: !0
            }, t, CB.Woi(i))),
            this.uKe.checked = !0
        }
        async GKe() {
            let t = 0
              , i = 0;
            try {
                const e = await caches.keys();
                t = e.length,
                t >= 2 && t--,
                await Promise.all(e.map(async t => {
                    const e = await caches.open(t)
                      , s = await e.keys()
                      , n = await Promise.all(s.map(async t => {
                        const i = await e.match(t);
                        return (await i.blob()).size
                    }
                    ));
                    i += n.reduce( (t, i) => t + i, 0)
                }
                )),
                this.xKe.set("c3-offline", {
                    DKe: i,
                    FKe: t,
                    delete: async () => {
                        await Promise.all(e.map(t => caches.delete(t)));
                        const t = await navigator.serviceWorker.getRegistrations();
                        await Promise.all(t.map(t => t.unregister()))
                    }
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning C3 offline storage: ", t),
                self.app.XGi("StorageCleanupDialog", "ScanError-c3:" + t)
            }
            CB.wQ(this.gKe, IB("ui.dialogs.storageCleanup.c3-offline.label", {
                LHt: !0
            }, t, CB.Woi(i))),
            this.wKe.checked = !1
        }
        AKe() {
            this.tc() && (this.o_i.removeAttribute("disabled"),
            this.rKe.style.display = "none",
            this.hKe.style.display = "")
        }
        xet() {
            const t = self.app;
            if (!(this.dKe.checked || this.pKe.checked || this.aKe.checked || this.uKe.checked || this.wKe.checked)) {
                return void CB.Qs.Ks.qs("OK").Xa(_B("ui.dialogs.storageCleanup.nothing-to-clear"))
            }
            this.o_i.setAttribute("disabled", ""),
            (async () => {
                const i = CB.Qs.Ks.qs("Progress");
                i.Xa(_B("ui.dialogs.storageCleanup.clearing-storage"));
                let e = 0;
                const s = [];
                this.dKe.checked && s.push("nwjs"),
                this.pKe.checked && s.push("linux-cef"),
                this.aKe.checked && s.push("export-manager"),
                this.uKe.checked && !this.wKe.checked && s.push("example-projects"),
                this.wKe.checked && s.push("c3-offline");
                let n = !1;
                try {
                    await Promise.all(s.map(t => {
                        const i = this.xKe.get(t);
                        if (i)
                            return e += i.DKe,
                            i.delete()
                    }
                    ))
                } catch (i) {
                    n = !0,
                    console.error("[Storage cleanup] Error deleting storage: ", i),
                    t.XGi("StorageCleanupDialog", "DeleteError:" + i)
                }
                t.XGi("StorageCleanupDialog", "DidCleanup-" + (n ? "Error" : "Success")),
                i.sW(),
                super.xet();
                CB.Qs.Ks.qs("OK").Xa(n ? _B("ui.dialogs.storageCleanup.error-clearing") : self.h_("ui.dialogs.storageCleanup.successfully-cleared", CB.Woi(e)))
            }
            )()
        }
        _et() {
            self.app.XGi("StorageCleanupDialog", "Cancelled"),
            super._et()
        }
        xO() {}
    }
    ;
    CB.Qs.mk.iit.addEventListener("load", () => {
        CB.Qs.Ks.rit(RB, kB)
    }
    )
}
{
    const OB = self.t
      , DB = self.lang
      , FB = OB.bW(import.meta.url)
      , LB = FB.getElementById("svgPreviewDialog")
      , BB = OB.IW(FB.URL);
    OB.p.MW(BB + "lang");
    const UB = "SVGPreview"
      , NB = OB.Qs.Fk.BKe = class extends OB.Qs.Ks {
        constructor() {
            super(LB),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.UKe = this.Pet("svgPreviewTitle"),
            this.NKe = this.Pet("svgPreviewEditXml"),
            this.NKe.onclick = () => this.jKe(),
            this.$Ke = null,
            this.zKe = null,
            this.wki = null,
            this.ZWe = "",
            this.VKe = this.Pet("headerWrap")
        }
        $et() {
            OB.p.u("ui.dialogs.svgPreview"),
            this.Wa(DB(".caption")),
            this.o_i.textContent = DB("common.close-dialog"),
            OB.p.j()
        }
        async Xa(t, i) {
            if (this.NKe.style.display = "none",
            this.Pet("svgPreviewDash").style.display = "none",
            OB.Bm(t, globalThis.e0)) {
                if (this.zKe = t,
                !await OB.e7(this.zKe.lS()))
                    throw new Error("expected image");
                await OB.xtt(this.zKe.lS()) ? (this.Wa(DB("ui.dialogs.svgPreview.caption")),
                this.NKe.style.display = "",
                this.Pet("svgPreviewDash").style.display = "",
                this.NKe.textContent = DB("ui.dialogs.svgPreview.edit-xml")) : await OB.s7(this.zKe.lS()) ? this.Wa(DB("ui.dialogs.svgPreview.caption-animation")) : this.Wa(DB("ui.dialogs.svgPreview.caption-image"))
            } else {
                if (this.wki = t,
                this.NKe.textContent = DB(".view-xml"),
                !await OB.e7(t))
                    throw new Error("expected image");
                await OB.xtt(t) ? (this.Wa(DB("ui.dialogs.svgPreview.caption")),
                this.NKe.style.display = "",
                this.Pet("svgPreviewDash").style.display = "",
                this.NKe.textContent = DB("ui.dialogs.svgPreview.view-xml")) : await OB.s7(t) ? this.Wa(DB("ui.dialogs.svgPreview.caption-animation")) : this.Wa(DB("ui.dialogs.svgPreview.caption-image"))
            }
            return this.UKe.textContent = self.h_("ui.dialogs.svgPreview.svg-title", this.QWe(t), this.iHe(t)),
            this.$Ke = new Image,
            this.$Ke.className = "transparent-checkerboard-pattern",
            this.$Ke.src = await this.eHe(t),
            this.Oet().appendChild(this.$Ke),
            super.Xa(i)
        }
        jKe() {
            if (this.zKe) {
                const t = this.zKe;
                this.sW();
                self.app.Iwe().MEt(t)
            }
            this.wki && OB.Qs.Ks.qs("TextPreview").Xa(this.wki, this.wki.type)
        }
        WKe(t) {
            return OB.Bm(t, globalThis.e0) ? t.cst().eEt() : OB.MimeType.Chi(t).eEt()
        }
        QWe(t) {
            return OB.Bm(t, globalThis.e0) ? t.s0() : t.name
        }
        iHe(t) {
            return OB.Bm(t, globalThis.e0) ? OB.Woi(t.lS().size) : OB.Woi(t.size)
        }
        async eHe(t) {
            return OB.Bm(t, globalThis.e0) ? t.SLt() : (this.ZWe = URL.createObjectURL(t),
            this.ZWe)
        }
        xO() {
            this.zKe = null,
            this.wki = null,
            OB.Qs.UO(this.$Ke),
            this.$Ke = null,
            this.UKe.textContent = "",
            this.ZWe && URL.revokeObjectURL(this.ZWe),
            this.ZWe = ""
        }
    }
    ;
    OB.Qs.mk.iit.addEventListener("load", () => {
        OB.Qs.Ks.rit(UB, NB)
    }
    )
}
{
    const jB = self.t
      , $B = self.lang
      , zB = jB.bW(import.meta.url)
      , VB = zB.getElementById("videoPreviewDialog")
      , WB = jB.IW(zB.URL);
    jB.p.MW(WB + "lang");
    const HB = "VideoPreview"
      , KB = jB.Qs.Fk.HKe = class extends jB.Qs.Ks {
        constructor() {
            super(VB),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.UKe = null,
            this.KKe = null,
            this.zKe = null,
            this.wki = null,
            this.ZWe = "",
            this.VKe = this.Pet("headerWrap")
        }
        $et() {
            this.o_i.textContent = $B("common.close-dialog"),
            this.Wa($B("ui.dialogs.videoPreview.caption"))
        }
        async Xa(t, i) {
            return this.UKe = document.createElement("h3"),
            this.KKe = document.createElement("video"),
            this.KKe.addEventListener("loadedmetadata", () => this.qKe()),
            jB.Bm(t, globalThis.e0) ? this.zKe = t : this.wki = t,
            this.KKe.src = await this.eHe(),
            this.KKe.controls = !0,
            this.KKe.autoplay = !0,
            this.qKe(),
            this.VKe.appendChild(this.UKe),
            this.Oet().appendChild(this.KKe),
            super.Xa(i)
        }
        qKe() {
            if (!this.KKe)
                return;
            const t = this.KKe.videoWidth || "?"
              , i = this.KKe.videoHeight || "?";
            this.UKe.textContent = self.h_("ui.dialogs.videoPreview.video-title", this.QWe(), this.tHe(), t, i, this.iHe())
        }
        tHe() {
            return this.zKe ? this.zKe.cst().gpi() : this.wki ? jB.MimeType.Chi(this.wki).gpi() : void 0
        }
        QWe() {
            return this.zKe ? this.zKe.s0() : this.wki ? this.wki.name : void 0
        }
        iHe() {
            return this.zKe ? jB.Woi(this.zKe.lS().size) : this.wki ? jB.Woi(this.wki.size) : void 0
        }
        async eHe() {
            return this.zKe ? this.zKe.SLt() : this.wki ? (this.ZWe = URL.createObjectURL(this.wki),
            this.ZWe) : void 0
        }
        xO() {
            this.KKe.pause(),
            this.KKe.src = "",
            jB.Qs.UO(this.KKe),
            this.KKe = null,
            this.UKe = null,
            this.zKe = null,
            this.wki = null,
            this.ZWe && URL.revokeObjectURL(this.ZWe),
            this.ZWe = "",
            jB.Qs.L6(this.VKe)
        }
    }
    ;
    jB.Qs.mk.iit.addEventListener("load", () => {
        jB.Qs.Ks.rit(HB, KB)
    }
    )
}
{
    const qB = self.t
      , XB = qB.bW(import.meta.url)
      , YB = XB.getElementById("viewIconSheetsDialog")
      , JB = (qB.IW(XB.URL),
    "ViewIconSheets")
      , ZB = qB.Qs.Fk.XKe = class extends qB.Qs.Ks {
        constructor() {
            super(YB),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.YKe = this.Pet("viewIconSheetsList"),
            this.JKe = []
        }
        $et() {}
        Xa(t) {
            let i = -1
              , e = null
              , s = 0
              , n = 0
              , r = 0
              , h = 0;
            for (let t of qB.Qs.hki.Bki()) {
                let o = t.Pki();
                if (!o)
                    continue;
                let a = t.ARi();
                a !== i && (i = a,
                h = 0,
                e && this.YKe.appendChild(e),
                e = document.createElement("div"),
                e.className = "sizeWrap",
                e.insertAdjacentHTML("beforeend", `<h3>Icon size ${a} x ${a}</h3>`)),
                ++n,
                r += t.Gki();
                let l = document.createElement("div");
                l.className = "sheetWrap";
                let u = t.jRi();
                l.insertAdjacentHTML("beforeend", `<p>Sheet #${h} (${u} x ${u}, ${t.Gki()} icons)`),
                o.className = "transparent-checkerboard-pattern",
                o.style.width = t.URi() + "px",
                o.style.height = t.URi() + "px",
                this.JKe.push(o),
                l.appendChild(o),
                e.appendChild(l),
                s += u * u,
                ++h
            }
            e && this.YKe.appendChild(e);
            let o = s / 1048576;
            return this.YKe.insertAdjacentHTML("afterbegin", `<p>Total icon sheet area: ${Math.round(100 * o) / 100} megapixels (${r} images over ${n} sheets)</p>`),
            super.Xa(t)
        }
        xO() {
            qB.Qs.L6(this.YKe);
            for (let t of this.JKe)
                t.style.width = "",
                t.style.height = "",
                t.className = "";
            qB.Io(this.JKe)
        }
    }
    ;
    qB.Qs.mk.iit.addEventListener("load", () => {
        qB.Qs.Ks.rit(JB, ZB)
    }
    )
}
{
    const QB = self.t
      , tU = self.lang
      , iU = self.h_
      , eU = self.e_
      , sU = QB.bW(import.meta.url)
      , nU = sU.getElementById("viewSpritesheetsDialog")
      , rU = QB.IW(sU.URL);
    QB.p.MW(rU + "lang");
    const hU = "ViewSpritesheets"
      , oU = [.1, 1 / 4, 1 / 3, .5, 2 / 3, 3 / 4, 1, 1.5, 2]
      , aU = QB.Qs.Fk.ZKe = class extends QB.Qs.Ks {
        constructor() {
            super(nU),
            this.QKe = this.Pet("statusText"),
            this.tqe = this.Pet("zoomSlider"),
            this.tqe.addEventListener("input", () => this.iqe()),
            this.eqe = this.Pet("zoomLabel"),
            this.uCt = null,
            this.sqe = 0,
            this.nqe = 0,
            this.rqe = 0,
            this.hqe = 0,
            this.oqe = [],
            this.aqe = new Map,
            this.lqe = [],
            this.YKe = this.Pet("viewSpritesheetsList")
        }
        $et() {}
        Xa(t, i) {
            QB.U(t, self.jw),
            QB.p.u("ui.dialogs.view-spritesheets"),
            this.uCt = t,
            this.Wa(iU(".caption", this.uCt.La())),
            this.QKe.textContent = self.lang(".loading"),
            this.tqe.value = 6,
            this.iqe(),
            QB.Qs.L6(this.YKe),
            QB.Io(this.lqe),
            localforage.getItem("view-spritesheets-options").then(t => {
                t && (this.tqe.value = t.zoomSetting ?? 6,
                this.iqe())
            }
            ).catch(QB.wS),
            this.sqe = 0,
            this.nqe = 0;
            const e = [];
            for (const t of this.uCt.uqe())
                this.sqe++,
                e.push(t.cqe().then( () => this.dqe()));
            return Promise.all(e).then( () => this.fqe()),
            QB.p.j(),
            super.Xa(i)
        }
        dqe() {
            this.nqe++;
            const t = this.nqe / this.sqe;
            this.QKe.textContent = iU("ui.dialogs.view-spritesheets.building-spritesheets", Math.round(1e3 * t) / 10)
        }
        fqe() {
            this.rqe = 0,
            this.hqe = 0;
            for (const t of this.uCt.uqe())
                for (const i of t.pqe())
                    this.rqe++,
                    this.oqe.push(i);
            this.mqe().then( () => this.wqe())
        }
        mqe() {
            const t = this.oqe.map(t => t.gqe().then( () => {
                this.uCt && this.yqe(t)
            }
            ));
            return Promise.all(t)
        }
        yqe(t) {
            this.aqe.set(t, {
                blob: t.bqe(),
                vqe: t.Sqe()
            }),
            this.hqe++;
            const i = this.hqe / this.rqe;
            this.QKe.textContent = iU("ui.dialogs.view-spritesheets.rendering-spritesheets", Math.round(1e3 * i) / 10)
        }
        wqe() {
            if (!this.uCt)
                return;
            QB.p.u("ui.dialogs.view-spritesheets");
            let t = 0
              , i = 0
              , e = 0;
            for (const s of this.uCt.xqe()) {
                const n = [...s.Mqe().pqe()];
                if (0 === n.length)
                    continue;
                const r = document.createElement("div");
                r.className = "objectWrap";
                const h = document.createElement("h3")
                  , o = s.Eqe() ? tU(".lossless") : tU(".lossy");
                h.textContent = iU(".shared-collection-header", s.La(), s.Cqe(), o),
                r.appendChild(h);
                const a = document.createElement("div");
                a.className = "sheetCollectionWrap",
                r.appendChild(a);
                let l = 1;
                for (const r of n) {
                    ++i,
                    e += r._qe();
                    const n = document.createElement("div");
                    if (n.className = "sheetWrap",
                    !this.aqe.has(r))
                        throw new Error("missing spritesheet");
                    const {blob: h, vqe: o} = this.aqe.get(r)
                      , u = s.Eqe() ? tU(".lossless") : iU(".lossy-quality", Math.round(100 * r.Tqe()))
                      , c = document.createElement("p")
                      , d = iU(".shared-sheet-number", l);
                    QB.wQ(c, eU(".sheet-details", d, r.ns(), r.er(), QB.Woi(r.ns() * r.er() * 4), QB.Woi(h.size), QB.MimeType.qs(h.type).gpi(), u)),
                    n.appendChild(c);
                    const f = new Image;
                    f.className = "spriteSheet transparent-checkerboard-pattern",
                    f.src = o,
                    this.lqe.push({
                        Iqe: f,
                        width: r.ns(),
                        height: r.er(),
                        Pqe: n
                    }),
                    n.appendChild(f),
                    a.appendChild(n),
                    t += r.ns() * r.er(),
                    ++l
                }
                this.YKe.appendChild(r)
            }
            for (const s of this.uCt.Gqe()) {
                if (!s.ih() && !s.sh())
                    continue;
                if (s.Aqe())
                    continue;
                const n = document.createElement("div");
                n.className = "objectWrap flex";
                for (let r = 0; r < 2; ++r) {
                    const h = 0 === r
                      , o = s.Rqe(h)
                      , a = [...o.pqe()];
                    if (0 === a.length)
                        continue;
                    const l = tU(h ? ".lossless" : ".lossy")
                      , u = document.createElement("div");
                    u.className = "objectCollectionWrap",
                    n.appendChild(u);
                    const c = document.createElement("h3");
                    c.textContent = iU(".collection-header", o.La(), l),
                    u.appendChild(c);
                    const d = document.createElement("div");
                    d.className = "sheetCollectionWrap",
                    u.appendChild(d);
                    let f = 1;
                    for (const s of a) {
                        ++i,
                        e += s._qe();
                        const n = document.createElement("div");
                        if (n.className = "sheetWrap",
                        !this.aqe.has(s))
                            throw new Error("missing spritesheet");
                        const {blob: r, vqe: o} = this.aqe.get(s)
                          , a = h ? tU(".lossless") : iU(".lossy-quality", Math.round(100 * s.Tqe()))
                          , l = document.createElement("p")
                          , u = iU(".sheet-number", f);
                        QB.wQ(l, eU(".sheet-details", u, s.ns(), s.er(), QB.Woi(s.ns() * s.er() * 4), QB.Woi(r.size), QB.MimeType.qs(r.type).gpi(), a)),
                        n.appendChild(l);
                        const c = new Image;
                        c.className = "spriteSheet transparent-checkerboard-pattern",
                        c.src = o,
                        this.lqe.push({
                            Iqe: c,
                            width: s.ns(),
                            height: s.er(),
                            Pqe: n
                        }),
                        n.appendChild(c),
                        d.appendChild(n),
                        t += s.ns() * s.er(),
                        ++f
                    }
                }
                this.YKe.appendChild(n)
            }
            const s = t / 1048576;
            this.QKe.textContent = iU(".summary", Math.round(100 * s) / 100, e, i),
            QB.p.j(),
            this.iqe()
        }
        iqe() {
            const t = oU[this.tqe.value];
            this.eqe.textContent = iU("ui.dialogs.view-spritesheets.zoom-label", Math.floor(100 * t));
            for (const {Iqe: i, width: e, height: s, Pqe: n} of this.lqe) {
                const r = e * t
                  , h = s * t;
                i.width = r,
                i.height = h,
                n.style.width = r < 200 ? "200px" : ""
            }
        }
        xet() {
            this.kqe(),
            super.xet()
        }
        _et() {
            this.kqe(),
            super._et()
        }
        kqe() {
            localforage.setItem("view-spritesheets-options", {
                zoomSetting: this.tqe.value
            }).catch(QB.wS)
        }
        xO() {
            this.uCt = null,
            QB.Qs.L6(this.YKe),
            QB.Io(this.lqe),
            this.aqe.clear(),
            QB.Io(this.oqe)
        }
    }
    ;
    QB.Qs.mk.iit.addEventListener("load", () => {
        QB.Qs.Ks.rit(hU, aU)
    }
    )
}
{
    const lU = self.t
      , uU = lU.bW(import.meta.url)
      , cU = uU.getElementById("viewTileTexturesDialog")
      , dU = (lU.IW(uU.URL),
    "ViewTileTextures")
      , fU = lU.Qs.Fk.Oqe = class extends lU.Qs.Ks {
        constructor() {
            super(cU),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.Dqe = this.Pet("previousButton"),
            this.Dqe.onclick = () => this.Fqe(-1),
            this.EMt = this.Pet("nextButton"),
            this.EMt.onclick = () => this.Fqe(1),
            this.q_ = this.Pet("tiles"),
            this.Ght = this.q_.getContext("2d"),
            this.Hze = this.Pet("tileTexturesControls"),
            this.Lqe = this.Hze.querySelector("span"),
            this.r$i = 1,
            this.h$i = 1
        }
        $et() {}
        Xa() {
            return this.r$i = 1,
            this.h$i = 1,
            this.Bqe(1),
            super.Xa()
        }
        xO() {}
        Fqe(t) {
            this.h$i += t,
            this.h$i < 1 ? this.h$i = 1 : this.h$i > this.r$i && (this.h$i = this.r$i),
            this.Bqe(this.h$i)
        }
        Bqe(t) {
            this.r$i = 1,
            this.Ght.clearRect(0, 0, this.q_.width, this.q_.height),
            this.Ght.setTransform(1, 0, 0, 1, 0, 0);
            let i = 0
              , e = 0;
            for (let s of self.app.nI().Gqe()) {
                if (!(s.$a().ez()instanceof lU.ei.wC))
                    continue;
                let n = [...s.Uqe()];
                if (!n.length)
                    continue;
                let r = n[0].ud().Wm()
                  , h = r._C()
                  , o = r.jC()
                  , a = r.LC()
                  , l = r.DC()
                  , u = r.AC()
                  , c = r.FC()
                  , d = r.kC();
                for (let s of r.Nqe()) {
                    let n = s.jqe() * (h + u) + a
                      , r = s.$qe() * (o + c) + l;
                    t === this.r$i && this.Ght.drawImage(d, n, r, h, o, i, e, h, o),
                    i += h,
                    i > this.q_.width && (i = 0,
                    e += o,
                    e > this.q_.height && (e = 0,
                    this.r$i++))
                }
            }
            this.Lqe.textContent = `   ${this.h$i}/${this.r$i}  `
        }
    }
    ;
    lU.Qs.mk.iit.addEventListener("load", () => {
        lU.Qs.Ks.rit(dU, fU)
    }
    )
}
{
    const pU = self.t
      , mU = self.lang
      , wU = self.Iet
      , gU = self.e_
      , yU = self.h_
      , bU = pU.bW(import.meta.url)
      , vU = bU.getElementById("viewUsedAddonsDialog")
      , SU = pU.IW(bU.URL);
    pU.p.MW(SU + "lang");
    const xU = "ViewUsedAddons"
      , MU = 5
      , EU = pU.Qs.Fk.zqe = class extends pU.Qs.Ks {
        constructor() {
            super(vU),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.Tet = pU.v(pU.Qs.Fk.Table, this.Oet(), {
                border: !0
            });
            let t = this.Tet.Aet();
            pU.p.u("ui.dialogs.viewUsedAddons"),
            t.Get("icon", self.app.Oq() + 4),
            t.Get("name", 90, mU(".name")),
            t.Get("type", 60, mU(".type")),
            t.Get("author", 80, mU(".author")),
            t.Get("source", 80, mU(".source")),
            t.Get("version", 110, mU(".version")),
            t.jet("references", mU(".references")),
            pU.p.j(),
            this.Tet.ket(),
            this.uCt = null,
            this.kf = pU.v(pU.Rf, pU._f.Gf(this.Tet, "rowcontextmenu", t => this.sFt(t)), pU._f.Gf(this.Tet, "tablecontextmenu", t => this.nBt(t)))
        }
        $et() {
            this.o_i.textContent = mU("common.ok")
        }
        Xa(t, i) {
            return this.Wa(yU("ui.dialogs.viewUsedAddons.caption", t.La())),
            this.uCt = t,
            this.Vqe(t),
            super.Xa(i)
        }
        Vqe(t) {
            pU.p.u("ui.dialogs.viewUsedAddons");
            let i = t.Xse()
              , e = [...t.R4t()]
              , s = [...i.Wqe].sort(self.Plugin.Kke)
              , n = [...i.Hqe].sort(self.EOe.OOe)
              , r = [...i.Qse].sort(self.SW.sDe);
            s.forEach(t => this.Kqe(t, e)),
            n.forEach(t => this.qqe(t, e)),
            r.forEach(i => this.Xqe(i, t, e)),
            pU.p.j()
        }
        Kqe(t, i) {
            let e = this.Tet.Wet(t);
            if (e.Xet("icon", t.M8()),
            e.Yet("name", t.La()),
            e.Yet("type", mU(".addon-types.plugin")),
            e.Yet("author", t.rse()),
            e.Yet("source", wU(".addon-sources." + t.Hot())),
            "project" === t.Hot() && pU.Li.bOe(t.Bk(), null)) {
                const i = t.a6()
                  , s = pU.Li.ed(t.Bk(), null).a6();
                s === i ? e.Yet("version", gU(".version-bundled-same-as-builtin", i, i)) : e.Yet("version", gU(".version-bundled-different-to-builtin", i, s))
            } else
                e.Yet("version", t.a6());
            let s = this.Yqe(t, i);
            e.Yet("references", this.Jqe(s))
        }
        qqe(t, i) {
            let e = this.Tet.Wet(t);
            if (e.Xet("icon", t.M8()),
            e.Yet("name", t.La()),
            e.Yet("type", mU(".addon-types.behavior")),
            e.Yet("author", t.rse()),
            e.Yet("source", wU(".addon-sources." + t.Hot())),
            "project" === t.Hot() && pU.F.bOe(t.Bk(), null)) {
                const i = t.a6()
                  , s = pU.F.ed(t.Bk(), null).a6();
                s === i ? e.Yet("version", gU(".version-bundled-same-as-builtin", i, i)) : e.Yet("version", gU(".version-bundled-different-to-builtin", i, s))
            } else
                e.Yet("version", t.a6());
            let s = this.Zqe(t, i);
            e.Yet("references", this.Jqe(s))
        }
        Xqe(t, i, e) {
            let s = this.Tet.Wet(t);
            if (s.Xet("icon", self.app.u0("effect")),
            s.Yet("name", t.La()),
            s.Yet("type", mU(".addon-types.effect")),
            s.Yet("author", t.rse()),
            s.Yet("source", wU(".addon-sources." + t.Hot())),
            "project" === t.Hot() && pU.bDe.bOe(t.Bk(), null)) {
                const i = t.a6()
                  , e = pU.bDe.ed(t.Bk(), null).a6();
                e === i ? s.Yet("version", gU(".version-bundled-same-as-builtin", i, i)) : s.Yet("version", gU(".version-bundled-different-to-builtin", i, e))
            } else
                s.Yet("version", t.a6());
            let n = this.Qqe(t, i, e);
            s.Yet("references", this.Jqe(n))
        }
        Yqe(t, i) {
            return i.filter(i => i.$a() === t).map(t => t.La())
        }
        Zqe(t, i) {
            let e = [];
            for (let s of i)
                if (s.$a().WA())
                    for (let i of s.xvi())
                        i.wre() === t && e.push(s.La());
            return e
        }
        Qqe(t, i, e) {
            let s = [];
            for (let i of e)
                if (i.$a().UA())
                    for (let e of i.tXe())
                        e.Bne() === t && s.push(i.La());
            for (let e of i.xse()) {
                for (let i of e.tXe())
                    if (i.Bne() === t) {
                        s.push(yU(".layout-reference", e.La()));
                        break
                    }
                for (let i of e.tA())
                    for (let n of i.tXe())
                        if (n.Bne() === t) {
                            s.push(yU(".layer-reference", e.La(), i.La()));
                            break
                        }
            }
            return s
        }
        Jqe(t) {
            return t.length > MU ? t.slice(0, MU).join(", ") + "... " + yU(".more-references", t.length - MU) : t.join(", ")
        }
        nBt(t) {
            this.nKt(null, t.clientX, t.clientY)
        }
        sFt(t) {
            this.nKt(t.Eet, t.clientX, t.clientY)
        }
        nKt(t, i, e) {
            let s = pU.v(pU.Qs.EA, this.Oet());
            if (pU.p.u("ui.dialogs.viewUsedAddons.context-menu"),
            t) {
                const i = t.Do();
                if (s._A("search", mU("common.find-all-references"), () => this.GHt(i)),
                s.YA(),
                "project" === i.Hot() && pU.bme.bOe(i.W7(), i.Bk(), null)) {
                    const t = i.a6()
                      , e = pU.bme.ed(i.W7(), i.Bk(), null).a6();
                    pU.Qoi(t, e) < 0 && (s._A("update", mU(".update-to-editor-version"), () => this.iXe(i, t, e)),
                    s.YA())
                }
            }
            s._A("help", mU(".help"), () => this.Sat()),
            s.NT(i, e),
            pU.p.j()
        }
        GHt(t) {
            const i = this.uCt;
            this.xet(),
            self.zT.xT(t, i)
        }
        iXe(t, i, e) {
            this.uCt.eXe(t);
            pU.Qs.Ks.qs("OK").Xa(gU("ui.dialogs.viewUsedAddons.update-confirmation", t.La(), i, e))
        }
        Sat() {
            self.app.FT("", "ViewUsedAddonsHelp")
        }
        xO() {
            this.Tet.Ry(),
            this.uCt = null
        }
    }
    ;
    pU.Qs.mk.iit.addEventListener("load", () => {
        pU.Qs.Ks.rit(xU, EU)
    }
    )
}
{
    const CU = self.t
      , _U = self.lang
      , TU = self.h_
      , IU = CU.bW(import.meta.url)
      , PU = IU.getElementById("textPreviewDialog")
      , GU = CU.IW(IU.URL);
    CU.p.MW(GU + "lang");
    const AU = "TextPreview"
      , RU = new Map([["application/javascript", "javascript"], ["text/javascript", "javascript"], ["application/typescript", "javascript"], ["text/typescript", "javascript"], ["text/css", "css"], ["text/markdown", "markdown"], ["text/html", "html"], ["application/json", "json"], ["text/xml", "xml"], ["image/svg+xml", "xml"]])
      , kU = CU.Qs.Fk.sXe = class extends CU.Qs.Ks {
        #z = null;
        #V = NaN;
        #W = null;
        #H = "";
        constructor() {
            super(PU),
            this.#z = null,
            this.#W = () => this.#K(),
            this.addEventListener("resize", this.#W),
            this.addEventListener("widthchange", this.#W),
            this.addEventListener("heightchange", this.#W),
            this.Oet().addEventListener("contextmenu", CU.Qs.gdt)
        }
        $et() {}
        async Xa(t, i) {
            CU.M4(t),
            CU.zt(i),
            this.#H = RU.get(i),
            CU.a7(t.name) && (this.#H = "javascript"),
            CU.n7(t.name) && (this.#H = "javascript");
            const e = _U(`ui.dialogs.textPreview.${this.#H ?? "other"}`);
            this.Wa(TU("ui.dialogs.textPreview.caption", e));
            const s = super.Xa();
            await CU.nEt.oEt();
            let n = await CU.Ist(t);
            const r = globalThis.app.aU()
              , h = {
                dropIntoEditor: {
                    enabled: !1
                },
                contextmenu: !1,
                links: !1,
                hover: {
                    enabled: !1
                },
                theme: CU.nEt.rXt(),
                fontSize: r.textEditorFontSize || 12,
                autoIndent: r.textEditorAutoIndent ? "advanced" : "keep",
                wordWrap: r.textEditorEnableWordWrap ? "on" : "off",
                minimap: {
                    enabled: r.textEditorEnableMinimap,
                    scale: r.textEditorMinimapScale
                },
                stickyScroll: {
                    enabled: r.textEditorEnableStickyScrolling
                },
                folding: r.textEditorEnableCodeFolding,
                value: n,
                readOnly: !0
            };
            this.#H && (h.language = this.#H),
            this.#z = globalThis.monaco.editor.create(this.Oet(), h);
            const o = this.#z.getModel()
              , a = /\bhttps?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b(?:\/[-a-zA-Z0-9@:%_+.~#?&/=]*)?/gi;
            n = o.getValue();
            const l = [];
            let u = a.exec(n);
            for (; u; ) {
                const t = u[0]
                  , i = u.index
                  , e = i + t.length
                  , s = o.getPositionAt(i)
                  , r = o.getPositionAt(e);
                l.push({
                    range: new globalThis.monaco.Range(s.lineNumber,s.column,r.lineNumber,r.column),
                    options: {
                        inlineClassName: "link-decoration"
                    }
                }),
                u = a.exec(n)
            }
            return this.#z.deltaDecorations([], l),
            this.#z.onMouseDown(t => {
                const i = t.target.position;
                if (!i)
                    return;
                const e = o.getOffsetAt(i);
                let s = ""
                  , r = a.exec(n);
                for (; r; ) {
                    const t = r.index
                      , i = r.index + r[0].length;
                    if (e >= t && e <= i) {
                        s = r[0];
                        break
                    }
                    a.exec(n)
                }
                s && globalThis.open(s, "_blank")
            }
            ),
            globalThis.requestAnimationFrame( () => {
                this.#z && this.#z.layout()
            }
            ),
            s
        }
        xO() {
            this.#z && (this.#z.dispose(),
            this.#z = null),
            this.#H = ""
        }
        #K() {
            CU.ub(this.#V) || (this.#V = globalThis.requestAnimationFrame( () => {
                this.#z && this.#z.layout(),
                this.#V = NaN
            }
            ))
        }
    }
    ;
    CU.Qs.mk.iit.addEventListener("load", () => {
        CU.Qs.Ks.rit(AU, kU)
    }
    )
}
{
    const OU = self.t
      , DU = self.lang
      , FU = self.h_
      , LU = OU.bW(import.meta.url)
      , BU = LU.getElementById("addonManagerDialog")
      , UU = OU.IW(LU.URL);
    OU.p.MW(UU + "lang");
    const NU = "AddonManager";
    function jU(t, i) {
        const e = t.trim().split(".").map(t => Number.parseInt(t, 10))
          , s = i.trim().split(".").map(t => Number.parseInt(t, 10));
        for (; e.length < s.length; )
            e.push(0);
        for (; s.length < e.length; )
            s.push(0);
        for (let t = 0, i = e.length; t < i; ++t) {
            const i = e[t] - s[t];
            if (0 !== i)
                return i
        }
        return 0
    }
    let $U = !1;
    const zU = new Set
      , VU = OU.Qs.Fk.ntt = class extends OU.Qs.Ks {
        constructor() {
            super(BU),
            this.JIt = this.Pet("searchInput"),
            this.JIt.setAttribute("placeholder", DU("common.search-input-placeholder")),
            this.JIt.addEventListener("input", () => this.nXe()),
            this.rXe = this.Pet("showBuiltInCheck"),
            this.rXe.addEventListener("input", () => this.nXe()),
            this.hXe = this.Pet("showUpdatesCheck"),
            this.hXe.addEventListener("input", () => this.nXe()),
            this.oXe = this.Pet("showOnlySdkV1"),
            this.oXe.addEventListener("input", () => this.nXe()),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.aXe = this.Pet("installAddon"),
            this.aXe.onclick = () => this.lXe(),
            this.uXe = this.Pet("updateAll"),
            this.uXe.onclick = () => this.cXe([...zU]),
            this.dXe = this.Pet("installDevAddon"),
            this.dXe.onclick = () => this.fXe(),
            this.dXe.style.display = "none",
            this.Tet = OU.v(OU.Qs.Fk.Table, this.Oet(), {
                border: !0
            }),
            this.pXe = 0;
            let t = this.Tet.Aet();
            OU.p.u("ui.dialogs.addonManager"),
            t.Get("icon", self.app.Oq() + 4),
            t.Get("name", 110, DU(".name")),
            t.Get("type", 70, DU(".type")),
            t.Get("version", 100, DU(".version")),
            t.Get("author", 100, DU(".author")),
            t.Get("source", 100, DU(".source")),
            t.jet("description", DU(".description")),
            OU.p.j();
            let i = OU.v(OU.Qs._q, self.app.oi("info"))
              , e = this.Pet("restartPendingMessage");
            e.insertBefore(i.k_(), e.firstChild),
            this.Tet.addEventListener("rowcontextmenu", t => this.gO(t, t.Eet)),
            this.Tet.ket()
        }
        $et() {
            OU.p.u("ui.dialogs.addonManager"),
            this.o_i.textContent = DU("common.done"),
            this.Wa(DU(".caption")),
            this.Pet("addonManagerHeaderText").textContent = DU(".loading-text"),
            this.Pet("showBuiltInCheckLabel").textContent = DU(".show-built-in"),
            this.Pet("showUpdatesLabel").textContent = DU(".show-updates-only"),
            this.Pet("showOnlySdkV1Label").textContent = DU(".show-only-legacy-addons"),
            this.Pet("restartPendingMessageText").textContent = DU(".restart-pending-message"),
            this.aXe.textContent = DU(".install-new-addon"),
            this.uXe.textContent = DU(".update-all"),
            this.dXe.textContent = DU(".add-dev-addon");
            const t = this.Pet("addonExchangeLink");
            t.textContent = DU(".get-addons"),
            t.onclick = () => self.app.pQ(OU.dQ.URL.Lme, "AddonManager", "GetAddons"),
            OU.p.j()
        }
        Xa(t) {
            this.Tet.k_().style.display = "none",
            Promise.all([OU.Li.vOe(), OU.F.vOe()]).then( () => this.Vqe()),
            this.mXe(),
            this.JIt.value = "",
            this.rXe.checked = !0,
            this.hXe.checked = !1,
            this.oXe.checked = !1;
            const i = super.Xa(t);
            return this.dXe.style.display = self.app.Tme() ? "" : "none",
            localforage.getItem("addon-manager-options").then(t => {
                t && (this.rXe.checked = !!t.showBuiltIn,
                this.hXe.checked = !!t.showUpdatesOnly,
                this.oXe.checked = !!t.showOnlySdkV1,
                this.nXe())
            }
            ).catch(OU.wS),
            i
        }
        Vqe() {
            OU.p.u("ui.dialogs.addonManager"),
            this.Tet.k_().style.display = "",
            this.Pet("addonManagerHeaderText").textContent = DU(".header-text");
            const t = [OU.Li.SOe(), ...OU.Li.plugins(null, !0)];
            t.sort(self.Plugin.Kke);
            const i = [...OU.F.BOe(null, !0)];
            i.sort(self.EOe.OOe);
            const e = [...OU.bDe.effects(null, !0)];
            e.sort(self.SW.sDe);
            const s = [...OU.bme.addons("theme", null)];
            s.sort(self.vFe.sDe);
            const n = [...OU.bme.addons("tour", null)];
            n.sort(self.GFe.sDe);
            const r = [...n, ...s, ...t, ...i, ...e];
            for (const t of r)
                (OU.Jvt(t) || "built-in" !== t.Hot()) && this.FBt(t);
            for (const t of r)
                OU.Jvt(t) || "built-in" !== t.Hot() || this.FBt(t);
            OU.p.j(),
            OU.Qs.eit(this.uXe, "hidden", 0 === zU.size),
            this.nXe()
        }
        FBt(t) {
            if (OU.Jvt(t)) {
                const i = this.Tet.Wet(t);
                return i.Yet("name", t.qke),
                i.Yet("type", DU(".addon-types." + t._Ue)),
                i.Yet("source", DU(".addon-sources." + t.source)),
                void i.Yet("description", DU(".safe-mode-deactivated"))
            }
            const i = t.W7();
            if ("plugin" === i)
                this.Kqe(t);
            else if ("behavior" === i)
                this.qqe(t);
            else if ("effect" === i)
                this.Xqe(t);
            else if ("theme" === i)
                this.wXe(t);
            else {
                if ("tour" !== i)
                    throw new Error(`unknown addon type '${i}'`);
                this.gXe(t)
            }
        }
        Kqe(t) {
            const i = this.Tet.Wet(t);
            i.Xet("icon", t.M8()),
            i.Yet("name", t.La()),
            i.Yet("type", DU(".addon-types.plugin")),
            i.Yet("author", t.rse()),
            i.Yet("source", DU(".addon-sources." + t.Hot())),
            i.Yet("description", t.nse());
            let e = t.a6() + (t instanceof self.sOe ? ` (SDK v${t.bke()})` : "");
            const s = t.VPe();
            s && (e += `\n[b]${FU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Yet("version", new OU.ix(e,{
                AU: !0
            }))
        }
        qqe(t) {
            const i = this.Tet.Wet(t);
            i.Xet("icon", t.M8()),
            i.Yet("name", t.La()),
            i.Yet("type", DU(".addon-types.behavior")),
            i.Yet("author", t.rse()),
            i.Yet("source", DU(".addon-sources." + t.Hot())),
            i.Yet("description", t.nse());
            let e = t.a6() + (t instanceof self.FOe ? ` (SDK v${t.bke()})` : "");
            const s = t.VPe();
            s && (e += `\n[b]${FU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Yet("version", new OU.ix(e,{
                AU: !0
            }))
        }
        Xqe(t) {
            const i = this.Tet.Wet(t);
            i.Xet("icon", self.app.u0("effect")),
            i.Yet("name", t.La()),
            i.Yet("type", DU(".addon-types.effect")),
            i.Yet("author", t.rse()),
            i.Yet("source", DU(".addon-sources." + t.Hot())),
            i.Yet("description", t.nse());
            let e = t.a6();
            const s = t.VPe();
            s && (e += `\n[b]${FU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Yet("version", new OU.ix(e,{
                AU: !0
            }))
        }
        wXe(t) {
            const i = this.Tet.Wet(t);
            i.Xet("icon", t.M8()),
            i.Yet("name", t.La()),
            i.Yet("type", DU(".addon-types.theme")),
            i.Yet("author", t.rse()),
            i.Yet("source", DU(".addon-sources." + t.Hot())),
            i.Yet("description", t.nse());
            let e = t.a6();
            const s = t.VPe();
            s && (e += `\n[b]${FU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Yet("version", new OU.ix(e,{
                AU: !0
            }))
        }
        gXe(t) {
            const i = this.Tet.Wet(t);
            i.Xet("icon", t.M8()),
            i.Yet("name", t.La()),
            i.Yet("type", DU(".addon-types.tour")),
            i.Yet("author", t.rse()),
            i.Yet("source", DU(".addon-sources." + t.Hot())),
            i.Yet("description", t.nse());
            let e = t.a6();
            const s = t.VPe();
            s && (e += `\n[b]${FU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Yet("version", new OU.ix(e,{
                AU: !0
            }))
        }
        nXe() {
            const t = this.JIt.value.toLowerCase()
              , i = this.rXe.checked
              , e = this.hXe.checked
              , s = this.oXe.checked;
            for (const n of this.Tet.rows()) {
                const r = n.Do();
                let h = ""
                  , o = ""
                  , a = ""
                  , l = ""
                  , u = !1
                  , c = 1;
                OU.Jvt(r) ? (h = r.qke,
                o = DU(".addon-types." + r._Ue),
                c = r.TUe) : (h = r.La(),
                o = DU(".addon-types." + r.W7()),
                a = r.rse(),
                l = r.nse(),
                u = "built-in" === r.Hot(),
                ("plugin" === r.W7() && r instanceof globalThis.sOe || "behavior" === r.W7() && r instanceof globalThis.FOe) && (c = r.bke())),
                n.eP((!u || i) && (!e || zU.has(r)) && (!s || !u && 1 === c) && (!t || h.toLowerCase().includes(t) || o.toLowerCase().includes(t) || a.toLowerCase().includes(t) || l.toLowerCase().includes(t)))
            }
        }
        xO() {
            this.Tet.Ry()
        }
        gO(t, i) {
            if (!i)
                return;
            const e = self.app;
            let s = this.Oet()
              , n = i.Do();
            OU.p.u("ui.dialogs.addonManager.menu");
            let r = OU.v(OU.Qs.EA, s);
            if (OU.Jvt(n))
                r._A("delete", DU(".uninstall"), () => {
                    this.yXe(n._Ue, n.qke, n.source, "").then(t => {
                        t && this.Tet.wvt(i)
                    }
                    )
                }
                );
            else {
                if (zU.has(n)) {
                    const t = n.VPe();
                    r._A("update", FU(".update", t.version), () => this.cXe([n])),
                    t.yNe && r._A("link", DU(".visit-addon-page"), () => e.pQ(t.yNe)),
                    r.YA()
                }
                "effect" === n.W7() ? r._A("help", DU(".effects-help"), () => e.FT("project-primitives/objects/effects", "AddonManager-EffectHelp")) : "tour" === n.W7() ? r._A("help", DU(".visit-website"), () => e.pQ(n.NFe(), "AddonManager-TourHelp")) : r._A("help", FU(".help", n.La()), () => e.FT(n.foe(), "AddonManager-AddonHelp")),
                "addon" === n.Hot() && (r._A("download", DU(".download-c3addon"), () => this.bXe(n)),
                r.YA()),
                "addon" !== n.Hot() && "dev" !== n.Hot() || r._A("delete", DU(".uninstall"), () => {
                    this.yXe(n.W7(), n.Bk(), n.Hot(), n.La()).then(t => {
                        t && this.Tet.wvt(i)
                    }
                    )
                }
                )
            }
            r.NT(t.clientX, t.clientY),
            OU.p.j()
        }
        async lXe() {
            const t = this.Oet()
              , i = new OU.Qs.ZCi
              , e = await i.Xa(".c3addon", t, !0);
            null !== e && this.XO() && OU.Qs.Fk.ntt.ott(e, this)
        }
        static async ott(t, i, e=!1, s=!1) {
            const n = i ? i.Oet() : null;
            i && i.vXe(!0);
            let r = !1;
            const h = [];
            for (const i of t)
                try {
                    await OU.bme.RUe(i, null, n, e, s) && ($U = !0,
                    r = !0,
                    h.push(i))
                } catch (t) {
                    console.error("Error installing addon: ", t);
                    const i = OU.Qs.Ks.qs("OK");
                    "min-version" === t.message ? await i.Xa(OU.v(OU.ix, FU("ui.dialogs.addonManager.install-min-version-error-message", OU.dPe(t.kUe), OU.dQ.mPe), {
                        links: [location.origin + "/" + OU.fPe(t.kUe)]
                    }), n) : await i.Xa(DU("ui.dialogs.addonManager.install-error-message"), n),
                    h.push(t)
                }
            if (i && (i.mXe(),
            i.vXe(!1)),
            r && !s) {
                const t = OU.Qs.Ks.qs("OK");
                t.Wa(DU("ui.dialogs.addonManager.install-confirmation.title")),
                await t.Xa(DU("ui.dialogs.addonManager.install-confirmation.message"), n)
            }
            return h
        }
        async yXe(t, i, e, s) {
            const n = this.Oet();
            OU.p.u("ui.dialogs.addonManager.uninstall-confirmation");
            const r = OU.Qs.Ks.qs("Confirm").Xa({
                caption: DU(".caption"),
                message: FU(".message", s || i),
                _nt: DU(".uninstall")
            }, n);
            OU.p.j();
            if (null === await r)
                return !1;
            this.vXe(!0);
            try {
                await OU.bme.OUe(t, i, e),
                $U = !0,
                this.mXe();
                const s = OU.Qs.Ks.qs("OK");
                return s.Wa(DU("ui.dialogs.addonManager.uninstall-finished.title")),
                await s.Xa(DU("ui.dialogs.addonManager.uninstall-finished.message"), n),
                !0
            } catch (t) {
                console.error("Error uninstalling addon: ", t);
                const i = OU.Qs.Ks.qs("OK");
                return await i.Xa(DU("ui.dialogs.addonManager.uninstall-error-message"), n),
                !1
            } finally {
                this.vXe(!1)
            }
        }
        bXe(t) {
            const i = t.wOe();
            OU.g7(t.La() + ".c3addon", i)
        }
        mXe() {
            $U && this.Pet("restartPendingMessage").removeAttribute("hidden")
        }
        async fXe() {
            OU.Qs.Fk.ntt.Ume(this)
        }
        static async Ume(t) {
            const i = t ? t.Oet() : null
              , e = OU.Qs.Ks.qs("Input");
            OU.p.u("ui.dialogs.addonManager.dev-addon-install");
            const s = e.Xa({
                caption: DU(".caption"),
                message: DU(".message"),
                label: DU(".url-label"),
                _Ti: "https://localhost:65432/addon.json",
                spellcheck: !1
            });
            OU.p.j();
            const n = await s;
            if (null !== n)
                try {
                    const e = await OU.O4(n);
                    OU.bme.AUe(e),
                    await OU.bme.LUe(n, e, i),
                    $U = !0,
                    t && t.mXe();
                    OU.Qs.Ks.qs("OK").Xa(FU("ui.dialogs.addonManager.dev-install-confirmation", e.id))
                } catch (t) {
                    console.error("Error loading addon JSON: ", t);
                    OU.Qs.Ks.qs("OK").Xa(DU("ui.dialogs.addonManager.dev-install-failed"))
                }
        }
        vXe(t) {
            t ? this.pXe++ : this.pXe--,
            OU.Qs.eit(this.o_i, "disabled", this.pXe > 0)
        }
        xet() {
            this.pXe > 0 || (localforage.setItem("addon-manager-options", {
                showBuiltIn: this.rXe.checked,
                showUpdatesOnly: this.hXe.checked,
                showOnlySdkV1: this.oXe.checked
            }).catch(OU.wS),
            super.xet())
        }
        wG(t) {
            return t.which === OU.Mk.VJ && document.activeElement === this.JIt ? (this.JIt.value = "",
            this.nXe(),
            t.preventDefault(),
            void t.stopPropagation()) : super.wG(t)
        }
        static async SXe() {
            await globalThis.app.Dde();
            const t = ["plugin", "behavior", "effect", "theme"]
              , i = [];
            for (const e of t) {
                const t = await Promise.all([...OU.bme.IUe(e)].map(t => OU.bme.CUe(e, t)));
                OU.Oo(i, t.map(t => ({
                    _Ue: e,
                    xXe: t
                })))
            }
            const e = {
                addons: i.map(t => ({
                    type: t._Ue,
                    id: t.xXe.Bk(),
                    currentVersion: t.xXe.a6()
                }))
            };
            try {
                const t = await fetch("/checkaddons.json", {
                    method: "POST",
                    body: JSON.stringify(e)
                });
                if (!t.ok)
                    throw new Error(`fetch '${t.url}' response returned ${t.status} ${t.statusText}`);
                const i = await t.json();
                if (!0 !== i.success || "object" != typeof i.data || !Array.isArray(i.data.foundAddons))
                    throw i;
                for (const t of i.data.foundAddons) {
                    const i = t.type;
                    if (!OU.bme.XUe(i))
                        continue;
                    const e = t.id;
                    if (!OU.bme.bOe(i, e))
                        continue;
                    const s = OU.bme.ed(i, e)
                      , n = t.releases.filter(t => "Stable" === t.branch);
                    if (0 === n.length)
                        continue;
                    n.sort( (t, i) => jU(t.version, i.version));
                    const r = n.at(-1);
                    jU(s.a6(), r.version) >= 0 || (s.zPe({
                        version: r.version,
                        wNe: new Date(r.date),
                        gNe: n.map(t => ({
                            version: t.version,
                            bNe: t.bbCodeReleaseNotes
                        })),
                        MXe: r.downloadURL,
                        yNe: t.url
                    }),
                    zU.add(s))
                }
                if (zU.size > 0) {
                    const t = OU.p.Yue("ui.dialogs.addonManager.addon-updates-available-notification");
                    OU.Qs.Notification.NT("info", t.UHt(".title", null, zU.size), t(".message"), {
                        align: "bottom-left",
                        UEt: 1e4,
                        onclick: async () => {
                            OU.Qs.Ks.qs("AddonManager").Xa()
                        }
                    })
                }
            } catch (t) {
                (() => {})("Failed to check for addon updates: ", t)
            }
        }
        async cXe(t) {
            const i = OU.p.Yue("ui.dialogs.addonManager")
              , e = OU.Qs.Ks.qs("AddonUpdateReview");
            if (null === await e.Xa(t, this.k_()))
                return;
            const s = OU.Qs.Ks.qs("Progress");
            let n = 0;
            s.onprogress = () => n,
            s.Xa(i(".downloading-updates")),
            this.vXe(!0);
            try {
                const e = await OU.lii(t.map(t => OU._4(t.VPe().MXe)), (t, i) => n = t / i);
                s.sW(),
                await OU.Qs.Fk.ntt.ott(e, this, !1, !0);
                const r = OU.Qs.Ks.qs("OK");
                r.Wa(i(".update-confirmation.title")),
                r.Xa(i(".update-confirmation.message"));
                for (const i of t)
                    zU.delete(i);
                OU.Qs.eit(this.uXe, "hidden", 0 === zU.size),
                this.nXe()
            } catch (t) {
                s.sW();
                OU.Qs.Ks.qs("OK").Xa(i(".update-error-message"))
            } finally {
                this.vXe(!1)
            }
        }
    }
    ;
    OU.Qs.mk.iit.addEventListener("load", () => {
        OU.Qs.Ks.rit(NU, VU)
    }
    )
}
{
    const WU = self.t
      , HU = self.r4
      , KU = self.lang
      , qU = WU.bW(import.meta.url)
      , XU = qU.getElementById("settingsDialog")
      , YU = WU.IW(qU.URL);
    WU.p.MW(YU + "lang");
    const JU = "Settings"
      , ZU = WU.Qs.Fk.EXe = class extends WU.Qs.Ks {
        constructor() {
            super(XU),
            this.o_i = this.Pet("okButton"),
            this.o_i.onclick = () => this.xet(),
            this.CXe = this.Pet("resetUserInterface"),
            this.CXe.onclick = () => this._Xe(),
            this.TXe = this.Pet("enableMultiMonitor"),
            this.TXe.onclick = () => this.IXe(),
            this.PXe = this.Pet("enableMultiMonitorWrap"),
            this.GXe = this.Pet("clearRecentProjects"),
            this.GXe.onclick = () => this.GXe.setAttribute("clearRecentProjects", ""),
            this.AXe = this.Pet("downloadBrowserSaves"),
            this.AXe.onclick = () => this.RXe(),
            this.kXe = this.Pet("languageSetting"),
            this.OXe = this.Pet("uiMode"),
            this.DXe = this.Pet("useSimplifiedMode"),
            this.FXe = this.Pet("enableExampleBrowser"),
            this.LXe = this.Pet("theme"),
            this.BXe = this.Pet("useDefaultIconColor"),
            this.UXe = this.Pet("iconColor"),
            this.NXe = this.Pet("defaultSaveLocation"),
            this.jXe = this.Pet("enableAutosave"),
            this.$Xe = this.Pet("autosaveDuration"),
            this.zXe = this.Pet("autosaveLocation"),
            this.zXe.addEventListener("change", () => this.VXe()),
            this.WXe = this.Pet("localBackupFolderSection"),
            this.HXe = this.Pet("localBackupFolderStatus"),
            this.KXe = this.Pet("localBackupFolderChoose"),
            this.KXe.addEventListener("click", () => this.qXe()),
            this.XXe = this.Pet("textEditorFontSize"),
            this.YXe = this.Pet("textEditorAutoIndent"),
            this.JXe = this.Pet("textEditorWordWrap"),
            this.ZXe = this.Pet("textEditorShowMinimap"),
            this.QXe = this.Pet("textEditorMinimapScale"),
            this.tYe = this.Pet("textEditorStickyScrolling"),
            this.iYe = this.Pet("textEditorEnableCodeFolding"),
            this.eYe = this.Pet("enableUIAnims"),
            this.sYe = this.Pet("enableUIEffects"),
            this.nYe = this.Pet("enableNotifications"),
            this.rYe = this.Pet("showTakeBreakReminders"),
            this.hYe = this.Pet("zoomMouseWheelOnly"),
            this.oYe = this.Pet("useFakeClipboard"),
            this.aYe = this.Pet("inProgressLanguages"),
            this.lYe = this.Pet("experimentalFeatures"),
            this.uYe = this.Pet("enableDeveloperMode"),
            this.cYe = this.Pet("cacheCloudMetadata"),
            this.dYe = this.Pet("limitToWebGL1"),
            this.fYe = this.Pet("enableWebGPUInEditor"),
            this.pYe = this.Pet("showStartPage"),
            this.mYe = this.Pet("autoHideStartPage"),
            this.wYe = this.Pet("showStartPageMessageBanners"),
            this.gYe = this.Pet("hideAddActionRows"),
            this.yYe = this.Pet("translateExpressions"),
            this.bYe = this.Pet("gpuPowerPreference"),
            this.vYe = this.Pet("previewMode"),
            this.SYe = this.Pet("updateChannel"),
            this.xYe = this.Pet("enableAddonUpdateChecks"),
            this.MYe = this.Pet("defaultProjectAuthor"),
            this.EYe = this.Pet("defaultProjectEmail"),
            this.CYe = this.Pet("defaultProjectWebsite"),
            this._Ye = this.Pet("defaultAnimationSpeed"),
            this.TYe = () => this.IYe(),
            this.PYe = () => this.GYe(),
            this.AYe = () => this.RYe(),
            this.BXe.onclick = () => this.kYe(),
            this.jXe.onclick = () => this.OYe(),
            this.DYe = "",
            this.FYe = 0,
            this.dCi().addEventListener("pointerdown", () => this.LYe()),
            globalThis.app.Bme() || (this.Pet("enableAddonUpdateChecksWrap").style.display = "none"),
            WU.$M && (this.BYe("synthetic-rockdots", " (synthetic-rockdots)"),
            this.BYe("synthetic-leet", "|_337 (synthetic-leet)"),
            this.BYe("synthetic-uppercase", "UPPERCASE (synthetic-uppercase)"),
            this.BYe("synthetic-lowercase", "lowercase (synthetic-lowercase)"),
            this.BYe("synthetic-repeat-2", "rreeppeeaatt22 (synthetic-repeat-2)"),
            this.BYe("synthetic-repeat-3", "rrreeepppeeeaaattt333 (synthetic-repeat-3)"),
            this.BYe("synthetic-repeat-4", "rrrreeeeppppeeeeaaaatttt4444 (synthetic-repeat-4)")),
            (WU.$M || self.app.aU().showInProgressLanguages) && (this.BYe("id-ID", "Bahasa Indonesia [incomplete]", "Indonesian"),
            this.BYe("bs-BA", "Bosanski [incomplete]", "Bosnian"),
            this.BYe("pl-PL", "Polski [incomplete]", "Polish"),
            this.BYe("ro-RO", "Romn [incomplete]", "Romanian"),
            this.BYe("ko-KR", " [incomplete]", "Korean"),
            this.BYe("th-TH", " [incomplete]", "Thai"))
        }
        BYe(t, i, e) {
            const s = document.createElement("option");
            s.value = t,
            s.text = i,
            e && s.setAttribute("title", e),
            this.kXe.add(s)
        }
        $et() {
            const t = self.app;
            WU.p.u("ui.dialogs.settings"),
            this.Wa(KU(".caption")),
            this.o_i.textContent = KU(".close");
            const i = this.Pet("helpLink");
            i.textContent = KU("common.help"),
            i.onclick = () => t.FT("interface/dialogs/settings", "SettingsDialog"),
            this.Pet("settingsUIHeader").textContent = KU(".user-interface.header"),
            WU.p.u(".editor-settings"),
            this.Pet("languageLabel").textContent = KU(".language"),
            this.Pet("uiModeLabel").textContent = KU(".ui-mode.label");
            for (let t = 0, i = this.OXe.options.length; t < i; ++t) {
                const i = this.OXe.options[t];
                i.textContent = KU(".ui-mode." + i.value)
            }
            this.Pet("useSimplifiedModeLabel").textContent = KU(".simplified-mode"),
            this.Pet("enableExampleBrowserLabel").textContent = KU(".enable-example-browser"),
            this.Pet("themeLabel").textContent = KU(".theme.label");
            const e = document.createElement("option");
            e.value = "",
            e.textContent = KU(".theme.default"),
            this.LXe.add(e);
            const s = [...WU.bme.addons("theme")].sort(self.vFe.sDe);
            for (const t of s) {
                const i = document.createElement("option");
                i.value = t.Bk(),
                i.textContent = t.La(),
                this.LXe.add(i)
            }
            this.TXe.textContent = KU(".enable-multi-monitor-features"),
            this.CXe.textContent = KU(".reset-user-interface.label"),
            this.GXe.textContent = KU(".clear-recent-projects"),
            this.AXe.textContent = KU(".download-browser-saves"),
            this.Pet("useDefaultIconColorLabel").textContent = KU(".use-default-icon-color"),
            this.Pet("iconColorLabel").textContent = KU(".icon-color-label"),
            this.Pet("enableUIAnimsLabel").textContent = KU(".enable-ui-animations"),
            this.Pet("enableUIEffectsLabel").textContent = KU(".enable-ui-effects"),
            this.Pet("enableNotificationsLabel").textContent = KU(".enable-notifications"),
            this.Pet("showTakeBreakRemindersLabel").textContent = KU(".show-take-a-break-reminder"),
            this.Pet("zoomMouseWheelOnlyLabel").textContent = KU(".zoom-mouse-wheel-only"),
            this.Pet("useFakeClipboardLabel").textContent = KU(".use-in-app-clipboard"),
            this.Pet("enableDeveloperModeLabel").textContent = KU(".enable-developer-mode"),
            this.Pet("cacheCloudMetadataLabel").textContent = KU(".cache-cloud-meta"),
            this.Pet("limitToWebGL1Label").textContent = KU(".limit-to-webgl1"),
            WU.p.u(".gpu-power-preference"),
            this.Pet("gpuPowerPreferenceLabel").textContent = KU(".label");
            for (let t = 0, i = this.bYe.options.length; t < i; ++t) {
                const i = this.bYe.options[t];
                i.textContent = KU("." + i.value)
            }
            WU.p.j(),
            WU.p.u(".enable-webgpu-in-editor"),
            this.Pet("enableWebGPUInEditorLabel").textContent = KU(".label");
            for (let t = 0, i = this.fYe.options.length; t < i; ++t) {
                const i = this.fYe.options[t];
                i.textContent = KU("." + i.value)
            }
            if (WU.p.j(),
            WU.p.j(),
            WU.p.u(".text-editor-settings"),
            this.Pet("settingsTextEditorHeader").textContent = KU(".header"),
            this.Pet("textEditorFontSizeLabel").textContent = KU(".font-size"),
            this.Pet("textEditorAutoIndentLabel").textContent = KU(".auto-indent"),
            this.Pet("textEditorWordWrapLabel").textContent = KU(".word-wrap"),
            this.Pet("textEditorShowMinimapLabel").textContent = KU(".show-minimap"),
            this.Pet("textEditorStickyScrollingLabel").textContent = KU(".use-sticky-scrolling"),
            this.Pet("textEditorEnableCodeFoldingLabel").textContent = KU(".enable-code-folding"),
            WU.p.u(".minimap-scale"),
            this.Pet("textEditorMinimapScaleLabel").textContent = KU(".label"),
            this.QXe.item(0).textContent = KU(".1x"),
            this.QXe.item(1).textContent = KU(".2x"),
            this.QXe.item(2).textContent = KU(".3x"),
            WU.p.j(),
            WU.p.j(),
            WU.p.u(".backup-settings"),
            this.Pet("settingsSaveHeader").textContent = KU(".header"),
            WU.p.u(".default-save-location"),
            this.Pet("defaultSaveLocationLabel").textContent = KU(".label"),
            this.NXe.item(0).textContent = KU(".cloud"),
            this.NXe.item(1).textContent = KU(".local-browser"),
            this.NXe.item(2).textContent = KU(".download-a-copy"),
            WU.QL.G2) {
                const t = document.createElement("option");
                t.value = "save-as",
                t.textContent = KU(".save-as"),
                this.NXe.add(t)
            }
            WU.p.j(),
            this.Pet("enableAutosaveLabel").textContent = KU(".autosave"),
            this.Pet("autosaveDurationLabel").textContent = KU(".autosave-duration"),
            this.Pet("autosaveLocationLabel").textContent = KU(".autosave-location"),
            this.zXe.item(0).textContent = KU(".locations.browser"),
            this.zXe.item(4).textContent = KU(".locations.match"),
            this.zXe.item(5).textContent = KU(".locations.local-folder"),
            WU.QL.G2 || (this.zXe.item(5).style.display = "none"),
            WU.p.u(".local-backup-folder"),
            this.Pet("localBackupFolderLabel").textContent = KU(".label"),
            this.KXe.textContent = KU(".choose"),
            WU.p.j(),
            WU.p.j(),
            WU.p.u(".default-properties-settings"),
            this.Pet("settingsDefaultPropsHeader").textContent = KU(".header"),
            this.Pet("defaultProjectAuthorLabel").textContent = KU(".default-project-author"),
            this.Pet("defaultProjectEmailLabel").textContent = KU(".default-project-email"),
            this.Pet("defaultProjectWebsiteLabel").textContent = KU(".default-project-website"),
            this.Pet("defaultAnimationSpeedLabel").textContent = KU(".default-animation-speed"),
            WU.p.j(),
            WU.p.u("ui.bars.properties.project"),
            this.EYe.placeholder = KU(".email.placeholder"),
            this.CYe.placeholder = KU(".website.placeholder"),
            WU.p.j(),
            WU.p.u(".update-settings"),
            this.Pet("settingsUpdatesHeader").textContent = KU(".header"),
            this.Pet("updatesDescription").textContent = KU(".beta-description"),
            this.Pet("updateChannelLabel").textContent = KU(".notify-updates-label"),
            this.SYe.item(0).textContent = KU(".stable-releases"),
            this.SYe.item(1).textContent = KU(".beta-releases"),
            this.Pet("enableAddonUpdateChecksLabel").textContent = KU(".check-for-addon-updates"),
            WU.p.j(),
            WU.p.u(".start-page-settings"),
            this.Pet("startPageHeader").textContent = KU(".header"),
            this.Pet("showStartPageLabel").textContent = KU(".show-start-page"),
            this.Pet("autoHideStartPageLabel").textContent = KU(".auto-hide-start-page"),
            this.Pet("showStartPageMessageBannersLabel").textContent = KU(".show-start-page-message-banners"),
            WU.p.j(),
            WU.p.u(".event-sheet-settings"),
            this.Pet("eventSheetHeader").textContent = KU(".header"),
            this.Pet("hideAddActionRowsLabel").textContent = KU(".hide-add-action-rows"),
            this.Pet("translateExpressionsLabel").textContent = KU(".translate-expressions"),
            WU.p.j(),
            WU.p.u(".preview-settings"),
            this.Pet("settingsPreviewHeader").textContent = KU(".header"),
            this.Pet("previewModeLabel").textContent = KU(".preview-with.label");
            for (let t = 0, i = this.vYe.options.length; t < i; ++t) {
                const i = this.vYe.options[t];
                i.textContent = KU(".preview-with." + i.value)
            }
            WU.p.j(),
            WU.p.u(".advanced-settings"),
            this.Pet("settingsAdvancedHeader").textContent = KU(".header"),
            this.Pet("inProgressLanguagesLabel").textContent = KU(".show-in-progress-languages"),
            this.Pet("experimentalFeaturesLabel").textContent = KU(".enable-experimental-features"),
            WU.p.j(),
            WU.p.j(),
            t.ime().then(t => {
                t || (this.NXe.item(1).style.display = "none",
                this.zXe.item(0).style.display = "none",
                this.AXe.style.display = "none")
            }
            )
        }
        Xa(t, i) {
            const e = super.Xa(t)
              , s = self.app
              , n = s.aU();
            return this.kXe.value = n.language,
            this.OXe.value = n.uiMode,
            this.DXe.checked = n.useSimplifiedMode,
            this.FXe.checked = n.enableExampleBrowser,
            this.LXe.value = n.theme,
            this.LXe.value !== n.theme && (this.LXe.value = "",
            n.theme = ""),
            this.CXe.disabled = !1,
            this.PXe.style.display = "none",
            this.UYe(),
            this.BXe.checked = n.useDefaultIconColor,
            this.UXe.value = n.iconColor,
            this.NXe.value = n.defaultSaveLocation,
            this.jXe.checked = n.autoSave,
            this.XXe.value = n.textEditorFontSize,
            this.YXe.checked = n.textEditorAutoIndent,
            this.JXe.checked = n.textEditorEnableWordWrap,
            this.ZXe.checked = n.textEditorEnableMinimap,
            this.ZXe.addEventListener("input", this.AYe),
            this.QXe.value = n.textEditorMinimapScale + "x",
            this.tYe.checked = n.textEditorEnableStickyScrolling,
            this.iYe.checked = n.textEditorEnableCodeFolding,
            this.RYe(),
            this.$Xe.value = n.autosaveDuration,
            this.zXe.value = n.autosaveLocation,
            this.eYe.checked = n.enableUIAnimations,
            this.sYe.checked = n.enableUIEffects,
            this.nYe.checked = n.enableNotifications,
            this.rYe.checked = n.showTakeBreakReminders,
            this.hYe.checked = n.zoomMouseWheelOnly,
            this.oYe.checked = n.useFakeClipboard,
            this.aYe.checked = n.showInProgressLanguages,
            this.lYe.checked = n.experimentalFeatures,
            this.uYe.checked = n.developerMode,
            this.pYe.checked = n.showStartPageOnStartup,
            this.mYe.checked = n.autoHideStartPage,
            this.wYe.checked = n.showStartPageMessageBanners,
            this.gYe.checked = n.hideAddActionRows,
            this.yYe.checked = n.translateExpressions,
            this.bYe.value = n.gpuPowerPreference,
            this.vYe.value = n.previewMode,
            this.SYe.value = n.updateChannel,
            this.xYe.checked = n.checkForAddonUpdates,
            this.cYe.checked = n.cloudCache,
            this.dYe.checked = n.limitToWebGL1,
            this.fYe.value = n.enableWebGPUInEditor,
            this.MYe.value = n.defaultProjectAuthor,
            this.EYe.value = n.defaultProjectEmail,
            this.CYe.value = n.defaultProjectWebsite,
            this._Ye.value = n.defaultAnimationSpeed,
            s.CP() && (this.wYe.checked = !0,
            this.wYe.disabled = !0),
            this.UXe.addEventListener("change", this.TYe),
            this.sYe.addEventListener("change", this.PYe),
            this.kYe(),
            this.DYe = s.MOi(),
            this.FYe = 0,
            s.Tme() || (this.Pet("developerModeWrap").style.display = "none"),
            this.OYe(),
            this.NYe(),
            "backup" === i && (this.Pet("settingsSaveHeader").scrollIntoView(!0),
            this.jXe.focus()),
            e
        }
        kqe() {
            const t = self.app
              , i = t.aU()
              , e = i.uiMode !== this.OXe.value || i.theme !== this.LXe.value
              , s = this.GXe.hasAttribute("clearRecentProjects");
            this.GXe.removeAttribute("clearRecentProjects");
            const n = this.kXe.value || i.language
              , r = e || i.language !== n || i.developerMode !== !!this.uYe.checked || i.gpuPowerPreference !== this.bYe.value || i.previewMode !== this.vYe.value || i.showInProgressLanguages !== this.aYe.checked || i.translateExpressions !== !!this.yYe.checked || i.limitToWebGL1 !== !!this.dYe.checked || i.enableWebGPUInEditor !== this.fYe.value;
            return i.language = n,
            i.uiMode = this.OXe.value,
            i.useSimplifiedMode = !!this.DXe.checked,
            i.enableExampleBrowser = !!this.FXe.checked,
            i.theme = this.LXe.value,
            i.useDefaultIconColor = !!this.BXe.checked,
            i.iconColor = this.UXe.value,
            i.defaultSaveLocation = this.NXe.value,
            i.autoSave = !!this.jXe.checked,
            i.autosaveDuration = WU.Ne(+this.$Xe.value, 1, 60),
            i.textEditorFontSize = WU.Ne(this.XXe.value, 6, 100),
            i.textEditorAutoIndent = !!this.YXe.checked,
            i.textEditorEnableWordWrap = !!this.JXe.checked,
            i.textEditorEnableMinimap = !!this.ZXe.checked,
            i.textEditorMinimapScale = Number.parseInt(this.QXe.value, 10),
            i.textEditorEnableStickyScrolling = !!this.tYe.checked,
            i.textEditorEnableCodeFolding = !!this.iYe.checked,
            i.autosaveLocation = this.zXe.value,
            i.enableUIAnimations = !!this.eYe.checked,
            i.enableUIEffects = !!this.sYe.checked,
            i.enableNotifications = !!this.nYe.checked,
            i.showTakeBreakReminders = !!this.rYe.checked,
            i.zoomMouseWheelOnly = !!this.hYe.checked,
            i.useFakeClipboard = !!this.oYe.checked,
            i.showInProgressLanguages = !!this.aYe.checked,
            i.experimentalFeatures = !!this.lYe.checked,
            i.developerMode = !!this.uYe.checked,
            i.showStartPageOnStartup = !!this.pYe.checked,
            i.autoHideStartPage = !!this.mYe.checked,
            i.showStartPageMessageBanners = !!this.wYe.checked,
            i.hideAddActionRows = !!this.gYe.checked,
            i.translateExpressions = !!this.yYe.checked,
            i.gpuPowerPreference = this.bYe.value,
            i.previewMode = this.vYe.value,
            i.updateChannel = this.SYe.value,
            i.checkForAddonUpdates = !!this.xYe.checked,
            i.cloudCache = !!this.cYe.checked,
            i.limitToWebGL1 = !!this.dYe.checked,
            i.enableWebGPUInEditor = this.fYe.value,
            i.defaultProjectAuthor = this.MYe.value,
            i.defaultProjectEmail = this.EYe.value,
            i.defaultProjectWebsite = this.CYe.value,
            i.defaultAnimationSpeed = WU.Ne(+this._Ye.value, 0, 60),
            this.DYe !== t.MOi() && this.jYe(),
            e && t.$Ye(),
            s && self.Hue.Ry(),
            t.X0i(),
            r
        }
        async UYe() {
            if (WU.Qs.nSi())
                try {
                    "prompt" === (await navigator.permissions.query({
                        name: "window-management"
                    })).state && (this.PXe.style.display = "")
                } catch (t) {
                    (() => {})("Unable to query 'window-management' permission state: ", t)
                }
        }
        async IXe() {
            await WU.Qs.rSi();
            try {
                "prompt" !== (await navigator.permissions.query({
                    name: "window-management"
                })).state && (this.PXe.style.display = "none")
            } catch (t) {
                (() => {})("Unable to query 'window-management' permission state: ", t)
            }
        }
        _Xe() {
            this.CXe.disabled = !0,
            globalThis.app.$Ye();
            WU.Qs.Ks.qs("OK").Xa(KU("ui.dialogs.settings.editor-settings.reset-user-interface.confirmation-message"))
        }
        async zYe() {
            const t = new HU("C3_localFiles")
              , i = await t.keys()
              , e = new Map;
            for (const s of i)
                try {
                    const i = await t.get(s)
                      , n = await WU.rW(i);
                    e.set(s, n)
                } catch (t) {
                    (() => {})("Unable to read blob " + s + ", skipping")
                }
            const s = new HU("localforage")
              , n = await s.get("C3_localMeta");
            return e.set("metadata.json", new Blob([JSON.stringify(n)])),
            e
        }
        async VYe() {
            const t = new WU.u7
              , i = WU.Qs.Ks.qs("Progress");
            i.onprogress = () => {
                let i = t._bi()
                  , e = t.Ebi();
                return 0 === e ? null : i / e
            }
            ,
            i.Xa();
            try {
                const i = await this.zYe();
                return await t.f7(i)
            } catch (t) {
                throw t
            } finally {
                i.sW()
            }
        }
        async RXe() {
            try {
                const t = await this.VYe()
                  , i = new Date
                  , e = `${i.getDate()}-${i.getMonth() + 1}-${i.getFullYear()}T${i.getHours()}-${i.getMinutes()}-${i.getSeconds()}`;
                await WU.g7("browser_saves_" + e + ".zip", t)
            } catch (t) {
                console.error("Error downloading browser saves: ", t);
                WU.Qs.Ks.qs("OK").Xa(KU("ui.dialogs.settings.editor-settings.download-browser-saves-failed"))
            }
        }
        WYe() {
            if (self.app.aU().useSimplifiedMode) {
                return WU.Qs.Ks.qs("OK").Xa(KU("ui.dialogs.settings.simplified-mode-notification"))
            }
            return Promise.resolve()
        }
        HYe() {
            if (self.app.aU().showInProgressLanguages) {
                return WU.Qs.Ks.qs("OK").Xa(KU("ui.dialogs.settings.in-progress-languages-notification"))
            }
            return Promise.resolve()
        }
        xet() {
            const t = this.kqe();
            (async () => {
                if (await this.WYe(),
                await this.HYe(),
                this.KYe() && !await this.qYe()) {
                    const t = WU.Qs.Ks.qs("OK");
                    return void await t.Xa(KU("ui.dialogs.settings.backup-settings.local-backup-folder.need-to-pick-folder"), this.k_())
                }
                if (t) {
                    const t = WU.Qs.Ks.qs("OK");
                    t.Wa(KU("ui.dialogs.settings.restart-notification.caption")),
                    await t.Xa(KU("ui.dialogs.settings.restart-notification.message"), this.k_())
                }
                this.sW(),
                self.app.Y0i("settingschange")
            }
            )()
        }
        _et() {
            this.xet()
        }
        xO() {
            this.ZXe.removeEventListener("input", this.AYe),
            this.UXe.removeEventListener("change", this.TYe),
            this.sYe.removeEventListener("change", this.PYe)
        }
        kYe() {
            WU.Qs.eit(this.UXe, "disabled", this.BXe.checked),
            WU.Qs.eit(this.Pet("iconColorLabel"), "disabled", this.BXe.checked)
        }
        OYe() {
            const t = !this.jXe.checked;
            WU.Qs.eit(this.$Xe, "disabled", t),
            WU.Qs.eit(this.zXe, "disabled", t),
            WU.Qs.eit(this.Pet("autosaveLocationLabel"), "disabled", t),
            WU.Qs.eit(this.Pet("autosaveDurationLabel"), "disabled", t),
            this.VXe()
        }
        RYe() {
            WU.Qs.eit(this.QXe, "disabled", !this.ZXe.checked)
        }
        KYe() {
            return this.jXe.checked && WU.QL.G2 && ("MATCH" === this.zXe.value || "WEBFS FOLDER" === this.zXe.value)
        }
        VXe() {
            this.WXe.style.display = this.KYe() ? "" : "none"
        }
        async qYe() {
            try {
                return await localforage.getItem("local-backup-folder")
            } catch (t) {
                return (() => {})("Error loading backup folder handle: ", t),
                null
            }
        }
        async NYe() {
            if (!WU.QL.G2)
                return;
            const t = await this.qYe();
            this.HXe.textContent = t ? t.name : KU("ui.dialogs.settings.backup-settings.local-backup-folder.none-chosen")
        }
        async qXe() {
            self.assert(WU.QL.G2, "WebFS not supported");
            let t = null;
            try {
                t = await window.showDirectoryPicker({
                    id: "local-backup-folder",
                    mode: "readwrite"
                })
            } catch (t) {
                return
            }
            if (t)
                try {
                    await localforage.setItem("local-backup-folder", t),
                    this.HXe.textContent = t.name
                } catch (t) {
                    (() => {})("Unable to save local backup folder: ", t)
                }
        }
        IYe() {
            self.app.aU().iconColor = this.UXe.value
        }
        async jYe() {
            const t = WU.Qs.wP.BSi();
            self.app.Y0i("settingschange"),
            await t
        }
        GYe() {
            self.app.aU().enableUIEffects = !!this.sYe.checked,
            self.app.Z0i()
        }
        LYe() {
            if (this.FYe++,
            this.FYe >= 10 && self.app.Bme()) {
                WU.Qs.Ks.qs("Confirm").Xa({
                    caption: KU("ui.dialogs.settings.developer-mode-confirmation.caption"),
                    message: KU("ui.dialogs.settings.developer-mode-confirmation.message"),
                    _nt: KU("common.ok"),
                    bnt: KU("common.cancel")
                }).then(t => {
                    null !== t ? this.Pet("developerModeWrap").style.display = "" : this.FYe = 0
                }
                )
            }
        }
    }
    ;
    WU.Qs.mk.iit.addEventListener("load", () => {
        WU.Qs.Ks.rit(JU, ZU)
    }
    )
}
{
    const QU = self.t
      , tN = new Map
      , iN = new Map
      , eN = new Map;
    window.s1 = class extends QU.Me {
        constructor(t, i, e, s, n, r=!0) {
            QU.U(t, QU.Qs.g_),
            QU.zt(i),
            QU.zt(e),
            QU.zt(s),
            QU.cti(n, "#document"),
            super();
            const h = self.app;
            if (this.XYe = s,
            this.Ikt = !1,
            this.YYe = !1,
            this.JYe = !!r,
            this.Iq = () => {
                this.Ikt = !0,
                this.he()
            }
            ,
            this.S_ = t.b_(i, self.lang(e), this.XYe),
            this.S_.addEventListener("remove", this.Iq),
            this.eP(!1),
            this.JYe || this.S_.jPi(),
            this.Upi = this.FO(),
            this.JYe && h.hF(s, this, n),
            tN.has(s))
                throw new Error(`Component already exists with name ${s}`);
            this.JYe && (tN.set(s, this),
            h.ZYe(this.XYe, this)),
            this.Hq = t => this.Jq(t),
            this.Nq = t => this.Rq(t),
            h.addEventListener("next-tab", this.Hq),
            h.addEventListener("previous-tab", this.Nq)
        }
        he() {
            const t = self.app;
            this.S_.removeEventListener("remove", this.Iq),
            this.Iq = null,
            t.removeEventListener("next-tab", this.Hq),
            this.Hq = null,
            t.removeEventListener("previous-tab", this.Nq),
            this.Nq = null,
            this.JYe && (t.W0i(this.XYe),
            tN.delete(this.XYe)),
            this.S_ = null,
            this.XYe = null,
            this.Upi = null,
            this.YYe = !0,
            QU.he(this)
        }
        I1(t) {
            QU.kK()
        }
        La() {
            return this.XYe
        }
        jO() {
            return this.S_
        }
        sBt() {
            return this.S_.k_()
        }
        D_() {
            return this.S_.D_()
        }
        eP(t) {
            return this.S_.eP(t)
        }
        BA() {
            return this.S_ && (this.S_.BA() || this.S_.aP())
        }
        cY() {
            return this.Ikt
        }
        C1() {
            return this.YYe
        }
        Ggt() {
            this.JYe && self.app.ZYe(this.XYe, null),
            this.YYe || this.S_.Ggt()
        }
        FO() {
            const t = this.S_.D_();
            return t ? (this.Upi = t.ownerDocument,
            this.Upi) : this.Upi
        }
        LO() {
            return this.FO().defaultView
        }
        async qdt(t=!0) {
            self.app.xit() || await self.app.Dde(t)
        }
        async sut(t) {
            return await this.qdt(),
            QU.Qs.Ks.qs(t)
        }
        async QYe(t, i) {
            return (await this.sut(t)).lQ(i)
        }
        async hut(t, i) {
            return (await this.sut(t)).Xa(i)
        }
        Jq(t) {
            if (!this.S_.LQ())
                return;
            if (!this.S_.aP())
                return;
            let i = this.S_.lP().fP();
            if (!i)
                return;
            let e = i.cP()
              , s = i.WQ(e) + 1;
            s >= i.HQ() || i.JQ(s)
        }
        Rq(t) {
            if (!this.S_.LQ())
                return;
            if (!this.S_.aP())
                return;
            let i = this.S_.lP().fP();
            if (!i)
                return;
            let e = i.cP()
              , s = i.WQ(e) - 1;
            s < 0 || i.JQ(s)
        }
        q1(t) {
            QU.kK()
        }
        V1(t) {
            QU.kK()
        }
        w1() {
            const t = this.S_.Kmt();
            t && this.q1(t)
        }
        d1(t) {
            let i = this.S_.Kmt();
            i || (i = {}),
            i = this.V1(i, t),
            this.S_.hxi(i)
        }
        static tJe(t) {
            if (QU.K9(t))
                return tN.get(t);
            if (QU.w9(t)) {
                const i = eN.get(t);
                return tN.get(i)
            }
            if (QU.Bm(t, QU.Qs.g_.SQ))
                for (const [i,e] of tN)
                    if (e.jO() === t)
                        return e
        }
        static H1(t, i) {
            if (iN.has(t))
                throw new Error(`Component constructor already exists with name ${t}`);
            iN.set(t, i),
            eN.set(i, t)
        }
        static ZIi(t, i=!1) {
            const e = iN.get(t)
              , s = tN.get(t);
            return s || (e ? e.hP(i) : null)
        }
    }
}
{
    const sN = self.t
      , nN = self.assert
      , rN = self.lang
      , hN = self.e_
      , oN = self.n_
      , aN = self.h_
      , lN = 2e3;
    function uN(t) {
        return t.map(t => String.fromCharCode(t)).join("")
    }
    const cN = {}.toString().substr(4, 1);
    let dN = !1;
    const fN = 6e4
      , pN = [["de-DE", "de"], ["en-US", "en"], ["fr-FR", "fr"], ["hr-HR", "hr"], ["hu-HU", "hu"], ["ru-RU", "ru"], ["cs-CZ", "cs"], ["es-ES", "es"], ["pt-BR", "pt"], ["nl-NL", "nl"], ["it-IT", "it"], ["sv-SE", "sv"], ["tr-TR", "tr"], ["uk-UA", "uk"], ["zh-CN", ""], ["zh-TW", ""]]
      , mN = new Set([])
      , wN = [["be-BY", "be", "Belarusian"], ["bn-IN", "bn", "Bengali"], ["bs-BA", "bs", "Bosnian"], ["da-DK", "da", "Danish"], ["fil-PH", "fil", "Filipino"], ["el-GR", "el", "Greek"], ["hi-IN", "hi", "Hindi"], ["id-ID", "id", "Indonesian"], ["ja-JP", "ja", "Japanese"], ["ko-KR", "ko", "Korean"], ["ms-MY", "ms", "Malay"], ["pa-IN", "pa", "Punjabi"], ["pl-PL", "pl", "Polish"], ["ro-RO", "ro", "Romanian"], ["sr-RS", "sr", "Serbian"], ["sh", "sh", "Serbo-Croatian"], ["sl-SI", "sl", "Slovenian"], ["th-TH", "th", "Thai"], ["vi-VN", "vi", "Vietnamese"]]
      , gN = {
        isZipFormat: !0,
        toLayoutView: !0
    }
      , yN = {
        duplicate: !1,
        iJe: !1,
        eJe: !1,
        fileHandle: null,
        ett: "(unknown)",
        G7: !0
    }
      , bN = {
        showNotification: !0,
        sJe: !1,
        ZRt: !1
    }
      , vN = uN([102, 114]) + cN + cN;
    let SN = null
      , xN = "games"
      , MN = null
      , EN = "personal"
      , CN = ""
      , _N = !1
      , TN = -1
      , IN = !1
      , PN = ""
      , GN = -1
      , AN = !1
      , RN = !1
      , kN = 25
      , ON = 2
      , DN = 2
      , FN = 1
      , LN = !1
      , BN = null;
    const UN = 6048e5
      , NN = 9e5;
    function jN() {
        MN.nJe()
    }
    function $N(t) {
        return Math.floor(Math.random() * t)
    }
    const zN = new Set(["free", "personal", "educational", "gamejam", "startupbusiness", "business"]);
    async function VN(t) {
        if (!t.verificationHash || !t.verificationDate)
            return !1;
        const i = t.verificationHash
          , e = t.verificationDate.toUpperCase().trim()
          , s = t.type.toUpperCase().trim()
          , n = Date.parse(e)
          , r = Date.now()
          , h = Math.floor(3024e5);
        if (n < r - h || n > r + h)
            return !1;
        let o = uN([97, 118, 88, 84, 82, 51, 66, 77, 55, 75, 112, 117, 88, 66, 51, 115])
          , a = uN([99, 74, 70, 74, 101, 72, 119, 68, 89, 72, 108, 55, 108, 112, 77, 103]);
        s.length > 4 && (o += [...e].reduce( (t, i) => t + ("5" === i ? 1 : 0), 0)),
        [...e].reduce( (t, i) => t + ("0" === i ? 1 : 0), 0) > 6 && (a += o.substring(0, 3),
        o = "_" + o);
        let l = 0;
        for (const t of e) {
            const i = Number(t);
            isFinite(i) && (l += i)
        }
        l % 3 == 0 && (a = a.substring(0, 5));
        const u = (o + "A" + e + "A" + s + "" + a).normalize()
          , c = await sN.Crypto.qni(u);
        return i.toLowerCase() === c.toLowerCase()
    }
    async function WN(t) {
        if (sN.ML(t),
        t && !zN.has(t.type) && (t.type = vN),
        !_N || !t || t.type !== vN) {
            if (IN = !1,
            PN = "",
            t) {
                const i = t.type;
                if (await VN(t)) {
                    EN = t.type;
                    const e = EN === vN;
                    CN = t.hash,
                    AN = !!t.scriptingEnabled && !e,
                    RN = !!t.canShareProject,
                    _N = !!t.isAccessCode,
                    LN = !!t.gamejamLicenseAvailable,
                    e ? ("number" == typeof t.maxEvents && (kN = Math.min(t.maxEvents, 200)),
                    "number" == typeof t.maxLayers && (ON = Math.min(t.maxLayers, 10)),
                    "number" == typeof t.maxEffects && (DN = Math.min(t.maxEffects, 10)),
                    "number" == typeof t.maxWebFonts && (FN = Math.min(t.maxWebFonts, 5))) : kN = ON = DN = FN = 1 / 0,
                    TN = t.expires ? t.expires : -1,
                    LN && t.hasOwnProperty("activeGamejamLicense") ? (BN = t.activeGamejamLicense,
                    "gamejam" === EN && -1 === TN && BN.hasOwnProperty("endTime") && (TN = BN.endTime)) : BN = null,
                    t.suspended && (IN = !0,
                    PN = t.suspensionReason || "unknown"),
                    i !== EN && (t = null)
                } else
                    t = null
            }
            (!t || IN || !sN.nEt.Ubi() && "function" == typeof self[uN([114, 101, 113, 117, 105, 114, 101])]) && (EN = vN,
            CN = "",
            AN = !1,
            RN = !1,
            _N = !1,
            TN = -1,
            kN = 25,
            ON = 2,
            DN = 2,
            FN = 1,
            LN = !1,
            BN = null),
            _N ? -1 === GN && (GN = window.setInterval(jN, NN)) : -1 !== GN && (window.clearInterval(GN),
            GN = -1),
            self.app.rJe(),
            EN = "personal"
        }
    }
    async function HN(t, i) {
        const e = $N(86400)
          , s = $N(UN)
          , n = AN ? 22 : $N(14)
          , r = $N(1e8)
          , h = $N(365);
        if (_N || IN)
            return;
        if ("gamejam" === EN)
            return;
        const o = Date.now();
        let a = o + UN;
        if (TN > 0) {
            const t = 1e3 * TN;
            t < a && (a = t)
        }
        let l = ON * DN * FN;
        isFinite(l) || (l = ".");
        let u = kN;
        isFinite(u) || (u = ".");
        const c = "." + (r + i) + t + l + [...(h + sN.dQ.BIe).toString()].reverse().join("") + "." + u + s + EN + n + Math.floor(o / 14 + a / 14 - s) + "528639"
          , d = await sN.Crypto.qni(c);
        localforage.removeItem(","),
        localforage.setItem(".", [h, ON, s, t, e, DN, o, i, n, EN, r, a, kN, sN.dQ.BIe, FN, d]).catch(t => self.app._we(t))
    }
    async function KN(t) {
        const i = [localforage.removeItem("."), localforage.removeItem(",")];
        if (t) {
            const t = sN.Qs.Ks.qs("OK");
            i.push(t.Xa(rN("ui.offline-login-expired")))
        }
        return await Promise.all(i),
        null
    }
    async function qN() {
        const t = await localforage.getItem(".");
        if (!t)
            return null;
        if (MN.Gme())
            return null;
        let i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3]
          , r = (t[4],
        t[5])
          , h = t[6]
          , o = t[7]
          , a = t[8]
          , l = t[9]
          , u = t[10]
          , c = t[11]
          , d = t[12]
          , f = t[13]
          , p = t[14]
          , m = t[15]
          , w = e * r * p;
        isFinite(w) || (w = ".");
        let g = d;
        isFinite(g) || (g = ".");
        const y = "." + (u + o) + n + w + [...(i + sN.dQ.BIe).toString()].reverse().join("") + "." + g + s + l + a + Math.floor(h / 14 + c / 14 - s) + "528639"
          , b = await Promise.all([sN.Crypto.qni(y), localforage.getItem(",")]);
        if (MN.Gme())
            return null;
        const v = b[0]
          , S = b[1];
        if (v !== m)
            return KN(!1);
        const x = Date.now();
        if ("number" == typeof S && S > x)
            return KN(!1);
        if (localforage.setItem(",", x).catch(t => self.app._we(t)),
        x < h)
            return KN(!1);
        if (x > c)
            return KN(!0);
        if (sN.dQ.BIe !== f)
            return KN(!1);
        EN = l;
        return CN = "",
        _N = !1,
        AN = 22 === a,
        EN === vN ? (kN = d,
        ON = e,
        DN = r,
        FN = p) : kN = ON = DN = FN = 1 / 0,
        TN = Math.floor(c / 1e3),
        self.app.rJe(),
        {
            username: n,
            hJe: o
        }
    }
    let XN = null;
    window.oJe = class extends sN.UMi {
        constructor() {
            if (super(),
            this.Ftt = "animation" === xN ? "Construct Animate" : "Construct 3",
            sN.dQ.cPe(xN),
            this.aJe = null,
            this.GW = null,
            this.hqi = null,
            this.que = null,
            this.lJe = null,
            this.x_ = null,
            this.A2t = null,
            this.eNt = null,
            this.uJe = null,
            this.cJe = null,
            this.dJe = null,
            this.fJe = null,
            this.pJe = null,
            this.rft = null,
            this.mJe = null,
            this.wJe = null,
            this.gJe = null,
            this.yJe = null,
            this.bJe = null,
            this.vJe = null,
            this.SJe = null,
            this.xJe = null,
            this.MJe = null,
            this.EJe = null,
            this.CJe = null,
            this._Je = null,
            this.TJe = !1,
            this.IJe = !1,
            this.PJe = null,
            this.GJe = null,
            this.AJe = sN.v(sN.ZG, () => this.RJe(), lN),
            this.kJe = [],
            this.wjt = null,
            this.OJe = null,
            this.DJe = new Promise(t => this.OJe = t),
            this.FJe = !1,
            this.kf = sN.v(sN.Rf, sN._f.Gf(this, "undo", () => this.ext()), sN._f.Gf(this, "redo", () => this.nxt()), sN._f.Gf(this, "settingschange", () => this.SKi()), sN._f.Gf(window, "hashchange", t => this.LJe(t))),
            this.BJe = null,
            this.UJe = null,
            this.NJe = null,
            this.jJe = null,
            this.$Je = null,
            this.zJe = null,
            this.VJe = self.devicePixelRatio,
            this.WJe = !1,
            this.HJe = !1,
            this.KJe = 1,
            this.qJe = !1,
            this.XJe = -1,
            this.YJe = !1,
            this.JJe = 0,
            this.ZJe = !1,
            this.QJe = 0,
            this.tZe = 0,
            this.iZe = !1,
            this.eZe = new Set,
            this.sZe = sN.v(sN.fwi, () => this.lNe(), fN, {
                enabled: !1,
                dwi: !0
            }),
            this.nZe = sN.v(sN.fwi, () => this.rZe(), 72e5, {
                enabled: !1,
                dwi: !0
            }),
            this.hZe = !1,
            this.oZe = !1,
            this.aZe = [],
            this.lZe = null,
            this.PQi || (window.C3_SetBeforeInstallPromptCallback(t => this.uZe(t)),
            window.C3_SetAppInstalledCallback(t => this.cZe(t))),
            sN.w9(window.ClaimAnalyticsSandbox) && (window.ClaimAnalyticsSandbox(t => {
                SN = t.securePostMessage
            }
            ),
            window.C3_LogAnalyticsEvent = (...t) => this.XGi(...t)),
            this.PQi || window.addEventListener("beforeunload", t => this.dZe(t)),
            "iOS" === sN.kt.OS) {
                let t = 0;
                document.addEventListener("touchend", i => {
                    const e = Date.now();
                    e - t <= 500 && i.preventDefault(),
                    t = e
                }
                , !0)
            }
            document.addEventListener("gesturestart", sN.Qs.Pdt),
            document.addEventListener("gesturechange", sN.Qs.Pdt),
            document.addEventListener("gestureend", sN.Qs.Pdt),
            document.addEventListener("MSGestureStart", sN.Qs.Pdt),
            document.addEventListener("MSGestureChange", sN.Qs.Pdt),
            document.addEventListener("MSGestureEnd", sN.Qs.Pdt),
            document.addEventListener("touchmove", t => {
                "number" == typeof t.scale && 1 !== t.scale && t.preventDefault()
            }
            , !1),
            XN = this
        }
        async yrt(t) {
            if (sN.lU("AppLoad"),
            !sN.q8t() && sN.S9t.y9t("testanimationmode") && (xN = "animation",
            this.Ftt = "Construct Animate",
            sN.dQ.cPe(xN),
            this.fZe()),
            this.zJe = new sN.Qs.TQi(this),
            this.zJe.AQi(self.pZe),
            this.PQi)
                return Promise.resolve(!0);
            window.addEventListener("resize", () => this.mZe()),
            sN.lre.P2t(!0);
            const i = sN.Qs.sk.ik("wait", document);
            this.i1i();
            const e = sN.bme.iUe(this);
            await Promise.all(sN.Y8t()),
            await sN.Qs.mk.BMi(this),
            this.wZe(),
            await t.gZe,
            await e;
            const s = sN.bme.KUe();
            await sN.p.yrt(),
            await this.$0i(),
            MN = this.uq("useraccount"),
            await this.yZe(),
            await MN.bZe(WN, HN, qN),
            await this.vZe(),
            await s,
            await this.j0i(),
            sN.bme.MUe(),
            sN.lre.P2t(!1),
            sN.Qs.sk.hk(i),
            window.addEventListener("dragover", t => t.preventDefault()),
            window.addEventListener("drop", t => {
                t.preventDefault(),
                this.z3(t)
            }
            ),
            sN.OU("AppLoad")
        }
        SZe(t, i, e=!1) {
            sN.zt(t);
            const s = t.toLowerCase();
            for (const t of i) {
                const i = t[0]
                  , n = i.toLowerCase()
                  , r = t[1].toLowerCase()
                  , h = e ? t[2] : i;
                if (s.startsWith(n))
                    return h;
                if (r && r === s)
                    return h
            }
            return null
        }
        xZe() {
            const t = navigator.languages || [navigator.language];
            for (const i of t) {
                const t = this.SZe(i, pN);
                if (t)
                    return t
            }
            return "en-US"
        }
        MZe() {
            const t = navigator.languages || [navigator.language];
            for (const i of t) {
                if (this.SZe(i, pN))
                    return "";
                const t = this.SZe(i, wN, !0);
                if (t)
                    return t
            }
            return ""
        }
        H0i() {
            return {
                language: this.xZe(),
                uiMode: "auto",
                useSimplifiedMode: !1,
                enableExampleBrowser: !0,
                theme: window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "",
                useDefaultIconColor: !0,
                iconColor: "#000000",
                enableUIAnimations: !window.matchMedia("(prefers-reduced-motion: reduce)").matches,
                enableUIEffects: !0,
                enableNotifications: !0,
                showTakeBreakReminders: !0,
                zoomMouseWheelOnly: !1,
                useFakeClipboard: !1,
                experimentalFeatures: !1,
                developerMode: !1,
                showInProgressLanguages: !1,
                defaultSaveLocation: sN.QL.G2 ? "save-as" : "cloud",
                textEditorFontSize: 12,
                textEditorAutoIndent: !0,
                textEditorEnableMinimap: !0,
                textEditorMinimapScale: 1,
                textEditorEnableStickyScrolling: !0,
                textEditorEnableCodeFolding: !0,
                textEditorEnableWordWrap: !0,
                autoSave: !1,
                autosaveDuration: 10,
                autosaveLocation: "MATCH",
                cloudCache: !0,
                limitToWebGL1: !1,
                enableWebGPUInEditor: "auto",
                updateChannel: "stable",
                checkForAddonUpdates: !0,
                gpuPowerPreference: "default",
                previewMode: "popup-window",
                hideAddActionRows: !1,
                translateExpressions: !0,
                showStartPageOnStartup: !0,
                autoHideStartPage: !1,
                showStartPageMessageBanners: !0,
                defaultProjectAuthor: "",
                defaultProjectEmail: "",
                defaultProjectWebsite: "",
                defaultAnimationSpeed: 5
            }
        }
        async K0i() {
            const t = await super.K0i();
            "boolean" == typeof t.enableWebGPUInEditor && (t.enableWebGPUInEditor = t.enableWebGPUInEditor ? "yes" : "auto"),
            document.documentElement.setAttribute("lang", this.X7()),
            this.EZe()
        }
        SKi() {
            this.EZe();
            const t = this.CZe();
            t !== this.nZe.Cwi() && (t ? this.nZe.ke() : this.nZe.Ewi())
        }
        MOi() {
            const t = this.aU();
            return t.useDefaultIconColor ? sN.Qs.wP.LSi() : t.iconColor
        }
        jKt() {
            return sN.QL.A9t && !!this.aU().enableUIAnimations && !sN.S9t.y9t("disable-ui-animations")
        }
        EZe() {
            const t = document.body.parentElement
              , i = this.jKt() ? "uianimationsenabled" : "uianimationsdisabled"
              , e = this.jKt() ? "uianimationsdisabled" : "uianimationsenabled";
            t.removeAttribute(e),
            t.setAttribute(i, "")
        }
        CZe() {
            return !!this.aU().showTakeBreakReminders
        }
        iN() {
            return !!this.aU().enableUIEffects
        }
        C0i() {
            return !!this.aU().enableNotifications
        }
        uL() {
            return !!this.aU().useFakeClipboard
        }
        Tme() {
            return "animation" !== xN && !!this.aU().developerMode
        }
        Eke() {
            return !!this.aU().experimentalFeatures
        }
        HA() {
            return !!this.aU().useSimplifiedMode && !this.mdt()
        }
        X7() {
            let t = this.aU().language;
            return t.startsWith("synthetic-") && (t = "en-US"),
            t
        }
        _Ze() {
            return this.aU().translateExpressions
        }
        TZe() {
            return "animation" === xN ? sN.Qs.g_.gPe.vPe : sN.Qs.g_.gPe.yPe
        }
        IZe() {
            if (sN.kt.Y_)
                this.GJe = null;
            else {
                const t = this.aJe.IPi();
                !(t && t[0]) || sN.S9t.y9t("default-layout") || t[0].devicePixelRatio !== window.devicePixelRatio ? this.GJe = this.TZe() : this.GJe = t
            }
        }
        K1() {
            return !!this.GJe
        }
        $Ye() {
            this.aJe.UPi()
        }
        D1() {
            this.AJe.FE()
        }
        RJe() {
            if (this.GJe = null,
            !this.Kue().O0())
                try {
                    this.aJe && this.TJe && !sN.kt.Y_ && this.aJe.NPi()
                } catch (t) {
                    console.error("Error saving UI state: ", t)
                }
        }
        async yZe(t=!1) {
            const i = this.GJe;
            if (i) {
                sN.S9t.y9t("log-pane") && console.info("Rebuilding with layout", JSON.stringify(i, null, 4));
                try {
                    sN.Qs.g_.zIi(i);
                    const t = JSON.parse(JSON.stringify(i));
                    sN.Qs.g_.qIi(t, this.aJe)
                } catch (e) {
                    if ((() => {})("Failed to restore layout", JSON.stringify(i)),
                    console.error(e),
                    t)
                        throw e;
                    this.GJe = this.TZe(),
                    this.yZe(!0)
                }
            }
            this.TJe = !0
        }
        JGi() {
            this.D1()
        }
        wZe() {
            const t = uN([108, 111, 99, 97, 116, 105, 111, 110])
              , i = uN([104, 111, 115, 116, 110, 97, 109, 101])
              , e = self[t][i]
              , s = uN([101, 100, 105, 116, 111, 114, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 46, 110, 101, 116])
              , n = uN([101, 100, 105, 116, 111, 114, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 100, 101, 118, 46, 110, 101, 116])
              , r = uN([97, 110, 105, 109, 97, 116, 101, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 46, 110, 101, 116])
              , h = uN([97, 110, 105, 109, 97, 116, 101, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 100, 101, 118, 46, 110, 101, 116])
              , o = "games" === xN ? e === s || e === n : e === r || e === h
              , a = e === uN([108, 111, 99, 97, 108, 104, 111, 115, 116])
              , l = location.port
              , u = parseInt(l, 10)
              , c = o && !l || a && (!sN.q8t() || u >= 61e3 && u <= 61005);
            this.N0i(),
            this.aJe = this.A0i.KTi("1fr", "Main area", "main"),
            this.aJe.txi("main"),
            this.A0i.PF(),
            this.IZe(),
            this.hqi = sN.v(sN.Qs.Fk.YKi),
            sN.p.u("ui.status-indicators"),
            this.BJe = new sN.Qs.Fk.rqi(this.hqi,rN(".building-spritesheets")),
            this.UJe = new sN.Qs.Fk.rqi(this.hqi,rN(".rendering-spritesheets")),
            this.NJe = new sN.Qs.Fk.rqi(this.hqi,rN(".compressing-spritesheets")),
            this.jJe = new sN.Qs.Fk.rqi(this.hqi,rN(".creating-textures")),
            this.$Je = new sN.Qs.Fk.rqi(this.hqi,rN(".loading-fonts")),
            sN.p.j(),
            c && self === self.top && (this.aJe.HTi(!0),
            this.GW = this.aJe.MIi("middle", !0))
        }
        async vZe() {
            this.GW.PF(),
            this.que = this.uq("mainMenu"),
            this.lJe = this.uq("midPane"),
            this.dJe = this.uq("propertiesBar"),
            this.fJe = this.uq("projectBar"),
            this.pJe = this.uq("layersBar"),
            this.rft = this.uq("tilemapBar"),
            this.SJe = this.uq("startPage2"),
            this.xJe = this.uq("exampleBrowser"),
            this.MJe = this.uq("buyNowPage"),
            this.EJe = this.uq("guidedtourcontroller"),
            this.CJe = this.uq("remotePreviewBar"),
            this._Je = this.uq("assetBrowserBar"),
            sN.sF.addEventListener("registercomponent", t => {
                this.ZYe(t.component.Bk(), t.component.ez())
            }
            ),
            sN.sF.addEventListener("unregistercomponent", t => {
                this.ZYe(t.component.Bk(), null)
            }
            ),
            this.aJe.addEventListener("replacesubgrid", t => {
                this.GW = t.LPi
            }
            ),
            await this.z0i()
        }
        IAi() {
            return this.IJe
        }
        async Q0i(t) {
            const i = self.app;
            if (this.PQi)
                return;
            this.IJe = !0,
            self.Aii = new self.dgi,
            "Safari" === sN.kt._r && self.Aii.wgi(),
            this.VJe = self.devicePixelRatio,
            sN.q8t() && !this.Tme() && (sN.p.u("ui.console-warning"),
            console.log("%c" + rN(".title"), "color: red; font-size: 4em; font-weight: bold; -webkit-text-stroke: 1px black"),
            console.log("%c" + rN(".message"), "font-size: 2em;"),
            console.log("%c" + rN(".message2"), "font-size: 2em; font-weight: bold;"),
            sN.p.j());
            const e = performance.now();
            sN.$5t && console.info(`[Perf] Startup time: ${Math.round(10 * e) / 10} ms`),
            this.sZe.ke(),
            this.CZe() && this.nZe.ke();
            const s = super.Q0i();
            window.OfflineClientInfo && window.OfflineClientInfo.SetMessageCallback( (t, i) => this.PZe(t, i)),
            this.GZe(t, s).catch(t => window.C3_OnAppFatalLoadError(t)),
            "en-US" !== this.aU().language && this.fZe();
            const n = await Promise.all([localforage.getItem("c3-done-first-run"), localforage.getItem("c3-last-release"), localforage.getItem("c3-launch-count")])
              , r = n[0]
              , h = n[1];
            this.KJe = n[2] || 1,
            localforage.setItem("c3-launch-count", this.KJe + 1).catch(t => i._we(t)),
            this.HJe = !r || sN.S9t.y9t("firstrun");
            const o = !this.HJe && h && h < sN.dQ.BIe
              , a = this.HJe ? "cold" : o ? "update-cold" : "warm";
            if (this.AZe("StartUp", e, a),
            sN.$M)
                return this.lJe.hQ(!1),
                void this.RZe();
            if (mN.has(this.aU().language)) {
                const t = this.aU().language;
                this.XGi("LanguageUnderReviewPrompt", {
                    event_label: "Shown",
                    lang_tag: t
                }),
                sN.p.u("ui.language-under-review-prompt");
                const e = sN.Qs.Ks.qs("Confirm").Xa({
                    message: aN(".message", sN.p.Xui()),
                    _nt: aN(".continue", sN.p.Xui()),
                    bnt: rN(".switch-to-english"),
                    m_i: !0
                });
                sN.p.j();
                null === await e ? (this.XGi("LanguageUnderReviewPrompt", {
                    event_label: "SwitchToEnglish",
                    lang_tag: t
                }),
                this.aU().language = "en-US",
                await i.X0i(),
                await sN.Jti(100),
                location.reload()) : this.XGi("LanguageUnderReviewPrompt", {
                    event_label: "Confirmed",
                    lang_tag: t
                })
            }
            if (this.fme() && (this.HJe || sN.S9t.y9t("startTour"))) {
                const t = sN.Qs.Ks.qs("WelcomeTour");
                await t.Xa()
            }
            if (o) {
                try {
                    await localforage.setItem("c3-last-release", sN.dQ.BIe)
                } catch (t) {
                    this._we(t)
                }
                if (!this.mdt()) {
                    sN.p.u("ui.update-notification");
                    const t = sN.Qs.Ks.qs("Confirm");
                    t.Pii = () => this.pQ(sN.dQ.URL.zIe + sN.dQ.URL.YIe + sN.dQ.wPe, "ReleaseNotes");
                    const i = t.Xa({
                        caption: rN(".caption"),
                        message: hN(".message", sN.dPe(h), sN.dPe(sN.dQ.BIe)),
                        _nt: rN(".view-release-notes"),
                        bnt: rN(".not-now")
                    });
                    sN.p.j(),
                    await i
                }
            } else if (!h)
                try {
                    await localforage.setItem("c3-last-release", sN.dQ.BIe)
                } catch (t) {
                    this._we(t)
                }
            if (this.q$e() ? localforage.setItem("c3-last-beta-release", sN.dQ.wPe).catch(t => this._we(t)) : this.kZe() && localforage.setItem("c3-last-lts-release", sN.dQ.wPe).catch(t => this._we(t)),
            sN.q8t() && "iOS" === sN.kt.OS && "Safari" === sN.kt._r && "browser" === sN.vii() && !this.mdt()) {
                sN.p.u("ui.safari-a2hs-prompt");
                const t = sN.Qs.Ks.qs("OK");
                t.Wa(rN(".title"));
                const i = t.Xa(self.Iet(".message"));
                sN.p.j(),
                await i
            }
            if (sN.kt.Y_ && "browser" === sN.kt.Mme && !sN.Sme() && sN.QL._me && window.matchMedia("(max-width: 500px), (max-height: 500px)").matches && !this.mdt()) {
                const t = sN.Qs.Ks.qs("FullscreenPrompt");
                await t.Xa(document.body)
            }
            this.HJe && localforage.setItem("c3-done-first-run", !0).catch(t => this._we(t)),
            this.aU().showStartPageOnStartup && this.SJe.lQ(),
            sN.x9t.y9t("open-example-browser") && this.vQ() && (this.xJe.lQ(),
            sN.x9t.b9t()),
            this.lJe.hQ(!1),
            window.launchQueue && window.LaunchParams && "files"in window.LaunchParams.prototype && sN.QL.G2 && window.launchQueue.setConsumer(async t => {
                if (1 !== t.files.length)
                    return;
                const i = t.files[0]
                  , e = i.name;
                if (e.toLowerCase().endsWith(".c3p"))
                    try {
                        const t = await i.getFile()
                          , s = await this.stt(t, {
                            ett: "webfs-launch-queue"
                        });
                        if (!sN.Bm(s, self.jw))
                            return;
                        s.OZe(e),
                        await s.DZe("webfs-single-file", {
                            fileHandle: i
                        })
                    } catch (t) {
                        (() => {})("Failed to open file from launch queue: ", t)
                    }
            }
            ),
            await this.uq("useraccount").pq(),
            this.CP() && this.MJe.lQ(!1),
            this.mdt() || (await this.FZe(),
            await this.LZe(),
            await this.BZe(),
            this.UZe()),
            this.NZe()
        }
        async GZe(t, i) {
            sN.lU("StartupBackgroundLoading");
            const e = self.app;
            let s = 0;
            const n = (t, i) => this.AZe("BackgroundLoad", performance.now() - i, t);
            let r = e.Pbi(rN("ui.loading-screen.still-loading"));
            r.lQ(),
            this.jZe(t).catch(t => window.C3_OnAppFatalLoadError(t));
            const h = this.xJe.$Ze();
            await Promise.all([i, this.DJe]),
            r.he(),
            await h,
            "Android" === sN.kt.OS && (sN.Ugi.zlt(),
            sN.Ugi.WL( () => this.zZe())),
            await Promise.all([sN.Abi.yrt(), this.xJe.VZe()]),
            await sN.lre(async () => {
                if (!this.x_.pa()) {
                    s = performance.now();
                    try {
                        await this.fS()
                    } catch (t) {}
                    n("CreateWebGLRenderer", s)
                }
            }
            ),
            r = e.Pbi(rN("ui.loading-screen.loading-icons")),
            r.lQ(),
            s = performance.now(),
            await this.t1i(),
            n("PrefetchAllIcons", s),
            r.ha(rN("ui.loading-screen.loading-addons")),
            s = performance.now(),
            await this.WZe(),
            n("PreloadAllAddons", s),
            r.ha(rN("ui.loading-screen.loading-addon-events")),
            s = performance.now(),
            await sN.bme.zUe(),
            n("PreParseDisplayTexts", s),
            r.he(),
            this.AZe("StartUp", performance.now(), "AllBackgroundLoadingDone"),
            sN.OU("StartupBackgroundLoading"),
            this.HZe(),
            sN.Qs.Fk.fHe.EHe()
        }
        async jZe(t) {
            if (this.PQi)
                return;
            sN.lU("BackgroundLoadProjectResources");
            const i = sN.u7.yrt()
              , e = sN.HIt.Ro()
              , s = new sN.kei("BLPR-ProjectResourcesImport");
            await sN.Nii("projectResources.html", !0),
            s.next("BLPR-ComponentImports"),
            await Promise.all([...t.KZe.values()].map(t => sN.Nii(t, !1))),
            s.next("BLPR-LoadAddons"),
            await Promise.all([sN.bme.nUe(), sN.bme.yrt(), sN.bDe.yrt()]),
            s.next("BLPR-LoadLang1"),
            await sN.p.yrt(),
            s.next("BLPR-AddonsReady"),
            await Promise.all([sN.bme.hUe(), sN.Li.bEt(this), sN.F.bEt(this), sN.bDe.bEt(this)]),
            s.next("BLPR-WaitForJobScheduler"),
            await Promise.all([i, e]),
            s.next("BLPR-LoadLang2"),
            await sN.p.yrt(),
            s.next("BLPR-LoadComponents"),
            await this.$0i(),
            s.next("BLPR-AfterLoadComponents"),
            this.x_ = this.uq("layoutViewManager"),
            this.A2t = this.uq("eventSheetViewManager"),
            this.eNt = this.uq("flowchartViewManager"),
            this.uJe = this.uq("textEditorManager"),
            this.cJe = this.uq("dataEditorManager"),
            await this.z0i(),
            this.dispatchEvent(new sN.Event("allcomponentsloaded")),
            s.next("BLPR-LoadDialogs"),
            await Promise.all([sN.Qs.mk.BMi(this), sN.bme.qUe()]),
            this.FJe = !0,
            this.AZe("StartUp", performance.now(), "ProjectResourcesLoadingDone"),
            s.end(),
            this.OJe(),
            this.OJe = null,
            sN.OU("BackgroundLoadProjectResources")
        }
        async Dde(t) {
            let i = null;
            t && !this.FJe && (i = sN.Qs.Ks.qs("Progress"),
            i.Xa(rN("ui.loading-screen.still-loading"))),
            await this.DJe,
            i && i.sW()
        }
        xit() {
            return this.FJe
        }
        async HZe() {
            if (sN.q8t() && sN.dQ.NIe && navigator.serviceWorker)
                try {
                    const t = await navigator.serviceWorker.register("sw.js");
                    console.log("Registered service worker on " + t.scope)
                } catch (t) {
                    console.error("Failed to register service worker: ", t)
                }
        }
        qZe() {
            if (this.oZe)
                return;
            this.oZe = !0;
            let t = document.createElement("iframe");
            const i = "https://preview.construct.net/local.html"
              , e = new URL(i).origin
              , s = () => {
                t && (t.parentElement.removeChild(t),
                t = null)
            }
            ;
            t.addEventListener("load", () => {
                try {
                    t.contentWindow.postMessage({
                        type: "register-sw"
                    }, e)
                } catch (t) {
                    s()
                }
            }
            ),
            t.addEventListener("error", s),
            t.style.display = "none",
            t.src = i,
            document.body.appendChild(t),
            window.setTimeout(s, 5e3)
        }
        PZe(t, i) {
            const e = t.data;
            "root" === i ? this.XZe(e) : "main" === i ? this.YZe(e) : (() => {})("Unknown broadcast source: ", i)
        }
        XZe(t) {
            switch (t.type) {
            case "downloading":
                this.qZe();
                break;
            case "update-pending":
                this.JZe();
                break;
            case "update-ready":
                this.ZZe(t.version)
            }
        }
        YZe(t) {
            switch (t.type) {
            case "downloading":
                this.qZe();
                break;
            case "offline-ready":
                this.QZe()
            }
        }
        JZe() {
            sN.p.u("ui.update-alerts.update-pending"),
            sN.Qs.Notification.NT("download", rN(".title"), rN(".message"), {
                align: "bottom-left",
                UEt: 1e4
            }),
            sN.p.j()
        }
        ZZe(t) {
            this.AZe("UpdateAvailable", performance.now() - 3e3),
            t > sN.dQ.BIe && (this.XJe = t),
            this.YJe && (this.h0() > 0 || sN.Qs.mk.wk() ? this.tQe() : this.iQe())
        }
        QZe() {
            this.AZe("OfflineCached", performance.now() - 3e3, this.HJe ? "FirstRun" : "NotFirstRun", 6e5),
            sN.p.u("ui.update-alerts.offline-ready"),
            sN.Qs.Notification.NT("download", rN(".title"), rN(".message"), {
                align: "bottom-left",
                UEt: 8e3
            }),
            sN.p.j()
        }
        LZe() {
            return nN(!this.YJe, "should only be called once"),
            this.YJe = !0,
            this.eQe(this.aU().updateChannel),
            this.XJe >= 0 ? this.iQe() : Promise.resolve()
        }
        iQe() {
            if (this.XJe < 0)
                return Promise.resolve();
            const t = sN.Qs.Ks.qs("Confirm");
            sN.p.u("ui.update-alerts.update-available-prompt"),
            t.Pii = () => location.reload(!0);
            const i = t.Xa({
                caption: rN(".title"),
                message: hN(".message", sN.dQ.mPe, sN.dPe(this.XJe)),
                _nt: rN(".update"),
                bnt: rN(".not-now")
            });
            return sN.p.j(),
            i
        }
        tQe() {
            this.XJe < 0 || (sN.p.u("ui.update-alerts.update-available-notification"),
            sN.Qs.Notification.NT("download", rN(".title"), rN(".message"), {
                align: "bottom-left",
                UEt: 1e4
            }),
            sN.p.j())
        }
        async BZe() {
            if (!sN.QL.V9t)
                return;
            let t, i, e;
            try {
                const s = await navigator.storage.estimate();
                if (t = s.quota,
                i = s.usage,
                e = Math.min(Math.round(100 * i / t), 100),
                e < 90)
                    return
            } catch (t) {
                return void (() => {})("Error estimating storage usage: ", t)
            }
            this.XGi("StorageQuotaFullPrompt", "Shown"),
            sN.p.u("ui.storage-quota-full-prompt");
            const s = sN.Qs.Ks.qs("Confirm").Xa({
                caption: rN(".caption"),
                message: hN(".message", e, sN.Woi(i), sN.Woi(t)),
                _nt: rN(".storage-cleanup")
            });
            sN.p.j();
            if (null === await s)
                return void this.XGi("StorageQuotaFullPrompt", "Cancelled");
            this.XGi("StorageQuotaFullPrompt", "OK-StorageCleanup");
            sN.Qs.Ks.qs("StorageCleanup").Xa()
        }
        NZe() {
            this.HA() && (sN.p.u("ui.simplified-mode-notification"),
            sN.Qs.Notification.NT("info", rN(".title"), rN(".message"), {
                align: "bottom-left",
                UEt: 1e4
            }),
            sN.p.j())
        }
        async eQe(t) {
            const i = this.oNe();
            try {
                const e = await fetch("/versions.json");
                if (!e.ok)
                    throw new Error(e.status + " " + e.statusText);
                const s = await e.json();
                let n = -1
                  , r = ""
                  , h = -1
                  , o = ""
                  , a = -1
                  , l = "";
                for (const t of s) {
                    const i = t.branchName;
                    "Stable" === i ? (h = sN.pPe(t.releaseName),
                    o = t.launchURL) : "Beta" === i ? (a = sN.pPe(t.releaseName),
                    l = t.launchURL) : "LTS" === i && (n = sN.pPe(t.releaseName),
                    r = t.launchURL)
                }
                if ("lts" === i) {
                    if (n > sN.dQ.BIe) {
                        const t = sN.p.Yue("ui.update-alerts.lts-update-available-prompt")
                          , i = sN.Qs.Ks.qs("Confirm");
                        i.Pii = () => location.href = r,
                        await i.Xa({
                            caption: t(".title"),
                            message: t.e4t(".message", sN.dQ.mPe, sN.dPe(n)),
                            _nt: t(".update"),
                            bnt: t(".not-now")
                        })
                    }
                } else if ("stable" === i) {
                    if ("beta" === t && a > sN.dQ.BIe) {
                        const t = sN.p.Yue("ui.update-alerts.beta-update-available-prompt")
                          , i = sN.Qs.Ks.qs("Confirm");
                        i.Pii = () => location.href = l,
                        await i.Xa({
                            caption: t(".title"),
                            message: t.e4t(".message", sN.dQ.mPe, sN.dPe(a)),
                            _nt: t(".update"),
                            bnt: t(".not-now")
                        })
                    } else if ("stable" === t && h > sN.dQ.BIe && "/" !== location.pathname) {
                        const t = sN.p.Yue("ui.update-alerts.update-available-prompt")
                          , i = sN.Qs.Ks.qs("Confirm");
                        i.Pii = () => location.href = location.origin,
                        await i.Xa({
                            caption: t(".title"),
                            message: t.e4t(".message", sN.dQ.mPe, sN.dPe(h)),
                            _nt: t(".update"),
                            bnt: t(".not-now")
                        })
                    }
                } else if (h > sN.dQ.BIe && h > a) {
                    const t = sN.p.Yue("ui.update-alerts.update-available-prompt")
                      , i = sN.Qs.Ks.qs("Confirm");
                    i.Pii = () => location.href = o,
                    await i.Xa({
                        caption: t(".title"),
                        message: t.e4t(".message", sN.dQ.mPe, sN.dPe(h)),
                        _nt: t(".update"),
                        bnt: t(".not-now")
                    })
                } else if (a > sN.dQ.BIe) {
                    const t = sN.p.Yue("ui.update-alerts.beta-update-available-prompt")
                      , i = sN.Qs.Ks.qs("Confirm");
                    i.Pii = () => location.href = l,
                    await i.Xa({
                        caption: t(".title"),
                        message: t.e4t(".message", sN.dQ.mPe, sN.dPe(a)),
                        _nt: t(".update"),
                        bnt: t(".not-now")
                    })
                }
            } catch (t) {
                (() => {})("Failed to check for beta update: ", t)
            }
        }
        async UZe() {
            if (this.aU().checkForAddonUpdates && !sN.bme.QBe() && !this.HA() && this.Bme())
                return await sN.Qs.Fk.ntt.SXe()
        }
        uZe(t) {
            this.lZe = t,
            this.XGi("WebAppInstall", "InstallAvailable")
        }
        cZe(t) {
            this.XGi("WebAppInstall", "AppInstalled")
        }
        Dme() {
            return !!this.lZe && "browser" === sN.kt.Mme
        }
        async Rme() {
            const t = this.lZe;
            if (this.lZe = null,
            !t)
                return;
            t.prompt(),
            this.XGi("WebAppInstall", "InstallPromptShown");
            const i = await t.userChoice;
            this.XGi("WebAppInstall", "InstallPromptOutcome-" + i.outcome)
        }
        async WZe() {
            const t = new sN.kei("PreloadAllAddons-ForceLoad");
            await Promise.all([sN.Li.vOe(), sN.F.vOe()]),
            t.next("PreloadAllAddons-LoadIcons");
            const i = [];
            i.push(sN.lre( () => sN.Li.SOe().M8()));
            for (const t of sN.Li.plugins())
                i.push(sN.lre( () => t.M8()));
            for (const t of sN.F.BOe())
                i.push(sN.lre( () => t.M8()));
            await Promise.all(i),
            t.end()
        }
        LJe(t) {
            sN.x9t.v9t(location.hash),
            0 === this.h0() && this.vQ() && this.xJe.$Ze()
        }
        nF() {
            return this.GW
        }
        sQe() {
            return this.que
        }
        nQe() {
            return this.que.Uue()
        }
        b0() {
            return this.aJe
        }
        Kue() {
            return this.lJe
        }
        cQ() {
            return this.SJe
        }
        vQ() {
            return this.aU().enableExampleBrowser
        }
        fQ() {
            return this.xJe
        }
        l0() {
            return this.MJe
        }
        yme() {
            return this.EJe
        }
        mdt() {
            const t = this.yme();
            return !!t && t.rQe()
        }
        fme() {
            return sN.kt.FG
        }
        Mmt() {
            return !this.mdt()
        }
        f0(t, i) {
            this.lJe.f0(t, i)
        }
        Fq() {
            this.lJe.Fq()
        }
        ZYe(t, i) {
            switch (t) {
            case "propertiesBar":
                this.dJe = i;
                break;
            case "projectBar":
                this.fJe = i;
                break;
            case "layersBar":
                this.pJe = i;
                break;
            case "tilemapBar":
                this.rft = i;
                break;
            case "zOrderBar":
                this.mJe = i;
                break;
            case "bookmarksBar":
                this.wJe = i;
                break;
            case "findResultsBar":
                this.gJe = i;
                break;
            case "findReferencesBar":
                this.yJe = i;
                break;
            case "timelineBar":
                this.bJe = i;
                break;
            case "instanceBar":
                this.vJe = i;
                break;
            case "remotePreviewBar":
                this.CJe = i;
                break;
            case "assetBrowserBar":
                this._Je = i
            }
        }
        dh() {
            return !(!this.dJe || this.dJe.C1()) || (this.dJe = null,
            !1)
        }
        mh(t) {
            if (t = void 0 === t,
            !this.dJe && t)
                throw new Error("properties bar unavailable");
            return this.dJe
        }
        hQe() {
            return !(!this.fJe || this.fJe.C1()) || (this.fJe = null,
            !1)
        }
        Q6(t) {
            if (t = void 0 === t,
            !this.fJe && t)
                throw new Error("project bar unavailable");
            return this.fJe
        }
        oQe() {
            return !(!this.pJe || this.pJe.C1()) || (this.pJe = null,
            !1)
        }
        MZ(t) {
            if (t = void 0 === t,
            !this.pJe && t)
                throw new Error("layers bar unavailable");
            return this.pJe
        }
        rP() {
            return !(!this.rft || this.rft.C1()) || (this.rft = null,
            !1)
        }
        oP(t) {
            if (t = void 0 === t,
            !this.rft && t)
                throw new Error("tilemap bar unavailable");
            return this.rft
        }
        TTt() {
            return !(!this.mJe || this.mJe.C1()) || (this.mJe = null,
            !1)
        }
        OP(t) {
            if (t = void 0 === t,
            !this.mJe && t)
                throw new Error("zorder bar unavailable");
            return this.mJe
        }
        gK() {
            return !(!this.bJe || this.bJe.C1()) || (this.bJe = null,
            !1)
        }
        jA(t) {
            if (t = void 0 === t,
            !this.bJe && t)
                throw new Error("timeline bar unavailable");
            return this.bJe
        }
        aQe() {
            return !(!this.wJe || this.wJe.C1()) || (this.wJe = null,
            !1)
        }
        jme(t) {
            if (t = void 0 === t,
            !this.wJe && t)
                throw new Error("bookmarks bar unavailable");
            return this.wJe
        }
        LT() {
            return !(!this.vJe || this.vJe.C1()) || (this.vJe = null,
            !1)
        }
        OZ(t) {
            if (t = void 0 === t,
            !this.vJe && t)
                throw new Error("hierarchy bar unavailable");
            return this.vJe
        }
        lQe() {
            return !(!this._Je || this._Je.C1()) || (this._Je = null,
            !1)
        }
        I0(t) {
            if (t = void 0 === t,
            !this._Je && t)
                throw new Error("hierarchy bar unavailable");
            return this._Je
        }
        uQe() {
            return this.CJe
        }
        cQe() {
            let t = this.uQe();
            return t || (t = self.dQe.hP()),
            t.eP(!0),
            t
        }
        xme() {
            return this.gJe
        }
        fQe() {
            return this.yJe
        }
        v4t() {
            if (this.Iwe().SEt())
                return;
            let t = this.xme();
            const i = this.fQ()
              , e = i.jO() && i.jO().BA();
            t && t.jO() && t.jO().BA() || !e ? (t || (t = self.$me.hP()),
            t.eP(!0),
            t.jO().mP(),
            t.pQe()) : i.pQe()
        }
        mQe() {
            this.Q6().pTt()
        }
        wQe(t, i, e=!0) {
            if (sN.gL(i),
            e = !!e,
            sN.kt.Y_) {
                if (i && e) {
                    sN.Qs.Ks.qs("OK").Xa(hN("ui.errors.feature-not-available-in-mobile", i))
                }
                return !1
            }
            return !0
        }
        KA(t) {
            return !!this.wQe(t)
        }
        DLt(t) {
            const i = rN("ui.bars.project.items.timelines");
            return !!this.wQe(t, i)
        }
        LP() {
            return !this.HA()
        }
        t4(t=!0) {
            return !0
        }
        gQe() {
            return sN.$M || this.q$e() || this.Eke()
        }
        async ime() {
            return !sN.QL.G2 || !await self.Xue.MKe()
        }
        Wot() {
            return !!this.x_
        }
        Us() {
            if (!this.x_)
                throw new Error("layout view manager unavailable");
            return this.x_
        }
        CT() {
            if (!this.A2t)
                throw new Error("event sheet view manager unavailable");
            return this.A2t
        }
        TPt() {
            return !!this.eNt
        }
        Vce() {
            if (!this.eNt)
                throw new Error("flowchart view manager unavailable");
            return this.eNt
        }
        yQe() {
            return this.Us().pa()
        }
        un() {
            return this.Us().fa()
        }
        async fS() {
            return await self.app.Dde(),
            await this.Us().fS()
        }
        NLt(t) {
            sN.U(t, self.fM);
            const i = t.Cn();
            if (this.DLt(i))
                return self.nP.NLt(t)
        }
        yH(t) {
            return sN.U(t, self.g_),
            this.x_.yH(t)
        }
        OT(t) {
            return sN.U(t, self.UQ),
            this.A2t.OT(t)
        }
        bq(t) {
            return sN.U(t, self.mM),
            this.eNt.bq(t)
        }
        dq(t, i=null) {
            return sN.U(t, window.e0),
            sN.ML(i),
            self.Nme.dq(t, i)
        }
        E_(t, i, e) {
            t.GPi(),
            this.lJe.OQ(t, i, e)
        }
        eU(t) {
            this.lJe.xQ(t)
        }
        PE() {
            return this.x_ ? this.Us().PE() : null
        }
        bQe() {
            return !!this.uJe
        }
        Iwe() {
            if (!this.uJe)
                throw new Error("text editor manager unavailable");
            return this.uJe
        }
        vQe() {
            return !!this.cJe
        }
        pdt() {
            if (!this.cJe)
                throw new Error("data editor manager unavailable");
            return this.cJe
        }
        bFe(t, i) {
            sN.nu(t),
            sN.kQ(i),
            i = Object.assign({}, gN, i),
            this.aZe.push({
                Fji: t,
                SQe: !!i.isZipFormat,
                xQe: !!i.toLayoutView
            })
        }
        async z3(t) {
            if (sN.Qs.mk.wk())
                return;
            if (this.mdt())
                return;
            const i = t.dataTransfer.files
              , e = this.nI()
              , s = this.PE();
            if (1 === i.length) {
                const n = i[0]
                  , r = {
                    ett: "drag-and-drop"
                };
                switch (sN.l7(n.name).toLowerCase().slice(1)) {
                case "capx":
                    return void this.itt(n, r);
                case "caproj":
                    return void this.MQe();
                case "c3p":
                    {
                        let i = null;
                        const e = t.dataTransfer.items[0];
                        if (e && e.getAsFileSystemHandle && sN.QL.G2)
                            try {
                                i = await e.getAsFileSystemHandle(),
                                i && (r.ett = "webfs-drag-and-drop")
                            } catch (t) {
                                (() => {})("Failed to get file system handle from drop: ", t),
                                i = null
                            }
                        const s = await this.stt(n, r);
                        if (!sN.Bm(s, self.jw))
                            return;
                        if (i)
                            try {
                                s.OZe(n.name),
                                await s.DZe("webfs-single-file", {
                                    fileHandle: i
                                })
                            } catch (t) {
                                (() => {})("Failed to set origin file system from drop: ", t)
                            }
                        return
                    }
                case "c3proj":
                    return void this.EQe();
                case "zip":
                    return void this.CQe(n, t.clientX, t.clientY);
                case "png":
                case "apng":
                case "webp":
                case "avif":
                case "avifs":
                case "jpg":
                case "gif":
                    return void (e && s && s.jO().BA() && s.JL(Array.from(i), t.clientX, t.clientY));
                case "svg":
                    return void (e && s && s.jO().BA() && s.cW(n, t.clientX, t.clientY));
                case "wav":
                case "webm":
                case "flac":
                case "opus":
                case "ogg":
                case "m4a":
                    {
                        const t = sN.Qs.Ks.qs("ImportAudio");
                        return void (e && t.Y7([n], e, document.body))
                    }
                case "c3addon":
                    return void (this.Bme() && sN.Qs.Fk.ntt.ott([n], null, !0))
                }
                if (await this._Qe(t))
                    return;
                this.TQe(n, t.clientX, t.clientY)
            } else if (i.length > 1) {
                let n = null
                  , r = !1;
                for (let t of i)
                    switch (sN.l7(t.name).toLowerCase().slice(1)) {
                    case "png":
                    case "apng":
                    case "webp":
                    case "avif":
                    case "avifs":
                    case "jpg":
                    case "gif":
                        null !== n && "image" !== n ? r = !0 : n = "image";
                        break;
                    case "wav":
                    case "webm":
                    case "flac":
                    case "opus":
                    case "ogg":
                    case "m4a":
                        null !== n && "audio" !== n ? r = !0 : n = "audio";
                        break;
                    case "c3addon":
                        null !== n && "c3addon" !== n ? r = !0 : n = "c3addon";
                        break;
                    default:
                        r = !0
                    }
                if (r)
                    (() => {})("[Construct] Cannot import mixed file types via drag-and-drop");
                else
                    switch (n) {
                    case "audio":
                        {
                            const t = sN.Qs.Ks.qs("ImportAudio");
                            e && t.Y7(i, e, document.body);
                            break
                        }
                    case "image":
                        s && s.jO().BA() && s.JL(Array.from(i), t.clientX, t.clientY);
                        break;
                    case "c3addon":
                        this.Bme() && sN.Qs.Fk.ntt.ott(i, null, !0)
                    }
            }
        }
        async _Qe(t) {
            const i = t.dataTransfer.items[0];
            if (!i || !i.getAsFileSystemHandle || !sN.QL.G2)
                return !1;
            let e = null;
            try {
                if (e = await i.getAsFileSystemHandle(),
                !(e && e instanceof FileSystemDirectoryHandle))
                    return !1;
                if (!await sN.y7.Fvi(e, ".c3proj"))
                    return !1
            } catch (t) {
                return !1
            }
            const s = await this.IQe(e, {
                ett: "webfs-drag-and-drop"
            });
            if (!sN.Bm(s, self.jw))
                return !0;
            try {
                s.OZe(e.name),
                await s.DZe("webfs-local-folder", {
                    folderHandle: e
                })
            } catch (t) {
                (() => {})("Failed to set origin file system from drop: ", t)
            }
            return !0
        }
        async TQe(t, i, e) {
            const s = this.PE()
              , n = new sN.u7;
            let r = !1
              , h = null;
            try {
                await n._ct(t),
                r = !0,
                h = new window.SDK.IZipFile(n)
            } catch (t) {
                r = !1
            }
            for (const {Fji: n, SQe: o, xQe: a} of this.aZe) {
                if (a && !s)
                    continue;
                let l = !1
                  , u = {};
                a && (u = {
                    layoutView: s._W(),
                    clientX: i,
                    clientY: e,
                    layoutX: s.AA(i - s._E()),
                    layoutY: s.TA(e - s.SE())
                });
                try {
                    o && r ? l = await n(t.name, h, u) : o || r || (l = await n(t.name, t, u))
                } catch (t) {
                    console.error("Error calling SDK import handler: ", t),
                    l = !1
                }
                if ("boolean" != typeof l && (() => {})(`[SDK] Import handler did not resolve with a boolean. Please make sure the callback passed to AddDragDropFileImportHandler() returns a promise that resolves with either true or false. (Returned: ${l})`),
                l)
                    break
            }
            n.Sct()
        }
        MQe() {
            sN.Qs.Ks.qs("OK").Xa(rN("ui.errors.cannot-open-c2-folder-project"))
        }
        EQe() {
            sN.Qs.Ks.qs("OK").Xa(rN("ui.cannot-open-folder-project"))
        }
        async PQe(t) {
            const i = t.path;
            i.toLowerCase().endsWith(".c3p") ? await this.stt(t, {
                ett: "desktopapp-activation"
            }) : i.toLowerCase().endsWith(".c3proj") ? this.EQe() : (() => {})("Unknown file extension to open for file: " + i)
        }
        GQe(t) {
            t.eJe || null === t.ett || (this.XGi("OpenProjectMethod", t.ett),
            t.ett = null)
        }
        async AQe(t, i) {
            sN.zt(t),
            sN.kQ(i),
            i = Object.assign({}, yN, i),
            this.GQe(i),
            this.lJe.hQ(!0);
            let e = sN.Qs.Ks.qs("Download");
            try {
                const s = await e.Xa(t);
                return await this.itt(s, i)
            } catch (t) {
                return console.error("[Project] Exception opening: ", t),
                e.Pct(),
                e = sN.Qs.Ks.qs("OK"),
                e.Xa(rN("ui.errors.failed-to-download-project")),
                t
            } finally {
                this.lJe.hQ(!1)
            }
        }
        async itt(t, i) {
            sN.U(t, Blob),
            sN.kQ(i),
            i = Object.assign({}, yN, i),
            this.GQe(i),
            this.lJe.hQ(!0),
            this.tZe++;
            const e = new sN.u7;
            if (i.G7) {
                let t = sN.Qs.Ks.qs("Progress");
                t.onprogress = () => {
                    const t = e.gct()
                      , i = e.yct();
                    return 0 === i ? 0 : t / i
                }
                ,
                t.Xa(rN("ui.projects.importing-caption"))
            }
            const s = performance.now();
            try {
                await e._ct(t),
                await this.Dde(!1);
                const n = await self.jw.RQe(e, !!i.duplicate);
                return n.kQe(i.eJe),
                i.G7 && sN.Qs.Ks.qs("Progress").sW(),
                this.XGi("ImportC2Capx", {
                    proj_id: n.MLt()
                }),
                i.eJe || await this.OQe(n, !!i.iJe),
                sN.$5t && console.info(`[Project] Opened C2 Capx in ${performance.now() - s} ms`),
                n
            } catch (t) {
                return i.G7 && sN.Qs.Ks.qs("Progress").Pct(),
                await this.DQe("ui.errors.failed-to-open-c2-project", t),
                t
            } finally {
                this.tZe--,
                e.Sct(),
                this.lJe.hQ(!1)
            }
        }
        async FQe(t, i) {
            sN.zt(t),
            sN.kQ(i),
            i = Object.assign({}, yN, i),
            this.GQe(i),
            this.lJe.hQ(!0),
            this.tZe++;
            let e = sN.Qs.Ks.qs("Download");
            try {
                const s = await e.Xa(t);
                i.LQe && i.LQe(s);
                return await this.stt(s, i)
            } catch (t) {
                return console.error("[Project] Exception opening: ", t),
                e.Pct(),
                e = sN.Qs.Ks.qs("OK"),
                e.Xa(rN("ui.errors.failed-to-download-project")),
                t
            } finally {
                this.lJe.hQ(!1),
                this.tZe--
            }
        }
        async stt(t, i) {
            sN.U(t, Blob),
            sN.kQ(i),
            i = Object.assign({}, yN, i),
            this.GQe(i),
            this.lJe.hQ(!0),
            this.tZe++;
            const e = new sN.u7
              , s = {
                indeterminate: !1,
                duplicate: !!i.duplicate,
                iJe: !!i.iJe,
                BQe: !!i.BQe
            };
            if (i.G7) {
                let t = sN.Qs.Ks.qs("Progress");
                t.onprogress = () => {
                    if (s.indeterminate)
                        return t.Wa(rN("ui.projects.opening-caption-no-progress")),
                        null;
                    const i = e.gct()
                      , n = e.yct();
                    return 0 === n ? 0 : i / n
                }
                ,
                t.Xa(rN("ui.projects.opening-caption"))
            }
            const n = performance.now();
            try {
                await e._ct(t),
                await this.Dde(!1);
                const r = await self.jw.UQe(e, s);
                if (r.kQe(i.eJe),
                sN.ptt(t)) {
                    const i = t.name;
                    r.OZe(i)
                }
                return i.fileHandle && await r.DZe("webfs-single-file", {
                    fileHandle: i.fileHandle
                }),
                i.eJe || await this.OQe(r, !!i.iJe),
                sN.$5t && console.info(`[Project] Opened C3 project in ${performance.now() - n} ms`),
                i.G7 && sN.Qs.Ks.qs("Progress").sW(),
                r
            } catch (t) {
                return i.G7 && sN.Qs.Ks.qs("Progress").Pct(),
                await this.DQe("ui.errors.failed-to-open-c3-project", t),
                t
            } finally {
                this.tZe--,
                e.Sct(),
                this.lJe.hQ(!1)
            }
        }
        async IQe(t, i) {
            sN.U(t, FileSystemDirectoryHandle),
            nN(sN.QL.G2, "web filesystem not supported"),
            sN.kQ(i),
            i = Object.assign({}, yN, i),
            this.GQe(i),
            this.lJe.hQ(!0),
            this.tZe++;
            const e = {
                indeterminate: !1,
                duplicate: !1
            }
              , s = sN.Qs.Ks.qs("Progress");
            s.Xa(rN("ui.projects.opening-caption-no-progress"));
            try {
                await this.Dde(!1);
                const i = await sN.y7.Fvi(t, ".c3proj")
                  , n = await i.getFile()
                  , r = sN.v(sN.NQe, t)
                  , h = await self.jw.jQe(n, r, e);
                return h.OZe(t.name + "/"),
                await h.DZe("webfs-local-folder", {
                    folderHandle: t
                }),
                await this.OQe(h),
                await h.$Qe(t),
                s.sW(),
                h
            } catch (t) {
                return s.Pct(),
                this.DQe("ui.errors.failed-to-open-c3-folder-project", t),
                t
            } finally {
                this.lJe.hQ(!1),
                this.tZe--
            }
        }
        async CQe(t, i, e) {
            const s = new sN.u7
              , n = {
                ett: "drag-and-drop"
            };
            try {
                if (await s._ct(t),
                s.xct(".c3proj"))
                    return await this.stt(t, n);
                const r = [...s.abi()].filter(t => !t.filename.toLowerCase().startsWith("__macosx"))
                  , h = r.filter(t => t.filename.toLowerCase().endsWith(".c3p"));
                if (1 === h.length) {
                    const t = h[0]
                      , i = await s.Gct(t);
                    return await this.stt(i, n)
                }
                const o = r.filter(t => t.filename.toLowerCase().endsWith(".capx"));
                if (1 === o.length) {
                    const t = o[0]
                      , i = await s.Gct(t);
                    return await this.itt(i, n)
                }
                this.TQe(t, i, e)
            } catch (t) {
                this.DQe("ui.errors.failed-to-open-c3-project", t)
            } finally {
                s.Sct()
            }
        }
        DQe(t, i) {
            if ("missing-addons" === i.type) {
                return sN.Qs.Ks.qs("MissingAddons").Xa({
                    zQe: i.zQe,
                    VQe: i.VQe
                })
            }
            if ("saved-with-future-release" === i.type) {
                const t = sN.dQ.mPe
                  , e = sN.dPe(i.WQe)
                  , s = sN.fPe(i.WQe);
                return sN.Qs.Ks.qs("OK").Xa(sN.v(sN.ix, aN("ui.errors.project-saved-in-newer-release", e, t), {
                    links: [location.origin + "/" + s]
                }))
            }
            if ("expression-name-collision" === i.type) {
                const t = i.KJ
                  , e = i.name
                  , s = i.ROe
                  , n = t.Cn().HQe()
                  , r = sN.dPe(n)
                  , h = sN.fPe(n)
                  , o = sN.p.Yue("ui.errors.expression-name-collision")
                  , a = sN.Qs.Ks.qs("OK");
                return a.Wa(o(".title")),
                a.Xa(sN.v(sN.ix, o.dme(".message", t.La(), o(".types." + s), e, t.$a().La(), r), {
                    links: [location.origin + "/" + h]
                }))
            }
            if ("invalid-spaces-in-name" === i.type) {
                return sN.Qs.Ks.qs("OK").Xa(sN.v(sN.ix, aN("ui.errors.invalid-spaces-in-name", i.path), {
                    links: ["https://www.construct.net/tutorials/fix-open-project-errors-due-3139"]
                }))
            }
            console.error("[Project] Exception opening: ", i);
            return sN.Qs.Ks.qs("OK").Xa({
                message: rN(t),
                e_i: !0
            })
        }
        KQe(t) {
            sN.zt(t);
            for (let i of this.kJe)
                if (i.MLt() === t)
                    return !0;
            return !1
        }
        aQ() {
            return sN.Qs.Ks.qs("NewProject").Xa()
        }
        mze(t, i="event-sheet") {
            return this.oL(this.qQe(t, i))
        }
        async qQe(t, i) {
            this.lJe.hQ(!0),
            await this.Dde(!0);
            try {
                sN.tot(t),
                sN.zt(i);
                const e = sN.v(self.jw);
                let s = null;
                if ("event-sheet" === i)
                    s = sN.v(self.UQ, e),
                    e.VAt().WL(s);
                else if ("javascript" === i)
                    self.Nme.ELt(e);
                else {
                    if ("typescript" !== i)
                        throw new Error("invalid parameter");
                    self.Nme._Lt(e)
                }
                const n = sN.v(self.g_, e)
                  , r = sN.v(self.t_, n);
                r.zie(!1),
                n.FUt().WL(r),
                e.LAt().WL(n),
                s && n.Mne(s);
                const h = e.ZD(e.$At())
                  , o = e.XLt(e.GAt())
                  , a = this.yme().b4t();
                if (a && (a.y4t("<first-layout>", n),
                s && a.y4t("<first-event-sheet>", s),
                a.y4t("<first-layer>", r),
                a.y4t("<first-timeline>", h),
                a.y4t("<first-flowchart>", o)),
                "animation" === this.bne()) {
                    const t = sN.Li.ed("Timeline")
                      , i = t.OL(e, t.La());
                    await i.JDe(),
                    e.xL().WL(i)
                }
                const l = this.aU();
                e.B(l.defaultProjectAuthor),
                e.lse(l.defaultProjectEmail),
                e.fse(l.defaultProjectWebsite),
                await e.XQe(),
                t && t(e),
                e.YQe(),
                await this.OQe(e, !0, !1)
            } catch (t) {
                console.error("Error creating new project: ", t);
                sN.Qs.Ks.qs("OK").Xa(rN("ui.errors.failed-to-create-project"))
            } finally {
                this.lJe.hQ(!1)
            }
        }
        async OQe(t, i=!1, e=!0) {
            if (sN.U(t, self.jw),
            nN(!t.Xw(), "project still loading"),
            this.kJe.includes(t))
                throw new Error("project already open");
            if (1 === this.kJe.length && await this.JQe(this.kJe[0]),
            this.aU().autoHideStartPage && this.SJe.j0(),
            this.kJe.push(t),
            this.ZQe(t, "projectopen"),
            await this.QQe(t, "afterprojectopen"),
            e && t.t0e(),
            self.app.dh() && this.dJe.zQ(!0),
            i)
                if (this.lJe.CQ(t)) {
                    let i = this.lJe.GQ(t)
                      , e = this.lJe.IQ(t);
                    i ? await this.i0e(i) : e ? await this.e0e(e) : await this.i0e(t.kse() || t.wze())
                } else
                    await this.i0e(t.kse() || t.wze());
            else
                this.lJe.CQ(t) || await this.i0e(t.kse() || t.wze());
            self.app.dh() && this.dJe.zQ(!1),
            await sN.Qs.Fk.oUt.s0e(t),
            this.n0e() && [...t.R4t()].length && !sN.$M && this.r0e(t)
        }
        async i0e(t) {
            if (!t)
                return;
            const i = await this.yH(t)
              , e = t.GT();
            if (e)
                this.OT(e);
            else {
                const i = sN.th(t.Cn().h0e())
                  , e = this.Iwe();
                i && !e.yEt(i) && await self.Nme.dq(i)
            }
            i && this.eU(i.jO())
        }
        async e0e(t) {
            if (!t)
                return;
            const i = this.OT(t)
              , e = t.td();
            e && await this.yH(e),
            this.eU(i.jO())
        }
        async wme(t) {
            sN.QL.G2 ? await this.o0e() : await this.a0e(t)
        }
        async o0e() {
            let t = null;
            try {
                [t] = await window.showOpenFilePicker({
                    multiple: !1,
                    id: "open-project-file",
                    types: [{
                        description: rN("ui.project-file-picker.c3-and-c2-single-file-projects"),
                        accept: {
                            "application/x-construct-project": [".c3p", ".capx"]
                        }
                    }, {
                        description: rN("ui.project-file-picker.c3-single-file-project"),
                        accept: {
                            "application/x-construct3-project": [".c3p"]
                        }
                    }, {
                        description: rN("ui.project-file-picker.c2-single-file-project"),
                        accept: {
                            "application/x-construct2-project": [".capx"]
                        }
                    }]
                })
            } catch (t) {
                return
            }
            try {
                const i = await t.getFile()
                  , e = i.name.toLowerCase();
                if (e.endsWith(".c3p")) {
                    const e = await this.stt(i, {
                        ett: "webfs-file-picker"
                    });
                    if (!sN.Bm(e, self.jw))
                        return;
                    e.OZe(i.name),
                    await e.DZe("webfs-single-file", {
                        fileHandle: t
                    })
                } else if (e.endsWith(".capx"))
                    this.itt(i, {
                        ett: "webfs-file-picker"
                    });
                else {
                    if (e.endsWith(".c3proj"))
                        return void this.EQe();
                    sN.Qs.Ks.qs("OK").Xa(rN("ui.errors.unknown-file-extension"))
                }
            } catch (t) {
                this.DQe("ui.errors.failed-to-open-c3-project", t),
                console.error("File read error: ", t)
            }
        }
        async a0e(t) {
            const i = await sN.Qs.ZCi.i_i(".c3p,.c3proj,.capx,.caproj", t, !1, !1, "open-project");
            if (null === i)
                return;
            const e = {
                ett: "file-picker"
            };
            if (i.name.toLowerCase().endsWith(".c3p"))
                this.stt(i, e);
            else if (i.name.toLowerCase().endsWith(".capx"))
                this.itt(i, e);
            else if (i.name.toLowerCase().endsWith(".caproj"))
                this.MQe();
            else if (i.name.toLowerCase().endsWith(".c3proj"))
                this.EQe();
            else {
                sN.Qs.Ks.qs("OK").Xa(rN("ui.errors.unknown-file-extension"))
            }
        }
        async vme() {
            let t = null;
            try {
                t = await window.showDirectoryPicker({
                    id: "open-project-folder",
                    mode: "readwrite"
                })
            } catch (t) {
                return
            }
            this.IQe(t, {
                ett: "webfs-folder-picker"
            })
        }
        async hme(t, i=!1) {
            if (nN(!t.Xw(), "project still loading"),
            t.cY())
                return;
            if (t.Swe() && !i) {
                const i = sN.Qs.Ks.qs("ConfirmMultiple")
                  , e = await i.Xa({
                    message: aN("ui.unsaved-project-warning", t.La()),
                    options: [{
                        text: rN("ui.save-and-close"),
                        tag: "save"
                    }, {
                        text: rN("ui.dont-save"),
                        tag: "discard"
                    }],
                    Stt: !0
                }, document.body);
                if (null === e)
                    return "cancelled";
                if ("save" === e) {
                    if (null === await self.app.Zue(t))
                        return "cancelled"
                }
            }
            if (t.cY())
                return;
            self.app.Fq(),
            t.l0e(),
            this.ZQe(t, "projectclose"),
            this.nI() === t && this.$U(null);
            const e = this.kJe.indexOf(t);
            e >= 0 && this.kJe.splice(e, 1),
            this.ZQe(t, "afterprojectclose"),
            this.dh() && this.mh().Ry(),
            t.he(),
            sN.bme.NUe(t)
        }
        async u0e() {
            if (this.kJe.length) {
                const t = await this.hme(this.kJe[0]);
                return "cancelled" === t ? t : this.u0e()
            }
        }
        async JQe(t) {
            sN.U(t, self.jw);
            const i = self.app
              , e = "close-existing-project-dont-ask-again";
            if (await localforage.getItem(e))
                return;
            i.XGi("CloseExistingProjectPrompt", "Shown"),
            sN.p.u("ui.confirm-open-second-project-prompt");
            const s = sN.Qs.Ks.qs("ConfirmCheck")
              , n = s.Xa({
                caption: rN(".caption"),
                message: rN(".message"),
                _nt: rN(".close-project"),
                bnt: rN(".open-both"),
                x_i: rN("common.dont-ask-again")
            });
            sN.p.j();
            if (null === await n) {
                if (s.C_i()) {
                    i.XGi("CloseExistingProjectPrompt", "Cancelled-DontAskAgain");
                    try {
                        await localforage.setItem(e, !0)
                    } catch (t) {
                        (() => {})('Failed to save "Don\'t ask again" preference: ', t)
                    }
                } else
                    i.XGi("CloseExistingProjectPrompt", "Cancelled");
                return
            }
            const r = await this.hme(t);
            i.XGi("CloseExistingProjectPrompt", "cancelled" === r ? "Cancelled-ClosingProject" : "Confirmed")
        }
        *N1() {
            for (let t of this.kJe)
                yield t
        }
        h0() {
            return this.kJe.length
        }
        c0e() {
            return this.QJe > 0
        }
        d0e() {
            return this.tZe > 0
        }
        async f0e(t, i) {
            sN.U(t, self.jw),
            i = !!i,
            nN(!t.Xw(), "project still loading");
            const e = new sN.u7;
            let s;
            i || (s = sN.Qs.Ks.qs("Progress"),
            s.onprogress = () => {
                let t = e._bi()
                  , i = e.Ebi();
                return 0 === i ? null : t / i
            }
            ,
            s.Xa());
            try {
                const i = await t.p0e()
                  , s = await e.f7(i.m0e);
                if (0 === s.size)
                    throw new Error("project save is zero size");
                return s
            } catch (t) {
                throw console.error("[Project] Exception saving project to blob: ", t),
                t
            } finally {
                i || s.sW()
            }
        }
        async nme(t, i) {
            sN.U(t, self.jw);
            const e = t.La() + ".c3p";
            let s = e;
            if (i) {
                sN.p.u("ui.save-download-name-prompt");
                const t = sN.Qs.Ks.qs("Input").Xa({
                    caption: rN(".caption"),
                    message: rN(".message"),
                    label: rN(".label"),
                    _Ti: e
                });
                sN.p.j();
                const i = await t;
                if (null === i)
                    return;
                "string" == typeof i && i && (s = i,
                s.toLowerCase().endsWith(".c3p") || (s += ".c3p"))
            }
            this.QJe++;
            try {
                const i = await this.f0e(t);
                await sN.g7(s, i),
                t.w0e(),
                this.XGi("SaveProjectMethod", "download")
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                sN.Qs.Ks.qs("OK").Xa(rN("ui.save-error"))
            } finally {
                this.QJe--
            }
        }
        async eme(t) {
            sN.U(t, self.jw),
            this.QJe++;
            try {
                return await self.Xue.brt(t)
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                sN.Qs.Ks.qs("OK").Xa(rN("ui.save-error"))
            } finally {
                this.QJe--
            }
        }
        async sme(t) {
            sN.U(t, self.jw),
            this.QJe++;
            try {
                return await self.Xue.brt(t, !0)
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                sN.Qs.Ks.qs("OK").Xa(rN("ui.save-error"))
            } finally {
                this.QJe--
            }
        }
        async g0e(t) {
            sN.U(t, self.jw),
            nN(sN.QL.G2, "web filesystem not supported"),
            nN("webfs-single-file" === t.hHt(), "expected webfs-single-file project"),
            this.QJe++;
            try {
                const i = t.uHt();
                if (!i)
                    throw new Error("missing metadata");
                const e = i.fileHandle;
                if (!e)
                    throw new Error("missing file handle");
                let s = await e.queryPermission({
                    mode: "readwrite"
                });
                if ("denied" === s)
                    throw new Error("file write permission denied");
                if ("prompt" === s && (s = await e.requestPermission({
                    mode: "readwrite"
                }),
                "granted" !== s))
                    throw new Error("file write permission denied");
                const n = await this.f0e(t);
                await sN.y7.b7(e, n),
                await t.DZe("webfs-single-file", i),
                t.w0e(),
                this.XGi("SaveProjectMethod", "webfs-local-file")
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                sN.Qs.Ks.qs("OK").Xa(rN("ui.save-error"))
            } finally {
                this.QJe--
            }
        }
        async tme(t) {
            if (sN.U(t, self.jw),
            nN(sN.QL.G2, "web filesystem not supported"),
            await this.y0e())
                return;
            let i = null;
            try {
                i = await window.showSaveFilePicker({
                    id: "save-project-file",
                    types: [{
                        description: rN("ui.project-file-picker.c3-single-file-project"),
                        accept: {
                            "application/x-construct3-project": [".c3p"]
                        }
                    }]
                })
            } catch (t) {
                return
            }
            this.QJe++;
            try {
                t.b0e();
                const e = await this.f0e(t);
                await sN.y7.b7(i, e),
                t.OZe(i.name),
                await t.DZe("webfs-single-file", {
                    fileHandle: i
                }),
                t.w0e(),
                this.XGi("SaveProjectMethod", "webfs-local-file")
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                sN.Qs.Ks.qs("OK").Xa(rN("ui.save-error"))
            } finally {
                this.QJe--
            }
        }
        async v0e(t) {
            sN.U(t, self.jw),
            nN(sN.QL.G2, "web filesystem not supported"),
            nN("webfs-local-folder" === t.hHt(), "expected webfs-local-folder project"),
            this.QJe++;
            let i = null;
            try {
                const e = t.uHt();
                if (!e)
                    throw new Error("missing metadata");
                const s = e.folderHandle;
                if (!s)
                    throw new Error("missing folder handle");
                await sN.y7.Rvi(s);
                let n = -1;
                const r = (t, i) => n = t / i;
                i = sN.Qs.Ks.qs("Progress"),
                i.onprogress = () => -1 === n ? null : n,
                i.Xa();
                const h = await t.p0e({
                    S0e: "save"
                })
                  , o = h.m0e
                  , a = h.x0e
                  , l = h.M0e;
                await sN.y7.Ovi(s, a),
                await sN.y7.Dvi(s, l),
                await sN.y7.kvi(s, o, r, !0),
                n = -1,
                t.OZe(s.name + "/"),
                await t.DZe("webfs-local-folder", e),
                i.sW(),
                t.w0e(),
                this.XGi("SaveProjectMethod", "webfs-local-folder")
            } catch (t) {
                console.error("[Project] Exception saving: ", t),
                i && i.Pct();
                sN.Qs.Ks.qs("OK").Xa(rN("ui.save-error"))
            } finally {
                this.QJe--
            }
        }
        async ome(t) {
            if (sN.U(t, self.jw),
            nN(sN.QL.G2, "web filesystem not supported"),
            await this.y0e())
                return;
            let i = null;
            try {
                i = await window.showDirectoryPicker({
                    id: "save-project-folder",
                    mode: "readwrite"
                })
            } catch (t) {
                return
            }
            let e = null;
            try {
                await sN.y7.Rvi(i);
                let s = -1;
                const n = (t, i) => s = t / i;
                e = sN.Qs.Ks.qs("Progress"),
                e.onprogress = () => -1 === s ? null : s,
                e.Xa(),
                this.QJe++,
                t.b0e();
                const r = await t.p0e({
                    S0e: "save-as"
                });
                r.m0e.set(".gitignore", "*.uistate.json\nts-defs"),
                await sN.y7.kvi(i, r.m0e, n),
                t.OZe(i.name + "/"),
                await t.DZe("webfs-local-folder", {
                    folderHandle: i
                }),
                e.sW(),
                t.w0e(),
                this.XGi("SaveProjectMethod", "webfs-local-folder")
            } catch (t) {
                console.error("[Project] Exception saving: ", t),
                e && e.Pct();
                sN.Qs.Ks.qs("OK").Xa(rN("ui.save-error"))
            } finally {
                this.QJe--
            }
        }
        async Zue(t) {
            if (sN.Ef(t, self.jw),
            !t)
                return;
            if (sN.ddt() && (document.activeElement.blur(),
            await sN.mii()),
            t.E0e()) {
                return void sN.Qs.Ks.qs("OK").Xa(rN("ui.save-busy-autosaving"))
            }
            const i = t.C0e();
            if (null !== i) {
                const e = sN.Qs.Ks.qs("Confirm")
                  , s = hN("ui.save-autosave-to-original", i.name);
                if (!await e.Xa({
                    message: s
                }))
                    return;
                t.OZe(i.name),
                await t.DZe(i.mode, i.meta),
                t.b0e()
            }
            switch (t.hHt()) {
            case "cloud":
                return self.Xue._0e(t);
            case "webfs-single-file":
                return this.g0e(t);
            case "webfs-local-folder":
                return this.v0e(t);
            default:
                switch (this.aU().defaultSaveLocation) {
                case "cloud":
                default:
                    return this.eme(t);
                case "local-browser":
                    return this.sme(t);
                case "download":
                    return this.nme(t, !0);
                case "save-as":
                    return sN.QL.G2 ? this.tme(t) : this.eme(t)
                }
            }
        }
        async y0e() {
            if (this.aU().autoSave)
                return !1;
            let t = !1
              , i = await localforage.getItem("local-file-save-count");
            if (("number" != typeof i || i >= 10) && (i = 0,
            t = !0),
            localforage.setItem("local-file-save-count", i + 1).catch(t => this._we(t)),
            t) {
                this.XGi("PromptToSetUpBackupsDlg", "Shown");
                const t = sN.Qs.Ks.qs("Confirm")
                  , i = sN.p.Yue("ui.configure-backups-prompt")
                  , e = await t.Xa({
                    caption: i(".caption"),
                    message: sN.v(sN.ix, i(".message"), {
                        links: [ () => this.FT("tips-and-guides/best-practices")]
                    }),
                    _nt: i(".open-settings"),
                    bnt: i(".save-anyway")
                });
                return e ? (this.XGi("PromptToSetUpBackupsDlg", "OpenSettings"),
                sN.Qs.Ks.qs("Settings").Xa(null, "backup")) : this.XGi("PromptToSetUpBackupsDlg", "SaveAnyway"),
                !!e
            }
            return !1
        }
        async T0e(t) {
            const i = t.system;
            let e, s;
            this.tZe++;
            try {
                switch (i) {
                case "cloud":
                    return await self.Xue.I0e(t);
                case "webfs-single-file":
                    const n = t.ref.fileHandle;
                    if (s = await n.requestPermission({
                        mode: "readwrite"
                    }),
                    "granted" !== s)
                        throw new Error("user declined permission");
                    return e = await n.getFile(),
                    await this.stt(e, {
                        fileHandle: n,
                        ett: "webfs-recent-project-file"
                    });
                case "webfs-local-folder":
                    const r = t.ref.folderHandle;
                    if (s = await r.requestPermission({
                        mode: "readwrite"
                    }),
                    "granted" !== s)
                        throw new Error("user declined permission");
                    return await this.IQe(r, {
                        ett: "webfs-recent-project-folder"
                    });
                default:
                    throw new Error(`bad origin ${i}`)
                }
            } finally {
                this.tZe--
            }
        }
        xHe() {
            for (const t of this.kJe)
                sN.QL.G2 ? this.tme(t) : this.nme(t, !1)
        }
        dZe(t) {
            if (!sN.$M) {
                if (this.c0e()) {
                    const i = rN("ui.still-saving-warning");
                    return t.returnValue = i,
                    i
                }
                if (self.Xue.P0e()) {
                    const i = rN("ui.still-saving-warning");
                    return t.returnValue = i,
                    i
                }
                for (let i of this.kJe)
                    if (i.Swe()) {
                        let e = aN("ui.unsaved-changes-warning", i.La());
                        return t.returnValue = e,
                        e
                    }
            }
        }
        zZe() {
            if (sN.kt.Y_ && sN.Qs._O.AAi())
                return sN.Qs._O.RAi(!1),
                void Promise.resolve().then( () => sN.Ugi.WL( () => this.zZe(), "app"));
            if (0 === this.h0())
                return void sN.Ugi.Bgi();
            sN.p.u("ui.back-confirmation");
            sN.Qs.Ks.qs("Confirm").Xa({
                caption: rN(".caption"),
                message: rN(".message"),
                _nt: rN(".go-back"),
                bnt: rN(".stay"),
                w_i: !0
            }).then(t => {
                null === t ? Promise.resolve().then( () => sN.Ugi.WL( () => this.zZe())) : sN.Ugi.Bgi()
            }
            ),
            sN.p.j()
        }
        lme(t, i="auto") {
            if (sN.Ef(t, self.jw),
            t && !this.d0e() && !this.c0e() && (t.n0() || !sN.Qs.mk.wk()))
                return this.G0e(t, t.kse() || t.wze(), {
                    A0e: i
                })
        }
        cme(t) {
            if (sN.Ef(t, self.jw),
            t && !this.d0e() && !this.c0e() && !sN.Qs.mk.wk()) {
                if (!(window.RTCDataChannel || window.webkitRTCDataChannel || window.mozRTCDataChannel || window.msRTCDataChannel)) {
                    return void sN.Qs.Ks.qs("OK").Xa(rN("ui.errors.remote-preview-not-supported"))
                }
                return this.G0e(t, t.kse() || t.wze(), {
                    R0e: !0
                })
            }
        }
        ume(t, i="auto") {
            if (sN.Ef(t, self.jw),
            t && !this.d0e() && !this.c0e() && !sN.Qs.mk.wk())
                return this.G0e(t, t.kse() || t.wze(), {
                    $M: !0,
                    A0e: i
                })
        }
        ywe(t, i="auto") {
            if (sN.Ef(t, self.g_),
            !(this.d0e() || this.c0e() || sN.Qs.mk.wk())) {
                if (t || (t = this.Us().qU()) && t.Cn() !== this.nI() && (t = null),
                !t) {
                    const i = this.nI();
                    i && (t = i.wze())
                }
                if (t)
                    return this.G0e(t.Cn(), t, {
                        A0e: i
                    })
            }
        }
        kwe(t, i="auto") {
            if (sN.Ef(t, self.g_),
            !(this.d0e() || this.c0e() || sN.Qs.mk.wk())) {
                if (t || (t = this.Us().qU()) && t.Cn() !== this.nI() && (t = null),
                !t) {
                    const i = this.nI();
                    i && (t = i.wze())
                }
                if (t)
                    return this.G0e(t.Cn(), t, {
                        $M: !0,
                        A0e: i
                    })
            }
        }
        G0e(t, i, e) {
            sN.U(t, self.jw),
            sN.U(i, self.g_),
            sN.kQ(e);
            if (e = Object.assign({}, {
                $M: !1,
                R0e: !1,
                A0e: !1,
                k0e: null
            }, e),
            i.Cn() !== t)
                throw new Error("first layout from wrong project");
            return "auto" === e.A0e && (e.A0e = sN.bk.Sk(sN.Mk.wE)),
            e.A0e = !!e.A0e,
            this.d0e() || this.c0e() || sN.Qs.mk._Mi() && !e.k0e ? Promise.resolve(null) : (this.yT(),
            sN.Abi.G0e(t, i, e))
        }
        async pme(t) {
            if (sN.Ef(t, self.jw),
            t && !this.d0e() && !this.c0e() && !sN.Qs.mk.wk())
                try {
                    await sN.Abi.O0e(t)
                } catch (t) {
                    if (console.error("Error exporting: ", t),
                    t && "remote-minify-error" === t.type) {
                        sN.Qs.Ks.qs("OK").Xa(rN("ui.errors.failed-remote-minify"))
                    } else if (t && "minify-error" === t.type) {
                        sN.Qs.Ks.qs("MinifyError").Xa(t.log)
                    } else {
                        sN.Qs.Ks.qs("OK").Xa(rN("ui.errors.failed-to-export"))
                    }
                }
        }
        D0e(t, i) {
            return sN.U(t, self.jw),
            sN.IL(i),
            this.G0e(t, t.kse() || t.wze(), {
                k0e: i
            })
        }
        async ext(t) {
            t = Object.assign({}, bN, t);
            const i = sN.Qs.mk.Oxi();
            if (sN.Qs.mk.pMi() && i && !i.vmt())
                return;
            const e = sN.ddt();
            if (!t.ZRt && e && document.activeElement && !sN.Fft(document.activeElement, ["ui-propertygrid"]))
                return void this.zJe.RQi();
            const s = this.nI();
            if (!s)
                return;
            const n = this.Iwe();
            if (!t.sJe) {
                const t = n.Awe(sN.Qs.TO.QU());
                if (t) {
                    if (t.i_t())
                        return void t.ext();
                    if (!t.dEt() && t.pEt())
                        return void n.Mo(t.gEt())
                }
            }
            if (!s.F0e())
                return;
            if (!s.L0e())
                return;
            await this.B0e();
            const r = (async () => {
                if (await this.U0e("beforeundo"),
                s.hat())
                    return;
                const t = this.Us()
                  , i = t.IR();
                i && t.NU(!1);
                const e = await s.ext();
                return i && t.NU(!0),
                await this.U0e("afterundo"),
                s.Xbt(),
                e
            }
            )()
              , h = await this.oL(r);
            h && (t.showNotification && sN.Qs.Notification.NT("undo", rN("main-menu.undo"), h.La(), {
                align: "bottom-left",
                e0i: sN.Qs.mk.pMi()
            }),
            this.N0e())
        }
        async nxt(t) {
            t = Object.assign({}, bN, t);
            const i = sN.Qs.mk.Oxi();
            if (sN.Qs.mk.pMi() && i && !i.vmt())
                return;
            const e = sN.ddt();
            if (!t.ZRt && e && document.activeElement && !sN.Fft(document.activeElement, ["ui-propertygrid"]))
                return void this.zJe.RQi();
            const s = this.nI();
            if (!s)
                return;
            const n = this.Iwe();
            if (!t.sJe) {
                const t = n.Awe(sN.Qs.TO.QU());
                if (t && t.s_t())
                    return void t.nxt()
            }
            if (!s.F0e())
                return;
            if (!s.j0e())
                return;
            await this.B0e();
            const r = (async () => {
                if (await this.U0e("beforeundo"),
                s.hat())
                    return;
                const t = this.Us()
                  , i = t.IR();
                i && t.NU(!1);
                const e = await s.nxt();
                return i && t.NU(!0),
                await this.U0e("afterundo"),
                s.Xbt(),
                e
            }
            )()
              , h = await this.oL(r);
            h && (t.showNotification && sN.Qs.Notification.NT("redo", rN("main-menu.redo"), h.La(), {
                align: "bottom-left",
                e0i: sN.Qs.mk.pMi()
            }),
            this.N0e())
        }
        async y_t(t) {
            sN.Ge(t),
            t <= 0 || (await this.$0e(t),
            sN.Qs.Notification.NT("undo", rN("main-menu.undo"), oN("main-menu.undo-multiple-changes", null, t), {
                align: "bottom-left",
                e0i: sN.Qs.mk.pMi()
            }))
        }
        async $0e(t) {
            if (sN.Ge(t),
            !(t <= 0))
                return t--,
                await this.ext({
                    showNotification: !1,
                    sJe: !0
                }),
                this.$0e(t)
        }
        async __t(t) {
            sN.Ge(t),
            t <= 0 || (await this.z0e(t),
            sN.Qs.Notification.NT("redo", rN("main-menu.undo"), oN("main-menu.redo-multiple-changes", null, t), {
                align: "bottom-left",
                e0i: sN.Qs.mk.pMi()
            }))
        }
        async z0e(t) {
            if (sN.Ge(t),
            !(t <= 0))
                return t--,
                await this.nxt({
                    showNotification: !1,
                    sJe: !0
                }),
                this.z0e(t)
        }
        jD() {
            for (let t of this.kJe)
                t.jD()
        }
        V0e(t) {
            sN.U(t, window.g_);
            let i = self.app.Us().Uz(t);
            i && i.qM()
        }
        Hv(t) {
            sN.U(t, window.ig),
            t.zH() ? this.V0e(t.Kz().td()) : this.V0e(t.td())
        }
        zs() {
            this.Us().zs(),
            this.dh() && this.mh().fh()
        }
        N0e() {
            this.Us().zs(),
            this.dh() && this.mh().Qw()
        }
        $U(t) {
            if (sN.Ef(t, self.jw),
            this.wjt !== t) {
                if (t && !this.kJe.includes(t))
                    throw new Error("invalid active project");
                this.ZQe(this.wjt, "beforeprojectactive"),
                this.wjt = t,
                this.fZe(),
                this.ZQe(this.wjt, "projectactive")
            }
        }
        La() {
            return this.q$e() ? aN("ui.title-beta", super.La()) : this.kZe() ? aN("ui.title-lts", super.La()) : super.La()
        }
        fZe() {
            let t;
            t = "Chromium" === sN.kt._9t && "standalone" === sN.vii() ? this.wjt ? this.wjt.La() : "animation" === this.bne() ? rN("ui.title-make-animations") : rN("ui.title-make-games") : this.wjt ? this.wjt.La() + " - " + this.La() : "animation" === this.bne() ? this.La() + " - " + rN("ui.title-make-animations") : this.La() + " - " + rN("ui.title-make-games"),
            document.title = t
        }
        nI() {
            return this.kJe.length ? 1 === this.kJe.length ? this.kJe[0] : this.wjt ? this.wjt : this.kJe.length ? this.kJe[0] : null : null
        }
        ye() {
            this.ZJe = !0,
            this.JJe = performance.now()
        }
        $W() {
            return this.ZJe
        }
        ER() {
            return this.ZJe ? performance.now() - this.JJe : 0
        }
        yT() {
            this.ZJe = !1,
            this.y0("livepreviewstop")
        }
        async rJe() {
            if (await this.$T()) {
                const t = this.nI();
                t && t.W0e()
            } else
                this.Fq();
            this.dispatchEvent(new sN.Event("accountstatechange"))
        }
        bne() {
            return xN
        }
        CGe(t) {
            return sN.zt(t),
            !t || "all" === t || xN === t
        }
        CP() {
            return EN === vN
        }
        $T() {
            return Promise.resolve(EN === vN)
        }
        j$e() {
            return _N
        }
        Bme() {
            return "animation" !== this.bne()
        }
        FZe() {
            if ("gamejam" !== this.Oze())
                return Promise.resolve();
            if (!BN)
                return Promise.resolve();
            const t = BN.name
              , i = new Date(1e3 * TN);
            sN.p.u("user-account.gamejam-license-warning");
            const e = sN.Qs.Ks.qs("OK");
            e.Wa(rN(".title"));
            const s = e.Xa(hN(".message", i.toLocaleDateString(self.app.X7(), {
                weekday: "long",
                day: "numeric",
                month: "long",
                year: "numeric"
            }), t));
            return sN.p.j(),
            s
        }
        H0e() {
            if (!IN)
                return Promise.resolve();
            sN.p.u("user-account.subscription-suspended-notification");
            const t = sN.Qs.Ks.qs("OK");
            t.Wa(rN(".title"));
            const i = t.Xa(hN(".message", PN));
            return sN.p.j(),
            i
        }
        Oze() {
            return _N ? "access-code" : EN
        }
        qWe() {
            return CN
        }
        Rze() {
            return TN
        }
        TEt() {
            return AN
        }
        zQt() {
            return Promise.resolve(AN)
        }
        rme() {
            return RN
        }
        async ame(t) {
            if (sN.U(t, self.jw),
            !this.rme())
                return;
            const i = t.La() + ".c3p";
            let e = i;
            const s = sN.p.Yue("ui.share-with-sub-admin-prompt")
              , n = sN.Qs.Ks.qs("Input")
              , r = await n.Xa({
                caption: s(".caption"),
                message: sN.v(sN.ix, s(".message"), {
                    AU: !0,
                    links: [sN.dQ.URL.KIe]
                }),
                label: s(".label"),
                _Ti: i
            });
            if (null === r)
                return;
            "string" == typeof r && r && (e = r,
            e.toLowerCase().endsWith(".c3p") || (e += ".c3p")),
            this.QJe++;
            let h = null
              , o = 0;
            try {
                const i = await this.f0e(t);
                if (o = i.size,
                i.size > 104857600)
                    throw {
                        responseCode: "FileTooLarge"
                    };
                h = this.K0e(s(".progress-status")),
                h.uqi(0);
                const n = await this.uq("useraccount").q0e(i, e, this.j$e(), t => {
                    h && h.uqi(t)
                }
                );
                if (!n.succeeded)
                    throw n;
                sN.Qs.Notification.NT("share-arrow", s(".completed.title"), s(".completed.message"), {
                    align: "bottom-left",
                    UEt: 1e4
                }),
                this.XGi("SaveProjectMethod", "share-with-admin")
            } catch (t) {
                console.error("[Project] Error sharing with subscription admin: ", t);
                let i = "";
                if (t && t.responseCode) {
                    const e = t.responseCode;
                    i = "FileTooLarge" === e ? s.dme(".errors.file-too-large", sN.Woi(o)) : "SubscriptionExpired" === e ? s(".errors.subscription-expired") : s.e4t(".errors.failed", e)
                } else
                    i = s.e4t(".errors.failed", "unknown error");
                sN.Qs.Ks.qs("OK").Xa(i)
            } finally {
                this.QJe--,
                h && h.he()
            }
        }
        l3t() {
            return kN
        }
        Vbi() {
            return this.TEt() ? 1 / 0 : MN.Gme() ? 500 : 250
        }
        gnt() {
            return ON
        }
        kze() {
            return DN
        }
        ILt() {
            return FN
        }
        RP(t, i) {
            return sN.Ge(i),
            sN.Ef(t, self.jw),
            new Promise(e => {
                window.setTimeout( () => this.X0e(t, i), 20)
            }
            )
        }
        X0e(t, i) {
            sN.Qs.Ks.qs("FreeEditionLimit").Xa(t, i)
        }
        Q7(t, i) {
            return sN.U(t, self.jw),
            sN.Ge(i),
            new Promise(e => {
                window.setTimeout( () => this.Y0e(t, i).then(e), 20)
            }
            )
        }
        Y0e(t, i) {
            return sN.Qs.Ks.qs("ScriptingFeatureLimit").Xa(t, i)
        }
        y0(t) {
            sN.zt(t);
            const i = new sN.Event(t);
            i.app = this,
            this.dispatchEvent(i)
        }
        async Obi(t) {
            sN.zt(t);
            const i = new sN.Event(t);
            i.app = this,
            await this.cfi(i)
        }
        async U0e(t) {
            sN.zt(t);
            const i = new sN.Event(t);
            i.app = this,
            await this.Xmt(i)
        }
        ZQe(t, i) {
            if (sN.Ef(t, self.jw),
            sN.zt(i),
            t && t.Xw())
                return;
            let e = new sN.Event(i);
            e.Iw = t,
            this.dispatchEvent(e)
        }
        async QQe(t, i) {
            if (sN.Ef(t, self.jw),
            sN.zt(i),
            t && t.Xw())
                return;
            let e = new sN.Event(i);
            e.Iw = t,
            await this.Xmt(e)
        }
        RJt(t, i) {
            if (sN.U(t, self.ZQ),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Dee = t,
            this.dispatchEvent(e)
        }
        J0e(t, i) {
            if (sN.U(t, self.g_),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.layout = t,
            this.dispatchEvent(e)
        }
        Z0e(t, i) {
            if (sN.U(t, self.OTt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Cjt = t,
            this.dispatchEvent(e)
        }
        Pnt(t, i, e) {
            if (sN.U(t, self.t_),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.NE = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        Q0e(t, i) {
            if (sN.U(t, self.t1e),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.i1e = t,
            this.dispatchEvent(e)
        }
        e1e(t, i) {
            if (sN.U(t, self.UQ),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.aBt = t,
            this.dispatchEvent(e)
        }
        s1e(t, i) {
            if (sN.U(t, self.CTt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e._jt = t,
            this.dispatchEvent(e)
        }
        n1e(t, i) {
            if (sN.U(t, self.i_),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.KJ = t,
            this.dispatchEvent(e)
        }
        r1e(t, i) {
            if (sN.U(t, self.BHt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            const e = new sN.Event(i);
            e.Wjt = t,
            this.dispatchEvent(e)
        }
        h1e(t, i, e) {
            if (sN.U(t, self.lFe),
            sN.Ef(i, self.i_),
            sN.zt(e),
            t.Cn().Xw())
                return;
            let s = new sN.Event(e);
            s.container = t,
            s.KJ = i,
            this.dispatchEvent(s)
        }
        Qv(t, i, e) {
            if (sN.U(t, self.PC),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.qj = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        o1e(t, i) {
            if (sN.U(t, self.Hte),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Fee = t,
            this.dispatchEvent(e)
        }
        a1e(t, i) {
            if (sN.U(t, self.qte),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Tee = t,
            this.dispatchEvent(e)
        }
        l1e(t, i) {
            if (sN.U(t, self.Tte),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Uee = t,
            this.dispatchEvent(e)
        }
        u1e(t, i, e) {
            if (sN.U(t, self.Fg),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.animation = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        c1e(t, i) {
            if (sN.U(t, self.zf),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.jf = t,
            this.dispatchEvent(e)
        }
        d1e(t, i) {
            if (sN.U(t, self.f1e),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.p1e = t,
            this.dispatchEvent(e)
        }
        m1e(t, i, e) {
            if (sN.U(t, self.e0),
            sN.zt(i),
            t.Cn().Xw())
                return;
            const s = new sN.Event(i);
            s.GS = t,
            e && Object.assign(s, e),
            this.dispatchEvent(s)
        }
        w1e(t, i) {
            if (sN.U(t, self.REt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.sTt = t,
            this.dispatchEvent(e)
        }
        Cte(t, i) {
            sN.zt(t),
            sN.ML(i);
            let e = new sN.Event(t);
            e.GIt = self.app.mh(),
            this.dispatchEvent(Object.assign(e, i))
        }
        g1e(t) {
            if (sN.zt(t),
            !self.app.gK())
                return;
            let i = new sN.Event(t);
            i.Qee = self.app.jA(),
            this.dispatchEvent(i)
        }
        y1e(t, i, ...e) {
            if (sN.U(t, self.fM),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.timeline = t,
            s.AN = e,
            s.cb = () => t,
            this.dispatchEvent(s)
        }
        b1e(t, i, ...e) {
            if (sN.U(t, self.nhe),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.track = t,
            s.AN = e,
            s.cb = () => t.cb(),
            this.dispatchEvent(s)
        }
        v1e(t, i, ...e) {
            if (sN.U(t, self.ohe),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.Nee = t,
            s.AN = e,
            this.dispatchEvent(s)
        }
        S1e(t, i) {
            if (sN.U(t, self.jK),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Eee = t,
            this.dispatchEvent(e)
        }
        x1e(t, i) {
            if (sN.U(t, self.xK),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Vee = t,
            this.dispatchEvent(e)
        }
        M1e(t, i) {
            if (sN.U(t, self.kTt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Rjt = t,
            this.dispatchEvent(e)
        }
        E1e(t, i) {
            if (sN.U(t, self.the),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Jee = t,
            e.cb = () => t.cb(),
            this.dispatchEvent(e)
        }
        C1e(t, i) {
            if (sN.U(t, self.ahe),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.$ee = t,
            e.cb = () => t.cb(),
            this.dispatchEvent(e)
        }
        _1e(t, i) {
            if (sN.U(t, self.che),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.zee = t,
            this.dispatchEvent(e)
        }
        T1e(t, i) {
            if (sN.U(t, self.fte),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.transition = t,
            this.dispatchEvent(e)
        }
        I1e(t, i) {
            if (sN.U(t, self.P1e),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.G1e = t,
            this.dispatchEvent(e)
        }
        A1e(t, i) {
            if (sN.U(t, self.xTt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Gjt = t,
            this.dispatchEvent(e)
        }
        R1e(t, i) {
            if (sN.U(t, self.mM),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Aee = t,
            this.dispatchEvent(e)
        }
        k1e(t, i) {
            if (sN.U(t, self.ETt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Djt = t,
            this.dispatchEvent(e)
        }
        O1e(t, i) {
            if (sN.U(t, self.yte),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Mee = t,
            this.dispatchEvent(e)
        }
        D1e(t, i) {
            if (sN.U(t, self.gte),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.Yee = t,
            this.dispatchEvent(e)
        }
        F1e(t, i) {
            if (sN.U(t, self.oFe),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let e = new sN.Event(i);
            e.L1e = t,
            this.dispatchEvent(e)
        }
        vH(t, i, e) {
            sN.U(t, self.y_),
            sN.zt(i),
            sN.ML(e);
            let s = new sN.Event(i);
            s.Ur = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        fY(t, i) {
            sN.zt(t),
            sN.ML(i);
            let e = new sN.Event(t);
            e.tct = this.Us().PE().uA(),
            e.AN = i,
            this.dispatchEvent(e)
        }
        KD(t, i) {
            sN.QH(t, window.ig),
            sN.zt(i),
            nN("topOfLayer" === i || "bottomOfLayer" === i || "otherLayer" === i, "invalid moveTo value");
            let e = new Map;
            for (let i of t) {
                let t = i.Za();
                e.has(t) ? e.get(t).push(i) : e.set(t, [i])
            }
            for (let t of e.values())
                t.sort(self.ig.B1e);
            let s = new sN.Event("objectinstanceszorderchange");
            s.moveTo = i,
            s.k$t = e,
            this.dispatchEvent(s)
        }
        r_t(t, i, e) {
            sN.zt(i),
            sN.ML(e);
            let s = new sN.Event(i);
            s.U1e = t,
            e && (s.AN = e),
            this.dispatchEvent(s)
        }
        N1e(t, i, e) {
            if (sN.U(t, self.j1e),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.$1e = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        z1e(t, i, e) {
            if (sN.U(t, self.IEt),
            sN.zt(i),
            t.Cn().Xw())
                return;
            let s = new sN.Event(i);
            s.V1e = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        Pbi(t) {
            return sN.zt(t),
            new sN.Qs.Fk.dqi(this.hqi,t)
        }
        K0e(t) {
            return sN.zt(t),
            new sN.Qs.Fk.aqi(this.hqi,t)
        }
        W1e() {
            return this.BJe
        }
        H1e() {
            return this.UJe
        }
        K1e() {
            return this.NJe
        }
        q1e() {
            return this.jJe
        }
        X1e() {
            return this.$Je
        }
        async oL(t) {
            sN.U(t, Promise),
            nN(!this.eZe.has(t), "async work promise already added"),
            this.eZe.add(t);
            try {
                return await t
            } finally {
                this.eZe.delete(t)
            }
        }
        B0e() {
            return Promise.all([...this.eZe])
        }
        QHt() {
            return this.eZe.size > 0
        }
        mZe() {
            if (this.WJe)
                return;
            const t = self.devicePixelRatio;
            if (Math.abs(t - this.VJe) >= .01) {
                this.WJe = !0;
                sN.Qs.Ks.qs("OK").Xa(rN("ui.zoom-level-changed-message"))
            }
        }
        Ene(t) {
            return sN.zt(t),
            t.startsWith("http:") || t.startsWith("https:") || (t && !t.startsWith("/") && (t = "/" + t),
            t = sN.dQ.URL.mQ + t),
            t
        }
        FT(t, i) {
            sN.zt(t),
            sN.gL(i),
            this.pQ(this.Ene(t), "OpenManualLink", i)
        }
        jLe(t, i, e) {
            let s = null;
            try {
                s = new URL(t)
            } catch (i) {
                return console.error(`Invalid URL '${t}': `, i),
                t
            }
            if ("construct.net" === s.hostname || "www.construct.net" === s.hostname) {
                const t = new URLSearchParams(s.search);
                return t.append("utm_campaign", "C3Editor"),
                t.append("utm_source", sN.vii()),
                t.append("utm_medium", sN.dQ.mPe),
                i && t.append("utm_term", i),
                e && t.append("utm_content", e),
                s.search = t.toString(),
                s.toString()
            }
            return t
        }
        pQ(t, i, e) {
            sN.zt(t),
            sN.gL(i),
            sN.gL(e),
            t = this.jLe(t, i, e),
            window.open(t)
        }
        n0e() {
            return this.HJe
        }
        Y1e() {
            return this.KJe
        }
        q$e() {
            return "beta" === this.oNe()
        }
        kZe() {
            return "lts" === this.oNe()
        }
        oNe(t) {
            let i = sN.dQ.UIe;
            return "lts" === i && t && (i = "LTS"),
            i
        }
        r0e(t) {
            if (this.mdt())
                return;
            if (this.qJe)
                return;
            const i = this.que.Wue().t2().c2("preview");
            i && (sN.p.u("ui.first-run.run-project-tip"),
            sN.Qs.Fk.Uk.NT(i.k_(), "info", rN(".title"), rN(".description"), {
                align: "bottom"
            }),
            sN.p.j(),
            this.qJe = !0)
        }
        XGi(t, i) {
            let e;
            if (sN.zt(t),
            "string" == typeof i)
                e = {
                    event_label: i
                };
            else {
                if ("object" != typeof i)
                    throw new TypeError("invalid analytics label");
                e = i
            }
            this.mdt() && !t.startsWith("tutorial_") || this.J1e({
                type: "event",
                eventAction: t,
                eventData: e
            })
        }
        AZe(t, i, e, s=3e5) {
            sN.zt(t),
            sN.Ge(i),
            sN.gL(e),
            (i = Math.round(i)) >= s || this.J1e({
                type: "timing",
                timingVar: t,
                timingValue: i,
                timingLabel: e
            })
        }
        vHe(t) {
            sN.zt(t),
            this.Tme() || this.J1e({
                type: "crash",
                description: t,
                release_name: sN.dQ.mPe,
                product_type: xN
            })
        }
        async Z1e(t) {
            if (dN)
                this.XGi("LoginStateChanged", t);
            else {
                dN = !0,
                await this.DJe,
                await this.x_.CU();
                let i = "(none)"
                  , e = "no-webgl"
                  , s = 0;
                if (this.yQe()) {
                    const t = this.un();
                    t.r4i() ? (i = "webgl" + t.k9i(),
                    e = t.Gbe()) : (i = "webgpu",
                    e = "n/a"),
                    t.n4i() && (i += "-majorperfcaveat"),
                    s = t.T5i()
                }
                this.J1e({
                    type: "pageview",
                    page_title: document.title,
                    page_location: document.location.toString(),
                    page_referrer: document.referrer,
                    user_properties: {
                        product_type: xN,
                        login_state: t
                    },
                    custom_dimensions: {
                        release_name: sN.dQ.mPe + " (" + this.oNe(!0) + ")",
                        language_setting: this.aU().language || "(unknown)",
                        theme: this.aU().theme || "(default)",
                        display_mode: sN.vii(),
                        ui_mode: sN.kt.Y_ ? "mobile" : "desktop",
                        webgl_support: i,
                        webgl_extensions: e,
                        webgl_max_texture_size: s,
                        device_pixel_ratio: Math.round(10 * (self.devicePixelRatio || 0)) / 10
                    }
                })
            }
        }
        J1e(t) {
            SN ? SN(t) : (() => {})("[Analytics] Sandbox iframe unavailable, skipped logging")
        }
        async lNe() {
            let t = await localforage.getItem("c3-time-spent-in-editor");
            "number" != typeof t && (t = 0),
            localforage.setItem("c3-time-spent-in-editor", t + fN / 1e3).catch(t => this._we(t))
        }
        async rZe() {
            await sN.Qs.mk.kMi();
            const t = sN.Qs.Ks.qs("OK");
            await t.Xa(rN("ui.take-a-break-reminder"))
        }
        _we(t, i) {
            if (sN.gL(i),
            (() => {})("Storage error:", t),
            this.hZe || this.mdt())
                return;
            this.hZe = !0,
            this.XGi("StorageError", t ? t.toString() : "<unknown>"),
            sN.p.u("ui.errors.storage-error");
            const e = sN.Qs.Ks.qs("Confirm");
            e.Wa(),
            e.Xa({
                caption: rN(".caption"),
                message: i || rN(".message"),
                _nt: rN(".storage-cleanup")
            }).then(t => {
                if (null === t)
                    return void this.XGi("StorageErrorPrompt", "Cancelled");
                this.XGi("StorageErrorPrompt", "OK-StorageCleanup");
                sN.Qs.Ks.qs("StorageCleanup").Xa()
            }
            ),
            sN.p.j()
        }
        r3t(t, i) {
            sN.gL(t),
            sN.gL(i),
            "UserAccountMenu" === t || "WelcomeDialog" === t || "ScriptingFeatureLimit" === t ? this.pQ(sN.dQ.URL.QIe, t, i) : this.MJe.XO() ? (this.MJe.Q1e(t, i),
            this.eU(this.MJe.jO())) : (this.MJe.Q1e(t, i),
            this.MJe.lQ(!0))
        }
        async RZe() {
            if (!new URLSearchParams(location.search).has("openmru"))
                return;
            const t = await self.Hue.ul();
            if (0 === t.length)
                return;
            const i = sN.Qs.Ks.qs("OK");
            await i.Xa("Click OK to open most recently used project, as this may need a user gesture."),
            await self.Hue.mme(t[0])
        }
        Dei() {
            return this.PJe || (this.PJe = new AudioContext),
            this.PJe
        }
    }
    ,
    Object.freeze(window.oJe.prototype);
    const YN = window.oJe.prototype
      , JN = [YN.CP, YN.Oze, YN.Rze, YN.l3t, YN.gnt, YN.kze, YN.ILt, YN.$T, YN.j$e, YN.qWe, YN.TEt, YN.zQt, YN.bne, YN.CGe]
      , ZN = new Set(["https://account.construct.net", "https://accountbeta.construct.net", "https://addons.construct.net", "https://cloud.construct.net", "https://stats.construct.net"])
      , QN = new Map
      , tj = 4e3;
    let ij = -1;
    const ej = window.setTimeout
      , sj = document.getElementsByTagName("iframe")
      , nj = document;
    function rj(t) {
        let i = t.parentNode;
        for (; i; ) {
            if (i === nj)
                return !0;
            i = i.parentNode
        }
        return !1
    }
    function hj() {
        throw XN.aJe = null,
        XN.GW = null,
        XN.hqi = null,
        XN.que = null,
        XN.lJe = null,
        XN.x_ = null,
        XN.A2t = null,
        XN.eNt = null,
        XN.dJe = null,
        XN.fJe = null,
        XN.pJe = null,
        XN.rft = null,
        XN.mJe = null,
        XN.wJe = null,
        XN.gJe = null,
        XN.yJe = null,
        XN.bJe = null,
        XN.vJe = null,
        XN.SJe = null,
        XN.xJe = null,
        XN.EJe = null,
        XN.CJe = null,
        XN._Je = null,
        XN.zJe = null,
        XN.kJe = [],
        XN.wjt = null,
        XN.kf && XN.kf.he(),
        XN.kf = null,
        WN(null),
        new Error("security exception")
    }
    function oj() {
        ij = -1,
        aj()
    }
    function aj() {
        if (-1 !== ij && window.clearTimeout(ij),
        !sN.ev())
            return;
        ij = ej(oj, tj);
        const t = new Set;
        for (let i = 0, e = sj.length; i < e; ++i) {
            const e = sj[i];
            if (!e.src)
                continue;
            const s = new URL(e.src).origin.toLowerCase();
            if (ZN.has(s)) {
                if (QN.has(s)) {
                    if (QN.get(s) !== e)
                        return void hj()
                } else
                    QN.set(s, e);
                if (t.has(s))
                    return void hj();
                t.add(s)
            }
        }
        for (const t of QN.values())
            if (!rj(t))
                return void hj();
        if (JN) {
            const t = JN
              , i = self.app;
            if (t[0] !== i.CP || t[1] !== i.Oze || t[2] !== i.Rze || t[3] !== i.l3t || t[4] !== i.gnt || t[5] !== i.kze || t[6] !== i.ILt || t[7] !== i.$T || t[8] !== i.j$e || t[9] !== i.qWe || t[10] !== i.TEt || t[11] !== i.zQt || t[12] !== i.bne || t[13] !== i.CGe || Object.getPrototypeOf(i) !== YN)
                return void hj()
        }
    }
    document.addEventListener("pointermove", aj, !0),
    ej(oj, tj)
}
{
    const lj = self.t;
    function uj(t, i, e=!0) {
        e && lj.Qs.mk.pMi() || t.dispatchEvent(lj.v(lj.Event, i, !0))
    }
    function cj() {}
    const dj = lj.kt.hyt ? "meta" : "ctrl"
      , fj = [new lj.Qs.dQi(lj.Mk.CDt,"delete"), new lj.Qs.dQi(lj.Mk.F2,"rename"), new lj.Qs.dQi(lj.Mk.aY,"edit"), new lj.Qs.dQi(dj,lj.Mk.A,"select-all"), new lj.Qs.dQi(dj,lj.Mk.D,"unselect"), new lj.Qs.dQi(dj,lj.Mk.Sci,"scroll-to-start"), new lj.Qs.dQi(dj,lj.Mk.vci,"scroll-to-end"), new lj.Qs.dQi("alt","shift",lj.Mk.zZ,"back"), new lj.Qs.dQi("alt","shift",lj.Mk.WZ,"next"), new lj.Qs.dQi("alt","shift",lj.Mk.B,"back").SQi(), new lj.Qs.dQi("alt","shift",lj.Mk.N,"next").SQi(), new lj.Qs.dQi(dj,lj.Mk.Z,t => uj(t, "undo", !1)), new lj.Qs.dQi(dj,lj.Mk.Y,t => uj(t, "redo", !1)), new lj.Qs.dQi(dj,lj.Mk.zmt,"zoom-in").MQi(), new lj.Qs.dQi(dj,lj.Mk.Nmt,"zoom-out").MQi(), new lj.Qs.dQi(dj,"shift",lj.Mk.zmt,"zoom-in-more").MQi(), new lj.Qs.dQi(dj,"shift",lj.Mk.Nmt,"zoom-out-more").MQi(), new lj.Qs.dQi(dj,lj.Mk.Lmt,"reset-zoom").MQi(), new lj.Qs.dQi(dj,lj.Mk.F,t => t.v4t()).SQi(), new lj.Qs.dQi(dj,"shift",lj.Mk.F,t => t.mQe()), new lj.Qs.dQi(dj,lj.Mk.P,t => uj(t, "print")), new lj.Qs.dQi(dj,lj.Mk.N,t => t.aQ()), new lj.Qs.dQi("alt",lj.Mk.N,t => t.mze()), new lj.Qs.dQi(dj,lj.Mk.O,t => t.wme(t.nQe())), new lj.Qs.dQi(dj,lj.Mk.S,t => t.Zue(t.nI())).SQi(), new lj.Qs.dQi(lj.Mk.F4,t => t.lme(t.nI(), !1)).SQi(), new lj.Qs.dQi("shift",lj.Mk.F4,t => t.ume(t.nI(), !1)).SQi(), new lj.Qs.dQi(lj.Mk.F5,t => t.ywe(null, !1)).SQi(), new lj.Qs.dQi(dj,lj.Mk.F5,t => t.kwe(null, !1)).SQi(), new lj.Qs.dQi("shift",lj.Mk.F5,t => t.kwe(null, !1)).SQi(), new lj.Qs.dQi("alt",lj.Mk.Tci,t => t.lme(t.nI(), !0)), new lj.Qs.dQi("alt","shift",lj.Mk.Tci,t => t.ume(t.nI(), !0)), new lj.Qs.dQi("alt",lj.Mk.Ici,t => t.ywe(null, !0)), new lj.Qs.dQi("alt","shift",lj.Mk.Ici,t => t.kwe(null, !0)), new lj.Qs.dQi(lj.Mk.F6,t => t.pme(t.nI())).SQi(), new lj.Qs.dQi(lj.Mk.F9,t => {
        const i = t.nI();
        i && "webfs-local-folder" === i.hHt() && i.hLt(i.z7())
    }
    ).SQi(), new lj.Qs.dQi(dj,lj.Mk.E,"go-to-event-sheet"), new lj.Qs.dQi("shift",lj.Mk.S,"go-to-associated"), new lj.Qs.dQi(dj,"shift",lj.Mk.UZ,"move-to-top"), new lj.Qs.dQi(dj,"shift",lj.Mk.FZ,"move-to-bottom"), new lj.Qs.dQi(dj,lj.Mk.R,"start-all-live-previews"), new lj.Qs.dQi(dj,"shift",lj.Mk.R,t => t.yT()), new lj.Qs.dQi(dj,lj.Mk.L,"go-to-layout"), new lj.Qs.dQi("ctrl","shift",lj.Mk.WZ,t => uj(t, "next-tab")), new lj.Qs.dQi("ctrl","shift",lj.Mk.zZ,t => uj(t, "previous-tab")), new lj.Qs.dQi("alt",lj.Mk.W,t => uj(t, "close-current-tab")).SQi(), new lj.Qs.dQi(dj,lj.Mk.udi,t => uj(t, "replace-whole-hierarchy")), new lj.Qs.dQi(dj,lj.Mk.cdi,t => uj(t, "modify-existing-hierarchy")), new lj.Qs.dQi("alt-gr",lj.Mk.eyt("open-square-bracket"),t => uj(t, "replace-whole-hierarchy")), new lj.Qs.dQi("alt-gr",lj.Mk.eyt("close-square-bracket"),t => uj(t, "modify-existing-hierarchy")), new lj.Qs.dQi("alt",lj.Mk.WZ,cj), new lj.Qs.dQi("alt",lj.Mk.zZ,cj), new lj.Qs.dQi("meta",lj.Mk.WZ,cj), new lj.Qs.dQi("meta",lj.Mk.zZ,cj)];
    window.pZe = fj
}
{
    const pj = self.t;
    let mj = null;
    const wj = !!window.C3_IsPopupWindow
      , gj = new Map([["propertiesbar", "components/bars/propertiesBar/propertiesBar.html"], ["midpane", "components/misc/midPane/midPane.html"], ["projectbar", "components/bars/projectBar/projectBar.html"], ["layersbar", "components/bars/layersBar/layersBar.html"], ["tilemapbar", "components/bars/tilemapBar/tilemapBar.html"], ["zorderbar", "components/bars/zOrderBar/zOrderBar.html"], ["instancebar", "components/bars/instanceBar/instanceBar.html"], ["bookmarksbar", "components/bars/bookmarksBar/bookmarksBar.html"], ["mainMenu", "components/misc/mainMenu/mainMenu.html"], ["findresultsbar", "components/bars/findResultsBar/findResultsBar.html"], ["findreferencesbar", "components/bars/findReferencesBar/findReferencesBar.html"], ["startpage2", "components/misc/startPage2/startPage2.html"], ["examplebrowser", "components/misc/exampleBrowser/exampleBrowser.html"], ["useraccount", "components/misc/userAccount/userAccount.html"], ["buynowpage", "components/misc/buyNowPage/buyNowPage.html"], ["timelineBar", "components/bars/timelineBar/timelineBar.html"], ["guidedtourcontroller", "components/misc/tourController/tourController.html"], ["remotePreviewBar", "components/bars/remotePreviewBar/remotePreviewBar.html"], ["assetBrowserBar", "components/bars/assetBrowserBar/assetBrowserBar.html"]])
      , yj = new Map([["layoutview", "components/editors/layoutView/layoutView.html"], ["eventsheetview", "components/editors/eventSheetView/eventSheetView.html"], ["flowchartview", "components/editors/flowchartView/flowchartView.html"], ["texteditor", "components/editors/textEditor/textEditor.html"], ["dataeditor", "components/editors/dataEditor/dataEditor.html"]]);
    function bj(t) {
        self.C3_SetLoadingHTML(t)
    }
    window.C3_OnAppFatalLoadError = function(t) {
        if (window.C3_HadLoaderError)
            return;
        window.C3_HadLoaderError = !0;
        const i = document.createElement("div");
        i.classList.add("apploaderrorcontainer");
        const e = document.createElement("div");
        e.classList.add("apploadererrormessage"),
        e.innerHTML = "<strong>Oops! There was an error loading Construct.</strong><br>Try the following:<ul ><li>Check your Internet connection is working.</li><li>Try disabling any browser addons you have installed. These can sometimes break Construct. In particular, Kaspersky Internet Security has been known to cause problems.</li><li>Check ad or tracking blocking settings which can also sometimes break Construct, including if you use a VPN. In particular, NordVPN has been known to cause problems.</li><li>Clear your browser cache and try again.</li><li>Press F12 and look for any additional errors in the browser console.</li></ul>Error details: " + t,
        i.appendChild(e),
        document.body.appendChild(i),
        mj && mj.XGi("LoadError", "" + t)
    }
    ;
    let vj = 0
      , Sj = 0;
    async function xj() {
        pj.lU("Bootstrap"),
        pj.z8t(),
        wj || bj("Loading UI..."),
        mj = pj.v(self.oJe),
        !pj.q8t() && pj.J8t || Object.seal(mj),
        await mj.K0i();
        const t = mj.aU().uiMode;
        "mobile" === t ? (pj.kt.Y_ = !0,
        pj.kt.FG = !1,
        pj.Qs.sSi()) : "desktop" === t && (pj.kt.Y_ = !1,
        pj.kt.FG = !0,
        pj.Qs.sSi()),
        wj || (bj("Loading..."),
        _j());
        const i = pj.p.Ro(mj.aU().language)
          , e = pj.Qs.wP.yrt("default")
          , s = Ej(gj);
        wj || s.then( () => {
            Tj(),
            bj("Starting...")
        }
        ),
        await Promise.all([i, e]),
        pj.OU("Bootstrap"),
        await Ij({
            gZe: s,
            KZe: yj
        })
    }
    async function Mj(t, i) {
        await pj.Nii(i, !1),
        Sj++
    }
    function Ej(t) {
        const i = [];
        for (const [e,s] of t)
            i.push(Mj(0, s));
        return vj += i.length,
        Promise.all(i)
    }
    window.c3_mainLoadPromise = xj().catch(t => window.C3_OnAppFatalLoadError(t));
    let Cj = -1;
    function _j() {
        let t = -1;
        Cj = window.setInterval( () => {
            const i = Sj
              , e = vj;
            if (0 === e)
                return;
            const s = Math.round(100 * i / e);
            s !== t && (bj("Loading (" + s + "%)..."),
            t = s)
        }
        , 100)
    }
    function Tj() {
        -1 !== Cj && (window.clearInterval(Cj),
        Cj = -1)
    }
    async function Ij(t) {
        if (!window.C3_HadLoaderError && (await mj.yrt(t),
        wj ? pj.q8t() || (await pj.Nii("projectResources.html", !0),
        await Promise.all([...t.KZe.values()].map(t => pj.Nii(t, !1)))) : (pj.Qs.qvi(),
        await mj.Q0i(t)),
        pj.$M)) {
            const t = pj.S9t.qs("project");
            if (t) {
                if ("new" === t)
                    return void mj.mze();
                await mj.AQe(`exampleProjects/debug/${t}.capx`);
                const i = mj.kJe[0]
                  , e = pj.S9t.qs("layout");
                if (e) {
                    const t = i.oq(e);
                    t && mj.yH(t)
                } else {
                    const t = pj.S9t.qs("eventsheet");
                    if (t) {
                        const e = i.aq(t);
                        e && mj.OT(e)
                    }
                }
            }
        }
    }
}
{
    const Pj = self.t
      , Gj = self.lang
      , Aj = "C3_RecentProjects"
      , Rj = 2
      , kj = 10
      , Oj = new Set(["cloud", "webfs-single-file", "webfs-local-folder"])
      , Dj = new Set(["DROPBOX", "ONE DRIVE", "GOOGLE DRIVE", "LOCAL STORAGE"]);
    let Fj = []
      , Lj = null;
    function Bj(t) {
        const i = {};
        for (const [e,s] of t)
            Object.defineProperty(i, e, {
                writable: !1,
                value: s,
                enumerable: !0
            });
        return i
    }
    async function Uj(t, i) {
        Pj.U(t, self.jw),
        Pj.zt(i);
        const e = t.hHt();
        if (!Oj.has(e))
            return;
        const s = await t.t2e()
          , n = t.La()
          , r = t.MLt()
          , h = t.a6()
          , o = Date.now()
          , a = t.uHt()
          , l = Bj([["modified", o], ["system", e], ["project", n], ["version", h], ["name", i], ["uuid", s], ["project-id", r], ["ref", a]]);
        if (!jj(l))
            throw console.error("[Construct] Invalid recent project entry: ", l),
            new Error("invalid recent project entry");
        let u;
        if (u = "webfs-single-file" === e ? await Hj(a.fileHandle) : "webfs-local-folder" === e ? await Kj(a.folderHandle) : Wj(r) || Wj(s),
        u) {
            const t = Fj.indexOf(u);
            Fj.splice(t, 1)
        }
        Fj.push(l),
        Fj.sort( (t, i) => i.modified - t.modified),
        Fj.length > kj && (Fj = Fj.slice(0, kj)),
        await Xj()
    }
    async function Nj(t, i) {
        if (Pj.zt(t),
        Pj.gL(i),
        i)
            for (let e = 0, s = Fj.length; e < s; e++) {
                const s = Fj[e]
                  , n = s.ref;
                if ("cloud" === s.system && (!n || n.service === i && n.id === t)) {
                    Fj.splice(e, 1),
                    await Xj();
                    break
                }
            }
        else
            for (let i = 0, e = Fj.length; i < e; i++)
                if (Fj[i].uuid === t) {
                    Fj.splice(i, 1),
                    await Xj();
                    break
                }
    }
    function jj(t) {
        if (!Pj.Jvt(t))
            return !1;
        if (!("ref"in t))
            return !1;
        const i = t.system;
        return !!Oj.has(i) && ("cloud" === i ? $j(t.ref) : "webfs-single-file" === i ? zj(t.ref) : "webfs-local-folder" === i ? Vj(t.ref) : Pj.K9(t.ref))
    }
    function $j(t) {
        if (!Pj.Jvt(t))
            return !1;
        const i = t.service
          , e = t.name
          , s = t.id
          , n = t.parent;
        return !!(Pj.K9(i) && Pj.K9(e) && Pj.K9(s) && Pj.K9(n)) && Dj.has(i)
    }
    function zj(t) {
        return !!Pj.Jvt(t) && t.fileHandle instanceof FileSystemFileHandle
    }
    function Vj(t) {
        return !!Pj.Jvt(t) && t.folderHandle instanceof FileSystemDirectoryHandle
    }
    function Wj(t) {
        Pj.zt(t);
        for (const i of Fj)
            if (i.uuid === t)
                return i
    }
    async function Hj(t) {
        try {
            for (const i of Fj)
                if ("webfs-single-file" === i.system) {
                    const e = i.ref.fileHandle;
                    if (await t.isSameEntry(e))
                        return i
                }
            return null
        } catch (t) {
            return (() => {})("Error looking for existing recent project file: ", t),
            null
        }
    }
    async function Kj(t) {
        try {
            for (const i of Fj)
                if ("webfs-local-folder" === i.system) {
                    const e = i.ref.folderHandle;
                    if (await t.isSameEntry(e))
                        return i
                }
            return null
        } catch (t) {
            return (() => {})("Error looking for existing recent project folder: ", t),
            null
        }
    }
    async function qj() {
        try {
            await Yj()
        } catch (t) {
            (() => {})("Failed to retrieve recent project meta data: ", t),
            Fj = []
        }
    }
    async function Xj() {
        try {
            await localforage.setItem(Aj, {
                version: Rj,
                data: Fj
            })
        } catch (t) {
            (() => {})("Unable to store recent project meta data: ", t),
            await Yj()
        }
        self.app.y0("recentprojectschange")
    }
    async function Yj() {
        const t = await localforage.getItem(Aj);
        if (null === t)
            Fj = [];
        else {
            const i = t.version
              , e = t.data;
            i === Rj && (Fj = e)
        }
    }
    Lj = qj(),
    window.Hue = {
        async PF(t, i) {
            Pj.U(t, self.jw),
            Pj.zt(i),
            await Lj;
            try {
                await Uj(t, i)
            } catch (t) {
                console.error("Failed to update recent projects", t)
            }
        },
        ul: async () => (await Lj,
        Fj.slice(0)),
        async Lw(t, i) {
            Pj.zt(t),
            Pj.gL(i),
            await Lj,
            await Nj(t, i)
        },
        async Ry() {
            await Lj,
            Fj.length = 0,
            await Xj()
        },
        async mme(t) {
            if (!self.app.d0e())
                try {
                    await self.app.T0e(t)
                } catch (i) {
                    let e;
                    (() => {})("Failed to open recent project: ", i),
                    "string" == typeof i ? e = i : 404 === i.code || "ENOENT" === i.code || "path/not_found/.." === i.message || "path/not_found/." === i.message ? (await Nj(t.uuid, null),
                    e = Gj("main-menu.project-menu.open-recent-not-found")) : e = "aborted" === i.message ? Gj("main-menu.project-menu.open-recent-abort") : "webfs-single-file" === t.system || "webfs-local-folder" === t.system ? Gj("main-menu.project-menu.open-recent-webfs-error") : Gj("main-menu.project-menu.open-recent-fail");
                    Pj.Qs.Ks.qs("OK").Xa(e)
                }
        }
    }
}
{
    const Jj = self.t
      , Zj = self.Hue
      , Qj = self.lang;
    window.C3_IsPopupWindow || (self.Xue = class {
        static gLt(t, i, e) {
            return Jj.zt(t),
            Jj.zt(i),
            Jj.zt(e),
            this.e2e.qs(e).i2e(i, t).then(i => Jj.g7(t, i))
        }
        static async wnt(t, i, e, s) {
            return Jj.zt(i),
            Jj.zt(t),
            Jj.zt(e),
            Jj.zt(s),
            await Zj.Lw(t, this.Ftt),
            this.e2e.qs(e).s2e(t, s, i)
        }
        static Qje(t, i, e) {
            return Jj.zt(i),
            Jj.zt(e),
            Jj.zt(t),
            this.e2e.qs(e).Qje(t, i)
        }
        static c$e(t) {
            return Jj.zt(t),
            this.e2e.qs(t).c$e()
        }
        static async XT(t, i, e) {
            return Jj.zt(i),
            Jj.zt(t),
            Jj.zt(e),
            await Zj.Lw(t, this.Ftt),
            this.e2e.qs(e).n2e(t, i)
        }
        static i$e(t, i, e, s, n) {
            return Jj.Rti(t, Blob),
            Jj.gL(i),
            Jj.zt(s),
            Jj.zt(e),
            Jj.zt(n),
            this.e2e.qs(n).r2e(t, e, i, s)
        }
        static P0e(t) {
            return this.e2e.P0e(t)
        }
        static async MKe() {
            try {
                return await this.e2e.qs("LOCAL STORAGE").q5()
            } catch (t) {
                return console.error(t),
                !1
            }
        }
        static async mme(t) {
            t = !!t;
            const i = Jj.Qs.Ks.qs("FileList")
              , e = await i.S$e(t, !1);
            if (!e)
                return null;
            const [s,n] = e;
            try {
                return await this.e2e.qs(s).OQe(n.id, n.name, n.parent)
            } catch (t) {
                this.e2e.h2e(t, Qj("ui.errors.failed-to-open-c3-project"))
            }
        }
        static async brt(t, i) {
            Jj.U(t, self.jw),
            i = !!i;
            const e = Jj.Qs.Ks.qs("FileList")
              , s = t.STt() || t.La() + ".c3p"
              , n = await e.M$e(s, i, !1);
            if (!n)
                return null;
            let[r,h,o,a] = n;
            return this.e2e.qs(r).Zue(t, h, o, a, !1, null)
        }
        static async I0e(t) {
            Jj.J1(t);
            const i = t.ref
              , e = i.service
              , s = i.id
              , n = i.name || t.name
              , r = i.parent
              , h = this.e2e.qs(e);
            if ("GOOGLE DRIVE" != e || await h.o2e(s, r))
                return h.OQe(s, n, r);
            throw {
                code: 404,
                message: "Not Found",
                response: "Not Found",
                status: "Not Found"
            }
        }
        static async _0e(t) {
            Jj.U(t, self.jw);
            const i = t.hHt()
              , e = t.uHt();
            try {
                if ("cloud" !== i)
                    throw new Error(`${t.La()} does not originate from the cloud, and therefore cannot be quick saved`);
                const s = this.e2e.qs(e.service)
                  , n = e.id
                  , r = e.parent
                  , h = e.name;
                await s.Zue(t, h, n, r, !1, null)
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                Jj.Qs.Ks.qs("OK").Xa(Qj("ui.save-error"))
            }
        }
        static Hri(t, i, e) {
            return Jj.zt(t),
            Jj.gL(e),
            i = !!i,
            this.e2e.qs(t).Hri(i, e)
        }
    }
    )
}
{
    const t$ = self.t
      , i$ = self.app
      , e$ = self.Xue
      , s$ = self.lang
      , n$ = self.h_
      , r$ = new Set(["cloud", "webfs-single-file", "webfs-local-folder"])
      , h$ = new Set(["DROPBOX", "ONE DRIVE", "GOOGLE DRIVE", "LOCAL STORAGE"]);
    let o$ = 6e4
      , a$ = null
      , l$ = null;
    function u$() {
        t$.Qs.Ks.qs("Settings").Xa()
    }
    async function c$(t) {
        const i = [...i$.N1()].filter(i => {
            if (e$.P0e(i))
                return !1;
            const e = i.hHt();
            return !("MATCH" === t && !r$.has(e)) && (null === i.C0e() && (!!i.STt() && i.a2e()))
        }
        ).map(i => {
            let e = t;
            const s = i.hHt()
              , n = i.uHt();
            return "MATCH" === e && (e = "webfs-single-file" === s || "webfs-local-folder" === s ? "WEBFS FOLDER" : n.service),
            {
                Iw: i,
                location: e
            }
        }
        );
        if (0 === i.length)
            return;
        if (i.some(t => "WEBFS FOLDER" === t.location)) {
            if (!await d$())
                return
        }
        let e = !1;
        for (const s of i) {
            const i = s.Iw
              , n = s.location;
            if ("WEBFS FOLDER" === n) {
                await f$(i) || (e = !0)
            } else if (h$.has(n)) {
                const e = "MATCH" === t;
                await p$(i, n, e)
            }
        }
        if (e) {
            const t = t$.Qs.Ks.qs("OK");
            await t.Xa(s$("ui.local-backup-folder-messages.folder-permission-denied")),
            u$()
        }
    }
    async function d$() {
        const t = t$.Qs.Ks.qs("OK");
        if (!a$ || !t$.QL.G2)
            return await t.Xa(s$("ui.local-backup-folder-messages.folder-unavailable")),
            u$(),
            !1;
        let i = await a$.queryPermission({
            mode: "readwrite"
        });
        if ("denied" === i)
            return await t.Xa(s$("ui.local-backup-folder-messages.folder-permission-denied")),
            u$(),
            !1;
        if ("prompt" === i) {
            await t.Xa(s$("ui.local-backup-folder-messages.folder-permission-prompt")),
            t$.Qs.Tvi.lQ();
            try {
                i = await a$.requestPermission({
                    mode: "readwrite"
                })
            } catch (t) {
                (() => {})("Backup folder permission prompt failed: ", t),
                i = "declined"
            } finally {
                t$.Qs.Tvi.j0()
            }
            return "granted" === i || (await t.Xa(s$("ui.local-backup-folder-messages.folder-permission-denied")),
            u$(),
            !1)
        }
        return !0
    }
    async function f$(t) {
        const i = t.hHt()
          , e = t.STt()
          , s = t$.Uti(`${t$.qti(e).name}-${t.MLt()}.c3p`)
          , n = s$("ui.local-backup-folder-messages.location")
          , r = e$.e2e.l2e(n$("ui.cloud-save.autosaving-project-to", t.La(), n));
        try {
            if (e$.e2e.P0e(t))
                throw new Error(n$("ui.cloud-save.already-saving", t.La()));
            t.u2e({
                mode: i,
                name: e
            }),
            t.c2e(!0);
            const r = await e$.e2e.d2e(t, !0);
            return t.b0e(),
            t.c2e(!1),
            await t$.y7._vi(a$, s, r),
            t$.Qs.Notification.NT("open-folder", n, n$("ui.cloud-save.save-succeeded", s), {
                align: "bottom-left"
            }),
            !0
        } catch (t) {
            return (() => {})("Error autosaving project to local backup folder: ", t),
            !1
        } finally {
            r.he(),
            t.b0e(),
            t.c2e(!1)
        }
    }
    async function p$(t, i, e) {
        const s = t.hHt()
          , n = t.uHt()
          , r = t.STt()
          , h = t$.qti(r).name + "._autosave_.c3p"
          , o = e$.e2e.qs(i)
          , a = o.NBt()
          , l = e$.e2e.l2e(n$("ui.cloud-save.autosaving-project-to", t.La(), a));
        try {
            const i = e ? n.parent : "root"
              , a = (await o.Hri(!1, i)).filter( ({name: t}) => t === h)
              , l = 1 === a.length ? a[0].id : null
              , u = {
                mode: s,
                name: r,
                meta: n
            };
            if (o.P0e(t))
                throw new Error(n$("ui.cloud-save.already-saving", t.La()));
            await o.Zue(t, h, l, i, !0, u)
        } catch (i) {
            await e$.e2e.h2e(i, n$("ui.cloud-save.unknown-error-while-saving", t.La(), a))
        } finally {
            l.he()
        }
    }
    async function m$() {
        const t = 60 * (i$.aU().autosaveDuration || 1) * 1e3;
        t !== o$ && l$.Awi(t),
        o$ = t;
        try {
            a$ = await localforage.getItem("local-backup-folder")
        } catch (t) {
            a$ = null,
            (() => {})("Failed to load local backup folder handle: ", t)
        }
    }
    window.C3_IsPopupWindow || (l$ = t$.v(t$.fwi, async () => {
        const t = i$.aU()
          , i = t && t.autoSave
          , e = t$.Qs.Fk.fHe;
        i && !e.MHe() && (await t$.Qs.mk.kMi(),
        await c$(t.autosaveLocation))
    }
    , o$, {
        dwi: !0
    }),
    t$._f.Gf(i$, "settingschange", m$),
    t$._f.Gf(t$.sF, "afterload", m$))
}
window.f2e = function(t, i) {
    const e = new Map
      , s = new Map;
    let n = 0;
    function r(t, i, e) {
        h("reply", t, i, e)
    }
    function h(i, e, s, n) {
        n instanceof Error && (n = {
            message: n.message,
            stack: n.stack
        }),
        t({
            type: i,
            supplement: e,
            id: s,
            data: n
        })
    }
    return {
        p2e: async function(t) {
            const n = t.type
              , h = t.id
              , o = t.data;
            if ("reply" === n) {
                const i = e.get(h)
                  , s = t.supplement;
                i && ("success" === s && (i.m2e(o),
                e.delete(h)),
                "error" === s && (i.error(o),
                e.delete(h)),
                "update" === s && i.update && i.update(o))
            }
            if ("request" === n) {
                const e = t.supplement
                  , n = t => r("update", h, t)
                  , a = window.t ? window.t.Nfi : new window.Nfi;
                s.set(h, a);
                try {
                    const t = i ? await i(e, o, n, a) : null;
                    r("success", h, t)
                } catch (t) {
                    r("error", h, t)
                }
            }
            if ("cancel" === n) {
                const i = t.data
                  , e = s.get(i);
                try {
                    e && await e.Ff(),
                    r("success", h)
                } catch (t) {
                    r("error", h, t)
                }
            }
        },
        request: function(t, i, s, r) {
            return new Promise( (o, a) => {
                const l = n++;
                e.set(l, {
                    m2e: o,
                    error: a,
                    update: s
                }),
                r && r.jfi( () => {
                    h("cancel", null, n++, l)
                }
                ),
                function(t, i, e) {
                    h("request", t, i, e)
                }(t, l, i)
            }
            )
        }
    }
}
;
{
    const w$ = self.t
      , g$ = self.app
      , y$ = self.Xue
      , b$ = self.lang
      , v$ = "cloud/sandbox.html"
      , S$ = w$.v(w$.Qs.Fk.YKi)
      , x$ = new Map;
    let M$ = null
      , E$ = !1;
    function C$() {
        if (M$)
            return M$;
        const t = _$(v$, location.protocol + "//" + location.host, "allow-scripts allow-popups allow-modals allow-same-origin allow-popups-to-escape-sandbox", function(t, i) {
            if ("authenticate" === t)
                return T$(i);
            if ("sign-out" === t)
                return I$(i);
            throw new Error("Unknown request type")
        });
        return M$ = t,
        t
    }
    async function _$(t, i, e, s) {
        let n;
        const {p2e: r, request: h} = self.f2e(function(t) {
            n.Fii(t)
        }, s);
        return n = await w$.kii({
            src: t,
            Oii: i,
            Dii: t => r(t.data),
            sandbox: e
        }),
        h
    }
    async function T$(t) {
        const i = t.auth
          , e = t.redirect
          , s = t.token;
        t.service;
        w$.zt(i),
        w$.zt(e),
        w$.zt(s);
        const n = window.screenX + window.outerWidth / 2 - 240
          , r = window.screenY + window.outerHeight / 2 - 320;
        let h = await w$.Qs.zxi.hMi(i, {
            features: `width=480,height=640,left=${n},top=${r},menubar=no,toolbar=no,location=no,personalbar=no,status=no,dependent=yes,dialog=yes,resizable=yes,scrollbars=no`,
            name: "Cloud Auth"
        });
        if (!h)
            throw b$("ui.dialogs.fileList.popupBlocked");
        h = h.window;
        const o = b$("ui.cloud-save.awaiting-authentication")
          , a = w$.v(w$.Qs.Fk.dqi, S$, o);
        a.lQ();
        const l = w$.Qs.Ks.qs("FileList");
        return l.XO() && l.Zje(o),
        new Promise( (t, i) => {
            const e = async () => {
                let n;
                try {
                    const r = await localforage.getItem("auth_" + s);
                    if (r) {
                        try {
                            await localforage.removeItem("auth_" + s)
                        } catch (t) {}
                        n = r,
                        a.he(),
                        t(n)
                    } else {
                        let t = !1;
                        try {
                            h.closed && (t = !0)
                        } catch (t) {}
                        n || (t ? (a.he(),
                        i(b$("ui.dialogs.fileList.userAuthenticationCancelled"))) : setTimeout(e, 50))
                    }
                } catch (t) {}
            }
            ;
            e()
        }
        )
    }
    async function I$(t) {
        const i = t.url;
        w$.zt(i);
        const e = window.screenX + window.outerWidth / 2 - 240
          , s = window.screenY + window.outerHeight / 2 - 320;
        if (!await w$.Qs.zxi.hMi(i, {
            features: `width=480,height=640,left=${e},top=${s},menubar=no,toolbar=no,location=no,personalbar=no,status=no,dependent=yes,dialog=yes,resizable=yes,scrollbars=no`,
            name: "Cloud Auth Signout"
        }))
            throw b$("ui.dialogs.fileList.popupBlocked")
    }
    if (!window.C3_IsPopupWindow) {
        function P$() {
            const t = g$.aU();
            E$ = t.cloudCache || !1
        }
        w$._f.Gf(g$, "settingschange", P$),
        w$._f.Gf(w$.sF, "afterload", P$),
        y$.w2e = class {
            constructor(t) {
                this.Ftt = t,
                this.g2e = new Map,
                this.y2e = null
            }
            b2e(t) {
                if (!E$)
                    return null;
                const i = this.g2e.get(t)
                  , e = i && i.children;
                return e || null
            }
            v2e(t) {
                this.g2e.get(t)
            }
            S2e(t) {
                t.detached = !0,
                this.g2e.set(t.id, t)
            }
            x2e(t) {
                if ("folder" === t.type) {
                    const i = this.g2e.get(t.id);
                    if (i && !0 === i.stub) {
                        const e = i.children;
                        null !== e && (t.children = e)
                    }
                }
                this.g2e.set(t.id, t)
            }
            async M2e(t, i) {
                if (w$.U(i, Promise),
                w$.zt(t),
                !E$)
                    return await i;
                let e = this.g2e.get(t);
                e || ("root" != t && (() => {})("Non root caching call"),
                e = {
                    type: "folder",
                    id: t,
                    name: "",
                    children: null,
                    date: "",
                    size: 0,
                    parent: null,
                    detached: !0
                },
                this.g2e.set(t, e)),
                e.children = i,
                this.g2e.set(t, e);
                try {
                    const t = await i;
                    e.children = t;
                    for (const i of t)
                        this.x2e(i);
                    return t
                } catch (t) {
                    throw e.children = null,
                    t
                }
            }
            E2e() {
                return E$ ? this.y2e : null
            }
            C2e(t) {
                return w$.zt(t),
                this.y2e = E$ ? t : null,
                t
            }
            async _2e(t) {
                let i = null;
                try {
                    i = await t.children
                } catch (i) {
                    (() => {})("Unable to resolve entry list for " + t.id)
                }
                return i
            }
            async T2e(t, i, ...e) {
                w$.zt(t),
                w$.ML(i);
                let {RPe: s, cancel: n} = i || {};
                w$.tot(s),
                w$.Ef(n, w$.Nfi);
                const r = {
                    method: t,
                    data: e
                };
                return (await C$())(this.Ftt, r, s, n)
            }
            async I2e(t, i, e) {
                await this.P2e(t, i),
                await this.G2e(e)
            }
            async P2e(t, i) {
                if (E$) {
                    const e = this.g2e.get(t);
                    if (e) {
                        const t = await this._2e(e);
                        if (t) {
                            const e = t.length;
                            let s = -1;
                            for (let n = 0; n < e; n++) {
                                t[n].id === i && (s = n)
                            }
                            s > -1 && t.splice(s, 1)
                        }
                    }
                    this.g2e.delete(i)
                }
            }
            async G2e(t) {
                if (E$) {
                    const i = this.g2e.get(t.parent);
                    if (i) {
                        const e = await this._2e(i);
                        e && (e.push(t),
                        i.children = this.h$e(e))
                    }
                    if ("folder" === t.type) {
                        const i = this.g2e.get(t.id);
                        if (i && !0 === i.detached) {
                            const e = i.children;
                            null !== e && (t.children = e)
                        }
                    }
                    this.g2e.set(t.id, t)
                }
            }
            h$e(t) {
                return t.sort( (t, i) => t.type === i.type ? t.name === i.name ? 0 : t.name.toLowerCase() > i.name.toLowerCase() ? 1 : -1 : "file" === t.type ? 1 : -1)
            }
            async A2e(t) {
                const i = await this.T2e("getFiles", null, t);
                return this.h$e(i)
            }
            async o2e(t, i) {
                if (w$.zt(t),
                w$.zt(i),
                "GOOGLE DRIVE" != this.Ftt)
                    throw new Error("Method not implemented");
                if (E$ && this.g2e.has(t))
                    return !0;
                const e = await this.T2e("getMeta", null, t);
                return e && 0 == e.trashed
            }
            q5() {
                if ("LOCAL STORAGE" != this.Ftt)
                    throw new Error("Method not implemented");
                return this.T2e("isEmpty")
            }
            async Hri(t, i) {
                if (w$.zt(i),
                !t) {
                    const t = this.b2e(i);
                    if (t)
                        return t
                }
                const e = this.A2e(i);
                return this.M2e(i, e)
            }
            async nhi(t, i, e) {
                return w$.zt(t),
                w$.tot(i),
                w$.Ef(e, w$.Nfi),
                await this.T2e("getFile", {
                    RPe: i,
                    cancel: e
                }, t)
            }
            async R2e() {
                const t = this.E2e();
                if (t)
                    return t;
                const i = await this.T2e("getID");
                return this.C2e(i)
            }
            async r2e(t, i, e, s, n) {
                w$.zt(t),
                w$.zt(e),
                w$.U(i, Blob);
                const r = await this.T2e("uploadFile", {
                    RPe: s,
                    cancel: n
                }, t, e, i);
                return await this.G2e(r),
                r
            }
            async Mct(t, i) {
                w$.zt(t),
                w$.zt(i);
                const e = await this.T2e("createFile", null, t, i);
                return await this.G2e(e),
                e
            }
            async Qje(t, i) {
                w$.zt(t),
                w$.zt(i);
                const e = await this.T2e("createFolder", null, t, i);
                return await this.G2e(e),
                e
            }
            async k2e(t, i, e, s, n) {
                w$.zt(t),
                w$.U(i, Blob),
                w$.zt(e),
                w$.tot(s),
                w$.U(n, w$.Nfi);
                const r = await this.T2e("updateFile", {
                    RPe: s,
                    cancel: n
                }, t, i, e);
                return await this.I2e(e, t, r),
                r
            }
            async s2e(t, i, e) {
                w$.zt(t),
                w$.zt(i),
                w$.zt(e);
                const s = await this.T2e("renameFile", null, t, i, e);
                return await this.I2e(e, t, s),
                s
            }
            async n2e(t, i) {
                w$.zt(t),
                w$.zt(i),
                await this.T2e("deleteFile", null, t),
                await this.P2e(i, t)
            }
            async c$e() {
                const t = await this.T2e("logout");
                return this.g2e.clear(),
                this.y2e = null,
                t
            }
            static O2e(t) {
                w$.zt(t);
                let i = x$.get(t);
                return i || (i = w$.v(y$.w2e, t),
                x$.set(t, i)),
                i
            }
        }
    }
}
{
    const G$ = self.t
      , A$ = self.app
      , R$ = self.Xue
      , k$ = self.h_
      , O$ = new WeakSet
      , D$ = new Map;
    let F$ = 0;
    if (!window.C3_IsPopupWindow) {
        const L$ = G$.v(G$.Qs.Fk.YKi);
        R$.e2e = class t {
            constructor(t) {
                switch (G$.zt(t),
                this.Ftt = t,
                this.y2e = null,
                this.Fje = R$.w2e.O2e(this.Ftt),
                this.G4 = null,
                this.D2e = new WeakSet,
                this.Ftt) {
                case "GOOGLE DRIVE":
                    this.G4 = "google-drive";
                    break;
                case "ONE DRIVE":
                    this.G4 = "onedrive";
                    break;
                case "DROPBOX":
                    this.G4 = "dropbox";
                    break;
                case "LOCAL STORAGE":
                    this.G4 = "open-folder"
                }
            }
            NBt() {
                return G$.Zoi(this.Ftt)
            }
            async F2e() {
                const t = await this.Fje.R2e();
                return this.y2e = t,
                this.y2e
            }
            L2e(t) {
                G$.U(t, self.jw),
                F$++,
                this.D2e.add(t)
            }
            B2e(t) {
                G$.U(t, self.jw),
                F$--,
                this.D2e.delete(t)
            }
            P0e(t) {
                return this.D2e.has(t)
            }
            q5() {
                return this.Fje.q5()
            }
            async i2e(i, e, s) {
                G$.zt(i),
                G$.zt(e),
                s = !!s;
                const n = k$("ui.cloud-save.downloading", this.NBt(), e);
                if (s) {
                    const t = G$.v(G$.Nfi);
                    let e = 0
                      , s = G$.Qs.Ks.qs("Progress");
                    s.onprogress = () => e,
                    s.Xa(n, null, () => t.Ff());
                    try {
                        return await this.Fje.nhi(i, t => e = t, t)
                    } finally {
                        s.sW()
                    }
                } else {
                    const e = t.U2e(n + " {0}%");
                    try {
                        return await this.Fje.nhi(i, t => e.uqi(t))
                    } finally {
                        e.he()
                    }
                }
            }
            s2e(t, i, e) {
                return G$.zt(t),
                G$.zt(i),
                G$.zt(e),
                this.Fje.s2e(t, i, e)
            }
            n2e(t, i) {
                return G$.zt(t),
                G$.zt(i),
                this.Fje.n2e(t, i)
            }
            Qje(t, i) {
                return G$.zt(t),
                G$.zt(i),
                this.Fje.Qje(t, i)
            }
            async r2e(i, e, s, n) {
                G$.Rti(i, Blob),
                G$.zt(e),
                G$.gL(s),
                G$.zt(n);
                const r = this.NBt()
                  , h = t.U2e(k$("ui.cloud-save.uploading", r, e) + " {0}%")
                  , o = t => h.uqi(t)
                  , a = G$.v(G$.Nfi);
                try {
                    s ? await this.Fje.k2e(s, i, n, o, a) : await this.Fje.r2e(e, i, n, o, a),
                    G$.Qs.Notification.NT(this.G4, r, k$("ui.cloud-save.upload-succeeded", e), {
                        align: "bottom-left"
                    })
                } catch (i) {
                    await t.h2e(i, k$("ui.cloud-save.unknown-error-while-saving", e, r))
                } finally {
                    h.he()
                }
            }
            async Zue(i, e, s, n, r, h) {
                if (G$.U(i, self.jw),
                G$.zt(e),
                G$.gL(s),
                G$.zt(n),
                G$.kQ(h),
                r = !!r,
                this.P0e(i))
                    return t.h2e(new Error(k$("ui.cloud-save.already-saving", e)));
                this.L2e(i);
                const o = G$.Zoi(this.Ftt)
                  , a = t.U2e(k$("ui.cloud-save.saving-project-to", e, this.NBt()) + " {0}%")
                  , l = t => a.uqi(t)
                  , u = G$.v(G$.Nfi);
                try {
                    h ? (i.u2e(h),
                    i.c2e(!0)) : (i.b0e(),
                    i.c2e(!1));
                    const a = await t.d2e(i, r);
                    if (i.b0e(),
                    i.c2e(!1),
                    s)
                        await this.Fje.k2e(s, a, n, l, u);
                    else {
                        s = (await this.Fje.r2e(e, a, n, l, u)).id
                    }
                    r || (i.OZe(e),
                    await i.DZe("cloud", {
                        parent: n,
                        service: this.Ftt,
                        name: e,
                        id: s
                    })),
                    A$.XGi("SaveProjectMethod", "LOCAL STORAGE" === this.Ftt ? "browser-storage" : "cloud"),
                    G$.Qs.Notification.NT(this.G4, o, k$("ui.cloud-save.save-succeeded", e), {
                        align: "bottom-left"
                    })
                } catch (i) {
                    await t.h2e(i, k$("ui.cloud-save.unknown-error-while-saving", e, o))
                } finally {
                    a.he(),
                    i.b0e(),
                    i.c2e(!1),
                    this.B2e(i)
                }
            }
            o2e(t, i) {
                return G$.zt(t),
                G$.zt(i),
                this.Fje.o2e(t, i)
            }
            async OQe(i, e, s) {
                G$.zt(e),
                G$.zt(i),
                G$.zt(s);
                const n = ".capx" === G$.l7(e).toLowerCase()
                  , r = [...A$.N1()].filter(t => "cloud" === t.hHt()).map(t => t.uHt()).filter(t => t.service === this.Ftt && t.id === i);
                if (r[0])
                    return t.h2e(new Error(k$("ui.cloud-save.already-open", e)));
                const h = await this.i2e(i, e, !0)
                  , o = {
                    ett: "LOCAL STORAGE" === this.Ftt ? "browser-storage" : "cloud"
                };
                let a = null;
                a = n ? await A$.itt(h, o) : await A$.stt(h, o),
                G$.Bm(a, self.jw) && (n ? a.OZe(e.slice(0, -4) + "c3p") : (a.OZe(e),
                await a.DZe("cloud", {
                    parent: s,
                    service: this.Ftt,
                    name: e,
                    id: i
                })))
            }
            Hri(t, i) {
                return G$.zt(i),
                t = !!t,
                this.Fje.Hri(t, i)
            }
            c$e() {
                return this.Fje.c$e()
            }
            static async d2e(t, i) {
                if (G$.U(t, self.jw),
                i = !!i,
                O$.has(t))
                    throw new Error(self.lang("ui.cloud-save.already-archiving"));
                O$.add(t);
                const e = this.l2e(k$("ui.cloud-save.archiving-project", t.La()));
                try {
                    const e = await A$.f0e(t, !0);
                    return i || t.w0e(),
                    e
                } finally {
                    e.he(),
                    O$.delete(t)
                }
            }
            static P0e(t) {
                if (t) {
                    for (const i of D$.values())
                        if (i.P0e(t))
                            return !0;
                    return !1
                }
                return F$ > 0
            }
            static qs(i) {
                G$.zt(i);
                let e = D$.get(i);
                return e || (e = t.hP(i)),
                e
            }
            static hP(i) {
                if (G$.zt(i),
                D$.has(i))
                    throw new Error(`Interface "${i}" already exists`);
                const e = G$.v(t, i);
                return D$.set(i, e),
                e
            }
            static l2e(t) {
                G$.zt(t);
                const i = G$.v(G$.Qs.Fk.dqi, L$, t);
                return i.lQ(),
                i
            }
            static h2e(t, i) {
                console.error("Error saving: ", t);
                let e = t.message;
                return e || (e = i),
                G$.zt(e),
                G$.Qs.Ks.qs("OK").Xa(e, document.body)
            }
            static U2e(t) {
                G$.zt(t);
                const i = G$.v(G$.Qs.Fk.aqi, L$, t);
                return i.uqi(0),
                i
            }
        }
    }
}
