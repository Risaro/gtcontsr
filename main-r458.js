{
    var t = 1e-6
      , i = "undefined" != typeof Float32Array ? Float32Array : Array
      , e = Math.random;
    function Tt(t) {
        i = t
    }
    var s = Math.PI / 180;
    function It(t) {
        return t * s
    }
    function Pt(i, e) {
        return Math.abs(i - e) <= t * Math.max(1, Math.abs(i), Math.abs(e))
    }
    Math.hypot || (Math.hypot = function() {
        for (var t = 0, i = arguments.length; i--; )
            t += arguments[i] * arguments[i];
        return Math.sqrt(t)
    }
    );
    var n = {
        __proto__: null,
        EPSILON: t,
        get tMe() {
            return i
        },
        iMe: e,
        eMe: "zyx",
        sMe: Tt,
        nMe: It,
        equals: Pt
    };
    function Gt() {
        var t = new i(4);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0),
        t[0] = 1,
        t[3] = 1,
        t
    }
    function At(t) {
        var e = new i(4);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e
    }
    function Rt(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t
    }
    function kt(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t
    }
    function Ot(t, e, s, n) {
        var r = new i(4);
        return r[0] = t,
        r[1] = e,
        r[2] = s,
        r[3] = n,
        r
    }
    function Dt(t, i, e, s, n) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t
    }
    function Ft(t, i) {
        if (t === i) {
            var e = i[1];
            t[1] = i[2],
            t[2] = e
        } else
            t[0] = i[0],
            t[1] = i[2],
            t[2] = i[1],
            t[3] = i[3];
        return t
    }
    function Lt(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e * r - n * s;
        return h ? (h = 1 / h,
        t[0] = r * h,
        t[1] = -s * h,
        t[2] = -n * h,
        t[3] = e * h,
        t) : null
    }
    function Bt(t, i) {
        var e = i[0];
        return t[0] = i[3],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = e,
        t
    }
    function Ut(t) {
        return t[0] * t[3] - t[2] * t[1]
    }
    function Nt(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return t[0] = s * o + r * a,
        t[1] = n * o + h * a,
        t[2] = s * l + r * u,
        t[3] = n * l + h * u,
        t
    }
    function jt(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a + r * o,
        t[1] = n * a + h * o,
        t[2] = s * -o + r * a,
        t[3] = n * -o + h * a,
        t
    }
    function $t(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1];
        return t[0] = s * o,
        t[1] = n * o,
        t[2] = r * a,
        t[3] = h * a,
        t
    }
    function zt(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = -e,
        t[3] = s,
        t
    }
    function Vt(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = i[1],
        t
    }
    function Wt(t) {
        return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }
    function Ht(t) {
        return Math.hypot(t[0], t[1], t[2], t[3])
    }
    function Kt(t, i, e, s) {
        return t[2] = s[2] / s[0],
        e[0] = s[0],
        e[1] = s[1],
        e[3] = s[3] - t[2] * e[1],
        [t, i, e]
    }
    function qt(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t
    }
    function Xt(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t
    }
    function Yt(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3]
    }
    function Jt(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return Math.abs(s - o) <= t * Math.max(1, Math.abs(s), Math.abs(o)) && Math.abs(n - a) <= t * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - l) <= t * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(h - u) <= t * Math.max(1, Math.abs(h), Math.abs(u))
    }
    function Zt(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t
    }
    function Qt(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t
    }
    var r = Nt
      , h = Xt
      , o = Object.freeze({
        __proto__: null,
        create: Gt,
        clone: At,
        ia: Rt,
        identity: kt,
        rMe: Ot,
        set: Dt,
        hMe: Ft,
        oMe: Lt,
        aMe: Bt,
        lMe: Ut,
        multiply: Nt,
        rotate: jt,
        scale: $t,
        uMe: zt,
        cMe: Vt,
        dMe: Wt,
        fMe: Ht,
        pMe: Kt,
        add: qt,
        mMe: Xt,
        wMe: Yt,
        equals: Jt,
        gMe: Zt,
        yMe: Qt,
        mul: r,
        sub: h
    });
    function ti() {
        var t = new i(6);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0,
        t[4] = 0,
        t[5] = 0),
        t[0] = 1,
        t[3] = 1,
        t
    }
    function ii(t) {
        var e = new i(6);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e
    }
    function ei(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t
    }
    function si(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = 0,
        t[5] = 0,
        t
    }
    function ni(t, e, s, n, r, h) {
        var o = new i(6);
        return o[0] = t,
        o[1] = e,
        o[2] = s,
        o[3] = n,
        o[4] = r,
        o[5] = h,
        o
    }
    function ri(t, i, e, s, n, r, h) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t
    }
    function hi(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = e * r - s * n;
        return a ? (a = 1 / a,
        t[0] = r * a,
        t[1] = -s * a,
        t[2] = -n * a,
        t[3] = e * a,
        t[4] = (n * o - r * h) * a,
        t[5] = (s * h - e * o) * a,
        t) : null
    }
    function oi(t) {
        return t[0] * t[3] - t[1] * t[2]
    }
    function ai(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1]
          , c = e[2]
          , d = e[3]
          , f = e[4]
          , p = e[5];
        return t[0] = s * l + r * u,
        t[1] = n * l + h * u,
        t[2] = s * c + r * d,
        t[3] = n * c + h * d,
        t[4] = s * f + r * p + o,
        t[5] = n * f + h * p + a,
        t
    }
    function li(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = Math.sin(e)
          , u = Math.cos(e);
        return t[0] = s * u + r * l,
        t[1] = n * u + h * l,
        t[2] = s * -l + r * u,
        t[3] = n * -l + h * u,
        t[4] = o,
        t[5] = a,
        t
    }
    function ui(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1];
        return t[0] = s * l,
        t[1] = n * l,
        t[2] = r * u,
        t[3] = h * u,
        t[4] = o,
        t[5] = a,
        t
    }
    function ci(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1];
        return t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = s * l + r * u + o,
        t[5] = n * l + h * u + a,
        t
    }
    function di(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = -e,
        t[3] = s,
        t[4] = 0,
        t[5] = 0,
        t
    }
    function fi(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = i[1],
        t[4] = 0,
        t[5] = 0,
        t
    }
    function pi(t, i) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = i[0],
        t[5] = i[1],
        t
    }
    function mi(t) {
        return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
    }
    function wi(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1)
    }
    function gi(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t
    }
    function yi(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t[4] = i[4] - e[4],
        t[5] = i[5] - e[5],
        t
    }
    function bi(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t
    }
    function vi(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t[4] = i[4] + e[4] * s,
        t[5] = i[5] + e[5] * s,
        t
    }
    function Si(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5]
    }
    function xi(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = e[0]
          , u = e[1]
          , c = e[2]
          , d = e[3]
          , f = e[4]
          , p = e[5];
        return Math.abs(s - l) <= t * Math.max(1, Math.abs(s), Math.abs(l)) && Math.abs(n - u) <= t * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(r - c) <= t * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(h - d) <= t * Math.max(1, Math.abs(h), Math.abs(d)) && Math.abs(o - f) <= t * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(a - p) <= t * Math.max(1, Math.abs(a), Math.abs(p))
    }
    var a = ai
      , l = yi
      , u = Object.freeze({
        __proto__: null,
        create: ti,
        clone: ii,
        ia: ei,
        identity: si,
        rMe: ni,
        set: ri,
        oMe: hi,
        lMe: oi,
        multiply: ai,
        rotate: li,
        scale: ui,
        translate: ci,
        uMe: di,
        cMe: fi,
        bMe: pi,
        dMe: mi,
        fMe: wi,
        add: gi,
        mMe: yi,
        gMe: bi,
        yMe: vi,
        wMe: Si,
        equals: xi,
        mul: a,
        sub: l
    });
    function Mi() {
        var t = new i(9);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0),
        t[0] = 1,
        t[4] = 1,
        t[8] = 1,
        t
    }
    function Ei(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[4],
        t[4] = i[5],
        t[5] = i[6],
        t[6] = i[8],
        t[7] = i[9],
        t[8] = i[10],
        t
    }
    function Ci(t) {
        var e = new i(9);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        e
    }
    function _i(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t
    }
    function Ti(t, e, s, n, r, h, o, a, l) {
        var u = new i(9);
        return u[0] = t,
        u[1] = e,
        u[2] = s,
        u[3] = n,
        u[4] = r,
        u[5] = h,
        u[6] = o,
        u[7] = a,
        u[8] = l,
        u
    }
    function Ii(t, i, e, s, n, r, h, o, a, l) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t[6] = o,
        t[7] = a,
        t[8] = l,
        t
    }
    function Pi(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 1,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 1,
        t
    }
    function Gi(t, i) {
        if (t === i) {
            var e = i[1]
              , s = i[2]
              , n = i[5];
            t[1] = i[3],
            t[2] = i[6],
            t[3] = e,
            t[5] = i[7],
            t[6] = s,
            t[7] = n
        } else
            t[0] = i[0],
            t[1] = i[3],
            t[2] = i[6],
            t[3] = i[1],
            t[4] = i[4],
            t[5] = i[7],
            t[6] = i[2],
            t[7] = i[5],
            t[8] = i[8];
        return t
    }
    function Ai(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = u * h - o * l
          , d = -u * r + o * a
          , f = l * r - h * a
          , p = e * c + s * d + n * f;
        return p ? (p = 1 / p,
        t[0] = c * p,
        t[1] = (-u * s + n * l) * p,
        t[2] = (o * s - n * h) * p,
        t[3] = d * p,
        t[4] = (u * e - n * a) * p,
        t[5] = (-o * e + n * r) * p,
        t[6] = f * p,
        t[7] = (-l * e + s * a) * p,
        t[8] = (h * e - s * r) * p,
        t) : null
    }
    function Ri(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8];
        return t[0] = h * u - o * l,
        t[1] = n * l - s * u,
        t[2] = s * o - n * h,
        t[3] = o * a - r * u,
        t[4] = e * u - n * a,
        t[5] = n * r - e * o,
        t[6] = r * l - h * a,
        t[7] = s * a - e * l,
        t[8] = e * h - s * r,
        t
    }
    function ki(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3]
          , r = t[4]
          , h = t[5]
          , o = t[6]
          , a = t[7]
          , l = t[8];
        return i * (l * r - h * a) + e * (-l * n + h * o) + s * (a * n - r * o)
    }
    function Oi(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = e[0]
          , f = e[1]
          , p = e[2]
          , m = e[3]
          , w = e[4]
          , g = e[5]
          , y = e[6]
          , b = e[7]
          , v = e[8];
        return t[0] = d * s + f * h + p * l,
        t[1] = d * n + f * o + p * u,
        t[2] = d * r + f * a + p * c,
        t[3] = m * s + w * h + g * l,
        t[4] = m * n + w * o + g * u,
        t[5] = m * r + w * a + g * c,
        t[6] = y * s + b * h + v * l,
        t[7] = y * n + b * o + v * u,
        t[8] = y * r + b * a + v * c,
        t
    }
    function Di(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = e[0]
          , f = e[1];
        return t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = o,
        t[5] = a,
        t[6] = d * s + f * h + l,
        t[7] = d * n + f * o + u,
        t[8] = d * r + f * a + c,
        t
    }
    function Fi(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = Math.sin(e)
          , f = Math.cos(e);
        return t[0] = f * s + d * h,
        t[1] = f * n + d * o,
        t[2] = f * r + d * a,
        t[3] = f * h - d * s,
        t[4] = f * o - d * n,
        t[5] = f * a - d * r,
        t[6] = l,
        t[7] = u,
        t[8] = c,
        t
    }
    function Li(t, i, e) {
        var s = e[0]
          , n = e[1];
        return t[0] = s * i[0],
        t[1] = s * i[1],
        t[2] = s * i[2],
        t[3] = n * i[3],
        t[4] = n * i[4],
        t[5] = n * i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t
    }
    function Bi(t, i) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 1,
        t[5] = 0,
        t[6] = i[0],
        t[7] = i[1],
        t[8] = 1,
        t
    }
    function Ui(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = 0,
        t[3] = -e,
        t[4] = s,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 1,
        t
    }
    function Ni(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = i[1],
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 1,
        t
    }
    function ji(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = 0,
        t[3] = i[2],
        t[4] = i[3],
        t[5] = 0,
        t[6] = i[4],
        t[7] = i[5],
        t[8] = 1,
        t
    }
    function $i(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e + e
          , o = s + s
          , a = n + n
          , l = e * h
          , u = s * h
          , c = s * o
          , d = n * h
          , f = n * o
          , p = n * a
          , m = r * h
          , w = r * o
          , g = r * a;
        return t[0] = 1 - c - p,
        t[3] = u - g,
        t[6] = d + w,
        t[1] = u + g,
        t[4] = 1 - l - p,
        t[7] = f - m,
        t[2] = d - w,
        t[5] = f + m,
        t[8] = 1 - l - c,
        t
    }
    function zi(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = i[9]
          , d = i[10]
          , f = i[11]
          , p = i[12]
          , m = i[13]
          , w = i[14]
          , g = i[15]
          , y = e * o - s * h
          , b = e * a - n * h
          , v = e * l - r * h
          , S = s * a - n * o
          , x = s * l - r * o
          , M = n * l - r * a
          , E = u * m - c * p
          , C = u * w - d * p
          , _ = u * g - f * p
          , T = c * w - d * m
          , I = c * g - f * m
          , P = d * g - f * w
          , G = y * P - b * I + v * T + S * _ - x * C + M * E;
        return G ? (G = 1 / G,
        t[0] = (o * P - a * I + l * T) * G,
        t[1] = (a * _ - h * P - l * C) * G,
        t[2] = (h * I - o * _ + l * E) * G,
        t[3] = (n * I - s * P - r * T) * G,
        t[4] = (e * P - n * _ + r * C) * G,
        t[5] = (s * _ - e * I - r * E) * G,
        t[6] = (m * M - w * x + g * S) * G,
        t[7] = (w * v - p * M - g * b) * G,
        t[8] = (p * x - m * v + g * y) * G,
        t) : null
    }
    function Vi(t, i, e) {
        return t[0] = 2 / i,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = -2 / e,
        t[5] = 0,
        t[6] = -1,
        t[7] = 1,
        t[8] = 1,
        t
    }
    function Wi(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
    }
    function Hi(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8])
    }
    function Ki(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t[6] = i[6] + e[6],
        t[7] = i[7] + e[7],
        t[8] = i[8] + e[8],
        t
    }
    function qi(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t[4] = i[4] - e[4],
        t[5] = i[5] - e[5],
        t[6] = i[6] - e[6],
        t[7] = i[7] - e[7],
        t[8] = i[8] - e[8],
        t
    }
    function Xi(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t[6] = i[6] * e,
        t[7] = i[7] * e,
        t[8] = i[8] * e,
        t
    }
    function Yi(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t[4] = i[4] + e[4] * s,
        t[5] = i[5] + e[5] * s,
        t[6] = i[6] + e[6] * s,
        t[7] = i[7] + e[7] * s,
        t[8] = i[8] + e[8] * s,
        t
    }
    function Ji(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5] && t[6] === i[6] && t[7] === i[7] && t[8] === i[8]
    }
    function Zi(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = e[0]
          , f = e[1]
          , p = e[2]
          , m = e[3]
          , w = e[4]
          , g = e[5]
          , y = e[6]
          , b = e[7]
          , v = e[8];
        return Math.abs(s - d) <= t * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(n - f) <= t * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(r - p) <= t * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(h - m) <= t * Math.max(1, Math.abs(h), Math.abs(m)) && Math.abs(o - w) <= t * Math.max(1, Math.abs(o), Math.abs(w)) && Math.abs(a - g) <= t * Math.max(1, Math.abs(a), Math.abs(g)) && Math.abs(l - y) <= t * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - b) <= t * Math.max(1, Math.abs(u), Math.abs(b)) && Math.abs(c - v) <= t * Math.max(1, Math.abs(c), Math.abs(v))
    }
    var c = Oi
      , d = qi
      , f = Object.freeze({
        __proto__: null,
        create: Mi,
        vMe: Ei,
        clone: Ci,
        ia: _i,
        rMe: Ti,
        set: Ii,
        identity: Pi,
        hMe: Gi,
        oMe: Ai,
        aMe: Ri,
        lMe: ki,
        multiply: Oi,
        translate: Di,
        rotate: Fi,
        scale: Li,
        bMe: Bi,
        uMe: Ui,
        cMe: Ni,
        SMe: ji,
        xMe: $i,
        MMe: zi,
        EMe: Vi,
        dMe: Wi,
        fMe: Hi,
        add: Ki,
        mMe: qi,
        gMe: Xi,
        yMe: Yi,
        wMe: Ji,
        equals: Zi,
        mul: c,
        sub: d
    });
    function Qi() {
        var t = new i(16);
        return i != Float32Array && (t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0),
        t[0] = 1,
        t[5] = 1,
        t[10] = 1,
        t[15] = 1,
        t
    }
    function te(t) {
        var e = new i(16);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e[8] = t[8],
        e[9] = t[9],
        e[10] = t[10],
        e[11] = t[11],
        e[12] = t[12],
        e[13] = t[13],
        e[14] = t[14],
        e[15] = t[15],
        e
    }
    function ie(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        t
    }
    function ee(t, e, s, n, r, h, o, a, l, u, c, d, f, p, m, w) {
        var g = new i(16);
        return g[0] = t,
        g[1] = e,
        g[2] = s,
        g[3] = n,
        g[4] = r,
        g[5] = h,
        g[6] = o,
        g[7] = a,
        g[8] = l,
        g[9] = u,
        g[10] = c,
        g[11] = d,
        g[12] = f,
        g[13] = p,
        g[14] = m,
        g[15] = w,
        g
    }
    function se(t, i, e, s, n, r, h, o, a, l, u, c, d, f, p, m, w) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t[6] = o,
        t[7] = a,
        t[8] = l,
        t[9] = u,
        t[10] = c,
        t[11] = d,
        t[12] = f,
        t[13] = p,
        t[14] = m,
        t[15] = w,
        t
    }
    function ne(t) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = 1,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 1,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function re(t, i) {
        if (t === i) {
            var e = i[1]
              , s = i[2]
              , n = i[3]
              , r = i[6]
              , h = i[7]
              , o = i[11];
            t[1] = i[4],
            t[2] = i[8],
            t[3] = i[12],
            t[4] = e,
            t[6] = i[9],
            t[7] = i[13],
            t[8] = s,
            t[9] = r,
            t[11] = i[14],
            t[12] = n,
            t[13] = h,
            t[14] = o
        } else
            t[0] = i[0],
            t[1] = i[4],
            t[2] = i[8],
            t[3] = i[12],
            t[4] = i[1],
            t[5] = i[5],
            t[6] = i[9],
            t[7] = i[13],
            t[8] = i[2],
            t[9] = i[6],
            t[10] = i[10],
            t[11] = i[14],
            t[12] = i[3],
            t[13] = i[7],
            t[14] = i[11],
            t[15] = i[15];
        return t
    }
    function he(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = i[9]
          , d = i[10]
          , f = i[11]
          , p = i[12]
          , m = i[13]
          , w = i[14]
          , g = i[15]
          , y = e * o - s * h
          , b = e * a - n * h
          , v = e * l - r * h
          , S = s * a - n * o
          , x = s * l - r * o
          , M = n * l - r * a
          , E = u * m - c * p
          , C = u * w - d * p
          , _ = u * g - f * p
          , T = c * w - d * m
          , I = c * g - f * m
          , P = d * g - f * w
          , G = y * P - b * I + v * T + S * _ - x * C + M * E;
        return G ? (G = 1 / G,
        t[0] = (o * P - a * I + l * T) * G,
        t[1] = (n * I - s * P - r * T) * G,
        t[2] = (m * M - w * x + g * S) * G,
        t[3] = (d * x - c * M - f * S) * G,
        t[4] = (a * _ - h * P - l * C) * G,
        t[5] = (e * P - n * _ + r * C) * G,
        t[6] = (w * v - p * M - g * b) * G,
        t[7] = (u * M - d * v + f * b) * G,
        t[8] = (h * I - o * _ + l * E) * G,
        t[9] = (s * _ - e * I - r * E) * G,
        t[10] = (p * x - m * v + g * y) * G,
        t[11] = (c * v - u * x - f * y) * G,
        t[12] = (o * C - h * T - a * E) * G,
        t[13] = (e * T - s * C + n * E) * G,
        t[14] = (m * b - p * S - w * y) * G,
        t[15] = (u * S - c * b + d * y) * G,
        t) : null
    }
    function oe(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = i[4]
          , o = i[5]
          , a = i[6]
          , l = i[7]
          , u = i[8]
          , c = i[9]
          , d = i[10]
          , f = i[11]
          , p = i[12]
          , m = i[13]
          , w = i[14]
          , g = i[15]
          , y = e * o - s * h
          , b = e * a - n * h
          , v = e * l - r * h
          , S = s * a - n * o
          , x = s * l - r * o
          , M = n * l - r * a
          , E = u * m - c * p
          , C = u * w - d * p
          , _ = u * g - f * p
          , T = c * w - d * m
          , I = c * g - f * m
          , P = d * g - f * w;
        return t[0] = o * P - a * I + l * T,
        t[1] = n * I - s * P - r * T,
        t[2] = m * M - w * x + g * S,
        t[3] = d * x - c * M - f * S,
        t[4] = a * _ - h * P - l * C,
        t[5] = e * P - n * _ + r * C,
        t[6] = w * v - p * M - g * b,
        t[7] = u * M - d * v + f * b,
        t[8] = h * I - o * _ + l * E,
        t[9] = s * _ - e * I - r * E,
        t[10] = p * x - m * v + g * y,
        t[11] = c * v - u * x - f * y,
        t[12] = o * C - h * T - a * E,
        t[13] = e * T - s * C + n * E,
        t[14] = m * b - p * S - w * y,
        t[15] = u * S - c * b + d * y,
        t
    }
    function ae(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3]
          , r = t[4]
          , h = t[5]
          , o = t[6]
          , a = t[7]
          , l = t[8]
          , u = t[9]
          , c = t[10]
          , d = t[11]
          , f = t[12]
          , p = t[13]
          , m = t[14]
          , w = i * h - e * r
          , g = i * o - s * r
          , y = e * o - s * h
          , b = l * p - u * f
          , v = l * m - c * f
          , S = u * m - c * p;
        return a * (i * S - e * v + s * b) - n * (r * S - h * v + o * b) + t[15] * (l * y - u * g + c * w) - d * (f * y - p * g + m * w)
    }
    function le(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = i[9]
          , f = i[10]
          , p = i[11]
          , m = i[12]
          , w = i[13]
          , g = i[14]
          , y = i[15]
          , b = e[0]
          , v = e[1]
          , S = e[2]
          , x = e[3];
        return t[0] = b * s + v * o + S * c + x * m,
        t[1] = b * n + v * a + S * d + x * w,
        t[2] = b * r + v * l + S * f + x * g,
        t[3] = b * h + v * u + S * p + x * y,
        b = e[4],
        v = e[5],
        S = e[6],
        x = e[7],
        t[4] = b * s + v * o + S * c + x * m,
        t[5] = b * n + v * a + S * d + x * w,
        t[6] = b * r + v * l + S * f + x * g,
        t[7] = b * h + v * u + S * p + x * y,
        b = e[8],
        v = e[9],
        S = e[10],
        x = e[11],
        t[8] = b * s + v * o + S * c + x * m,
        t[9] = b * n + v * a + S * d + x * w,
        t[10] = b * r + v * l + S * f + x * g,
        t[11] = b * h + v * u + S * p + x * y,
        b = e[12],
        v = e[13],
        S = e[14],
        x = e[15],
        t[12] = b * s + v * o + S * c + x * m,
        t[13] = b * n + v * a + S * d + x * w,
        t[14] = b * r + v * l + S * f + x * g,
        t[15] = b * h + v * u + S * p + x * y,
        t
    }
    function ue(t, i, e) {
        var s, n, r, h, o, a, l, u, c, d, f, p, m = e[0], w = e[1], g = e[2];
        return i === t ? (t[12] = i[0] * m + i[4] * w + i[8] * g + i[12],
        t[13] = i[1] * m + i[5] * w + i[9] * g + i[13],
        t[14] = i[2] * m + i[6] * w + i[10] * g + i[14],
        t[15] = i[3] * m + i[7] * w + i[11] * g + i[15]) : (s = i[0],
        n = i[1],
        r = i[2],
        h = i[3],
        o = i[4],
        a = i[5],
        l = i[6],
        u = i[7],
        c = i[8],
        d = i[9],
        f = i[10],
        p = i[11],
        t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = o,
        t[5] = a,
        t[6] = l,
        t[7] = u,
        t[8] = c,
        t[9] = d,
        t[10] = f,
        t[11] = p,
        t[12] = s * m + o * w + c * g + i[12],
        t[13] = n * m + a * w + d * g + i[13],
        t[14] = r * m + l * w + f * g + i[14],
        t[15] = h * m + u * w + p * g + i[15]),
        t
    }
    function ce(t, i, e) {
        var s = e[0]
          , n = e[1]
          , r = e[2];
        return t[0] = i[0] * s,
        t[1] = i[1] * s,
        t[2] = i[2] * s,
        t[3] = i[3] * s,
        t[4] = i[4] * n,
        t[5] = i[5] * n,
        t[6] = i[6] * n,
        t[7] = i[7] * n,
        t[8] = i[8] * r,
        t[9] = i[9] * r,
        t[10] = i[10] * r,
        t[11] = i[11] * r,
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        t
    }
    function de(i, e, s, n) {
        var r, h, o, a, l, u, c, d, f, p, m, w, g, y, b, v, S, x, M, E, C, _, T, I, P = n[0], G = n[1], A = n[2], R = Math.hypot(P, G, A);
        return R < t ? null : (P *= R = 1 / R,
        G *= R,
        A *= R,
        r = Math.sin(s),
        o = 1 - (h = Math.cos(s)),
        a = e[0],
        l = e[1],
        u = e[2],
        c = e[3],
        d = e[4],
        f = e[5],
        p = e[6],
        m = e[7],
        w = e[8],
        g = e[9],
        y = e[10],
        b = e[11],
        v = P * P * o + h,
        S = G * P * o + A * r,
        x = A * P * o - G * r,
        M = P * G * o - A * r,
        E = G * G * o + h,
        C = A * G * o + P * r,
        _ = P * A * o + G * r,
        T = G * A * o - P * r,
        I = A * A * o + h,
        i[0] = a * v + d * S + w * x,
        i[1] = l * v + f * S + g * x,
        i[2] = u * v + p * S + y * x,
        i[3] = c * v + m * S + b * x,
        i[4] = a * M + d * E + w * C,
        i[5] = l * M + f * E + g * C,
        i[6] = u * M + p * E + y * C,
        i[7] = c * M + m * E + b * C,
        i[8] = a * _ + d * T + w * I,
        i[9] = l * _ + f * T + g * I,
        i[10] = u * _ + p * T + y * I,
        i[11] = c * _ + m * T + b * I,
        e !== i && (i[12] = e[12],
        i[13] = e[13],
        i[14] = e[14],
        i[15] = e[15]),
        i)
    }
    function fe(t, i, e) {
        var s = Math.sin(e)
          , n = Math.cos(e)
          , r = i[4]
          , h = i[5]
          , o = i[6]
          , a = i[7]
          , l = i[8]
          , u = i[9]
          , c = i[10]
          , d = i[11];
        return i !== t && (t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15]),
        t[4] = r * n + l * s,
        t[5] = h * n + u * s,
        t[6] = o * n + c * s,
        t[7] = a * n + d * s,
        t[8] = l * n - r * s,
        t[9] = u * n - h * s,
        t[10] = c * n - o * s,
        t[11] = d * n - a * s,
        t
    }
    function pe(t, i, e) {
        var s = Math.sin(e)
          , n = Math.cos(e)
          , r = i[0]
          , h = i[1]
          , o = i[2]
          , a = i[3]
          , l = i[8]
          , u = i[9]
          , c = i[10]
          , d = i[11];
        return i !== t && (t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15]),
        t[0] = r * n - l * s,
        t[1] = h * n - u * s,
        t[2] = o * n - c * s,
        t[3] = a * n - d * s,
        t[8] = r * s + l * n,
        t[9] = h * s + u * n,
        t[10] = o * s + c * n,
        t[11] = a * s + d * n,
        t
    }
    function me(t, i, e) {
        var s = Math.sin(e)
          , n = Math.cos(e)
          , r = i[0]
          , h = i[1]
          , o = i[2]
          , a = i[3]
          , l = i[4]
          , u = i[5]
          , c = i[6]
          , d = i[7];
        return i !== t && (t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15]),
        t[0] = r * n + l * s,
        t[1] = h * n + u * s,
        t[2] = o * n + c * s,
        t[3] = a * n + d * s,
        t[4] = l * n - r * s,
        t[5] = u * n - h * s,
        t[6] = c * n - o * s,
        t[7] = d * n - a * s,
        t
    }
    function we(t, i) {
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = 1,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 1,
        t[11] = 0,
        t[12] = i[0],
        t[13] = i[1],
        t[14] = i[2],
        t[15] = 1,
        t
    }
    function ge(t, i) {
        return t[0] = i[0],
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = i[1],
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = i[2],
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function ye(i, e, s) {
        var n, r, h, o = s[0], a = s[1], l = s[2], u = Math.hypot(o, a, l);
        return u < t ? null : (o *= u = 1 / u,
        a *= u,
        l *= u,
        n = Math.sin(e),
        h = 1 - (r = Math.cos(e)),
        i[0] = o * o * h + r,
        i[1] = a * o * h + l * n,
        i[2] = l * o * h - a * n,
        i[3] = 0,
        i[4] = o * a * h - l * n,
        i[5] = a * a * h + r,
        i[6] = l * a * h + o * n,
        i[7] = 0,
        i[8] = o * l * h + a * n,
        i[9] = a * l * h - o * n,
        i[10] = l * l * h + r,
        i[11] = 0,
        i[12] = 0,
        i[13] = 0,
        i[14] = 0,
        i[15] = 1,
        i)
    }
    function be(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = 1,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = s,
        t[6] = e,
        t[7] = 0,
        t[8] = 0,
        t[9] = -e,
        t[10] = s,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function ve(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = 0,
        t[2] = -e,
        t[3] = 0,
        t[4] = 0,
        t[5] = 1,
        t[6] = 0,
        t[7] = 0,
        t[8] = e,
        t[9] = 0,
        t[10] = s,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function Se(t, i) {
        var e = Math.sin(i)
          , s = Math.cos(i);
        return t[0] = s,
        t[1] = e,
        t[2] = 0,
        t[3] = 0,
        t[4] = -e,
        t[5] = s,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 1,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function xe(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = s + s
          , a = n + n
          , l = r + r
          , u = s * o
          , c = s * a
          , d = s * l
          , f = n * a
          , p = n * l
          , m = r * l
          , w = h * o
          , g = h * a
          , y = h * l;
        return t[0] = 1 - (f + m),
        t[1] = c + y,
        t[2] = d - g,
        t[3] = 0,
        t[4] = c - y,
        t[5] = 1 - (u + m),
        t[6] = p + w,
        t[7] = 0,
        t[8] = d + g,
        t[9] = p - w,
        t[10] = 1 - (u + f),
        t[11] = 0,
        t[12] = e[0],
        t[13] = e[1],
        t[14] = e[2],
        t[15] = 1,
        t
    }
    function Me(t, e) {
        var s = new i(3)
          , n = -e[0]
          , r = -e[1]
          , h = -e[2]
          , o = e[3]
          , a = e[4]
          , l = e[5]
          , u = e[6]
          , c = e[7]
          , d = n * n + r * r + h * h + o * o;
        return d > 0 ? (s[0] = 2 * (a * o + c * n + l * h - u * r) / d,
        s[1] = 2 * (l * o + c * r + u * n - a * h) / d,
        s[2] = 2 * (u * o + c * h + a * r - l * n) / d) : (s[0] = 2 * (a * o + c * n + l * h - u * r),
        s[1] = 2 * (l * o + c * r + u * n - a * h),
        s[2] = 2 * (u * o + c * h + a * r - l * n)),
        xe(t, e, s),
        t
    }
    function Ee(t, i) {
        return t[0] = i[12],
        t[1] = i[13],
        t[2] = i[14],
        t
    }
    function Ce(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[4]
          , h = i[5]
          , o = i[6]
          , a = i[8]
          , l = i[9]
          , u = i[10];
        return t[0] = Math.hypot(e, s, n),
        t[1] = Math.hypot(r, h, o),
        t[2] = Math.hypot(a, l, u),
        t
    }
    function _e(t, e) {
        var s = new i(3);
        Ce(s, e);
        var n = 1 / s[0]
          , r = 1 / s[1]
          , h = 1 / s[2]
          , o = e[0] * n
          , a = e[1] * r
          , l = e[2] * h
          , u = e[4] * n
          , c = e[5] * r
          , d = e[6] * h
          , f = e[8] * n
          , p = e[9] * r
          , m = e[10] * h
          , w = o + c + m
          , g = 0;
        return w > 0 ? (g = 2 * Math.sqrt(w + 1),
        t[3] = .25 * g,
        t[0] = (d - p) / g,
        t[1] = (f - l) / g,
        t[2] = (a - u) / g) : o > c && o > m ? (g = 2 * Math.sqrt(1 + o - c - m),
        t[3] = (d - p) / g,
        t[0] = .25 * g,
        t[1] = (a + u) / g,
        t[2] = (f + l) / g) : c > m ? (g = 2 * Math.sqrt(1 + c - o - m),
        t[3] = (f - l) / g,
        t[0] = (a + u) / g,
        t[1] = .25 * g,
        t[2] = (d + p) / g) : (g = 2 * Math.sqrt(1 + m - o - c),
        t[3] = (a - u) / g,
        t[0] = (f + l) / g,
        t[1] = (d + p) / g,
        t[2] = .25 * g),
        t
    }
    function Te(t, i, e, s) {
        i[0] = s[12],
        i[1] = s[13],
        i[2] = s[14];
        var n = s[0]
          , r = s[1]
          , h = s[2]
          , o = s[4]
          , a = s[5]
          , l = s[6]
          , u = s[8]
          , c = s[9]
          , d = s[10];
        e[0] = Math.hypot(n, r, h),
        e[1] = Math.hypot(o, a, l),
        e[2] = Math.hypot(u, c, d);
        var f = 1 / e[0]
          , p = 1 / e[1]
          , m = 1 / e[2]
          , w = n * f
          , g = r * p
          , y = h * m
          , b = o * f
          , v = a * p
          , S = l * m
          , x = u * f
          , M = c * p
          , E = d * m
          , C = w + v + E
          , _ = 0;
        return C > 0 ? (_ = 2 * Math.sqrt(C + 1),
        t[3] = .25 * _,
        t[0] = (S - M) / _,
        t[1] = (x - y) / _,
        t[2] = (g - b) / _) : w > v && w > E ? (_ = 2 * Math.sqrt(1 + w - v - E),
        t[3] = (S - M) / _,
        t[0] = .25 * _,
        t[1] = (g + b) / _,
        t[2] = (x + y) / _) : v > E ? (_ = 2 * Math.sqrt(1 + v - w - E),
        t[3] = (x - y) / _,
        t[0] = (g + b) / _,
        t[1] = .25 * _,
        t[2] = (S + M) / _) : (_ = 2 * Math.sqrt(1 + E - w - v),
        t[3] = (g - b) / _,
        t[0] = (x + y) / _,
        t[1] = (S + M) / _,
        t[2] = .25 * _),
        t
    }
    function Ie(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2]
          , o = i[3]
          , a = n + n
          , l = r + r
          , u = h + h
          , c = n * a
          , d = n * l
          , f = n * u
          , p = r * l
          , m = r * u
          , w = h * u
          , g = o * a
          , y = o * l
          , b = o * u
          , v = s[0]
          , S = s[1]
          , x = s[2];
        return t[0] = (1 - (p + w)) * v,
        t[1] = (d + b) * v,
        t[2] = (f - y) * v,
        t[3] = 0,
        t[4] = (d - b) * S,
        t[5] = (1 - (c + w)) * S,
        t[6] = (m + g) * S,
        t[7] = 0,
        t[8] = (f + y) * x,
        t[9] = (m - g) * x,
        t[10] = (1 - (c + p)) * x,
        t[11] = 0,
        t[12] = e[0],
        t[13] = e[1],
        t[14] = e[2],
        t[15] = 1,
        t
    }
    function Pe(t, i, e, s, n) {
        var r = i[0]
          , h = i[1]
          , o = i[2]
          , a = i[3]
          , l = r + r
          , u = h + h
          , c = o + o
          , d = r * l
          , f = r * u
          , p = r * c
          , m = h * u
          , w = h * c
          , g = o * c
          , y = a * l
          , b = a * u
          , v = a * c
          , S = s[0]
          , x = s[1]
          , M = s[2]
          , E = n[0]
          , C = n[1]
          , _ = n[2]
          , T = (1 - (m + g)) * S
          , I = (f + v) * S
          , P = (p - b) * S
          , G = (f - v) * x
          , A = (1 - (d + g)) * x
          , R = (w + y) * x
          , k = (p + b) * M
          , O = (w - y) * M
          , D = (1 - (d + m)) * M;
        return t[0] = T,
        t[1] = I,
        t[2] = P,
        t[3] = 0,
        t[4] = G,
        t[5] = A,
        t[6] = R,
        t[7] = 0,
        t[8] = k,
        t[9] = O,
        t[10] = D,
        t[11] = 0,
        t[12] = e[0] + E - (T * E + G * C + k * _),
        t[13] = e[1] + C - (I * E + A * C + O * _),
        t[14] = e[2] + _ - (P * E + R * C + D * _),
        t[15] = 1,
        t
    }
    function Ge(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e + e
          , o = s + s
          , a = n + n
          , l = e * h
          , u = s * h
          , c = s * o
          , d = n * h
          , f = n * o
          , p = n * a
          , m = r * h
          , w = r * o
          , g = r * a;
        return t[0] = 1 - c - p,
        t[1] = u + g,
        t[2] = d - w,
        t[3] = 0,
        t[4] = u - g,
        t[5] = 1 - l - p,
        t[6] = f + m,
        t[7] = 0,
        t[8] = d + w,
        t[9] = f - m,
        t[10] = 1 - l - c,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        t
    }
    function Ae(t, i, e, s, n, r, h) {
        var o = 1 / (e - i)
          , a = 1 / (n - s)
          , l = 1 / (r - h);
        return t[0] = 2 * r * o,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = 2 * r * a,
        t[6] = 0,
        t[7] = 0,
        t[8] = (e + i) * o,
        t[9] = (n + s) * a,
        t[10] = (h + r) * l,
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[14] = h * r * 2 * l,
        t[15] = 0,
        t
    }
    function Re(t, i, e, s, n) {
        var r = 1 / Math.tan(i / 2);
        if (t[0] = r / e,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = r,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[15] = 0,
        null != n && n !== 1 / 0) {
            var h = 1 / (s - n);
            t[10] = (n + s) * h,
            t[14] = 2 * n * s * h
        } else
            t[10] = -1,
            t[14] = -2 * s;
        return t
    }
    var p = Re;
    function ke(t, i, e, s, n) {
        var r = 1 / Math.tan(i / 2);
        if (t[0] = r / e,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = r,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[15] = 0,
        null != n && n !== 1 / 0) {
            var h = 1 / (s - n);
            t[10] = n * h,
            t[14] = n * s * h
        } else
            t[10] = -1,
            t[14] = -s;
        return t
    }
    function Oe(t, i, e, s) {
        var n = Math.tan(i.upDegrees * Math.PI / 180)
          , r = Math.tan(i.downDegrees * Math.PI / 180)
          , h = Math.tan(i.leftDegrees * Math.PI / 180)
          , o = Math.tan(i.rightDegrees * Math.PI / 180)
          , a = 2 / (h + o)
          , l = 2 / (n + r);
        return t[0] = a,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = l,
        t[6] = 0,
        t[7] = 0,
        t[8] = -(h - o) * a * .5,
        t[9] = (n - r) * l * .5,
        t[10] = s / (e - s),
        t[11] = -1,
        t[12] = 0,
        t[13] = 0,
        t[14] = s * e / (e - s),
        t[15] = 0,
        t
    }
    function De(t, i, e, s, n, r, h) {
        var o = 1 / (i - e)
          , a = 1 / (s - n)
          , l = 1 / (r - h);
        return t[0] = -2 * o,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = -2 * a,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = 2 * l,
        t[11] = 0,
        t[12] = (i + e) * o,
        t[13] = (n + s) * a,
        t[14] = (h + r) * l,
        t[15] = 1,
        t
    }
    var m = De;
    function Fe(t, i, e, s, n, r, h) {
        var o = 1 / (i - e)
          , a = 1 / (s - n)
          , l = 1 / (r - h);
        return t[0] = -2 * o,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t[4] = 0,
        t[5] = -2 * a,
        t[6] = 0,
        t[7] = 0,
        t[8] = 0,
        t[9] = 0,
        t[10] = l,
        t[11] = 0,
        t[12] = (i + e) * o,
        t[13] = (n + s) * a,
        t[14] = r * l,
        t[15] = 1,
        t
    }
    function Le(i, e, s, n) {
        var r, h, o, a, l, u, c, d, f, p, m = e[0], w = e[1], g = e[2], y = n[0], b = n[1], v = n[2], S = s[0], x = s[1], M = s[2];
        return Math.abs(m - S) < t && Math.abs(w - x) < t && Math.abs(g - M) < t ? ne(i) : (c = m - S,
        d = w - x,
        f = g - M,
        r = b * (f *= p = 1 / Math.hypot(c, d, f)) - v * (d *= p),
        h = v * (c *= p) - y * f,
        o = y * d - b * c,
        (p = Math.hypot(r, h, o)) ? (r *= p = 1 / p,
        h *= p,
        o *= p) : (r = 0,
        h = 0,
        o = 0),
        a = d * o - f * h,
        l = f * r - c * o,
        u = c * h - d * r,
        (p = Math.hypot(a, l, u)) ? (a *= p = 1 / p,
        l *= p,
        u *= p) : (a = 0,
        l = 0,
        u = 0),
        i[0] = r,
        i[1] = a,
        i[2] = c,
        i[3] = 0,
        i[4] = h,
        i[5] = l,
        i[6] = d,
        i[7] = 0,
        i[8] = o,
        i[9] = u,
        i[10] = f,
        i[11] = 0,
        i[12] = -(r * m + h * w + o * g),
        i[13] = -(a * m + l * w + u * g),
        i[14] = -(c * m + d * w + f * g),
        i[15] = 1,
        i)
    }
    function Be(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2]
          , o = s[0]
          , a = s[1]
          , l = s[2]
          , u = n - e[0]
          , c = r - e[1]
          , d = h - e[2]
          , f = u * u + c * c + d * d;
        f > 0 && (u *= f = 1 / Math.sqrt(f),
        c *= f,
        d *= f);
        var p = a * d - l * c
          , m = l * u - o * d
          , w = o * c - a * u;
        return (f = p * p + m * m + w * w) > 0 && (p *= f = 1 / Math.sqrt(f),
        m *= f,
        w *= f),
        t[0] = p,
        t[1] = m,
        t[2] = w,
        t[3] = 0,
        t[4] = c * w - d * m,
        t[5] = d * p - u * w,
        t[6] = u * m - c * p,
        t[7] = 0,
        t[8] = u,
        t[9] = c,
        t[10] = d,
        t[11] = 0,
        t[12] = n,
        t[13] = r,
        t[14] = h,
        t[15] = 1,
        t
    }
    function Ue(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
    }
    function Ne(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
    }
    function je(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t[6] = i[6] + e[6],
        t[7] = i[7] + e[7],
        t[8] = i[8] + e[8],
        t[9] = i[9] + e[9],
        t[10] = i[10] + e[10],
        t[11] = i[11] + e[11],
        t[12] = i[12] + e[12],
        t[13] = i[13] + e[13],
        t[14] = i[14] + e[14],
        t[15] = i[15] + e[15],
        t
    }
    function $e(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t[4] = i[4] - e[4],
        t[5] = i[5] - e[5],
        t[6] = i[6] - e[6],
        t[7] = i[7] - e[7],
        t[8] = i[8] - e[8],
        t[9] = i[9] - e[9],
        t[10] = i[10] - e[10],
        t[11] = i[11] - e[11],
        t[12] = i[12] - e[12],
        t[13] = i[13] - e[13],
        t[14] = i[14] - e[14],
        t[15] = i[15] - e[15],
        t
    }
    function ze(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t[6] = i[6] * e,
        t[7] = i[7] * e,
        t[8] = i[8] * e,
        t[9] = i[9] * e,
        t[10] = i[10] * e,
        t[11] = i[11] * e,
        t[12] = i[12] * e,
        t[13] = i[13] * e,
        t[14] = i[14] * e,
        t[15] = i[15] * e,
        t
    }
    function Ve(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t[4] = i[4] + e[4] * s,
        t[5] = i[5] + e[5] * s,
        t[6] = i[6] + e[6] * s,
        t[7] = i[7] + e[7] * s,
        t[8] = i[8] + e[8] * s,
        t[9] = i[9] + e[9] * s,
        t[10] = i[10] + e[10] * s,
        t[11] = i[11] + e[11] * s,
        t[12] = i[12] + e[12] * s,
        t[13] = i[13] + e[13] * s,
        t[14] = i[14] + e[14] * s,
        t[15] = i[15] + e[15] * s,
        t
    }
    function We(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5] && t[6] === i[6] && t[7] === i[7] && t[8] === i[8] && t[9] === i[9] && t[10] === i[10] && t[11] === i[11] && t[12] === i[12] && t[13] === i[13] && t[14] === i[14] && t[15] === i[15]
    }
    function He(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = i[8]
          , d = i[9]
          , f = i[10]
          , p = i[11]
          , m = i[12]
          , w = i[13]
          , g = i[14]
          , y = i[15]
          , b = e[0]
          , v = e[1]
          , S = e[2]
          , x = e[3]
          , M = e[4]
          , E = e[5]
          , C = e[6]
          , _ = e[7]
          , T = e[8]
          , I = e[9]
          , P = e[10]
          , G = e[11]
          , A = e[12]
          , R = e[13]
          , k = e[14]
          , O = e[15];
        return Math.abs(s - b) <= t * Math.max(1, Math.abs(s), Math.abs(b)) && Math.abs(n - v) <= t * Math.max(1, Math.abs(n), Math.abs(v)) && Math.abs(r - S) <= t * Math.max(1, Math.abs(r), Math.abs(S)) && Math.abs(h - x) <= t * Math.max(1, Math.abs(h), Math.abs(x)) && Math.abs(o - M) <= t * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(a - E) <= t * Math.max(1, Math.abs(a), Math.abs(E)) && Math.abs(l - C) <= t * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(u - _) <= t * Math.max(1, Math.abs(u), Math.abs(_)) && Math.abs(c - T) <= t * Math.max(1, Math.abs(c), Math.abs(T)) && Math.abs(d - I) <= t * Math.max(1, Math.abs(d), Math.abs(I)) && Math.abs(f - P) <= t * Math.max(1, Math.abs(f), Math.abs(P)) && Math.abs(p - G) <= t * Math.max(1, Math.abs(p), Math.abs(G)) && Math.abs(m - A) <= t * Math.max(1, Math.abs(m), Math.abs(A)) && Math.abs(w - R) <= t * Math.max(1, Math.abs(w), Math.abs(R)) && Math.abs(g - k) <= t * Math.max(1, Math.abs(g), Math.abs(k)) && Math.abs(y - O) <= t * Math.max(1, Math.abs(y), Math.abs(O))
    }
    var w = le
      , g = $e
      , y = Object.freeze({
        __proto__: null,
        create: Qi,
        clone: te,
        ia: ie,
        rMe: ee,
        set: se,
        identity: ne,
        hMe: re,
        oMe: he,
        aMe: oe,
        lMe: ae,
        multiply: le,
        translate: ue,
        scale: ce,
        rotate: de,
        CMe: fe,
        _Me: pe,
        TMe: me,
        bMe: we,
        cMe: ge,
        uMe: ye,
        IMe: be,
        PMe: ve,
        GMe: Se,
        AMe: xe,
        RMe: Me,
        kMe: Ee,
        OMe: Ce,
        DMe: _e,
        FMe: Te,
        LMe: Ie,
        BMe: Pe,
        xMe: Ge,
        UMe: Ae,
        NMe: Re,
        perspective: p,
        jMe: ke,
        $Me: Oe,
        zMe: De,
        VMe: m,
        WMe: Fe,
        HMe: Le,
        KMe: Be,
        dMe: Ue,
        fMe: Ne,
        add: je,
        mMe: $e,
        gMe: ze,
        yMe: Ve,
        wMe: We,
        equals: He,
        mul: w,
        sub: g
    });
    function Ke() {
        var t = new i(3);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0),
        t
    }
    function qe(t) {
        var e = new i(3);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e
    }
    function Xe(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2];
        return Math.hypot(i, e, s)
    }
    function Ye(t, e, s) {
        var n = new i(3);
        return n[0] = t,
        n[1] = e,
        n[2] = s,
        n
    }
    function Je(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t
    }
    function Ze(t, i, e, s) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t
    }
    function Qe(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t
    }
    function ts(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t
    }
    function is(t, i, e) {
        return t[0] = i[0] * e[0],
        t[1] = i[1] * e[1],
        t[2] = i[2] * e[2],
        t
    }
    function es(t, i, e) {
        return t[0] = i[0] / e[0],
        t[1] = i[1] / e[1],
        t[2] = i[2] / e[2],
        t
    }
    function ss(t, i) {
        return t[0] = Math.ceil(i[0]),
        t[1] = Math.ceil(i[1]),
        t[2] = Math.ceil(i[2]),
        t
    }
    function ns(t, i) {
        return t[0] = Math.floor(i[0]),
        t[1] = Math.floor(i[1]),
        t[2] = Math.floor(i[2]),
        t
    }
    function rs(t, i, e) {
        return t[0] = Math.min(i[0], e[0]),
        t[1] = Math.min(i[1], e[1]),
        t[2] = Math.min(i[2], e[2]),
        t
    }
    function hs(t, i, e) {
        return t[0] = Math.max(i[0], e[0]),
        t[1] = Math.max(i[1], e[1]),
        t[2] = Math.max(i[2], e[2]),
        t
    }
    function os(t, i) {
        return t[0] = Math.round(i[0]),
        t[1] = Math.round(i[1]),
        t[2] = Math.round(i[2]),
        t
    }
    function as(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t
    }
    function ls(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t
    }
    function us(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2];
        return Math.hypot(e, s, n)
    }
    function cs(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2];
        return e * e + s * s + n * n
    }
    function ds(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2];
        return i * i + e * e + s * s
    }
    function fs(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t
    }
    function ps(t, i) {
        return t[0] = 1 / i[0],
        t[1] = 1 / i[1],
        t[2] = 1 / i[2],
        t
    }
    function ms(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = e * e + s * s + n * n;
        return r > 0 && (r = 1 / Math.sqrt(r)),
        t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t
    }
    function ws(t, i) {
        return t[0] * i[0] + t[1] * i[1] + t[2] * i[2]
    }
    function gs(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[0]
          , o = e[1]
          , a = e[2];
        return t[0] = n * a - r * o,
        t[1] = r * h - s * a,
        t[2] = s * o - n * h,
        t
    }
    function ys(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2];
        return t[0] = n + s * (e[0] - n),
        t[1] = r + s * (e[1] - r),
        t[2] = h + s * (e[2] - h),
        t
    }
    function bs(t, i, e, s) {
        var n = Math.acos(Math.min(Math.max(ws(i, e), -1), 1))
          , r = Math.sin(n)
          , h = Math.sin((1 - s) * n) / r
          , o = Math.sin(s * n) / r;
        return t[0] = h * i[0] + o * e[0],
        t[1] = h * i[1] + o * e[1],
        t[2] = h * i[2] + o * e[2],
        t
    }
    function vs(t, i, e, s, n, r) {
        var h = r * r
          , o = h * (2 * r - 3) + 1
          , a = h * (r - 2) + r
          , l = h * (r - 1)
          , u = h * (3 - 2 * r);
        return t[0] = i[0] * o + e[0] * a + s[0] * l + n[0] * u,
        t[1] = i[1] * o + e[1] * a + s[1] * l + n[1] * u,
        t[2] = i[2] * o + e[2] * a + s[2] * l + n[2] * u,
        t
    }
    function Ss(t, i, e, s, n, r) {
        var h = 1 - r
          , o = h * h
          , a = r * r
          , l = o * h
          , u = 3 * r * o
          , c = 3 * a * h
          , d = a * r;
        return t[0] = i[0] * l + e[0] * u + s[0] * c + n[0] * d,
        t[1] = i[1] * l + e[1] * u + s[1] * c + n[1] * d,
        t[2] = i[2] * l + e[2] * u + s[2] * c + n[2] * d,
        t
    }
    function xs(t, i) {
        i = i || 1;
        var s = 2 * e() * Math.PI
          , n = 2 * e() - 1
          , r = Math.sqrt(1 - n * n) * i;
        return t[0] = Math.cos(s) * r,
        t[1] = Math.sin(s) * r,
        t[2] = n * i,
        t
    }
    function Ms(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[3] * s + e[7] * n + e[11] * r + e[15];
        return h = h || 1,
        t[0] = (e[0] * s + e[4] * n + e[8] * r + e[12]) / h,
        t[1] = (e[1] * s + e[5] * n + e[9] * r + e[13]) / h,
        t[2] = (e[2] * s + e[6] * n + e[10] * r + e[14]) / h,
        t
    }
    function Es(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2];
        return t[0] = s * e[0] + n * e[3] + r * e[6],
        t[1] = s * e[1] + n * e[4] + r * e[7],
        t[2] = s * e[2] + n * e[5] + r * e[8],
        t
    }
    function Cs(t, i, e) {
        var s = e[0]
          , n = e[1]
          , r = e[2]
          , h = e[3]
          , o = i[0]
          , a = i[1]
          , l = i[2]
          , u = n * l - r * a
          , c = r * o - s * l
          , d = s * a - n * o
          , f = n * d - r * c
          , p = r * u - s * d
          , m = s * c - n * u
          , w = 2 * h;
        return u *= w,
        c *= w,
        d *= w,
        f *= 2,
        p *= 2,
        m *= 2,
        t[0] = o + u + f,
        t[1] = a + c + p,
        t[2] = l + d + m,
        t
    }
    function _s(t, i, e, s) {
        var n = []
          , r = [];
        return n[0] = i[0] - e[0],
        n[1] = i[1] - e[1],
        n[2] = i[2] - e[2],
        r[0] = n[0],
        r[1] = n[1] * Math.cos(s) - n[2] * Math.sin(s),
        r[2] = n[1] * Math.sin(s) + n[2] * Math.cos(s),
        t[0] = r[0] + e[0],
        t[1] = r[1] + e[1],
        t[2] = r[2] + e[2],
        t
    }
    function Ts(t, i, e, s) {
        var n = []
          , r = [];
        return n[0] = i[0] - e[0],
        n[1] = i[1] - e[1],
        n[2] = i[2] - e[2],
        r[0] = n[2] * Math.sin(s) + n[0] * Math.cos(s),
        r[1] = n[1],
        r[2] = n[2] * Math.cos(s) - n[0] * Math.sin(s),
        t[0] = r[0] + e[0],
        t[1] = r[1] + e[1],
        t[2] = r[2] + e[2],
        t
    }
    function Is(t, i, e, s) {
        var n = []
          , r = [];
        return n[0] = i[0] - e[0],
        n[1] = i[1] - e[1],
        n[2] = i[2] - e[2],
        r[0] = n[0] * Math.cos(s) - n[1] * Math.sin(s),
        r[1] = n[0] * Math.sin(s) + n[1] * Math.cos(s),
        r[2] = n[2],
        t[0] = r[0] + e[0],
        t[1] = r[1] + e[1],
        t[2] = r[2] + e[2],
        t
    }
    function Ps(t, i) {
        var e = t[0]
          , s = t[1]
          , n = t[2]
          , r = i[0]
          , h = i[1]
          , o = i[2]
          , a = Math.sqrt((e * e + s * s + n * n) * (r * r + h * h + o * o))
          , l = a && ws(t, i) / a;
        return Math.acos(Math.min(Math.max(l, -1), 1))
    }
    function Gs(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t
    }
    function As(t) {
        return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
    }
    function Rs(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2]
    }
    function ks(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[0]
          , o = e[1]
          , a = e[2];
        return Math.abs(s - h) <= t * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(n - o) <= t * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - a) <= t * Math.max(1, Math.abs(r), Math.abs(a))
    }
    var b = ts
      , v = is
      , S = es
      , x = us
      , M = cs
      , E = Xe
      , C = ds
      , _ = (_t = Ke(),
    function(t, i, e, s, n, r) {
        var h, o;
        for (i || (i = 3),
        e || (e = 0),
        o = s ? Math.min(s * i + e, t.length) : t.length,
        h = e; h < o; h += i)
            _t[0] = t[h],
            _t[1] = t[h + 1],
            _t[2] = t[h + 2],
            n(_t, _t, r),
            t[h] = _t[0],
            t[h + 1] = _t[1],
            t[h + 2] = _t[2];
        return t
    }
    )
      , T = Object.freeze({
        __proto__: null,
        create: Ke,
        clone: qe,
        length: Xe,
        rMe: Ye,
        ia: Je,
        set: Ze,
        add: Qe,
        mMe: ts,
        multiply: is,
        tb: es,
        ceil: ss,
        floor: ns,
        min: rs,
        max: hs,
        round: os,
        scale: as,
        qMe: ls,
        XMe: us,
        YMe: cs,
        JMe: ds,
        ZMe: fs,
        inverse: ps,
        normalize: ms,
        dot: ws,
        QMe: gs,
        mi: ys,
        tTe: bs,
        iTe: vs,
        eTe: Ss,
        random: xs,
        sTe: Ms,
        nTe: Es,
        rTe: Cs,
        CMe: _s,
        _Me: Ts,
        TMe: Is,
        angle: Ps,
        hTe: Gs,
        dMe: As,
        wMe: Rs,
        equals: ks,
        sub: b,
        mul: v,
        div: S,
        oTe: x,
        aTe: M,
        lTe: E,
        uTe: C,
        forEach: _
    });
    function Os() {
        var t = new i(4);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0),
        t
    }
    function Ds(t) {
        var e = new i(4);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e
    }
    function Fs(t, e, s, n) {
        var r = new i(4);
        return r[0] = t,
        r[1] = e,
        r[2] = s,
        r[3] = n,
        r
    }
    function Ls(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t
    }
    function Bs(t, i, e, s, n) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t
    }
    function Us(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t
    }
    function Ns(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t[2] = i[2] - e[2],
        t[3] = i[3] - e[3],
        t
    }
    function js(t, i, e) {
        return t[0] = i[0] * e[0],
        t[1] = i[1] * e[1],
        t[2] = i[2] * e[2],
        t[3] = i[3] * e[3],
        t
    }
    function $s(t, i, e) {
        return t[0] = i[0] / e[0],
        t[1] = i[1] / e[1],
        t[2] = i[2] / e[2],
        t[3] = i[3] / e[3],
        t
    }
    function zs(t, i) {
        return t[0] = Math.ceil(i[0]),
        t[1] = Math.ceil(i[1]),
        t[2] = Math.ceil(i[2]),
        t[3] = Math.ceil(i[3]),
        t
    }
    function Vs(t, i) {
        return t[0] = Math.floor(i[0]),
        t[1] = Math.floor(i[1]),
        t[2] = Math.floor(i[2]),
        t[3] = Math.floor(i[3]),
        t
    }
    function Ws(t, i, e) {
        return t[0] = Math.min(i[0], e[0]),
        t[1] = Math.min(i[1], e[1]),
        t[2] = Math.min(i[2], e[2]),
        t[3] = Math.min(i[3], e[3]),
        t
    }
    function Hs(t, i, e) {
        return t[0] = Math.max(i[0], e[0]),
        t[1] = Math.max(i[1], e[1]),
        t[2] = Math.max(i[2], e[2]),
        t[3] = Math.max(i[3], e[3]),
        t
    }
    function Ks(t, i) {
        return t[0] = Math.round(i[0]),
        t[1] = Math.round(i[1]),
        t[2] = Math.round(i[2]),
        t[3] = Math.round(i[3]),
        t
    }
    function qs(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t
    }
    function Xs(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t[2] = i[2] + e[2] * s,
        t[3] = i[3] + e[3] * s,
        t
    }
    function Ys(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2]
          , r = i[3] - t[3];
        return Math.hypot(e, s, n, r)
    }
    function Js(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1]
          , n = i[2] - t[2]
          , r = i[3] - t[3];
        return e * e + s * s + n * n + r * r
    }
    function Zs(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3];
        return Math.hypot(i, e, s, n)
    }
    function Qs(t) {
        var i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3];
        return i * i + e * e + s * s + n * n
    }
    function tn(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = -i[3],
        t
    }
    function en(t, i) {
        return t[0] = 1 / i[0],
        t[1] = 1 / i[1],
        t[2] = 1 / i[2],
        t[3] = 1 / i[3],
        t
    }
    function sn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e * e + s * s + n * n + r * r;
        return h > 0 && (h = 1 / Math.sqrt(h)),
        t[0] = e * h,
        t[1] = s * h,
        t[2] = n * h,
        t[3] = r * h,
        t
    }
    function nn(t, i) {
        return t[0] * i[0] + t[1] * i[1] + t[2] * i[2] + t[3] * i[3]
    }
    function rn(t, i, e, s) {
        var n = e[0] * s[1] - e[1] * s[0]
          , r = e[0] * s[2] - e[2] * s[0]
          , h = e[0] * s[3] - e[3] * s[0]
          , o = e[1] * s[2] - e[2] * s[1]
          , a = e[1] * s[3] - e[3] * s[1]
          , l = e[2] * s[3] - e[3] * s[2]
          , u = i[0]
          , c = i[1]
          , d = i[2]
          , f = i[3];
        return t[0] = c * l - d * a + f * o,
        t[1] = -u * l + d * h - f * r,
        t[2] = u * a - c * h + f * n,
        t[3] = -u * o + c * r - d * n,
        t
    }
    function hn(t, i, e, s) {
        var n = i[0]
          , r = i[1]
          , h = i[2]
          , o = i[3];
        return t[0] = n + s * (e[0] - n),
        t[1] = r + s * (e[1] - r),
        t[2] = h + s * (e[2] - h),
        t[3] = o + s * (e[3] - o),
        t
    }
    function on(t, i) {
        var s, n, r, h, o, a;
        i = i || 1;
        do {
            o = (s = 2 * e() - 1) * s + (n = 2 * e() - 1) * n
        } while (o >= 1);
        do {
            a = (r = 2 * e() - 1) * r + (h = 2 * e() - 1) * h
        } while (a >= 1);
        var l = Math.sqrt((1 - o) / a);
        return t[0] = i * s,
        t[1] = i * n,
        t[2] = i * r * l,
        t[3] = i * h * l,
        t
    }
    function an(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3];
        return t[0] = e[0] * s + e[4] * n + e[8] * r + e[12] * h,
        t[1] = e[1] * s + e[5] * n + e[9] * r + e[13] * h,
        t[2] = e[2] * s + e[6] * n + e[10] * r + e[14] * h,
        t[3] = e[3] * s + e[7] * n + e[11] * r + e[15] * h,
        t
    }
    function ln(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = e[0]
          , o = e[1]
          , a = e[2]
          , l = e[3]
          , u = l * s + o * r - a * n
          , c = l * n + a * s - h * r
          , d = l * r + h * n - o * s
          , f = -h * s - o * n - a * r;
        return t[0] = u * l + f * -h + c * -a - d * -o,
        t[1] = c * l + f * -o + d * -h - u * -a,
        t[2] = d * l + f * -a + u * -o - c * -h,
        t[3] = i[3],
        t
    }
    function un(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 0,
        t
    }
    function cn(t) {
        return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }
    function dn(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3]
    }
    function fn(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return Math.abs(s - o) <= t * Math.max(1, Math.abs(s), Math.abs(o)) && Math.abs(n - a) <= t * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - l) <= t * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(h - u) <= t * Math.max(1, Math.abs(h), Math.abs(u))
    }
    var I = Ns
      , P = js
      , G = $s
      , A = Ys
      , R = Js
      , k = Zs
      , O = Qs
      , D = function() {
        var t = Os();
        return function(i, e, s, n, r, h) {
            var o, a;
            for (e || (e = 4),
            s || (s = 0),
            a = n ? Math.min(n * e + s, i.length) : i.length,
            o = s; o < a; o += e)
                t[0] = i[o],
                t[1] = i[o + 1],
                t[2] = i[o + 2],
                t[3] = i[o + 3],
                r(t, t, h),
                i[o] = t[0],
                i[o + 1] = t[1],
                i[o + 2] = t[2],
                i[o + 3] = t[3];
            return i
        }
    }()
      , F = Object.freeze({
        __proto__: null,
        create: Os,
        clone: Ds,
        rMe: Fs,
        ia: Ls,
        set: Bs,
        add: Us,
        mMe: Ns,
        multiply: js,
        tb: $s,
        ceil: zs,
        floor: Vs,
        min: Ws,
        max: Hs,
        round: Ks,
        scale: qs,
        qMe: Xs,
        XMe: Ys,
        YMe: Js,
        length: Zs,
        JMe: Qs,
        ZMe: tn,
        inverse: en,
        normalize: sn,
        dot: nn,
        QMe: rn,
        mi: hn,
        random: on,
        sTe: an,
        rTe: ln,
        hTe: un,
        dMe: cn,
        wMe: dn,
        equals: fn,
        sub: I,
        mul: P,
        div: G,
        oTe: A,
        aTe: R,
        lTe: k,
        uTe: O,
        forEach: D
    });
    function pn() {
        var t = new i(4);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0),
        t[3] = 1,
        t
    }
    function mn(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t
    }
    function wn(t, i, e) {
        e *= .5;
        var s = Math.sin(e);
        return t[0] = s * i[0],
        t[1] = s * i[1],
        t[2] = s * i[2],
        t[3] = Math.cos(e),
        t
    }
    function gn(i, e) {
        var s = 2 * Math.acos(e[3])
          , n = Math.sin(s / 2);
        return n > t ? (i[0] = e[0] / n,
        i[1] = e[1] / n,
        i[2] = e[2] / n) : (i[0] = 1,
        i[1] = 0,
        i[2] = 0),
        s
    }
    function yn(t, i) {
        var e = V(t, i);
        return Math.acos(2 * e * e - 1)
    }
    function bn(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return t[0] = s * u + h * o + n * l - r * a,
        t[1] = n * u + h * a + r * o - s * l,
        t[2] = r * u + h * l + s * a - n * o,
        t[3] = h * u - s * o - n * a - r * l,
        t
    }
    function vn(t, i, e) {
        e *= .5;
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a + h * o,
        t[1] = n * a + r * o,
        t[2] = r * a - n * o,
        t[3] = h * a - s * o,
        t
    }
    function Sn(t, i, e) {
        e *= .5;
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a - r * o,
        t[1] = n * a + h * o,
        t[2] = r * a + s * o,
        t[3] = h * a - n * o,
        t
    }
    function xn(t, i, e) {
        e *= .5;
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = Math.sin(e)
          , a = Math.cos(e);
        return t[0] = s * a + n * o,
        t[1] = n * a - s * o,
        t[2] = r * a + h * o,
        t[3] = h * a - r * o,
        t
    }
    function Mn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2];
        return t[0] = e,
        t[1] = s,
        t[2] = n,
        t[3] = Math.sqrt(Math.abs(1 - e * e - s * s - n * n)),
        t
    }
    function En(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = Math.sqrt(e * e + s * s + n * n)
          , o = Math.exp(r)
          , a = h > 0 ? o * Math.sin(h) / h : 0;
        return t[0] = e * a,
        t[1] = s * a,
        t[2] = n * a,
        t[3] = o * Math.cos(h),
        t
    }
    function Cn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = Math.sqrt(e * e + s * s + n * n)
          , o = h > 0 ? Math.atan2(h, r) / h : 0;
        return t[0] = e * o,
        t[1] = s * o,
        t[2] = n * o,
        t[3] = .5 * Math.log(e * e + s * s + n * n + r * r),
        t
    }
    function _n(t, i, e) {
        return Cn(t, i),
        z(t, t, e),
        En(t, t),
        t
    }
    function Tn(i, e, s, n) {
        var r, h, o, a, l, u = e[0], c = e[1], d = e[2], f = e[3], p = s[0], m = s[1], w = s[2], g = s[3];
        return (h = u * p + c * m + d * w + f * g) < 0 && (h = -h,
        p = -p,
        m = -m,
        w = -w,
        g = -g),
        1 - h > t ? (r = Math.acos(h),
        o = Math.sin(r),
        a = Math.sin((1 - n) * r) / o,
        l = Math.sin(n * r) / o) : (a = 1 - n,
        l = n),
        i[0] = a * u + l * p,
        i[1] = a * c + l * m,
        i[2] = a * d + l * w,
        i[3] = a * f + l * g,
        i
    }
    function In(t) {
        var i = e()
          , s = e()
          , n = e()
          , r = Math.sqrt(1 - i)
          , h = Math.sqrt(i);
        return t[0] = r * Math.sin(2 * Math.PI * s),
        t[1] = r * Math.cos(2 * Math.PI * s),
        t[2] = h * Math.sin(2 * Math.PI * n),
        t[3] = h * Math.cos(2 * Math.PI * n),
        t
    }
    function Pn(t, i) {
        var e = i[0]
          , s = i[1]
          , n = i[2]
          , r = i[3]
          , h = e * e + s * s + n * n + r * r
          , o = h ? 1 / h : 0;
        return t[0] = -e * o,
        t[1] = -s * o,
        t[2] = -n * o,
        t[3] = r * o,
        t
    }
    function Gn(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = i[3],
        t
    }
    function An(t, i) {
        var e, s = i[0] + i[4] + i[8];
        if (s > 0)
            e = Math.sqrt(s + 1),
            t[3] = .5 * e,
            e = .5 / e,
            t[0] = (i[5] - i[7]) * e,
            t[1] = (i[6] - i[2]) * e,
            t[2] = (i[1] - i[3]) * e;
        else {
            var n = 0;
            i[4] > i[0] && (n = 1),
            i[8] > i[3 * n + n] && (n = 2);
            var r = (n + 1) % 3
              , h = (n + 2) % 3;
            e = Math.sqrt(i[3 * n + n] - i[3 * r + r] - i[3 * h + h] + 1),
            t[n] = .5 * e,
            e = .5 / e,
            t[3] = (i[3 * r + h] - i[3 * h + r]) * e,
            t[r] = (i[3 * r + n] + i[3 * n + r]) * e,
            t[h] = (i[3 * h + n] + i[3 * n + h]) * e
        }
        return t
    }
    function Rn(t, i, e, s) {
        var n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "zyx"
          , r = Math.PI / 360;
        i *= r,
        s *= r,
        e *= r;
        var h = Math.sin(i)
          , o = Math.cos(i)
          , a = Math.sin(e)
          , l = Math.cos(e)
          , u = Math.sin(s)
          , c = Math.cos(s);
        switch (n) {
        case "xyz":
            t[0] = h * l * c + o * a * u,
            t[1] = o * a * c - h * l * u,
            t[2] = o * l * u + h * a * c,
            t[3] = o * l * c - h * a * u;
            break;
        case "xzy":
            t[0] = h * l * c - o * a * u,
            t[1] = o * a * c - h * l * u,
            t[2] = o * l * u + h * a * c,
            t[3] = o * l * c + h * a * u;
            break;
        case "yxz":
            t[0] = h * l * c + o * a * u,
            t[1] = o * a * c - h * l * u,
            t[2] = o * l * u - h * a * c,
            t[3] = o * l * c + h * a * u;
            break;
        case "yzx":
            t[0] = h * l * c + o * a * u,
            t[1] = o * a * c + h * l * u,
            t[2] = o * l * u - h * a * c,
            t[3] = o * l * c - h * a * u;
            break;
        case "zxy":
            t[0] = h * l * c - o * a * u,
            t[1] = o * a * c + h * l * u,
            t[2] = o * l * u + h * a * c,
            t[3] = o * l * c - h * a * u;
            break;
        case "zyx":
            t[0] = h * l * c - o * a * u,
            t[1] = o * a * c + h * l * u,
            t[2] = o * l * u - h * a * c,
            t[3] = o * l * c + h * a * u;
            break;
        default:
            throw new Error("Unknown angle order " + n)
        }
        return t
    }
    function kn(t) {
        return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }
    var L = Ds
      , B = Fs
      , U = Ls
      , N = Bs
      , j = Us
      , $ = bn
      , z = qs
      , V = nn
      , W = hn
      , H = Zs
      , K = H
      , q = Qs
      , X = q
      , Y = sn
      , J = dn;
    function On(t, i) {
        return Math.abs(nn(t, i)) >= .999999
    }
    var Z = (Mt = Ke(),
    Et = Ye(1, 0, 0),
    Ct = Ye(0, 1, 0),
    function(t, i, e) {
        var s = ws(i, e);
        return s < -.999999 ? (gs(Mt, Et, i),
        E(Mt) < 1e-6 && gs(Mt, Ct, i),
        ms(Mt, Mt),
        wn(t, Mt, Math.PI),
        t) : s > .999999 ? (t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t) : (gs(Mt, i, e),
        t[0] = Mt[0],
        t[1] = Mt[1],
        t[2] = Mt[2],
        t[3] = 1 + s,
        Y(t, t))
    }
    )
      , Q = (St = pn(),
    xt = pn(),
    function(t, i, e, s, n, r) {
        return Tn(St, i, n, r),
        Tn(xt, e, s, r),
        Tn(t, St, xt, 2 * r * (1 - r)),
        t
    }
    )
      , tt = (vt = Mi(),
    function(t, i, e, s) {
        return vt[0] = e[0],
        vt[3] = e[1],
        vt[6] = e[2],
        vt[1] = s[0],
        vt[4] = s[1],
        vt[7] = s[2],
        vt[2] = -i[0],
        vt[5] = -i[1],
        vt[8] = -i[2],
        Y(t, An(t, vt))
    }
    )
      , it = Object.freeze({
        __proto__: null,
        create: pn,
        identity: mn,
        cTe: wn,
        dTe: gn,
        fTe: yn,
        multiply: bn,
        CMe: vn,
        _Me: Sn,
        TMe: xn,
        pTe: Mn,
        exp: En,
        ln: Cn,
        pow: _n,
        tTe: Tn,
        random: In,
        oMe: Pn,
        mTe: Gn,
        wTe: An,
        gTe: Rn,
        dMe: kn,
        clone: L,
        rMe: B,
        ia: U,
        set: N,
        add: j,
        mul: $,
        scale: z,
        dot: V,
        mi: W,
        length: H,
        lTe: K,
        JMe: q,
        uTe: X,
        normalize: Y,
        wMe: J,
        equals: On,
        yTe: Z,
        bTe: Q,
        vTe: tt
    });
    function Dn() {
        var t = new i(8);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[4] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0),
        t[3] = 1,
        t
    }
    function Fn(t) {
        var e = new i(8);
        return e[0] = t[0],
        e[1] = t[1],
        e[2] = t[2],
        e[3] = t[3],
        e[4] = t[4],
        e[5] = t[5],
        e[6] = t[6],
        e[7] = t[7],
        e
    }
    function Ln(t, e, s, n, r, h, o, a) {
        var l = new i(8);
        return l[0] = t,
        l[1] = e,
        l[2] = s,
        l[3] = n,
        l[4] = r,
        l[5] = h,
        l[6] = o,
        l[7] = a,
        l
    }
    function Bn(t, e, s, n, r, h, o) {
        var a = new i(8);
        a[0] = t,
        a[1] = e,
        a[2] = s,
        a[3] = n;
        var l = .5 * r
          , u = .5 * h
          , c = .5 * o;
        return a[4] = l * n + u * s - c * e,
        a[5] = u * n + c * t - l * s,
        a[6] = c * n + l * e - u * t,
        a[7] = -l * t - u * e - c * s,
        a
    }
    function Un(t, i, e) {
        var s = .5 * e[0]
          , n = .5 * e[1]
          , r = .5 * e[2]
          , h = i[0]
          , o = i[1]
          , a = i[2]
          , l = i[3];
        return t[0] = h,
        t[1] = o,
        t[2] = a,
        t[3] = l,
        t[4] = s * l + n * a - r * o,
        t[5] = n * l + r * h - s * a,
        t[6] = r * l + s * o - n * h,
        t[7] = -s * h - n * o - r * a,
        t
    }
    function Nn(t, i) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = .5 * i[0],
        t[5] = .5 * i[1],
        t[6] = .5 * i[2],
        t[7] = 0,
        t
    }
    function jn(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t
    }
    function $n(t, e) {
        var s = pn();
        _e(s, e);
        var n = new i(3);
        return Ee(n, e),
        Un(t, s, n),
        t
    }
    function zn(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t
    }
    function Vn(t) {
        return t[0] = 0,
        t[1] = 0,
        t[2] = 0,
        t[3] = 1,
        t[4] = 0,
        t[5] = 0,
        t[6] = 0,
        t[7] = 0,
        t
    }
    function Wn(t, i, e, s, n, r, h, o, a) {
        return t[0] = i,
        t[1] = e,
        t[2] = s,
        t[3] = n,
        t[4] = r,
        t[5] = h,
        t[6] = o,
        t[7] = a,
        t
    }
    var et = U;
    function Hn(t, i) {
        return t[0] = i[4],
        t[1] = i[5],
        t[2] = i[6],
        t[3] = i[7],
        t
    }
    var st = U;
    function Kn(t, i) {
        return t[4] = i[0],
        t[5] = i[1],
        t[6] = i[2],
        t[7] = i[3],
        t
    }
    function qn(t, i) {
        var e = i[4]
          , s = i[5]
          , n = i[6]
          , r = i[7]
          , h = -i[0]
          , o = -i[1]
          , a = -i[2]
          , l = i[3];
        return t[0] = 2 * (e * l + r * h + s * a - n * o),
        t[1] = 2 * (s * l + r * o + n * h - e * a),
        t[2] = 2 * (n * l + r * a + e * o - s * h),
        t
    }
    function Xn(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = .5 * e[0]
          , a = .5 * e[1]
          , l = .5 * e[2]
          , u = i[4]
          , c = i[5]
          , d = i[6]
          , f = i[7];
        return t[0] = s,
        t[1] = n,
        t[2] = r,
        t[3] = h,
        t[4] = h * o + n * l - r * a + u,
        t[5] = h * a + r * o - s * l + c,
        t[6] = h * l + s * a - n * o + d,
        t[7] = -s * o - n * a - r * l + f,
        t
    }
    function Yn(t, i, e) {
        var s = -i[0]
          , n = -i[1]
          , r = -i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = o * h + u * s + a * r - l * n
          , d = a * h + u * n + l * s - o * r
          , f = l * h + u * r + o * n - a * s
          , p = u * h - o * s - a * n - l * r;
        return vn(t, i, e),
        s = t[0],
        n = t[1],
        r = t[2],
        h = t[3],
        t[4] = c * h + p * s + d * r - f * n,
        t[5] = d * h + p * n + f * s - c * r,
        t[6] = f * h + p * r + c * n - d * s,
        t[7] = p * h - c * s - d * n - f * r,
        t
    }
    function Jn(t, i, e) {
        var s = -i[0]
          , n = -i[1]
          , r = -i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = o * h + u * s + a * r - l * n
          , d = a * h + u * n + l * s - o * r
          , f = l * h + u * r + o * n - a * s
          , p = u * h - o * s - a * n - l * r;
        return Sn(t, i, e),
        s = t[0],
        n = t[1],
        r = t[2],
        h = t[3],
        t[4] = c * h + p * s + d * r - f * n,
        t[5] = d * h + p * n + f * s - c * r,
        t[6] = f * h + p * r + c * n - d * s,
        t[7] = p * h - c * s - d * n - f * r,
        t
    }
    function Zn(t, i, e) {
        var s = -i[0]
          , n = -i[1]
          , r = -i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = o * h + u * s + a * r - l * n
          , d = a * h + u * n + l * s - o * r
          , f = l * h + u * r + o * n - a * s
          , p = u * h - o * s - a * n - l * r;
        return xn(t, i, e),
        s = t[0],
        n = t[1],
        r = t[2],
        h = t[3],
        t[4] = c * h + p * s + d * r - f * n,
        t[5] = d * h + p * n + f * s - c * r,
        t[6] = f * h + p * r + c * n - d * s,
        t[7] = p * h - c * s - d * n - f * r,
        t
    }
    function Qn(t, i, e) {
        var s = e[0]
          , n = e[1]
          , r = e[2]
          , h = e[3]
          , o = i[0]
          , a = i[1]
          , l = i[2]
          , u = i[3];
        return t[0] = o * h + u * s + a * r - l * n,
        t[1] = a * h + u * n + l * s - o * r,
        t[2] = l * h + u * r + o * n - a * s,
        t[3] = u * h - o * s - a * n - l * r,
        o = i[4],
        a = i[5],
        l = i[6],
        u = i[7],
        t[4] = o * h + u * s + a * r - l * n,
        t[5] = a * h + u * n + l * s - o * r,
        t[6] = l * h + u * r + o * n - a * s,
        t[7] = u * h - o * s - a * n - l * r,
        t
    }
    function tr(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[0]
          , a = e[1]
          , l = e[2]
          , u = e[3];
        return t[0] = s * u + h * o + n * l - r * a,
        t[1] = n * u + h * a + r * o - s * l,
        t[2] = r * u + h * l + s * a - n * o,
        t[3] = h * u - s * o - n * a - r * l,
        o = e[4],
        a = e[5],
        l = e[6],
        u = e[7],
        t[4] = s * u + h * o + n * l - r * a,
        t[5] = n * u + h * a + r * o - s * l,
        t[6] = r * u + h * l + s * a - n * o,
        t[7] = h * u - s * o - n * a - r * l,
        t
    }
    function ir(i, e, s, n) {
        if (Math.abs(n) < t)
            return zn(i, e);
        var r = Math.hypot(s[0], s[1], s[2]);
        n *= .5;
        var h = Math.sin(n)
          , o = h * s[0] / r
          , a = h * s[1] / r
          , l = h * s[2] / r
          , u = Math.cos(n)
          , c = e[0]
          , d = e[1]
          , f = e[2]
          , p = e[3];
        i[0] = c * u + p * o + d * l - f * a,
        i[1] = d * u + p * a + f * o - c * l,
        i[2] = f * u + p * l + c * a - d * o,
        i[3] = p * u - c * o - d * a - f * l;
        var m = e[4]
          , w = e[5]
          , g = e[6]
          , y = e[7];
        return i[4] = m * u + y * o + w * l - g * a,
        i[5] = w * u + y * a + g * o - m * l,
        i[6] = g * u + y * l + m * a - w * o,
        i[7] = y * u - m * o - w * a - g * l,
        i
    }
    function er(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t[2] = i[2] + e[2],
        t[3] = i[3] + e[3],
        t[4] = i[4] + e[4],
        t[5] = i[5] + e[5],
        t[6] = i[6] + e[6],
        t[7] = i[7] + e[7],
        t
    }
    function sr(t, i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , u = e[7]
          , c = i[4]
          , d = i[5]
          , f = i[6]
          , p = i[7]
          , m = e[0]
          , w = e[1]
          , g = e[2]
          , y = e[3];
        return t[0] = s * y + h * m + n * g - r * w,
        t[1] = n * y + h * w + r * m - s * g,
        t[2] = r * y + h * g + s * w - n * m,
        t[3] = h * y - s * m - n * w - r * g,
        t[4] = s * u + h * o + n * l - r * a + c * y + p * m + d * g - f * w,
        t[5] = n * u + h * a + r * o - s * l + d * y + p * w + f * m - c * g,
        t[6] = r * u + h * l + s * a - n * o + f * y + p * g + c * w - d * m,
        t[7] = h * u - s * o - n * a - r * l + p * y - c * m - d * w - f * g,
        t
    }
    var nt = sr;
    function nr(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t[2] = i[2] * e,
        t[3] = i[3] * e,
        t[4] = i[4] * e,
        t[5] = i[5] * e,
        t[6] = i[6] * e,
        t[7] = i[7] * e,
        t
    }
    var rt = V;
    function rr(t, i, e, s) {
        var n = 1 - s;
        return rt(i, e) < 0 && (s = -s),
        t[0] = i[0] * n + e[0] * s,
        t[1] = i[1] * n + e[1] * s,
        t[2] = i[2] * n + e[2] * s,
        t[3] = i[3] * n + e[3] * s,
        t[4] = i[4] * n + e[4] * s,
        t[5] = i[5] * n + e[5] * s,
        t[6] = i[6] * n + e[6] * s,
        t[7] = i[7] * n + e[7] * s,
        t
    }
    function hr(t, i) {
        var e = at(i);
        return t[0] = -i[0] / e,
        t[1] = -i[1] / e,
        t[2] = -i[2] / e,
        t[3] = i[3] / e,
        t[4] = -i[4] / e,
        t[5] = -i[5] / e,
        t[6] = -i[6] / e,
        t[7] = i[7] / e,
        t
    }
    function or(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t[2] = -i[2],
        t[3] = i[3],
        t[4] = -i[4],
        t[5] = -i[5],
        t[6] = -i[6],
        t[7] = i[7],
        t
    }
    var ht = H
      , ot = ht
      , at = q
      , lt = at;
    function ar(t, i) {
        var e = at(i);
        if (e > 0) {
            e = Math.sqrt(e);
            var s = i[0] / e
              , n = i[1] / e
              , r = i[2] / e
              , h = i[3] / e
              , o = i[4]
              , a = i[5]
              , l = i[6]
              , u = i[7]
              , c = s * o + n * a + r * l + h * u;
            t[0] = s,
            t[1] = n,
            t[2] = r,
            t[3] = h,
            t[4] = (o - s * c) / e,
            t[5] = (a - n * c) / e,
            t[6] = (l - r * c) / e,
            t[7] = (u - h * c) / e
        }
        return t
    }
    function lr(t) {
        return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")"
    }
    function ur(t, i) {
        return t[0] === i[0] && t[1] === i[1] && t[2] === i[2] && t[3] === i[3] && t[4] === i[4] && t[5] === i[5] && t[6] === i[6] && t[7] === i[7]
    }
    function cr(i, e) {
        var s = i[0]
          , n = i[1]
          , r = i[2]
          , h = i[3]
          , o = i[4]
          , a = i[5]
          , l = i[6]
          , u = i[7]
          , c = e[0]
          , d = e[1]
          , f = e[2]
          , p = e[3]
          , m = e[4]
          , w = e[5]
          , g = e[6]
          , y = e[7];
        return Math.abs(s - c) <= t * Math.max(1, Math.abs(s), Math.abs(c)) && Math.abs(n - d) <= t * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(r - f) <= t * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(h - p) <= t * Math.max(1, Math.abs(h), Math.abs(p)) && Math.abs(o - m) <= t * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(a - w) <= t * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(l - g) <= t * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u - y) <= t * Math.max(1, Math.abs(u), Math.abs(y))
    }
    var ut = Object.freeze({
        __proto__: null,
        create: Dn,
        clone: Fn,
        rMe: Ln,
        STe: Bn,
        AMe: Un,
        bMe: Nn,
        uMe: jn,
        vMe: $n,
        ia: zn,
        identity: Vn,
        set: Wn,
        xTe: et,
        MTe: Hn,
        ETe: st,
        CTe: Kn,
        kMe: qn,
        translate: Xn,
        CMe: Yn,
        _Me: Jn,
        TMe: Zn,
        _Te: Qn,
        TTe: tr,
        ITe: ir,
        add: er,
        multiply: sr,
        mul: nt,
        scale: nr,
        dot: rt,
        mi: rr,
        oMe: hr,
        mTe: or,
        length: ht,
        lTe: ot,
        JMe: at,
        uTe: lt,
        normalize: ar,
        dMe: lr,
        wMe: ur,
        equals: cr
    });
    function dr() {
        var t = new i(2);
        return i != Float32Array && (t[0] = 0,
        t[1] = 0),
        t
    }
    function fr(t) {
        var e = new i(2);
        return e[0] = t[0],
        e[1] = t[1],
        e
    }
    function pr(t, e) {
        var s = new i(2);
        return s[0] = t,
        s[1] = e,
        s
    }
    function mr(t, i) {
        return t[0] = i[0],
        t[1] = i[1],
        t
    }
    function wr(t, i, e) {
        return t[0] = i,
        t[1] = e,
        t
    }
    function gr(t, i, e) {
        return t[0] = i[0] + e[0],
        t[1] = i[1] + e[1],
        t
    }
    function yr(t, i, e) {
        return t[0] = i[0] - e[0],
        t[1] = i[1] - e[1],
        t
    }
    function br(t, i, e) {
        return t[0] = i[0] * e[0],
        t[1] = i[1] * e[1],
        t
    }
    function vr(t, i, e) {
        return t[0] = i[0] / e[0],
        t[1] = i[1] / e[1],
        t
    }
    function Sr(t, i) {
        return t[0] = Math.ceil(i[0]),
        t[1] = Math.ceil(i[1]),
        t
    }
    function xr(t, i) {
        return t[0] = Math.floor(i[0]),
        t[1] = Math.floor(i[1]),
        t
    }
    function Mr(t, i, e) {
        return t[0] = Math.min(i[0], e[0]),
        t[1] = Math.min(i[1], e[1]),
        t
    }
    function Er(t, i, e) {
        return t[0] = Math.max(i[0], e[0]),
        t[1] = Math.max(i[1], e[1]),
        t
    }
    function Cr(t, i) {
        return t[0] = Math.round(i[0]),
        t[1] = Math.round(i[1]),
        t
    }
    function _r(t, i, e) {
        return t[0] = i[0] * e,
        t[1] = i[1] * e,
        t
    }
    function Tr(t, i, e, s) {
        return t[0] = i[0] + e[0] * s,
        t[1] = i[1] + e[1] * s,
        t
    }
    function Ir(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1];
        return Math.hypot(e, s)
    }
    function Pr(t, i) {
        var e = i[0] - t[0]
          , s = i[1] - t[1];
        return e * e + s * s
    }
    function Gr(t) {
        var i = t[0]
          , e = t[1];
        return Math.hypot(i, e)
    }
    function Ar(t) {
        var i = t[0]
          , e = t[1];
        return i * i + e * e
    }
    function Rr(t, i) {
        return t[0] = -i[0],
        t[1] = -i[1],
        t
    }
    function kr(t, i) {
        return t[0] = 1 / i[0],
        t[1] = 1 / i[1],
        t
    }
    function Or(t, i) {
        var e = i[0]
          , s = i[1]
          , n = e * e + s * s;
        return n > 0 && (n = 1 / Math.sqrt(n)),
        t[0] = i[0] * n,
        t[1] = i[1] * n,
        t
    }
    function Dr(t, i) {
        return t[0] * i[0] + t[1] * i[1]
    }
    function Fr(t, i, e) {
        var s = i[0] * e[1] - i[1] * e[0];
        return t[0] = t[1] = 0,
        t[2] = s,
        t
    }
    function Lr(t, i, e, s) {
        var n = i[0]
          , r = i[1];
        return t[0] = n + s * (e[0] - n),
        t[1] = r + s * (e[1] - r),
        t
    }
    function Br(t, i) {
        i = i || 1;
        var s = 2 * e() * Math.PI;
        return t[0] = Math.cos(s) * i,
        t[1] = Math.sin(s) * i,
        t
    }
    function Ur(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[2] * n,
        t[1] = e[1] * s + e[3] * n,
        t
    }
    function Nr(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[2] * n + e[4],
        t[1] = e[1] * s + e[3] * n + e[5],
        t
    }
    function jr(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[3] * n + e[6],
        t[1] = e[1] * s + e[4] * n + e[7],
        t
    }
    function $r(t, i, e) {
        var s = i[0]
          , n = i[1];
        return t[0] = e[0] * s + e[4] * n + e[12],
        t[1] = e[1] * s + e[5] * n + e[13],
        t
    }
    function zr(t, i, e, s) {
        var n = i[0] - e[0]
          , r = i[1] - e[1]
          , h = Math.sin(s)
          , o = Math.cos(s);
        return t[0] = n * o - r * h + e[0],
        t[1] = n * h + r * o + e[1],
        t
    }
    function Vr(t, i) {
        var e = t[0]
          , s = t[1]
          , n = i[0]
          , r = i[1]
          , h = Math.sqrt((e * e + s * s) * (n * n + r * r))
          , o = h && (e * n + s * r) / h;
        return Math.acos(Math.min(Math.max(o, -1), 1))
    }
    function Wr(t) {
        return t[0] = 0,
        t[1] = 0,
        t
    }
    function Hr(t) {
        return "vec2(" + t[0] + ", " + t[1] + ")"
    }
    function Kr(t, i) {
        return t[0] === i[0] && t[1] === i[1]
    }
    function qr(i, e) {
        var s = i[0]
          , n = i[1]
          , r = e[0]
          , h = e[1];
        return Math.abs(s - r) <= t * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(n - h) <= t * Math.max(1, Math.abs(n), Math.abs(h))
    }
    var ct = Gr
      , dt = yr
      , ft = br
      , pt = vr
      , mt = Ir
      , wt = Pr
      , gt = Ar
      , yt = function() {
        var t = dr();
        return function(i, e, s, n, r, h) {
            var o, a;
            for (e || (e = 2),
            s || (s = 0),
            a = n ? Math.min(n * e + s, i.length) : i.length,
            o = s; o < a; o += e)
                t[0] = i[o],
                t[1] = i[o + 1],
                r(t, t, h),
                i[o] = t[0],
                i[o + 1] = t[1];
            return i
        }
    }()
      , bt = Object.freeze({
        __proto__: null,
        create: dr,
        clone: fr,
        rMe: pr,
        ia: mr,
        set: wr,
        add: gr,
        mMe: yr,
        multiply: br,
        tb: vr,
        ceil: Sr,
        floor: xr,
        min: Mr,
        max: Er,
        round: Cr,
        scale: _r,
        qMe: Tr,
        XMe: Ir,
        YMe: Pr,
        length: Gr,
        JMe: Ar,
        ZMe: Rr,
        inverse: kr,
        normalize: Or,
        dot: Dr,
        QMe: Fr,
        mi: Lr,
        random: Br,
        PTe: Ur,
        GTe: Nr,
        nTe: jr,
        sTe: $r,
        rotate: zr,
        angle: Vr,
        hTe: Wr,
        dMe: Hr,
        wMe: Kr,
        equals: qr,
        lTe: ct,
        sub: dt,
        mul: ft,
        div: pt,
        oTe: mt,
        aTe: wt,
        uTe: gt,
        forEach: yt
    });
    globalThis.sG = n,
    globalThis.sG.ATe = o,
    globalThis.sG.RTe = u,
    globalThis.sG.kTe = f,
    globalThis.sG.eG = y,
    globalThis.sG.OTe = it,
    globalThis.sG.DTe = ut,
    globalThis.sG.FTe = bt,
    globalThis.sG.hG = T,
    globalThis.sG.dys = F
}
var vt, St, xt, Mt, Et, Ct, _t;
!function() {
    function t(t) {
        this.mode = e.xf,
        this.data = t,
        this.Sf = [];
        for (var i = 0, s = this.data.length; i < s; i++) {
            var n = []
              , r = this.data.charCodeAt(i);
            r > 65536 ? (n[0] = 240 | (1835008 & r) >>> 18,
            n[1] = 128 | (258048 & r) >>> 12,
            n[2] = 128 | (4032 & r) >>> 6,
            n[3] = 128 | 63 & r) : r > 2048 ? (n[0] = 224 | (61440 & r) >>> 12,
            n[1] = 128 | (4032 & r) >>> 6,
            n[2] = 128 | 63 & r) : r > 128 ? (n[0] = 192 | (1984 & r) >>> 6,
            n[1] = 128 | 63 & r) : n[0] = r,
            this.Sf.push(n)
        }
        this.Sf = Array.prototype.concat.apply([], this.Sf),
        this.Sf.length != this.data.length && (this.Sf.unshift(191),
        this.Sf.unshift(187),
        this.Sf.unshift(239))
    }
    function i(t, i) {
        this.Cf = t,
        this.vf = i,
        this.Mf = null,
        this.If = 0,
        this.Tf = null,
        this.Of = []
    }
    t.prototype = {
        Pf: function(t) {
            return this.Sf.length
        },
        write: function(t) {
            for (var i = 0, e = this.Sf.length; i < e; i++)
                t.put(this.Sf[i], 8)
        }
    },
    i.prototype = {
        Vf: function(i) {
            var e = new t(i);
            this.Of.push(e),
            this.Tf = null
        },
        kf: function(t, i) {
            if (t < 0 || this.If <= t || i < 0 || this.If <= i)
                throw new Error(t + "," + i);
            return this.Mf[t][i]
        },
        Gf: function() {
            return this.If
        },
        jf: function() {
            this.Rf(!1, this._f())
        },
        Rf: function(t, e) {
            this.If = 4 * this.Cf + 17,
            this.Mf = new Array(this.If);
            for (var s = 0; s < this.If; s++) {
                this.Mf[s] = new Array(this.If);
                for (var n = 0; n < this.If; n++)
                    this.Mf[s][n] = null
            }
            this.Df(0, 0),
            this.Df(this.If - 7, 0),
            this.Df(0, this.If - 7),
            this.Lf(),
            this.Nf(),
            this.Af(t, e),
            this.Cf >= 7 && this.Ff(t),
            null == this.Tf && (this.Tf = i.zf(this.Cf, this.vf, this.Of)),
            this.Ef(this.Tf, e)
        },
        Df: function(t, i) {
            for (var e = -1; e <= 7; e++)
                if (!(t + e <= -1 || this.If <= t + e))
                    for (var s = -1; s <= 7; s++)
                        i + s <= -1 || this.If <= i + s || (this.Mf[t + e][i + s] = 0 <= e && e <= 6 && (0 == s || 6 == s) || 0 <= s && s <= 6 && (0 == e || 6 == e) || 2 <= e && e <= 4 && 2 <= s && s <= 4)
        },
        _f: function() {
            for (var t = 0, i = 0, e = 0; e < 8; e++) {
                this.Rf(!0, e);
                var s = d.Bf(this);
                (0 == e || t > s) && (t = s,
                i = e)
            }
            return i
        },
        Uf: function(t, i, e) {
            var s = t.Hf(i, e);
            this.jf();
            for (var n = 0; n < this.Mf.length; n++)
                for (var r = 1 * n, h = 0; h < this.Mf[n].length; h++) {
                    var o = 1 * h;
                    this.Mf[n][h] && (s.Wf(0, 100),
                    s.moveTo(o, r),
                    s.lineTo(o + 1, r),
                    s.lineTo(o + 1, r + 1),
                    s.lineTo(o, r + 1),
                    s.Xf())
                }
            return s
        },
        Nf: function() {
            for (var t = 8; t < this.If - 8; t++)
                null == this.Mf[t][6] && (this.Mf[t][6] = t % 2 == 0);
            for (var i = 8; i < this.If - 8; i++)
                null == this.Mf[6][i] && (this.Mf[6][i] = i % 2 == 0)
        },
        Lf: function() {
            for (var t = d.$f(this.Cf), i = 0; i < t.length; i++)
                for (var e = 0; e < t.length; e++) {
                    var s = t[i]
                      , n = t[e];
                    if (null == this.Mf[s][n])
                        for (var r = -2; r <= 2; r++)
                            for (var h = -2; h <= 2; h++)
                                this.Mf[s + r][n + h] = -2 == r || 2 == r || -2 == h || 2 == h || 0 == r && 0 == h
                }
        },
        Ff: function(t) {
            for (var i = d.Yf(this.Cf), e = 0; e < 18; e++) {
                var s = !t && 1 == (i >> e & 1);
                this.Mf[Math.floor(e / 3)][e % 3 + this.If - 8 - 3] = s
            }
            for (e = 0; e < 18; e++) {
                s = !t && 1 == (i >> e & 1);
                this.Mf[e % 3 + this.If - 8 - 3][Math.floor(e / 3)] = s
            }
        },
        Af: function(t, i) {
            for (var e = this.vf << 3 | i, s = d.qf(e), n = 0; n < 15; n++) {
                var r = !t && 1 == (s >> n & 1);
                n < 6 ? this.Mf[n][8] = r : n < 8 ? this.Mf[n + 1][8] = r : this.Mf[this.If - 15 + n][8] = r
            }
            for (n = 0; n < 15; n++) {
                r = !t && 1 == (s >> n & 1);
                n < 8 ? this.Mf[8][this.If - n - 1] = r : n < 9 ? this.Mf[8][15 - n - 1 + 1] = r : this.Mf[8][15 - n - 1] = r
            }
            this.Mf[this.If - 8][8] = !t
        },
        Ef: function(t, i) {
            for (var e = -1, s = this.If - 1, n = 7, r = 0, h = this.If - 1; h > 0; h -= 2)
                for (6 == h && h--; ; ) {
                    for (var o = 0; o < 2; o++)
                        if (null == this.Mf[s][h - o]) {
                            var a = !1;
                            r < t.length && (a = 1 == (t[r] >>> n & 1)),
                            d.Jf(i, s, h - o) && (a = !a),
                            this.Mf[s][h - o] = a,
                            -1 == --n && (r++,
                            n = 7)
                        }
                    if ((s += e) < 0 || this.If <= s) {
                        s -= e,
                        e = -e;
                        break
                    }
                }
        }
    },
    i.Qf = 236,
    i.Kf = 17,
    i.zf = function(t, e, s) {
        for (var n = w.Zf(t, e), r = new g, h = 0; h < s.length; h++) {
            var o = s[h];
            r.put(o.mode, 4),
            r.put(o.Pf(), d.tm(o.mode, t)),
            o.write(r)
        }
        var a = 0;
        for (h = 0; h < n.length; h++)
            a += n[h].im;
        if (r.tm() > 8 * a)
            throw new Error("code length overflow. (" + r.tm() + ">" + 8 * a + ")");
        for (r.tm() + 4 <= 8 * a && r.put(0, 4); r.tm() % 8 != 0; )
            r.sm(!1);
        for (; !(r.tm() >= 8 * a || (r.put(i.Qf, 8),
        r.tm() >= 8 * a)); )
            r.put(i.Kf, 8);
        return i.nm(r, n)
    }
    ,
    i.nm = function(t, i) {
        for (var e = 0, s = 0, n = 0, r = new Array(i.length), h = new Array(i.length), o = 0; o < i.length; o++) {
            var a = i[o].im
              , l = i[o].rm - a;
            s = Math.max(s, a),
            n = Math.max(n, l),
            r[o] = new Array(a);
            for (var u = 0; u < r[o].length; u++)
                r[o][u] = 255 & t.buffer[u + e];
            e += a;
            var c = d.am(l)
              , f = new m(r[o],c.Pf() - 1).lm(c);
            h[o] = new Array(c.Pf() - 1);
            for (u = 0; u < h[o].length; u++) {
                var p = u + f.Pf() - h[o].length;
                h[o][u] = p >= 0 ? f.get(p) : 0
            }
        }
        var w = 0;
        for (u = 0; u < i.length; u++)
            w += i[u].rm;
        var g = new Array(w)
          , y = 0;
        for (u = 0; u < s; u++)
            for (o = 0; o < i.length; o++)
                u < r[o].length && (g[y++] = r[o][u]);
        for (u = 0; u < n; u++)
            for (o = 0; o < i.length; o++)
                u < h[o].length && (g[y++] = h[o][u]);
        return g
    }
    ;
    for (var e = {
        hm: 1,
        om: 2,
        xf: 4,
        um: 8
    }, s = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
    }, n = 0, r = 1, h = 2, o = 3, a = 4, l = 5, u = 6, c = 7, d = {
        pm: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
        dm: 1335,
        fm: 7973,
        gm: 21522,
        qf: function(t) {
            for (var i = t << 10; d.wm(i) - d.wm(d.dm) >= 0; )
                i ^= d.dm << d.wm(i) - d.wm(d.dm);
            return (t << 10 | i) ^ d.gm
        },
        Yf: function(t) {
            for (var i = t << 12; d.wm(i) - d.wm(d.fm) >= 0; )
                i ^= d.fm << d.wm(i) - d.wm(d.fm);
            return t << 12 | i
        },
        wm: function(t) {
            for (var i = 0; 0 != t; )
                i++,
                t >>>= 1;
            return i
        },
        $f: function(t) {
            return d.pm[t - 1]
        },
        Jf: function(t, i, e) {
            switch (t) {
            case n:
                return (i + e) % 2 == 0;
            case r:
                return i % 2 == 0;
            case h:
                return e % 3 == 0;
            case o:
                return (i + e) % 3 == 0;
            case a:
                return (Math.floor(i / 2) + Math.floor(e / 3)) % 2 == 0;
            case l:
                return i * e % 2 + i * e % 3 == 0;
            case u:
                return (i * e % 2 + i * e % 3) % 2 == 0;
            case c:
                return (i * e % 3 + (i + e) % 2) % 2 == 0;
            default:
                throw new Error("bad maskPattern:" + t)
            }
        },
        am: function(t) {
            for (var i = new m([1],0), e = 0; e < t; e++)
                i = i.multiply(new m([1, f.bm(e)],0));
            return i
        },
        tm: function(t, i) {
            if (1 <= i && i < 10)
                switch (t) {
                case e.hm:
                    return 10;
                case e.om:
                    return 9;
                case e.xf:
                case e.um:
                    return 8;
                default:
                    throw new Error("mode:" + t)
                }
            else if (i < 27)
                switch (t) {
                case e.hm:
                    return 12;
                case e.om:
                    return 11;
                case e.xf:
                    return 16;
                case e.um:
                    return 10;
                default:
                    throw new Error("mode:" + t)
                }
            else {
                if (!(i < 41))
                    throw new Error("type:" + i);
                switch (t) {
                case e.hm:
                    return 14;
                case e.om:
                    return 13;
                case e.xf:
                    return 16;
                case e.um:
                    return 12;
                default:
                    throw new Error("mode:" + t)
                }
            }
        },
        Bf: function(t) {
            for (var i = t.Gf(), e = 0, s = 0; s < i; s++)
                for (var n = 0; n < i; n++) {
                    for (var r = 0, h = t.kf(s, n), o = -1; o <= 1; o++)
                        if (!(s + o < 0 || i <= s + o))
                            for (var a = -1; a <= 1; a++)
                                n + a < 0 || i <= n + a || 0 == o && 0 == a || h == t.kf(s + o, n + a) && r++;
                    r > 5 && (e += 3 + r - 5)
                }
            for (s = 0; s < i - 1; s++)
                for (n = 0; n < i - 1; n++) {
                    var l = 0;
                    t.kf(s, n) && l++,
                    t.kf(s + 1, n) && l++,
                    t.kf(s, n + 1) && l++,
                    t.kf(s + 1, n + 1) && l++,
                    0 != l && 4 != l || (e += 3)
                }
            for (s = 0; s < i; s++)
                for (n = 0; n < i - 6; n++)
                    t.kf(s, n) && !t.kf(s, n + 1) && t.kf(s, n + 2) && t.kf(s, n + 3) && t.kf(s, n + 4) && !t.kf(s, n + 5) && t.kf(s, n + 6) && (e += 40);
            for (n = 0; n < i; n++)
                for (s = 0; s < i - 6; s++)
                    t.kf(s, n) && !t.kf(s + 1, n) && t.kf(s + 2, n) && t.kf(s + 3, n) && t.kf(s + 4, n) && !t.kf(s + 5, n) && t.kf(s + 6, n) && (e += 40);
            var u = 0;
            for (n = 0; n < i; n++)
                for (s = 0; s < i; s++)
                    t.kf(s, n) && u++;
            return e += 10 * (Math.abs(100 * u / i / i - 50) / 5)
        }
    }, f = {
        ym: function(t) {
            if (t < 1)
                throw new Error("glog(" + t + ")");
            return f.xm[t]
        },
        bm: function(t) {
            for (; t < 0; )
                t += 255;
            for (; t >= 256; )
                t -= 255;
            return f.Sm[t]
        },
        Sm: new Array(256),
        xm: new Array(256)
    }, p = 0; p < 8; p++)
        f.Sm[p] = 1 << p;
    for (p = 8; p < 256; p++)
        f.Sm[p] = f.Sm[p - 4] ^ f.Sm[p - 5] ^ f.Sm[p - 6] ^ f.Sm[p - 8];
    for (p = 0; p < 255; p++)
        f.xm[f.Sm[p]] = p;
    function m(t, i) {
        if (null == t.length)
            throw new Error(t.length + "/" + i);
        for (var e = 0; e < t.length && 0 == t[e]; )
            e++;
        this.Cm = new Array(t.length - e + i);
        for (var s = 0; s < t.length - e; s++)
            this.Cm[s] = t[s + e]
    }
    function w(t, i) {
        this.rm = t,
        this.im = i
    }
    function g() {
        this.buffer = [],
        this.length = 0
    }
    m.prototype = {
        get: function(t) {
            return this.Cm[t]
        },
        Pf: function() {
            return this.Cm.length
        },
        multiply: function(t) {
            for (var i = new Array(this.Pf() + t.Pf() - 1), e = 0; e < this.Pf(); e++)
                for (var s = 0; s < t.Pf(); s++)
                    i[e + s] ^= f.bm(f.ym(this.get(e)) + f.ym(t.get(s)));
            return new m(i,0)
        },
        lm: function(t) {
            if (this.Pf() - t.Pf() < 0)
                return this;
            for (var i = f.ym(this.get(0)) - f.ym(t.get(0)), e = new Array(this.Pf()), s = 0; s < this.Pf(); s++)
                e[s] = this.get(s);
            for (s = 0; s < t.Pf(); s++)
                e[s] ^= f.bm(f.ym(t.get(s)) + i);
            return new m(e,0).lm(t)
        }
    },
    w.vm = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]],
    w.Zf = function(t, i) {
        var e = w.Mm(t, i);
        if (null == e)
            throw new Error("bad rs block @ typeNumber:" + t + "/errorCorrectLevel:" + i);
        for (var s = e.length / 3, n = [], r = 0; r < s; r++)
            for (var h = e[3 * r + 0], o = e[3 * r + 1], a = e[3 * r + 2], l = 0; l < h; l++)
                n.push(new w(o,a));
        return n
    }
    ,
    w.Mm = function(t, i) {
        switch (i) {
        case s.L:
            return w.vm[4 * (t - 1) + 0];
        case s.M:
            return w.vm[4 * (t - 1) + 1];
        case s.Q:
            return w.vm[4 * (t - 1) + 2];
        case s.H:
            return w.vm[4 * (t - 1) + 3];
        default:
            return
        }
    }
    ,
    g.prototype = {
        get: function(t) {
            var i = Math.floor(t / 8);
            return 1 == (this.buffer[i] >>> 7 - t % 8 & 1)
        },
        put: function(t, i) {
            for (var e = 0; e < i; e++)
                this.sm(1 == (t >>> i - e - 1 & 1))
        },
        tm: function() {
            return this.length
        },
        sm: function(t) {
            var i = Math.floor(this.length / 8);
            this.buffer.length <= i && this.buffer.push(0),
            t && (this.buffer[i] |= 128 >>> this.length % 8),
            this.length++
        }
    };
    var y = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    var b = function() {
        var t = function(t, i) {
            this.Pm = t,
            this.Tm = i
        };
        return t.prototype.draw = function(t) {
            var i = this.Tm
              , e = this.Pm
              , s = t.Gf();
            Math.floor(i.width / s),
            Math.floor(i.height / s);
            function n(t, i) {
                var e = document.createElementNS("http://www.w3.org/2000/svg", t);
                for (var s in i)
                    i.hasOwnProperty(s) && e.setAttribute(s, i[s]);
                return e
            }
            this.clear();
            var r = n("svg", {
                viewBox: "0 0 " + String(s) + " " + String(s),
                width: "100%",
                height: "100%",
                fill: i.jm
            });
            r.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"),
            e.appendChild(r),
            r.appendChild(n("rect", {
                fill: i.jm,
                width: "100%",
                height: "100%"
            })),
            r.appendChild(n("rect", {
                fill: i.Gm,
                width: "1",
                height: "1",
                id: "template"
            }));
            for (var h = 0; h < s; h++)
                for (var o = 0; o < s; o++)
                    if (t.kf(h, o)) {
                        var a = n("use", {
                            x: String(o),
                            y: String(h)
                        });
                        a.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#template"),
                        r.appendChild(a)
                    }
        }
        ,
        t.prototype.clear = function() {
            for (; this.Pm.hasChildNodes(); )
                this.Pm.removeChild(this.Pm.lastChild)
        }
        ,
        t
    }()
      , v = "svg" === document.documentElement.tagName.toLowerCase() ? b : "undefined" == typeof CanvasRenderingContext2D ? function() {
        var t = function(t, i) {
            this.Pm = t,
            this.Tm = i
        };
        return t.prototype.draw = function(t) {
            for (var i = this.Tm, e = this.Pm, s = t.Gf(), n = Math.floor(i.width / s), r = Math.floor(i.height / s), h = ['<table style="border:0;border-collapse:collapse;">'], o = 0; o < s; o++) {
                h.push("<tr>");
                for (var a = 0; a < s; a++)
                    h.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + n + "px;height:" + r + "px;background-color:" + (t.kf(o, a) ? i.Gm : i.jm) + ';"></td>');
                h.push("</tr>")
            }
            h.push("</table>"),
            e.innerHTML = h.join("");
            var l = e.childNodes[0]
              , u = (i.width - l.offsetWidth) / 2
              , c = (i.height - l.offsetHeight) / 2;
            u > 0 && c > 0 && (l.style.margin = c + "px " + u + "px")
        }
        ,
        t.prototype.clear = function() {
            this.Pm.innerHTML = ""
        }
        ,
        t
    }() : function() {
        function t() {
            this.LTe.src = this.Om.toDataURL("image/png"),
            this.LTe.style.display = "block",
            this.Om.style.display = "none"
        }
        function i(t, i) {
            var e = this;
            if (e.BTe = i,
            e.UTe = t,
            null === e.km) {
                var s = document.createElement("img")
                  , n = function() {
                    e.km = !1,
                    e.BTe && e.BTe.call(e)
                };
                return s.onabort = n,
                s.onerror = n,
                s.onload = function() {
                    e.km = !0,
                    e.UTe && e.UTe.call(e)
                }
                ,
                void (s.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==")
            }
            !0 === e.km && e.UTe ? e.UTe.call(e) : !1 === e.km && e.BTe && e.BTe.call(e)
        }
        var e = function(t, i) {
            this.Im = !1,
            this.Tm = i,
            this.Om = document.createElement("canvas"),
            this.Om.width = i.width,
            this.Om.height = i.height,
            t.appendChild(this.Om),
            this.Pm = t,
            this.Vm = this.Om.getContext("2d"),
            this.Im = !1,
            this.LTe = document.createElement("img"),
            this.LTe.alt = "Scan me!",
            this.LTe.style.display = "none",
            this.km = null
        };
        return e.prototype.draw = function(t) {
            var i = this.LTe
              , e = this.Vm
              , s = this.Tm
              , n = t.Gf()
              , r = s.width / n
              , h = s.height / n
              , o = Math.round(r)
              , a = Math.round(h);
            i.style.display = "none",
            this.clear();
            for (var l = 0; l < n; l++)
                for (var u = 0; u < n; u++) {
                    var c = t.kf(l, u)
                      , d = u * r
                      , f = l * h;
                    e.strokeStyle = c ? s.Gm : s.jm,
                    e.lineWidth = 1,
                    e.fillStyle = c ? s.Gm : s.jm,
                    e.fillRect(d, f, r, h),
                    e.strokeRect(Math.floor(d) + .5, Math.floor(f) + .5, o, a),
                    e.strokeRect(Math.ceil(d) - .5, Math.ceil(f) - .5, o, a)
                }
            this.Im = !0
        }
        ,
        e.prototype.NTe = function() {
            this.Im && i.call(this, t)
        }
        ,
        e.prototype.Rm = function() {
            return this.Im
        }
        ,
        e.prototype.clear = function() {
            this.Vm.clearRect(0, 0, this.Om.width, this.Om.height),
            this.Im = !1
        }
        ,
        e.prototype.round = function(t) {
            return t ? Math.floor(1e3 * t) / 1e3 : t
        }
        ,
        e
    }();
    function S(t, i) {
        for (var e = 1, n = function(t) {
            var i = encodeURI(t).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
            return i.length + (i.length != t ? 3 : 0)
        }(t), r = 0, h = y.length; r <= h; r++) {
            var o = 0;
            switch (i) {
            case s.L:
                o = y[r][0];
                break;
            case s.M:
                o = y[r][1];
                break;
            case s.Q:
                o = y[r][2];
                break;
            case s.H:
                o = y[r][3]
            }
            if (n <= o)
                break;
            e++
        }
        if (e > y.length)
            throw new Error("Too long data");
        return e
    }
    self.lf = function(t, i) {
        if (this.Tm = {
            width: 256,
            height: 256,
            Cf: 4,
            Gm: "#000000",
            jm: "#ffffff",
            gf: s.H
        },
        "string" == typeof i && (i = {
            text: i
        }),
        i)
            for (var e in i)
                this.Tm[e] = i[e];
        "string" == typeof t && (t = document.getElementById(t)),
        this.Tm.jTe && (v = b),
        this.Pm = t,
        this._m = null,
        this.Dm = new v(this.Pm,this.Tm),
        this.Tm.text && this.Lm(this.Tm.text)
    }
    ,
    self.lf.prototype.Lm = function(t) {
        this._m = new i(S(t, this.Tm.gf),this.Tm.gf),
        this._m.Vf(t),
        this._m.jf(),
        this.Dm.draw(this._m)
    }
    ,
    self.lf.prototype.NTe = function() {
        "function" == typeof this.Dm.NTe && this.Dm.NTe()
    }
    ,
    self.lf.prototype.clear = function() {
        this.Dm.clear()
    }
    ,
    self.lf.yf = s
}();
{
    let Xr = !1
      , Yr = !1
      , Jr = "dev";
    const Zr = []
      , Qr = self.t = class {
        constructor() {
            throw TypeError("static class can't be instantiated")
        }
        static $Te() {
            Xr = !0
        }
        static yc() {
            return Xr
        }
        static zTe() {
            Yr = !0
        }
        static VTe() {
            return Yr
        }
        static WTe(t) {
            Jr = t
        }
        static HTe() {
            return Jr
        }
        static jii() {
            return "final" === Jr
        }
        static KTe(t) {
            Zr.push(t)
        }
        static qTe() {
            return Zr
        }
    }
    ;
    Qr.Vl = !1,
    Qr.XTe = !1,
    Qr.j_t = !1,
    Qr.hardwareConcurrency = navigator.hardwareConcurrency || 2,
    self.YTe = {}
}
{
    const th = self.t;
    th.JTe = class {
        constructor(t) {
            this.ZTe = t,
            this.tqs = new Map,
            this.G3s()
        }
        G3s() {
            let t = this.ZTe;
            (t.startsWith("?") || t.startsWith("#")) && (t = t.substr(1));
            const i = t.split("&");
            for (const t of i)
                this.QTe(t)
        }
        QTe(t) {
            if (!t)
                return;
            if (!t.includes("="))
                return void this.tqs.set(t, null);
            const i = t.indexOf("=")
              , e = decodeURIComponent(t.substring(0, i))
              , s = decodeURIComponent(t.substring(i + 1));
            this.tqs.set(e, s)
        }
        MRe() {
            for (const t of this.tqs)
                console.log("[QueryParser] Parameter '" + t[0] + "' = " + (null === t[1] ? "null" : "'" + t[1] + "'"))
        }
        lVs(t) {
            return this.tqs.has(t)
        }
        $s(t) {
            const i = this.tqs.get(t);
            return void 0 === i ? null : i
        }
        IRe() {
            history.replaceState("", document.title, location.pathname + location.search)
        }
        GRe(t) {
            this.ZTe = t,
            this.tqs.clear(),
            this.G3s()
        }
    }
    ,
    th.M9s = new th.JTe(location.search),
    th.DRe = new th.JTe(location.hash),
    th.M9s.lVs("perf") && (th.j_t = !0),
    "dev" !== th.M9s.$s("mode") && th.WTe("final")
}
{
    const ih = self.t
      , eh = "(unknown)";
    ih.kt = {
        OS: eh,
        LRe: eh,
        Nr: eh,
        BRe: eh,
        URe: NaN,
        NRe: eh,
        Tj: "browser",
        lA: !0,
        mj: !1,
        w$t: !1,
        V7i: !1,
        $Re: async () => {}
    };
    const sh = new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
    function nh(t) {
        const i = parseFloat(t)
          , e = sh.get(i);
        return e || (i >= 13 ? "11" : "NT " + t)
    }
    const rh = navigator.userAgent
      , hh = navigator.userAgentData;
    if (hh && hh.brands.length > 0) {
        ih.kt.OS = hh.platform,
        ih.kt.mj = hh.mobile,
        ih.kt.lA = !ih.kt.mj;
        const oh = new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]])
          , ah = new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
        function lh(t) {
            let i = ""
              , e = ""
              , s = ""
              , n = "";
            for (const r of t) {
                const t = oh.get(r.brand);
                !i && t && (i = t,
                e = r.version);
                const h = ah.get(r.brand);
                !s && h && (s = h,
                n = r.version)
            }
            i || "Chromium" !== s || (ih.kt.Nr = "Chromium",
            ih.kt.BRe = n),
            ih.kt.Nr = i || eh,
            ih.kt.BRe = e || eh,
            ih.kt.NRe = s || eh
        }
        lh(hh.brands);
        let uh = !1;
        ih.kt.$Re = async () => {
            if (!uh)
                try {
                    const t = await navigator.userAgentData.getHighEntropyValues(["platformVersion", "fullVersionList"]);
                    lh(t.fullVersionList),
                    "Windows" === ih.kt.OS ? ih.kt.LRe = nh(t.platformVersion) : ih.kt.LRe = t.platformVersion,
                    uh = !0
                } catch (t) {
                    (() => {})("Failed to get detailed user agent information: ", t)
                }
        }
    } else {
        function ch(t, i) {
            const e = Array.isArray(t) ? t : [t];
            for (const t of e) {
                const e = t.exec(rh);
                if (e) {
                    i(e);
                    break
                }
            }
        }
        ch(/windows\s+nt\s+([\d\.]+)/i, t => {
            ih.kt.OS = "Windows";
            const i = t[1];
            ih.kt.LRe = nh(i)
        }
        ),
        ch(/mac\s+os\s+x\s+([\d\._]+)/i, t => {
            ih.kt.OS = "macOS",
            ih.kt.LRe = t[1].replace(/_/g, ".")
        }
        ),
        ch(/CrOS/, () => {
            ih.kt.OS = "Chrome OS"
        }
        ),
        ch(/linux|openbsd|freebsd|netbsd/i, () => {
            ih.kt.OS = "Linux"
        }
        ),
        ch(/android/i, () => {
            ih.kt.OS = "Android"
        }
        ),
        ch(/android\s+([\d\.]+)/i, t => {
            ih.kt.OS = "Android",
            ih.kt.LRe = t[1]
        }
        ),
        ih.kt.OS === eh && (ch(/(iphone|ipod|ipad)/i, t => {
            ih.kt.OS = "iOS"
        }
        ),
        ch([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], t => {
            ih.kt.OS = "iOS",
            ih.kt.LRe = t[1].replace(/_/g, ".")
        }
        ));
        const dh = /chrome\//i.test(rh)
          , fh = /chromium\//i.test(rh)
          , ph = /edg\//i.test(rh)
          , mh = /OPR\//.test(rh)
          , wh = /nwjs/i.test(rh)
          , gh = /safari\//i.test(rh)
          , yh = /webkit/i.test(rh);
        ph || mh || ch(/chrome\/([\d\.]+)/i, t => {
            ih.kt.Nr = "Chrome",
            ih.kt.BRe = t[1],
            ih.kt.NRe = "Chromium"
        }
        ),
        ch(/edg\/([\d\.]+)/i, t => {
            ih.kt.Nr = "Edge",
            ih.kt.BRe = t[1],
            ih.kt.NRe = "Chromium"
        }
        ),
        ch(/OPR\/([\d\.]+)/, t => {
            ih.kt.Nr = "Opera",
            ih.kt.BRe = t[1],
            ih.kt.NRe = "Chromium"
        }
        ),
        ch(/chromium\/([\d\.]+)/i, t => {
            ih.kt.Nr = "Chromium",
            ih.kt.BRe = t[1],
            ih.kt.NRe = "Chromium"
        }
        ),
        ch(/nwjs\/[0-9.]+/i, t => {
            ih.kt.Nr = "NW.js",
            ih.kt.BRe = t[1],
            ih.kt.NRe = "Chromium",
            ih.kt.Tj = "nwjs"
        }
        ),
        ch(/firefox\/([\d\.]+)/i, t => {
            ih.kt.Nr = "Firefox",
            ih.kt.BRe = t[1],
            ih.kt.NRe = "Gecko"
        }
        ),
        !gh || dh || fh || ph || mh || wh || (ih.kt.Nr = "Safari",
        ih.kt.NRe = "WebKit",
        ch(/version\/([\d\.]+)/i, t => {
            ih.kt.BRe = t[1]
        }
        ),
        ch(/crios\/([\d\.]+)/i, t => {
            ih.kt.Nr = "Chrome for iOS",
            ih.kt.BRe = t[1]
        }
        ),
        ch(/fxios\/([\d\.]+)/i, t => {
            ih.kt.Nr = "Firefox for iOS",
            ih.kt.BRe = t[1]
        }
        ),
        ch(/edgios\/([\d\.]+)/i, t => {
            ih.kt.Nr = "Edge for iOS",
            ih.kt.BRe = t[1]
        }
        )),
        ih.kt.NRe === eh && yh && (ih.kt.NRe = "WebKit"),
        "Android" === ih.kt.OS && "Safari" === ih.kt.Nr && (ih.kt.Nr = "Stock");
        const bh = new Set(["Windows", "macOS", "Linux", "Chrome OS"]).has(ih.kt.OS) || "nwjs" === ih.kt.Tj;
        ih.kt.lA = bh,
        ih.kt.mj = !bh
    }
    "Chrome" === ih.kt.Nr && "browser" === ih.kt.Tj && /wv\)/.test(rh) && (ih.kt.Tj = "webview"),
    "nwjs" !== ih.kt.Tj && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (ih.kt.Tj = "webapp"),
    ih.kt.URe = parseFloat(ih.kt.BRe);
    "macOS" === ih.kt.OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && (ih.kt.OS = "iOS",
    ih.kt.LRe = ih.kt.BRe,
    ih.kt.lA = !1,
    ih.kt.mj = !0,
    ih.kt.V7i = !0),
    ih.kt.w$t = "macOS" === ih.kt.OS || "iOS" === ih.kt.OS
}
{
    const vh = self.t;
    vh.Vl = !vh.jii() && vh.M9s.lVs("debug"),
    vh.XTe = !vh.jii() && vh.M9s.lVs("debug-defend"),
    vh.XTe && (vh.Vl = !0);
    let Sh = !1;
    function xh(t) {
        let i = vh.zRe()
          , e = "Assertion failure: " + t + "\n\nStack trace:\n" + i;
        if (console.error(e),
        !Sh) {
            Sh = !0,
            vh.qs.Ys.$s("CrashReport").Qa("assertion failure", {
                stack: i,
                message: t
            }, document.body)
        }
    }
    window.assert = function(t, i) {
        t || xh(i)
    }
}
{
    const Mh = self.t;
    String.prototype.replaceAll || (String.prototype.replaceAll = function(t, i) {
        return this.replace(new RegExp(Mh.VRe(t),"g"), i)
    }
    ),
    Array.prototype.at || (Array.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length),
        !(t < 0 || t >= this.length))
            return this[t]
    }
    ),
    String.prototype.at || (String.prototype.at = function(t) {
        if ((t = Math.trunc(t) || 0) < 0 && (t += this.length),
        !(t < 0 || t >= this.length))
            return this[t]
    }
    ),
    RegExp.escape || (RegExp.escape = function(t) {
        return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
    }
    ),
    Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {
        if (!(t instanceof Set))
            throw new TypeError("argument must be a Set");
        for (const i of this)
            if (!t.has(i))
                return !1;
        return !0
    }
    ),
    navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
        return new Promise( (t, i) => navigator.webkitTemporaryStorage.queryUsageAndQuota( (i, e) => t({
            usage: i,
            quota: e
        }), i))
    }
    )
}
{
    const Eh = self.t;
    if (Eh.zk = {},
    Eh.zk.WRe = ( () => {
        try {
            if ("undefined" == typeof document)
                return !1;
            const t = document.createElement("div");
            if (void 0 === t.animate)
                return !1;
            return void 0 !== t.animate([{
                opacity: "0"
            }, {
                opacity: "1"
            }], 1e3).reverse
        } catch (t) {
            return !1
        }
    }
    )(),
    Eh.zk.R$i = "undefined" != typeof HTMLDialogElement,
    Eh.zk.HRe = !!self.requestIdleCallback,
    Eh.zk.ImageBitmap = !!self.createImageBitmap,
    Eh.zk.Qhs = !1,
    Eh.zk.KRe = !1,
    Eh.zk.ImageBitmap) {
        try {
            self.createImageBitmap(new ImageData(32,32), {
                premultiplyAlpha: "none"
            }).then( () => {
                Eh.zk.Qhs = !0
            }
            ).catch( () => {
                Eh.zk.Qhs = !1
            }
            )
        } catch (Ch) {
            Eh.zk.Qhs = !1
        }
        try {
            self.createImageBitmap(new ImageData(32,32), {
                resizeWidth: 10,
                resizeHeight: 10
            }).then(t => {
                Eh.zk.KRe = 10 === t.width && 10 === t.height
            }
            ).catch( () => {
                Eh.zk.KRe = !1
            }
            )
        } catch (_h) {
            Eh.zk.KRe = !1
        }
    }
    if (Eh.zk.qRe = !(!navigator.clipboard || !navigator.clipboard.readText),
    Eh.zk.S6i = !(!navigator.permissions || !navigator.permissions.query),
    Eh.zk.t6i = !1,
    Eh.zk.S6i) {
        const Th = {
            name: "clipboard-read"
        };
        navigator.permissions.query(Th).then( () => {
            Eh.zk.t6i = !0
        }
        ).catch( () => {
            Eh.zk.t6i = !1
        }
        )
    }
    Eh.zk.s6i = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem),
    Eh.zk.XRe = "undefined" != typeof Proxy,
    Eh.zk.YRe = ( () => {
        if ("undefined" == typeof document)
            return !1;
        return void 0 !== document.createElement("a").download
    }
    )(),
    Eh.zk.JRe = "function" == typeof fetch,
    Eh.zk.ZRe = !!(self.isSecureContext && "Opera" !== Eh.kt.Nr && navigator.storage && navigator.storage.persist),
    Eh.zk.QRe = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate),
    Eh.zk.Uj = ( () => {
        if ("undefined" == typeof document)
            return !1;
        if ("iOS" === Eh.kt.OS)
            return !1;
        const t = document.documentElement;
        return !!(t.requestFullscreen || t.msRequestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullscreen)
    }
    )(),
    Eh.zk.ImageDecoder = void 0 !== self.ImageDecoder,
    Eh.zk.ike = !!self.VideoEncoder,
    Eh.zk.Lk = !!self.showOpenFilePicker,
    Eh.zk.eke = !!self.queryLocalFonts,
    Eh.zk.UserActivation = !!navigator.userActivation,
    Eh.zk.jPe = !1,
    (async () => {
        let t;
        "undefined" == typeof document ? t = new OffscreenCanvas(32,32) : (t = document.createElement("canvas"),
        t.width = 32,
        t.height = 32);
        const i = t.getContext("2d");
        i.fillStyle = "blue",
        i.fillRect(0, 0, 32, 32);
        let e = null;
        try {
            t.convertToBlob ? e = await t.convertToBlob({
                type: "image/webp",
                quality: 1
            }) : t.toBlob && (e = await new Promise(i => t.toBlob(i, "image/webp", 1))),
            Eh.zk.jPe = e && "image/webp" === e.type
        } catch (t) {
            Eh.zk.jPe = !1
        }
    }
    )()
}
{
    const Ih = self.t
      , Ph = self.YTe;
    Ih.nke = function(t) {
        return "number" == typeof t
    }
    ,
    Ih.Go = function(t) {
        return Ih.nke(t) && isFinite(t)
    }
    ,
    Ih.VY = function(t) {
        if (!Ih.nke(t))
            throw new TypeError("expected number")
    }
    ,
    Ih.U6 = function(t) {
        Ih.fO(t) || Ih.VY(t)
    }
    ,
    Ih.rke = function(t, i, e) {
        if (!Ih.nke(t) || isNaN(t) || i > t || e < t)
            throw new RangeError("number outside of range")
    }
    ,
    Ih.hke = function(...t) {
        for (let i of t)
            Ih.VY(i)
    }
    ,
    Ih.Ge = function(t) {
        if (!Ih.Go(t))
            throw new TypeError("expected finite number")
    }
    ,
    Ih.cO = function(t) {
        Ih.fO(t) || Ih.Ge(t)
    }
    ,
    Ih.zms = function(...t) {
        for (let i of t)
            Ih.Ge(i)
    }
    ,
    Ih.doe = function(t) {
        return "string" == typeof t
    }
    ,
    Ih.zt = function(t) {
        if (!Ih.doe(t))
            throw new TypeError("expected string")
    }
    ,
    Ih.Kq = function(t) {
        Ih.fO(t) || Ih.zt(t)
    }
    ,
    Ih.oke = function(...t) {
        for (let i of t)
            Ih.zt(i)
    }
    ,
    Ih.Ots = function(t) {
        if ("object" != typeof t || null === t)
            return !1;
        let i = Object.getPrototypeOf(t);
        return i ? i.constructor === Object : null === i
    }
    ,
    Ih.Hut = function(t) {
        if (!Ih.Ots(t))
            throw new TypeError("expected simple object")
    }
    ,
    Ih._U = function(t) {
        if (!Ih.fO(t) && !Ih.Ots(t))
            throw new TypeError("expected simple object")
    }
    ,
    Ih.$nt = function(t) {
        return "object" == typeof t && null !== t && !Array.isArray(t)
    }
    ,
    Ih.Yq = function(t) {
        if (!Ih.$nt(t))
            throw new TypeError("expected object")
    }
    ,
    Ih.Wat = function(t) {
        Ih.fO(t) || Ih.Yq(t)
    }
    ,
    Ih.MNs = function(...t) {
        for (let i of t)
            Ih.Yq(i)
    }
    ,
    Ih.g2t = function(t) {
        return Ih.ake(t, Blob) && "string" == typeof t.name
    }
    ,
    Ih.e0t = function(t) {
        if (!Ih.g2t(t))
            throw new TypeError("expected file")
    }
    ,
    Ih.DBt = function(t) {
        Ih.fO(t) || Ih.e0t(t)
    }
    ,
    Ih.kft = function(t) {
        return Array.isArray(t)
    }
    ,
    Ih._D = function(t) {
        if (!Ih.kft(t))
            throw new TypeError("expected array")
    }
    ,
    Ih.zAt = function(t) {
        Ih.fO(t) || Ih._D(t)
    }
    ,
    Ih.lke = function(...t) {
        for (let i of t)
            Ih._D(i)
    }
    ,
    Ih.KRt = function(t) {
        return !!Ih.kft(t) && (!t.length || !!Ih.kft(t[0]))
    }
    ,
    Ih.oO = function(t) {
        if (!Ih.KRt(t))
            throw new TypeError("expected 2d array");
        for (let i of t)
            if (!Ih.kft(i))
                throw new TypeError("expected 2d array")
    }
    ,
    Ih.dO = function(t) {
        Ih.fO(t) || Ih.oO(t)
    }
    ,
    Ih.XOt = function(t) {
        return "function" == typeof t
    }
    ,
    Ih.qd = function(t, i) {
        if (!Ih.XOt(t))
            throw new TypeError("expected function");
        if (!Ih.fO(i) && t !== i)
            throw new TypeError("expected same function reference")
    }
    ,
    Ih.X_t = function(t) {
        Ih.fO(t) || Ih.qd(t)
    }
    ,
    Ih.uke = function(...t) {
        for (let i of t)
            Ih.qd(i)
    }
    ,
    Ih.YQi = function(t, ...i) {
        if (!Ih.XOt(t))
            throw new TypeError("expected function");
        if (!i.length)
            throw new Error("missing comparison functions");
        for (let e of i)
            if (!Ih.fO(e) && t === e)
                return;
        throw new TypeError("expected same function reference")
    }
    ,
    Ih.w2i = function(...t) {
        if (!Ih.fO(t))
            for (let i of t)
                Ih.X_t(i)
    }
    ,
    Ih.$l = function(t, i) {
        return t instanceof i
    }
    ,
    Ih.GH = function(t, ...i) {
        for (let e of i)
            if (Ih.$l(t, e))
                return !0;
        return !1
    }
    ,
    Ih.U = function(t, i) {
        if (!Ih.$l(t, i))
            throw new TypeError("unexpected type")
    }
    ,
    Ih.Mw = function(t, i) {
        Ih.fO(t) || Ih.U(t, i)
    }
    ,
    Ih.Hms = function(t, ...i) {
        for (let e of i)
            Ih.U(e, t)
    }
    ,
    Ih.cT = function(t, ...i) {
        if (!Ih.GH(t, ...i))
            throw new TypeError("unexpected type")
    }
    ,
    Ih.a_ = function(t, ...i) {
        if (!Ih.fO(t) && !Ih.GH(t, ...i))
            throw new TypeError("unexpected type")
    }
    ,
    Ih.nte = function(t, i) {
        Ih._D(t);
        for (let e of t)
            if (!Ih.$l(e, i))
                return !1;
        return !0
    }
    ,
    Ih.$ms = function(t) {
        Ih._D(t);
        for (let i of t)
            if (!Ih.Go(i))
                return !1;
        return !0
    }
    ,
    Ih.YJ = function(t, i) {
        Ih._D(t);
        for (let e of t)
            Ih.U(e, i)
    }
    ,
    Ih.E$ = function(t, i) {
        if (!Ih.fO(t)) {
            Ih._D(t);
            for (let e of t)
                Ih.U(e, i)
        }
    }
    ,
    Ih.cke = function(t, i) {
        if (!Ih.fO(t)) {
            Ih._D(t);
            for (let e of t)
                Ih.qd(e, i)
        }
    }
    ,
    Ih.KQi = function(t, ...i) {
        Ih._D(t);
        for (let e of t)
            Ih.cT(e, ...i)
    }
    ,
    Ih.tli = function(t, ...i) {
        if (!Ih.fO(t)) {
            Ih._D(t);
            for (let e of t)
                Ih.cT(e, ...i)
        }
    }
    ,
    Ih.dke = function(t, i) {
        return !(Ih.fO(t) || !Ih.doe(t.nodeName)) && (!i || Ih._x(t.nodeName, i))
    }
    ,
    Ih.rAe = function(t, i) {
        if (Ih.fO(t) || !Ih.doe(t.nodeName))
            throw new TypeError("expected DOM node");
        if (i && !Ih._x(t.nodeName, i))
            throw new TypeError(`expected DOM '${i}' node`)
    }
    ,
    Ih.fke = function(t, i) {
        Ih.fO(t) || Ih.rAe(t, i)
    }
    ,
    Ih.Vmi = function(t, i) {
        return !(Ih.fO(t) || !Ih.doe(t.tagName)) && (!i || Ih._x(t.tagName, i))
    }
    ,
    Ih.zlt = function(t, i) {
        if (Ih.fO(t) || !Ih.doe(t.tagName))
            throw new TypeError("expected HTML element");
        if (i && !Ih._x(t.tagName, i))
            throw new TypeError(`expected HTML '${i}' element`)
    }
    ,
    Ih.Hdt = function(t, i) {
        Ih.fO(t) || Ih.zlt(t, i)
    }
    ,
    Ih.pke = function(t) {
        return Ih.Vmi(t, "img") || Ih.Vmi(t, "canvas") || Ih.Vmi(t, "video") || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap
    }
    ,
    Ih.cwi = function(t) {
        if (!Ih.pke(t))
            throw new TypeError("expected drawable")
    }
    ,
    Ih.BM = function(t) {
        Ih.fO(t) || Ih.cwi(t)
    }
    ,
    Ih.mke = function(t) {
        return t instanceof ImageData || Ih.pke(t)
    }
    ,
    Ih.aBi = function(t) {
        if (!Ih.mke(t))
            throw new TypeError("expected drawable or image data")
    }
    ,
    Ih.Cxi = function(t) {
        if (!Ih.fO(t) && !Ih.mke(t))
            throw new TypeError("expected drawable or image data")
    }
    ,
    Ih.wke = function(t) {
        return "string" == typeof t || Ih.gke && t instanceof Ih.gke || t instanceof Ih.MC
    }
    ,
    Ih.u7t = function(t) {
        if (!Ih.wke(t))
            throw new TypeError("expected string-like")
    }
    ,
    Ih.yke = function(t) {
        Ih.fO(t) || Ih.u7t(t)
    }
    ,
    Ih.bke = function(...t) {
        for (let i of t)
            Ih.u7t(i)
    }
    ,
    Ih.E4 = function() {
        throw new Error("must be overridden")
    }
    ,
    Ih.Gks = function() {
        throw new Error("not yet implemented")
    }
    ,
    Ih.vke = function(t) {
        return t.constructor === function*() {}
        .constructor
    }
    ,
    Ih.Ske = function(t) {
        if (!Ih.vke(t))
            throw new Error("expected generator function")
    }
    ,
    Ih.xke = function(t) {
        return "function" === t[Symbol.iterator]
    }
    ,
    Ih.Mke = function(t) {
        if (!Ih.xke(t))
            throw new Error("expected iterable")
    }
    ,
    Ih.Dee = function(t) {
        return !Ih.fO(t)
    }
    ,
    Ih.fO = function(t) {
        return null == t
    }
    ,
    Ih.zce = function(t) {
        Ih._D(t);
        let i = t[0].constructor;
        for (let e of t)
            if (e.constructor !== i)
                return !1;
        return i
    }
    ,
    Ih.wft = function(t, i) {
        Ih._D(t);
        for (let e of t)
            if (!(e instanceof i))
                return !1;
        return !0
    }
    ;
    const Gh = Object.getPrototypeOf(Uint8Array);
    Ih.Eke = function(t) {
        return Ih.$l(t, Gh)
    }
    ,
    Ih.Cke = function(t) {
        Ih.U(t, Gh)
    }
    ,
    Ih._ke = function(t) {
        Ih.Tke(t, Gh)
    }
    ,
    Ih.Ike = function(t, ...i) {
        if (!Ih.Pke(t, ...i))
            throw new TypeError("unexpected type")
    }
    ,
    Ih.Pke = function(t, ...i) {
        for (const e of i)
            if (Ih.ake(t, e))
                return !0;
        return !1
    }
    ,
    Ih.Tke = function(t, i) {
        if (!Ih.ake(t, i))
            throw new TypeError("unexpected type")
    }
    ,
    Ih.ake = function(t, i) {
        for (; t = Object.getPrototypeOf(t); )
            if (t.constructor.name === i.name)
                return !0;
        return !1
    }
    ,
    Ph.VY = Ih.VY,
    Ph.U6 = Ih.U6,
    Ph.Ge = Ih.Ge,
    Ph.cO = Ih.cO,
    Ph.zt = Ih.zt,
    Ph.Kq = Ih.Kq,
    Ph.Yq = Ih.Yq,
    Ph.Wat = Ih.Wat,
    Ph._D = Ih._D,
    Ph.zAt = Ih.zAt,
    Ph.qd = Ih.qd,
    Ph.X_t = Ih.X_t,
    Ph.U = Ih.U,
    Ph.Mw = Ih.Mw,
    Ph.fO = Ih.fO
}
{
    const Ah = self.t
      , Rh = new Set(["con", "prn", "aux", "nul", "com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9", "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"])
      , kh = new Set(["\\", "/", ":", "*", "?", '"', "<", ">", "|", "~"])
      , Oh = new Set(["."])
      , Dh = new Set(["."])
      , Fh = 200;
    Ah.ZJs = function() {
        return Fh
    }
    ,
    Ah.Mes = function(t) {
        if (Ah.zt(t),
        !t)
            return !1;
        const i = [...t.normalize()];
        return !(i.length >= Fh) && (!i.some(t => kh.has(t)) && (!Oh.has(i[0]) && !Ah.Ues(i[0]) && (!Dh.has(i.at(-1)) && !Ah.Ues(i.at(-1)) && !Ah.vas(t))))
    }
    ,
    Ah.Fms = function(t, i=!0) {
        Ah.zt(t);
        const e = [...t.normalize()];
        if (Ah.ote(e, t => kh.has(t)),
        i)
            for (; e.length && (Dh.has(e.at(-1)) || Ah.Ues(e.at(-1))); )
                e.pop();
        for (; e.length && (Oh.has(e[0]) || Ah.Ues(e[0])); )
            e.shift();
        return e.length > Fh && Ah.yp(e, Fh),
        e.join("")
    }
    ,
    Ah.OAs = function(t, i="file") {
        const e = t.lastIndexOf(".");
        let s = -1 === e ? t : t.substr(0, e);
        const n = -1 === e ? "" : t.substr(e);
        return s = Ah.Fms(s, !1),
        s && !Ah.vas(s) || (s = i),
        s + n
    }
    ,
    Ah.Des = function(t, i="folder") {
        return !(t = Ah.Fms(t)) || Ah.vas(t) ? i : t
    }
    ,
    Ah.vas = function(t) {
        return Ah.zt(t),
        Rh.has(t.toLowerCase())
    }
}
{
    const Lh = self.t;
    let Bh = null
      , Uh = "";
    if ("undefined" != typeof document) {
        Bh = document;
        const Wh = document.querySelector("base");
        Uh = Wh && Wh.hasAttribute("href") ? Wh.getAttribute("href") : "",
        Uh && (Uh.startsWith("/") && (Uh = Uh.substr(1)),
        Uh.endsWith("/") || (Uh += "/"))
    }
    Lh.Gke = function() {
        return Uh
    }
    ,
    Lh.sh = function() {
        if (!Bh)
            return "";
        const t = Bh.location;
        return Lh.tk(t.origin + t.pathname) + Uh
    }
    ,
    Lh.tk = function(t) {
        if (Lh.zt(t),
        !t.length)
            return t;
        if (t.endsWith("/") || t.endsWith("\\"))
            return t;
        const i = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === i ? "" : t.substr(0, i + 1)
    }
    ,
    Lh.des = function(t) {
        if (Lh.zt(t),
        !t.length)
            return t;
        if (t.endsWith("/") || t.endsWith("\\"))
            return "";
        const i = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return -1 === i ? t : t.substr(i + 1)
    }
    ,
    Lh.Uh = function(t) {
        Lh.zt(t);
        let i = t.lastIndexOf(".");
        return i < 1 ? "" : t.substr(i)
    }
    ,
    Lh.JAs = function(t, i) {
        Lh.zt(t),
        Lh.zt(i);
        const e = t.lastIndexOf(".");
        return -1 === e ? t + "." + i : t.substr(0, e + 1) + i
    }
    ,
    Lh.EU = function(t) {
        let i = t.lastIndexOf(".");
        return i < 1 ? t : t.substr(0, i)
    }
    ,
    Lh.Ake = function(t) {
        return t.replace(/\\/g, "/")
    }
    ,
    Lh.Rke = function(t, i) {
        return i === (t ? Lh.Uh(t).slice(1) : "")
    }
    ,
    Lh.kke = function(t, i) {
        let e, s;
        return Lh.g2t(t) && (e = Lh.EU(t.name)),
        Lh.doe(t) && (e = Lh.EU(t)),
        Lh.g2t(i) && (s = Lh.EU(i.name)),
        Lh.doe(i) && (s = Lh.EU(i)),
        e === s
    }
    ,
    Lh._ye = function(t) {
        t = Lh.Ake(t);
        let i = /^\w\:\//.exec(t);
        i ? (i = i[0],
        "/" !== (t = t.slice(3))[0] && (t = "/" + t)) : i = "",
        (t = t.replace(/\/{2,}/g, "/")).length > 1 && "/" === t.slice(-1) && (t = t.slice(0, -1));
        const e = t.lastIndexOf("/") + 1;
        let s, n = "", r = t, h = "";
        e > 0 && (n = t.slice(0, e),
        r = t.slice(e)),
        s = r;
        const o = r.lastIndexOf(".");
        o > 0 && (h = r.slice(o),
        s = r.slice(0, -h.length));
        return {
            dir: n,
            xye: r,
            name: s,
            root: i,
            ext: h,
            Oke: i + n + r
        }
    }
    ,
    Lh.KTi = function(t, i) {
        return Lh.Ge(t),
        new Promise( (e, s) => {
            self.setTimeout(e, t, i)
        }
        )
    }
    ,
    Lh.Dke = function(t) {
        Lh.qd(t);
        try {
            t()
        } catch (t) {
            Lh.Vl && (() => {})("Swallowed exception: ", t)
        }
    }
    ,
    Lh.Gv = function() {}
    ,
    Lh._x = function(t, i) {
        return Lh.Kq(t),
        Lh.Kq(i),
        "string" == typeof t && "string" == typeof i && (t === i || t.normalize().toLowerCase() === i.normalize().toLowerCase())
    }
    ,
    Lh.Fke = function(t, i) {
        return Lh.Kq(t),
        Lh.Kq(i),
        "string" == typeof t && "string" == typeof i && (t === i || t.normalize() === i.normalize())
    }
    ,
    Lh.Lke = function(t, i, e) {
        t[e++] = i[0],
        t[e++] = i[1],
        t[e++] = i[2],
        t[e++] = i[3],
        t[e++] = i[4],
        t[e++] = i[5],
        t[e++] = i[6],
        t[e++] = i[7],
        t[e++] = i[8],
        t[e++] = i[9],
        t[e++] = i[10],
        t[e++] = i[11],
        t[e++] = i[12],
        t[e++] = i[13],
        t[e++] = i[14],
        t[e] = i[15]
    }
    ,
    Lh.yp = function(t, i) {
        Lh._D(t),
        Lh.Ge(i),
        t.length = i
    }
    ,
    Lh.sc = function(t) {
        Lh.zAt(t),
        t && 0 !== t.length && Lh.yp(t, 0)
    }
    ,
    Lh.szt = function(t) {
        if (Lh.dO(t),
        t) {
            for (let i = 0; i < t.length; i++) {
                let e = t[i];
                Lh.yp(e, 0)
            }
            Lh.yp(t, 0)
        }
    }
    ,
    Lh.f9s = function(t, i, e) {
        Lh._D(t),
        Lh.Ge(i),
        i |= 0;
        const s = t.length;
        if (!(i <= s))
            for (let n = s; n < i; ++n)
                t.push(e)
    }
    ,
    Lh.pI = function(t, i, e) {
        Lh._D(t),
        Lh.Ge(i),
        i |= 0;
        const s = t.length;
        i < s ? Lh.yp(t, i) : i > s && Lh.f9s(t, i, e)
    }
    ,
    Lh.lw = function(t, i) {
        Lh._D(t),
        Lh._D(i),
        Lh.sc(t),
        Lh.bp(t, i)
    }
    ,
    Lh.bp = function(t, i) {
        if (Lh._D(t),
        Lh._D(i),
        i.length < 1e4)
            t.push(...i);
        else
            for (let e = 0, s = i.length; e < s; ++e)
                t.push(i[e])
    }
    ,
    Lh.Bke = function(t, i) {
        if ((i = Math.floor(i)) < 0 || i >= t.length)
            return;
        let e = t.length - 1;
        for (let s = i; s < e; ++s)
            t[s] = t[s + 1];
        Lh.yp(t, e)
    }
    ,
    Lh.sni = function(t, i) {
        Lh._D(t);
        let e = t.indexOf(i);
        e >= 0 && t.splice(e, 1)
    }
    ,
    Lh.lSt = function(t, i) {
        Lh._D(t),
        Lh._D(i);
        let e = t.length;
        if (i.length !== e)
            return !1;
        for (let s = 0; s < e; ++s)
            if (t[s] !== i[s])
                return !1;
        return !0
    }
    ,
    Lh.ote = function(t, i) {
        Lh._D(t),
        Lh.qd(i);
        let e = []
          , s = 0;
        for (let n = 0, r = t.length; n < r; ++n) {
            let r = t[n];
            i(r) ? e.push(r) : (t[s] = r,
            ++s)
        }
        return Lh.yp(t, s),
        e
    }
    ,
    Lh.spt = function(t, i) {
        Lh._D(t),
        Lh.U(i, Set);
        const e = t.length;
        let s = 0;
        for (let e = 0, n = t.length; e < n; ++e) {
            let n = t[e];
            i.has(n) || (t[s++] = n)
        }
        return Lh.yp(t, s),
        e - s
    }
    ,
    Lh.Uke = function(t, i) {
        return t === Math.floor(t) && (t >= 0 && t < i.length)
    }
    ,
    Lh.Qws = function(t, i) {
        if (!Lh.Uke(t, i))
            throw new RangeError("array index out of bounds")
    }
    ,
    Lh.PC = function(t) {
        return t.slice()
    }
    ,
    Lh.QRt = function(t, i) {
        Lh._D(t),
        Lh.qd(i);
        let e = [];
        for (let s of t)
            if (Lh.$nt(s)) {
                let t = i(s);
                if (!t)
                    throw new Error("missing clone");
                if (t.constructor !== s.constructor)
                    throw new Error("object is not a clone");
                e.push(t)
            } else
                Lh.kft(s) ? e.push(Lh.QRt(s, i)) : e.push(s);
        return e
    }
    ,
    Lh.tzt = function(t) {
        Lh.oO(t);
        let i = [];
        for (let e of t)
            i.push(e.slice());
        return i
    }
    ,
    Lh.Ygs = function(t, i=" ") {
        return t ? t.split(i).map(t => t.trim()).filter(t => !!t) : []
    }
    ,
    Lh.rZi = function(t, i, e) {
        Lh.U(t, Set),
        Lh.qd(i),
        Lh.X_t(e);
        const s = new Set;
        for (const n of t.values())
            i(n) && (e ? s.add(e(n)) : s.add(n));
        return s
    }
    ,
    Lh.V4t = function(t, i) {
        return t.union ? t.union(i) : new Set([...t, ...i])
    }
    ,
    Lh.WR = function(t, i) {
        for (const e of i)
            t.add(e);
        return t
    }
    ,
    Lh.eu = function(t) {
        for (let i of t)
            return i;
        return null
    }
    ,
    Lh.xor = function(t, i) {
        return !t != !i
    }
    ,
    Lh.compare = function(t, i, e) {
        switch (i) {
        case 0:
            return t === e;
        case 1:
            return t !== e;
        case 2:
            return t < e;
        case 3:
            return t <= e;
        case 4:
            return t > e;
        case 5:
            return t >= e;
        default:
            return !1
        }
    }
    ,
    Lh.Nke = function(t) {
        Lh.Yq(t);
        for (let i in t)
            if (t.hasOwnProperty(i))
                return !0;
        return !1
    }
    ,
    Lh.RPe = function(t, i) {
        return Lh.YJ(t, Promise),
        Lh.qd(i),
        t.length ? new Promise( (e, s) => {
            const n = [];
            let r = 0
              , h = !1;
            for (let o = 0, a = t.length; o < a; ++o)
                n.push(void 0),
                t[o].then(s => {
                    h || (n[o] = s,
                    ++r,
                    r === t.length ? e(n) : i(r, t.length))
                }
                ).catch(t => {
                    h = !0,
                    s(t)
                }
                )
        }
        ) : Promise.resolve([])
    }
    ;
    let Nh = [];
    Lh.jke = function(t) {
        Lh.qd(t),
        Nh.push(t)
    }
    ,
    Lh.$ke = function() {
        let t = 0;
        for (let i of Nh) {
            let e = i();
            Lh.Ge(e),
            t += e
        }
        return Math.floor(t)
    }
    ;
    let jh = 1;
    const $h = new Map
      , zh = new MessageChannel;
    zh.port2.onmessage = function(t) {
        const i = t.data
          , e = $h.get(i);
        $h.delete(i),
        e && e(performance.now())
    }
    ,
    Lh.zke = function(t) {
        Lh.qd(t);
        const i = jh++;
        return $h.set(i, t),
        zh.port1.postMessage(i),
        i
    }
    ,
    Lh.Vke = function(t) {
        Lh.Ge(t),
        $h.delete(t)
    }
    ,
    Lh.Wke = Lh.zke,
    Lh.Mme = function() {
        return new Promise(t => Lh.Wke(t))
    }
    ;
    const Vh = new Set;
    Lh.Hke = function(t) {
        Lh.qd(t);
        const i = self.requestAnimationFrame(async e => {
            await Lh.Mme(),
            Vh.has(i) && (Vh.delete(i),
            t(e))
        }
        );
        return Vh.add(i),
        i
    }
    ,
    Lh.Kke = function(t) {
        Lh.Ge(t),
        Vh.has(t) && (self.cancelAnimationFrame(t),
        Vh.delete(t))
    }
}
{
    const Hh = self.t;
    Hh.ek = function(t) {
        let i = window.getImportDocument(t)
          , e = window.c3_releaseMainImportDoc;
        return i === document && e && (i = e),
        i
    }
    ,
    Hh.Y_e = function(t) {
        return Hh.zt(t),
        /^(?:[a-z\-]+:)?\/\//.test(t) || "data:" === t.substr(0, 5) || "blob:" === t.substr(0, 5)
    }
    ,
    Hh.qke = function(t) {
        return !Hh.Y_e(t)
    }
    ,
    Hh.Unt = function(t, i) {
        const e = new t.constructor(t.type,t);
        e.QAt = !0;
        !i.dispatchEvent(e) && t.preventDefault()
    }
    ,
    Hh.Xke = function() {
        return window.matchMedia("(display-mode: fullscreen)").matches ? "fullscreen" : window.matchMedia("(display-mode: standalone)").matches ? "app-info://platform/microsoft-store" === document.referrer ? "standalone-microsoft-store" : "standalone" : window.matchMedia("(display-mode: minimal-ui)").matches ? "minimal-ui" : navigator.standalone ? "standalone" : "browser"
    }
    ,
    Hh.Edi = function(t, i) {
        for (Hh.rAe(t),
        Hh.zt(i),
        i = i.toUpperCase(); t.parentNode; )
            if ((t = t.parentNode).tagName === i)
                return t;
        return null
    }
    ,
    Hh.bAt = function(t, i) {
        for (Hh.Hdt(t),
        Hh._D(i); t; ) {
            for (const e of i)
                if (t.classList.contains(e))
                    return t;
            t = t.parentElement
        }
        return null
    }
    ,
    Hh.Lgt = function(t, i) {
        return Hh.Hdt(t),
        Hh._D(i),
        !!Hh.bAt(t, i)
    }
    ,
    Hh.yAt = function(t, i) {
        for (Hh.Hdt(t),
        Hh._D(i); t; ) {
            const e = t.tagName;
            for (const s of i)
                if (Hh._x(e, s))
                    return t;
            t = t.parentElement
        }
        return null
    }
    ,
    Hh.jgt = function(t, i) {
        return Hh.Hdt(t),
        Hh._D(i),
        !!Hh.yAt(t, i)
    }
    ,
    Hh.vX = function(t, i) {
        for (Hh.zlt(t),
        Hh.zlt(i); t.parentNode; ) {
            if (t.parentNode === i)
                return !0;
            t = t.parentNode
        }
        return !1
    }
    ,
    Hh.Yke = function(t, i) {
        Hh.zlt(t);
        let e = getComputedStyle(t);
        const s = "absolute" === e.position
          , n = i ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
        if ("fixed" === e.position)
            return document.body;
        for (let i = t; i = i.parentElement; )
            if (e = getComputedStyle(i),
            (!s || "static" !== e.position) && n.test(e.overflow + e.overflowY + e.overflowX))
                return i;
        return document.body
    }
    ,
    Hh.Jke = function(t) {
        Hh.zlt(t);
        const i = t.childNodes;
        for (let t = 0, e = i.length; t < e; ++t) {
            let e = i[t];
            if (3 === e.nodeType)
                return e
        }
        return null
    }
    ,
    Hh.Uis = function(t) {
        Hh.rAe(t);
        do {
            if (t.parentNode && t.hasAttribute("contenteditable"))
                return !0;
            t = t.parentNode
        } while (t);
        return !1
    }
    ;
    const Kh = new Set(["textarea", "input", "button", "select", "option"]);
    Hh.Zke = function(t) {
        const i = t || document;
        if (i.hasFocus()) {
            const t = i.activeElement
              , e = t.tagName.toLowerCase();
            return !(!t || !t.hasAttribute("contenteditable") || "false" === t.getAttribute("contenteditable")) || Kh.has(e)
        }
        for (const t of Hh.qs.iA.Qke()) {
            const i = t?.PH();
            if (!i?.hasFocus())
                continue;
            const e = i.activeElement
              , s = e.tagName.toLowerCase();
            return !(!e || !e.hasAttribute("contenteditable") || "false" === e.getAttribute("contenteditable")) || Kh.has(s)
        }
        return !1
    }
    ;
    const qh = new Set(["email", "number", "password", "search", "tel", "text", "url"]);
    Hh.Lat = function(t, i) {
        const e = t || document;
        if (e.hasFocus()) {
            if (Hh.tOe(e.activeElement, i))
                return !0
        } else
            for (const t of Hh.qs.iA.Qke()) {
                const e = t?.PH();
                if (e?.hasFocus() && Hh.tOe(e.activeElement, i))
                    return !0
            }
        return !1
    }
    ,
    Hh.tOe = function(t, i) {
        if (!t)
            return !1;
        const e = t.tagName.toLowerCase();
        if ("textarea" === e)
            return !0;
        if ("input" === e) {
            const e = t.getAttribute("type") || "text";
            return i ? (self.assert(qh.has(i), `"${i}" is not a text editable type`),
            i.toLowerCase() === e.toLowerCase()) : qh.has(e.toLowerCase())
        }
        return !(!t || !t.hasAttribute("contenteditable") || "false" === t.getAttribute("contenteditable"))
    }
    ,
    Hh.iOe = function t(i, e) {
        Hh.rAe(i),
        Hh.qd(e),
        e(i);
        for (let s = 0, n = i.childNodes.length; s < n; ++s)
            t(i.childNodes[s], e)
    }
    ,
    Hh.Pj = function() {
        return !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement)
    }
    ,
    Hh.Dj = function(t) {
        let i;
        t.requestFullscreen ? i = t.requestFullscreen() : t.msRequestFullscreen ? i = t.msRequestFullscreen() : t.mozRequestFullScreen ? i = t.mozRequestFullScreen() : t.webkitRequestFullscreen && (i = t.webkitRequestFullscreen()),
        i instanceof Promise && i.catch(t => console.error("Failed to enter fullscreen mode: ", t))
    }
    ,
    Hh.Vj = function() {
        let t;
        document.exitFullscreen ? t = document.exitFullscreen() : document.msExitFullscreen ? t = document.msExitFullscreen() : document.mozCancelFullScreen ? t = document.mozCancelFullScreen() : document.webkitExitFullscreen && (t = document.webkitExitFullscreen()),
        t instanceof Promise && t.catch(t => console.error("Failed to exit fullscreen mode: ", t))
    }
    ,
    Hh.IOt = function(t) {
        Hh.Ge(t);
        const i = self.devicePixelRatio;
        return Math.round(t * i) / i
    }
    ,
    Hh.qU = function(t, i) {
        return Hh.zt(t),
        Hh.zt(i),
        new Promise( (e, s) => {
            const n = document.createElement("a");
            n.textContent = t,
            n.href = i,
            n.download = t,
            n.setAttribute("target", "_self"),
            document.body.appendChild(n),
            n.click(),
            document.body.removeChild(n),
            window.setTimeout(e, 16)
        }
        )
    }
    ,
    Hh._Lt = function(t, i) {
        Hh.zt(t),
        Hh.U(i, Blob);
        let e = URL.createObjectURL(i);
        return setTimeout( () => URL.revokeObjectURL(e), 6e4),
        Hh.qU(t, e)
    }
    ,
    Hh.n0 = function(t) {
        Hh.j_t && performance.mark(t + "-Start")
    }
    ,
    Hh.I0 = function(t) {
        Hh.j_t && (performance.mark(t + "-End"),
        performance.measure(t, t + "-Start", t + "-End"))
    }
    ,
    Hh.eOe = function(t) {
        Hh.j_t && console.log(performance.getEntriesByName(t, "measure"))
    }
    ;
    const Xh = document.createElement("input");
    Xh.setAttribute("type", "color"),
    Xh.className = "hiddenColorPicker",
    Xh.style.left = "-9999px",
    Xh.style.top = "-9999px",
    Xh.style.opacity = "0",
    window.C3_IsPopupWindow || document.body.appendChild(Xh),
    Hh.EK = function(t, i, e=-1, s=-1) {
        if (Hh.zt(t),
        Hh.qd(i),
        e < 0 || s < 0) {
            const [t,i] = Hh.qs.SH.vDt(document);
            e = t,
            s = i
        }
        Xh.style.left = e + "px",
        Xh.style.top = s + "px",
        Xh.onchange = null,
        Xh.value = t;
        const n = () => {
            i(Xh.value)
        }
        ;
        Xh.onblur = n,
        Xh.onchange = n,
        requestAnimationFrame( () => Xh.click())
    }
    ;
    let Yh = ""
      , Jh = "";
    function Zh(t) {
        t.clipboardData.setData("text/plain", Yh),
        t.stopPropagation(),
        t.preventDefault()
    }
    function Qh(t) {
        Hh.zt(t);
        const i = document.createElement("textarea");
        let e;
        i.value = "x",
        document.body.appendChild(i),
        i.select(),
        window.addEventListener("copy", Zh, !0),
        Yh = t;
        try {
            e = document.execCommand("copy")
        } catch (t) {
            e = !1
        }
        return Yh = "",
        window.removeEventListener("copy", Zh, !0),
        document.body.removeChild(i),
        e
    }
    function to(t, i, e) {
        const s = self.lang
          , n = Hh.qs.Ys.$s("Confirm");
        let r = null
          , h = null;
        const o = new Promise( (t, i) => {
            r = t,
            h = i
        }
        );
        return n.sOe = () => {
            let n;
            n = "function" == typeof e ? e() : Hh.lY(t, i),
            n.then(t => r(t)).catch( () => {
                Hh.p.u("ui.clipboard-copy-prompt");
                const t = Hh.qs.Ys.$s("OK");
                t.Ya(s(".caption")),
                t.Qa(s(".failed-message"), i),
                Hh.p.j(),
                h()
            }
            )
        }
        ,
        Hh.p.u("ui.clipboard-copy-prompt"),
        n.Qa({
            caption: s(".caption"),
            message: s(".message"),
            jD: s(".copy")
        }, i).then(t => {
            null === t && h()
        }
        ),
        Hh.p.j(),
        o
    }
    Hh.lY = function(t, i) {
        if (Hh.Hdt(i),
        self.app.tH())
            return Hh.ZD(t),
            Promise.resolve();
        if (navigator.clipboard && navigator.clipboard.writeText) {
            const e = i ? i.ownerDocument.defaultView : window;
            return Hh.zk.qRe || Hh.ZD(t),
            self.rOe.nOe( () => e.navigator.clipboard.writeText(t))
        }
        return Hh.ZD(t),
        Qh(t),
        Promise.resolve()
    }
    ,
    Hh.dR = async function() {
        if (self.app.tH())
            return !1;
        if (!Hh.zk.qRe)
            return !1;
        if (!Hh.zk.t6i)
            return !0;
        let t;
        try {
            t = await navigator.permissions.query({
                name: "clipboard-read"
            })
        } catch (t) {
            return !1
        }
        return "prompt" === t.state
    }
    ,
    Hh.QD = async function(t, i) {
        Hh.zt(t);
        try {
            return await Hh.lY(t, i),
            !0
        } catch (e) {
            try {
                return await to(t, i),
                !0
            } catch (t) {
                return !1
            }
        }
    }
    ,
    Hh.b6i = function(t, i) {
        return to("", t, i)
    }
    ,
    Hh.nH = function(t) {
        if (Hh.Hdt(t),
        Hh.zk.qRe && !self.app.tH()) {
            return (t ? t.ownerDocument.defaultView : window).navigator.clipboard.readText().catch( () => "")
        }
        return Promise.resolve(Hh.sH())
    }
    ,
    Hh.ZD = function(t) {
        Hh.zt(t),
        Jh = t
    }
    ,
    Hh.sH = function() {
        return Jh
    }
    ;
    const io = document.createElement
      , eo = document.appendChild
      , so = MessageChannel
      , no = MessagePort.prototype.postMessage;
    Hh.hOe = function(t) {
        Hh.Yq(t),
        Hh.zt(t.src),
        Hh.zt(t.oOe),
        Hh.X_t(t.aOe),
        Hh.Kq(t.sandbox);
        const i = io.call(document, "iframe")
          , e = new so
          , s = e.port1
          , n = e.port2;
        t.aOe && (s.onmessage = t.aOe);
        const r = new Promise( (e, r) => {
            i.addEventListener("load", () => {
                try {
                    i.contentWindow.postMessage({
                        type: "init",
                        productType: self.app.QPe()
                    }, t.oOe, [n])
                } catch (t) {
                    return void r(t)
                }
                e({
                    il: i,
                    lOe: function(t, i) {
                        try {
                            no.call(s, t, i)
                        } catch (t) {
                            console.error("[Analytics] Failed to post message: ", t)
                        }
                    }
                })
            }
            ),
            i.addEventListener("error", t => {
                r(t)
            }
            )
        }
        );
        return "string" == typeof t.sandbox && i.setAttribute("sandbox", t.sandbox),
        i.style.display = "none",
        i.src = t.src,
        eo.call(t.parent || document.body, i),
        r
    }
    ,
    Hh.Tnt = function(t, i, e) {
        if (Hh.Ge(i),
        Hh.Ge(e),
        "function" == typeof t.elementsFromPoint)
            return t.elementsFromPoint(i, e);
        if (t.msElementsFromPoint) {
            const s = t.msElementsFromPoint(i, e);
            return s ? Array.from(s) : []
        }
        throw new Error("no elementsFromPoint method")
    }
    ,
    Hh.act = function(t, i) {
        Hh.Sss(t, i, "scrollBy")
    }
    ,
    Hh.Bt = function(t, i) {
        Hh.Sss(t, i, "scrollTo")
    }
    ,
    Hh.Sss = function(t, i, e) {
        Hh.zlt(t),
        Hh.Yq(i),
        Hh.Ge(i.left),
        Hh.Ge(i.top),
        Hh.Kq(i.behavior),
        Hh.zt(e);
        const s = "scrollBehavior"in t.ownerDocument.documentElement.style;
        if ("function" == typeof t[e])
            s ? t[e](i) : t[e](i.left, i.top);
        else
            switch (e) {
            case "scrollTo":
                t.scrollLeft = i.left,
                t.scrollTop = i.top;
                break;
            case "scrollBy":
                t.scrollLeft = t.scrollLeft + i.left,
                t.scrollTop = t.scrollTop + i.top
            }
    }
}
{
    const ro = self.t
      , ho = new Set(["text", "blob", "json", "arraybuffer"])
      , oo = new Set(["text", "blob", "json", "arraybuffer", "document"]);
    function ao(t) {
        const i = [];
        for (let e in t)
            t[e] && i.push(e + "=" + encodeURIComponent(t[e]));
        return i.join("&")
    }
    function lo(t, i, e, s, n, r, h, o) {
        return new Promise( (a, l) => {
            const u = new XMLHttpRequest;
            if (u.open(t, i),
            u.responseType = "json" === n ? "text" : n,
            r && u.overrideMimeType(r),
            e)
                for (const [t,i] of Object.entries(e))
                    u.setRequestHeader(t, i);
            u.onload = () => {
                if (u.status < 300 && u.status >= 200)
                    if ("json" === n)
                        try {
                            a(JSON.parse(u.response))
                        } catch (t) {
                            l(t)
                        }
                    else
                        a(u.response);
                else
                    l(new Error(`error fetching ${i} (${u.status} ${u.statusText})`))
            }
            ,
            h && (u.onprogress = h),
            u.onerror = () => l(new Error(`error fetching ${i} (${u.status} ${u.statusText})`)),
            u.onabort = () => {
                l(new DOMException("Aborted","AbortError"))
            }
            ,
            o && (o.aborted ? u.abort() : o.addEventListener("abort", () => u.abort())),
            u.send(s)
        }
        )
    }
    async function uo(t, i, e, s, n, r) {
        const h = {
            method: t
        };
        s && (h.body = s),
        e && (h.headers = e),
        r && (h.signal = r);
        let o = null;
        try {
            o = await fetch(i, h)
        } catch (t) {
            throw t && "string" == typeof t.message && "failed to fetch" === t.message.toLowerCase() && (t.message += ` (url: ${i})`),
            t
        }
        if (!o.ok)
            throw new Error(`error fetching ${i} (${o.status} ${o.statusText})`);
        return o[n]()
    }
    ro.JRe = function(t) {
        t = ro.doe(t) ? {
            url: t
        } : t,
        ro.Yq(t),
        ro.zt(t.url),
        ro.Kq(t.method),
        ro.Wat(t.arguments),
        ro.Wat(t.query),
        ro.Kq(t.response),
        ro.Wat(t.headers),
        ro.Kq(t.encode),
        ro.Kq(t.uOe),
        ro.X_t(t.onprogress),
        ro.X_t(t.onprogress),
        ro.Wat(t.signal);
        let i = t.url
          , e = t.data;
        const s = t.uOe
          , n = t.onprogress
          , r = t.headers
          , h = t.method || "GET"
          , o = ao(t.arguments) || ""
          , a = t.response || "text"
          , l = t.signal;
        o && (i += i.includes("?") ? "&" : "?",
        i += o),
        e && ("json" === t.encode ? e = JSON.stringify(t.data) : "url" === t.encode && (e = ao(t.data)));
        const u = ro.zk.JRe && ho.has(a)
          , c = oo.has(a);
        if (u && !n)
            return uo(h, i, r, e, a, l);
        if (c)
            return lo(h, i, r, e, a, s, n, l);
        throw new TypeError(`invalid response type '${a}'`)
    }
    ,
    ro.Nxe = function(t) {
        return ro.zt(t),
        ro.JRe({
            url: t,
            mimeType: "text/plain; charset=utf-8"
        })
    }
    ,
    ro.cOe = function(t, i) {
        return ro.zt(t),
        ro.Kq(i),
        ro.JRe({
            url: t,
            response: "document",
            uOe: i
        })
    }
    ,
    ro.Z1t = function(t) {
        return ro.zt(t),
        ro.JRe({
            url: t,
            response: "json"
        })
    }
    ,
    ro.Kl = function(t, i, e) {
        ro.zt(t),
        ro.X_t(i);
        const s = Object.assign({}, {
            url: t,
            onprogress: i,
            response: "blob"
        }, e);
        return ro.JRe(s)
    }
    ,
    ro.K1t = function(t, i, e) {
        return ro.zt(t),
        ro.zt(i),
        ro.X_t(e),
        ro.JRe({
            url: t,
            onprogress: e,
            response: "blob"
        }).then(t => ro.CU([t], i, {
            type: t.type
        }))
    }
    ,
    ro.MAe = function(t, i=!0) {
        return ro.zt(t),
        window.addImport(t, i)
    }
    ,
    ro.dOe = function(t) {
        return ro.zt(t),
        new Promise( (i, e) => {
            let s = document.createElement("link");
            s.onload = function() {
                i(s)
            }
            ,
            s.onerror = function(t) {
                e(t)
            }
            ,
            s.rel = "stylesheet",
            s.href = t,
            document.head.appendChild(s)
        }
        )
    }
    ,
    ro.ih = function(t, i=!1) {
        return ro.zt(t),
        new Promise( (e, s) => {
            const n = document.createElement("script");
            n.onload = function() {
                e(n)
            }
            ,
            n.onerror = function(t) {
                s(t)
            }
            ,
            n.async = !1,
            i || (n.type = "module"),
            n.src = t,
            document.head.appendChild(n)
        }
        )
    }
    ,
    ro.yAs = function(t) {
        return ro.zt(t),
        new Promise( (i, e) => {
            let s = new Image;
            s.onload = function() {
                i(s)
            }
            ,
            s.onerror = function(t) {
                e(t)
            }
            ,
            s.src = t
        }
        )
    }
}
{
    const co = self.t;
    async function fo(t) {
        if (t.size < 24)
            return null;
        const i = t.slice(0, 24)
          , e = await co.fAs(i)
          , s = new DataView(e);
        return 2303741511 !== s.getUint32(0) || 218765834 !== s.getUint32(4) || 1229472850 !== s.getUint32(12) ? null : {
            width: s.getUint32(16),
            height: s.getUint32(20)
        }
    }
    async function po(t) {
        const i = await fo(t);
        if (i)
            return i;
        const e = await co.jv(t);
        return {
            width: e.width,
            height: e.height
        }
    }
    co.Ats = function(t) {
        return co.zt(t),
        co._Ct( () => JSON.parse(t))
    }
    ,
    co.yL = async function(t) {
        co.zt(t);
        const i = await fetch(t);
        return await i.blob()
    }
    ,
    co.rQ = async function(t) {
        if (co.e0t(t),
        self.assert(co.zk.ImageDecoder, "ImageDecoder is not supported"),
        self.assert(co.nQ(t), "the file is not a multi image container"),
        t.c3Props && t.c3Props.extracted)
            return [t];
        const i = t.type || co.MimeType.H3t(co.Uh(t.name)).uL();
        try {
            const e = new self.ImageDecoder({
                data: t.stream(),
                options: {},
                type: i
            });
            if (!(e.completed instanceof Promise))
                return [t];
            await e.completed;
            const s = e.tracks;
            if (!(s.ready instanceof Promise))
                return [t];
            await s.ready;
            const n = s.selectedIndex;
            if ("number" != typeof n)
                return [t];
            const r = s[n].frameCount;
            if (1 === r)
                return [t];
            const h = async (i, s) => {
                const n = await e.decode({
                    frameIndex: i
                })
                  , r = await createImageBitmap(n.image)
                  , h = await co.dMi(r)
                  , o = `${co.EU(t.name)}-${i}.png`
                  , a = co.CU([h], o, {
                    type: "image/png",
                    pMi: {
                        extracted: !0
                    }
                });
                s[i] = a
            }
              , o = new Array(r)
              , a = [];
            for (let t = 0, i = r; t < i; t++)
                a.push(h(t, o));
            return await Promise.all(a),
            e.close(),
            o
        } catch (i) {
            return (() => {})("Error decoding multi image container: ", i),
            [t]
        }
    }
    ;
    let mo = null;
    co.Lfs = function(t) {
        return mo || (mo = co.v(co.j1t, 16)),
        mo.cR( () => po(t))
    }
    ,
    co.Sv = async function(t) {
        const i = await co.jv(t);
        if (i.width > 0 && i.height > 0)
            return [i.width, i.height];
        {
            i.style.position = "absolute",
            i.style.left = "0px",
            i.style.top = "0px",
            i.style.visibility = "hidden",
            document.body.appendChild(i);
            const t = i.getBoundingClientRect();
            return document.body.removeChild(i),
            [t.width, t.height]
        }
    }
    ,
    co.rR = function(t) {
        return co.U(t, Blob),
        new Promise( (i, e) => {
            let s = new FileReader;
            s.onload = t => i(t.target.result),
            s.onerror = t => e(t),
            s.readAsDataURL(t)
        }
        )
    }
    ,
    co.Xbe = function(t, i) {
        co.zt(t),
        co.Kq(i);
        let e, s, n = t.length, r = n >> 2, h = new Uint8Array(n), o = new Uint32Array(h.buffer,0,r);
        for (e = 0,
        s = 0; e < r; ++e)
            o[e] = t.charCodeAt(s++) | t.charCodeAt(s++) << 8 | t.charCodeAt(s++) << 16 | t.charCodeAt(s++) << 24;
        let a = 3 & n;
        for (; a--; )
            h[s] = t.charCodeAt(s),
            ++s;
        return i ? new Blob([h],{
            type: i
        }) : new Blob([h])
    }
    ,
    co.fAs = function(t) {
        return co.Tke(t, Blob),
        "function" == typeof t.arrayBuffer ? t.arrayBuffer() : new Promise( (i, e) => {
            const s = new FileReader;
            s.onload = () => i(s.result),
            s.onerror = () => e(s.error),
            s.readAsArrayBuffer(t)
        }
        )
    }
    ,
    co.cQ = function(t) {
        return co.Tke(t, Blob),
        co.fAs(t).then(i => new Blob([i],{
            type: t.type
        }))
    }
    ,
    co.wes = function(t, i) {
        return co.e0t(t),
        co.Kq(i),
        co.fAs(t).then(e => co.CU([e], i ?? t.name, {
            type: t.type,
            lastModified: t.lastModified,
            path: t.path,
            pMi: t.c3Props
        }))
    }
    ,
    co.CU = function(t, i="", {type: e="", lastModified: s=Date.now(), path: n="", pMi: r={}}={}) {
        co._D(t),
        co.zt(i),
        co.zt(e),
        co.Ge(s),
        co.zt(n),
        co.Hut(r);
        let h = null;
        if (n ? (h = new Blob(t,{
            type: e
        }),
        h.name = i,
        h.lastModified = s,
        h.path = n) : h = new File(t,i,{
            type: e,
            lastModified: s
        }),
        r) {
            const t = Object.entries(r);
            if (t.length) {
                h.c3Props = {};
                for (const [i,e] of t)
                    h.c3Props[i] = e
            }
        }
        return h
    }
    ,
    co.fOe = function(t, i={}) {
        co.e0t(t),
        co.Hut(i);
        const e = Object.entries(i);
        if (e.length) {
            t.c3Props = {};
            for (const [i,s] of e)
                t.c3Props[i] = s
        }
        return t
    }
    ,
    co.pOe = function(t) {
        return co.Ike(t, FileList, Array),
        new Promise( (i, e) => {
            let s = [];
            for (let i = 0; i < t.length; i++) {
                let n = t[i];
                co.e0t(n),
                s.push(co.wes(n).catch(t => {
                    t.file = n,
                    e(t)
                }
                ))
            }
            return Promise.all(s).then(i)
        }
        )
    }
    ,
    co.eUt = function(t, i, e) {
        if (co.Kq(i),
        co.cO(e),
        "number" != typeof e && (e = 1),
        i = i || "image/png",
        e = co.Ne(e, 0, 1),
        t.convertToBlob)
            return t.convertToBlob({
                type: i,
                quality: e
            });
        if (t.toBlob)
            return new Promise(s => t.toBlob(s, i, e));
        throw new Error("could not convert canvas to blob")
    }
    ,
    co.lpi = function(t, i, e, s, n) {
        co.zlt(t, "canvas");
        let r = co.GS(t.width, t.height);
        if (co.Go(i) && co.Go(e) && co.Go(s) && co.Go(n)) {
            let h = s - i
              , o = n - e;
            r.getContext("2d").drawImage(t, i, e, h, o, 0, 0, h, o)
        } else
            r.getContext("2d").drawImage(t, 0, 0);
        return r
    }
    ,
    co.GS = function(t=1, i=1) {
        if ("undefined" != typeof document && "function" == typeof document.createElement) {
            const e = document.createElement("canvas");
            return e.width = t,
            e.height = i,
            e
        }
        return new OffscreenCanvas(t,i)
    }
    ;
    let wo = null
      , go = null
      , yo = null;
    function bo() {
        yo || (yo = new co.oG(vo,5)),
        yo.Bg(),
        wo || (wo = document.createElement("canvas"),
        wo.width = 32,
        wo.height = 32,
        go = wo.getContext("2d", {
            willReadFrequently: !0
        }))
    }
    function vo() {
        wo.width = 32,
        wo.height = 32
    }
    function So(t) {
        co.cwi(t),
        bo(),
        wo.width = t.width,
        wo.height = t.height,
        go.drawImage(t, 0, 0)
    }
    function xo(t, i, e, s, n) {
        let r, h;
        co.cwi(t),
        co.Ge(i),
        n = !!n,
        self.assert(i >= 1, "step count must be greater or equal to 1"),
        i % 2 != 0 ? (r = e.canvas,
        h = e) : (r = s.canvas,
        h = s);
        let o = Math.floor(.5 * t.width)
          , a = Math.floor(.5 * t.height);
        return 0 === o && (o = 1),
        0 === a && (a = 1),
        r.width = o,
        r.height = a,
        h.save(),
        h.scale(.5, .5),
        h.imageSmoothingEnabled = n,
        h.drawImage(t, 0, 0),
        h.restore(),
        n && To(h, o, a, .1),
        r
    }
    co.jke( () => wo ? wo.width * wo.height * 4 : 0),
    co.jv = async function(t, i) {
        co.U(t, Blob);
        let e = URL.createObjectURL(t);
        try {
            const t = await co.yAs(e);
            return URL.revokeObjectURL(e),
            e = "",
            i && "function" == typeof t.decode && await t.decode(),
            t
        } finally {
            e && URL.revokeObjectURL(e)
        }
    }
    ,
    co.q1t = function(t) {
        return co.U(t, Blob),
        co.zk.Qhs ? createImageBitmap(t, {
            premultiplyAlpha: "none"
        }) : co.zk.ImageBitmap ? createImageBitmap(t) : co.jv(t, !0)
    }
    ,
    co.gAs = function(t) {
        co.cwi(t);
        const i = co.GS(4, 4).getContext("2d", {
            willReadFrequently: !0
        });
        i.drawImage(t, 0, 0);
        try {
            i.getImageData(0, 0, 1, 1)
        } catch (t) {
            return !0
        }
    }
    ,
    co.gle = function(t) {
        return co.U(t, Blob),
        "function" == typeof t.text ? t.text() : new Promise( (i, e) => {
            let s = new FileReader;
            s.onload = t => i(t.target.result),
            s.onerror = t => e(t),
            s.readAsText(t)
        }
        )
    }
    ,
    co.pes = function(t) {
        return co.U(t, Blob),
        co.gle(t).then(co.Ats)
    }
    ,
    co.sRi = function(t, i) {
        let e = i ? JSON.stringify(t, null, 4) : JSON.stringify(t);
        return new Blob([e],{
            type: "application/json"
        })
    }
    ,
    co.mOe = function(t) {
        return co.U(t, ImageBitmap),
        So(t),
        go.getImageData(0, 0, t.width, t.height)
    }
    ,
    co.cBi = function(t) {
        co.cwi(t),
        So(t);
        let i = go.getImageData(0, 0, t.width, t.height);
        return wo.width = 1,
        wo.height = 1,
        i
    }
    ,
    co.dMi = function(t, i, e) {
        return co.cwi(t),
        co.Kq(i),
        co.cO(e),
        So(t),
        co.eUt(wo, i, e)
    }
    ,
    co.wOe = function(t, i, e) {
        return co.cwi(t),
        co.Kq(i),
        co.cO(e),
        So(t),
        wo.toDataURL(i || "image/png", e)
    }
    ,
    co.tos = function(t, i=!1) {
        return co.U(t, Blob),
        i = !!i,
        co.zk.Qhs && !i ? createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then(co.mOe) : co.zk.ImageBitmap && !i ? createImageBitmap(t).then(co.mOe) : co.jv(t, !0).then(t => co.c6i(t))
    }
    ,
    co.gOe = function(t) {
        return co.U(t, Image),
        So(t),
        go.getImageData(0, 0, t.width, t.height)
    }
    ,
    co.c6i = function(t) {
        return co.zk.Qhs ? (co.cT(t, Image, ImageBitmap),
        createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then(co.mOe)) : co.zk.ImageBitmap ? (co.cT(t, Image, ImageBitmap),
        createImageBitmap(t).then(co.mOe)) : (co.U(t, Image),
        co._Ct( () => co.gOe(t)))
    }
    ,
    co.mms = function(t, i, e) {
        return co.U(t, ImageData),
        co.Kq(i),
        co.cO(e),
        co.zk.Qhs ? createImageBitmap(t, {
            premultiplyAlpha: "none"
        }).then(t => co.dMi(t, i, e)) : co.zk.ImageBitmap ? createImageBitmap(t).then(t => co.dMi(t, i, e)) : co._Ct( () => (bo(),
        wo.width = t.width,
        wo.height = t.height,
        go.putImageData(t, 0, 0),
        co.eUt(wo, i, e)))
    }
    ,
    co.yOe = function(t, i, e) {
        return co.U(t, ImageData),
        co.Kq(i),
        co.cO(e),
        "number" != typeof e && (e = 1),
        i = i || "image/png",
        e = co.Ne(e, 0, 1),
        bo(),
        wo.width = t.width,
        wo.height = t.height,
        go.putImageData(t, 0, 0),
        wo.toDataURL(i, e)
    }
    ,
    co.qHi = function(t, i, e, s="columns") {
        if (co.cwi(t),
        co.Ge(i),
        co.Ge(e),
        co.Kq(s),
        "columns" != s && "rows" != s)
            throw new Error("unexpected slicing mode. Supported values are 'columns' and 'rows'.");
        bo(),
        wo.width = t.width,
        wo.height = t.height,
        go.drawImage(t, 0, 0);
        let n = Math.floor(t.width / i)
          , r = Math.floor(t.height / e)
          , h = []
          , o = 0
          , a = 0;
        if ("columns" === s)
            for (o = 0; o < i; o++)
                for (a = 0; a < e; a++)
                    h.push(go.getImageData(o * n, a * r, n, r));
        if ("rows" === s)
            for (a = 0; a < e; a++)
                for (o = 0; o < i; o++)
                    h.push(go.getImageData(o * n, a * r, n, r));
        return h
    }
    ;
    let Mo = null
      , Eo = null;
    function Co(t, i, e, s) {
        co.cwi(t),
        co.Ge(i),
        co.Ge(e),
        s = !!s;
        let n = t;
        const r = n.width
          , h = n.height;
        let o = 1
          , a = r > h ? r : h;
        const l = r > h ? i : e;
        for (; a > l; ) {
            if (.5 * a < l)
                return n;
            a *= .5,
            1 === o ? Mo || (Mo = co.GS().getContext("2d")) : 2 === o && (Eo || (Eo = co.GS().getContext("2d"))),
            n = xo(n, o, Mo, Eo, s),
            o++
        }
        return n
    }
    function _o(t, i, e, s, n, r) {
        for (let h = s - 1; h >= 0; --h)
            for (let o = e - 1; o >= 0; --o) {
                let a = h
                  , l = o
                  , u = 4 * (h * e + o)
                  , c = 0
                  , d = 0
                  , f = 0;
                for (let i = 0; i < 3; i++)
                    for (let n = 0; n < 3; n++) {
                        const h = a + i - 1
                          , o = l + n - 1;
                        if (h >= 0 && h < s && o >= 0 && o < e) {
                            const s = 4 * (h * e + o)
                              , a = r[3 * i + n];
                            c += t[s] * a,
                            d += t[s + 1] * a,
                            f += t[s + 2] * a
                        }
                    }
                const p = u + 1
                  , m = u + 2
                  , w = u + 3
                  , g = 1 - n;
                0 === o || o === e - 1 || 0 === h || h === s - 1 ? (i[u] = t[u],
                i[p] = t[p],
                i[m] = t[m],
                i[w] = t[w]) : (i[u] = c * n + t[u] * g,
                i[p] = d * n + t[p] * g,
                i[m] = f * n + t[m] * g,
                i[w] = t[w])
            }
    }
    function To(t, i, e, s) {
        try {
            const n = [0, -1, 0, -1, 5, -1, 0, -1, 0]
              , r = t.createImageData(i, e)
              , h = r.data;
            _o(t.getImageData(0, 0, i, e).data, h, i, e, s, n),
            t.putImageData(r, 0, 0)
        } catch (t) {
            console.log(t)
        }
    }
    function Io(t, i, e, s, n, r, h) {
        if (i.width > e || i.height > s)
            if ((i.width / 2 < e || i.height / 2 < s) && (n = "low"),
            "high" === n) {
                const n = Co(i, e, s, r);
                t.save(),
                t.imageSmoothingEnabled = r,
                t.drawImage(n, 0, 0, e, s),
                t.restore(),
                r && To(t, e, s, .1),
                Mo && (Mo.canvas.width = 1,
                Mo.canvas.height = 1),
                Eo && (Eo.canvas.width = 1,
                Eo.canvas.height = 1)
            } else {
                if ("low" !== n)
                    throw new Error(`unexpected scale quality "${n}". Valid values are "low" and "high"`);
                t.save(),
                t.imageSmoothingEnabled = r,
                t.drawImage(i, 0, 0, e, s),
                t.restore(),
                h.quality && "high" !== h.quality || r && To(t, e, s, .1)
            }
        else
            t.save(),
            t.imageSmoothingEnabled = r,
            t.drawImage(i, 0, 0, e, s),
            t.restore(),
            "high" === n && r && To(t, e, s, .1);
        return t.canvas
    }
    function Po(t, i, e, s, n, r, h) {
        let o = s * i + e
          , a = o + r * i;
        for (let e = o; e < a; e += i)
            t.fill(h, e, e + n)
    }
    function Go(t, i, e, s) {
        return t[s * i + e]
    }
    co.rUt = function(t, i, e, s={}) {
        if (co.aBi(t),
        co.Ge(i),
        co.Ge(e),
        i < 0 || e < 0)
            throw new Error("invalid target size");
        if (co.$l(t, ImageData)) {
            const i = co.GS(t.width, t.height);
            i.getContext("2d").putImageData(t, 0, 0),
            t = i
        }
        const n = s.context ? s.context : co.GS().getContext("2d")
          , r = !s.hasOwnProperty("smooth") || !!s.smooth
          , h = !!s.hasOwnProperty("async") && !!s.async;
        let o = s.quality ? s.quality : "high";
        return "high" !== o && "medium" !== o && "low" !== o && (o = "high"),
        n.canvas.width = i,
        n.canvas.height = e,
        0 === i || 0 === e ? h ? Promise.resolve(n.canvas) : n.canvas : t.width === i && t.height === e ? (n.drawImage(t, 0, 0),
        h ? Promise.resolve(n.canvas) : n.canvas) : h && co.zk.ImageBitmap && co.zk.KRe ? (r || (o = "pixelated"),
        createImageBitmap(t, {
            resizeWidth: i,
            resizeHeight: e,
            resizeQuality: o
        }).then(t => (n.drawImage(t, 0, 0),
        n.canvas))) : h ? co._Ct( () => Io(n, t, i, e, o, r, s)) : Io(n, t, i, e, o, r, s)
    }
    ,
    co.Zrs = function(t, i, e, s, n, r, h, o, a, l) {
        let u = o * s + h
          , c = u + l * s;
        for (let h = u, o = r * i + n; h < c; h += s,
        o += i)
            e.set(t.subarray(o, o + a), h)
    }
    ,
    co.Yrs = function(t, i, e, s, n, r, h, o, a, l) {
        let u = r * i + n;
        const c = u + l * i;
        let d = o * s + h + l - 1;
        for (; u < c; u += i,
        --d) {
            const i = u + a;
            let n = d;
            for (let r = u; r < i; ++r,
            n += s)
                e[n] = t[r]
        }
    }
    ,
    co.bOe = function(t, i, e, s, n, r, h) {
        let o = s * i + e
          , a = r * i + n;
        t.copyWithin(a, o, o + h)
    }
    ,
    co.vOe = function(t, i, e, s, n, r, h) {
        let o = r * i + n
          , a = o + h * i;
        for (let n = o, r = s * i + e; n < a; n += i,
        r += i)
            t[n] = t[r]
    }
    ,
    co.bMi = function(t, i, e, s, n) {
        co.U(t, ImageData),
        co.Ge(i),
        co.Ge(e),
        co.Ge(s),
        co.Ge(n),
        i |= 0,
        e |= 0,
        s |= 0,
        n |= 0;
        let r = 0 | t.width
          , h = 0 | t.height;
        if (i < 0 || i >= r || e < 0 || e >= h || i + s > r || e + n > h)
            throw new Error("invalid sub image");
        let o = new ImageData(s,n)
          , a = new Uint32Array(t.data.buffer)
          , l = new Uint32Array(o.data.buffer);
        return co.Zrs(a, r, l, s, i, e, 0, 0, s, n),
        o
    }
    ,
    co.SOe = function(t, i, e, s) {
        co.U(t, ImageData),
        co.U(i, ImageData),
        co.Ge(e),
        co.Ge(s),
        e |= 0,
        s |= 0;
        let n = 0 | t.width
          , r = 0 | t.height
          , h = 0 | i.width
          , o = 0 | i.height;
        if (e < 0 || s < 0 || e > n - h || s > r - o)
            throw new Error("invalid sub image");
        let a = new Uint32Array(i.data.buffer)
          , l = new Uint32Array(t.data.buffer);
        co.Zrs(a, h, l, n, 0, 0, e, s, h, o)
    }
    ,
    co.xOe = function(t, i, e, s, n) {
        co.U(t, ImageData),
        co.Ge(i),
        co.Ge(e),
        co.Ge(s),
        co.Ge(n),
        i |= 0,
        e |= 0,
        s |= 0,
        n |= 0;
        let r = 0 | t.width
          , h = 0 | t.height;
        if (i < 0 || i >= r || e < 0 || e >= h || i + s > r || e + n > h)
            throw new Error("invalid sub image");
        Po(new Uint32Array(t.data.buffer), r, i, e, s, n, 0)
    }
    ,
    co.qrs = function(t, i, e, s, n, r, h, o, a, l, u) {
        if (co.U(t, Uint32Array),
        co.Ge(i),
        co.Ge(e),
        co.Ge(s),
        co.Ge(n),
        co.Ge(r),
        co.Ge(h),
        co.Ge(o),
        co.Ge(a),
        co.Ge(l),
        co.Ge(u),
        r > i || l > i || h > e || u > e)
            throw new Error("rectangle larger than destination");
        if (r > l || h > u)
            throw new Error("inner size larger than outer size");
        if (s < o || n < a || s + r > o + l || n + h > a + u)
            throw new Error("inner rectange not inside outer rectangle");
        if (r === l && h === u)
            return;
        let c = s + r
          , d = c - 1
          , f = o + l
          , p = n + h
          , m = p - 1
          , w = a + u
          , g = Go(t, i, s, n);
        Po(t, i, o, a, s - o, n - a, g);
        for (let e = a; e < n; ++e)
            co.bOe(t, i, s, n, s, e, r);
        g = Go(t, i, d, n),
        Po(t, i, c, a, f - c, n - a, g);
        for (let e = o; e < s; ++e)
            co.vOe(t, i, s, n, e, n, h);
        for (let e = c; e < f; ++e)
            co.vOe(t, i, d, n, e, n, h);
        g = Go(t, i, s, m),
        Po(t, i, o, p, s - o, w - p, g);
        for (let e = p; e < w; ++e)
            co.bOe(t, i, s, m, s, e, r);
        g = Go(t, i, d, m),
        Po(t, i, c, p, f - c, w - p, g)
    }
    ,
    co.MOe = function(t, i, e=0, s=-1) {
        co.U(t, ArrayBuffer),
        co.Kq(i),
        co.Ge(e),
        co.Ge(s),
        s < 0 && (s = t.byteLength);
        let n = new Uint8Array(t,e,s);
        return co.EOe(n, i)
    }
    ,
    co.EOe = function(t, i) {
        return co.Cke(t),
        co.Kq(i),
        new TextDecoder(i || "utf-8").decode(t)
    }
    ,
    co.COe = function(t) {
        return co.zt(t),
        new TextEncoder("utf-8").encode(t).buffer
    }
    ,
    co._Oe = function(t, i, e) {
        co.U(t, ArrayBuffer),
        co.qd(i),
        co.VY(e);
        let s = 0
          , n = t.byteLength
          , r = [];
        for (; s < n; )
            e = Math.min(n - s, e),
            r.push(new i(t,s,e)),
            s += e;
        return r
    }
    ;
    const Ao = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    co.TOe = function(t) {
        const i = i => i < e ? t[i] : (n++,
        0)
          , e = t.length
          , s = [];
        let n = 0
          , r = 0;
        for (; r < e; ) {
            const t = (i(r++) << 16) + (i(r++) << 8) + i(r++);
            s.push(Ao[t >>> 18 & 63], Ao[t >>> 12 & 63], Ao[t >>> 6 & 63], Ao[63 & t])
        }
        for (r = s.length - n; r < s.length; )
            s[r++] = "=";
        return s.join("")
    }
    ,
    co.IOe = function(t) {
        const i = t.indexOf("=")
          , e = t.length
          , s = e >> 2 << 2
          , n = e - s
          , r = i > -1 ? e - i : 0;
        if (r > 2)
            throw new Error("Invalid padding");
        let h = e;
        s === i ? h = s - r : 0 === n && i > -1 && (h -= r);
        const o = 3 * h >> 2
          , a = new Uint8Array(o);
        let l = 0
          , u = 0;
        const c = () => {
            if (l >= h)
                return 0;
            const i = t.charCodeAt(l++);
            if (i > 64 && i < 91)
                return i - 65;
            if (i > 96 && i < 123)
                return i - 71;
            if (i > 47 && i < 58)
                return i + 4;
            if (43 === i)
                return 62;
            if (47 === i)
                return 63;
            if (61 === i)
                return 0;
            throw new Error("Invalid character at column " + (l - 1))
        }
          , d = t => u < o && (a[u++] = t);
        for (; u < o; ) {
            const t = (c() << 18) + (c() << 12) + (c() << 6) + c();
            d(t >>> 16 & 255),
            d(t >>> 8 & 255),
            d(255 & t)
        }
        return a
    }
}
{
    const Ro = self.t
      , ko = new Map;
    let Oo;
    function Do(t, i) {
        let e = Ro.getType(t)
          , s = Ro.getType(i);
        return "null" === e || "null" === s || "undefined" !== e && "undefined" !== s && e === s
    }
    Ro.POe = function(t, i) {
        console.log(`%c${t}`, `font-weight: bold; color:${i}`)
    }
    ,
    Ro.GOe = function(t, ...i) {
        ko.has(t) || ko.set(t, -1),
        -1 === ko.get(t) && ko.set(t, requestAnimationFrame( () => {
            console.log(`%c${t}`, "font-weight: bold", ...i),
            ko.set(t, -1)
        }
        ))
    }
    ,
    Ro.AOe = function(t) {
        performance.mark(t),
        Oo || (Oo = new Map),
        Oo.has(t) || Oo.set(t, {
            M5: 0,
            total: 0,
            ROe: 0,
            kOe: 1,
            toString: function() {
                return `${t} :: current => ${this.M5.toPrecision(3)} :: average => ${this.ROe.toPrecision(3)} :: calls => ${this.kOe}`
            }
        })
    }
    ,
    Ro.OOe = function(t) {
        performance.measure(`measure-${t}`, t);
        const i = performance.getEntriesByName(`measure-${t}`)[0]
          , e = Oo.get(t);
        e.M5 = i.duration,
        e.total += e.M5,
        e.ROe = e.total / e.kOe,
        console.log(e.toString()),
        e.kOe++,
        performance.clearMarks(t),
        performance.clearMeasures(`measure-${t}`)
    }
    ,
    Ro.zRe = function() {
        return (new Error).stack
    }
    ,
    Ro.DOe = function() {}
    ,
    Ro.cast = function(t, i) {
        return t && t instanceof i ? t : null
    }
    ,
    Ro.getName = function(t) {
        return void 0 === t ? "undefined" : null === t ? "null" : "boolean" == typeof t ? "<boolean>" : Ro.nke(t) ? "<number>" : Ro.doe(t) ? "<string>" : Ro.kft(t) ? "<array>" : "symbol" == typeof t ? "<" + t.toString() + ">" : Ro.XOt(t) ? t.name && "Function" !== t.name ? t.name : "<anonymous function>" : "object" == typeof t ? t.constructor && t.constructor.name && "Object" !== t.constructor.name ? t.constructor.name : "<anonymous object>" : "<unknown>"
    }
    ,
    Ro.getType = function(t) {
        return null === t ? "null" : Array.isArray(t) ? "array" : typeof t
    }
    ,
    Ro.range = function*(t, i) {
        if (!isFinite(Math.abs(t - i)))
            throw new Error("Invalid parameters");
        if (t > i)
            for (let e = t - 1; e >= i; e--)
                yield e;
        else
            for (let e = t; e < i; e++)
                yield e
    }
    ;
    let Fo = new Map
      , Lo = new Map
      , Bo = new WeakMap
      , Uo = new WeakMap;
    Ro.FOe = {};
    const No = new Set(["then", "splice"]);
    function jo(t) {
        (() => {})("[Defence] " + t + " @", Ro.zRe())
    }
    Ro.FOe.get = function(t, i) {
        return i in t || "symbol" == typeof i || No.has(i) || jo(`Accessed missing property '${i}' from defended object '${Ro.getName(t)}', returning undefined`),
        Uo.has(t) && "symbol" != typeof i && !No.has(i) && jo(`Accessed property '${i}' on a released object '${Ro.getName(t)}'\nObject was originally released at: ${Uo.get(t)})\nCall stack at access: `),
        t[i]
    }
    ,
    Ro.FOe.set = function(t, i, e) {
        return i in t || Fo.has(t) || jo(`Set non-existent property '${i}' to '${e}' on defended object '${Ro.getName(t)}'`),
        Do(t[i], e) || Fo.has(t) || jo(`Set '${Ro.getType(t[i])}' property '${i}' to type '${Ro.getType(e)}' on defended object '${Ro.getName(t)}'`),
        Uo.has(t) && jo(`Set property '${i}' on a released object '${Ro.getName(t)}'\nObject was originally released at: ${Uo.get(t)})\nCall stack at access: `),
        t[i] = e,
        !0
    }
    ,
    Ro.FOe.deleteProperty = function(t, i) {
        throw new ReferenceError(`Cannot delete property '${i}' from defended object '${Ro.getName(t)}'`)
    }
    ,
    Ro.FOe.defineProperty = function(t, i, e) {
        throw new ReferenceError(`Cannot define property '${i}' on defended object '${Ro.getName(t)}'`)
    }
    ,
    Ro.FOe.enumerate = function(t) {
        throw new ReferenceError(`Cannot enumerate defended object '${Ro.getName(t)}'`)
    }
    ;
    let $o = -1;
    function zo() {
        if ($o = -1,
        Fo.size > 0 || Lo.size > 0) {
            let t = [...new Set([...Fo.keys()].map(t => Ro.getName(t)))].join(",");
            (() => {})(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${t}`),
            Fo.clear(),
            Lo.clear()
        }
    }
    Ro.Me = class {
        constructor() {
            if (!Ro.XTe || !Ro.zk.XRe)
                return;
            let t = new.target
              , i = Object.create(t.prototype)
              , e = new Proxy(i,Ro.FOe);
            return Fo.set(i, e),
            Lo.set(e, i),
            Bo.set(e, i),
            -1 === $o && ($o = requestAnimationFrame(zo)),
            e
        }
    }
    ,
    Ro.LOe = function(t) {
        if (Ro.Yq(t),
        Ro.XTe && Ro.zk.XRe && t instanceof Ro.Me) {
            if (!Lo.has(t))
                return t;
            let i = Lo.get(t);
            return Lo.delete(t),
            Fo.delete(i),
            t
        }
        return Ro.Vl ? Object.seal(t) : t
    }
    ,
    Ro.v = function(t, ...i) {
        let e;
        Ro.qd(t);
        try {
            e = new t(...i)
        } catch (t) {
            throw Lo.clear(),
            Fo.clear(),
            t
        }
        return Ro.XTe && Ho(t, e),
        Ro.LOe(e)
    }
    ,
    Ro.he = function(t) {
        let i = Bo.get(t);
        i && Uo.set(i, Ro.zRe())
    }
    ,
    Ro.dn = function(t) {
        let i = Bo.get(t);
        return !!i && !!Uo.get(i)
    }
    ;
    let Vo = new Map;
    function Wo(t) {
        let i = new Set;
        for (let e in t)
            i.add(e);
        return i
    }
    function Ho(t, i) {
        let e = Wo(i)
          , s = Vo.get(t);
        if (s) {
            let i = [];
            for (let t of s.values())
                e.has(t) ? e.delete(t) : i.push(t);
            Ro.bp(i, [...e]),
            i.length && (() => {})(`[Defence] '${Ro.getName(t)}' constructor creates inconsistent properties: ${i.join(", ")}`)
        } else
            Vo.set(t, e)
    }
    Ro.BOe = class {
        constructor(t) {
            this.rVt = "",
            t && this.start(t)
        }
        start(t) {
            Ro.j_t && (this.rVt = t,
            performance.mark(this.rVt + "-Start"))
        }
        end() {
            Ro.j_t && (performance.mark(this.rVt + "-End"),
            performance.measure(this.rVt, this.rVt + "-Start", this.rVt + "-End"))
        }
        next(t) {
            Ro.j_t && (this.end(),
            this.rVt = t,
            performance.mark(this.rVt + "-Start"))
        }
    }
}
{
    const Ko = self.t;
    Ko.UOe = function(t) {
        Ko.U(t, self.fh);
        const i = self.app.eLs();
        return i && t.YU() ? Ko.fAs(t.xc()).then(t => new Promise(e => {
            i.decodeAudioData(t, t => {
                e(t.duration)
            }
            , t => {
                e(-1)
            }
            )
        }
        )) : Promise.resolve(-1)
    }
}
{
    const qo = self.t
      , Xo = 2 * Math.PI
      , Yo = Math.PI / 180
      , Jo = 180 / Math.PI;
    qo.wrap = function(t, i, e) {
        t = Math.floor(t),
        i = Math.floor(i);
        const s = (e = Math.floor(e)) - i;
        if (0 === s)
            return e;
        if (t < i) {
            const n = e - (i - t) % s;
            return n === e ? 0 : n
        }
        return i + (t - i) % s
    }
    ,
    qo.Mrt = function(t, i, e, s, n) {
        const r = e - i;
        if (0 === r && 0 === s)
            return t;
        return (t - i) * (n - s) / r + s
    }
    ,
    qo.normalize = function(t, i, e) {
        return i - e === 0 ? 1 : (t - i) / (e - i)
    }
    ,
    qo.Ne = function(t, i, e) {
        return t < i ? i : t > e ? e : t
    }
    ,
    qo.ut = function(t) {
        return (t %= Xo) < 0 && (t += Xo),
        t
    }
    ,
    qo.ct = function(t) {
        return t * Yo
    }
    ,
    qo.pi = function(t) {
        return t * Jo
    }
    ,
    qo.NOe = function(t, i) {
        return Math.sqrt(t * t + i * i)
    }
    ,
    qo.bw = function(t, i, e) {
        return Math.sqrt(t * t + i * i + e * e)
    }
    ,
    qo.di = function(t, i, e, s) {
        return qo.NOe(e - t, s - i)
    }
    ,
    qo.h4 = function(t, i, e, s) {
        const n = e - t
          , r = s - i;
        return n * n + r * r
    }
    ,
    qo.fi = function(t, i, e, s) {
        return Math.atan2(s - i, e - t)
    }
    ,
    qo.xi = function(t, i) {
        if (t === i)
            return 0;
        let e = Math.sin(t)
          , s = Math.cos(t)
          , n = e * Math.sin(i) + s * Math.cos(i);
        return n >= 1 ? 0 : n <= -1 ? Math.PI : Math.acos(n)
    }
    ,
    qo.Ci = function(t, i, e) {
        let s = Math.sin(t)
          , n = Math.cos(t)
          , r = Math.sin(i)
          , h = Math.cos(i);
        return Math.acos(s * r + n * h) > e ? n * r - s * h > 0 ? qo.ut(t + e) : qo.ut(t - e) : qo.ut(i)
    }
    ,
    qo.jOe = function(t, i) {
        let e = Math.sin(t);
        return Math.cos(t) * Math.sin(i) - e * Math.cos(i) <= 0
    }
    ,
    qo.Si = function(t, i, e, s=0) {
        let n = qo.xi(t, i);
        const r = Xo * s;
        return qo.jOe(i, t) ? qo.ut(t + (n + r) * e) : qo.ut(t - (n + r) * e)
    }
    ,
    qo.CLs = function(t, i, e, s=0) {
        const n = qo.xi(t, i)
          , r = Xo * s;
        return qo.jOe(i, t) ? qo.ut(t + (n + r) * e) : qo.ut(t + (Xo - n + r) * e)
    }
    ,
    qo.ILs = function(t, i, e, s=0) {
        const n = qo.xi(t, i)
          , r = Xo * s;
        return qo.jOe(i, t) ? qo.ut(t - (-Xo + n - r) * e) : qo.ut(t - (n + r) * e)
    }
    ,
    qo.$Oe = function(t, i) {
        const e = qo.xi(t, i);
        return qo.jOe(t, i) ? qo.ut(i - e) : qo.ut(i + e)
    }
    ,
    qo.mi = function(t, i, e) {
        return t + e * (i - t)
    }
    ,
    qo.gi = function(t, i, e) {
        return t === i ? 0 : (e - t) / (i - t)
    }
    ,
    qo.pb = function(t, i, e, s, n) {
        return qo.mi(s, n, qo.gi(t, i, e))
    }
    ,
    qo.wi = function(t, i, e, s) {
        return qo.mi(qo.mi(t, i, s), qo.mi(i, e, s), s)
    }
    ,
    qo.bi = function(t, i, e, s, n) {
        return qo.mi(qo.wi(t, i, e, n), qo.wi(i, e, s, n), n)
    }
    ,
    qo.yi = function(t, i, e) {
        return (t + i + (t - i) * Math.cos(e * Math.PI)) / 2
    }
    ,
    qo.zOe = function(t) {
        return t > 0 && !(t - 1 & t)
    }
    ,
    qo.ha = function(t) {
        --t;
        for (let i = 1; i < 32; i <<= 1)
            t |= t >> i;
        return t + 1
    }
    ,
    qo.oY = function(t, i) {
        return Math.round(t * i) / i
    }
    ,
    qo.SLs = function(t, i) {
        return Math.floor(t * i) / i
    }
    ,
    qo.Sq = function(t, i) {
        i = Math.max(Math.floor(i), 0);
        const e = Math.pow(10, i);
        return Math.round(t * e) / e
    }
    ,
    qo.VOe = function(t) {
        return Math.floor(t) !== t && t.toString().split(".")[1].length || 0
    }
    ,
    qo.toFixed = function(t, i) {
        qo.VY(t),
        qo.Ge(i);
        let e = t.toFixed(i)
          , s = e.length - 1;
        for (; s >= 0 && "0" === e.charAt(s); --s)
            ;
        return s >= 0 && "." === e.charAt(s) && --s,
        s < 0 ? e : e.substr(0, s + 1)
    }
    ,
    qo.Ti = function(t, i, e) {
        return qo.Ne(t, 0, 255) | qo.Ne(i, 0, 255) << 8 | qo.Ne(e, 0, 255) << 16
    }
    ;
    const Zo = 1024
      , Qo = 1023
      , ta = 16384
      , ia = 8191
      , ea = -8192;
    qo.WOe = function(t, i, e, s) {
        return t = qo.Ne(Math.floor(1024 * t), ea, ia),
        i = qo.Ne(Math.floor(1024 * i), ea, ia),
        e = qo.Ne(Math.floor(1024 * e), ea, ia),
        s = qo.Ne(Math.floor(s * Qo), 0, Qo),
        t < 0 && (t += ta),
        i < 0 && (i += ta),
        e < 0 && (e += ta),
        -(t * ta * ta * Zo + i * ta * Zo + e * Zo + s)
    }
    ,
    qo.Oi = function(t, i, e) {
        return qo.WOe(t, i, e, 1)
    }
    ,
    qo.HOe = function(t) {
        if (t >= 0)
            return (255 & t) / 255;
        {
            let i = Math.floor(-t / (ta * ta * Zo));
            return i > ia && (i -= ta),
            i / 1024
        }
    }
    ,
    qo.KOe = function(t) {
        if (t >= 0)
            return ((65280 & t) >> 8) / 255;
        {
            let i = Math.floor(-t % (ta * ta * Zo) / (ta * Zo));
            return i > ia && (i -= ta),
            i / 1024
        }
    }
    ,
    qo.qOe = function(t) {
        if (t >= 0)
            return ((16711680 & t) >> 16) / 255;
        {
            let i = Math.floor(-t % (ta * Zo) / Zo);
            return i > ia && (i -= ta),
            i / 1024
        }
    }
    ,
    qo.XOe = function(t) {
        if (0 === (i = t) && 1 / i < 0)
            return 0;
        if (t >= 0)
            return 1;
        return Math.floor(-t % Zo) / Qo;
        var i
    }
    ,
    qo.YOe = function(t, i) {
        for (qo.Ge(t),
        qo.Ge(i),
        t = Math.floor(t),
        i = Math.floor(i); 0 !== i; ) {
            let e = i;
            i = t % i,
            t = e
        }
        return t
    }
    ;
    const sa = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
    qo.fse = function(t, i) {
        if (qo.Ge(t),
        qo.Ge(i),
        (t = Math.floor(t)) === (i = Math.floor(i)))
            return [1, 1];
        for (let e of sa) {
            let s = t / e[0] * e[1];
            if (Math.abs(i - s) < 1)
                return e.slice(0);
            if (s = t / e[1] * e[0],
            Math.abs(i - s) < 1)
                return [e[1], e[0]]
        }
        let e = qo.YOe(t, i);
        return [t / e, i / e]
    }
    ,
    qo.JOe = function(t, i, e, s, n, r, h, o) {
        const a = Math.min(t, e)
          , l = Math.max(t, e)
          , u = Math.min(n, h)
          , c = Math.max(n, h);
        if (l < u || a > c)
            return !1;
        const d = Math.min(i, s)
          , f = Math.max(i, s)
          , p = Math.min(r, o)
          , m = Math.max(r, o);
        if (f < p || d > m)
            return !1;
        const w = n - t + h - e
          , g = r - i + o - s
          , y = e - t
          , b = s - i
          , v = h - n
          , S = o - r
          , x = Math.abs(b * v - S * y)
          , M = v * g - S * w;
        if (Math.abs(M) > x)
            return !1;
        const E = y * g - b * w;
        return Math.abs(E) <= x
    }
    ,
    qo.ZOe = function(t, i, e, s, n, r, h, o, a, l, u, c) {
        const d = Math.min(a, u)
          , f = Math.max(a, u);
        if (r < d || n > f)
            return !1;
        const p = Math.min(l, c)
          , m = Math.max(l, c);
        if (o < p || h > m)
            return !1;
        const w = a - t + u - e
          , g = l - i + c - s
          , y = e - t
          , b = s - i
          , v = u - a
          , S = c - l
          , x = Math.abs(b * v - S * y)
          , M = v * g - S * w;
        if (Math.abs(M) > x)
            return !1;
        const E = y * g - b * w;
        return Math.abs(E) <= x
    }
    ,
    qo.QOe = function(t, i, e, s, n) {
        const r = Math.min(t, e)
          , h = Math.max(t, e)
          , o = Math.min(i, s)
          , a = Math.max(i, s)
          , l = n.Jn()
          , u = n.Qn()
          , c = n.Hw()
          , d = n.rl()
          , f = n.al()
          , p = n.ll()
          , m = n.zc()
          , w = n.Ec();
        return qo.ZOe(t, i, e, s, r, h, o, a, l, u, c, d) || qo.ZOe(t, i, e, s, r, h, o, a, c, d, f, p) || qo.ZOe(t, i, e, s, r, h, o, a, f, p, m, w) || qo.ZOe(t, i, e, s, r, h, o, a, m, w, l, u)
    }
    ,
    qo.tDe = function(t, i, e, s, n) {
        const r = Math.min(t, e)
          , h = Math.max(t, e)
          , o = Math.min(i, s)
          , a = Math.max(i, s);
        let l = 0;
        for (let u = n.length - 4; l <= u; l += 2)
            if (qo.ZOe(t, i, e, s, r, h, o, a, n[l], n[l + 1], n[l + 2], n[l + 3]))
                return !0;
        return qo.ZOe(t, i, e, s, r, h, o, a, n[l], n[l + 1], n[0], n[1])
    }
    ;
    const na = 2
      , ra = 1e-6;
    qo.iDe = function(t, i, e, s, n, r, h, o) {
        const a = e - t
          , l = o - r
          , u = a * l - (s - i) * (h - n);
        if (0 === u)
            return na;
        const c = ((i - s) * (h - t) + a * (o - i)) / u;
        return 0 < c && c < 1 + ra ? (l * (h - t) + (n - h) * (o - i)) / u : na
    }
    ,
    qo.eDe = function(t, i, e, s, n, r, h, o, a) {
        const l = (h - n) * a
          , u = (o - r) * a;
        return qo.iDe(t, i, e, s, n - l, r - u, h + l, o + u)
    }
    ,
    qo.sDe = function(t, i, e, s, n, r, h, o) {
        const a = n - e
          , l = r - s
          , u = h - e
          , c = o - s
          , d = t - e
          , f = i - s
          , p = a * a + l * l
          , m = a * u + l * c
          , w = a * d + l * f
          , g = u * u + c * c
          , y = u * d + c * f
          , b = 1 / (p * g - m * m)
          , v = (g * w - m * y) * b
          , S = (p * y - m * w) * b;
        return v >= 0 && S >= 0 && v + S <= 1
    }
    ,
    qo.nDe = function(t, i, e, s, n, r, h, o) {
        const a = n - e
          , l = r - s
          , u = h - e
          , c = o - s
          , d = t - e
          , f = i - s
          , p = a * a + l * l
          , m = a * u + l * c
          , w = u * u + c * c
          , g = d * a + f * l
          , y = d * u + f * c
          , b = p * w - m * m
          , v = (w * g - m * y) / b
          , S = (p * y - m * g) / b;
        return [1 - v - S, v, S]
    }
    ,
    qo.rDe = function(t, i, e, s, n, r, h, o, a, l, u, c) {
        return [t * s + i * h + e * l, t * n + i * o + e * u, t * r + i * a + e * c]
    }
}
{
    const ha = self.t;
    ha.m3 = class {
        constructor(t, i) {
            this.kd = 0,
            this.Gd = 0,
            t instanceof ha.m3 ? this.ia(t) : this.set(t || 0, i || 0)
        }
        set(t, i) {
            this.kd = +t,
            this.Gd = +i
        }
        ia(t) {
            this.kd = t.kd,
            this.Gd = t.Gd
        }
        equals(t) {
            return this.kd === t.kd && this.Gd === t.Gd
        }
        hDe(t, i) {
            return this.kd === t && this.Gd === i
        }
        oDe(t, i) {
            return t[i] === Math.fround(this.kd) && t[i + 1] === Math.fround(this.Gd)
        }
        aDe(t) {
            this.kd = +t
        }
        s8() {
            return this.kd
        }
        lDe(t) {
            this.Gd = +t
        }
        e8() {
            return this.Gd
        }
        toArray() {
            return [this.kd, this.Gd]
        }
        yNi() {
            return new Float64Array(this.toArray())
        }
        uDe(t, i) {
            t[i++] = this.kd,
            t[i] = this.Gd
        }
        offset(t, i) {
            this.kd += +t,
            this.Gd += +i
        }
        scale(t, i) {
            this.kd *= t,
            this.Gd *= i
        }
        tb(t, i) {
            this.kd /= t,
            this.Gd /= i
        }
        round() {
            this.kd = Math.round(this.kd),
            this.Gd = Math.round(this.Gd)
        }
        floor() {
            this.kd = Math.floor(this.kd),
            this.Gd = Math.floor(this.Gd)
        }
        ceil() {
            this.kd = Math.ceil(this.kd),
            this.Gd = Math.ceil(this.Gd)
        }
        angle() {
            return ha.fi(0, 0, this.kd, this.Gd)
        }
        cDe() {
            return this.kd * this.kd + this.Gd * this.Gd
        }
        length() {
            return ha.NOe(this.kd, this.Gd)
        }
        dDe(t, i) {
            const e = this.kd * i - this.Gd * t;
            this.Gd = this.Gd * i + this.kd * t,
            this.kd = e
        }
        rotate(t) {
            0 !== t && this.dDe(Math.sin(t), Math.cos(t))
        }
        Vtt(t, i, e) {
            0 === t || i === this.kd && e === this.Gd || (this.kd -= i,
            this.Gd -= e,
            this.dDe(Math.sin(t), Math.cos(t)),
            this.kd += +i,
            this.Gd += +e)
        }
        move(t, i) {
            0 !== i && (this.kd += Math.cos(t) * i,
            this.Gd += Math.sin(t) * i)
        }
        normalize() {
            const t = this.length();
            0 !== t && 1 !== t && (this.kd /= t,
            this.Gd /= t)
        }
        Ne(t, i) {
            this.kd = ha.Ne(this.kd, t, i),
            this.Gd = ha.Ne(this.Gd, t, i)
        }
        dot(t) {
            return this.kd * t.kd + this.Gd * t.Gd
        }
        reverse() {
            this.kd = -this.kd,
            this.Gd = -this.Gd
        }
        fDe() {
            let t = this.kd;
            return this.kd = this.Gd,
            this.Gd = -t,
            this
        }
    }
}
{
    const oa = self.t
      , aa = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i
      , la = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
    function ua(t) {
        return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t
    }
    function ca(t, i, e) {
        return e < 0 && (e += 1),
        e > 1 && (e -= 1),
        e < 1 / 6 ? t + 6 * (i - t) * e : e < .5 ? i : e < 2 / 3 ? t + (i - t) * (2 / 3 - e) * 6 : t
    }
    oa.Ha = class {
        constructor(t, i, e, s) {
            this._r = NaN,
            this._g = NaN,
            this._b = NaN,
            this._a = NaN,
            this._r = 0,
            this._g = 0,
            this._b = 0,
            this._a = 0,
            t instanceof oa.Ha ? this.set(t) : this.CIs(t || 0, i || 0, e || 0, s || 0)
        }
        Eo(t, i, e) {
            return this._r = +t,
            this._g = +i,
            this._b = +e,
            this.Ne(),
            this
        }
        CIs(t, i, e, s) {
            return this._r = +t,
            this._g = +i,
            this._b = +e,
            this._a = +s,
            this.Ne(),
            this
        }
        set(t) {
            return this._r = t._r,
            this._g = t._g,
            this._b = t._b,
            this._a = t._a,
            this
        }
        ia(t) {
            return this.set(t)
        }
        add(t) {
            this._r += t._r,
            this._g += t._g,
            this._b += t._b,
            this._a += t._a,
            this.Ne()
        }
        pDe(t, i, e, s=0) {
            this._r += +t,
            this._g += +i,
            this._b += +e,
            this._a += +s,
            this.Ne()
        }
        Uas(t) {
            this.mDe(Math.max(this._r, t._r) - Math.min(this._r, t._r)),
            this.wDe(Math.max(this._g, t._g) - Math.min(this._g, t._g)),
            this.gDe(Math.max(this._b, t._b) - Math.min(this._b, t._b)),
            this.FC(Math.max(this._a, t._a) - Math.min(this._a, t._a)),
            this.Ne()
        }
        Wa(t) {
            this._r = t._r,
            this._g = t._g,
            this._b = t._b
        }
        mDe(t) {
            this._r = oa.Ne(+t, 0, 1)
        }
        getR() {
            return this._r
        }
        wDe(t) {
            this._g = oa.Ne(+t, 0, 1)
        }
        getG() {
            return this._g
        }
        gDe(t) {
            this._b = oa.Ne(+t, 0, 1)
        }
        getB() {
            return this._b
        }
        FC(t) {
            this._a = oa.Ne(+t, 0, 1)
        }
        getA() {
            return this._a
        }
        clone() {
            return oa.v(oa.Ha, this._r, this._g, this._b, this._a)
        }
        toArray() {
            return [this._r, this._g, this._b, this._a]
        }
        yNi() {
            return new Float64Array(this.toArray())
        }
        uDe(t, i) {
            t[i++] = this._r,
            t[i++] = this._g,
            t[i++] = this._b,
            t[i] = this._a
        }
        yDe(t, i) {
            const e = this._r
              , s = this._g
              , n = this._b
              , r = this._a;
            for (let h = 0; h < 4; ++h)
                t[i++] = e,
                t[i++] = s,
                t[i++] = n,
                t[i++] = r
        }
        bDe(t, i) {
            t[i++] = this._r,
            t[i++] = this._g,
            t[i] = this._b
        }
        equals(t) {
            return this._r === t._r && this._g === t._g && this._b === t._b && this._a === t._a
        }
        Oae(t) {
            return this._r === t._r && this._g === t._g && this._b === t._b
        }
        PLs(t, i, e) {
            return this._r === t && this._g === i && this._b === e
        }
        RGs(t, i, e, s) {
            return this._r === t && this._g === i && this._b === e && this._a === s
        }
        oDe(t, i) {
            return t[i] === Math.fround(this._r) && t[i + 1] === Math.fround(this._g) && t[i + 2] === Math.fround(this._b) && t[i + 3] === Math.fround(this._a)
        }
        vDe(t, i) {
            return t[i] === Math.fround(this._r) && t[i + 1] === Math.fround(this._g) && t[i + 2] === Math.fround(this._b)
        }
        multiply(t) {
            this._r *= t._r,
            this._g *= t._g,
            this._b *= t._b,
            this._a *= t._a
        }
        sf(t) {
            this._r *= t,
            this._g *= t,
            this._b *= t,
            this._a *= t
        }
        Vc() {
            return this._r *= this._a,
            this._g *= this._a,
            this._b *= this._a,
            this
        }
        SDe() {
            return this._r /= this._a,
            this._g /= this._a,
            this._b /= this._a,
            this
        }
        Ne() {
            return this._r = oa.Ne(this._r, 0, 1),
            this._g = oa.Ne(this._g, 0, 1),
            this._b = oa.Ne(this._b, 0, 1),
            this._a = oa.Ne(this._a, 0, 1),
            this
        }
        xDe(t) {
            this._r = oa.HOe(t),
            this._g = oa.KOe(t),
            this._b = oa.qOe(t),
            this._a = oa.XOe(t)
        }
        MDe(t, i, e) {
            oa.cO(t),
            oa.cO(i),
            oa.cO(e);
            return `rgb(${100 * (oa.Go(t) ? t : this.getR())}%, ${100 * (oa.Go(i) ? i : this.getG())}%, ${100 * (oa.Go(e) ? e : this.getB())}%)`
        }
        $vi(t, i, e, s) {
            oa.cO(t),
            oa.cO(i),
            oa.cO(e),
            oa.cO(s);
            return `rgba(${100 * (oa.Go(t) ? t : this.getR())}%, ${100 * (oa.Go(i) ? i : this.getG())}%, ${100 * (oa.Go(e) ? e : this.getB())}%, ${oa.Go(s) ? s : this.getA()})`
        }
        DK() {
            const t = Math.round(255 * this.getR())
              , i = Math.round(255 * this.getG())
              , e = Math.round(255 * this.getB());
            return "#" + ua(t.toString(16)) + ua(i.toString(16)) + ua(e.toString(16))
        }
        HK(t) {
            if ("string" != typeof t)
                return !1;
            let i, e, s;
            if ("#" === (t = t.trim()).charAt(0) && (t = t.substr(1)),
            3 === t.length)
                i = parseInt(t[0], 16) / 15,
                e = parseInt(t[1], 16) / 15,
                s = parseInt(t[2], 16) / 15;
            else {
                if (6 !== t.length)
                    return !1;
                i = parseInt(t.substr(0, 2), 16) / 255,
                e = parseInt(t.substr(2, 2), 16) / 255,
                s = parseInt(t.substr(4, 2), 16) / 255
            }
            return isFinite(i) && this.mDe(i),
            isFinite(e) && this.wDe(e),
            isFinite(s) && this.gDe(s),
            this.FC(1),
            !0
        }
        EDe() {
            return `${Math.round(255 * this.getR())}, ${Math.round(255 * this.getG())}, ${Math.round(255 * this.getB())}`
        }
        Rzs() {
            return [Math.round(255 * this.getR()), Math.round(255 * this.getG()), Math.round(255 * this.getB())]
        }
        $zs(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (i.length < 3)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 255
              , s = parseInt(i[1].trim(), 10) / 255
              , n = parseInt(i[2].trim(), 10) / 255;
            return isFinite(e) && this.mDe(e),
            isFinite(s) && this.wDe(s),
            isFinite(n) && this.gDe(n),
            this.FC(1),
            !0
        }
        CDe(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
            if (i.length < 3)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 100
              , s = parseInt(i[1].trim(), 10) / 100
              , n = parseInt(i[2].trim(), 10) / 100;
            return isFinite(e) && this.mDe(e),
            isFinite(s) && this.wDe(s),
            isFinite(n) && this.gDe(n),
            this.FC(1),
            !0
        }
        _De(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (i.length < 4)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 255
              , s = parseInt(i[1].trim(), 10) / 255
              , n = parseInt(i[2].trim(), 10) / 255
              , r = parseFloat(i[3].trim());
            return isFinite(e) && this.mDe(e),
            isFinite(s) && this.wDe(s),
            isFinite(n) && this.gDe(n),
            isFinite(r) && this.FC(r),
            !0
        }
        TDe(t) {
            if ("string" != typeof t)
                return !1;
            const i = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
            if (i.length < 4)
                return !1;
            const e = parseInt(i[0].trim(), 10) / 100
              , s = parseInt(i[1].trim(), 10) / 100
              , n = parseInt(i[2].trim(), 10) / 100
              , r = parseFloat(i[3].trim());
            return isFinite(e) && this.mDe(e),
            isFinite(s) && this.wDe(s),
            isFinite(n) && this.gDe(n),
            isFinite(r) && this.FC(r),
            !0
        }
        AC(t) {
            if ("string" != typeof t)
                return !1;
            if ((t = t.replace(/\s+/, "")).includes(",")) {
                if (t.startsWith("rgb("))
                    return t.includes("%") ? this.CDe(t) : this.$zs(t);
                if (t.startsWith("rgba("))
                    return t.includes("%") ? this.TDe(t) : this._De(t);
                if (t.startsWith("hsl(") || t.startsWith("hsla("))
                    return this.IDe(t);
                {
                    const i = t.split(",");
                    return t.includes("%") ? 3 === i.length ? this.CDe(t) : 4 === i.length && this.TDe(t) : 3 === i.length ? this.$zs(t) : 4 === i.length && this._De(t)
                }
            }
            return this.HK(t)
        }
        toJSON() {
            return [this._r, this._g, this._b, this._a]
        }
        poi(t, i, e, s) {
            let n, r, h;
            if (t %= 360,
            i = oa.Ne(i, 0, 100),
            e = oa.Ne(e, 0, 100),
            s = oa.Ne(s, 0, 1),
            t /= 360,
            e /= 100,
            0 === (i /= 100))
                n = r = h = e;
            else {
                const s = e < .5 ? e * (1 + i) : e + i - e * i
                  , o = 2 * e - s;
                n = ca(o, s, t + 1 / 3),
                r = ca(o, s, t),
                h = ca(o, s, t - 1 / 3)
            }
            return this.mDe(n),
            this.wDe(r),
            this.gDe(h),
            this.FC(s),
            this
        }
        IDe(t) {
            const i = t.replace(/ |hsl|hsla|\(|\)|;/gi, "")
              , e = aa.exec(i)
              , s = la.exec(i);
            return e && 4 === e.length ? (this.poi(+e[1], +e[2], +e[3], 1),
            !0) : !(!s || 5 !== s.length) && (this.poi(+e[1], +e[2], +e[3], +e[4]),
            !0)
        }
        PDe() {
            const t = this._r
              , i = this._g
              , e = this._b
              , s = this._a;
            return `hsla(${oa.Ha.GDe(t, i, e)}, ${oa.Ha.ADe(t, i, e)}%, ${oa.Ha.WTi(t, i, e)}%, ${s})`
        }
        RDe() {
            const t = this._r
              , i = this._g
              , e = this._b;
            return [oa.Ha.GDe(t, i, e), oa.Ha.ADe(t, i, e), oa.Ha.WTi(t, i, e), this._a]
        }
        Kd(t) {
            Array.isArray(t) && (t.length < 3 || (this._r = t[0],
            this._g = t[1],
            this._b = t[2],
            t.length >= 4 ? this._a = t[3] : this._a = 1))
        }
        set r(t) {
            this.mDe(t)
        }
        get r() {
            return this.getR()
        }
        set g(t) {
            this.wDe(t)
        }
        get g() {
            return this.getG()
        }
        set b(t) {
            this.gDe(t)
        }
        get b() {
            return this.getB()
        }
        set a(t) {
            this.FC(t)
        }
        get a() {
            return this.getA()
        }
        Coi(t, i) {
            switch (t) {
            case 0:
                this.mDe(i);
                break;
            case 1:
                this.wDe(i);
                break;
            case 2:
                this.gDe(i);
                break;
            case 3:
                this.FC(i);
                break;
            default:
                throw new RangeError("invalid color index")
            }
        }
        kDe(t) {
            switch (t) {
            case 0:
                return this.getR();
            case 1:
                return this.getG();
            case 2:
                return this.getB();
            case 3:
                return this.getA();
            default:
                throw new RangeError("invalid color index")
            }
        }
        static KNt(t, i) {
            let e, s;
            if (Array.isArray(t))
                e = new oa.Ha,
                e.Kd(t);
            else {
                if (!(t instanceof oa.Ha))
                    throw new Error("unexpected type");
                e = t
            }
            if (Array.isArray(i))
                s = new oa.Ha,
                s.Kd(i);
            else {
                if (!(i instanceof oa.Ha))
                    throw new Error("unexpected type");
                s = i
            }
            return e.equals(s)
        }
        static ODe(t, i) {
            return oa.Ne(Math.max(t, i) - Math.min(t, i), 0, 1)
        }
        static nDs(t, i) {
            const e = new oa.Ha;
            return e.mDe(Math.max(t._r, i._r) - Math.min(t._r, i._r)),
            e.wDe(Math.max(t._g, i._g) - Math.min(t._g, i._g)),
            e.gDe(Math.max(t._b, i._b) - Math.min(t._b, i._b)),
            e.FC(Math.max(t._a, i._a) - Math.min(t._a, i._a)),
            e
        }
        static OVs(t, i) {
            const e = new oa.Ha(0,0,0,1);
            return e.mDe(Math.max(t._r, i._r) - Math.min(t._r, i._r)),
            e.wDe(Math.max(t._g, i._g) - Math.min(t._g, i._g)),
            e.gDe(Math.max(t._b, i._b) - Math.min(t._b, i._b)),
            e
        }
        static GDe(t, i, e) {
            const s = Math.max(t, i, e)
              , n = Math.min(t, i, e);
            if (s === n)
                return 0;
            let r = 0;
            switch (s) {
            case t:
                r = (i - e) / (s - n) + (i < e ? 6 : 0);
                break;
            case i:
                r = (e - t) / (s - n) + 2;
                break;
            case e:
                r = (t - i) / (s - n) + 4
            }
            return Math.round(r / 6 * 360)
        }
        static ADe(t, i, e) {
            const s = Math.max(t, i, e)
              , n = Math.min(t, i, e);
            if (s === n)
                return 0;
            const r = s - n
              , h = (s + n) / 2 > .5 ? r / (2 - s - n) : r / (s + n);
            return Math.round(100 * h)
        }
        static WTi(t, i, e) {
            const s = Math.max(t, i, e)
              , n = (s + Math.min(t, i, e)) / 2;
            return s ? Math.round(100 * n) : 0
        }
    }
    ,
    oa.Ha.DDe = Object.freeze(oa.v(oa.Ha, 1, 1, 1, 1)),
    oa.Ha.FDe = Object.freeze(oa.v(oa.Ha, 0, 0, 0, 1)),
    oa.Ha.LDe = Object.freeze(oa.v(oa.Ha, 0, 0, 0, 0))
}
{
    const da = self.t;
    da.Rect = class {
        constructor(t, i, e, s) {
            this.U6s = NaN,
            this.BDe = NaN,
            this.V6s = NaN,
            this.UDe = NaN,
            this.U6s = 0,
            this.BDe = 0,
            this.V6s = 0,
            this.UDe = 0,
            t instanceof da.Rect ? this.ia(t) : this.set(t || 0, i || 0, e || 0, s || 0)
        }
        set(t, i, e, s) {
            this.U6s = +t,
            this.BDe = +i,
            this.V6s = +e,
            this.UDe = +s
        }
        ff(t, i, e, s) {
            t = +t,
            i = +i,
            this.U6s = t,
            this.BDe = i,
            this.V6s = t + +e,
            this.UDe = i + +s
        }
        ia(t) {
            this.U6s = +t.U6s,
            this.BDe = +t.BDe,
            this.V6s = +t.V6s,
            this.UDe = +t.UDe
        }
        clone() {
            return new da.Rect(this.U6s,this.BDe,this.V6s,this.UDe)
        }
        static NDe(t, i) {
            da.U(t, da.Rect),
            da.U(i, da.Rect);
            const e = new da.Rect;
            return e.u9(Math.min(t.U6s, i.U6s)),
            e.d9(Math.min(t.BDe, i.BDe)),
            e.zC(Math.max(t.V6s, i.V6s)),
            e.p9(Math.max(t.UDe, i.UDe)),
            e
        }
        static lvt(t) {
            return da.Yq(t),
            new da.Rect(t.left,t.top,t.right,t.bottom)
        }
        equals(t) {
            return this.U6s === t.U6s && this.BDe === t.BDe && this.V6s === t.V6s && this.UDe === t.UDe
        }
        jDe(t, i, e, s) {
            return this.U6s === t && this.BDe === i && this.width() === e && this.height() === s
        }
        oDe(t, i) {
            return t[i] === Math.fround(this.U6s) && t[i + 1] === Math.fround(this.BDe) && t[i + 2] === Math.fround(this.V6s) && t[i + 3] === Math.fround(this.UDe)
        }
        u9(t) {
            this.U6s = +t
        }
        Kr() {
            return this.U6s
        }
        d9(t) {
            this.BDe = +t
        }
        Zr() {
            return this.BDe
        }
        zC(t) {
            this.V6s = +t
        }
        gl() {
            return this.V6s
        }
        p9(t) {
            this.UDe = +t
        }
        wl() {
            return this.UDe
        }
        toArray() {
            return [this.U6s, this.BDe, this.V6s, this.UDe]
        }
        yNi() {
            return new Float64Array(this.toArray())
        }
        $De() {
            return new DOMRect(this.U6s,this.BDe,this.width(),this.height())
        }
        static zDe(t) {
            return da.v(da.Rect, t.left, t.top, t.right, t.bottom)
        }
        uDe(t, i) {
            t[i++] = this.U6s,
            t[i++] = this.BDe,
            t[i++] = this.V6s,
            t[i] = this.UDe
        }
        VDe(t, i) {
            t[i++] = this.U6s,
            t[i++] = this.BDe,
            t[i++] = this.V6s,
            t[i++] = this.BDe,
            t[i++] = this.V6s,
            t[i++] = this.UDe,
            t[i++] = this.U6s,
            t[i] = this.UDe
        }
        WDe(t, i, e) {
            t[i++] = this.U6s,
            t[i++] = this.BDe,
            t[i++] = e,
            t[i++] = this.V6s,
            t[i++] = this.BDe,
            t[i++] = e,
            t[i++] = this.V6s,
            t[i++] = this.UDe,
            t[i++] = e,
            t[i++] = this.U6s,
            t[i++] = this.UDe,
            t[i] = e
        }
        width() {
            return this.V6s - this.U6s
        }
        height() {
            return this.UDe - this.BDe
        }
        bl() {
            return (this.U6s + this.V6s) / 2
        }
        yl() {
            return (this.BDe + this.UDe) / 2
        }
        offset(t, i) {
            t = +t,
            i = +i,
            this.U6s += t,
            this.BDe += i,
            this.V6s += t,
            this.UDe += i
        }
        offsetLeft(t) {
            this.U6s += +t
        }
        offsetTop(t) {
            this.BDe += +t
        }
        xl(t) {
            this.V6s += +t
        }
        NCs(t) {
            this.UDe += +t
        }
        OUi(t) {
            if (da.zt(t),
            "x" !== t)
                throw new Error("invalid axis, only 'x' supported");
            this.BDe < this.UDe ? this.U6s < this.V6s ? this.UDe = this.BDe + this.width() : this.UDe = this.BDe - this.width() : this.U6s < this.V6s ? this.UDe = this.BDe - this.width() : this.UDe = this.BDe + this.width()
        }
        Xm(t, i) {
            t = +t,
            i = +i,
            this.U6s -= t,
            this.BDe -= i,
            this.V6s += t,
            this.UDe += i
        }
        ea(t, i) {
            t = +t,
            i = +i,
            this.U6s += t,
            this.BDe += i,
            this.V6s -= t,
            this.UDe -= i
        }
        multiply(t, i) {
            this.U6s *= t,
            this.BDe *= i,
            this.V6s *= t,
            this.UDe *= i
        }
        tb(t, i) {
            this.U6s /= t,
            this.BDe /= i,
            this.V6s /= t,
            this.UDe /= i
        }
        HDe(t) {
            this.U6s = +t - this.U6s,
            this.V6s = +t - this.V6s
        }
        KDe(t) {
            this.BDe = +t - this.BDe,
            this.UDe = +t - this.UDe
        }
        CNi(t, i) {
            const e = this.width()
              , s = this.height()
              , n = this.Kr() + e * t
              , r = this.Zr() + s * i;
            this.ff(n - s * i, r - e * t, s, e)
        }
        qDe() {
            const t = this.U6s;
            this.U6s = this.V6s,
            this.V6s = t
        }
        XDe() {
            const t = this.BDe;
            this.BDe = this.UDe,
            this.UDe = t
        }
        YDe(t) {
            const i = this.BDe;
            this.BDe = +t - this.UDe,
            this.UDe = +t - i
        }
        round() {
            this.U6s = Math.round(this.U6s),
            this.BDe = Math.round(this.BDe),
            this.V6s = Math.round(this.V6s),
            this.UDe = Math.round(this.UDe)
        }
        JDe() {
            this.U6s = Math.ceil(this.U6s),
            this.BDe = Math.ceil(this.BDe),
            this.V6s = Math.floor(this.V6s),
            this.UDe = Math.floor(this.UDe)
        }
        ZDe() {
            this.U6s = Math.floor(this.U6s),
            this.BDe = Math.floor(this.BDe),
            this.V6s = Math.ceil(this.V6s),
            this.UDe = Math.ceil(this.UDe)
        }
        floor() {
            this.U6s = Math.floor(this.U6s),
            this.BDe = Math.floor(this.BDe),
            this.V6s = Math.floor(this.V6s),
            this.UDe = Math.floor(this.UDe)
        }
        ceil() {
            this.U6s = Math.ceil(this.U6s),
            this.BDe = Math.ceil(this.BDe),
            this.V6s = Math.ceil(this.V6s),
            this.UDe = Math.ceil(this.UDe)
        }
        Ne(t, i, e, s) {
            this.U6s = Math.max(this.U6s, +t),
            this.BDe = Math.max(this.BDe, +i),
            this.V6s = Math.min(this.V6s, +e),
            this.UDe = Math.min(this.UDe, +s)
        }
        QDe(t, i, e, s) {
            t = +t,
            i = +i,
            e = +e,
            s = +s,
            this.U6s = da.Ne(this.U6s, t, e),
            this.BDe = da.Ne(this.BDe, i, s),
            this.V6s = da.Ne(this.V6s, t, e),
            this.UDe = da.Ne(this.UDe, i, s)
        }
        normalize() {
            this.U6s > this.V6s && this.qDe(),
            this.BDe > this.UDe && this.XDe()
        }
        Yp(t) {
            return !(t.V6s < this.U6s || t.UDe < this.BDe || t.U6s > this.V6s || t.BDe > this.UDe)
        }
        tFe(t, i, e) {
            return !(t.V6s + i < this.U6s || t.UDe + e < this.BDe || t.U6s + i > this.V6s || t.BDe + e > this.UDe)
        }
        a8(t, i) {
            return t >= this.U6s && t <= this.V6s && i >= this.BDe && i <= this.UDe
        }
        T$(t) {
            return t.U6s >= this.U6s && t.BDe >= this.BDe && t.V6s <= this.V6s && t.UDe <= this.UDe
        }
        Xp(t) {
            t.U6s < this.U6s && (this.U6s = +t.U6s),
            t.BDe < this.BDe && (this.BDe = +t.BDe),
            t.V6s > this.V6s && (this.V6s = +t.V6s),
            t.UDe > this.UDe && (this.UDe = +t.UDe)
        }
        OS(t) {
            this.U6s = da.mi(t.U6s, t.V6s, this.U6s),
            this.BDe = da.mi(t.BDe, t.UDe, this.BDe),
            this.V6s = da.mi(t.U6s, t.V6s, this.V6s),
            this.UDe = da.mi(t.BDe, t.UDe, this.UDe)
        }
    }
}
{
    const fa = self.t;
    fa.Nn = class {
        constructor(t, i, e, s, n, r, h, o) {
            this.iFe = NaN,
            this.eFe = NaN,
            this.sFe = NaN,
            this.nFe = NaN,
            this.rFe = NaN,
            this.hFe = NaN,
            this.oFe = NaN,
            this.aFe = NaN,
            this.iFe = 0,
            this.eFe = 0,
            this.sFe = 0,
            this.nFe = 0,
            this.rFe = 0,
            this.hFe = 0,
            this.oFe = 0,
            this.aFe = 0,
            t instanceof fa.Nn ? this.ia(t) : this.set(t || 0, i || 0, e || 0, s || 0, n || 0, r || 0, h || 0, o || 0)
        }
        set(t, i, e, s, n, r, h, o) {
            this.iFe = +t,
            this.eFe = +i,
            this.sFe = +e,
            this.nFe = +s,
            this.rFe = +n,
            this.hFe = +r,
            this.oFe = +h,
            this.aFe = +o
        }
        Nc(t, i, e, s) {
            this.set(t, i, e, i, e, s, t, s)
        }
        ia(t) {
            this.iFe = t.iFe,
            this.eFe = t.eFe,
            this.sFe = t.sFe,
            this.nFe = t.nFe,
            this.rFe = t.rFe,
            this.hFe = t.hFe,
            this.oFe = t.oFe,
            this.aFe = t.aFe
        }
        equals(t) {
            return this.iFe === t.iFe && this.eFe === t.eFe && this.sFe === t.sFe && this.nFe === t.nFe && this.rFe === t.rFe && this.hFe === t.hFe && this.oFe === t.oFe && this.aFe === t.aFe
        }
        ab(t) {
            this.iFe = +t
        }
        Jn() {
            return this.iFe
        }
        lb(t) {
            this.eFe = +t
        }
        Qn() {
            return this.eFe
        }
        lFe(t) {
            this.sFe = +t
        }
        Hw() {
            return this.sFe
        }
        uFe(t) {
            this.nFe = +t
        }
        rl() {
            return this.nFe
        }
        cFe(t) {
            this.rFe = +t
        }
        al() {
            return this.rFe
        }
        dFe(t) {
            this.hFe = +t
        }
        ll() {
            return this.hFe
        }
        fFe(t) {
            this.oFe = +t
        }
        zc() {
            return this.oFe
        }
        pFe(t) {
            this.aFe = +t
        }
        Ec() {
            return this.aFe
        }
        mFe() {
            return new DOMQuad(new DOMPoint(this.iFe,this.eFe),new DOMPoint(this.sFe,this.nFe),new DOMPoint(this.rFe,this.hFe),new DOMPoint(this.oFe,this.aFe))
        }
        static wFe(t) {
            return fa.v(fa.Nn, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y)
        }
        toArray() {
            return [this.iFe, this.eFe, this.sFe, this.nFe, this.rFe, this.hFe, this.oFe, this.aFe]
        }
        yNi() {
            return new Float64Array(this.toArray())
        }
        uDe(t, i) {
            t[i++] = this.iFe,
            t[i++] = this.eFe,
            t[i++] = this.sFe,
            t[i++] = this.nFe,
            t[i++] = this.rFe,
            t[i++] = this.hFe,
            t[i++] = this.oFe,
            t[i] = this.aFe
        }
        gFe(t, i, e) {
            t[i++] = this.iFe,
            t[i++] = this.eFe,
            t[i++] = e,
            t[i++] = this.sFe,
            t[i++] = this.nFe,
            t[i++] = e,
            t[i++] = this.rFe,
            t[i++] = this.hFe,
            t[i++] = e,
            t[i++] = this.oFe,
            t[i++] = this.aFe,
            t[i] = e
        }
        offset(t, i) {
            t = +t,
            i = +i,
            this.iFe += t,
            this.eFe += i,
            this.sFe += t,
            this.nFe += i,
            this.rFe += t,
            this.hFe += i,
            this.oFe += t,
            this.aFe += i
        }
        round() {
            this.iFe = Math.round(this.iFe),
            this.eFe = Math.round(this.eFe),
            this.sFe = Math.round(this.sFe),
            this.nFe = Math.round(this.nFe),
            this.rFe = Math.round(this.rFe),
            this.hFe = Math.round(this.hFe),
            this.oFe = Math.round(this.oFe),
            this.aFe = Math.round(this.aFe)
        }
        floor() {
            this.iFe = Math.floor(this.iFe),
            this.eFe = Math.floor(this.eFe),
            this.sFe = Math.floor(this.sFe),
            this.nFe = Math.floor(this.nFe),
            this.rFe = Math.floor(this.rFe),
            this.hFe = Math.floor(this.hFe),
            this.oFe = Math.floor(this.oFe),
            this.aFe = Math.floor(this.aFe)
        }
        ceil() {
            this.iFe = Math.ceil(this.iFe),
            this.eFe = Math.ceil(this.eFe),
            this.sFe = Math.ceil(this.sFe),
            this.nFe = Math.ceil(this.nFe),
            this.rFe = Math.ceil(this.rFe),
            this.hFe = Math.ceil(this.hFe),
            this.oFe = Math.ceil(this.oFe),
            this.aFe = Math.ceil(this.aFe)
        }
        sa(t) {
            this.iFe = t.U6s,
            this.eFe = t.BDe,
            this.sFe = t.V6s,
            this.nFe = t.BDe,
            this.rFe = t.V6s,
            this.hFe = t.UDe,
            this.oFe = t.U6s,
            this.aFe = t.UDe
        }
        mr(t, i) {
            0 === i ? this.sa(t) : this.EC(t, Math.sin(i), Math.cos(i))
        }
        EC(t, i, e) {
            const s = t.U6s * i
              , n = t.BDe * i
              , r = t.V6s * i
              , h = t.UDe * i
              , o = t.U6s * e
              , a = t.BDe * e
              , l = t.V6s * e
              , u = t.UDe * e;
            this.iFe = o - n,
            this.eFe = a + s,
            this.sFe = l - n,
            this.nFe = a + r,
            this.rFe = l - h,
            this.hFe = u + r,
            this.oFe = o - h,
            this.aFe = u + s
        }
        Lbs(t) {
            t.set(Math.min(this.iFe, this.sFe, this.rFe, this.oFe), Math.min(this.eFe, this.nFe, this.hFe, this.aFe), Math.max(this.iFe, this.sFe, this.rFe, this.oFe), Math.max(this.eFe, this.nFe, this.hFe, this.aFe))
        }
        a8(t, i) {
            let e = this.sFe - this.iFe
              , s = this.nFe - this.eFe;
            const n = this.rFe - this.iFe
              , r = this.hFe - this.eFe
              , h = t - this.iFe
              , o = i - this.eFe;
            let a = e * e + s * s
              , l = e * n + s * r
              , u = e * h + s * o;
            const c = n * n + r * r
              , d = n * h + r * o;
            let f = 1 / (a * c - l * l)
              , p = (c * u - l * d) * f
              , m = (a * d - l * u) * f;
            return p >= 0 && m > 0 && p + m < 1 || (e = this.oFe - this.iFe,
            s = this.aFe - this.eFe,
            a = e * e + s * s,
            l = e * n + s * r,
            u = e * h + s * o,
            f = 1 / (a * c - l * l),
            p = (c * u - l * d) * f,
            m = (a * d - l * u) * f,
            p >= 0 && m > 0 && p + m < 1)
        }
        bl() {
            return (this.iFe + this.sFe + this.rFe + this.oFe) / 4
        }
        yl() {
            return (this.eFe + this.nFe + this.hFe + this.aFe) / 4
        }
        yFe(t, i, e, s) {
            return !(!this.a8(t, i) && !this.a8(e, s)) || fa.QOe(t, i, e, s, this)
        }
        bFe(t) {
            let i = t.bl()
              , e = t.yl();
            if (this.a8(i, e))
                return !0;
            if (i = this.bl(),
            e = this.yl(),
            t.a8(i, e))
                return !0;
            const s = this.iFe
              , n = this.eFe
              , r = this.sFe
              , h = this.nFe
              , o = this.rFe
              , a = this.hFe
              , l = this.oFe
              , u = this.aFe;
            return fa.QOe(s, n, r, h, t) || fa.QOe(r, h, o, a, t) || fa.QOe(o, a, l, u, t) || fa.QOe(l, u, s, n, t)
        }
        sos() {
            const t = this.iFe
              , i = this.eFe;
            this.iFe = this.sFe,
            this.eFe = this.nFe,
            this.sFe = this.rFe,
            this.nFe = this.hFe,
            this.rFe = this.oFe,
            this.hFe = this.aFe,
            this.oFe = t,
            this.aFe = i
        }
        hb() {
            this.vFe(0, 2),
            this.vFe(1, 3),
            this.vFe(6, 4),
            this.vFe(7, 5)
        }
        aO() {
            this.vFe(0, 6),
            this.vFe(1, 7),
            this.vFe(2, 4),
            this.vFe(3, 5)
        }
        rO() {
            this.vFe(2, 6),
            this.vFe(3, 7)
        }
        vFe(t, i) {
            const e = this.SFe(t);
            this.xFe(t, this.SFe(i)),
            this.xFe(i, e)
        }
        SFe(t) {
            switch (t) {
            case 0:
                return this.iFe;
            case 1:
                return this.eFe;
            case 2:
                return this.sFe;
            case 3:
                return this.nFe;
            case 4:
                return this.rFe;
            case 5:
                return this.hFe;
            case 6:
                return this.oFe;
            case 7:
                return this.aFe;
            default:
                throw new RangeError("invalid quad point index")
            }
        }
        xFe(t, i) {
            switch (i = +i,
            t) {
            case 0:
                this.iFe = i;
                break;
            case 1:
                this.eFe = i;
                break;
            case 2:
                this.sFe = i;
                break;
            case 3:
                this.nFe = i;
                break;
            case 4:
                this.rFe = i;
                break;
            case 5:
                this.hFe = i;
                break;
            case 6:
                this.oFe = i;
                break;
            case 7:
                this.aFe = i;
                break;
            default:
                throw new RangeError("invalid quad point index")
            }
        }
        tb(t, i) {
            this.iFe /= t,
            this.eFe /= i,
            this.sFe /= t,
            this.nFe /= i,
            this.rFe /= t,
            this.hFe /= i,
            this.oFe /= t,
            this.aFe /= i
        }
    }
}
{
    const pa = self.t;
    pa.Crypto = {};
    const ma = "0123456789abcdef";
    pa.Crypto.MFe = function(t) {
        let i = "";
        const e = new Uint8Array(t);
        for (let t = 0; t < e.length; ++t) {
            const s = e[t]
              , n = 15 & s;
            i += ma[s >> 4] + ma[n]
        }
        return i
    }
    ,
    pa.Crypto.aos = function(t) {
        return "string" == typeof t && (t = pa.COe(t)),
        pa.Crypto.dAs(t)
    }
    ,
    pa.Crypto.dAs = function(t) {
        return window.isSecureContext ? crypto.subtle.digest("SHA-256", t).then(pa.Crypto.MFe) : Promise.reject(new Error("web crypto only available on secure origins"))
    }
}
{
    const wa = self.t
      , ga = new Map
      , ya = new Map
      , ba = new Map
      , va = new Map
      , Sa = new Map
      , xa = new Map
      , Ma = new Map
      , Ea = new Map
      , Ca = new Map;
    Ca.set("linear", "noease"),
    Ca.set("default", "noease");
    const _a = ["default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce"]
      , Ta = ["default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce"]
      , Ia = new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
    self.yce = class t {
        constructor() {}
        static Lfe() {
            return "default"
        }
        static Ufe() {
            return "noease"
        }
        static EFe(t) {
            return Ia.get(t)
        }
        static Hfe(i, ...e) {
            let s, n;
            this.CFe(),
            i ? (ba.has(i) || ba.set(i, new Map),
            s = ba.get(i),
            n = [...s.keys()].filter(e => !t._Fe(e, i) || t._Fe(e, i).transition.$Bs())) : (s = Sa,
            n = [...s.keys()]);
            const r = n.sort();
            return [...ya.keys()].concat(r).filter(t => !e.includes(t))
        }
        static TFe() {
            this.CFe();
            const t = [...Sa.keys()];
            return t.sort(),
            [...ya.keys()].concat(t)
        }
        static IFe() {
            this.CFe();
            const t = [...Sa.keys()];
            return t.sort(),
            t
        }
        static s$s(t) {
            wa.zt(t);
            for (const i of _a) {
                if (self.lang(`ui.bars.timeline.eases.${i}`) === t)
                    return !0
            }
            for (const i of Ta) {
                if (self.lang(`ui.bars.timeline.short-eases.${i}`) === t)
                    return !0
            }
        }
        static qfe(t) {
            return wa.zt(t),
            this.CFe(),
            [...ya.keys()].includes(t)
        }
        static PFe(i) {
            wa.zt(i);
            const e = Ca.get(i);
            return e ? ga.get(e) : t.qfe(i) ? ga.get(i) : Ma.has(i) ? Ma.get(i) : void 0
        }
        static Bfe(t) {
            return wa.zt(t),
            this.CFe(),
            Ea.get(t)
        }
        static $js(i, e) {
            wa.zt(i),
            wa.Mw(e, self.gh),
            this.CFe();
            const s = t.PFe(i);
            if (s)
                return s;
            if (!e)
                throw new Error("missing ease function");
            return ba.get(e).get(i)
        }
        static _Fe(t, i) {
            wa.zt(t),
            this.CFe();
            const e = va.get(i);
            if (e)
                return e.get(t)
        }
        static G$s(i, e) {
            wa.zt(i),
            wa.U(e, self.gh),
            this.CFe();
            return !!t.PFe(i) || !!ba.get(e).get(i)
        }
        static GFe(i) {
            wa.zt(i),
            this.CFe();
            const e = t.PFe(i);
            return e || Sa.get(i)
        }
        static AFe(t) {
            return wa.zt(t),
            this.CFe(),
            xa.get(t)
        }
        static RFe(t) {
            wa.Ge(t),
            this.CFe();
            return this.TFe()[t]
        }
        static Q5s(t, i) {
            wa.zt(t),
            this.CFe();
            return this.Hfe(i).indexOf(t)
        }
        static kFe(t) {
            return this.Q5s(t)
        }
        static CFe() {
            0 === ga.size && (this.OFe("default", () => {}
            ),
            this.OFe("noease", [{
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            }], !0),
            this.OFe("easeinsine", [{
                x: 0,
                y: 0,
                sax: .485,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutsine", [{
                x: 0,
                y: 0,
                sax: .038,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.485,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutsine", [{
                x: 0,
                y: 0,
                sax: .336,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.336,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinelastic", [{
                x: 0,
                y: 0,
                sax: .018,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .116,
                y: .002,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .266,
                y: -.005,
                sax: .024,
                say: 0,
                eax: -.021,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .416,
                y: .016,
                sax: .024,
                say: 0,
                eax: -.026,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .566,
                y: -.045,
                sax: .061,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .716,
                y: .132,
                sax: .072,
                say: -.004,
                eax: -.045,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .866,
                y: -.373,
                sax: .06,
                say: 0,
                eax: -.049,
                eay: -.002,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.038,
                eay: -.263,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutelastic", [{
                x: 0,
                y: 0,
                sax: .038,
                say: .263,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .136,
                y: 1.373,
                sax: .049,
                say: .002,
                eax: -.06,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .286,
                y: .868,
                sax: .045,
                say: 0,
                eax: -.072,
                eay: .004,
                se: !0,
                ee: !0
            }, {
                x: .436,
                y: 1.045,
                sax: .025,
                say: 0,
                eax: -.061,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .586,
                y: .984,
                sax: .026,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .736,
                y: 1.005,
                sax: .021,
                say: 0,
                eax: -.024,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .886,
                y: .998,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.018,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutelastic", [{
                x: 0,
                y: 0,
                sax: .025,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .067,
                y: .001,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .18,
                y: -.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .292,
                y: .025,
                sax: .053,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .405,
                y: -.118,
                sax: .069,
                say: 0,
                eax: -.027,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .597,
                y: 1.118,
                sax: .027,
                say: 0,
                eax: -.069,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .71,
                y: .975,
                sax: .025,
                say: 0,
                eax: -.053,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .822,
                y: 1.005,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .935,
                y: .999,
                sax: .025,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinback", [{
                x: 0,
                y: 0,
                sax: .35,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.34,
                eay: -1.579,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutback", [{
                x: 0,
                y: 0,
                sax: .34,
                say: 1.579,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.35,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutback", [{
                x: 0,
                y: 0,
                sax: .035,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .242,
                y: -.1,
                sax: .258,
                say: 0,
                eax: -.025,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: .76,
                y: 1.1,
                sax: .025,
                say: 0,
                eax: -.26,
                eay: 0,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.035,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinbounce", [{
                x: 0,
                y: 0,
                sax: .033,
                say: .025,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .092,
                y: 0,
                sax: .026,
                say: .078,
                eax: -.033,
                eay: .025,
                se: !0,
                ee: !0
            }, {
                x: .274,
                y: 0,
                sax: .097,
                say: .319,
                eax: -.026,
                eay: .078,
                se: !0,
                ee: !0
            }, {
                x: .637,
                y: 0,
                sax: .105,
                say: .625,
                eax: -.097,
                eay: .319,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: -.004,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutbounce", [{
                x: 0,
                y: 0,
                sax: .125,
                say: .004,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .365,
                y: 1,
                sax: .097,
                say: -.319,
                eax: -.105,
                eay: -.625,
                se: !0,
                ee: !0
            }, {
                x: .728,
                y: 1,
                sax: .026,
                say: -.078,
                eax: -.097,
                eay: -.319,
                se: !0,
                ee: !0
            }, {
                x: .91,
                y: 1,
                sax: .033,
                say: -.025,
                eax: -.026,
                eay: -.078,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.033,
                eay: -.025,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutbounce", [{
                x: 0,
                y: 0,
                sax: .01,
                say: .006,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .046,
                y: 0,
                sax: .021,
                say: .038,
                eax: -.01,
                eay: .006,
                se: !0,
                ee: !0
            }, {
                x: .137,
                y: 0,
                sax: .059,
                say: .158,
                eax: -.021,
                eay: .038,
                se: !0,
                ee: !0
            }, {
                x: .319,
                y: 0,
                sax: .117,
                say: .744,
                eax: -.059,
                eay: .158,
                se: !0,
                ee: !0
            }, {
                x: .683,
                y: 1,
                sax: .059,
                say: -.158,
                eax: -.117,
                eay: -.744,
                se: !0,
                ee: !0
            }, {
                x: .865,
                y: 1,
                sax: .021,
                say: -.038,
                eax: -.059,
                eay: -.158,
                se: !0,
                ee: !0
            }, {
                x: .956,
                y: 1,
                sax: .01,
                say: -.006,
                eax: -.021,
                eay: -.038,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.01,
                eay: -.006,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeincubic", [{
                x: 0,
                y: 0,
                sax: .75,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.138,
                eay: -.321,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutcubic", [{
                x: 0,
                y: 0,
                sax: .138,
                say: .321,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.75,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutcubic", [{
                x: 0,
                y: 0,
                sax: .285,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .081,
                say: .272,
                eax: -.081,
                eay: -.272,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.285,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinquad", [{
                x: 0,
                y: 0,
                sax: .4,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.178,
                eay: -.392,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutquad", [{
                x: 0,
                y: 0,
                sax: .178,
                say: .392,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.4,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutquad", [{
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .03,
                say: .065,
                eax: -.03,
                eay: -.065,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinquart", [{
                x: 0,
                y: 0,
                sax: .5,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: -1,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutquart", [{
                x: 0,
                y: 0,
                sax: .25,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.5,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutquart", [{
                x: 0,
                y: 0,
                sax: .765,
                say: .03,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.765,
                eay: -.03,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinquint", [{
                x: 0,
                y: 0,
                sax: .6,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.2,
                eay: -1,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutquint", [{
                x: 0,
                y: 0,
                sax: .2,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.6,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutquint", [{
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .84,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.84,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            }]),
            this.OFe("easeincirc", [{
                x: 0,
                y: 0,
                sax: .25,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.024,
                eay: -.808,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutcirc", [{
                x: 0,
                y: 0,
                sax: .024,
                say: .808,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.25,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutcirc", [{
                x: 0,
                y: 0,
                sax: .125,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: .5,
                y: .5,
                sax: .02,
                say: .428,
                eax: -.02,
                eay: -.428,
                se: !0,
                ee: !0
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.125,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinexpo", [{
                x: 0,
                y: 0,
                sax: .66,
                say: 0,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.14,
                eay: -1,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeoutexpo", [{
                x: 0,
                y: 0,
                sax: .14,
                say: 1,
                eax: 0,
                eay: 0,
                se: !0,
                ee: !1
            }, {
                x: 1,
                y: 1,
                sax: 0,
                say: 0,
                eax: -.66,
                eay: 0,
                se: !1,
                ee: !0
            }]),
            this.OFe("easeinoutexpo", [{
                eax: 0,
                eay: 0,
                ee: !1,
                sax: .345,
                say: 0,
                se: !0,
                x: 0,
                y: 0
            }, {
                eax: -.06,
                eay: -.5,
                ee: !0,
                sax: .06,
                say: .5,
                se: !0,
                x: .5,
                y: .5
            }, {
                eax: -.335,
                eay: 0,
                ee: !0,
                sax: 0,
                say: 0,
                se: !1,
                x: 1,
                y: 1
            }]),
            this.DFe("cubicbezier", this.FFe),
            this.DFe("spline", this.LFe))
        }
        static OFe(i, e, s=!1) {
            if (wa.zt(i),
            "function" == typeof e)
                t.BFe(i, e, "predefined");
            else {
                if (!wa.kft(e))
                    throw new Error("unexpected arguments");
                if (self.PBs) {
                    const n = wa.v(self.PBs, i, s);
                    n.yO(e),
                    t.BFe(i, (t, i, e, s) => n.q5(t, i, e, s), "predefined"),
                    Ea.set(i, n)
                } else {
                    const n = wa.v(wa.mF, [i, e.map(t => [t.x, t.y, t.sax, t.say, t.eax, t.eay, t.se, t.ee])], !1);
                    n.UFe(s),
                    t.BFe(i, (t, i, e, s) => n.q5(t, i, e, s), "predefined")
                }
            }
        }
        static DFe(i, e) {
            wa.zt(i),
            wa.qd(e),
            t.BFe(i, e, "private")
        }
        static I$s(i, e, s, n) {
            wa.zt(i),
            wa.qd(e),
            wa.Mw(s, self.gh),
            wa._U(n),
            this.CFe(),
            t.BFe(i, e, "custom", s, n)
        }
        static E$s(t, i) {
            if (wa.zt(t),
            wa.U(i, self.gh),
            this.qfe(t))
                return;
            if ([...Ma.keys()].includes(t))
                return;
            const e = ba.get(i);
            e && e.delete(t);
            const s = va.get(i);
            s && s.delete(t)
        }
        static BFe(t, i, e, s, n) {
            switch (wa.zt(t),
            wa.qd(i),
            wa.zt(e),
            wa.Mw(s, self.gh),
            wa._U(n),
            e) {
            case "predefined":
                ga.set(t, i),
                ya.set(t, i);
                break;
            case "custom":
                if (s) {
                    ba.has(s) || ba.set(s, new Map),
                    va.has(s) || va.set(s, new Map);
                    ba.get(s).set(t, i);
                    va.get(s).set(t, n)
                } else
                    Sa.set(t, i),
                    xa.set(t, n);
                break;
            case "private":
                ga.set(t, i),
                Ma.set(t, i);
                break;
            default:
                throw new Error("unexpected ease mode")
            }
        }
        static WBs(t, i, e, s) {
            return 0 === s ? i : e * t / s + i
        }
        static FFe(t, i, e, s, n) {
            return i + 3 * t * (e - i) + 3 * t ** 2 * (i + s - 2 * e) + t ** 3 * (n - i + 3 * e - 3 * s)
        }
        static LFe(t, i, e, s, n, r, h, o, a, l) {
            if (s === n && r === h)
                return t;
            const u = Na(t, i, s, r, o, l)
              , c = Da(e, n, h, a)
              , d = Fa(e, n, h, a)
              , f = La(e, n, h, a);
            return Ba(u, c, d, f)
        }
        static C$s(t, i, e, s) {
            const n = []
              , r = Da(t, i, e, s)
              , h = Fa(t, i, e, s)
              , o = La(t, i, e, s);
            for (let t = 0; t < Pa; ++t) {
                const i = Ba(t * Ga, r, h, o);
                n.push(i)
            }
            return n
        }
    }
    ;
    const Pa = 11
      , Ga = 1 / (Pa - 1)
      , Aa = 4
      , Ra = .01
      , ka = 1e-7
      , Oa = 10
      , Da = (t, i, e, s) => s - 3 * e + 3 * i - t
      , Fa = (t, i, e, s) => 3 * e - 6 * i + 3 * t
      , La = (t, i, e, s) => 3 * (i - t)
      , Ba = (t, i, e, s) => ((i * t + e) * t + s) * t
      , Ua = (t, i, e, s) => 3 * i * t * t + 2 * e * t + s
      , Na = (t, i, e, s, n, r) => {
        if (1 == t)
            return 1;
        let h = 0
          , o = 1
          , a = r[o]
          , l = Pa - 1;
        r[Pa - 1];
        for (; o != l && a <= t; )
            o++,
            a = r[o],
            h += Ga;
        o--,
        a = r[o];
        let u = h + (t - a) / (r[o + 1] - a) * Ga;
        const c = Da(i, e, s, n)
          , d = Fa(i, e, s, n)
          , f = La(i, e, s, n)
          , p = Ua(u, c, d, f);
        if (0 === p)
            return u;
        if (p >= Ra) {
            for (let i = 0; i < Aa; ++i) {
                u -= (Ba(u, c, d, f) - t) / Ua(u, c, d, f)
            }
            return u
        }
        {
            let i, e, s = h, n = h + Ga, r = 0;
            do {
                u = s + (n - s) / 2;
                let h = Ba(u, c, d, f) - t;
                h > 0 ? n = u : s = u,
                i = Math.abs(h) > ka,
                e = ++r < Oa
            } while (i && e);
            return u
        }
    }
}
{
    const ja = self.t;
    function $a(t) {
        ja.doe(t) || ja.VY(t)
    }
    ja.gFt = class {
        constructor(t) {
            this._es = [],
            this.rVt = t || "",
            this.NFe = 0
        }
        he() {
            this.tC(),
            this._es = null
        }
        Fa() {
            return this.rVt
        }
        tC() {
            ja.szt(this._es),
            this.NFe = 0
        }
        jFe() {
            return this.NFe
        }
        JFt(t=Math.random() * this.jFe()) {
            ja.rke(t, 0, this.NFe);
            let i = 0;
            for (const [e,s] of this._es)
                if (i += e,
                t < i)
                    return s;
            return 0
        }
        JK() {
            return !!this._es.length
        }
        Pk(t, i) {
            ja.rke(t, 0, 1 / 0),
            $a(i),
            this.NFe += t,
            this._es.push([t, i])
        }
        Xjt(t, i) {
            ja.rke(t, 0, 1 / 0),
            $a(i);
            const e = 0 === t;
            for (let s = 0; s < this._es.length; s++) {
                const n = this._es[s]
                  , r = e || n[0] === t
                  , h = n[1] === i;
                if (r && h) {
                    this._es.splice(s, 1),
                    this.NFe -= n[0];
                    break
                }
            }
        }
        $Fe() {
            return JSON.stringify(this._es)
        }
        static zFe(t, i) {
            ja.zt(t);
            const e = new ja.gFt(i)
              , s = JSON.parse(t);
            ja._D(s);
            for (const t of s) {
                ja._D(t);
                const i = t[0]
                  , s = t[1];
                e.Pk(i, s)
            }
            return e
        }
    }
}
{
    const za = self.t
      , Va = ["alphabetical", "numerical", "no-sort"]
      , Wa = ["ascending", "descending"]
      , Ha = ["auto", "array", "tree", "array-with-meta-info"]
      , Ka = ["all", "root-only"]
      , qa = {
        filter: null,
        S2t: () => !0,
        Jfs: null,
        sort: null,
        order: null,
        a1t: !1,
        h1t: "all",
        result: "auto"
    }
      , Xa = []
      , Ya = [];
    za.TKi = async function(t, i) {
        za.Ske(t),
        wl(i);
        const e = za.v(Qa, "tree", "directories");
        Xa.push(e);
        for (const i of t()) {
            za.qd(i.Fa),
            za.Ske(i.files);
            const t = za.v(Za, i.Fa());
            for (const e of i.files())
                if (e instanceof self.Promise) {
                    const i = await e;
                    za.ake(i, Blob) && (i.name = "dummy-name",
                    i.dummy = !0),
                    t.VFe(i)
                } else
                    za.ake(e, Blob) && (e.name = "dummy-name",
                    e.dummy = !0),
                    t.VFe(e);
            e.WFe(t)
        }
        return el(e, i)
    }
    ,
    za.BRt = function(t) {
        if (t.types)
            for (let i = 0; i < t.types.length; i++)
                if ("Files" === t.types[i] || "application/x-c3-file" === t.types[i])
                    return !0;
        return !1
    }
    ,
    za.JBi = async function(t, i) {
        za.Tke(t, DataTransfer),
        i = wl(i);
        try {
            za.hMi();
            return await gl(t, i) ? await xl(t, i) : await Sl(t, i)
        } catch (t) {
            if (za.$l(t, fl))
                throw t
        }
    }
    ,
    za.CRt = async function(t) {
        return za.Tke(t, DataTransfer),
        za.JBi(t, {
            filter: t => !0,
            Jfs: "",
            sort: "no-sort",
            order: "ascending",
            a1t: !1,
            result: "array"
        })
    }
    ,
    za.n1t = async function(t, i) {
        za.Hut(i),
        i = wl(i),
        za.hMi();
        if (await yl(t, null, i)) {
            const e = za.v(Qa, null, "files");
            return Xa.push(e),
            vl(t, e, i)
        }
        return bl(t, i)
    }
    ,
    za.hMi = function() {
        for (const t of Xa)
            t.he();
        za.sc(Xa);
        for (const t of ol)
            t.he();
        za.sc(ol);
        for (const t of Ya)
            t.he();
        za.sc(Ya)
    }
    ,
    za.B2t = async function(t) {
        if (!za.zk.Lk)
            return Promise.resolve([]);
        const i = Array.from(t.items);
        if (!i.length)
            return Promise.resolve([]);
        if (i[0].getAsFileSystemHandle) {
            const t = [];
            for (let e = 0; e < i.length; e++) {
                const s = i[e];
                t.push(s.getAsFileSystemHandle())
            }
            return (await Promise.all(t)).filter(t => {
                if (t && "directory" === t.kind)
                    return t
            }
            )
        }
        return Promise.resolve([])
    }
    ,
    za.rMi = async function(t) {
        za._D(t);
        const i = t.map(async t => {
            const i = t.file
              , e = t.HFe;
            if (!e)
                return i;
            const s = await e.qfs("animation.frame-durations")
              , n = await e.qfs("animation.frame-image-points")
              , r = await e.qfs("animation.frame-collision-polys")
              , h = await e.qfs("animation.frame-tags")
              , o = self.Iw.Ngs({
                duration: s?.[t.index] ?? 0,
                ims: n?.[t.index] ?? void 0,
                sws: r?.[t.index] ?? void 0,
                tag: h?.[t.index] ?? ""
            });
            return za.fOe(i, {
                Ufs: o
            }),
            i
        }
        );
        return await Promise.all(i)
    }
    ;
    class Ja extends za.Me {
        constructor(t) {
            za.zt(t),
            super(),
            this.rVt = t,
            this.KFe = [],
            this.qFe = [],
            this.XFe = null,
            this.YFe = null,
            this.hVt = null
        }
        he() {
            if (this.KFe)
                for (const t of this.KFe)
                    za.$l(t, Za) && t.he();
            if (this.KFe = null,
            this.qFe)
                for (const t of this.qFe)
                    t.he();
            this.qFe = null,
            this.rVt = null,
            this.XFe = null,
            this.YFe = null,
            this.hVt = null
        }
        lN() {
            for (const t of this.Kfs()) {
                if (za.$l(t, Za) && !t.lN())
                    return !1;
                if (za.g2t(t))
                    return !1
            }
            for (const t of this.c1t())
                if (!t.lN())
                    return !1;
            return !0
        }
        Fa() {
            return this.rVt
        }
        Xfs() {
            return this.KFe
        }
        Kfs() {
            return this.KFe
        }
        c1t() {
            return this.qFe
        }
        Kyt(t) {
            za.U(t, Ja),
            this.hVt = t
        }
        JFe() {
            return !!this.XFe
        }
        ZFe(t) {
            za.e0t(t),
            this.XFe = t
        }
        QFe() {
            return this.XFe
        }
        async tLe(t) {
            if (za.zt(t),
            this.YFe && this.YFe.hasOwnProperty(t))
                return this.YFe[t];
            if (this.XFe) {
                try {
                    const i = await this.XFe.text();
                    if (!za.aMi(this.XFe))
                        throw new Error("unsupported meta info");
                    if (this.YFe = JSON.parse(i),
                    this.YFe.hasOwnProperty(t))
                        return this.YFe[t]
                } catch (t) {
                    throw "unsupported meta info" === t.message ? new pl(this.XFe) : new ml(this.XFe)
                }
                this.XFe = null
            }
            return null
        }
        async qfs(t, i=!0) {
            za.zt(t);
            const e = t.split(".");
            let s;
            try {
                for (; e.length; ) {
                    const n = e.shift();
                    if (s = s ? s[n] : await this.tLe(n),
                    za.Go(s) || za.doe(s) || za.kft(s) || !0 === s || !1 === s)
                        return s;
                    if ((!s || "object" != typeof s) && i) {
                        if (this.hVt)
                            return await this.hVt.qfs(t);
                        if (!this.hVt) {
                            const i = this.Kfs();
                            for (const e of i) {
                                const i = await e.qfs(t, !1);
                                if (za.Go(i) || za.doe(i) || za.kft(i) || !0 === i || !1 === i)
                                    return i
                            }
                        }
                    }
                }
                return za.Go(s) || za.doe(s) || za.kft(s) || !0 === s || !1 === s ? s : void 0
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
        WFe(t) {
            za.Mw(t, Za),
            t && (t.Kyt(this),
            this.KFe.push(t))
        }
        iLe(t) {
            za.Mw(t, Ja),
            t && (t.Kyt(this),
            this.qFe.push(t))
        }
        NDe(t) {
            if (za.Mw(t, Ja),
            t) {
                this.KFe = this.KFe.concat(t.Kfs()),
                this.qFe = this.qFe.concat(t.c1t());
                for (const t of this.KFe)
                    t.Kyt(this);
                for (const t of this.qFe)
                    t.Kyt(this)
            }
        }
        async w1t(t) {
            za.Hut(t);
            let i = [];
            try {
                for (const e of this.Kfs())
                    za.$l(e, Za) && (await e.eLe(t),
                    i = i.concat(e.Xfs())),
                    za.g2t(e) && i.push(e);
                return Za.eLe(t, i),
                i
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
        async sLe(t) {
            za.Hut(t);
            let i = [];
            try {
                for (const e of this.Kfs())
                    za.$l(e, Za) && (await e.eLe(t),
                    i = i.concat(e.Xfs())),
                    za.g2t(e) && i.push(e);
                for (const e of this.c1t()) {
                    const s = await e.sLe(t);
                    i = i.concat(s)
                }
                return Za.eLe(t, i),
                i
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
        async nLe(t) {
            za.Hut(t);
            let i = [];
            try {
                for (const e of this.Kfs())
                    za.$l(e, Za) && (await e.eLe(t),
                    i = i.concat(e.Xfs().map( (t, i) => ({
                        file: t,
                        index: i,
                        HFe: e
                    }))));
                for (const e of this.c1t()) {
                    const s = await e.nLe(t);
                    i = i.concat(s)
                }
                return i
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
        async rLe() {
            const t = this.qFe;
            try {
                let i = "alphabetical";
                switch (t.every(t => {
                    const i = Number(za.EU(t.Fa()));
                    return za.Go(i)
                }
                ) && (i = "numerical"),
                i) {
                case "alphabetical":
                    t.sort( (t, i) => t.Fa().localeCompare(i.Fa()));
                    break;
                case "numerical":
                    t.sort( (t, i) => {
                        let e = Number(za.EU(t.Fa()))
                          , s = Number(za.EU(i.Fa()));
                        return za.Go(e) || (e = 0),
                        za.Go(s) || (s = 0),
                        e - s
                    }
                    )
                }
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
    }
    class Za extends za.Me {
        constructor(t) {
            za.zt(t),
            super(),
            this.rVt = t,
            this.N2t = [],
            this.XFe = null,
            this.YFe = null,
            this.hVt = null
        }
        he() {
            za.sc(this.N2t),
            this.N2t = null,
            this.rVt = null,
            this.XFe = null,
            this.YFe = null,
            this.hVt = null
        }
        lN() {
            return !(this.N2t && this.N2t.length)
        }
        Fa() {
            return this.rVt
        }
        Xfs() {
            return this.N2t
        }
        VFe(t) {
            za.DBt(t),
            t && this.N2t.push(t)
        }
        Kyt(t) {
            za.U(t, Ja),
            this.hVt = t
        }
        JFe() {
            return !!this.XFe
        }
        ZFe(t) {
            za.e0t(t),
            this.XFe = t
        }
        QFe() {
            return this.XFe
        }
        static eLe(t, i, e, s) {
            za.Hut(t),
            za._D(i);
            try {
                let n = e || t.sort
                  , r = s || t.order;
                if (void 0 === t.hLe && void 0 === e) {
                    i.every(t => {
                        const i = Number(za.EU(t.name));
                        return za.Go(i)
                    }
                    ) && (n = "numerical")
                }
                switch (n) {
                case "alphabetical":
                    switch (r) {
                    case "ascending":
                        i.sort( (t, i) => t.name.localeCompare(i.name));
                        break;
                    case "descending":
                        i.sort( (t, i) => t.name.localeCompare(i.name)),
                        i.reverse();
                        break;
                    default:
                        throw new Error(`invalid sort order "${r}", valid orders are "${Wa}"`)
                    }
                    break;
                case "numerical":
                    switch (r) {
                    case "ascending":
                        i.sort( (t, i) => {
                            let e = Number(za.EU(t.name))
                              , s = Number(za.EU(i.name));
                            return za.Go(e) || (e = 0),
                            za.Go(s) || (s = 0),
                            e - s
                        }
                        );
                        break;
                    case "descending":
                        i.sort( (t, i) => {
                            let e = Number(za.EU(t.name))
                              , s = Number(za.EU(i.name));
                            return za.Go(e) || (e = 0),
                            za.Go(s) || (s = 0),
                            s - e
                        }
                        );
                        break;
                    default:
                        throw new Error(`invalid sort order "${r}", valid orders are "${Wa}"`)
                    }
                    break;
                case "no-sort":
                    break;
                default:
                    throw new Error(`invalid sort mode "${n}", valid modes are "${Va}"`)
                }
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
        async eLe(t) {
            za.Hut(t);
            try {
                const i = await this.qfs("sort")
                  , e = await this.qfs("order");
                Za.eLe(t, this.N2t, i, e)
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
        async tLe(t) {
            try {
                return await Ja.prototype.tLe.call(this, t)
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
        async qfs(t, i=!0) {
            try {
                return await Ja.prototype.qfs.call(this, t, i)
            } catch (t) {
                if (za.$l(t, fl))
                    throw t
            }
        }
    }
    class Qa extends Ja {
        constructor(t, i, e) {
            za.Kq(t),
            za.Kq(i),
            za.zAt(e),
            super(t || "root"),
            this.lVt = i,
            e && (1 === e.length && (this.lVt = "file"),
            this.KFe = e)
        }
        Vdt() {
            return this.lVt
        }
        wHt(t) {
            this.lVt = t
        }
        JHi() {
            if ("file" !== this.lVt)
                throw new Error("wrong type");
            return this.KFe[0]
        }
    }
    async function tl(t, i) {
        if (za._D(t),
        za.Hut(i),
        !za.nte(t, Za))
            throw new Error("invalid file collection");
        try {
            for (const e of t)
                await e.eLe(i)
        } catch (t) {
            if (za.$l(t, fl))
                throw t
        }
        return t
    }
    async function il(t) {
        za.U(t, Ja),
        await t.rLe()
    }
    async function el(t, i) {
        if ("array" === i.result) {
            if (za.$l(t, Qa))
                try {
                    return await t.sLe(i)
                } catch (t) {
                    if (za.$l(t, fl))
                        throw t
                }
            else if (za.kft(t))
                return Za.eLe({
                    sort: "numerical",
                    order: "ascending",
                    hLe: !0
                }, t),
                t;
            throw new Error("unexpected filter result")
        }
        if ("array-with-meta-info" === i.result) {
            if (za.$l(t, Qa))
                try {
                    return await t.nLe(i)
                } catch (t) {
                    if (za.$l(t, fl))
                        throw t
                }
            else if (za.kft(t))
                return Za.eLe({
                    sort: "numerical",
                    order: "ascending",
                    hLe: !0
                }, t),
                t.map( (t, i) => ({
                    file: t
                }));
            throw new Error("unexpected filter result")
        }
        if ("tree" === i.result) {
            if (za.$l(t, Qa))
                return t;
            if (za.kft(t)) {
                Za.eLe({
                    sort: "numerical",
                    order: "ascending",
                    hLe: !0
                }, t);
                const i = za.v(Qa, null, "files", t);
                return Xa.push(i),
                i
            }
            throw new Error("unexpected filter result")
        }
        if ("auto" === i.result)
            return t;
        throw new Error("unexpected result mode")
    }
    class sl extends za.Me {
        constructor(t) {
            super(),
            this.SLt = t
        }
        he() {
            this.SLt = null
        }
        oLe() {
            return !1
        }
        aLe() {
            return !0
        }
        lLe() {
            return za.Rke(this.SLt.name, "zip")
        }
        Fa() {
            return this.SLt.name
        }
        uLe() {
            return !!this.oLe() && "__MACOSX" === this.Fa()
        }
        async cLe() {}
        async JHi() {
            return this.SLt
        }
    }
    class nl extends sl {
        constructor(t) {
            super(t)
        }
        oLe() {
            return "directory" === this.SLt.kind
        }
        aLe() {
            return "file" === this.SLt.kind
        }
        lLe() {
            return "file" === this.SLt.kind && za.Rke(this.SLt.name, "zip")
        }
        Fa() {
            return this.SLt.name
        }
        async cLe() {
            try {
                if (this.uLe())
                    return null;
                const t = [];
                for await(const i of this.SLt.values())
                    t.push(i);
                return al(t, "handles").filter(t => t)
            } catch (t) {
                return console.error(t),
                null
            }
        }
        async JHi() {
            try {
                return await this.SLt.getFile()
            } catch (t) {
                return console.error(t),
                null
            }
        }
    }
    class rl extends sl {
        constructor(t) {
            super(t)
        }
        oLe() {
            return this.SLt.isDirectory
        }
        aLe() {
            return this.SLt.isFile
        }
        lLe() {
            return this.SLt.isFile && za.Rke(this.SLt.name, "zip")
        }
        Fa() {
            return this.SLt.name
        }
        async cLe() {
            return new Promise( (t, i) => {
                this.uLe() ? t(null) : this.SLt.createReader().readEntries(i => {
                    t(al(i, "entries").filter(t => t))
                }
                , i => {
                    t(null)
                }
                )
            }
            )
        }
        async JHi() {
            return new Promise( (t, i) => {
                this.SLt.file(async i => {
                    t(i)
                }
                , i => {
                    t(null)
                }
                )
            }
            )
        }
    }
    class hl extends sl {
        constructor(t, i) {
            super(t),
            this.dLe = i
        }
        oLe() {
            return this.SLt.entry.directory
        }
        aLe() {
            return !this.SLt.entry.directory
        }
        lLe() {
            return !this.SLt.entry.directory && za.Rke(this.Fa(), "zip")
        }
        Fa() {
            return za._ye(this.SLt.entry.filename).xye
        }
        async cLe() {
            return new Promise( (t, i) => {
                if (this.uLe())
                    t(null);
                else
                    try {
                        t(al(this.SLt.children, "zip-entries", this.dLe).filter(t => t))
                    } catch (i) {
                        console.error(i),
                        t(null)
                    }
            }
            )
        }
        async JHi() {
            const t = await this.dLe.JRt(this.SLt.entry);
            return za.CU([t], this.Fa(), {
                type: t.type
            })
        }
        he() {
            this.dLe.he(),
            this.dLe = null,
            super.he()
        }
    }
    const ol = [];
    function al(t, i, ...e) {
        if (za.zt(i),
        t = Array.from(t),
        "handles" === i) {
            const i = t.map(t => za.v(nl, t));
            return ol.push(...i),
            i
        }
        if ("entries" === i) {
            const i = t.map(t => za.v(rl, t));
            return ol.push(...i),
            i
        }
        if ("zip-entries" === i) {
            const i = t.map(t => za.v(hl, t, ...e));
            return ol.push(...i),
            i
        }
        if ("files" === i) {
            const i = t.map(t => za.v(sl, t));
            return ol.push(...i),
            i
        }
        throw new Error("unexpected filter result type")
    }
    async function ll(t, i, e, s) {
        za.YJ(t, sl),
        za.U(i, Ja),
        za.Hut(e),
        za.zt(s);
        try {
            const n = za.v(Za, s);
            i.WFe(n);
            for (let r = 0; r < t.length; r++) {
                const h = t[r];
                if (e.Jfs && za.kke(e.Jfs, h.Fa()) && !n.JFe()) {
                    const t = await ul(h);
                    n.ZFe(t),
                    i.ZFe(t)
                } else if (e.a1t && "all" === e.h1t && h.lLe()) {
                    const t = await dl(h, e, i);
                    i.NDe(t)
                } else if (e.a1t && "root-only" === e.h1t && "" === s && h.lLe()) {
                    const t = await dl(h, e, i);
                    i.NDe(t)
                } else if (h.oLe()) {
                    const t = await cl(h, e, i);
                    i.iLe(t)
                } else if (h.aLe()) {
                    const t = await ul(h, e);
                    n.VFe(t)
                }
            }
            return await il(i),
            await tl(i.Kfs(), e)
        } catch (t) {
            if (za.$l(t, fl))
                throw t
        }
    }
    async function ul(t, i) {
        za.U(t, sl),
        za._U(i);
        try {
            const e = await t.JHi();
            if (!e)
                return null;
            if (0 === e.size)
                return null;
            if (i && !i.filter(e))
                return null;
            if (i && !await i.S2t(e))
                return null;
            if (za.ORt(e)) {
                if (!await za.P0t(e))
                    return null
            } else if (za.fye(e)) {
                const t = await za.S0t(e)
                  , i = await za._0t(e);
                if (!t && i)
                    ;
                else if (t && i)
                    ;
                else if (!t || i)
                    return null
            } else if (za.Kye(e)) {
                if (!await za._0t(e))
                    return null
            } else if (za.Xye(e)) {
                if (!await za.j5t(e))
                    return null
            } else if (za.aMi(e)) {
                if (!await za.fLe(e))
                    return null
            } else if (za.pLe(e)) {
                if (!await za.mLe(e))
                    return null
            }
            return await za.wes(e)
        } catch (t) {
            return console.error(t),
            null
        }
    }
    async function cl(t, i, e) {
        za.U(t, sl),
        za.Hut(i),
        za.U(e, Ja);
        try {
            const s = za.v(Ja, t.Fa());
            s.Kyt(e);
            const n = await t.cLe();
            return await ll(n, s, i, t.Fa()),
            s
        } catch (t) {
            if (za.$l(t, fl))
                throw t;
            return console.error(t),
            null
        }
    }
    async function dl(t, i, e) {
        za.U(t, sl),
        za.Hut(i),
        za.U(e, Ja);
        try {
            const s = za.v(Ja, za.EU(t.Fa()));
            s.Kyt(e);
            const n = await ul(t)
              , r = new za.FRt;
            Ya.push(r),
            await r.HRt(n);
            const h = al(r.wLe(), "zip-entries", r);
            return await ll(h, s, i, s.Fa()),
            s
        } catch (t) {
            if (za.$l(t, fl))
                throw t;
            return null
        }
    }
    class fl extends Error {
        constructor(t, i) {
            super(t),
            this.w5t = i
        }
        get file() {
            return this.w5t
        }
    }
    class pl extends fl {
        constructor(t) {
            super("config-file-unsupported-format", t)
        }
    }
    class ml extends fl {
        constructor(t) {
            super("config-file-json-parse-error", t)
        }
    }
    function wl(t) {
        if (za._U(t),
        t = Object.assign({}, qa, t),
        !za.XOt(t.filter))
            throw new Error('"filter" option must be a function');
        if (!za.XOt(t.S2t))
            throw new Error('"asyncFilter" option must be a function');
        if (t.Jfs && !za.doe(t.Jfs))
            throw new Error('"meta_info_file" option must be a string');
        if (!Va.includes(t.sort))
            throw new Error(`invalid "sort" value, valid values are ${Va}`);
        if (!Wa.includes(t.order))
            throw new Error(`invalid "order" value, valid values are ${Wa}`);
        if (!Ha.includes(t.result))
            throw new Error(`invalid "result" value, valid values are ${Ha}`);
        if (!Ka.includes(t.h1t))
            throw new Error(`invalid "extractMode" value, valid values are ${Ka}`);
        return t
    }
    async function gl(t, i) {
        return za.Tke(t, DataTransfer),
        i = wl(i),
        await yl(t.items, t, i)
    }
    async function yl(t, i, e) {
        za.Hut(e);
        const s = Array.from(t);
        if (!s.length)
            return Promise.resolve(!1);
        const n = s[0];
        if (n.webkitGetAsEntry || n.getAsEntry)
            for (let t = 0; t < s.length; t++) {
                const i = s[t];
                let r;
                if (n.webkitGetAsEntry ? r = i.webkitGetAsEntry() : n.getAsEntry && (r = i.getAsEntry()),
                r) {
                    if (r && r.isDirectory)
                        return Promise.resolve(!0);
                    if (e.a1t && r && r.isFile && za.Rke(r.name, "zip"))
                        return Promise.resolve(!0)
                }
            }
        else {
            if (n.getAsFileSystemHandle) {
                const t = [];
                for (let i = 0; i < s.length; i++) {
                    const e = s[i];
                    t.push(e.getAsFileSystemHandle())
                }
                const n = await Promise.all(t);
                return i.c3_filesystem_handles = n,
                n.some(t => {
                    if (t) {
                        if ("directory" === t.kind)
                            return !0;
                        if (e.a1t && "file" === t.kind && za.Rke(t.name, "zip"))
                            return !0
                    }
                }
                )
            }
            if (za.g2t(n) && e.a1t)
                for (const t of s)
                    if (za.Rke(t.name, "zip"))
                        return Promise.resolve(!0)
        }
        return Promise.resolve(!1)
    }
    async function bl(t, i) {
        za.Hut(i),
        i = wl(i);
        try {
            const e = Array.from(t).filter(t => 0 !== t.size).filter(t => i.filter(t)).map(async t => {
                if (!await i.S2t(t))
                    return null;
                if (za.ORt(t)) {
                    if (!await za.P0t(t))
                        return null
                } else if (za.fye(t)) {
                    const i = await za.S0t(t)
                      , e = await za._0t(t);
                    if (!i && e)
                        ;
                    else if (i && e)
                        ;
                    else if (!i || e)
                        return null
                } else if (za.Kye(t)) {
                    if (!await za._0t(t))
                        return null
                } else if (za.Xye(t)) {
                    if (!await za.j5t(t))
                        return null
                } else if (za.aMi(t)) {
                    if (!await za.fLe(t))
                        return null
                } else if (za.pLe(t)) {
                    if (!await za.mLe(t))
                        return null
                }
                try {
                    return await za.wes(t)
                } catch (t) {
                    return console.error(t),
                    null
                }
            }
            )
              , s = (await Promise.all(e)).filter(t => t);
            return await el(s, i)
        } catch (t) {
            if (za.$l(t, fl))
                throw t
        }
    }
    async function vl(t, i, e) {
        za.U(i, Ja),
        za._U(e),
        e = wl(e);
        const s = al(t, i.Vdt());
        try {
            return await ll(s, i, e, ""),
            i.wHt("directories"),
            await el(i, e)
        } catch (t) {
            if (za.$l(t, fl))
                throw t
        }
    }
    async function Sl(t, i) {
        za.Tke(t, DataTransfer),
        za._U(i),
        i = wl(i);
        let e = !1;
        if (t.c3_filesystem_handles && (e = t.c3_filesystem_handles.every(t => !t)),
        t.c3_filesystem_handles && !e) {
            const e = t.c3_filesystem_handles.map(t => t.getFile())
              , s = await Promise.all(e);
            return await bl(s, i)
        }
        return await bl(t.files, i)
    }
    async function xl(t, i) {
        za.Tke(t, DataTransfer),
        za._U(i),
        i = wl(i);
        const e = za.v(Qa);
        Xa.push(e);
        const s = t.items[0];
        let n = null;
        try {
            if (t.c3_filesystem_handles)
                e.wHt("handles"),
                n = await vl(t.c3_filesystem_handles, e, i);
            else if (s.getAsFileSystemHandle) {
                e.wHt("handles");
                const s = Array.from(t.items).map(t => t.getAsFileSystemHandle())
                  , r = await Promise.all(s);
                t.c3_filesystem_handles = r,
                n = await vl(r, e, i)
            } else if (s.webkitGetAsEntry) {
                e.wHt("entries");
                const s = Array.from(t.items).map(t => t.webkitGetAsEntry()).filter(t => !!t);
                n = await vl(s, e, i)
            }
            if (!e.Vdt())
                throw new Error("data transfer has no entries");
            return e.wHt("directories"),
            await el(e, i)
        } catch (t) {
            if (za.$l(t, fl))
                throw t
        }
    }
}
{
    const Ml = self.t;
    Ml.P0t = async function(t) {
        if (Ml.e0t(t),
        !Ml.ORt(t))
            return !1;
        const i = t.slice(0, 8)
          , e = new DataView(await i.arrayBuffer());
        switch (Ml.MimeType.gLe(t)) {
        case "image/png":
        case "image/apng":
            return 2303741511 === e.getUint32(0) && 218765834 === e.getUint32(4);
        case "image/jpeg":
            return 255 === e.getUint8(0) && 216 === e.getUint8(1) && 255 === e.getUint8(2);
        case "image/webp":
            return 1380533830 === e.getUint32(0);
        case "image/gif":
            return 1195984440 === e.getUint32(0);
        case "image/bmp":
            return 16973 === e.getUint16(0);
        case "image/x-icon":
            return 256 === e.getUint32(0);
        case "image/svg+xml":
            try {
                const i = await Ml.gle(t)
                  , e = new self.DOMParser;
                return 0 === e.parseFromString(i, "image/svg+xml").getElementsByTagName("parsererror").length
            } catch (t) {
                return !1
            }
        case "image/avif":
        case "image/tiff":
        case "image/jxl":
            {
                const i = self.URL.createObjectURL(t);
                let e = new Image;
                e.src = i;
                try {
                    return await e.decode(),
                    URL.revokeObjectURL(i),
                    e = null,
                    !0
                } catch (t) {
                    return URL.revokeObjectURL(i),
                    e = null,
                    !1
                }
            }
        default:
            return !1
        }
    }
    ,
    Ml.ORt = function(t) {
        return Ml.e0t(t),
        t.type ? -1 !== t.type.search(/image\/.*/) : Ml.K3t(t.name)
    }
    ,
    Ml.K3t = function(t) {
        Ml.zt(t);
        return -1 !== Ml.MimeType.H3t(Ml.Uh(t)).uL().search(/image\/.*/)
    }
    ,
    Ml.S0t = async function(t) {
        if (Ml.e0t(t),
        !Ml.fye(t) && !Ml.Kye(t))
            return !1;
        const i = t.slice(0, 128)
          , e = new DataView(await i.arrayBuffer());
        switch (Ml.MimeType.gLe(t)) {
        case "audio/ogg":
        case "video/ogg":
            if (1332176723 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer()
                      , e = (new TextDecoder).decode(i);
                    if (e.includes("OpusHead") || e.includes("vorbis") && !e.includes("theora"))
                        return !0
                } catch (t) {}
            return !1;
        case "audio/webm":
        case "video/webm":
            if (440786851 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer()
                      , e = (new TextDecoder).decode(i);
                    if (e.includes("A_OPUS") || e.includes("A_VORBIS") && !(e.includes("V_VP8") || e.includes("V_VP9") || e.includes("V_AV1")))
                        return !0
                } catch (t) {}
            return !1;
        case "audio/wav":
        case "audio/x-wav":
            return 1380533830 === e.getUint32(0, !1) && 1463899717 === e.getUint32(8, !1);
        case "audio/flac":
            return 1716281667 === e.getUint32(0, !1);
        case "audio/mpeg":
        case "video/mpeg":
            try {
                const i = await t.slice(0, 65536).arrayBuffer()
                  , e = new DataView(i);
                let s = 0;
                if (73 === e.getUint8(0) && 68 === e.getUint8(1) && 51 === e.getUint8(2)) {
                    s = 10 + ((127 & e.getUint8(6)) << 21 | (127 & e.getUint8(7)) << 14 | (127 & e.getUint8(8)) << 7 | 127 & e.getUint8(9))
                }
                if (s + 1 >= e.byteLength)
                    return !1;
                const n = e.getUint8(s)
                  , r = e.getUint8(s + 1);
                return 255 === n && !(224 & ~r)
            } catch (t) {}
            return !1;
        case "audio/midi":
        case "audio/x-midi":
            return 1297377380 === e.getUint32(0, !1);
        case "audio/mp4":
        case "video/mp4":
            if (1718909296 === !e.getUint32(4, !1))
                return !1;
        default:
            {
                const i = new Promise(i => {
                    const e = document.createElement("audio")
                      , s = URL.createObjectURL(t);
                    e.preload = "metadata";
                    const n = t => {
                        e.removeEventListener("loadedmetadata", r),
                        e.removeEventListener("error", h),
                        URL.revokeObjectURL(s),
                        e.pause(),
                        e.removeAttribute("src"),
                        e.load(),
                        i(t)
                    }
                      , r = () => n(!0)
                      , h = () => n(!1);
                    e.addEventListener("loadedmetadata", r),
                    e.addEventListener("error", h),
                    e.src = s
                }
                )
                  , e = new Promise(i => {
                    const e = document.createElement("video")
                      , s = URL.createObjectURL(t);
                    e.preload = "metadata";
                    const n = t => {
                        const n = e.videoWidth
                          , o = e.videoHeight
                          , a = Ml.Go(n) && n > 0 && Ml.Go(o) && o > 0;
                        e.removeEventListener("loadedmetadata", r),
                        e.removeEventListener("error", h),
                        URL.revokeObjectURL(s),
                        e.pause(),
                        e.removeAttribute("src"),
                        e.load(),
                        i(a)
                    }
                      , r = () => n()
                      , h = () => n();
                    e.addEventListener("loadedmetadata", r),
                    e.addEventListener("error", h),
                    e.src = s
                }
                )
                  , s = await Promise.all([i, e]);
                return s[0] && !s[1]
            }
        }
    }
    ,
    Ml.fye = function(t) {
        return Ml.e0t(t),
        t.type ? -1 !== t.type.search(/audio\/.*/) || (-1 !== t.type.search(/ogg/) || -1 !== t.type.search(/webm/)) : Ml.Z3t(t.name)
    }
    ,
    Ml.Z3t = function(t) {
        Ml.zt(t);
        const i = Ml.MimeType.H3t(Ml.Uh(t)).uL();
        return -1 !== i.search(/audio\/.*/) || (-1 !== i.search(/ogg/) || -1 !== i.search(/webm/))
    }
    ,
    Ml._0t = async function(t) {
        if (Ml.e0t(t),
        !Ml.fye(t) && !Ml.Kye(t))
            return !1;
        const i = t.slice(0, 128)
          , e = new DataView(await i.arrayBuffer());
        switch (Ml.MimeType.gLe(t)) {
        case "video/webm":
        case "audio/webm":
            if (440786851 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer()
                      , e = (new TextDecoder).decode(i);
                    if (e.includes("V_VP8") || e.includes("V_VP9") || e.includes("V_AV1"))
                        return !0
                } catch (t) {}
            return !1;
        case "video/ogg":
        case "audio/ogg":
            if (1332176723 === e.getUint32(0, !1))
                try {
                    const i = await t.slice(0, 65536).arrayBuffer();
                    if ((new TextDecoder).decode(i).includes("theora"))
                        return !0
                } catch (t) {}
            return !1;
        case "video/avi":
        case "video/x-msvideo":
            return 1380533830 === e.getUint32(0, !1) && 1096173856 === e.getUint32(8, !1);
        case "video/mpeg":
        case "audio/mpeg":
            try {
                const i = await t.slice(0, 65536).arrayBuffer()
                  , e = new DataView(i);
                if (442 !== e.getUint32(0, !1))
                    return !1;
                for (let t = 4; t < e.byteLength - 3; t++)
                    if (0 === e.getUint8(t) && 0 === e.getUint8(t + 1) && 1 === e.getUint8(t + 2) && e.getUint8(t + 3) >= 224 && e.getUint8(t + 3) <= 239)
                        return !0
            } catch (t) {}
            return !1;
        case "video/quicktime":
        case "video/mp4":
        case "audio/mp4":
            if (1718909296 !== e.getUint32(4, !1))
                return !1;
        default:
            return new Promise(i => {
                const e = document.createElement("video")
                  , s = URL.createObjectURL(t);
                e.preload = "metadata";
                const n = t => {
                    const n = e.videoWidth
                      , o = e.videoHeight
                      , a = Ml.Go(n) && n > 0 && Ml.Go(o) && o > 0;
                    e.removeEventListener("loadedmetadata", r),
                    e.removeEventListener("error", h),
                    URL.revokeObjectURL(s),
                    e.pause(),
                    e.removeAttribute("src"),
                    e.load(),
                    i(a)
                }
                  , r = () => n()
                  , h = () => n();
                e.addEventListener("loadedmetadata", r),
                e.addEventListener("error", h),
                e.src = s
            }
            )
        }
    }
    ,
    Ml.Kye = function(t) {
        return Ml.e0t(t),
        t.type ? -1 !== t.type.search(/video\/.*/) || (-1 !== t.type.search(/ogg/) || -1 !== t.type.search(/webm/)) : Ml.J3t(t.name)
    }
    ,
    Ml.J3t = function(t) {
        Ml.zt(t);
        const i = Ml.MimeType.H3t(Ml.Uh(t)).uL();
        return -1 !== i.search(/video\/.*/) || (-1 !== i.search(/ogg/) || -1 !== i.search(/webm/))
    }
    ;
    const El = new Map;
    Ml.yLe = async function(t) {
        if (El.has(t.name))
            return El.get(t.name);
        try {
            if (await Ml.j5t(t) && El.has(t.name))
                return El.get(t.name)
        } catch (t) {}
    }
    ,
    Ml.j5t = async function(t) {
        if (Ml.e0t(t),
        !Ml.Xye(t))
            return !1;
        if (El.has(t.name))
            return !0;
        const i = t.slice(0, 12)
          , e = new DataView(await i.arrayBuffer());
        let s = !1;
        switch (Ml.MimeType.gLe(t)) {
        case "application/font-woff":
            2001684038 === e.getUint32(0, !1) && (s = !0);
            break;
        case "font/woff2":
            2001684018 === e.getUint32(0, !1) && (s = !0);
            break;
        case "application/font-sfnt":
            {
                const t = e.getUint32(0, !1);
                65536 !== t && 1330926671 !== t || (s = !0);
                break
            }
        case "application/vnd.ms-fontobject":
            if (e.byteLength >= 36) {
                const i = t.slice(34, 36)
                  , e = new DataView(await i.arrayBuffer()).getUint16(0, !0);
                1 !== e && 2 !== e || (s = !0);
                break
            }
        }
        if (s) {
            const i = URL.createObjectURL(t);
            try {
                const e = new globalThis.FontFace(t.name,`url(${i})`);
                return await e.load(),
                El.set(t.name, e),
                !0
            } catch (t) {
                return !1
            } finally {
                URL.revokeObjectURL(i)
            }
        }
        return !1
    }
    ,
    Ml.Xye = function(t) {
        return Ml.e0t(t),
        t.type ? t.type.includes("font") : Ml.X3t(t.name)
    }
    ,
    Ml.X3t = function(t) {
        Ml.zt(t);
        return Ml.MimeType.H3t(Ml.Uh(t)).UH()
    }
    ,
    Ml.B5t = function(t) {
        if (Ml.e0t(t),
        t.type) {
            const i = Ml.MimeType.$s(t.type);
            return i.nL() || i.iL()
        }
        return Ml.Y3t(t.name)
    }
    ,
    Ml.Y3t = function(t) {
        Ml.zt(t);
        const i = Ml.MimeType.H3t(Ml.Uh(t));
        return i.nL() || i.iL()
    }
    ,
    Ml.x0t = function(t) {
        return Ml.zt(t),
        Ml.MimeType.H3t(Ml.Uh(t)).nL()
    }
    ,
    Ml.A0t = function(t) {
        return Ml.zt(t),
        Ml.MimeType.H3t(Ml.Uh(t)).iL()
    }
    ,
    Ml.i5t = function(t) {
        Ml.zt(t);
        return Ml.MimeType.H3t(Ml.Uh(t)).bLe()
    }
    ,
    Ml.Q3t = function(t) {
        Ml.zt(t);
        const i = Ml.Uh(t)
          , e = Ml.MimeType.H3t(i).uL();
        return "application/zip" === e && ".c3p" === i || "application/octet-stream" === e && ".c3p" === i
    }
    ,
    Ml.t5t = function(t) {
        Ml.zt(t);
        const i = Ml.Uh(t)
          , e = Ml.MimeType.H3t(i).uL();
        return "application/zip" === e && ".capx" === i || "application/octet-stream" === e && ".capx" === i
    }
    ,
    Ml.s5t = function(t) {
        Ml.zt(t);
        const i = Ml.Uh(t)
          , e = Ml.MimeType.H3t(i).uL();
        return "application/x-construct3-addon" === e && ".c3addon" === i || "application/octet-stream" === e && ".c3addon" === i
    }
    ,
    Ml.e5t = function(t) {
        Ml.zt(t);
        const i = Ml.Uh(t)
          , e = Ml.MimeType.H3t(i).uL();
        return "application/x-construct2-addon" === e && ".c2addon" === i || "application/octet-stream" === e && ".c2addon" === i
    }
    ,
    Ml.o1t = async function(t) {
        if (Ml.e0t(t),
        !Ml.vLe(t))
            return !1;
        const i = new Uint8Array(await t.slice(0, 4).arrayBuffer()).join(" ");
        return ["80 75 3 4", "80 75 5 6", "80 75 7 8"].includes(i)
    }
    ,
    Ml.vLe = function(t) {
        return Ml.e0t(t),
        t.type ? !!t.type.match("zip") : Ml.d5t(t.name)
    }
    ,
    Ml.d5t = function(t) {
        Ml.zt(t);
        const i = Ml.Uh(t)
          , e = Ml.MimeType.H3t(i).uL();
        return "application/zip" === e && ".zip" === i || "application/octet-stream" === e && ".zip" === i
    }
    ,
    Ml.fLe = async function(t) {
        Ml.e0t(t);
        try {
            const i = await Ml.gle(t);
            return JSON.parse(i)
        } catch (t) {
            return !1
        }
    }
    ,
    Ml.aMi = function(t) {
        return Ml.e0t(t),
        t.type ? !!t.type.match("json") : Ml.lMi(t.name)
    }
    ,
    Ml.lMi = function(t) {
        Ml.zt(t);
        return !!Ml.MimeType.H3t(Ml.Uh(t)).uL().match("json")
    }
    ,
    Ml.mLe = async function(t) {
        if (Ml.e0t(t),
        !Ml.pLe(t))
            return !1;
        try {
            const i = await Ml.gle(t);
            return !(new DOMParser).parseFromString(i, "application/xml").querySelector("parsererror")
        } catch (t) {
            return !1
        }
    }
    ,
    Ml.pLe = function(t) {
        return Ml.e0t(t),
        t.type ? !!t.type.match("text/xml") || "text/xml" === t.type : Ml.lMi(t.name)
    }
    ,
    Ml.SLe = function(t) {
        Ml.zt(t);
        const i = Ml.MimeType.H3t(Ml.Uh(t)).uL();
        return !!i.match("text/xml") || "text/xml" === i
    }
    ,
    Ml._2t = async function(t) {
        if (Ml.e0t(t),
        !Ml.T0t(t))
            return !1;
        try {
            const i = await Ml.gle(t)
              , e = new self.DOMParser;
            return 0 === e.parseFromString(i, "image/svg+xml").getElementsByTagName("parsererror").length
        } catch (t) {
            return !1
        }
    }
    ,
    Ml.T0t = function(t) {
        return Ml.e0t(t),
        t.type ? !!t.type.match("image/svg+xml") || "image/svg+xml" === t.type : Ml.T2t(t.name)
    }
    ,
    Ml.T2t = function(t) {
        Ml.zt(t);
        const i = Ml.MimeType.H3t(Ml.Uh(t)).uL();
        return !!i.match("image/svg+xml") || "image/svg+xml" === i
    }
    ,
    Ml.xLe = function(t) {
        return Ml.e0t(t),
        Ml.MimeType.NAs(t).WU()
    }
    ,
    Ml.nQ = function(t) {
        return Ml.e0t(t),
        t.type ? Ml.MimeType.$s(t.type).MLe() : Ml.MimeType.H3t(Ml.Uh(t.name)).MLe()
    }
    ,
    Ml.W3t = function(t) {
        Ml.zt(t);
        const i = Ml.MimeType.H3t(Ml.Uh(t));
        return i?.MLe()
    }
    ,
    Ml.I0t = async function(t) {
        if (Ml.e0t(t),
        !Ml.ORt(t))
            return !1;
        const i = await t.slice(0, 32768).arrayBuffer()
          , e = new DataView(i)
          , s = new TextDecoder("utf-8")
          , n = new Uint8Array(i)
          , r = s.decode(n.subarray(0, 6));
        if ("GIF89a" === r || "GIF87a" === r) {
            let t = 6
              , e = 0;
            for (; t + 1 < i.byteLength; ) {
                if (33 === n[t] && 249 === n[t + 1] && (e++,
                e > 1))
                    return !0;
                t++
            }
            return !1
        }
        if ([137, 80, 78, 71, 13, 10, 26, 10].every( (t, i) => n[i] === t)) {
            let t = 8;
            for (; t + 8 <= i.byteLength && !(t + 8 > i.byteLength); ) {
                const r = e.getUint32(t, !1)
                  , h = s.decode(n.subarray(t + 4, t + 8));
                if (r > i.byteLength - t - 12)
                    break;
                if ("acTL" === h)
                    return !0;
                if ("IDAT" === h || "IEND" === h)
                    break;
                t += 8 + r + 4
            }
            return !1
        }
        const h = s.decode(n.subarray(0, 4))
          , o = s.decode(n.subarray(8, 12));
        if ("RIFF" === h && "WEBP" === o) {
            let t = 12;
            for (; t + 8 <= i.byteLength; ) {
                const r = s.decode(n.subarray(t, t + 4))
                  , h = e.getUint32(t + 4, !0);
                if (h > i.byteLength - t - 8)
                    break;
                if ("ANIM" === r)
                    return !0;
                t += 8 + h + h % 2
            }
            return !1
        }
        return !1
    }
    ,
    Ml.g3t = async function(t) {
        Ml.e0t(t);
        const i = await t.slice(0, 1024).arrayBuffer()
          , e = new globalThis.Uint8Array(i);
        try {
            const t = new TextDecoder("utf-8",{
                fatal: !0
            }).decode(e)
              , i = (new TextEncoder).encode(t);
            if (i.length !== e.length)
                return !1;
            for (let t = 0; t < i.length; t++)
                if (i[t] !== e[t])
                    return !1;
            return !0
        } catch (t) {
            return !1
        }
    }
}
{
    const Cl = self.t
      , _l = self.assert
      , Tl = new Map;
    Cl.OMi = class {
        static _Yt(t, i) {
            Tl.set(t, i)
        }
        static YMi(t, i) {
            Cl.zt(t),
            Cl.qd(i);
            const e = Tl.get(t);
            return _l(e, `missing ignore function for user '${t}'`),
            new Promise(async (t, s) => {
                if (!e())
                    return void s("ignore-results");
                const n = await i();
                e() ? t(n) : s("ignore-results")
            }
            )
        }
        static LMi(t, i) {
            if (Cl.X_t(i),
            Cl.$l(t, Error)) {
                if ("ignore-results" !== t.message) {
                    if (!i)
                        throw t;
                    i(t)
                }
            } else {
                if (!Cl.doe(t))
                    throw new Error("missing error argument");
                if ("ignore-results" !== t) {
                    const e = new Error(t);
                    if (!i)
                        throw e;
                    i(e)
                }
            }
        }
    }
}
{
    const Il = self.t
      , Pl = Il.m3;
    function Gl(t, i, e, s) {
        return Il.Ge(t),
        Il.Ge(i),
        Il.Ge(e),
        Il.Ge(s),
        !(s < t) && !(i < e)
    }
    function Al(t, i, e, s, n, r) {
        Il.U(t, Pl),
        Il.U(i, Pl),
        Il.YJ(e, Pl),
        Il.YJ(s, Pl),
        Il.U(n, Pl),
        Il.Mw(r, Fl);
        const h = [0, 0]
          , o = [0, 0]
          , a = new Pl;
        a.ia(i),
        a.offset(-t.s8(), -t.e8());
        const l = a.dot(n);
        if (kl(e, n, h),
        kl(s, n, o),
        o[0] += l,
        o[1] += l,
        h[0] > o[1] || o[0] > h[1])
            return !0;
        if (!r)
            return !1;
        let u = 0;
        if (h[0] < o[0])
            if (h[1] < o[1])
                u = h[1] - o[0];
            else {
                const t = h[1] - o[0]
                  , i = o[1] - h[0];
                u = t < i ? t : -i
            }
        else if (h[1] > o[1])
            u = h[0] - o[1];
        else {
            const t = h[1] - o[0]
              , i = o[1] - h[0];
            u = t < i ? t : -i
        }
        const c = Math.abs(u);
        return c < r.ELe() && (r.CLe(c),
        r._Le().ia(n),
        u < 0 && r._Le().reverse()),
        !1
    }
    function Rl(t, i, e) {
        Il.U(t, Ol),
        Il.U(i, Ol),
        Il.Mw(e, Fl);
        const s = t.TLe()
          , n = s.length
          , r = i.TLe()
          , h = r.length
          , o = t.tnt()
          , a = i.tnt()
          , l = t.ILe()
          , u = i.ILe();
        for (let t = 0; t < n; t++)
            if (Al(o, a, s, r, l[t], e))
                return !1;
        for (let t = 0; t < h; t++)
            if (Al(o, a, s, r, u[t], e))
                return !1;
        if (e) {
            e.PLe(t),
            e.GLe(i);
            const s = e.pct();
            s.ia(e._Le()),
            s.scale(e.ELe(), e.ELe())
        }
        return !0
    }
    function kl(t, i, e) {
        Il.YJ(t, Pl),
        Il.U(i, Pl),
        Il._D(e),
        Il.Ge(e[0]),
        Il.Ge(e[1]);
        let s = Number.MAX_VALUE
          , n = -Number.MAX_VALUE;
        const r = t.length;
        for (let e = 0; e < r; e++) {
            const r = t[e].dot(i);
            r < s && (s = r),
            r > n && (n = r)
        }
        e[0] = s,
        e[1] = n
    }
    class Ol {
        constructor(t, i, e) {
            Il.Ge(t),
            Il.Ge(i),
            Il.YJ(e, Pl),
            this.ALe = new Pl(t,i),
            this.Cps = null,
            this.RLe = new Pl,
            this.kLe = new Pl,
            this.OLe = null,
            this.DLe = null,
            this.FLe = null,
            this.Eps(e)
        }
        he() {
            this.ALe = null,
            this.RLe = null,
            this.kLe = null,
            Il.sc(this.Cps),
            this.Cps = null,
            this.RLe = null,
            Il.sc(this.OLe),
            this.OLe = null,
            Il.sc(this.DLe),
            this.DLe = null,
            Il.sc(this.FLe),
            this.FLe = null
        }
        tnt() {
            return this.ALe
        }
        LLe() {
            return this.RLe
        }
        ILe() {
            return this.FLe
        }
        BLe() {
            return this.DLe
        }
        TLe() {
            return this.OLe
        }
        Eps(t) {
            if (!this.Cps || this.Cps.length !== t.length) {
                var i = this.OLe = []
                  , e = this.DLe = []
                  , s = this.FLe = [];
                for (let n = 0; n < t.length; n++)
                    i.push(new Pl),
                    e.push(new Pl),
                    s.push(new Pl)
            }
            this.Cps = t,
            this.uu()
        }
        gt() {
            this.RLe.set(this.ALe.s8(), this.ALe.e8())
        }
        Eht() {
            this.RLe.set(0, 0)
        }
        Zht() {
            this.kLe.set(this.ALe.s8(), this.ALe.e8())
        }
        s7() {
            this.ALe.set(this.kLe.s8(), this.kLe.e8()),
            this.kLe.set(0, 0)
        }
        Jht(t, i) {
            Il.Ge(t),
            Il.Ge(i),
            this.ALe.set(this.RLe.s8() + t, this.RLe.e8() + i)
        }
        Knt(t, i) {
            Il.Ge(t),
            Il.Ge(i),
            this.ALe.offset(t, i)
        }
        uu() {
            const t = this.OLe
              , i = this.DLe
              , e = this.FLe
              , s = this.Cps
              , n = s.length;
            for (let i = 0; i < n; i++)
                t[i].ia(s[i]);
            for (let s = 0; s < n; s++) {
                var r = t[s]
                  , h = s < n - 1 ? t[s + 1] : t[0]
                  , o = i[s];
                o.ia(h),
                o.offset(-r.s8(), -r.e8());
                const a = e[s];
                a.ia(o),
                a.fDe(),
                a.normalize()
            }
        }
    }
    class Dl extends Ol {
        constructor(t, i, e, s) {
            Il.Ge(t),
            Il.Ge(i),
            Il.Ge(e),
            Il.Ge(s),
            super(t, i, [new Pl, new Pl(e,0), new Pl(e,s), new Pl(0,s)]),
            this.Nd = null,
            this.ULe = new Pl,
            this.NLe = new Pl,
            this.BLs = !0
        }
        static dct(t) {
            return Il.U(t, Il.Rect),
            new Dl(t.Kr(),t.Zr(),t.width(),t.height())
        }
        bet(t) {
            this.BLs = !!t
        }
        Wot() {
            return this.BLs
        }
        OL() {
            const t = this.ALe.s8()
              , i = this.ALe.e8()
              , e = this.Nd.s8()
              , s = this.Nd.e8()
              , n = new Il.vet.met(t,i,e,s);
            return n.ULe = new Pl(this.ULe.s8(),this.ULe.e8()),
            n.NLe = new Pl(this.NLe.s8(),this.NLe.e8()),
            n.Set(t, i, e, s),
            n
        }
        Set(t, i, e, s) {
            this.ALe.set(t, i),
            this.Cps[0].set(0, 0),
            this.Cps[1].set(e, 0),
            this.Cps[2].set(e, s),
            this.Cps[3].set(0, s),
            this.Nd = this.Cps[2],
            this.uu()
        }
        ilt(t) {
            this.ALe.set(t.ALe.s8(), t.ALe.e8()),
            this.Cps[0].set(0, 0),
            this.Cps[1].set(t.Nd.s8(), 0),
            this.Cps[2].set(t.Nd.s8(), t.Nd.e8()),
            this.Cps[3].set(0, t.Nd.e8()),
            this.Nd = this.Cps[2],
            this.uu()
        }
        jp() {
            return this.Nd
        }
        jLe() {
            return this.ULe
        }
        gt() {
            super.gt(),
            this.ULe.set(this.Nd.s8(), this.Nd.e8())
        }
        Eht() {
            super.Eht(),
            this.ULe.set(0, 0)
        }
        Zht() {
            super.Zht(),
            this.NLe.set(this.Nd.s8(), this.Nd.e8())
        }
        s7() {
            super.s7(),
            this.Cps[1].set(this.NLe.s8(), 0),
            this.Cps[2].set(this.NLe.s8(), this.NLe.e8()),
            this.Cps[3].set(0, this.NLe.e8()),
            this.NLe.set(0, 0),
            this.uu()
        }
        Hnt(t, i) {
            Il.Ge(t),
            Il.Ge(i),
            this.Cps[1].set(this.ULe.s8() + t, 0),
            this.Cps[2].set(this.ULe.s8() + t, this.ULe.e8() + i),
            this.Cps[3].set(0, this.ULe.e8() + i),
            this.uu()
        }
        TT(t, i) {
            Il.Ge(t),
            Il.Ge(i),
            this.Cps[1].offset(t, 0),
            this.Cps[2].offset(t, i),
            this.Cps[3].offset(0, i),
            this.uu()
        }
    }
    class Fl {
        constructor() {
            this.m3s = null,
            this.$Le = null,
            this.zLe = NaN,
            this.VLe = new Pl,
            this.WLe = new Pl,
            this.tC()
        }
        he() {
            this.m3s = null,
            this.$Le = null,
            this.VLe = null,
            this.WLe = null
        }
        PLe(t) {
            this.m3s = t
        }
        GLe(t) {
            this.$Le = t
        }
        ELe() {
            return this.zLe
        }
        CLe(t) {
            this.zLe = t
        }
        _Le() {
            return this.VLe
        }
        pct() {
            return this.WLe
        }
        tC() {
            this.m3s = null,
            this.$Le = null,
            this.VLe.set(0, 0),
            this.WLe.set(0, 0),
            this.zLe = Number.MAX_VALUE
        }
    }
    Il.vet = {},
    Il.vet.xct = Rl,
    Il.vet.met = Dl,
    Il.vet.Response = Fl,
    Il.vet.Nct = Gl
}
{
    const Ll = 2
      , Bl = "keyvaluepairs"
      , Ul = new Map
      , Nl = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll
      , jl = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
    function $l(t) {
        return new Promise( (i, e) => {
            t.onsuccess = () => i(t.result),
            t.onerror = () => e(t.error)
        }
        )
    }
    function zl(t) {
        return new Promise( (i, e) => {
            t.oncomplete = () => i(),
            t.onerror = () => e(t.error),
            t.onabort = () => e(t.error)
        }
        )
    }
    function Vl(t, i) {
        return Hl(t, i)
    }
    function Wl(t, i) {
        return Hl(t, i, !0)
    }
    async function Hl(t, i, e=!1, s=!0) {
        const n = await Kl(t);
        try {
            return i(n.transaction([Bl], e ? "readwrite" : "readonly"))
        } catch (n) {
            if (s && "InvalidStateError" === n.name)
                return Ul.delete(t),
                Hl(t, i, e, !1);
            throw n
        }
    }
    function Kl(t) {
        Xl(t);
        let i = Ul.get(t);
        return i instanceof Promise || (i = ql(t),
        Ul.set(t, i),
        i.catch(i => Ul.delete(t))),
        i
    }
    async function ql(t) {
        Xl(t);
        const i = indexedDB.open(t, Ll);
        return i.addEventListener("upgradeneeded", i => {
            try {
                i.target.result.createObjectStore(Bl)
            } catch (i) {
                console.error(`Failed to create objectstore for database ${t}`, i)
            }
        }
        ),
        $l(i)
    }
    function Xl(t) {
        if ("string" != typeof t)
            throw new TypeError("expected string")
    }
    function Yl(t, i) {
        const e = t.objectStore(Bl).openCursor();
        return new Promise(t => {
            const s = [];
            e.onsuccess = e => {
                const n = e.target.result;
                if (n) {
                    switch (i) {
                    case "entries":
                        s.push([n.key, n.value]);
                        break;
                    case "keys":
                        s.push(n.key);
                        break;
                    case "values":
                        s.push(n.value)
                    }
                    n.continue()
                } else
                    t(s)
            }
        }
        )
    }
    class Jl {
        constructor(t) {
            Xl(t),
            this.name = t
        }
        async ready() {
            await Kl(this.name)
        }
        set(t, i) {
            return Xl(t),
            Wl(this.name, async e => {
                const s = $l(e.objectStore(Bl).put(i, t))
                  , n = zl(e);
                await Promise.all([n, s])
            }
            )
        }
        get(t) {
            return Xl(t),
            Vl(this.name, async i => {
                const e = $l(i.objectStore(Bl).get(t))
                  , s = zl(i)
                  , [n,r] = await Promise.all([s, e]);
                return r
            }
            )
        }
        delete(t) {
            return Xl(t),
            Wl(this.name, async i => {
                const e = $l(i.objectStore(Bl).delete(t))
                  , s = zl(i);
                await Promise.all([s, e])
            }
            )
        }
        clear() {
            return Wl(this.name, async t => {
                const i = $l(t.objectStore(Bl).clear())
                  , e = zl(t);
                await Promise.all([e, i])
            }
            )
        }
        keys() {
            return Vl(this.name, async t => {
                let i;
                if (jl) {
                    i = $l(t.objectStore(Bl).getAllKeys())
                } else
                    i = Yl(t, "keys");
                const e = zl(t)
                  , [s,n] = await Promise.all([e, i]);
                return n
            }
            )
        }
        values() {
            return Vl(this.name, async t => {
                let i;
                if (Nl) {
                    i = $l(t.objectStore(Bl).getAll())
                } else
                    i = Yl(t, "values");
                const e = zl(t)
                  , [s,n] = await Promise.all([e, i]);
                return n
            }
            )
        }
        entries() {
            return Vl(this.name, async t => {
                const i = Yl(t, "entries")
                  , e = zl(t)
                  , [s,n] = await Promise.all([e, i]);
                return n
            }
            )
        }
    }
    self.G1t = Jl
}
{
    const Zl = self.G1t
      , Ql = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i];
    new WeakMap;
    function tu(t) {
        throw new Error(`"${t}" is not implemented`)
    }
    function iu(t) {
        if ("function" == typeof t)
            throw new Error("localforage callback API is not implemented; please use the promise API instead")
    }
    function eu(t) {
        return "object" == typeof t ? new Promise(i => {
            const {port1: e, port2: s} = new MessageChannel;
            s.onmessage = t => i(t.data),
            e.postMessage(t)
        }
        ) : Promise.resolve(t)
    }
    class su {
        constructor(t) {
            this.Ie = t,
            this.HLe = !this.Ie,
            this.HLe || "undefined" != typeof indexedDB || (this.HLe = !0,
            (() => {})("Unable to use local storage because IndexedDB API is not available")),
            this.KLe = new Map
        }
        qLe(t) {
            if (!this.HLe)
                for (const i of Ql)
                    if (t && i.test(t.message)) {
                        console.error("Unable to use local storage, reverting to in-memory store: ", t, t.message),
                        this.HLe = !0;
                        break
                    }
        }
        async XLe(t) {
            const i = this.KLe.get(t)
              , e = await eu(i);
            return void 0 === e ? null : e
        }
        async YLe(t, i) {
            i = await eu(i),
            this.KLe.set(t, i)
        }
        JLe(t) {
            this.KLe.delete(t)
        }
        ZLe() {
            this.KLe.clear()
        }
        QLe() {
            return Array.from(this.KLe.keys())
        }
        tBe() {
            return this.HLe
        }
        iBe() {
            return this.KLe
        }
        eBe(t) {
            this.KLe = t
        }
        async getItem(t, i) {
            if (iu(i),
            this.HLe)
                return await this.XLe(t);
            let e;
            try {
                e = await this.Ie.get(t)
            } catch (i) {
                return this.qLe(i),
                this.HLe ? await this.XLe(t) : (console.error(`Error reading '${t}' from storage, returning null: `, i),
                null)
            }
            return void 0 === e ? null : e
        }
        async setItem(t, i, e) {
            if (iu(e),
            void 0 === i && (i = null),
            this.HLe)
                await this.YLe(t, i);
            else
                try {
                    await this.Ie.set(t, i)
                } catch (e) {
                    if (this.qLe(e),
                    !this.HLe)
                        throw e;
                    await this.YLe(t, i)
                }
        }
        async removeItem(t, i) {
            if (iu(i),
            this.HLe)
                this.JLe(t);
            else
                try {
                    await this.Ie.delete(t)
                } catch (i) {
                    this.qLe(i),
                    this.HLe ? this.JLe(t) : console.error(`Error removing '${t}' from storage: `, i)
                }
        }
        async clear(t) {
            if (iu(t),
            this.HLe)
                this.ZLe();
            else
                try {
                    await this.Ie.clear()
                } catch (t) {
                    this.qLe(t),
                    this.HLe ? this.ZLe() : console.error("Error clearing storage: ", t)
                }
        }
        async keys(t) {
            if (iu(t),
            this.HLe)
                return this.QLe();
            let i = [];
            try {
                i = await this.Ie.keys()
            } catch (t) {
                if (this.qLe(t),
                this.HLe)
                    return this.QLe();
                console.error("Error getting storage keys: ", t)
            }
            return i
        }
        ready(t) {
            return iu(t),
            this.HLe ? Promise.resolve(!0) : this.Ie.ready()
        }
        sBe(t) {
            if (t.nBe)
                return new su(null);
            {
                const i = t.name;
                if ("string" != typeof i)
                    throw new TypeError("invalid store name");
                const e = new Zl(i);
                return new su(e)
            }
        }
        length(t) {
            tu("localforage.length()")
        }
        key(t, i) {
            tu("localforage.key()")
        }
        iterate(t, i) {
            tu("localforage.iterate()")
        }
        rBe(t) {
            tu("localforage.setDriver()")
        }
        config(t) {
            tu("localforage.config()")
        }
        hBe(t) {
            tu("localforage.defineDriver()")
        }
        oBe() {
            tu("localforage.driver()")
        }
        supports(t) {
            tu("localforage.supports()")
        }
        dropInstance() {
            tu("localforage.dropInstance()")
        }
    }
    self.localforage = new su(new Zl("localforage"))
}
{
    const nu = self.t;
    let ru = !1
      , hu = []
      , ou = null;
    const au = 800
      , lu = 200
      , uu = "26pt"
      , cu = "unknownFontName948958658";
    let du = null
      , fu = null
      , pu = null;
    function mu(t, i) {
        const e = t.data
          , s = i.data;
        if (e.length !== s.length)
            return !1;
        const n = new Uint8Array(e.buffer)
          , r = new Uint8Array(s.buffer);
        let h = 0;
        for (let t = 0, i = n.length; t < i; ++t)
            if (n[t] !== r[t] && (h += Math.abs(n[t] - r[t]),
            h > 100))
                return !1;
        return !0
    }
    function wu(t) {
        return fu.clearRect(0, 0, au, lu),
        fu.font = uu + " " + t,
        fu.fillText("ABCDEFGHIJKLMNOPQRSTUVWXYZ", 5, 5),
        fu.fillText("abcdefghijklmnopqrstuvwxyz", 5, 55),
        fu.fillText("0123456789", 5, 105),
        fu.getImageData(0, 0, au, lu)
    }
    async function gu() {
        const t = nu.lBe.aBe
          , i = t.fontCandidateList
          , e = new Set(t.fontAlwaysShowList)
          , s = [];
        du = document.createElement("canvas"),
        du.width = au,
        du.height = lu,
        fu = du.getContext("2d"),
        fu.textBaseline = "top",
        fu.fillStyle = "black",
        pu = wu(cu);
        for (const t of i)
            e.has(t) ? hu.push(t) : s.push(nu._Ct( () => {
                mu(pu, wu('"' + t + '"')) || hu.push(t)
            }
            ));
        return await Promise.all(s),
        ru = !0,
        du.width = 32,
        du.height = 32,
        du = null,
        fu = null,
        pu = null,
        ou = null,
        hu.sort(),
        hu
    }
    async function yu() {
        const t = new Set
          , i = await self.queryLocalFonts();
        for (const e of i)
            t.add(e.family);
        return hu = [...t],
        hu.sort(),
        ru = !0,
        ou = null,
        hu
    }
    async function bu() {
        try {
            if (nu.zk.eke)
                try {
                    return await yu()
                } catch (t) {
                    (() => {})("Failed to get local font list: ", t)
                }
            return await gu()
        } catch (t) {
            return console.error("Failed to get local font list: ", t),
            nu.PC(nu.lBe.aBe.fontAlwaysShowList)
        }
    }
    nu.lBe = class {
        constructor() {
            throw new Error("static class")
        }
        static uBe() {
            return ru ? Promise.resolve(hu) : ou || (ou = bu(),
            ou)
        }
    }
}
self.t.lBe.aBe = {
    fontCandidateList: ["Algerian", "Andale Mono", "Arial", "Avant Garde", "Baskerville", "Big Caslon", "Bitstream Vera", "Bodoni MT", "Book Antiqua", "Bookman", "Bookman Old Style", "Bradley Hand ITC TT", "Broadway", "Brush Script MT", "Calibri", "Calisto MT", "Candara", "Cambria", "Cardo", "Carrois Gothic SC", "Caslon Roman", "Century Gothic", "Century Schoolbook", "Comic Sans MS", "Consolas", "Copperplate", "Copperplate Gothic", "Courier New", "Cutive Mono", "Dancing Script", "Diavlo", "Didot", "Droid", "Droid Sans", "Droid Sans Mono", "Droid Serif", "Franklin Gothic", "Futura", "Garamond", "Geneva", "Gentium", "Georgia", "Ghostscript", "Gill Sans", "Goudy", "Goudy Old Style", "Haettenschweiler", "Helvetica", "Hoefler Text", "Impact", "ITC Stone Serif", "Junicode", "Latin Modern", "Lucida Bright", "Lucida Calligraphy", "Lucida Console", "Lucida Grande", "Lucida Sans", "Lucida Sans Typewriter", "Lucida Sans Unicode", "Mistral", "Moire", "Monaco", "MS Mincho", "MS Sans Serif", "New Athena Unicode", "New York", "Noto", "Noto Sans", "Noto Serif", "Old Standard TT", "Onyx", "Optima", "Oxygen", "Palatino", "Palatino Linotype", "Papyrus", "Perpetua", "Perpetua Titling MT", "Playbill", "Roboto", "Rockwell", "San Francisco", "Segoe UI", "Snap ITC", "Source Sans Pro", "Source Code Pro", "Stencil", "Symbol", "Symbola", "Tahoma", "Times", "Times New Roman", "Trebuchet MS", "Tw Cen MT", "UniFraktur", "Verdana", "Webdings", "Wide Latin", "Wingdings"],
    fontAlwaysShowList: ["Arial", "Times New Roman"]
};
{
    const vu = self.t;
    vu.cBe = "\ufeff";
    const Su = new Set("0123456789");
    vu.qcs = function(t) {
        return vu.zt(t),
        Su.has(t)
    }
    ;
    const xu = new Set(" \t\n\r\u2028\u2029");
    vu.Ues = function(t) {
        return vu.zt(t),
        xu.has(t)
    }
    ,
    vu.sPs = function(t) {
        return [...t].filter(t => !vu.Ues(t)).join("")
    }
    ,
    vu.dBe = function(t) {
        for (const i of t)
            if (!vu.Ues(i))
                return !1;
        return !0
    }
    ,
    vu.LC = function(t) {
        for (const i of t)
            if (!vu.Ues(i))
                return !1;
        return !0
    }
    ,
    vu.fBe = function(t) {
        return vu.zt(t),
        1 === t.length && t.charCodeAt(0) < 32
    }
    ,
    vu.pBe = function(t) {
        return [...t].filter(t => !vu.fBe(t)).join("")
    }
    ;
    let Mu = null;
    try {
        Mu = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])","u")
    } catch (Du) {
        (() => {})("Unable to detect CJK punctuation: ", Du)
    }
    vu.mBe = function(t) {
        return !vu.Ues(t) && Mu && Mu.test(t)
    }
    ;
    const Eu = new Set("0123456789.+-e");
    vu.Soi = function(t) {
        if (vu.zt(t),
        !(t = t.trim()).length)
            return !1;
        let i = t.charAt(0);
        if ("-" !== i && !Su.has(i))
            return !1;
        for (let i of t)
            if (!Eu.has(i))
                return !1;
        return !0
    }
    ,
    vu.oQ = function(t) {
        vu.zt(t);
        let i = t.length;
        for (; i > 0; ) {
            let e = t.charAt(i - 1);
            if (!vu.qcs(e))
                break;
            --i
        }
        return t.substr(0, i)
    }
    ,
    vu.yR = function(t) {
        vu.zt(t);
        let i = vu.oQ(t)
          , e = t.substr(i.length);
        return e = e ? (parseInt(e, 10) + 1).toString() : "2",
        i + e
    }
    ;
    const Cu = new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
    function _u(t) {
        return Cu.get(t)
    }
    const Tu = /[&<>"']/g;
    vu.zPe = function(t) {
        return vu.u7t(t),
        t.replace(Tu, _u)
    }
    ,
    vu.oPs = function(t) {
        let i = vu.L5s(t, "\\", "\\\\");
        return i = vu.L5s(i, '"', '\\"'),
        i = vu.L5s(i, "\t", "\\t"),
        i = vu.L5s(i, "\r", ""),
        vu.L5s(i, "\n", "\\n")
    }
    ,
    vu.wBe = function(t) {
        let i = vu.L5s(t, "&", "&amp;");
        return i = vu.L5s(i, "<", "&lt;"),
        i = vu.L5s(i, ">", "&gt;"),
        vu.L5s(i, '"', "&quot;")
    }
    ;
    const Iu = /[-[\]{}()*+?.,\\^$|#\s]/g;
    vu.VRe = function(t) {
        return vu.u7t(t),
        t.replace(Iu, "\\$&")
    }
    ,
    vu.YAs = function(t, i) {
        let e = 0;
        for (const s of t)
            s === i && ++e;
        return e
    }
    ,
    vu.wPs = function(t, i) {
        let e = 0
          , s = 0;
        for (; e < i; ) {
            if (e = t.indexOf("\n", e),
            -1 === e)
                return s;
            s++,
            e++
        }
        return s
    }
    ,
    vu.Ojs = function(t, i, e=!1) {
        if (vu.zt(t),
        vu.zt(i),
        !i)
            return [];
        e || (t = t.toLowerCase(),
        i = i.toLowerCase());
        const s = i.length;
        let n = 0
          , r = 0
          , h = [];
        for (; (r = t.indexOf(i, n)) > -1; )
            h.push(r),
            n = r + s;
        return h
    }
    ,
    vu.L5s = function(t, i, e) {
        return vu.zt(t),
        vu.zt(i),
        vu.zt(e),
        t.replaceAll(i, () => e)
    }
    ,
    vu.Mi = function(t, i, e) {
        return vu.zt(t),
        vu.zt(i),
        vu.zt(e),
        t.replace(new RegExp(vu.VRe(i),"gi"), () => e)
    }
    ,
    vu.odt = function(t, i) {
        vu.zlt(t),
        vu.u7t(i),
        "string" == typeof i ? t.textContent = i : i.gBe() ? t.textContent = i.toString() : (t.innerHTML = i.ibt(),
        i instanceof vu.MC && i.yBe(t))
    }
    ,
    vu.bBe = function(t, i) {
        return t instanceof vu.gke || t instanceof vu.MC ? t.equals(i) : i instanceof vu.gke || i instanceof vu.MC ? i.equals(t) : t === i
    }
    ,
    vu.vBe = function(t, ...i) {
        vu.zt(t);
        let e = t;
        for (let s = 0, n = i.length; s < n; ++s) {
            const n = `{${s}}`;
            if (!t.includes(n))
                throw new Error(`missing placeholder '${n}' in string substitution`);
            e = e.replace(n, i[s].toString())
        }
        return e
    }
    ,
    vu.SBe = function(t, ...i) {
        vu.zt(t);
        let e = t
          , s = -1
          , n = -1;
        for (let r = 0, h = i.length; r < h; ++r) {
            const h = `{${r}}`;
            t.includes(h) ? (n = r,
            e = e.replace(h, i[r].toString())) : -1 === s && (s = r)
        }
        if (s >= 0 && n >= 0 && s < n)
            throw new Error(`missing placeholder '${s}' in string substitution`);
        return e
    }
    ,
    vu.gxe = function(t, i) {
        vu.zt(t);
        let e = t;
        for (let[t,s] of Object.entries(i))
            vu.zt(t),
            e = e.replaceAll(t, s.toString());
        return e
    }
    ,
    vu.vhi = function(t, i) {
        return t > i ? 1 : t < i ? -1 : 0
    }
    ,
    vu.cj = function(t, i) {
        let e = t.toLowerCase()
          , s = i.toLowerCase();
        return e > s ? 1 : e < s ? -1 : 0
    }
    ;
    const Pu = new self.Intl.Segmenter;
    vu.pv = function(t) {
        if (1 === t.length)
            return [t];
        const i = [];
        for (const e of Pu.segment(t))
            i.push(e.segment);
        return i
    }
    ,
    vu.xBe = function*(t) {
        for (const i of Pu.segment(t))
            yield i.segment
    }
    ,
    vu.MBe = function(t) {
        let i = 0;
        for (const e of Pu.segment(t))
            ++i;
        return i
    }
    ;
    const Gu = 1024
      , Au = 1024 * Gu
      , Ru = 1024 * Au
      , ku = 1024 * Ru;
    vu.Iye = function(t, i) {
        let e = "common." + (i ? "dataRates" : "dataSizes") + ".";
        const s = self.tP;
        if (t < Gu)
            return s(e + "bytes", t);
        if (t < Au) {
            let i = t / Gu;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "kilobytes", i)
        }
        if (t < Ru) {
            let i = t / Au;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "megabytes", i)
        }
        if (t < ku) {
            let i = t / Ru;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "gigabytes", i)
        }
        {
            let i = t / ku;
            return i = i < 10 ? Math.round(10 * i) / 10 : Math.round(i),
            s(e + "terabytes", i)
        }
    }
    ;
    const Ou = {
        EBe: !1,
        CBe: !0,
        _Be: !0,
        TBe: !0,
        IBe: !0
    };
    vu.PBe = function(t, i) {
        i = Object.assign({}, Ou, i),
        vu.p.u("common.time");
        const e = []
          , s = self.lang
          , n = self.iG;
        if (i.CBe) {
            const i = Math.floor(t / 86400);
            i > 0 && (t -= 24 * i * 3600,
            e.push(n(".days", null, i)))
        }
        if (i._Be) {
            const i = Math.floor(t / 3600);
            (i > 0 || e.length) && (t -= 3600 * i,
            e.push(n(".hours", null, i)))
        }
        if (i.TBe) {
            const s = Math.floor(t / 60);
            (s > 0 || e.length || !i.IBe) && (t -= 60 * s,
            e.push(n(".minutes", null, s)))
        }
        if (i.IBe) {
            const i = Math.floor(t % 60);
            e.push(n(".seconds", null, i))
        }
        const r = (i.EBe ? s(".approx-prefix") : "") + e.join(s(".separator"));
        return vu.p.j(),
        r
    }
    ,
    vu.Ii = function(t, i) {
        let e = t < 0 ? "-" : ""
          , s = (t = Math.abs(t)).toString()
          , n = i - s.length;
        for (let t = 0; t < n; ++t)
            e += "0";
        return e + s
    }
    ,
    vu.iPs = function(t) {
        return t.toLowerCase().replace(/\b\w/g, t => t.toUpperCase())
    }
    ,
    vu.GBe = function(t, i) {
        let e = t.split(".").map(t => t.trim())
          , s = i.split(".").map(t => t.trim());
        vu.pI(e, 4, "0"),
        vu.pI(s, 4, "0"),
        e = e.map(t => parseInt(t, 10)),
        s = s.map(t => parseInt(t, 10));
        for (let t = 0; t < 4; ++t) {
            const i = e[t] - s[t];
            if (0 !== i)
                return i < 0 ? -1 : 1
        }
        return 0
    }
    ,
    vu.lTi = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
            const i = Math.floor(16 * Math.random());
            return ("x" === t ? i : 3 & i | 8).toString(16)
        }
        )
    }
    ,
    vu.oni = function(t, i) {
        if (t.length !== i.length)
            throw new Error("strings must be same length");
        let e = 0;
        for (let s = 0, n = t.length; s < n; ++s)
            t.charAt(s) !== i.charAt(s) && ++e;
        return e
    }
    ,
    vu.ABe = function(t, i) {
        if (0 === t.length)
            return i.length;
        if (0 === i.length)
            return t.length;
        let e, s, n, r, h, o;
        for (t.length > i.length && (e = t,
        t = i,
        i = e),
        o = Array(t.length + 1),
        s = 0; s <= t.length; s++)
            o[s] = s;
        for (s = 1; s <= i.length; s++) {
            for (r = s,
            n = 1; n <= t.length; n++)
                h = i[s - 1] === t[n - 1] ? o[n - 1] : Math.min(o[n - 1] + 1, Math.min(r + 1, o[n] + 1)),
                o[n - 1] = r,
                r = h;
            o[t.length] = r
        }
        return o[t.length]
    }
    ,
    vu.RBe = function(t) {
        return (new TextEncoder).encode(t).length
    }
}
{
    const Fu = self.t;
    Fu.gke = class {
        constructor(t) {
            Fu.zt(t),
            this.l4s = t,
            this.kBe = !this.l4s.includes("<") && !this.l4s.includes("&")
        }
        toString() {
            return this.l4s
        }
        valueOf() {
            return this.l4s
        }
        gBe() {
            return this.kBe
        }
        ibt() {
            return this.l4s
        }
        equals(t) {
            return t instanceof Fu.gke ? this.l4s === t.l4s : t instanceof Fu.MC ? this.l4s === t.ibt() : this.l4s === t
        }
    }
}
{
    const Lu = self.t
      , Bu = self.assert
      , Uu = new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]])
      , Nu = new Set(["icon"])
      , ju = /\[(\/?)([a-zA-Z0-9]+)\]/g
      , $u = /\[(\/?)([^\[\n]*?)\]/g;
    let zu = null
      , Vu = null
      , Wu = 0;
    function Hu(t, i, e) {
        const s = Uu.get(e);
        if (!s)
            return "class" === e ? i ? "</span>" : `<span class="bbclass${Wu++}">` : t;
        if ("string" == typeof s) {
            if ("a" === s && 0 === zu.length || "abbr" === s && 0 === Vu.length)
                return t;
            if ("a" !== s || i) {
                if ("abbr" !== s || i)
                    return "<" + i + s + ">";
                {
                    const t = parseInt(e.substring(3), 10) - 1;
                    if (t < 0 || t >= Vu.length)
                        throw new Error("invalid bbcode tip substitution");
                    const i = Vu[t];
                    let s = "";
                    if ("string" == typeof i ? s = i : "function" == typeof i && (s = i()),
                    "string" != typeof s)
                        throw new TypeError("invalid bbcode tip");
                    return `<abbr title="${Lu.L5s(s, '"', "&quot;")}">`
                }
            }
            {
                const t = parseInt(e.substring(1), 10) - 1;
                if (t < 0 || t >= zu.length)
                    throw new Error("invalid bbcode link substitution");
                const i = zu[t];
                if ("string" == typeof i)
                    return `<a href="${zu[t]}">`;
                if ("function" == typeof i)
                    return `<a class="bblink${t}">`;
                throw new TypeError("invalid bbcode link action")
            }
        }
        if (Array.isArray(s)) {
            Bu(2 === s.length, "invalid bbcode entry");
            let t = s[0]
              , e = s[1];
            return i ? "</" + t + ">" : `<${t} class="${e}">`
        }
        Bu(!1, "invalid bbcode entry")
    }
    const Ku = /\n/g;
    Lu.MC = class {
        constructor(t, i) {
            if (Lu.zt(t),
            Lu.Wat(i),
            this.OBe = i && i.IC ? t : Lu.zPe(t),
            this.DBe = "",
            this.FBe = !1,
            this.LBe = [],
            this.BBe = [],
            i) {
                if (this.FBe = !!i.O0,
                i.links) {
                    if (Lu._D(i.links),
                    i.links.length > 9)
                        throw new Error("too many links");
                    this.LBe = i.links
                }
                if (i.UBe) {
                    if (Lu._D(i.UBe),
                    i.UBe.length > 9)
                        throw new Error("too many tips");
                    this.BBe = i.UBe
                }
            }
            this.NBe = this.OBe.includes("["),
            this.jBe = this.FBe && this.OBe.includes("\n"),
            this.kBe = !this.NBe && !this.jBe && !this.OBe.includes("&"),
            this.$Be = !1,
            this.zBe = []
        }
        toString() {
            return this.OBe
        }
        valueOf() {
            return this.OBe
        }
        gBe() {
            return this.kBe
        }
        MKt() {
            return this.NBe ? this.OBe.replace(ju, "") : this.OBe
        }
        ibt() {
            if (this.kBe)
                return this.OBe;
            if (!this.DBe && this.OBe) {
                let t = this.OBe;
                this.NBe && (Wu = 0,
                zu = this.LBe,
                Vu = this.BBe,
                t = t.replace(ju, Hu),
                zu = null,
                Vu = null),
                this.jBe && (t = t.replace(Ku, "<br>")),
                this.DBe = t
            }
            return this.DBe
        }
        yBe(t) {
            if (this.LBe.length)
                for (let i = 0, e = this.LBe.length; i < e; ++i) {
                    const e = this.LBe[i];
                    if ("function" != typeof e)
                        continue;
                    const s = t.querySelector(".bblink" + i);
                    if (!s)
                        throw new Error("unable to attach BBString link handler");
                    s.onclick = e
                }
        }
        equals(t) {
            return t instanceof Lu.gke ? this.ibt() === t.ibt() : t instanceof Lu.MC ? this.OBe === t.OBe : this.OBe === t
        }
        TC() {
            if (this.$Be)
                return this.zBe;
            const t = []
              , i = this.OBe
              , e = [];
            $u.lastIndex = 0;
            let s = 0
              , n = null;
            for (; null !== (n = $u.exec(i)); ) {
                const r = n.index;
                if (r > 0 && "\\" === i.charAt(r - 1))
                    continue;
                const h = n[0]
                  , o = n[1]
                  , a = n[2]
                  , l = i.substring(s, r);
                if (s = r + h.length,
                l && t.push({
                    text: l,
                    VBe: e.slice(0)
                }),
                a)
                    if (o) {
                        const t = a.toLowerCase();
                        for (let i = e.length - 1; i >= 0; --i)
                            if (e[i].tag === t) {
                                e.splice(i, 1);
                                break
                            }
                    } else {
                        let i = a
                          , s = null;
                        const n = a.indexOf("=");
                        if (-1 !== n ? (i = a.substring(0, n).toLowerCase(),
                        s = a.substring(n + 1)) : i = i.toLowerCase(),
                        Nu.has(i)) {
                            if ("icon" !== i)
                                throw new Error(`unknown self-closing tag ${i}`);
                            t.push({
                                icon: s,
                                VBe: e.slice(0)
                            })
                        } else
                            e.push({
                                tag: i,
                                nC: s
                            })
                    }
            }
            s < i.length && t.push({
                text: i.substring(s),
                VBe: e.slice(0)
            });
            for (const i of t)
                i.text && (i.text = this.WBe(i.text));
            return this.zBe = t.map(t => t.icon ? Lu.v(Lu.HBe, {
                icon: t.icon,
                VBe: t.VBe
            }) : Lu.v(Lu.KBe, {
                qBe: Lu.pv(t.text),
                VBe: t.VBe
            })),
            this.$Be = !0,
            this.zBe
        }
        WBe(t) {
            return t = Lu.L5s(t, "\\[", "["),
            Lu.L5s(t, "\\\\", "\\")
        }
        static rqs(t) {
            return Lu.v(Lu.MC, t, {
                IC: !0
            }).MKt()
        }
        static XBe(t) {
            return t.replace($u, "")
        }
    }
}
self.t.Gvt = Object.freeze({
    YBe: "",
    Avt: "",
    JBe: "",
    ZBe: "",
    QBe: "",
    tUe: "",
    iUe: "",
    eUe: "",
    sUe: "",
    M4s: "",
    nUe: "",
    rUe: "",
    hUe: "",
    PI: "",
    oUe: "",
    aUe: "",
    lUe: "",
    uUe: "",
    cUe: "",
    dUe: "",
    fUe: "",
    pUe: "",
    mUe: "",
    wUe: "",
    gUe: "",
    yUe: "",
    bUe: "",
    vUe: "",
    SUe: "",
    xUe: "",
    MUe: "",
    EUe: "",
    CUe: "",
    _Ue: "",
    TUe: "",
    Fcs: [".", ""],
    Tcs: [",", ""],
    Ocs: ['"', "", ""],
    Mcs: ["(", ""],
    jcs: [")", ""],
    Rcs: ["?", ""],
    Ncs: [":", ""]
});
{
    const qu = self.t;
    function Xu(t) {
        return "" !== t && "" !== t && qu.Ues(t)
    }
    const Yu = new Set("");
    function Ju(t) {
        return Yu.has(t)
    }
    function Zu(t) {
        return qu.mBe(t) && !Ju(t)
    }
    function Qu(t) {
        for (; t.length > 0 && Xu(t.at(-1)); )
            t.pop()
    }
    function tc(t) {
        return "\n" === t || "\r\n" === t
    }
    class ic {
        constructor() {
            this.wC = [],
            this.width = 0,
            this.height = 0,
            this.fontBoundingBoxAscent = 0,
            this.fontBoundingBoxDescent = 0,
            this.IUe = 0,
            this.PUe = !1
        }
        static GUe(t, i, e, s, n, r) {
            const h = new ic;
            return h.wC.push(t),
            h.width = i,
            h.height = e,
            h.fontBoundingBoxAscent = s,
            h.fontBoundingBoxDescent = n,
            h.IUe = r,
            h
        }
        u6s(t) {
            this.wC = t.wC.map(t => t.AUe()),
            this.width = t.width,
            this.height = t.height,
            this.fontBoundingBoxAscent = t.fontBoundingBoxAscent,
            this.fontBoundingBoxDescent = t.fontBoundingBoxDescent,
            this.IUe = t.IUe,
            this.PUe = t.PUe
        }
        Bg() {
            this.wC = [],
            this.width = 0,
            this.height = 0,
            this.fontBoundingBoxAscent = 0,
            this.fontBoundingBoxDescent = 0,
            this.IUe = 0,
            this.PUe = !1
        }
        RUe(t, i) {
            i || (this.width = t.width),
            this.height = t.height || 0,
            this.fontBoundingBoxAscent = t.fontBoundingBoxAscent || 0,
            this.fontBoundingBoxDescent = t.fontBoundingBoxDescent || 0,
            this.IUe = t.IUe || 0,
            this.PUe = !0
        }
        kUe(t) {
            const i = this.wC.length ? this.wC.at(-1) : null;
            let e = 0;
            i && i.OUe() && t[0].OUe() && t[0].DUe() === i.DUe() && (i.FUe(t[0].iC()),
            e = 1);
            for (let i = t.length; e < i; ++e) {
                const i = t[e];
                this.wC.push(i.AUe())
            }
            this.PUe = !1
        }
    }
    qu.AS = class {
        constructor() {
            this.LUe = [],
            this.BUe = null,
            this.UUe = new ic,
            this.NUe = new ic,
            this.jUe = !1
        }
        mC() {
            return this.LUe
        }
        JC() {
            return this.LUe.length
        }
        lM(t) {
            qu.Mw(t, qu.$Ue),
            this.BUe = t
        }
        AS(t, i, e, s, n) {
            if ("string" == typeof t && (t = [qu.v(qu.KBe, {
                qBe: qu.pv(t)
            })]),
            qu._D(t),
            qu.qd(i),
            qu.Ge(e),
            qu.zt(s),
            qu.sc(this.LUe),
            !t.length || 1 === t.length && t[0].OUe() && t[0].lN() || e < 2)
                return;
            if (1 === t.length) {
                const s = t[0];
                if (s.OUe() && s.zUe() <= 100 && !s.VUe()) {
                    let {width: t, height: r, fontBoundingBoxAscent: h, fontBoundingBoxDescent: o, IUe: a} = i(s);
                    if (t += n,
                    s.Qx(t),
                    s.Kx(r),
                    s.WUe(h || 0),
                    s.HUe(o || 0),
                    s.KUe(a || 0),
                    t <= e)
                        return void this.qUe(ic.GUe(s, t, r, h, o, a))
                }
            }
            let r, h = 4;
            "word" === s ? r = this.XUe(t) : "cjk" === s ? (r = this.YUe(t),
            h = 8) : (r = this.JUe(t),
            h = 8),
            this.ZUe(r, i, e, h, n)
        }
        XUe(t) {
            const i = [];
            let e = []
              , s = !1;
            for (const n of t) {
                const t = n.DUe();
                if (n.eC())
                    e.length > 0 && i.push(e),
                    i.push([n]),
                    e = [];
                else
                    for (const r of n.iC())
                        if (tc(r))
                            e.length > 0 && i.push(e),
                            i.push([qu.v(qu.KBe, {
                                qBe: ["\n"],
                                VBe: t
                            })]),
                            e = [];
                        else if (0 === e.length)
                            e.push(qu.v(qu.KBe, {
                                qBe: [r],
                                VBe: t
                            })),
                            s = Xu(r);
                        else {
                            const n = Xu(r);
                            if (n === s) {
                                const i = e.at(-1);
                                i.DUe() === t ? i.QUe(r) : e.push(qu.v(qu.KBe, {
                                    qBe: [r],
                                    VBe: t
                                }))
                            } else
                                i.push(e),
                                e = [qu.v(qu.KBe, {
                                    qBe: [r],
                                    VBe: t
                                })],
                                s = n
                        }
            }
            return e.length > 0 && i.push(e),
            i
        }
        YUe(t) {
            const i = [];
            let e = []
              , s = !1;
            for (const n of t) {
                const t = n.DUe();
                if (n.eC())
                    e.length > 0 && i.push(e),
                    i.push([n]),
                    e = [];
                else
                    for (const r of n.iC())
                        if (tc(r))
                            e.length > 0 && i.push(e),
                            i.push([qu.v(qu.KBe, {
                                qBe: ["\n"],
                                VBe: t
                            })]),
                            e = [];
                        else if (0 === e.length)
                            e.push(qu.v(qu.KBe, {
                                qBe: [r],
                                VBe: t
                            })),
                            s = Ju(r);
                        else if (s || Zu(r)) {
                            const i = e.at(-1);
                            i.DUe() === t ? i.QUe(r) : e.push(qu.v(qu.KBe, {
                                qBe: [r],
                                VBe: t
                            })),
                            s = Ju(r)
                        } else
                            i.push(e),
                            e = [qu.v(qu.KBe, {
                                qBe: [r],
                                VBe: t
                            })],
                            s = Ju(r)
            }
            return e.length > 0 && i.push(e),
            i
        }
        JUe(t) {
            const i = [];
            for (const e of t)
                if (e.OUe()) {
                    const t = e.iC();
                    qu.bp(i, t.map(t => [qu.v(qu.KBe, {
                        qBe: [t],
                        VBe: e.DUe()
                    })]))
                } else
                    i.push([e]);
            return i
        }
        tNe(t, i) {
            let e = 0
              , s = 0
              , n = 0
              , r = 0
              , h = 0;
            for (const o of t) {
                if (-1 === o.ns()) {
                    const t = i(o);
                    o.Kx(t.height),
                    o.WUe(t.fontBoundingBoxAscent || 0),
                    o.HUe(t.fontBoundingBoxDescent || 0),
                    o.KUe(t.IUe || 0),
                    o.OUe() ? o.Qx(t.width) : o.eC() && o.iNe(this.BUe)
                }
                e += o.ns(),
                s = Math.max(s, o.Kn()),
                n = Math.max(n, o.eNe()),
                r = Math.max(r, o.sNe()),
                h = Math.max(h, o.nNe())
            }
            return {
                width: e,
                height: s,
                fontBoundingBoxAscent: n,
                fontBoundingBoxDescent: r,
                IUe: h
            }
        }
        rNe() {
            this.UUe.Bg(),
            this.NUe.Bg()
        }
        qUe(t) {
            this.LUe.push(new qu.AS.Ra(t)),
            this.rNe()
        }
        hNe(t, i, e) {
            const s = e(qu.v(qu.KBe, {
                qBe: [" "],
                VBe: i
            }));
            t.RUe(s, !0),
            this.qUe(t)
        }
        oNe(t) {
            return 1 === t.length && t[0].OUe() && 1 === t[0].zUe() && tc(t[0].iC()[0])
        }
        aNe(t) {
            return t[0].OUe() && qu.LC(t[0].iC())
        }
        ZUe(t, i, e, s, n) {
            let r = 0;
            for (; r < t.length; )
                r = this.lNe(t, r, i, e, s);
            if (this.NUe.wC.length > 0) {
                if (!this.NUe.PUe) {
                    const t = this.tNe(this.NUe.wC, i);
                    this.NUe.RUe(t)
                }
                this.qUe(this.NUe)
            }
            this.uNe(i, n),
            this.rNe(),
            this.jUe = !1
        }
        lNe(t, i, e, s, n) {
            const r = this.UUe
              , h = this.NUe
              , o = t[i];
            if (this.oNe(o))
                return this.hNe(h, o[0].DUe(), e),
                i + 1;
            const a = this.cNe(t, i, n)
              , l = this.tNe(h.wC, e);
            return h.RUe(l),
            l.width >= s ? this.dNe(t, i, e, s) : (r.u6s(h),
            this.jUe && this.qUe(r),
            a + 1)
        }
        cNe(t, i, e) {
            const s = this.NUe;
            this.jUe = !1;
            let n = i
              , r = 0;
            for (let i = t.length; n < i; ++n) {
                const i = t[n];
                if (this.oNe(i)) {
                    this.jUe = !0;
                    break
                }
                if (s.kUe(i),
                !this.aNe(i) && (++r,
                r === e))
                    break
            }
            return n
        }
        dNe(t, i, e, s) {
            const n = this.UUe
              , r = this.NUe;
            r.u6s(n);
            let h = i;
            for (let i = t.length; h < i; ++h) {
                const o = t[h];
                if (this.oNe(o))
                    return this.qUe(n),
                    h + 1;
                if (r.kUe(o),
                !this.aNe(o) || 0 === n.wC.length) {
                    const o = this.tNe(r.wC, e);
                    if (r.RUe(o),
                    o.width >= s) {
                        let e;
                        return n.wC.length > 0 ? e = n : (e = r,
                        ++h,
                        h < i && this.aNe(t[h]) && ++h),
                        this.qUe(e),
                        h
                    }
                    n.u6s(r)
                }
            }
            return h
        }
        uNe(t, i) {
            for (const e of this.LUe) {
                const s = e.fNe();
                if (!s.length)
                    continue;
                let n = s.at(-1);
                if (n.OUe()) {
                    const r = n.iC()
                      , h = r.slice(0);
                    if (Qu(h),
                    0 === h.length)
                        e.pNe(-n.ns()),
                        s.pop();
                    else if (h.length < r.length) {
                        n.mNe(h);
                        const i = t(n).width
                          , s = n.ns() - i;
                        n.Qx(i),
                        e.pNe(-s)
                    }
                    0 !== i && s.length > 0 && (n = s.at(-1),
                    n.pNe(i),
                    e.pNe(i))
                }
            }
        }
        tC() {
            qu.sc(this.LUe)
        }
        YC() {
            return this.LUe.reduce( (t, i) => Math.max(t, i.ns()), 0)
        }
        wNe() {
            return this.LUe.reduce( (t, i) => t + i.Kn(), 0)
        }
    }
}
self.t.AS.Ra = class {
    constructor(t) {
        this.zBe = t.wC,
        this.ZC = t.width,
        this.tv = t.height,
        this.gNe = t.fontBoundingBoxAscent,
        this.yNe = t.fontBoundingBoxDescent,
        this.bNe = t.IUe,
        this.vNe = 0,
        this.SNe = 0
    }
    wC() {
        return this.zBe.values()
    }
    *xNe() {
        const t = this.zBe;
        for (let i = t.length - 1; i >= 0; --i)
            yield t[i]
    }
    fNe() {
        return this.zBe
    }
    pNe(t) {
        this.ZC += t
    }
    ns() {
        return this.ZC
    }
    Kn() {
        return this.tv
    }
    MNe() {
        return this.gNe
    }
    sNe() {
        return this.yNe
    }
    nNe() {
        return this.bNe
    }
    VC(t) {
        this.vNe = t
    }
    bC() {
        return this.vNe
    }
    kC(t) {
        this.SNe = t
    }
    gC() {
        return this.SNe
    }
}
;
self.t.ENe = class {
    constructor(t) {
        this.CNe = t.VBe || [],
        this.ZC = t.width || -1,
        this.tv = t.height || -1,
        this.gNe = t.fontBoundingBoxAscent || -1,
        this.yNe = t.fontBoundingBoxDescent || -1,
        this.bNe = t.IUe || -1,
        this.vNe = 0,
        this.SNe = 0
    }
    OUe() {
        return !1
    }
    eC() {
        return !1
    }
    DUe() {
        return this.CNe
    }
    sC(t) {
        const i = this.CNe;
        for (let e = i.length - 1; e >= 0; --e) {
            const s = i[e];
            if (s.tag === t)
                return s
        }
        return null
    }
    NC(t) {
        return !!this.sC(t)
    }
    _Ne() {
        const t = new Map;
        for (const i of this.CNe)
            t.set(i.tag, i.nC);
        return t
    }
    pNe(t) {
        this.ZC += t
    }
    Qx(t) {
        this.ZC = t
    }
    ns() {
        return this.ZC
    }
    Kx(t) {
        this.tv = t
    }
    Kn() {
        return this.tv
    }
    WUe(t) {
        this.gNe = t
    }
    eNe() {
        return this.gNe
    }
    HUe(t) {
        this.yNe = t
    }
    sNe() {
        return this.yNe
    }
    KUe(t) {
        this.bNe = t
    }
    nNe() {
        return this.bNe
    }
    VC(t) {
        this.vNe = t
    }
    bC() {
        return this.vNe
    }
    kC(t) {
        this.SNe = t
    }
    gC() {
        return this.SNe
    }
}
;
{
    const ec = self.t;
    ec.KBe = class extends ec.ENe {
        constructor(t) {
            super(t),
            this.TNe = t.qBe
        }
        OUe() {
            return !0
        }
        FUe(t) {
            ec.bp(this.TNe, t),
            this.ZC = -1,
            this.tv = -1,
            this.gNe = -1,
            this.yNe = -1,
            this.bNe = -1
        }
        QUe(t) {
            this.TNe.push(t)
        }
        AUe() {
            return ec.v(ec.KBe, {
                qBe: this.TNe.slice(0),
                VBe: this.CNe,
                width: this.ZC,
                height: this.tv,
                fontBoundingBoxAscent: this.gNe,
                fontBoundingBoxDescent: this.yNe,
                IUe: this.bNe
            })
        }
        iC() {
            return this.TNe
        }
        mNe(t) {
            this.TNe = t
        }
        zUe() {
            return this.TNe.length
        }
        lN() {
            return 0 === this.TNe.length
        }
        VUe() {
            return this.TNe.includes("\n")
        }
    }
}
{
    const sc = self.t;
    sc.HBe = class extends sc.ENe {
        constructor(t) {
            super(t),
            this.X1t = t.icon
        }
        eC() {
            return !0
        }
        INe() {
            return this.X1t
        }
        AUe() {
            return sc.v(sc.HBe, {
                icon: this.X1t,
                VBe: this.CNe,
                width: this.ZC,
                height: this.tv,
                fontBoundingBoxAscent: this.gNe,
                fontBoundingBoxDescent: this.yNe,
                IUe: this.bNe
            })
        }
        MA(t) {
            if (!t)
                return null;
            let i = Number(this.X1t);
            return String(i) === this.X1t ? (i = Math.floor(i),
            t.PNe(i)) : t.GNe(this.X1t)
        }
        iNe(t) {
            const i = this.MA(t);
            this.ZC = i ? this.tv * i.ns() / i.Kn() : 0
        }
        gn(t) {
            const i = this.MA(t);
            return i ? i.gn() : null
        }
        zUe() {
            return 1
        }
    }
}
{
    const nc = self.t;
    nc.esi = class {
        constructor(t) {
            nc.qd(t.nsi),
            nc.qd(t.hsi),
            this.ANe = new Map,
            this.RNe = t.nsi,
            this.kNe = t.hsi
        }
        he() {
            for (const t of this.ANe.values())
                t.he();
            this.ANe.clear()
        }
        Gri(t) {
            let i = this.ANe.get(t);
            if (i)
                return i;
            const e = this.RNe(t);
            return i = nc.v(nc.$Ue, this, {
                source: t,
                ONe: e
            }),
            this.ANe.set(t, i),
            i
        }
        _ri(t) {
            return this.ANe.has(t)
        }
        xri(t) {
            const i = this.ANe.get(t);
            i && i.he(),
            this.ANe.delete(t)
        }
        async DNe(t) {
            return await this.kNe(t)
        }
    }
}
{
    const rc = self.t;
    rc.$Ue = class {
        constructor(t, i) {
            rc.Yq(i),
            this.isi = t,
            this.SLt = i.source,
            this.FNe = [],
            this.LNe = new Map,
            this.BNe = !1,
            this.hn = !1,
            this.due = null;
            const e = i.ONe.Ari;
            for (let t = 0, i = e.length; t < i; ++t) {
                const i = e[t]
                  , s = rc.v(rc.UNe, this, {
                    index: t,
                    tag: i.tag,
                    source: i.source,
                    width: i.width,
                    height: i.height
                });
                this.FNe.push(s),
                i.tag && this.LNe.set(i.tag.toLowerCase(), s)
            }
        }
        he() {
            for (const t of this.FNe)
                t.he();
            rc.sc(this.FNe),
            this.LNe.clear(),
            this.isi = null,
            this.SLt = null
        }
        Cri() {
            return this.BNe
        }
        kx() {
            return this.hn
        }
        Iri() {
            return this.due || (this.due = this.NNe()),
            this.due
        }
        async NNe() {
            if (this.BNe)
                return;
            this.BNe = !0,
            this.hn = !0;
            const t = await this.isi.DNe(this.SLt);
            if (!this.isi)
                return;
            const i = t.Ari;
            rc._D(i);
            for (let t = 0, e = Math.min(i.length, this.FNe.length); t < e; ++t) {
                const e = i[t].Pri;
                this.FNe[t].jNe(e)
            }
            this.hn = !1
        }
        PNe(t) {
            return rc.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.FNe.length ? null : this.FNe[t]
        }
        GNe(t) {
            return rc.zt(t),
            this.LNe.get(t.toLowerCase()) || null
        }
    }
}
self.t.UNe = class {
    constructor(t, i) {
        this.$Ne = t,
        this.SLt = i.source || null,
        this.eVt = i.index,
        this.vg = i.tag,
        this.ZC = i.width,
        this.tv = i.height,
        this.zNe = null
    }
    he() {
        this.ZC = 0,
        this.tv = 0,
        this.$Ne = null
    }
    YMt() {
        return this.SLt
    }
    ns() {
        return this.ZC
    }
    Kn() {
        return this.tv
    }
    jNe(t) {
        this.zNe = t
    }
    gn() {
        return this.zNe
    }
}
;
{
    const hc = self.t
      , oc = self.assert;
    let ac = null
      , lc = null
      , uc = ""
      , cc = !1
      , dc = []
      , fc = [];
    const pc = "[???]";
    let mc = 0;
    const wc = {
        useGrouping: !1
    };
    hc.p = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static VNe() {
            return hc.jii() || uc && "en-US" !== uc && !uc.startsWith("synthetic-")
        }
        static vp(t) {
            if (hc.zt(t),
            uc = t,
            lc = hc.v(hc.p.WNe),
            hc.p.VNe() ? lc.HNe("loader/lang/precompiled-en-US.json", !0) : lc.HNe("lang/en-US.json"),
            "en-US" !== uc)
                if (uc.startsWith("synthetic-")) {
                    let t = hc.p.KNe(uc);
                    if (!t)
                        throw new Error(`invalid synthetic language '${uc}'`);
                    ac = hc.v(hc.p.qNe, lc, t)
                } else
                    ac = hc.v(hc.p.WNe),
                    hc.p.VNe() ? ac.HNe(`loader/lang/precompiled-${uc}.json`, !0) : ac.HNe(`lang/${uc}.json`);
            cc = !0;
            for (let t of dc)
                hc.p.ik(t);
            return hc.sc(dc),
            hc.p.SIt()
        }
        static ik(t, i) {
            if (hc.zt(t),
            hc.p.VNe()) {
                if (!i)
                    return
            } else if (i)
                throw new Error("do not specify the 'includeWhenPrecompiled' flag on AddPath when not using a pre-compiled language file");
            cc ? (lc.HNe(`${t}/en-US.json`),
            "en-US" === uc || uc.startsWith("synthetic-") || ac.HNe(`${t}/${uc}.json`)) : dc.push(t)
        }
        static XNe(t) {
            hc.zt(t),
            lc.HNe(t)
        }
        static YNe(t) {
            hc.zt(t),
            "en-US" === uc || uc.startsWith("synthetic-") || ac.HNe(t)
        }
        static SIt(t) {
            return "en-US" === uc || uc.startsWith("synthetic-") ? lc.SIt(t) : Promise.all([lc.SIt(t), ac.SIt(t)]).then( () => hc.qs.JNe(ac.ZNe()))
        }
        static QNe(t, i) {
            return i ? i.startsWith("http:") || i.startsWith("https:") || t.endsWith(".help-url") ? i : (0 === mc && (() => {})(`[LANG] Failed to find '${uc}' string ${hc.p.dMt() + t}'`),
            `[${i}]`) : i
        }
        static $s(t) {
            if (hc.zt(t),
            oc(lc, "English language not initialised"),
            ac) {
                let i = ac.tje(t);
                return i === pc ? (i = lc.tje(t),
                i === pc ? i : hc.p.QNe(t, i)) : i
            }
            return lc.tje(t)
        }
        static ije(t, i) {
            return hc.zt(t),
            hc.Ge(i),
            ac ? ac.eje(i) : lc.eje(i)
        }
        static sje(t) {
            return hc.zt(t),
            new hc.MC(hc.p.$s(t))
        }
        static nje(t) {
            return !!hc.p.$s(t).match(/{\d+}|\{{1}.+\}{1}/g)
        }
        static rje(t) {
            hc._D(t);
            const i = [];
            for (const e of t)
                "number" == typeof e ? i.push(hc.p.ZZ(e)) : i.push(e);
            return i
        }
        static ZZ(t, i) {
            return hc.VY(t),
            i = Object.assign({}, wc, i),
            t.toLocaleString((ac || lc).Yg(), i)
        }
        static hje(t, ...i) {
            return hc.zt(t),
            1 === i.length && hc.Ots(i[0]) ? hc.gxe(hc.p.$s(t), i[0]) : hc.vBe(hc.p.$s(t), ...hc.p.rje(i))
        }
        static oje(t, ...i) {
            return hc.zt(t),
            new hc.MC(hc.vBe(hc.p.$s(t), ...hc.p.rje(i)))
        }
        static aje(t, i, ...e) {
            let s;
            if (hc.zt(t),
            hc.Wat(i),
            i && "number" == typeof i.lje)
                s = i.lje;
            else {
                const t = i && "number" == typeof i.Tue ? Math.floor(i.Tue) : 0;
                if (t < 0 || t >= e.length)
                    throw new RangeError("invalid plural index");
                if (s = e[t],
                "number" != typeof s)
                    throw new TypeError("expected number for pluralising string")
            }
            const n = hc.p.ije(t, s)
              , r = hc.SBe(hc.p.$s(t + "." + n), ...hc.p.rje(e));
            return i && i.bD ? new hc.MC(r) : r
        }
        static dMt() {
            let t = fc.length
              , i = t - 1;
            for (; i >= 0 && "." === fc[i][0]; --i)
                ;
            i < 0 && (i = 0);
            let e = "";
            for (; i < t; ++i)
                e += fc[i];
            return e
        }
        static uje() {
            let t = hc.p.dMt();
            ac && ac.cje(t),
            lc && lc.cje(t)
        }
        static Ok(t) {
            hc.zt(t),
            oc("." !== t[0], "context cannot be relative."),
            oc("." !== t.slice(-1), "context cannot finish with a '.'.");
            const i = i => i.startsWith(".") ? t + i : t + "." + i
              , e = t => self.lang(i(t));
            return e.oj = (t, ...e) => self.tP(i(t), ...e),
            e.BB = t => self.idt(i(t)),
            e.hDt = (t, ...e) => self.tG(i(t), ...e),
            e.yD = (t, e, ...s) => self.iG(i(t), e, ...s),
            e
        }
        static u(t) {
            hc.zt(t),
            oc(fc.length || "." !== t[0], "first pushed language context cannot be relative"),
            fc.push(t),
            oc(fc.length < 100, `language context stack reached 100 items - is this right? Stack is: ${fc.join(";")}`),
            hc.p.uje()
        }
        static j() {
            oc(fc.length > 0, "popping language context stack when it's empty - check PushContext/PopContext calls paired correctly"),
            fc.pop(),
            hc.p.uje()
        }
        static oZs() {
            return "en-US" === uc
        }
        static dje() {
            return uc
        }
        static fje() {
            return (ac || lc).pje()
        }
        static ZNe() {
            return !!ac && ac.ZNe()
        }
        static iXs(t) {
            return `${t}${!hc.p.ZNe() ? hc.Gvt._Ue : hc.Gvt.TUe}`
        }
        static mje(t) {
            return ac ? ac.wje(t) : lc.wje(t)
        }
        static Vr(t) {
            t ? --mc : ++mc,
            oc(mc >= 0, "disabled missing string logging too many times")
        }
    }
    ,
    hc.p.Fl = pc,
    window.lang = hc.p.$s,
    window.idt = hc.p.sje,
    window.tP = hc.p.hje,
    window.tG = hc.p.oje,
    window.iG = hc.p.aje,
    window.p$t = hc.p.nje
}
{
    const gc = self.t;
    gc.p.WNe = class extends gc.Me {
        constructor() {
            super(),
            this.gje = [],
            this.yje = !1,
            this.bje = "",
            this.vje = "",
            this.Sje = "",
            this.xje = !1,
            this.Mje = new Map,
            this.TTt = "",
            this.Eje = null
        }
        Yg() {
            return this.Sje
        }
        pje() {
            return this.vje
        }
        HNe(t) {
            if (gc.zt(t),
            this.gje.includes(t))
                throw new Error("same language URL added twice");
            this.gje.push(t)
        }
        async SIt(t) {
            if (!this.gje.length)
                return Promise.resolve(this);
            const i = [];
            return gc.lw(i, this.gje),
            gc.sc(this.gje),
            await Promise.all(i.map(async i => {
                const e = await gc.Z1t(i);
                this.G3s(e, t)
            }
            )),
            this
        }
        G3s(t, i) {
            gc.Yq(t);
            let e = t.languageTag;
            if (this.Sje) {
                if (this.Sje !== e)
                    throw new Error(`language file has wrong language tag (has '${e}', expected '${this.Sje}')`)
            } else
                this.Sje = e,
                void 0 !== Intl.PluralRules && (this.Eje = new Intl.PluralRules(this.Sje));
            if (t.main) {
                this.bje = t.englishName,
                this.vje = t.nativeName;
                const i = t.rightToLeft;
                this.xje = "string" == typeof i ? "true" === i : !!i,
                this.yje = !0
            }
            this.Cje(t.text, "", i)
        }
        Cje(t, i, e) {
            gc.Yq(t),
            gc.zt(i),
            i && (i += ".");
            for (let[s,n] of Object.entries(t)) {
                let t = i + s;
                if ("object" == typeof n)
                    this.Cje(n, t, e);
                else if ("string" == typeof n) {
                    if (!e && this.Mje.has(t))
                        throw new Error(`key name '${t}' already exists in language string map`);
                    this.Mje.set(t, n)
                }
            }
        }
        cje(t) {
            gc.zt(t),
            this.TTt = t
        }
        tje(t) {
            if (gc.zt(t),
            !this.yje)
                throw new Error("language not loaded");
            if (!t)
                throw new Error("cannot lookup empty key");
            if (t.startsWith(".")) {
                if (!this.TTt)
                    throw new Error("relative language string used with no context set");
                t = this.TTt + t
            }
            let i = this.Mje.get(t);
            return void 0 === i ? gc.p.Fl : i
        }
        eje(t) {
            return gc.Ge(t),
            this.Eje ? this.Eje.select(t) : "other"
        }
        ZNe() {
            if (!this.yje)
                throw new Error("language not loaded");
            return this.xje
        }
        wje(t) {
            const i = "exporters.preview.debugger."
              , e = /^(plugins|behaviors)\.\w+\.name$/
              , s = /^(plugins|behaviors)\.\w+\.debugger\./
              , n = /^(plugins|behaviors)\.\w+\.properties\.[\w-]+\.name$/
              , r = /^(plugins|behaviors)\.\w+\.properties\.[\w-]+\.items/
              , h = [];
            for (const t of this.Mje.keys())
                t.startsWith(i) ? h.push({
                    _je: t,
                    key: t.substr(27)
                }) : (e.test(t) || s.test(t) || n.test(t) || r.test(t)) && h.push({
                    _je: t,
                    key: t
                });
            return h
        }
    }
}
{
    const yc = self.t;
    function bc(t, i) {
        if (!i)
            return t;
        let e = ""
          , s = !1
          , n = !1;
        for (let r = 0, h = t.length; r < h; ++r) {
            let h = t.charAt(r);
            "[" === h ? (s = !0,
            e += h) : "]" === h ? (s = !1,
            e += h) : "{" === h ? (n = !0,
            e += h) : "}" === h ? (n = !1,
            e += h) : e += s || n ? h : i(h)
        }
        return e
    }
    function vc(t) {
        return t.toUpperCase()
    }
    function Sc(t) {
        return t.toLowerCase()
    }
    let xc = new Set([" ", "\n", "\t", "-", ".", ":", ";", "'", '"', "(", ")", "+", "=", "[", "]", "{", "}", "!", "?", "|", "\\", "/", "<", ">", "@", "#", "~", "%", "&", "*"]);
    function Mc(t, i) {
        if (xc.has(t))
            return t;
        {
            let e = "";
            for (let s = 0; s < i; ++s)
                e += t;
            return e
        }
    }
    function Ec(t) {
        return function(i) {
            return Mc(i, t)
        }
    }
    let Cc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
      , _c = "jqJQ"
      , Tc = new Map;
    for (let kc = 0, Oc = Cc.length; kc < Oc; ++kc)
        Tc.set(Cc.charAt(kc), _c.charAt(kc));
    function Ic(t) {
        return Tc.get(t) || t
    }
    let Pc = new Map([["a", "4"], ["A", "4"], ["B", "|3"], ["c", "<"], ["C", "("], ["D", "[)"], ["e", "3"], ["E", "3"], ["g", "9"], ["G", "9"], ["H", "|-|"], ["i", "1"], ["I", "1"], ["K", "|<"], ["l", "L"], ["L", "|_"], ["M", "(\\/)"], ["N", "(\\)"], ["o", "0"], ["O", "0"], ["R", "|2"], ["s", "5"], ["S", "5"], ["t", "7"], ["T", "7"], ["U", "|_|"], ["V", "\\/"], ["W", "(/\\)"]]);
    function Gc(t) {
        return Pc.get(t) || t
    }
    function Ac(t) {
        switch (t) {
        case "synthetic-uppercase":
            return vc;
        case "synthetic-lowercase":
            return Sc;
        case "synthetic-repeat-2":
            return Ec(2);
        case "synthetic-repeat-3":
            return Ec(3);
        case "synthetic-repeat-4":
            return Ec(4);
        case "synthetic-rockdots":
            return Ic;
        case "synthetic-leet":
            return Gc;
        default:
            return null
        }
    }
    function Rc(t) {
        let i = Ac(t);
        return t => bc(t, i)
    }
    yc.p.KNe = function(t) {
        return Rc(t)
    }
    ,
    yc.p.qNe = class extends yc.Me {
        constructor(t, i) {
            super(),
            this.Tje = t,
            this.cyi = i
        }
        Yg() {
            return this.Tje.Yg()
        }
        eje(t) {
            return this.Tje.eje(t)
        }
        wje(t) {
            return this.Tje.wje(t)
        }
        SIt() {
            return self
        }
        cje(t) {}
        tje(t) {
            yc.zt(t);
            let i = this.Tje.tje(t);
            return (e = i) === yc.p.Fl || e.startsWith("http:") || e.startsWith("https:") ? i : this.cyi(i);
            var e
        }
        ZNe() {
            return this.Tje.ZNe()
        }
    }
}
{
    const Dc = self.t;
    let Fc = new Map
      , Lc = new Map
      , Bc = new Map;
    const Uc = "unknown";
    function Nc(t, i, e) {
        if (Dc.Ge(t),
        t = Math.floor(t),
        Dc.zt(i),
        Dc.Kq(e),
        Fc.has(t))
            throw new Error("duplicate key code");
        if (Lc.has(i))
            throw new Error("duplicate key id");
        return Fc.set(t, i),
        Lc.set(i, t),
        e && Bc.set(i, e),
        t
    }
    class jc extends Dc.Me {
        constructor() {
            super(),
            this.Ije = Nc(8, "backspace"),
            this.UY = Nc(9, "tab"),
            this.Pje = Nc(12, "clear"),
            this.w9 = Nc(13, "enter"),
            this.CF = Nc(16, "shift", ""),
            this.oSi = Nc(17, "control", "Ctrl"),
            this.OZ = Nc(18, "alt", Dc.kt.w$t ? "" : "Alt"),
            this.Gje = Nc(19, "pause"),
            this.Aje = Nc(20, "caps-lock"),
            this.IE = Nc(27, "escape"),
            this.Rje = Nc(33, "page-up"),
            this._1 = Nc(32, "space"),
            this.kje = Nc(34, "page-down"),
            this.Oje = Nc(35, "end"),
            this.Dje = Nc(36, "home"),
            this.F7 = Nc(37, "left-arrow", ""),
            this.K7 = Nc(38, "up-arrow", ""),
            this.V7 = Nc(39, "right-arrow", ""),
            this.j7 = Nc(40, "down-arrow", ""),
            this.Fje = Nc(45, "insert"),
            this.vis = Nc(46, "delete"),
            this.Lje = Nc(48, "0"),
            this.XVi = Nc(49, "1"),
            this.qVi = Nc(50, "2"),
            this.QVi = Nc(51, "3"),
            this.$Vi = Nc(52, "4"),
            this.HVi = Nc(53, "5"),
            this.WVi = Nc(54, "6"),
            this.jVi = Nc(55, "7"),
            this.NVi = Nc(56, "8"),
            this.VVi = Nc(57, "9"),
            this.A = Nc(65, "a"),
            this.B = Nc(66, "b"),
            this.C = Nc(67, "c"),
            this.D = Nc(68, "d"),
            this.E = Nc(69, "e"),
            this.F = Nc(70, "f"),
            this.G = Nc(71, "g"),
            this.H = Nc(72, "h"),
            this.I = Nc(73, "i"),
            this.J = Nc(74, "j"),
            this.K = Nc(75, "k"),
            this.L = Nc(76, "l"),
            this.M = Nc(77, "m"),
            this.N = Nc(78, "n"),
            this.O = Nc(79, "o"),
            this.P = Nc(80, "p"),
            this.Q = Nc(81, "q"),
            this.R = Nc(82, "r"),
            this.S = Nc(83, "s"),
            this.T = Nc(84, "t"),
            this.U = Nc(85, "u"),
            this.V = Nc(86, "v"),
            this.W = Nc(87, "w"),
            this.X = Nc(88, "x"),
            this.Y = Nc(89, "y"),
            this.Z = Nc(90, "z"),
            this.Bje = Nc((Dc.kt.w$t,
            91), "left-meta", Dc.kt.w$t ? "" : ""),
            this.Uje = Nc(Dc.kt.w$t ? 93 : 92, "right-meta", Dc.kt.w$t ? "" : ""),
            this.Nje = Nc(224, "firefox-meta", ""),
            this.jje = Nc(96, "numpad-0"),
            this.$je = Nc(97, "numpad-1"),
            this.zje = Nc(98, "numpad-2"),
            this.Vje = Nc(99, "numpad-3"),
            this.Wje = Nc(100, "numpad-4"),
            this.Hje = Nc(101, "numpad-5"),
            this.Kje = Nc(102, "numpad-6"),
            this.qje = Nc(103, "numpad-7"),
            this.Xje = Nc(104, "numpad-8"),
            this.Yje = Nc(105, "numpad-9"),
            this.Jje = Nc(106, "numpad-multiply"),
            this.Zje = Nc(107, "numpad-add"),
            this.Qje = Nc(109, "numpad-subtract"),
            this.t$e = Nc(110, "numpad-decimal"),
            this.i$e = Nc(111, "numpad-divide"),
            this.F1 = Nc(112, "f1"),
            this.F2 = Nc(113, "f2"),
            this.F3 = Nc(114, "f3"),
            this.F4 = Nc(115, "f4"),
            this.F5 = Nc(116, "f5"),
            this.F6 = Nc(117, "f6"),
            this.F7 = Nc(118, "f7"),
            this.F8 = Nc(119, "f8"),
            this.F9 = Nc(120, "f9"),
            this.eGt = Nc(121, "f10"),
            this.b$i = Nc(122, "f11"),
            this.S$i = Nc(123, "f12"),
            this.e$e = Nc(144, "num-lock"),
            this.s$e = Nc(145, "scroll-lock"),
            this.n$e = Nc(180, "launch-mail"),
            this.r$e = Nc(183, "launch-calculator"),
            this.h$e = Nc(186, "semicolon", ";"),
            this.o$e = Nc(187, "equals", "="),
            this.P4s = Nc(188, "comma", ","),
            this.T4s = Nc(189, "subtract", "-"),
            this.a$e = Nc(190, "period", "."),
            this.l$e = Nc(191, "slash", "/"),
            this.u$e = Nc(192, "apostrophe", "'"),
            this.c$e = Nc(219, "open-square-bracket", "["),
            this.d$e = Nc(221, "close-square-bracket", "]"),
            this.f$e = Nc(220, "backslash", "\\"),
            this.p$e = Nc(222, "hash", "#"),
            this.m$e = Nc(223, "backtick", "`"),
            this.ZLt = 1e4,
            this.Rzt = 10001,
            this.Dzt = 10002,
            this.Ezt = 10003,
            this.zzt = 10004,
            this.Uzt = 10005,
            this.Nzt = 10006,
            this.Fzt = 10007,
            this.DVi = 10008,
            this.LVi = 10009,
            this.Jct = 10010,
            this.jLi = 10011,
            this.RLi = 10012,
            this.DLi = 10013,
            this.NLi = 10014,
            this.w$e = 10015,
            this.lGt = 10016,
            this.rGt = 10017
        }
        g$e(t) {
            return t >= 1e4
        }
        Zct(t, i) {
            if (this.g$e(t)) {
                if (this.g$e(i))
                    return t === i
            } else {
                if (!this.g$e(i))
                    return t === i;
                {
                    let e = t;
                    t = i,
                    i = e
                }
            }
            return this.y$e(t).includes(i)
        }
        b$e(t) {
            return [this.ZLt, this.Rzt, this.Dzt, this.Ezt, this.zzt, this.Uzt, this.Nzt, this.Fzt, this.DVi, this.LVi].some(i => this.y$e(i).includes(t))
        }
        y$e(t) {
            if (!this.g$e(t))
                return [t];
            switch (t) {
            case this.ZLt:
                return [this.Lje, this.jje, this.Fje];
            case this.Rzt:
                return [this.XVi, this.$je, this.Oje];
            case this.Dzt:
                return [this.qVi, this.zje];
            case this.Ezt:
                return [this.QVi, this.Vje, this.kje];
            case this.zzt:
                return [this.$Vi, this.Wje];
            case this.Uzt:
                return [this.HVi, this.Hje, this.Pje];
            case this.Nzt:
                return [this.WVi, this.Kje];
            case this.Fzt:
                return [this.jVi, this.qje, this.Dje];
            case this.DVi:
                return [this.NVi, this.Xje];
            case this.LVi:
                return [this.VVi, this.Yje, this.Rje];
            case this.Jct:
                return [this.vis, this.t$e, this.Ije];
            case this.jLi:
                return [this.F7, this.Wje];
            case this.RLi:
                return [this.V7, this.Kje];
            case this.DLi:
                return [this.j7, this.zje];
            case this.NLi:
                return [this.K7, this.Xje];
            case this.w$e:
                return [this.Bje, this.Uje, this.Nje];
            case this.lGt:
                return [this.o$e, this.Zje];
            case this.rGt:
                return [this.T4s, this.Qje];
            default:
                throw new RangeError("invalid virtual key code")
            }
        }
        v$e(t) {
            return Dc.Ge(t),
            t = Math.floor(t),
            Fc.get(t) || Uc
        }
        S$e(t) {
            return Dc.zt(t),
            Lc.get(t) || 0
        }
        Fa(t) {
            if ("string" == typeof t)
                return this.x$e(t);
            if ("number" == typeof t)
                return this.WGe(t);
            throw new TypeError("expected string or number")
        }
        WGe(t) {
            return Dc.Ge(t),
            t = Math.floor(t),
            Fc.has(t) ? this.x$e(this.v$e(t)) : self.tP("ui.keyboard.keyNames.codeNumber", t)
        }
        x$e(t) {
            return Dc.zt(t),
            self.lang("ui.keyboard.keyNames." + t)
        }
        m$t(t) {
            if ("string" == typeof t)
                return this.M$e(t);
            if ("number" == typeof t)
                return this.E$e(t);
            throw new TypeError("expected string or number")
        }
        E$e(t) {
            return Dc.Ge(t),
            t = Math.floor(t),
            Bc.get(this.v$e(t)) || null
        }
        M$e(t) {
            return Dc.zt(t),
            Bc.get(t) || null
        }
        TSt(t) {
            return this.m$t(t) || this.Fa(t)
        }
    }
    Dc.kE = Dc.v(jc)
}
self.t.f1 = Object.freeze({
    e5: 0,
    c1: 1,
    DOt: 2
});
{
    const $c = self.t
      , zc = 333
      , Vc = 25
      , Wc = 333
      , Hc = 33
      , Kc = 20
      , qc = 500;
    let Xc = 0
      , Yc = 0
      , Jc = 0;
    $c.C$e = class extends $c.Me {
        constructor(t, i) {
            super(),
            this.phs = t.id,
            this._$e = i,
            this._9 = t.clientX,
            this.S9 = t.clientY,
            this.T$e = Date.now(),
            this.I$e = this._9,
            this.P$e = this.S9,
            this.G$e = !1,
            this.A$e = !1,
            this.R$e = !1,
            this.k$e = null,
            this.O$e = null
        }
        D$e(t) {
            this.k$e = t
        }
        F$e(t) {
            this.O$e = t
        }
        so(t) {
            this.I$e = t.clientX,
            this.P$e = t.clientY;
            const i = $c.di(this._9, this.S9, this.I$e, this.P$e);
            i > Vc && (this.G$e = !0),
            i > Kc && (this.A$e = !0)
        }
        aNi() {
            return !!this._$e.ownerDocument.defaultView
        }
        L$e() {
            if (this.R$e)
                return;
            if (Date.now() - this.T$e >= qc && !this.A$e && $c.di(this._9, this.S9, this.I$e, this.P$e) < Kc) {
                this.R$e = !0;
                const t = new MouseEvent("contextmenu",{
                    bubbles: !0,
                    cancelable: !0,
                    screenX: this._9,
                    screenY: this.S9,
                    clientX: this._9,
                    clientY: this.S9,
                    button: 2,
                    buttons: 2
                });
                this._$e.dispatchEvent(t)
            }
        }
        B$e(t) {
            this.I$e = t.clientX,
            this.P$e = t.clientY;
            const i = Date.now();
            let e = !1;
            if (!this.G$e && i - this.T$e < zc && $c.di(this._9, this.S9, this.I$e, this.P$e) <= Vc) {
                let s = null;
                const n = {
                    PY: $c.f1.e5,
                    TY: "touch" === t.pointerType,
                    screenX: t.screenX,
                    screenY: t.screenY,
                    clientX: t.clientX,
                    clientY: t.clientY,
                    pageX: t.pageX,
                    pageY: t.pageY,
                    pointerType: t.pointerType
                };
                i - Jc <= zc + Wc && $c.di(this._9, this.S9, Xc, Yc) <= Hc ? (s = new CustomEvent("UIDoubleTap",{
                    bubbles: !0,
                    cancelable: !0,
                    detail: n
                }),
                Jc = 0,
                e = !0,
                this.O$e && this.O$e()) : (s = new CustomEvent("UITap",{
                    bubbles: !0,
                    cancelable: !0,
                    detail: n
                }),
                Xc = this.I$e,
                Yc = this.P$e,
                Jc = i,
                this.k$e && this.k$e()),
                e = !this._$e.dispatchEvent(s)
            }
            return this._$e = null,
            e
        }
    }
    ;
    const Zc = new Map;
    let Qc = -1;
    function td() {
        Qc = -1;
        for (const [t,i] of Zc.entries())
            i.aNi() ? i.L$e() : Zc.delete(t);
        Zc.size && (Qc = requestAnimationFrame(td))
    }
    $c.U$e = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static N$e(t, i) {
            const e = Zc.get(t.id);
            e && e.D$e(i)
        }
        static j$e(t, i) {
            const e = Zc.get(t.id);
            e && e.F$e(i)
        }
        static $$e(t, i, e) {
            let s = !1;
            if ("CustomPointerDown" === t)
                Zc.set(i.id, $c.v($c.C$e, i, e)),
                -1 === Qc && "iOS" === $c.kt.OS && (Qc = requestAnimationFrame(td));
            else if ("CustomPointerMove" === t) {
                const t = Zc.get(i.id);
                t && t.so(i)
            } else if ("CustomPointerUp" === t) {
                const t = Zc.get(i.id);
                t && (s = t.B$e(i)),
                Zc.delete(i.id)
            }
            return s
        }
    }
}
{
    const id = self.t
      , ed = {
        capture: !0,
        passive: !1
    }
      , sd = {
        capture: !0,
        passive: !0
    };
    let nd = !1
      , rd = !1;
    function hd(t) {
        return function(i) {
            if (!id.yc())
                return;
            if (i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)
                return;
            if (nd && "click" === i.type)
                return void (nd = !1);
            if (rd && "dblclick" === i.type)
                return void (rd = !1);
            const e = new CustomEvent(t,{
                bubbles: !0,
                cancelable: !0,
                detail: {
                    id: -1,
                    PY: i.button,
                    TY: !1,
                    screenX: i.screenX,
                    screenY: i.screenY,
                    clientX: i.clientX,
                    clientY: i.clientY,
                    pageX: i.pageX,
                    pageY: i.pageY,
                    ctrlKey: i.ctrlKey,
                    shiftKey: i.shiftKey,
                    altKey: i.altKey,
                    metaKey: i.metaKey,
                    pointerType: "mouse"
                }
            });
            i.target.dispatchEvent(e) || i.preventDefault()
        }
    }
    function od(t) {
        return function(i) {
            if (!id.yc())
                return;
            if ("mouse" === i.pointerType)
                return;
            const e = {
                id: i.pointerId,
                PY: id.f1.e5,
                TY: "touch" === i.pointerType,
                screenX: i.screenX,
                screenY: i.screenY,
                clientX: i.clientX,
                clientY: i.clientY,
                pageX: i.pageX,
                pageY: i.pageY,
                ctrlKey: !1,
                shiftKey: !1,
                altKey: !1,
                metaKey: !1,
                pointerType: i.pointerType
            };
            id.U$e.N$e(e, () => nd = !0),
            id.U$e.j$e(e, () => rd = !0);
            const s = id.U$e.$$e(t, e, i.target);
            id.U$e.N$e(e, null),
            id.U$e.j$e(e, null),
            s && i.preventDefault()
        }
    }
    let ad = -1;
    function ld(t) {
        const i = t.touches;
        if (0 === t.touches.length)
            return;
        const e = window.innerWidth <= 600 ? 30 : 50
          , s = i[0].pageX;
        (s < e || s > window.innerWidth - 15) && t.preventDefault()
    }
    window.addEventListener("pointermove", t => {
        "mouse" === t.pointerType && (ad = t.pointerId)
    }
    , sd),
    id.Yit = function() {
        return ad
    }
    ,
    "Safari" === id.kt.Nr && document.addEventListener("touchstart", ld, ed),
    document.addEventListener("click", hd("UITap"), ed),
    document.addEventListener("dblclick", hd("UIDoubleTap"), ed),
    document.addEventListener("pointerdown", od("CustomPointerDown"), ed),
    document.addEventListener("pointermove", od("CustomPointerMove"), sd),
    document.addEventListener("pointerup", od("CustomPointerUp"), ed)
}
{
    const ud = self.t;
    ud.Event = class {
        constructor(t, i) {
            ud.zt(t),
            this.type = t,
            this.cancelable = !!i,
            this.defaultPrevented = !1,
            this.z$e = !1,
            this.oEt = !1
        }
        preventDefault() {
            if (!this.cancelable)
                throw new Error(`event '${this.type}' is not cancelable`);
            this.defaultPrevented = !0
        }
        stopPropagation() {
            if (!this.cancelable)
                throw new Error(`event '${this.type}' cannot be stopped`);
            if (this.oEt)
                throw new Error(`cannot stop async event '${this.type}' propagation`);
            this.z$e = !0
        }
    }
}
{
    const cd = self.t;
    cd.Event.aG = class extends cd.Me {
        constructor() {
            super(),
            this.V$e = new Map,
            this.W$e = !1
        }
        he() {
            if (this.W$e)
                throw new Error("already released");
            this.IWt(),
            this.W$e = !0,
            cd.he(this)
        }
        dn() {
            return this.W$e
        }
        IWt() {
            if (this.V$e) {
                for (let t of this.V$e.values())
                    t.he();
                this.V$e.clear()
            }
        }
        H$e(t, i) {
            cd.zt(t);
            let e = this.V$e.get(t);
            return e || (i ? (e = cd.v(cd.Event.K$e, t),
            this.V$e.set(t, e),
            e) : null)
        }
        q$e(t) {
            return this.V$e.has(t)
        }
        addEventListener(t, i, e) {
            cd.zt(t),
            cd.qd(i),
            this.H$e(t, !0).X$e(i, !!e)
        }
        removeEventListener(t, i, e) {
            cd.zt(t),
            cd.qd(i);
            let s = this.H$e(t, !1);
            s && (s.Y$e(i, !!e),
            s.J$e() && this.V$e.delete(t))
        }
        dispatchEvent(t) {
            cd.U(t, cd.Event),
            cd.zt(t.type);
            const i = this.H$e(t.type, !1);
            return !i || (t.cancelable ? i.Z$e(t) : i.Q$e(t))
        }
        RAe(t) {
            cd.U(t, cd.Event),
            cd.zt(t.type);
            const i = this.H$e(t.type, !1);
            return i ? (t.oEt = !0,
            i.tze(t)) : Promise.resolve(!0)
        }
        async ize(t) {
            cd.U(t, cd.Event),
            cd.zt(t.type);
            const i = this.H$e(t.type, !1);
            if (!i)
                return !0;
            this.V$e.delete(t.type),
            t.oEt = !0;
            const e = await i.tze(t);
            return i.he(),
            e
        }
        async eze(t) {
            cd.U(t, cd.Event),
            cd.zt(t.type);
            const i = this.H$e(t.type, !1);
            return !i || await i.sze(t)
        }
        nze(t) {
            cd.U(t, cd.Event),
            cd.zt(t.type);
            const i = this.H$e(t.type, !1);
            return !i || i.rze(t)
        }
        async oWt(t) {
            cd.U(t, cd.Event),
            cd.zt(t.type);
            const i = this.H$e(t.type, !1);
            return !i || await i.hze(t)
        }
        oze(t) {
            cd.U(t, cd.Event),
            cd.zt(t.type);
            const i = this.H$e(t.type, !1);
            if (!i)
                return null;
            if (t.cancelable)
                throw new Error("not supported");
            return i.aze(t)
        }
        lze(t) {
            for (const i of this.V$e.values())
                i.lze(t)
        }
    }
}
{
    const dd = self.t
      , fd = self.assert;
    dd.Event.K$e = class extends dd.Me {
        constructor(t) {
            super(),
            this.lVt = t,
            this.uze = [],
            this.cze = new Set,
            this.dze = [],
            this.fze = new Set,
            this.pze = 0,
            this.mze = []
        }
        he() {
            this.pze > 0 || (dd.sc(this.uze),
            this.cze.clear(),
            dd.sc(this.dze),
            this.fze.clear(),
            dd.sc(this.mze),
            dd.he(this))
        }
        X$e(t, i) {
            if (dd.qd(t),
            this.wze())
                this.mze.push({
                    op: "add",
                    gze: t,
                    capture: i
                });
            else if (i) {
                if (this.cze.has(t))
                    return;
                this.uze.push(t),
                this.cze.add(t)
            } else {
                if (this.fze.has(t))
                    return;
                this.dze.push(t),
                this.fze.add(t)
            }
        }
        Y$e(t, i) {
            dd.qd(t),
            this.wze() ? this.mze.push({
                op: "remove",
                gze: t,
                capture: i
            }) : i ? this.cze.has(t) && (this.cze.delete(t),
            dd.sni(this.uze, t)) : this.fze.has(t) && (this.fze.delete(t),
            dd.sni(this.dze, t))
        }
        J$e() {
            return !this.uze.length && !this.dze.length
        }
        wze() {
            return this.pze > 0
        }
        yze() {
            const t = new Set
              , i = new Set;
            for (const e of this.mze)
                if ("add" === e.op)
                    this.X$e(e.gze, e.capture),
                    e.capture ? i.delete(e.gze) : t.delete(e.gze);
                else {
                    if ("remove" !== e.op)
                        throw new Error("invalid op");
                    e.capture ? (this.cze.delete(e.gze),
                    i.add(e.gze)) : (this.fze.delete(e.gze),
                    t.add(e.gze))
                }
            dd.spt(this.dze, t),
            dd.spt(this.uze, i),
            dd.sc(this.mze)
        }
        Z$e(t) {
            fd(t instanceof dd.Event, "invalid event"),
            fd(t.type === this.lVt, "event type does not match handler"),
            this.bze();
            let i = !1;
            for (let e = 0, s = this.uze.length; e < s; ++e)
                if (this.uze[e](t),
                t.z$e) {
                    i = !0;
                    break
                }
            if (!i)
                for (let i = 0, e = this.dze.length; i < e && (this.dze[i](t),
                !t.z$e); ++i)
                    ;
            return this.vze(),
            !t.defaultPrevented
        }
        Q$e(t) {
            this.bze();
            for (let i = 0, e = this.uze.length; i < e; ++i)
                this.uze[i](t);
            for (let i = 0, e = this.dze.length; i < e; ++i)
                this.dze[i](t);
            return this.vze(),
            !0
        }
        bze() {
            this.pze++
        }
        vze() {
            this.pze--,
            0 === this.pze && this.mze.length > 0 && this.yze()
        }
        lze(t) {
            t ? this.bze() : this.vze()
        }
        tze(t) {
            fd(t instanceof dd.Event, "invalid event"),
            fd(t.type === this.lVt, "event type does not match handler");
            let i = [];
            for (let e = 0, s = this.uze.length; e < s; ++e) {
                let s = this.uze[e];
                i.push(dd._Ct( () => s(t)))
            }
            for (let e = 0, s = this.dze.length; e < s; ++e) {
                let s = this.dze[e];
                i.push(dd._Ct( () => s(t)))
            }
            return Promise.all(i).then( () => !t.defaultPrevented)
        }
        rze(t) {
            fd(t instanceof dd.Event, "invalid event"),
            fd(t.type === this.lVt, "event type does not match handler");
            const i = [];
            this.bze();
            for (let e = 0, s = this.uze.length; e < s; ++e) {
                const s = this.uze[e](t);
                s instanceof Promise && i.push(s)
            }
            for (let e = 0, s = this.dze.length; e < s; ++e) {
                const s = this.dze[e](t);
                s instanceof Promise && i.push(s)
            }
            return this.vze(),
            i.length ? Promise.all(i).then( () => !t.defaultPrevented) : !t.defaultPrevented
        }
        async sze(t) {
            return await this.rze(t)
        }
        async hze(t) {
            fd(t instanceof dd.Event, "invalid event"),
            fd(t.type === this.lVt, "event type does not match handler"),
            this.bze();
            for (let i = 0, e = this.uze.length; i < e; ++i) {
                const e = this.uze[i](t);
                e instanceof Promise && await e
            }
            for (let i = 0, e = this.dze.length; i < e; ++i) {
                const e = this.dze[i](t);
                e instanceof Promise && await e
            }
            return this.vze(),
            !t.defaultPrevented
        }
        *aze(t) {
            this.bze();
            for (let i = 0, e = this.uze.length; i < e; ++i) {
                const e = this.uze[i](t);
                dd.Sze(e) && (yield*e)
            }
            for (let i = 0, e = this.dze.length; i < e; ++i) {
                const e = this.dze[i](t);
                dd.Sze(e) && (yield*e)
            }
            this.vze()
        }
    }
}
{
    const pd = self.t
      , md = self.assert;
    let wd = [];
    pd.OF = class {
        constructor() {
            throw new TypeError("static class")
        }
        static FP(t) {
            let i = t.which;
            for (; wd.length <= i; )
                wd.push(!1);
            i === pd.kE.UY && wd[i] && t.preventDefault(),
            wd[i] = !0
        }
        static Pz(t) {
            let i = t.which;
            i < 0 || i >= wd.length || (wd[i] = !1)
        }
        static xze() {
            for (let t = 0, i = wd.length; t < i; ++t)
                wd[t] = !1
        }
        static PF(t) {
            if (pd.kE.g$e(t)) {
                let i = pd.kE.y$e(t);
                for (let t of i)
                    if (pd.OF.Mze(t))
                        return !0;
                return !1
            }
            return pd.OF.Mze(t)
        }
        static j1(t) {
            if (t) {
                if (pd.$nt(t)) {
                    let i = t;
                    return pd.$nt(i.detail) && (i = i.detail),
                    pd.kt.w$t ? !!i.metaKey : !!i.ctrlKey
                }
                throw new TypeError("invalid argument")
            }
            return pd.kt.w$t ? this.PF(pd.kE.w$e) : this.PF(pd.kE.oSi)
        }
        static Gct(t) {
            if (t) {
                if (pd.$nt(t)) {
                    let i = t;
                    return pd.$nt(i.detail) && (i = i.detail),
                    !!i.shiftKey
                }
                throw new TypeError("invalid argument")
            }
            return this.PF(pd.kE.CF)
        }
        static qFt(t) {
            if (t) {
                if (pd.$nt(t)) {
                    let i = t;
                    return pd.$nt(i.detail) && (i = i.detail),
                    !!i.altKey
                }
                throw new TypeError("invalid argument")
            }
            return this.PF(pd.kE.OZ)
        }
        static Azt(t) {
            if (pd.GH(t, pd.Event, Event, CustomEvent, KeyboardEvent)) {
                let i = t;
                if (pd.$nt(i.detail)) {
                    let t = i.detail;
                    return md("ctrlKey"in t),
                    md("metaKey"in t),
                    md("shiftKey"in t),
                    md("altKey"in t),
                    t.ctrlKey || t.metaKey || t.shiftKey || t.altKey
                }
                return md("ctrlKey"in i),
                md("metaKey"in i),
                md("shiftKey"in i),
                md("altKey"in i),
                i.ctrlKey || i.metaKey || i.shiftKey || i.altKey
            }
            if (pd.Ots(t)) {
                let i = t;
                return md("ctrlKey"in i),
                md("metaKey"in i),
                md("shiftKey"in i),
                md("altKey"in i),
                i.ctrlKey || i.metaKey || i.shiftKey || i.altKey
            }
            if (pd.fO(t))
                return pd.OF.PF(pd.kE.oSi) || pd.OF.PF(pd.kE.CF) || pd.OF.PF(pd.kE.OZ) || pd.OF.PF(pd.kE.w$e);
            throw new Error("unexpected argument")
        }
        static Eze(t) {
            if (pd.GH(t, pd.Event, Event, CustomEvent, KeyboardEvent)) {
                let i = t;
                if (pd.$nt(i.detail)) {
                    let t = i.detail;
                    return md("ctrlKey"in t),
                    md("metaKey"in t),
                    md("shiftKey"in t),
                    md("altKey"in t),
                    !(t.ctrlKey || t.metaKey || t.shiftKey || t.altKey)
                }
                return md("ctrlKey"in i),
                md("metaKey"in i),
                md("shiftKey"in i),
                md("altKey"in i),
                !(i.ctrlKey || i.metaKey || i.shiftKey || i.altKey)
            }
            if (pd.Ots(t)) {
                let i = t;
                return md("ctrlKey"in i),
                md("metaKey"in i),
                md("shiftKey"in i),
                md("altKey"in i),
                !(i.ctrlKey || i.metaKey || i.shiftKey || i.altKey)
            }
            if (pd.fO(t))
                return !(pd.OF.PF(pd.kE.oSi) || pd.OF.PF(pd.kE.CF) || pd.OF.PF(pd.kE.OZ) || pd.OF.PF(pd.kE.w$e));
            throw new Error("unexpected argument")
        }
        static Mze(t) {
            return md(!pd.kE.g$e(t), "should not be virtual key code"),
            !((t = Math.floor(t)) < 0 || t >= wd.length) && wd[t]
        }
    }
    ,
    window.addEventListener("keydown", pd.OF.FP),
    window.addEventListener("keyup", pd.OF.Pz),
    window.addEventListener("blur", pd.OF.xze),
    window.addEventListener("external-keydown", pd.OF.FP),
    window.addEventListener("external-keyup", pd.OF.Pz)
}
{
    const gd = self.t;
    let yd = new Set;
    gd.m1 = class {
        constructor() {
            throw new TypeError("static class")
        }
        static w1(t) {
            if (gd.Ge(t),
            yd.has(t))
                throw new Error("pointer already captured");
            yd.add(t)
        }
        static he(t) {
            if (gd.Ge(t),
            !yd.has(t))
                throw new Error("pointer not captured");
            yd.delete(t)
        }
        static Cze(t) {
            return gd.Ge(t),
            yd.has(t)
        }
    }
}
{
    const bd = self.t
      , vd = 12
      , Sd = 16
      , xd = 35
      , Md = "undefined" != typeof requestIdleCallback;
    let Ed = []
      , Cd = -1
      , _d = 0;
    function Td(t) {
        Cd = Md && 0 === _d ? requestIdleCallback(Id, {
            timeout: xd
        }) : setTimeout(Id, _d > 0 ? 1 : t)
    }
    function Id(t) {
        if (Cd = -1,
        !Ed.length)
            return;
        let i = performance.now()
          , e = i
          , s = 0
          , n = 0;
        do {
            Pd(Ed.shift()),
            e = performance.now(),
            ++s,
            n = (e - i) / s * 1.1
        } while (Ed.length && (Md && 0 === _d && void 0 !== t ? n < t.timeRemaining() : e - i + n < vd));
        if (-1 === Cd && Ed.length) {
            let t = e - i;
            Td(Math.max(Sd - t, 4))
        }
    }
    function Pd(t) {
        let i;
        try {
            i = t.gze()
        } catch (i) {
            return void t.reject(i)
        }
        t.resolve(i)
    }
    let Gd = bd.M9s.lVs("disable-asyncify");
    Gd && (() => {})("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."),
    bd._Ct = function(t) {
        let i = null;
        return bd.Vl && (i = bd.zRe()),
        new Promise( (e, s) => {
            Ed.push({
                gze: t,
                resolve: e,
                reject: s,
                stack: i
            }),
            Gd ? Pd(Ed.pop()) : -1 === Cd && Td(Sd)
        }
        )
    }
    ,
    bd._Ct.CCt = function(t) {
        if (t)
            ++_d;
        else if (--_d,
        _d < 0)
            throw new Error("already turned off high throughput mode")
    }
}
{
    const Ad = self.t;
    let Rd = null
      , kd = !1;
    function Od() {
        Rd && (kd = !Rd.charging)
    }
    navigator.getBattery && navigator.getBattery().then(t => {
        Rd = t,
        Od(),
        t.addEventListener("chargingchange", Od)
    }
    ),
    Ad._ze = class {
        constructor() {
            throw new Error("static class")
        }
        static Tze() {
            return kd
        }
    }
}
{
    const Dd = self.t;
    Dd.jh = class t {
        constructor(t) {
            Dd.X_t(t),
            this.Ize = !1,
            this.Pze = t
        }
        Vh() {
            this.Ize || (this.Ize = !0,
            this.Pze && (this.Pze(),
            this.Pze = null))
        }
        Gze() {
            return this.Ize
        }
        he() {
            this.Vh()
        }
        static he(i) {
            return new t( () => i.he())
        }
        static Gh(t, i, e, s, n) {
            if ("string" != typeof i && !Array.isArray(i))
                throw new TypeError("expected string or array");
            if (Dd.qd(e),
            null == s)
                s = !1;
            else if ("boolean" != typeof s && "object" != typeof s)
                throw new TypeError("invalid event listener options");
            if (n && (e = e.bind(n)),
            Array.isArray(i) || i.includes(" ")) {
                "string" == typeof i && (i = i.split(" "));
                const n = new Dd.kh;
                for (const r of i)
                    Dd.zt(r),
                    t.addEventListener(r, e, s),
                    n.cR(Dd.v(Dd.jh, () => t.removeEventListener(r, e, s)));
                return n
            }
            return t.addEventListener(i, e, s),
            Dd.v(Dd.jh, () => t.removeEventListener(i, e, s))
        }
    }
    ,
    Dd.Cye = class extends Dd.jh {
        Aze(t) {
            Dd.qd(t),
            this.Pze = t
        }
    }
    ,
    Dd.kh = class extends Dd.jh {
        constructor(...t) {
            super(),
            this.yh = new Set;
            for (let i of t)
                this.cR(i)
        }
        cR(...t) {
            if (Dd.YJ(t, Dd.jh),
            this.Ize)
                throw new Error("already disposed");
            for (let i of t)
                this.yh.add(i)
        }
        bx(t) {
            if (Dd.U(t, Dd.jh),
            this.Ize)
                throw new Error("already disposed");
            this.yh.delete(t)
        }
        Tht() {
            if (this.Ize)
                throw new Error("already disposed");
            if (this.yh) {
                for (let t of this.yh)
                    t.Vh();
                this.yh.clear()
            }
        }
        Gze() {
            return this.Ize
        }
        Vh() {
            if (this.Ize)
                throw new Error("already disposed");
            this.Ize = !0;
            for (let t of this.yh)
                t.Vh();
            this.yh.clear(),
            this.yh = null
        }
        he() {
            this.Vh()
        }
    }
}
{
    const Fd = Symbol("OK")
      , Ld = Symbol("ERR");
    class Bd {
        constructor(t, i) {
            if (t !== Fd && t !== Ld)
                throw new Error("Invalid result type");
            this.lVt = t,
            this.LIs = i
        }
        Rze() {
            return this.lVt === Fd
        }
        kze() {
            return this.lVt === Ld
        }
        Oze() {
            if (this.kze())
                throw new Error(this.LIs);
            return this.LIs
        }
        Dze() {
            if (this.Rze())
                throw new Error(this.LIs);
            return this.LIs
        }
        static Fze(t) {
            const i = t.filter(t => t.kze());
            return 0 === i.length ? Bd.Ok(t.map(t => t.LIs)) : Bd.Lze(i.map(t => t.LIs))
        }
        static Bze(t, i) {
            return t ? Bd.Ok(t) : Bd.Lze(i)
        }
        static Ok(t) {
            return new Bd(Fd,t)
        }
        static Lze(t) {
            return new Bd(Ld,t)
        }
    }
    self.Uze = Bd
}
{
    const Ud = self.t
      , Nd = 1e3
      , jd = 100;
    let $d = -1;
    function zd() {
        $d = -1
    }
    Ud.Nze = function() {
        return -1 === $d && ($d = Date.now(),
        self.setTimeout(zd, 16)),
        $d
    }
    ;
    let Vd = -1
      , Wd = -1
      , Hd = new Set;
    function Kd() {
        Vd = -1,
        Wd = -1;
        let t = Date.now();
        for (let i of Hd)
            if (i.jze(t)) {
                let t = i.$ze();
                (-1 === Wd || t < Wd) && (Wd = t)
            } else
                Hd.delete(i);
        if (-1 !== Wd) {
            let i = Math.max(Wd - t + jd, Nd);
            Vd = self.setTimeout(Kd, i)
        }
    }
    Ud.oG = class {
        constructor(t, i) {
            Ud.qd(t),
            Ud.Ge(i),
            this.d5s = t,
            this.op = 1e3 * i,
            this.zze = 0,
            this.Vd = !1
        }
        Bg() {
            let t = Ud.Nze();
            this.zze = t + this.op,
            this.Vd || (Hd.add(this),
            this.Vd = !0),
            -1 === Vd ? (Wd = this.zze,
            Vd = self.setTimeout(Kd, this.op + jd)) : this.zze < Wd && Wd > t + Nd && (self.clearTimeout(Vd),
            Wd = this.zze,
            Vd = self.setTimeout(Kd, this.op + jd))
        }
        jze(t) {
            return !(t >= this.zze) || (this.d5s() ? (this.zze = t + this.op,
            !0) : (this.Vd = !1,
            !1))
        }
        $ze() {
            return this.zze
        }
        cu() {
            this.Vd && (Hd.delete(this),
            this.Vd = !1,
            0 === Hd.size && -1 !== Vd && (self.clearTimeout(Vd),
            Vd = -1,
            Wd = -1))
        }
        he() {
            this.cu(),
            this.d5s = null
        }
    }
}
{
    const qd = self.t;
    let Xd = new Map
      , Yd = 0
      , Jd = -1;
    function Zd() {
        Jd = -1;
        let t = performance.now() - Yd;
        for (let i of Xd.values())
            i.frameCount++,
            i.Vze.push(t);
        Xd.size > 0 && Qd()
    }
    function Qd() {
        -1 === Jd && (Jd = requestAnimationFrame(Zd),
        Yd = performance.now())
    }
    qd.Wze = class {
        constructor(t) {
            if (qd.zt(t),
            Xd.has(t))
                throw new Error("label in use");
            this.dat = t,
            Xd.set(t, {
                startTime: performance.now(),
                frameCount: 0,
                Vze: []
            }),
            Qd()
        }
        B$e() {
            let t = Xd.get(this.dat);
            Xd.delete(this.dat);
            let i = performance.now() - t.startTime
              , e = -1
              , s = -1;
            for (let i of t.Vze)
                i > e && (e = i);
            if (t.Vze.length >= 3) {
                t.Vze.pop(),
                t.Vze.shift();
                for (let i of t.Vze)
                    i > s && (s = i)
            }
            console.log(`[JankMeasurement] '${this.dat}' ended. Duration: ${Math.round(10 * i) / 10} ms, frame count: ${t.frameCount}, max dt: ${Math.round(10 * e) / 10}ms, max dt exclusive: ${Math.round(10 * s) / 10}ms`)
        }
    }
}
{
    const tf = self.t
      , ef = 1
      , sf = 2
      , nf = 4
      , rf = 8
      , hf = 16
      , of = 32;
    let af = null
      , lf = new Map;
    function uf() {
        return af
    }
    function cf(t, i, e, s) {
        let n = new tf.MimeType(t,i,e,s);
        lf.set(t, n)
    }
    tf.MimeType = class {
        constructor(t, i, e, s) {
            if (tf.zt(t),
            tf.Kq(e),
            tf.cO(s),
            !t)
                throw new Error("invalid MIME type");
            if (this.Hze = t,
            this.Kze = t.split("/")[0],
            this.qze = [],
            this.Xze = e || t,
            this.Yze = !1,
            this.Jze = !1,
            this.Zze = !1,
            this.Qze = !1,
            this.tVe = !1,
            this.iVe = !1,
            "string" == typeof i)
                this.qze.push(i);
            else {
                if (!Array.isArray(i))
                    throw new TypeError("expected string or array");
                this.qze = i
            }
            "number" == typeof s && (this.Yze = !!(s & ef),
            this.Jze = !!(s & sf),
            this.Zze = !!(s & nf),
            this.Qze = !!(s & rf),
            this.tVe = !!(s & hf),
            this.iVe = !!(s & of))
        }
        uL() {
            return this.Hze
        }
        Ags() {
            return this.Kze
        }
        Pgs() {
            return this.qze
        }
        aAs() {
            return this.Xze
        }
        S3t() {
            return this.Yze
        }
        WU() {
            return this.Jze || "text" === this.Ags()
        }
        MLe() {
            return this.Qze
        }
        UH() {
            return this.Zze
        }
        vle() {
            return "text/html" === this.Hze
        }
        xle() {
            return "text/css" === this.Hze
        }
        _3t() {
            return "image/svg+xml" === this.Hze
        }
        x3t() {
            return "text/csv" === this.Hze || "text/tab-separated-values" === this.Hze
        }
        A3t() {
            return "text/xml" === this.Hze
        }
        mL() {
            return "application/json" === this.Hze
        }
        O3t() {
            return "application/pdf" === this.Hze
        }
        nL() {
            return "application/javascript" === this.Hze || "text/javascript" === this.Hze
        }
        iL() {
            return "application/typescript" === this.Hze || "text/typescript" === this.Hze
        }
        bLe() {
            return this.tVe
        }
        eVe() {
            this.iVe
        }
        static $s(t) {
            return tf.zt(t),
            lf.get(t) || uf()
        }
        static NAs(t) {
            tf.U(t, Blob);
            const i = t.name ? tf.Uh(t.name).slice(1) : ""
              , e = t.type;
            if (!i)
                return e ? tf.MimeType.$s(e) : uf();
            if (!e)
                return tf.MimeType.H3t(i);
            for (let t of lf.values())
                if (t.uL() === e)
                    for (let e of t.Pgs())
                        if (e === i)
                            return t;
            return tf.MimeType.H3t(i)
        }
        static j0t(t) {
            return tf.MimeType.H3t(t).uL()
        }
        static H3t(t, i) {
            tf.zt(t),
            tf.Kq(i),
            t.length && "." === t[0] && (t = t.substr(1)),
            t = t.toLowerCase();
            const e = [];
            for (const i of lf.values())
                for (const s of i.Pgs())
                    s === t && e.push(i);
            if (!e.length)
                return uf();
            if (1 === e.length || !i)
                return e[0];
            for (const t of e)
                if (t.uL().toLowerCase().includes(i.toLowerCase()))
                    return t;
            return e[0]
        }
        static gLe(t, i) {
            return tf.e0t(t),
            tf.Kq(i),
            t.type && tf.doe(t.type) ? t.type.split(";")[0].trim() : tf.MimeType.H3t(tf.Uh(t.name), i).uL()
        }
    }
    ,
    af = new tf.MimeType("application/octet-stream",[],"Binary"),
    cf("text/html", ["html", "htm"], "HTML", hf),
    cf("application/javascript", "js", "JavaScript", sf),
    cf("text/javascript", "js", "JavaScript", sf),
    cf("application/typescript", "ts", "TypeScript", sf),
    cf("text/typescript", "ts", "TypeScript", sf),
    cf("text/css", "css", "CSS", hf),
    cf("application/json", ["json", "scon"], "JSON", sf | hf),
    cf("text/xml", ["xml", "scml"], "XML", hf),
    cf("text/csv", "csv", "CSV", hf),
    cf("text/tab-separated-values", "tsv", "Tab-separated values", hf),
    cf("text/plain", "txt", "Text", hf),
    cf("text/markdown", "md", "Markdown", hf),
    cf("text/x-ini", "ini", "INI configuration file", hf),
    cf("image/png", "png", "PNG", ef | rf),
    cf("image/apng", "apng", "APNG", ef | rf),
    cf("image/jpeg", ["jpg", "jpeg"], "JPEG", ef),
    cf("image/jxl", "jxl", "JPEG XL", ef),
    cf("image/svg+xml", "svg", "SVG", sf | hf),
    cf("image/webp", "webp", "WebP", ef | rf),
    cf("image/gif", "gif", "GIF", ef | rf),
    cf("image/tiff", ["tif", "tiff"], "TIFF"),
    cf("image/bmp", "bmp", "Bitmap"),
    cf("image/x-icon", "ico", "Icon"),
    cf("image/avif", ["avif", "avifs"], "AVIF", ef | rf),
    cf("audio/ogg; codecs=opus", "opus", "Ogg Opus", ef),
    cf("audio/ogg; codecs=vorbis", "ogg", "Ogg Vorbis", ef),
    cf("audio/webm; codecs=opus", "webm", "WebM Opus", ef),
    cf("audio/mp4", "m4a", "MPEG-4 AAC", ef),
    cf("audio/wav", "wav", "WAV"),
    cf("audio/flac", "flac", "FLAC", ef),
    cf("audio/mpeg", "mp3", "MP3", ef),
    cf("audio/midi", ["mid", "midi", "kar"], "MIDI"),
    cf("video/webm", "webm", "WebM", ef),
    cf("video/ogg", "ogv", "Ogg video", ef),
    cf("video/mp4", "mp4", "MPEG-4 video", ef),
    cf("video/mpeg", ["mpg", "mpeg"], "MPEG video", ef),
    cf("video/quicktime", ["mov", "qt"], "Quicktime movie", ef),
    cf("video/avi", "avi", "AVI"),
    cf("application/font-woff", "woff", "Web font", nf | ef),
    cf("font/woff2", "woff2", "Web font", nf | ef),
    cf("application/font-sfnt", ["ttf", "otf"], "TrueType/OpenType font", nf),
    cf("application/vnd.ms-fontobject", "eot", "Embedded OpenType", nf),
    cf("application/pdf", "pdf", "PDF", hf),
    cf("application/zip", ["zip", "c3p", "capx"], "ZIP", ef | hf),
    cf("application/wasm", "wasm", "WebAssembly", hf),
    cf("application/wast", "wast", "WebAssembly Text format", sf | hf),
    cf("application/octet-stream", "mem", "asm.js memory", hf),
    cf("application/x-construct3-addon", "c3addon", "Construct addon", ef | of),
    cf("application/x-construct2-addon", "c2addon", "Construct 2 addon", ef | of)
}
{
    const df = self.t;
    df.j1t = class {
        constructor(t=df.hardwareConcurrency) {
            df.Ge(t),
            this.sVe = t,
            this.nVe = [],
            this.rVe = 0
        }
        cR(t, i) {
            return df.qd(t),
            new Promise( (e, s) => {
                const n = {
                    gze: t,
                    resolve: e,
                    reject: s,
                    hVe: i
                };
                i?.signal && i.signal.aborted ? s(new Error("abort")) : (i?.signal && (n.onabort = () => {
                    const t = this.nVe.indexOf(n);
                    -1 !== t && (this.nVe.splice(t, 1),
                    s(new Error("abort")))
                }
                ,
                i.signal.addEventListener("abort", n.onabort)),
                this.nVe.push(n),
                this.oVe())
            }
            )
        }
        aVe(t) {
            df.qd(t);
            for (let i = 0, e = this.nVe.length; i < e; ++i)
                if (this.nVe[i].gze === t)
                    return i;
            return -1
        }
        lVe(t, i) {
            df.qd(t);
            const e = this.aVe(t);
            if (-1 === e)
                throw new Error("cannot find promise to resolve");
            this.nVe[e].resolve(i),
            this.nVe.splice(e, 1)
        }
        uVe(t, i) {
            df.qd(t);
            const e = this.aVe(t);
            if (-1 === e)
                throw new Error("cannot find promise to reject");
            this.nVe[e].reject(i),
            this.nVe.splice(e, 1)
        }
        async oVe() {
            if (!this.nVe.length)
                return;
            if (this.rVe >= this.sVe)
                return;
            this.rVe++;
            const t = this.nVe.shift();
            t.hVe?.signal && t.onabort && t.hVe.signal.removeEventListener("abort", t.onabort);
            try {
                const i = await t.gze();
                t.resolve(i)
            } catch (i) {
                t.reject(i)
            }
            this.rVe--,
            this.oVe()
        }
    }
}
{
    const ff = self.t;
    ff.gP = class {
        constructor(t, i, e) {
            ff.qd(t),
            ff.Ge(i),
            ff.cO(e),
            this.d5s = t,
            this.cVe = i,
            this.dVe = e || 2 * i,
            this.fVe = -1,
            this.pVe = -1 / 0,
            this.mVe = () => this.wVe(),
            this.gVe = !1,
            this.yVe = !1,
            this.bVe = null
        }
        lW(t) {
            this.yVe = !!t
        }
        vVe() {
            return void 0 !== ff._ze && ff._ze.Tze() ? this.dVe : this.cVe
        }
        IF(...t) {
            if (-1 !== this.fVe)
                return;
            this.bVe = t;
            let i = ff.Nze()
              , e = i - this.pVe
              , s = this.vVe();
            e >= s && this.yVe ? (this.pVe = i,
            this.SVe()) : this.fVe = self.setTimeout(this.mVe, Math.max(s - e, 4))
        }
        SVe() {
            this.gVe = !0;
            const t = this.bVe;
            this.bVe = null,
            t ? this.d5s(...t) : this.d5s(),
            this.gVe = !1
        }
        Bg() {
            this.gVe || (this.xVe(),
            this.bVe = null,
            this.pVe = ff.Nze())
        }
        wVe() {
            this.fVe = -1,
            this.pVe = ff.Nze(),
            this.SVe()
        }
        xVe() {
            -1 !== this.fVe && (self.clearTimeout(this.fVe),
            this.fVe = -1)
        }
        he() {
            this.xVe(),
            this.d5s = null,
            this.bVe = null,
            this.mVe = null
        }
    }
}
{
    const pf = self.t;
    pf.oT = {},
    pf.oT.Document = class {
        constructor() {
            this.Xbi = null,
            this.E2t = null
        }
        static wLt(t) {
            return pf.zt(t),
            (new pf.oT.Document).MVe(t)
        }
        static jRt(t) {
            return new Promise( (i, e) => {
                let s = new FileReader;
                s.onload = t => pf.oT.Document.wLt(t.target.result).then(i),
                s.readAsText(t)
            }
            )
        }
        MVe(t, i) {
            return pf.zt(t),
            pf.Kq(i),
            pf._Ct( () => {
                const e = new DOMParser;
                return this.Xbi = e.parseFromString(t, i || "text/xml"),
                this.E2t = new pf.oT.Element(this.Xbi.documentElement,this.Xbi),
                this
            }
            )
        }
        PH() {
            return this.Xbi
        }
        mT() {
            return this.E2t
        }
        gLt() {
            return new Blob([this.EVe(!0)],{
                type: "text/xml"
            })
        }
        Wbe() {
            return (new XMLSerializer).serializeToString(this.Xbi)
        }
        EVe(t) {
            t = !!t;
            let i = ""
              , e = 0
              , s = this.Wbe().replace(/(>)(<)(\/*)/g, "$1\r\n$2$3");
            for (let t of s.split("\r\n")) {
                let s = 0;
                t.match(/.+<\/\w[^>]*>$/) ? s = 0 : t.match(/^<\/\w/) ? 0 !== e && (e -= 1) : s = t.match(/^<\w[^>]*[^\/]>.*$/) ? 1 : 0;
                let n = "";
                for (let t = 0; t < e; t++)
                    n += "\t";
                i += n + t + "\r\n",
                e += s
            }
            if (t) {
                let t = '<?xml version="1.0" encoding="utf-8" ?>\n';
                t += i
            }
            return i
        }
        A6s(t, i, e) {
            if (pf.zlt(t),
            pf.zlt(i),
            e || (e = this.Xbi),
            this.Bus(e, i))
                e.replaceChild(t, i),
                this.E2t.CVe(),
                this.E2t._Ve();
            else
                for (const s of e.children)
                    this.A6s(t, i, s)
        }
        Bus(t, i) {
            pf.zlt(i);
            for (const e of t.children)
                if (e === i)
                    return !0;
            return !1
        }
    }
    ,
    pf.oT.Element = class {
        constructor(t, i) {
            this.Get = t,
            this.TVe = null,
            this.Xbi = i
        }
        Kbe() {
            return this.Get
        }
        CVe() {
            this.TVe = null
        }
        _Ve() {
            if (!this.TVe) {
                this.TVe = new Map;
                for (let t = 0, i = this.Get.children.length; t < i; ++t)
                    this.IVe(this.Get.children[t])
            }
        }
        IVe(t) {
            self.assert(this.TVe, "missing child cache");
            let i = t.tagName.toLowerCase()
              , e = this.TVe.get(i);
            e ? -1 === e.indexOf(t) && e.push(t) : this.TVe.set(i, [t])
        }
        Kas() {
            return this.Get.tagName
        }
        *children(t) {
            if (pf.Kq(t),
            t) {
                this._Ve();
                let i = this.TVe.get(t.toLowerCase());
                if (!i)
                    return;
                for (let t = 0, e = i.length; t < e; ++t)
                    yield new pf.oT.Element(i[t],this.Xbi)
            } else
                for (let t of this.Get.children)
                    yield new pf.oT.Element(t,this.Xbi)
        }
        pa(t) {
            pf.zt(t),
            this.Get.textContent = t
        }
        VB(t) {
            return pf.Kq(t),
            t ? this.gT(t).VB() : this.Get.textContent
        }
        eoi(t, i) {
            pf.zt(t),
            pf.Kq(i);
            let e = this.Xas(t);
            return e ? e.VB() : i || ""
        }
        qCs(t) {
            return pf.Kq(t),
            t ? this.gT(t).qCs() : parseInt(this.VB(), 10)
        }
        Jzs(t, i) {
            pf.zt(t),
            pf.cO(i);
            let e = this.Xas(t);
            return e ? e.qCs() : Math.floor(i || 0)
        }
        KCs(t) {
            return pf.Kq(t),
            t ? this.gT(t).KCs() : parseFloat(this.VB())
        }
        XCs(t, i) {
            pf.zt(t),
            pf.U6(i);
            let e = this.Xas(t);
            return e ? e.KCs() : i || 0
        }
        Bzs(t) {
            if (pf.Kq(t),
            t)
                return this.gT(t).Bzs();
            {
                let t = this.VB().toLowerCase();
                return !("false" === t || "no" === t || "0" === t)
            }
        }
        aHs(t, i) {
            pf.zt(t);
            let e = this.Xas(t);
            return e ? e.Bzs() : !!i
        }
        oas(t) {
            return pf.zt(t),
            this.Get.hasAttribute(t)
        }
        mLt(t, i) {
            return pf.zt(t),
            pf.zt(i),
            this.Get.setAttribute(t, i)
        }
        VRt(t) {
            return pf.zt(t),
            this.Get.getAttribute(t) || ""
        }
        fT(t) {
            return pf.zt(t),
            parseInt(this.VRt(t), 10)
        }
        aas(t) {
            return pf.zt(t),
            parseFloat(this.VRt(t))
        }
        ips(t) {
            pf.zt(t);
            let i = this.VRt(t).toLowerCase();
            return !("false" === i || "no" === i || "0" === i || "" === i)
        }
        hN(t) {
            pf.zt(t);
            let i = this.Xbi.createElement(t);
            return this.Get.appendChild(i),
            this.TVe ? this.IVe(i) : this._Ve(),
            this.gT(t)
        }
        gT(t) {
            pf.zt(t),
            this._Ve();
            let i = this.TVe.get(t.toLowerCase());
            if (!i || !i.length)
                throw new Error(`expected a child with tag name '${t}'`);
            if (i.length > 1)
                throw new Error(`expected only one child with tag name '${t}'`);
            return new pf.oT.Element(i[0],this.Xbi)
        }
        Xas(t) {
            pf.zt(t),
            this._Ve();
            let i = this.TVe.get(t.toLowerCase());
            return i && 1 === i.length ? new pf.oT.Element(i[0],this.Xbi) : null
        }
        Bus(t) {
            pf.zt(t),
            this._Ve();
            let i = this.TVe.get(t.toLowerCase());
            return i && 1 === i.length
        }
    }
}
{
    const mf = self.t;
    let wf = class {
        constructor(t, i, e, s) {
            if (mf.zt(t),
            mf.Ge(i),
            !mf.Go(e) && !mf.GH(e, ArrayBuffer))
                throw new Error("unsupported data");
            this.PVe = t,
            this.GVe = i,
            this.Wjt = e,
            this.AVe = !!s
        }
        RVe() {
            return this.PVe
        }
        kVe() {
            return this.GVe
        }
        SFt() {
            return this.Wjt
        }
        OVe() {
            return this.AVe
        }
    }
    ;
    mf.DataView = class {
        constructor(t) {
            mf.Mw(t, ArrayBuffer),
            this.DVe = null,
            this.FVe = [],
            t && (this.DVe = new DataView(t)),
            this.LVe = 0,
            this.BVe = 0
        }
        gLt() {
            return new Blob([this.UVe()])
        }
        NVe() {
            if (!this.DVe)
                throw new Error("missing DataView");
            return this.DVe
        }
        UVe() {
            if (!this.DVe)
                throw new Error("missing DataView");
            return this.DVe.buffer
        }
        jVe() {
            this.BVe = 0
        }
        he() {
            this.DVe = null,
            this.FVe = null
        }
        W2i() {
            if (this.DVe)
                throw new Error("data already commited");
            let t = 0;
            for (let i of this.FVe)
                t += i.kVe();
            this.DVe = new DataView(new ArrayBuffer(t));
            for (let t of this.FVe) {
                switch (t.RVe()) {
                case "setInt8":
                    this.DVe.setInt8(this.LVe, t.SFt());
                    break;
                case "setUint8":
                    this.DVe.setUint8(this.LVe, t.SFt());
                    break;
                case "setInt16":
                    this.DVe.setInt16(this.LVe, t.SFt(), t.OVe());
                    break;
                case "setUint16":
                    this.DVe.setUint16(this.LVe, t.SFt(), t.OVe());
                    break;
                case "setInt32":
                    this.DVe.setInt32(this.LVe, t.SFt(), t.OVe());
                    break;
                case "setUint32":
                    this.DVe.setUint32(this.LVe, t.SFt(), t.OVe());
                    break;
                case "setFloat32":
                    this.DVe.setFloat32(this.LVe, t.SFt(), t.OVe());
                    break;
                case "setFloat64":
                    this.DVe.setFloat64(this.LVe, t.SFt(), t.OVe());
                    break;
                case "setArrayBuffer":
                    let i = new Uint8Array(this.DVe.buffer)
                      , e = new Uint8Array(t.SFt());
                    i.set(e, this.LVe),
                    this.DVe = new DataView(i.buffer)
                }
                this.LVe += t.kVe()
            }
            this.FVe = null
        }
        JRt(t) {
            let i = this.p3i("raw");
            return t || (t = {}),
            t.type || (t.type = "application/octet-stream"),
            new Blob([i],t)
        }
        H2i(t) {
            mf.U(t, ArrayBuffer),
            this.i4i(t.byteLength),
            this.FVe.push(new wf("setArrayBuffer",t.byteLength,t))
        }
        p3i(t) {
            switch (mf.zt(t),
            t) {
            case "int8":
                return this.$Ve();
            case "uint8":
                return this.zVe();
            case "clampedUint8":
                return this.VVe();
            case "int16":
                return this.WVe();
            case "uint16":
                return this.HVe();
            case "int32":
                return this.i5i();
            case "uint32":
                return this.KVe();
            case "float32":
                return this.qVe();
            case "float64":
                return this.f5i();
            case "raw":
                return this.zVe().buffer;
            default:
                throw new Error("unsupported return type. supported types are 'int8, uint8, clampedUint8, int16, uint16, int32, uint32, float32, float64, raw'")
            }
        }
        XVe(t, i) {
            this.c4i(JSON.stringify(t))
        }
        YVe(t) {
            return JSON.parse(this.u4i(t))
        }
        c4i(t, i) {
            mf.zt(t);
            let e = Array.prototype.map.call(t, (i, e) => t.charCodeAt(e));
            this.JVe(e, i)
        }
        u4i(t) {
            return Array.prototype.map.call(this.HVe(t), t => String.fromCharCode(t)).join("")
        }
        z2i(t) {
            this.e4i(t ? 1 : 0)
        }
        K2i() {
            return !!this.r4i()
        }
        j3i(t) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setInt8",Int8Array.BYTES_PER_ELEMENT,t))
        }
        e4i(t) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setUint8",Uint8Array.BYTES_PER_ELEMENT,t))
        }
        b5i(t, i) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setInt16",Int16Array.BYTES_PER_ELEMENT,t,!!i))
        }
        q2i(t, i) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setUint16",Uint16Array.BYTES_PER_ELEMENT,t,!!i))
        }
        L5i(t, i) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setInt32",Int32Array.BYTES_PER_ELEMENT,t,!!i))
        }
        i4i(t, i) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setUint32",Uint32Array.BYTES_PER_ELEMENT,t,!!i))
        }
        Z2i(t, i) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setFloat32",Float32Array.BYTES_PER_ELEMENT,t,!!i))
        }
        ZVe(t, i) {
            if (this.DVe)
                throw new Error("data already commited");
            this.FVe.push(new wf("setFloat64",Float64Array.BYTES_PER_ELEMENT,t,!!i))
        }
        QVe(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setInt8")
        }
        iWe(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setUint8")
        }
        eWe(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setInt16", !!i)
        }
        JVe(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setUint16", !!i)
        }
        Q2i(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setInt32", !!i)
        }
        sWe(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setUint32", !!i)
        }
        nWe(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setFloat32", !!i)
        }
        u5i(t, i) {
            this.i4i(t.length, !!i),
            this.tWe(t, "setFloat64", !!i)
        }
        R3i() {
            let t = this.DVe.getInt8(this.BVe);
            return this.BVe += Int8Array.BYTES_PER_ELEMENT,
            t
        }
        r4i() {
            let t = this.DVe.getUint8(this.BVe);
            return this.BVe += Uint8Array.BYTES_PER_ELEMENT,
            t
        }
        S5i(t) {
            let i = this.DVe.getInt16(this.BVe, !!t);
            return this.BVe += Int16Array.BYTES_PER_ELEMENT,
            i
        }
        t5i(t) {
            let i = this.DVe.getUint16(this.BVe, !!t);
            return this.BVe += Uint16Array.BYTES_PER_ELEMENT,
            i
        }
        B5i(t) {
            let i = this.DVe.getInt32(this.BVe, !!t);
            return this.BVe += Int32Array.BYTES_PER_ELEMENT,
            i
        }
        n4i(t) {
            let i = this.DVe.getUint32(this.BVe, !!t);
            return this.BVe += Uint32Array.BYTES_PER_ELEMENT,
            i
        }
        s5i(t) {
            let i = this.DVe.getFloat32(this.BVe, !!t);
            return this.BVe += Float32Array.BYTES_PER_ELEMENT,
            i
        }
        rWe(t) {
            let i = this.DVe.getFloat64(this.BVe, !!t);
            return this.BVe += Float64Array.BYTES_PER_ELEMENT,
            i
        }
        $Ve(t) {
            return this.hWe(this.n4i(!!t), "getInt8", Int8Array)
        }
        zVe(t) {
            return this.hWe(this.n4i(!!t), "getUint8", Uint8Array)
        }
        VVe(t) {
            return this.hWe(this.n4i(!!t), "getUint8", Uint8ClampedArray)
        }
        WVe(t) {
            return this.hWe(this.n4i(!!t), "getInt16", Int16Array, !!t)
        }
        HVe(t) {
            return this.hWe(this.n4i(!!t), "getUint16", Uint16Array, !!t)
        }
        i5i(t) {
            return this.hWe(this.n4i(!!t), "getInt32", Int32Array, !!t)
        }
        KVe(t) {
            return this.hWe(this.n4i(!!t), "getUint32", Uint32Array, !!t)
        }
        qVe(t) {
            return this.hWe(this.n4i(!!t), "getFloat32", Float32Array, !!t)
        }
        f5i(t) {
            return this.hWe(this.n4i(!!t), "getFloat64", Float64Array, !!t)
        }
        tWe(t, i, e) {
            let s = t.length;
            for (let n = 0; n < s; n++)
                "setInt8" !== i ? "setUint8" !== i ? "setInt16" !== i ? "setUint16" !== i ? "setInt32" !== i ? "setUint32" !== i ? "setFloat32" !== i ? "setFloat64" !== i || this.FVe.push(new wf(i,Float64Array.BYTES_PER_ELEMENT,t[n],e)) : this.FVe.push(new wf(i,Float32Array.BYTES_PER_ELEMENT,t[n],e)) : this.FVe.push(new wf(i,Uint32Array.BYTES_PER_ELEMENT,t[n],e)) : this.FVe.push(new wf(i,Int32Array.BYTES_PER_ELEMENT,t[n],e)) : this.FVe.push(new wf(i,Uint16Array.BYTES_PER_ELEMENT,t[n],e)) : this.FVe.push(new wf(i,Int16Array.BYTES_PER_ELEMENT,t[n],e)) : this.FVe.push(new wf(i,Uint8Array.BYTES_PER_ELEMENT,t[n],e)) : this.FVe.push(new wf(i,Int8Array.BYTES_PER_ELEMENT,t[n],e))
        }
        hWe(t, i, e, s) {
            let n = new e(t)
              , r = e.BYTES_PER_ELEMENT;
            for (let e = 0; e < t; e++)
                "getInt8" !== i ? "getUint8" !== i ? "getInt16" !== i ? "getUint16" !== i ? "getInt32" !== i ? "getUint32" !== i ? "getFloat32" !== i ? "getFloat64" !== i || (n[e] = this.DVe.getFloat64(this.BVe + e * r, s)) : n[e] = this.DVe.getFloat32(this.BVe + e * r, s) : n[e] = this.DVe.getUint32(this.BVe + e * r, s) : n[e] = this.DVe.getInt32(this.BVe + e * r, s) : n[e] = this.DVe.getUint16(this.BVe + e * r, s) : n[e] = this.DVe.getInt16(this.BVe + e * r, s) : n[e] = this.DVe.getUint8(this.BVe + e * r, s) : n[e] = this.DVe.getInt8(this.BVe + e * r, s);
            return this.BVe += t * r,
            n
        }
    }
}
{
    const gf = self.t
      , yf = 60;
    gf.$Ci = function(t, i, e) {
        if (gf.zlt(t, "input"),
        gf.X_t(i),
        "number" !== t.type && "text" !== t.type)
            throw new TypeError(`unable to bind drag scroller to input, unsupported type ${t.type}`);
        let s = null
          , n = null
          , r = null
          , h = 0
          , o = !1
          , a = gf.v(gf.kh)
          , l = null
          , u = null
          , c = null
          , d = null;
        const f = i => {
            if (!o)
                return;
            const s = parseFloat(t.value);
            if (!gf.Go(s))
                return;
            if (s !== r)
                return p();
            const a = Math.round(h - i.clientY)
              , l = t.min ? parseFloat(t.min) : -1 / 0
              , u = t.max ? parseFloat(t.max) : 1 / 0
              , c = t.step ? parseFloat(t.step) : 1;
            i.preventDefault();
            let f = a * c;
            f = e ? n - f : n + f,
            r = gf.Ne(f, l, u),
            t.value = r,
            t.select(),
            d.IF()
        }
          , p = () => {
            o = !1,
            n = null,
            h = 0,
            gf.qs.SH.CH(s),
            s = null,
            l && (l.Vh(),
            a.bx(l)),
            l = null,
            u && (u.Vh(),
            a.bx(u)),
            u = null,
            c && (c.Vh(),
            a.bx(c)),
            c = null
        }
          , m = e => {
            e.target !== t && e.preventDefault(),
            e.stopPropagation(),
            p();
            let s = new Event("change");
            t.dispatchEvent(s),
            i && i()
        }
          , w = t => {
            p()
        }
        ;
        return d = gf.v(gf.gP, () => {
            let i = new Event("input");
            t.dispatchEvent(i)
        }
        , yf),
        a.cR(gf.jh.Gh(t, "dragstart", i => {
            o || gf.Go(parseFloat(t.value)) && (i.preventDefault(),
            o = !0,
            h = i.clientY,
            n = parseFloat(t.value),
            r = n,
            s = gf.qs.SH.gH("ns-resize", t.ownerDocument, i.clientX, i.clientY),
            l = gf.jh.Gh(t.ownerDocument, "pointermove", f),
            u = gf.jh.Gh(t.ownerDocument, "pointerup", m),
            c = gf.jh.Gh(t.ownerDocument, "pointercancel", w),
            a.cR(l),
            a.cR(u),
            a.cR(c))
        }
        )),
        a.cR(gf.jh.Gh(t, "focus", () => t.select())),
        a.cR(gf.v(gf.jh, () => {
            t = null,
            i = null,
            l = null,
            u = null,
            c = null,
            a = null,
            gf.qs.SH.CH(s),
            s = null,
            d.he()
        }
        )),
        a
    }
}
{
    const bf = self.t
      , vf = {
        enabled: !0,
        oWe: !1
    };
    bf.aWe = class {
        constructor(t, i, e) {
            bf.qd(t),
            bf.Ge(i),
            bf.Wat(e),
            e = Object.assign({}, vf, e),
            this.fVe = -1,
            this.Uli = "stopped",
            this.ews = i,
            this.lWe = t,
            this.uWe = () => this.SVe(),
            this.cWe = !1,
            this.dWe = 0,
            this.fWe = 0,
            this.pWe = () => this.mWe(),
            this.wWe = !!e.oWe,
            e.enabled && this.ke()
        }
        he() {
            this.rjs(),
            this.lWe = null,
            this.uWe = null,
            this.pWe = null
        }
        gWe() {
            return "stopped" !== this.Uli
        }
        hOs() {
            return "paused" === this.Uli
        }
        yWe(t) {
            this.fVe = self.setTimeout(this.uWe, t),
            this.dWe = Date.now()
        }
        bWe() {
            -1 !== this.fVe && (self.clearTimeout(this.fVe),
            this.fVe = -1)
        }
        ke() {
            if (!this.gWe()) {
                if (this.wWe && (document.addEventListener("visibilitychange", this.pWe),
                "hidden" === document.visibilityState))
                    return this.Uli = "paused",
                    void (this.fWe = 0);
                this.Uli = "running",
                this.cWe || (this.fWe = 0,
                this.yWe(this.ews))
            }
        }
        rjs() {
            this.gWe() && (this.wWe && document.removeEventListener("visibilitychange", this.pWe),
            this.bWe(),
            this.Uli = "stopped")
        }
        ojs() {
            this.gWe() && !this.hOs() && (this.Uli = "paused",
            this.cWe ? this.fWe = 0 : (this.fWe += Date.now() - this.dWe,
            this.bWe()))
        }
        ajs() {
            this.gWe() && this.hOs() && (this.Uli = "running",
            this.cWe || this.yWe(bf.Ne(this.ews - this.fWe, 1, this.ews)))
        }
        async SVe() {
            this.fVe = -1,
            this.fWe = 0,
            this.cWe = !0,
            await this.lWe(),
            this.cWe = !1,
            "running" === this.Uli && this.yWe(this.ews)
        }
        Mws(t) {
            bf.Ge(t),
            this.ews !== t && (this.ews = t,
            "running" !== this.Uli || this.cWe || (this.rjs(),
            this.ke()))
        }
        mWe() {
            "hidden" === document.visibilityState ? this.ojs() : this.ajs()
        }
    }
}
{
    const Sf = self.t;
    Sf.Met = function(t, i, e, s=null) {
        Sf.zlt(t),
        Sf.zlt(i),
        Sf.qd(e);
        let n = null
          , r = null
          , h = null
          , o = null
          , a = null
          , l = null
          , u = e => function() {
            const e = i.getBoundingClientRect()
              , s = t.getBoundingClientRect();
            n.style.left = `${s.left - e.left + i.scrollLeft}px`,
            n.style.top = `${s.top - e.top + i.scrollTop}px`;
            const r = n.getBoundingClientRect();
            (r.bottom > e.bottom + 1 || r.top < e.top - 1) && p()
        }();
        function c() {
            if (n)
                return Promise.resolve("");
            const c = s && s.Iet ? s.Iet : "tree-edit-text";
            if (n = Sf.qs.lk("input", i, null, c),
            n.type = "text",
            n.setAttribute("spellcheck", "false"),
            s && s.position)
                n.style.left = `${s.position.x ?? 0}px`,
                n.style.top = `${s.position.y ?? 0}px`;
            else {
                const e = i.getBoundingClientRect()
                  , s = t.getBoundingClientRect()
                  , r = s.left - e.left
                  , h = s.top - e.top + i.scrollTop;
                n.type = "text",
                n.style.left = `${r}px`,
                n.style.top = `${h}px`,
                n.style.width = `${Math.max(s.right - s.left, 30)}px`,
                n.style.maxWidth = `${Math.max(s.right - s.left, 30)}px`,
                n.style.height = s.bottom - s.top + "px"
            }
            return o = t => d(),
            n.addEventListener("blur", o),
            a = i => function() {
                if (t.textContent = n.value,
                !s?.position) {
                    const i = t.getBoundingClientRect();
                    n.style.width = `${Math.max(i.right - i.left, 30)}px`
                }
                t.textContent = "."
            }(),
            n.addEventListener("input", a),
            l = t => function(t) {
                t.which === Sf.kE.w9 ? (t.preventDefault(),
                t.stopPropagation(),
                d()) : t.which === Sf.kE.IE && (t.preventDefault(),
                t.stopPropagation(),
                p())
            }(t),
            n.addEventListener("keydown", l, !0),
            i.addEventListener("scroll", u),
            n.value = e(),
            n.focus(),
            t.textContent = ".",
            new Promise( (t, i) => {
                r = t,
                h = i
            }
            )
        }
        function d() {
            if (!n)
                return;
            let t = n.value;
            f(t),
            r && r(t),
            r = null,
            h = null
        }
        function f(s=null) {
            n && (t.textContent = s || e(),
            i.removeEventListener("scroll", u, {
                passive: !0
            }),
            n.removeEventListener("keydown", l, !0),
            l = null,
            n.removeEventListener("input", a),
            a = null,
            n.removeEventListener("blur", o),
            o = null,
            Sf.qs.BW(n),
            n = null)
        }
        function p() {
            n && (f(),
            r && r(null),
            r = null,
            h = null)
        }
        return {
            Lht: () => c(),
            vWe: () => {
                d()
            }
            ,
            he: () => {
                f(),
                r = null,
                h = null
            }
        }
    }
}
{
    const xf = self.t;
    self.lang;
    xf.Kqt = function(t, i, e=null) {
        xf.zlt(t),
        xf._D(i),
        xf._U(e);
        let s = xf.qs.lk("div", t, null, "progressBarContainer")
          , n = xf.qs.lk("progress", s, null, "progressBarElement")
          , r = xf.qs.lk("div", s, null, "progressBarLabel");
        return r.textContent = e?.label ?? self.lang("common.loading-with-ellipsis"),
        {
            Cj: () => function() {
                for (const t of i)
                    t.style.opacity = "",
                    t.style.pointerEvents = "";
                s.style.display = "none",
                e?.SWe && e?.SWe()
            }(),
            Ej: () => function() {
                for (const t of i)
                    t.style.opacity = "0.2",
                    t.style.pointerEvents = "none";
                s.style.display = "",
                e?.xWe && e?.xWe()
            }(),
            Wqt: () => {
                t.appendChild(s)
            }
            ,
            he: () => (xf.qs.BW(r),
            r = null,
            xf.qs.BW(n),
            n = null,
            xf.qs.BW(s),
            void (s = null))
        }
    }
}
{
    const Mf = self.t
      , Ef = new Map;
    function Cf(t, i) {
        if (!Array.isArray(t))
            throw new TypeError("unexpected type");
        for (const e of t)
            Mf.Tke(e, i)
    }
    Mf.Sis = class {
        static MWe(t) {
            Mf.Tke(t, Element);
            const i = t.ownerDocument.createRange();
            return i.selectNodeContents(t),
            i
        }
        static Ais(t) {
            Mf.Tke(t, Element);
            const i = this.EWe(t)
              , e = this.MWe(t);
            return this.CWe(e, i),
            e
        }
        static WSe(t, i, e) {
            Mf.Tke(t, Element),
            Mf.Ge(i),
            Mf.Ge(e);
            const s = t.ownerDocument.createRange();
            let n = 0
              , r = null
              , h = !1;
            -1 == i && (i = 0),
            -1 == e && (e = 0);
            for (const o of this._We(t)) {
                const t = n;
                if (n += o.textContent.length,
                n > i && !1 === h && (s.setStart(o, i - t),
                h = !0),
                n >= e)
                    return i === e && !1 === h && (s.setStart(o, e - t),
                    h = !0),
                    s.setEnd(o, e - t),
                    s;
                r = o
            }
            if (r) {
                const t = r.length;
                s.setStart(r, t),
                s.setEnd(r, t)
            } else
                s.setStart(t, 0),
                s.setEnd(t, 0);
            return s
        }
        static Mis(t, i, e) {
            Mf.Tke(t, Element),
            Mf.Ge(i),
            Mf.Ge(e);
            const s = this.EWe(t)
              , n = this.WSe(t, i, e);
            return this.CWe(n, s),
            n
        }
        static CWe(t, i) {
            Mf.Tke(i, Window),
            Mf.Tke(t, Range);
            const e = i.getSelection();
            e.removeAllRanges(),
            e.addRange(t)
        }
        static Lst(t) {
            Mf.Tke(t, Window);
            t.getSelection().removeAllRanges()
        }
        static TWe(t, i) {
            Mf.Tke(i, Window),
            Mf.Tke(t, Range);
            i.getSelection().addRange(t)
        }
        static IWe(t, i) {
            Mf.Tke(i, Window),
            Mf.Tke(t, Range);
            i.getSelection().removeRange(t)
        }
        static PWe(t) {
            Mf.Tke(t, Window);
            return t.getSelection().rangeCount
        }
        static u1(t) {
            Mf.Tke(t, Window);
            const i = t.getSelection()
              , e = i.rangeCount > 0 && i.getRangeAt(0);
            return e && !1 === e.collapsed
        }
        static GWe(t) {
            Mf.Tke(t, Window);
            const i = t.getSelection();
            return 1 === i.rangeCount ? i.getRangeAt(0) : null
        }
        static $Se(t) {
            Mf.Tke(t, Window);
            const i = this.GWe(t);
            return i ? i.getBoundingClientRect() : null
        }
        static JSe(t) {
            Mf.Tke(t, Element);
            const i = this.EWe(t)
              , e = this.GWe(i);
            return e ? this.AWe(t, e) : null
        }
        static AWe(t, i) {
            Mf.Tke(t, Element),
            Mf.Tke(i, Range);
            const e = {
                start: -1,
                end: -1
            };
            let s = 0;
            for (const n of this.RWe(t)) {
                if (n === i.startContainer && (e.start = s + this.kWe(n, i.startOffset)),
                n === i.endContainer) {
                    e.end = s + this.kWe(n, i.endOffset);
                    break
                }
                if (n.nodeType === Node.TEXT_NODE) {
                    s += n.textContent.length
                }
            }
            return e
        }
        static OWe(t, i) {
            Mf.Tke(t, Element),
            Mf.Tke(i, Range);
            let e = i.commonAncestorContainer;
            do {
                if (t == e)
                    return !0
            } while (e = e.parentNode);
            return !1
        }
        static NSe(t) {
            Mf.Tke(t, Element);
            const i = this.EWe(t).getSelection()
              , e = i.rangeCount;
            if (0 === e)
                return null;
            const s = [];
            for (let n = 0; n < e; n++) {
                const e = i.getRangeAt(n);
                this.OWe(t, e) && s.push(this.AWe(t, e))
            }
            return {
                vQ: t,
                DWe: s
            }
        }
        static USe(t, i) {
            Mf.Tke(t, Element),
            Mf.Tke(i, Object);
            const e = this.EWe(t);
            if (null === i)
                return;
            const s = e.getSelection()
              , n = i.DWe;
            s.removeAllRanges();
            for (const i of n) {
                const {start: e, end: n} = i
                  , r = this.WSe(t, e, n);
                s.addRange(r)
            }
        }
        static*_We(t) {
            Mf.Tke(t, Element);
            for (const i of t.childNodes)
                switch (i.nodeType) {
                case Node.TEXT_NODE:
                    yield i;
                    break;
                case Node.ELEMENT_NODE:
                    yield*this._We(i)
                }
        }
        static*RWe(t) {
            Mf.Tke(t, Element),
            yield t;
            for (const i of t.childNodes)
                switch (i.nodeType) {
                case Node.TEXT_NODE:
                    yield i;
                    break;
                case Node.ELEMENT_NODE:
                    yield*this.RWe(i)
                }
        }
        static kWe(t, i=1 / 0) {
            if (Mf.Tke(t, Node),
            Mf.VY(i),
            t.nodeType === Node.TEXT_NODE)
                return Math.min(i, t.textContent.length);
            let e = 0;
            for (const s of this._We(t)) {
                if (i-- < 1)
                    break;
                e += this.kWe(s)
            }
            return e
        }
        static FWe(t, i) {
            Mf.Tke(t, Element),
            Mf.Ge(i);
            let e = 0
              , s = 0
              , n = null;
            for (const r of this._We(t))
                if (s = e,
                n = r,
                e += r.textContent.length,
                e > i)
                    return [r, i - s];
            return e === i ? [n, i - s] : null
        }
        static LWe(t) {
            Cf(t, Node);
            for (const i of t) {
                const t = i.parentNode
                  , e = t && t.parentNode;
                if (!e)
                    continue;
                const s = i.ownerDocument.createDocumentFragment();
                for (const i of Array.from(t.childNodes))
                    s.appendChild(i);
                e.replaceChild(s, t),
                e.normalize()
            }
        }
        static BWe(t, i) {
            Mf.Tke(t, Range),
            Mf.zt(i);
            const e = this.UWe(t)
              , s = new Set
              , n = t.commonAncestorContainer;
            if (n.nodeType === Node.TEXT_NODE) {
                let i = n;
                t.startOffset > 0 && (i = i.splitText(t.startOffset)),
                t.endOffset < i.textContent.length && i.splitText(t.endOffset),
                s.add(i)
            } else {
                const {start: i, end: r} = this.AWe(n, t, e);
                let h = 0
                  , o = 0;
                const a = Array.from(this._We(n));
                for (const t of a) {
                    const e = h + t.textContent.length;
                    if (0 === o && e > i) {
                        if (i > h) {
                            const e = t.splitText(i - h);
                            s.add(e)
                        } else
                            s.add(t);
                        o = 1
                    }
                    if (1 === o && e >= r) {
                        if (e > r) {
                            t.splitText(r - h);
                            s.add(t)
                        } else
                            s.add(t);
                        break
                    }
                    h = e
                }
            }
            for (const t of s) {
                const e = document.createElement("span");
                e.className = i,
                t.parentNode.replaceChild(e, t),
                e.appendChild(t)
            }
            return Array.from(s)
        }
        static LSe(t) {
            Mf.zt(t);
            let i = Ef.get(t);
            return i || (i = new _f(t),
            Ef.set(t, i)),
            i
        }
        static UWe(t) {
            Mf.Tke(t, Range);
            const i = t.commonAncestorContainer;
            return (i.nodeType === Node.DOCUMENT_NODE ? i : i.ownerDocument).defaultView
        }
        static EWe(t) {
            return Mf.Tke(t, Element),
            t.ownerDocument.defaultView
        }
    }
    ;
    class _f {
        constructor(t) {
            Mf.zt(t),
            this.NWe = new Map,
            this.jWe = new Map,
            this.className = t
        }
        cR(t) {
            if (Mf.Tke(t, Range),
            this.NWe.has(t))
                return;
            const i = Mf.Sis.BWe(t, this.className);
            this.NWe.set(t, i)
        }
        bx(t) {
            Mf.Tke(t, Range);
            const i = this.NWe.get(t);
            i && (Mf.Sis.LWe(i),
            this.NWe.delete(t))
        }
        tC() {
            for (const t of this.NWe.keys())
                this.bx(t)
        }
    }
}
{
    const Tf = self.t
      , If = t => {
        const i = t.target;
        if (!Gf.has(i))
            return;
        const e = t.keyCode
          , s = i.min ? self.parseFloat(i.min) : -1 / 0
          , n = i.max ? self.parseFloat(i.max) : 1 / 0
          , r = i.step ? self.parseFloat(i.step) : 1;
        if (Tf.kE.Zct(Tf.kE.K7, e)) {
            let e = self.parseFloat(i.value);
            Tf.Go(e) && (e += r,
            i.value = Tf.Ne(e, s, n),
            i.dispatchEvent(new Event("input")),
            t.preventDefault(),
            Af.get(i).$We || (Af.get(i).zWe = i.value),
            Af.get(i).$We = !0)
        } else if (Tf.kE.Zct(Tf.kE.j7, e)) {
            let e = self.parseFloat(i.value);
            Tf.Go(e) && (e -= r,
            i.value = Tf.Ne(e, s, n),
            i.dispatchEvent(new Event("input")),
            t.preventDefault(),
            Af.get(i).$We || (Af.get(i).zWe = i.value),
            Af.get(i).$We = !0)
        }
    }
      , Pf = t => {
        const i = t.target;
        if (!Gf.has(i))
            return;
        const e = t.keyCode;
        i.min && self.parseFloat(i.min),
        i.max && self.parseFloat(i.max),
        i.step && self.parseFloat(i.step);
        if (Tf.kE.Zct(Tf.kE.K7, e)) {
            const t = self.parseFloat(i.value);
            Af.get(i).$We && Af.get(i).zWe !== t && i.dispatchEvent(new Event("change")),
            Af.get(i).$We = !1,
            Af.get(i).zWe = NaN
        } else if (Tf.kE.Zct(Tf.kE.j7, e)) {
            const t = self.parseFloat(i.value);
            Af.get(i).$We && Af.get(i).zWe !== t && i.dispatchEvent(new Event("change")),
            Af.get(i).$We = !1,
            Af.get(i).zWe = NaN
        }
    }
      , Gf = new Set
      , Af = new Map
      , Rf = new Set;
    Tf.VWe = function(t) {
        if (Tf.zlt(t, "input"),
        "text" !== t.type)
            throw new TypeError(`unable to bind keyboard handlers to input, unsupported type ${t.type}`);
        const i = t.ownerDocument;
        return Rf.has(i) || (i.addEventListener("keydown", If, !0),
        i.addEventListener("keyup", Pf, !0),
        Rf.add(i)),
        Gf.add(t),
        Af.set(t, {
            $We: !1,
            zWe: NaN
        }),
        {
            Vh: () => {
                Gf.delete(t),
                Af.delete(t)
            }
            ,
            WWe() {
                const i = t.ownerDocument;
                Rf.has(i) || (i.addEventListener("keydown", If, !0),
                i.addEventListener("keyup", Pf, !0),
                Rf.add(i))
            }
        }
    }
}
{
    const kf = self.t
      , Of = new Set([16, 32, 64, 128, 256, 512])
      , Df = new Map([[16, [1768124468, 0]], [32, [1768124469, 1768108337]], [64, [1768124470, 1768108338]], [128, [1768108087, 0]], [256, [1768108088, 1768108339]], [512, [1768108089, 1768108340]]]);
    kf.HWe = async function(t) {
        let i = t.filter(t => Of.has(t.width) && t.width === t.height);
        if (i = await Promise.all(i.map(async t => ({
            arrayBuffer: await kf.fAs(t.blob),
            KWe: t.width
        }))),
        0 === i.length)
            return null;
        let e = 8;
        for (const t of i) {
            e += (8 + t.arrayBuffer.byteLength) * (0 !== Df.get(t.KWe)[1] ? 2 : 1)
        }
        const s = new ArrayBuffer(e)
          , n = new DataView(s)
          , r = new Uint8Array(s);
        n.setUint32(0, 1768124019, !1),
        n.setUint32(4, e, !1);
        let h = 8;
        for (const t of i) {
            const i = Df.get(t.KWe)
              , e = i[0]
              , s = i[1];
            n.setUint32(h, e, !1),
            h += 4,
            n.setUint32(h, t.arrayBuffer.byteLength + 8, !1),
            h += 4,
            r.set(new Uint8Array(t.arrayBuffer), h),
            h += t.arrayBuffer.byteLength,
            0 !== s && (n.setUint32(h, s, !1),
            h += 4,
            n.setUint32(h, t.arrayBuffer.byteLength + 8, !1),
            h += 4,
            r.set(new Uint8Array(t.arrayBuffer), h),
            h += t.arrayBuffer.byteLength)
        }
        return new Blob([s],{
            type: "application/octet-stream"
        })
    }
}
{
    const Ff = 1e3
      , Lf = 50;
    self.qWe = class {
        constructor() {
            this.XWe = !1,
            this.fVe = -1,
            this.YWe = [],
            this.JWe = -1
        }
        ski() {
            if (this.XWe || navigator.userActivation)
                return;
            const t = {
                capture: !0,
                passive: !0
            };
            window.addEventListener("pointerdown", () => this.ZWe(), t),
            window.addEventListener("pointerup", () => this.ZWe(), t),
            window.addEventListener("keydown", () => this.ZWe(), t),
            window.addEventListener("keyup", () => this.ZWe(), t),
            this.XWe = !0
        }
        ZWe() {
            -1 !== this.fVe && self.clearTimeout(this.fVe),
            this.JWe = Date.now(),
            this.QWe()
        }
        QWe() {
            this.fVe = self.setTimeout( () => this.wVe(), Lf)
        }
        wVe() {
            if (this.fVe = -1,
            this.YWe.length > 0) {
                const t = this.YWe;
                this.YWe = [];
                for (const i of t)
                    i()
            } else
                Date.now() < this.JWe + Ff && this.QWe()
        }
        $s(t) {
            -1 === this.fVe ? t() : this.YWe.push(t)
        }
        nOe(t) {
            return new Promise(i => {
                this.$s( () => {
                    i(t())
                }
                )
            }
            )
        }
    }
}
{
    const Bf = self.t
      , Uf = 1664311650
      , Nf = 1717856626
      , jf = 1651273570
      , $f = Bf.v(Bf.j1t, 16);
    async function zf(t, i, e) {
        let s = null;
        if (i instanceof Blob)
            s = i;
        else {
            if ("string" != typeof i)
                throw new TypeError("unexpected file data");
            s = new Blob([i])
        }
        let n = !1
          , r = s.size;
        if (e.tHe) {
            Bf.MimeType.H3t(Bf.Uh(t)).S3t() || (n = !0,
            await $f.cR(async () => {
                const t = new CompressionStream("deflate")
                  , i = s.stream().pipeThrough(t)
                  , e = await new Response(i).blob();
                s = e
            }
            ))
        }
        return {
            blob: s,
            iHe: r,
            eHe: n
        }
    }
    const Vf = new Map([[".js", 1], [".json", 2], [".html", 3], [".css", 4]]);
    function Wf(t, i) {
        const e = Bf.Uh(t).toLowerCase()
          , s = Bf.Uh(i).toLowerCase()
          , n = Vf.get(e) ?? 999
          , r = Vf.get(s) ?? 999;
        if (n < r)
            return -1;
        if (n > r)
            return 1;
        const h = Bf.MimeType.H3t(e)
          , o = Bf.MimeType.H3t(s);
        return h.WU() && !o.WU() ? -1 : !h.WU() && o.WU() ? 1 : "image" === h.Ags() && "image" !== o.Ags() ? -1 : "image" !== h.Ags() && "image" === o.Ags() ? 1 : 0
    }
    const Hf = {
        tHe: !1
    };
    Bf.sHe = async function(t, i) {
        i = Object.assign({}, Hf, i);
        const e = new Map
          , s = [];
        for (const [n,r] of t)
            s.push((async () => {
                const t = await zf(n, r, i);
                e.set(n, t)
            }
            )());
        await Promise.all(s);
        const n = [...e.entries()];
        n.sort( (t, i) => {
            const e = Wf(t[0], i[0]);
            return 0 !== e ? e : t[1].blob.size - i[1].blob.size
        }
        );
        const r = new ArrayBuffer(16)
          , h = new DataView(r);
        h.setUint32(0, Uf),
        h.setUint32(4, 0),
        h.setUint32(8, 16),
        h.setUint32(12, 0);
        let o = 0
          , a = 0;
        const l = []
          , u = []
          , c = new TextEncoder;
        for (const [t,i] of n) {
            Bf.zt(t);
            const {blob: e, iHe: s, eHe: n} = i
              , r = c.encode(t.normalize())
              , h = new ArrayBuffer(37 + r.length)
              , d = new DataView(h);
            d.setUint32(0, 0),
            d.setUint32(4, 0);
            const f = e.size;
            d.setBigUint64(8, BigInt(o)),
            o += f,
            d.setBigUint64(16, BigInt(f)),
            d.setBigUint64(24, BigInt(s)),
            d.setUint8(32, n ? 1 : 0),
            d.setUint32(33, r.length),
            new Uint8Array(h).set(r, 37),
            l.push(h),
            a += h.byteLength,
            u.push(e)
        }
        const d = new ArrayBuffer(16)
          , f = new DataView(d);
        f.setUint32(0, Nf),
        f.setBigUint64(4, BigInt(a + 4)),
        f.setUint32(12, l.length);
        const p = new ArrayBuffer(12)
          , m = new DataView(p);
        return m.setUint32(0, jf),
        m.setBigUint64(4, BigInt(o)),
        new Blob([r, d, ...l, p, ...u])
    }
}
{
    const Kf = self.t;
    Kf.nHe = class {
        constructor(t, i, e, s) {
            Kf.Ge(i),
            Kf.qd(s),
            Kf.Kq(e),
            this.rHe = t,
            this.BWs = i,
            this.pXs = e || null,
            this.d5s = s,
            this.hHe = !1
        }
        tC() {
            this.rHe = null,
            this.d5s = null
        }
        he() {
            this.rHe && !this.hHe && this.rHe.oHe(this)
        }
        zWs() {
            return this.BWs
        }
        cU() {
            return this.pXs
        }
        aHe() {
            this.d5s && (this.hHe = !0,
            this.d5s(),
            this.hHe = !1)
        }
    }
}
{
    const qf = self.t;
    class Xf {
        constructor() {
            this.C1 = !1,
            this._2i = [],
            this.lHe = 0,
            this.BWs = 0,
            this.uHe = 0,
            this.cHe = [],
            this.dHe = !1
        }
        Ent() {
            if (this.C1)
                throw new Error("already enabled");
            this.C1 = !0,
            window.addEventListener("popstate", t => this.fHe(t));
            for (const t of this._2i)
                history.pushState({
                    sequence: t.zWs()
                }, t.cU(), location.toString())
        }
        fHe(t) {
            if (this.lHe > 0)
                return this.lHe--,
                void (0 === this.lHe && this.cHe.length && qf.Wke( () => this.pHe()));
            if (!this._2i.length || !this.C1)
                return;
            if (this.dHe = !0,
            t.state) {
                const i = t.state.sequence;
                this.uHe = i
            }
            const i = this._2i.pop();
            i.aHe(),
            i.tC(),
            this.dHe = !1
        }
        pHe() {
            for (const t of this.cHe)
                t();
            qf.sc(this.cHe)
        }
        cR(t, i) {
            qf.qd(t),
            qf.Kq(i);
            const e = this.BWs++;
            if (this.uHe = e,
            this.C1) {
                const t = () => history.pushState({
                    sequence: e
                }, i || null, location.toString());
                this.lHe > 0 ? this.cHe.push(t) : this.dHe ? qf.Wke(t) : t()
            }
            const s = qf.v(qf.nHe, this, e, i, t);
            return this._2i.push(s),
            s
        }
        oHe(t) {
            const i = this._2i.indexOf(t);
            if (self.assert(-1 !== i, "cannot find back stack entry"),
            this._2i.splice(i, 1),
            t.tC(),
            this._2i.length) {
                const t = this._2i.at(-1);
                this.uHe = t.zWs()
            }
            this.C1 && (this.lHe++,
            this.mHe())
        }
        mHe() {
            this.C1 && (this.lHe > 0 || this.dHe ? qf.Wke( () => history.back()) : history.back())
        }
    }
    qf.wHe = qf.v(Xf)
}
{
    const Yf = self.t
      , Jf = "undefined" != typeof TextEncoder ? new TextEncoder("utf8") : null
      , Zf = 3;
    Yf.WebSocket = class extends Yf.Event.aG {
        constructor(t) {
            Yf.zt(t),
            super(),
            this.gHe = new WebSocket(t),
            this.gHe.binaryType = "arraybuffer",
            this.yHe = t,
            this.RLs = !1,
            this.bHe = new Yf.aWe( () => this.vHe(),10,{
                enabled: !1
            }),
            this.Hye = new Yf.kh(Yf.jh.Gh(this.gHe, "open", t => this.SHe(t)),Yf.jh.Gh(this.gHe, "close", t => this.xHe(t)),Yf.jh.Gh(this.gHe, "message", t => this.MHe(t)),Yf.jh.Gh(this.gHe, "error", t => this.EHe(t)),Yf.jh.he(this.bHe)),
            this.CHe = null,
            this._He = [],
            this.THe = new Map,
            this.IHe = null,
            this.PHe = null
        }
        he() {
            this.g_(),
            this.CHe = null,
            this.Hye.Vh(),
            this._He.length = 0,
            this.THe.forEach(t => t.he()),
            this.THe.clear()
        }
        GHe() {
            if (this.gHe.readyState !== WebSocket.CLOSED)
                throw new Error("Websocket is not closed");
            return this.Hye.Vh(),
            this.gHe = new WebSocket(this.yHe),
            this.gHe.binaryType = "arraybuffer",
            this.bHe = new Yf.aWe( () => this.vHe(),10,{
                enabled: !1
            }),
            this.Hye = new Yf.kh(Yf.jh.Gh(this.gHe, "open", t => this.SHe(t)),Yf.jh.Gh(this.gHe, "close", t => this.xHe(t)),Yf.jh.Gh(this.gHe, "message", t => this.MHe(t)),Yf.jh.Gh(this.gHe, "error", t => this.EHe(t)),Yf.jh.he(this.bHe)),
            new Promise( (t, i) => {
                this.IHe = t,
                this.PHe = i
            }
            )
        }
        yc() {
            return this.RLs
        }
        AHe(t, i, e=Yf.WebSocket.AHe.RHe) {
            Yf.zt(t),
            Yf.zt(e),
            Yf.X_t(i);
            let s = this.THe.get(t);
            if (s || (s = new Yf.WebSocket.AHe(this,t,e),
            this.THe.set(t, s)),
            !s.kHe(e))
                throw new Error(`Requested channel is not requested type "${e}"`);
            return i ? s.OHe(i) : s
        }
        DHe(t, i) {
            return this.AHe(t, i, Yf.WebSocket.AHe.FHe)
        }
        LHe(t, i) {
            return this.AHe(t, i, Yf.WebSocket.AHe.JSON)
        }
        BHe(t) {
            Yf.zt(t);
            let i = this.THe.get(t);
            i && i.he()
        }
        UHe(t) {
            this.THe.delete(t)
        }
        g_(t, i) {
            const e = this.gHe.readyState;
            e != WebSocket.OPEN && e != WebSocket.CONNECTING || this.gHe.close(t, i)
        }
        NHe(t, i=Yf.WebSocket.AHe.RHe) {
            return new Promise( (e, s) => {
                const n = this.AHe(t, t => {
                    n.he(),
                    r.Vh(),
                    e(t)
                }
                , i)
                  , r = Yf.jh.Gh(this, "close", t => {
                    n.he(),
                    r.Vh(),
                    s(t)
                }
                )
            }
            )
        }
        jHe(t) {
            return this.NHe(t, Yf.WebSocket.AHe.JSON)
        }
        $He(t) {
            return this.NHe(t, Yf.WebSocket.AHe.FHe)
        }
        zHe(t, i, e) {
            Yf.U(i, Uint8Array);
            const s = new Uint8Array(i.length + Zf);
            for (let i = 0; i < Zf; i++)
                s[i] = 255 & t.charCodeAt(i);
            return s.set(i, Zf),
            this.VHe(s, e)
        }
        WHe(t, i, e) {
            return i ? this.HHe(t, i, e) : this.KHe(t, e)
        }
        KHe(t, i) {
            return this.zHe(t, i)
        }
        HHe(t, i, e) {
            return Yf.zt(i),
            this.zHe(t, Jf.encode(i), e)
        }
        qHe(t, i, e) {
            Yf.Hut(i);
            let s = JSON.stringify(i);
            return this.HHe(t, s, e)
        }
        VHe(t, i) {
            return Yf.U(t, Uint8Array),
            new Promise( (e, s) => {
                let n = {
                    data: t,
                    resolve: e,
                    reject: s
                };
                i ? this._He.unshift(n) : this._He.push(n),
                this.yc() && !this.bHe.gWe() && (this.vHe(),
                this.bHe.ke())
            }
            )
        }
        MHe({data: t}) {
            let i = new Uint8Array(t,0,Zf)
              , e = Array(Zf);
            for (let t = 0; t < Zf; t++)
                e[t] = String.fromCharCode(i[t]);
            e = e.join("");
            let s = new Uint8Array(t,Zf)
              , n = this.THe.get(e);
            n && n.XHe(s)
        }
        SHe() {
            this.RLs = !0,
            this.IHe && this.IHe(),
            this.IHe = null,
            this.PHe = null,
            this.vHe(),
            this.bHe.ke();
            let t = Yf.v(Yf.Event, "open");
            this.dispatchEvent(t)
        }
        xHe() {
            const t = Yf.v(Yf.Event, "close");
            this.CHe && this.CHe.reject(t),
            this.CHe = null,
            this.bHe.rjs(),
            this.PHe && this.PHe(t),
            this.IHe = null,
            this.PHe = null,
            this.dispatchEvent(t)
        }
        EHe(t) {
            this.CHe && this.CHe.reject(t),
            this.CHe = null
        }
        vHe() {
            const t = this.gHe
              , i = this._He;
            if (t.readyState !== WebSocket.OPEN)
                return;
            if (!(t.bufferedAmount > 0)) {
                if (this.CHe && (this.CHe.resolve(),
                this.CHe = null),
                i.length > 0) {
                    let e = i.shift();
                    this.CHe = e,
                    t.send(e.data)
                }
                this.CHe || 0 !== i.length || this.bHe.rjs()
            }
        }
        static async YHe(t) {
            const i = Yf.v(Yf.WebSocket, t);
            try {
                return await new Promise( (t, e) => {
                    const s = Yf.jh.Gh(i, "open", () => {
                        s.Vh(),
                        n.Vh(),
                        t()
                    }
                    )
                      , n = Yf.jh.Gh(i, "close", t => {
                        s.Vh(),
                        n.Vh(),
                        e(t)
                    }
                    )
                }
                ),
                i
            } catch (t) {
                throw i.he(),
                t
            }
        }
    }
}
{
    const Qf = self.t
      , tp = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : null;
    Qf.WebSocket.AHe = class t {
        constructor(i, e, s) {
            if (s !== t.RHe && s !== t.FHe && s !== t.JSON)
                throw new Error(`Invalid channel type ${s}`);
            Qf.U(i, Qf.WebSocket),
            Qf.zt(e),
            this.rVt = e,
            this.lVt = s,
            this.VYi = i,
            this.dze = new Set
        }
        he() {
            this.VYi.UHe(this.rVt),
            this.dze.clear()
        }
        kHe(t) {
            return t === this.lVt
        }
        WHe(i, e) {
            switch (this.lVt) {
            case t.JSON:
                return this.VYi.qHe(this.rVt, i, e);
            case t.RHe:
                return this.VYi.HHe(this.rVt, i, e);
            case t.FHe:
                return this.VYi.zHe(this.rVt, i, e)
            }
        }
        OHe(t) {
            return Qf.qd(t),
            this.dze.add(t),
            new Qf.jh( () => this.dze.delete(t))
        }
        XHe(i) {
            let e;
            switch (this.lVt) {
            case t.RHe:
                e = tp.decode(i);
                break;
            case t.JSON:
                e = JSON.parse(tp.decode(i));
                break;
            case t.FHe:
                e = i
            }
            for (let t of this.dze)
                t(e)
        }
    }
    ,
    Qf.WebSocket.AHe.FHe = "binary",
    Qf.WebSocket.AHe.JSON = "json",
    Qf.WebSocket.AHe.RHe = "text"
}
{
    const ip = self.t;
    ip.yv = class {
        constructor() {
            this.JHe = new Map,
            this.ZHe = !1,
            this.QHe = null,
            this.tKe = null,
            this.iKe = null,
            this.eKe = null
        }
        Vv(t) {
            this.ZHe = !!t
        }
        sKe() {
            return this.ZHe
        }
        xv(t) {
            ip.qd(t),
            this.QHe = t
        }
        nKe(t) {
            if (!this.QHe)
                throw new Error("no get base size callback set");
            return this.QHe(t)
        }
        Cv(t) {
            ip.qd(t),
            this.tKe = t
        }
        rKe(t, i, e, s, n, r) {
            if (!this.tKe)
                throw new Error("no raster at size callback set");
            return this.tKe(t, i, e, s, n, r)
        }
        Mv(t) {
            ip.qd(t),
            this.iKe = t
        }
        hKe(t) {
            if (!this.iKe)
                throw new Error("no release result callback set");
            this.iKe(t)
        }
        Tv(t) {
            ip.qd(t),
            this.eKe = t
        }
        bOt() {
            if (!this.eKe)
                throw new Error("no redraw callback set");
            this.eKe()
        }
        Ev(t) {
            let i = this.JHe.get(t);
            return i || (i = ip.v(ip.oKe, this, t),
            this.JHe.set(t, i)),
            i.aKe(),
            i
        }
        lKe(t) {
            this.JHe.delete(t.zv())
        }
        Rv() {
            for (const t of this.JHe.values())
                t.uKe(),
                t.Bv()
        }
    }
}
{
    const ep = self.t
      , sp = 4096;
    ep.oKe = class {
        constructor(t, i) {
            this.VYi = t,
            this.cKe = i,
            this.dKe = 0,
            this.fKe = 0,
            this.pKe = 0,
            this.mKe = this.VYi.nKe(i).then(t => {
                this.VYi && (this.fKe = t[0],
                this.pKe = t[1],
                this.VYi.bOt())
            }
            ).catch(t => {
                console.error("[SVG] Error loading SVG: ", t),
                this.zn = !0,
                this.VYi && this.VYi.bOt()
            }
            ),
            this.wKe = 0,
            this.gKe = 0,
            this.yKe = 0,
            this.bKe = 0,
            this.vKe = !1,
            this.SKe = null,
            this.xKe = !1,
            this.zn = !1
        }
        he() {
            if (this.dKe <= 0)
                throw new Error("already released");
            this.dKe--,
            0 === this.dKe && this.LUt()
        }
        uKe() {
            this.SKe && (this.VYi.hKe(this.SKe),
            this.SKe = null)
        }
        LUt() {
            this.uKe(),
            this.VYi.lKe(this),
            this.VYi = null
        }
        zv() {
            return this.cKe
        }
        aKe() {
            this.dKe++
        }
        MKe() {
            return this.dKe > 0
        }
        Yv() {
            return this.SKe
        }
        Bv() {
            this.xKe = !0
        }
        async $v(t, i, e) {
            if (0 === i || 0 === e || this.zn)
                return;
            if (this.vKe)
                return;
            let s = ep.ha(Math.ceil(i))
              , n = ep.ha(Math.ceil(e));
            const r = Math.max(s, n);
            if (r > sp) {
                const t = sp / r;
                i *= t,
                e *= t,
                s = Math.min(Math.ceil(s * t), sp),
                n = Math.min(Math.ceil(n * t), sp)
            }
            if (i < s && e < n) {
                const t = i / e;
                s / n > t ? (i = n * t,
                e = n) : (i = s,
                e = s / t)
            }
            if (this.VYi.sKe() && (s = Math.ceil(i),
            n = Math.ceil(e)),
            s <= this.wKe && n <= this.gKe && !this.xKe)
                return;
            this.vKe = !0,
            this.wKe = s,
            this.gKe = n;
            const h = await this.VYi.rKe(this.cKe, t, this.wKe, this.gKe, i, e);
            this.VYi && (this.uKe(),
            this.SKe = h,
            this.yKe = i,
            this.bKe = e,
            this.vKe = !1,
            this.xKe = !1,
            this.VYi.bOt())
        }
        EKe() {
            return this.mKe
        }
        Wv() {
            return this.fKe
        }
        Xv() {
            return this.pKe
        }
        Jv() {
            return this.yKe
        }
        Qv() {
            return this.bKe
        }
        Hv() {
            return this.zn
        }
    }
}
{
    const np = self.t;
    let rp = null;
    const hp = /\\/g;
    function op(t) {
        return t.normalize().toLowerCase().replace(hp, "/")
    }
    let ap = null
      , lp = !1;
    async function up() {
        if (lp)
            return;
        lp = !0;
        const t = np.sh() + "3rdparty/zipjs/zip.js";
        await np.ih(t),
        rp = self.zip,
        ap = np.FRt.CKe()
    }
    np.FRt = class {
        constructor() {
            this._Ke = null,
            this.TKe = new Map,
            this.IKe = 0,
            this.PKe = 0,
            this.GKe = new Set,
            this.AKe = 0,
            this.RKe = 0,
            this.kKe = -1,
            this.OKe = np.v(np.j1t, 16)
        }
        he() {
            this.YRt(),
            this.TKe && this.TKe.clear(),
            this.TKe = null,
            this.GKe && this.GKe.clear(),
            this.GKe = null
        }
        YRt() {
            this._Ke && (this._Ke.close(),
            this._Ke = null)
        }
        static SIt() {
            return up()
        }
        async HRt(t) {
            let i;
            if (np.U(t, Blob),
            await up(),
            this.YRt(),
            this.TKe.clear(),
            this.GKe.clear(),
            this.IKe = 0,
            this.PKe = 0,
            t.size < 209715200) {
                const e = await np.fAs(t);
                i = new rp.Uint8ArrayReader(new Uint8Array(e))
            } else
                i = new rp.BlobReader(t);
            this._Ke = new rp.ZipReader(i);
            let e = 0;
            for await(const t of this._Ke.getEntriesGenerator())
                this.TKe.set(op(t.filename), t),
                this.IKe += t.compressedSize,
                e++,
                e >= 1e3 && (await np.Mme(),
                e = 0);
            return this
        }
        hes(t) {
            return np.zt(t),
            this.TKe.has(op(t))
        }
        XRt(t) {
            return np.zt(t),
            this.TKe.get(op(t)) || null
        }
        DKe() {
            return this.TKe.values()
        }
        FKe() {
            return this.TKe.keys()
        }
        wLe() {
            const t = (i, e, s) => {
                for (let t = s.length - 1; t >= 0; t--) {
                    const n = s[t]
                      , r = n.filename.replace(i, "");
                    if (!n.directory && r.includes("/"))
                        continue;
                    if (n.directory && 1 !== (r.match(/\//g) || []).length)
                        continue;
                    const h = np.des(n.filename);
                    (n.directory || r === np.EU(h) + np.Uh(h)) && (s.splice(t, 1),
                    n.directory ? e.push({
                        entry: n,
                        children: []
                    }) : e.push({
                        entry: n
                    }))
                }
                for (const i of e) {
                    const e = i.entry;
                    e.directory && t(e.filename, i.children, s)
                }
                return e.reverse()
            }
            ;
            let i = [...this.DKe()];
            for (const t of i)
                t.filename = t.filename.replace(/\\/g, "/");
            for (const t of i) {
                if (t.directory)
                    continue;
                const e = t.filename.split("/");
                e.pop();
                let s = "";
                for (const t of e)
                    s += `${t}/`,
                    i.some(t => t.filename === s) || i.push({
                        filename: s,
                        directory: !0
                    })
            }
            return t("", [], i)
        }
        $Rt(t) {
            np.zt(t);
            const i = t.toLowerCase();
            for (const t of this.TKe.values())
                if (t.filename.toLowerCase().endsWith(i))
                    return t;
            return null
        }
        ies(t) {
            return this.OKe.cR( () => this.LKe(t))
        }
        async LKe(t) {
            np.Yq(t);
            const i = {
                BKe: 0
            };
            this.GKe.add(i);
            const e = new rp.TextWriter
              , s = await t.getData(e, {
                onprogress: t => i.BKe = t
            });
            return this.GKe.delete(i),
            this.PKe += t.compressedSize,
            s
        }
        async ees(t) {
            np.Yq(t);
            const i = await this.ies(t);
            return await np.Ats(i)
        }
        JRt(t, i) {
            return this.OKe.cR( () => this.mes(t, i))
        }
        async mes(t, i) {
            np.Yq(t),
            np.Kq(i);
            const e = i || np.MimeType.H3t(np.Uh(t.filename)).uL()
              , s = {
                BKe: 0
            };
            this.GKe.add(s);
            const n = new rp.BlobWriter(e)
              , r = await t.getData(n, {
                onprogress: t => s.BKe = t
            });
            return this.GKe.delete(s),
            this.PKe += t.compressedSize,
            r.name = t.filename,
            t.lastModDate && (r.lastModified = +t.lastModDate),
            r
        }
        WRt() {
            return this.IKe
        }
        LRt() {
            return this.PKe + this.UKe()
        }
        UKe() {
            let t = 0;
            for (const i of this.GKe)
                t += i.BKe || 0;
            return t
        }
        PPe(t) {
            if (np.Ge(t),
            t < -1 || t > 9)
                throw new RangeError("invalid compression level");
            this.kKe = t
        }
        NKe(t) {
            if (np.Ge(t),
            -1 !== this.kKe)
                return this.kKe;
            const i = 1048576;
            return t > 5 * i ? 1 : t > 2 * i ? 2 : t > 1 * i ? 3 : t > 524288 ? 4 : 5
        }
        jKe(t) {
            let i = 0;
            for (const e of t.values()) {
                let t = null;
                t = np.Ots(e) ? e.data : e,
                i += t.byteLength || t.size || t.length || 0
            }
            return i
        }
        async yLt(t, i) {
            let e;
            np.Mw(i, Map),
            await up(),
            this.AKe = 0,
            this.RKe = 0,
            this.GKe.clear(),
            e = this.jKe(t) < 262144e3 ? new ap : new rp.BlobWriter("application/zip");
            const s = new rp.ZipWriter(e,{
                zip64: !0,
                supportZip64SplitFile: !1,
                bufferedWrite: !0,
                dataDescriptor: !1
            });
            await this.$Ke(s, t, i);
            const n = await s.close();
            return n instanceof Blob ? n : new Blob([n],{
                type: "application/zip"
            })
        }
        async $Ke(t, i, e) {
            const s = [];
            for (const [n,r] of i) {
                let i = null;
                if (i = np.Ots(r) ? r.data : r,
                "string" == typeof i)
                    this.AKe += i.length;
                else {
                    if (!np.$l(i, Blob))
                        throw new Error("unknown file content");
                    this.AKe += i.size
                }
                s.push(this.OKe.cR( () => this.zKe(t, n, r, e)))
            }
            await Promise.all(s)
        }
        async zKe(t, i, e, s) {
            let n, r = null, h = 0, o = null, a = null;
            np.Ots(e) ? (r = e.data,
            h = e.VKe || 0,
            o = e.WKe || null,
            a = "number" == typeof e.HKe ? e.HKe : null) : r = e;
            let l = 5
              , u = 0;
            if ("string" == typeof r)
                n = new rp.TextReader(r),
                u = r.length,
                l = this.NKe(u);
            else {
                if (!np.$l(r, Blob))
                    throw new Error("unknown file content");
                {
                    n = new rp.BlobReader(r),
                    u = r.size,
                    l = this.NKe(u);
                    let t = r.type;
                    t || (t = np.MimeType.H3t(np.Uh(i)).uL()),
                    np.MimeType.$s(t).S3t() && (l = 0)
                }
            }
            const c = {
                bytesWritten: 0
            };
            this.GKe.add(c);
            const d = {
                level: l,
                externalFileAttribute: h,
                extraField: o,
                zip64: !0,
                supportZip64SplitFile: !1,
                onprogress: t => c.bytesWritten = t
            };
            null !== a && (d.versionMadeBy = a);
            const f = await t.add(i, n, d);
            this.GKe.delete(c),
            this.RKe += u,
            s && s.set(i, f.compressedSize)
        }
        xPe() {
            return this.AKe
        }
        KKe() {
            let t = 0;
            for (const i of this.GKe)
                t += i.bytesWritten || 0;
            return t
        }
        _Pe() {
            return this.RKe + this.KKe()
        }
    }
}
self.t.FRt.CKe = function() {
    return class extends self.zip.Writer {
        init(t=0) {
            super.init(),
            Object.assign(this, {
                offset: 0,
                arrayParts: [],
                totalSize: 0
            })
        }
        writeUint8Array(t) {
            this.arrayParts.push(t),
            this.totalSize += t.length
        }
        getData() {
            const t = new ArrayBuffer(this.totalSize)
              , i = new Uint8Array(t);
            let e = 0;
            for (const t of this.arrayParts)
                i.set(t, e),
                e += t.length;
            return i
        }
    }
}
;
{
    const cp = globalThis.t
      , dp = globalThis.lang
      , fp = globalThis.iG;
    let pp = null
      , mp = !1
      , wp = !1
      , gp = !1
      , yp = null
      , bp = null
      , vp = null;
    const Sp = new Map
      , xp = new WeakMap
      , Mp = new Map;
    let Ep = null
      , Cp = !1;
    const _p = new Map([["application/javascript", "javascript"], ["text/javascript", "javascript"], ["application/typescript", "typescript"], ["text/typescript", "typescript"], ["text/css", "css"], ["text/markdown", "markdown"], ["text/html", "html"], ["application/json", "json"], ["text/xml", "xml"], ["image/svg+xml", "xml"]])
      , Tp = ["de", "es", "fr", "it", "ja", "ko", "ru", "zh-cn", "zh-tw"];
    let Ip = null;
    const Pp = {
        textContent: null,
        mimeType: "text/plain",
        fontSize: null
    };
    async function Gp() {
        mp = !0,
        await cp.ih(cp.sh() + "3rdparty/monaco/vs/loader.js", !0);
        const t = globalThis.require
          , i = {
            baseUrl: cp.sh() + "3rdparty/monaco",
            paths: {
                vs: cp.sh() + "3rdparty/monaco/vs"
            }
        }
          , e = globalThis.app.iwt().toLowerCase();
        for (const t of Tp)
            if (e.startsWith(t)) {
                Ip = t,
                i["vs/nls"] = {
                    availableLanguages: {
                        "*": t
                    }
                };
                break
            }
        t.config(i),
        await new Promise(i => t(["vs/editor/editor.main"], i)),
        bp = globalThis.monaco
    }
    async function Ap() {
        if (vp)
            return;
        const t = await fetch("media/autocomplete-data.json");
        vp = await t.json()
    }
    cp.fgt = class t extends cp.Event.aG {
        #t;
        #i;
        #e;
        #s;
        #n;
        #r = null;
        #h = !1;
        #o = !1;
        #a = null;
        #l = null;
        #u = 0;
        #c = !1;
        #d = null;
        #f = [];
        #p = null;
        #m = !1;
        #w = !1;
        #g = -1;
        #y = "";
        #b = 0;
        #v = !1;
        constructor(t, i) {
            cp.zlt(t),
            cp.Wat(i),
            super();
            const e = i.Agt
              , s = i.sx
              , n = i._h
              , r = i.Ggt
              , h = i.Bgt;
            cp.Mw(e, globalThis.eAs),
            cp.Mw(s, globalThis.gh),
            cp.Mw(n, globalThis.fh),
            cp.Wat(r),
            cp.Mw(h, globalThis.lpt),
            this.#t = t,
            this.#i = e,
            this.#e = s,
            this.#s = n,
            this.#n = r,
            this.#r = h,
            this.#d = cp.v(cp.kh, cp.jh.Gh(globalThis.app, "settingschange", () => this.#S())),
            this.#r && this.#d.cR(cp.jh.Gh(this.#r.dH(), "resize", () => this.Fgt()), cp.jh.Gh(this.#r.dH(), "move", () => this.Fgt()), cp.jh.Gh(this.#r, "scroll", () => this.Fgt()))
        }
        static mgt() {
            return cp.qs.oX.qKe() ? "vs-dark" : "vs"
        }
        static async _gt() {
            return pp && !wp || (pp = t.#x()),
            pp
        }
        static async #x() {
            const t = globalThis.app;
            let i = null;
            wp = !1;
            try {
                i = t.ZPe(globalThis.lang("ui.bars.textEditor.loading-status")),
                i.Ej();
                const [e] = await Promise.all([import(cp.sh() + "3rdparty/monaco-ts-locales/index.js"), Gp(), Ap()]);
                Ip && e.register(bp)
            } catch (t) {
                throw i.he(),
                wp = !0,
                t
            }
            try {
                gp = !0;
                const i = bp.languages.typescript;
                console.log("Loaded Monaco editor, using TypeScript v" + i.typescriptVersion),
                i.javascriptDefaults.setEagerModelSync(!0),
                i.typescriptDefaults.setEagerModelSync(!0),
                this.#M(!1, !0);
                const e = await cp.Ars.APs()
                  , s = [];
                for (const [t,i] of e)
                    t.endsWith("AddonSDK.d.ts") || s.push({
                        content: i,
                        filePath: "file:///ts-defs/runtime/" + cp.des(t)
                    });
                i.javascriptDefaults.setExtraLibs(s),
                i.typescriptDefaults.setExtraLibs(s),
                bp.editor.registerEditorOpener({
                    openCodeEditor: (t, i, e) => cp.fgt.XKe(t, i, e)
                }),
                bp.languages.registerCompletionItemProvider("typescript", {
                    triggerCharacters: ".",
                    provideCompletionItems: (t, i, e, s) => t.uri.toString().toLowerCase().endsWith(".js") ? cp.fgt.YKe(t, i, e) : null,
                    resolveCompletionItem: (t, i) => null
                }),
                bp.editor.setTheme(cp.fgt.mgt()),
                yp = bp.editor.createModel("/* dummy js model */", "javascript", bp.Uri.parse("file:///construct-internal/__dummy_js_model__.js")),
                await t.JKe("monacoeditorloaded")
            } finally {
                i.he()
            }
        }
        static #M(t, i) {
            if (t = !!t,
            !i && Cp === t)
                return;
            Cp = t;
            const e = bp.languages.typescript
              , s = ["lib.es2023.d.ts"];
            t ? s.push("lib.webworker.d.ts") : s.push("lib.dom.d.ts");
            const n = {
                target: e.ScriptTarget.ESNext,
                module: e.ModuleKind.ESNext,
                esModuleInterop: !1,
                forceConsistentCasingInFileNames: !0,
                strict: !0,
                skipLibCheck: !0,
                lib: s,
                allowJs: !0,
                moduleDetection: 3
            };
            Ip && (n.locale = Ip),
            e.typescriptDefaults.setCompilerOptions(n)
        }
        static async XKe(t, i, e) {
            const s = globalThis.app
              , n = i.path;
            let r = null;
            if (n.toLowerCase().endsWith(".d.ts")) {
                const i = xp.get(t);
                return void i?.ZKe()
            }
            const h = globalThis.QAs.XAs(n);
            if (h) {
                let t = -1;
                if ("number" == typeof e.lineNumber)
                    t = e.lineNumber;
                else {
                    if ("number" != typeof e.startLineNumber)
                        return !1;
                    t = e.startLineNumber
                }
                if (r = h.dPs(t)?.VP,
                !r)
                    return !1
            } else {
                const t = globalThis.eAs.XAs(n);
                if (!t)
                    return !1;
                r = t.mte()
            }
            if (r instanceof globalThis.fh) {
                const t = s.DA()
                  , i = await t.TU(r);
                e && (await i.W7t(),
                "number" == typeof e.column ? i.M7t(e.lineNumber, e.column) : i.R7t(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn))
            } else {
                const t = s.JR().GR(r.$R());
                await t.Vxt(),
                t.ryt(r, {
                    Fxt: !0
                }),
                cp.qs.iA.SF(t.dH())
            }
            return !0
        }
        static QKe() {
            return mp
        }
        static dgt() {
            return gp
        }
        static pgt() {
            return bp
        }
        async y_(t) {
            if (!bp)
                throw new Error("monaco not loaded");
            const i = (t = Object.assign({}, Pp, t)).textContent
              , e = t.mimeType;
            cp.Kq(i),
            cp.zt(e);
            const s = globalThis.app.r0();
            this.#p = cp.qs.lk("div", document.body, null, "construct-monaco-overlay monaco-editor"),
            this.#p.style.display = "none",
            this.#m = !1;
            const n = {
                dropIntoEditor: {
                    enabled: !1
                },
                overflowWidgetsDomNode: this.#p,
                contextmenu: !1,
                theme: cp.fgt.mgt(),
                fontSize: t.fontSize || s.textEditorFontSize || 12,
                autoIndent: s.textEditorAutoIndent ? "advanced" : "keep",
                wordWrap: s.textEditorEnableWordWrap ? "on" : "off",
                minimap: {
                    enabled: s.textEditorEnableMinimap,
                    scale: s.textEditorMinimapScale
                },
                stickyScroll: {
                    enabled: s.textEditorEnableStickyScrolling
                },
                folding: s.textEditorEnableCodeFolding
            };
            this.#l = _p.get(e),
            this.#l && (n.language = this.#l);
            let r = -1
              , h = -1
              , o = -1;
            if (this.#i)
                if (this.#i.mte()instanceof globalThis.fh) {
                    if (n.model = await this.#i.KAs(),
                    this.#o)
                        return
                } else {
                    if (this.#h = !0,
                    n.model = await this.#e.cgt(this.#l).KAs(),
                    this.#o)
                        return;
                    n.minimap.enabled = !1,
                    n.stickyScroll.enabled = !1,
                    n.scrollbar = {
                        horizontal: "hidden",
                        vertical: "hidden"
                    },
                    n.overviewRulerBorder = !1,
                    n.overviewRulerLanes = 0,
                    n.hideCursorInOverviewRuler = !0,
                    n.scrollBeyondLastLine = !1,
                    n.lineNumbersMinChars = 3,
                    n.multiCursorLimit = 1,
                    n.folding = !1;
                    const t = n.model.getValue()
                      , i = this.#i.mte().$q()
                      , e = t.indexOf("//construct-start-block:" + i)
                      , s = t.indexOf("//construct-end-block:" + i);
                    r = cp.wPs(t, e) + 2,
                    h = cp.wPs(t, s),
                    o = n.model.getLineCount(),
                    n.lineNumbers = t => String(t - r),
                    this.#g = r + 1,
                    this.#y = "//construct-end-block:" + i,
                    this.#d.cR(cp.jh.Gh(this.#t, "keydown", t => this.#E(t), !0), cp.jh.Gh(this.#t, "wheel", t => this.#C(t), !0))
                }
            else
                n.value = i;
            n.model && (Sp.set(n.model.uri.path, this),
            this.#u = n.model.getValueLength()),
            this.#a = bp.editor.create(this.#t, n);
            const a = this.#f;
            this.#h && (this.#a.setHiddenAreas([new bp.Range(0,0,r,0), new bp.Range(h,0,o,0)]),
            this.M7t(r + 1, 0),
            this.#w = !0,
            a.push(this.#a.onDidChangeCursorPosition(t => this.#_(t))),
            a.push(this.#a.onDidChangeCursorSelection(t => this.#T(t)))),
            a.push(this.#a.onDidChangeModelContent( () => this.#I())),
            a.push(this.#a.onDidContentSizeChange( () => this.#P())),
            a.push(this.#a.onContextMenu(t => this.#G(t))),
            a.push(this.#a.onDidFocusEditorText( () => this.#A())),
            a.push(this.#a.onDidFocusEditorWidget( () => this.#A())),
            a.push(this.#a.onDidBlurEditorText( () => this.#R())),
            a.push(this.#a.onDidBlurEditorWidget( () => this.#R())),
            this.#d.cR(cp.jh.Gh(this.#p, "keydown", t => this.#k(t))),
            this.#s && !this.#i && this.#d.cR(cp.jh.Gh(this.#s, "projectfileblobchange", t => this.#O(t))),
            xp.set(this.#a, this)
        }
        he() {
            Sp.delete(this.#a.getModel().uri.path),
            this.#D(),
            this.#o = !0,
            this.#d.Vh(),
            this.#d = null;
            for (const t of this.#f)
                t.dispose();
            cp.sc(this.#f),
            this.#a && (xp.delete(this.#a),
            this.#a.dispose(),
            this.#a = null),
            this.#p && (this.#p.remove(),
            this.#p = null),
            this.#t = null,
            this.#i = null,
            this.#e = null,
            this.#n = null,
            super.he()
        }
        #F() {
            let t = 1 / 0;
            if (this.#y) {
                const i = this.#a.getValue()
                  , e = i.indexOf(this.#y);
                -1 !== e && (t = cp.wPs(i, e) - 1)
            }
            return [this.#g, t]
        }
        #_(t) {
            if (!this.#w || this.#v)
                return;
            const [i,e] = this.#F()
              , s = t.position;
            let n = s.lineNumber
              , r = s.column
              , h = !1;
            n < i ? (n = this.#g,
            r = this.#b,
            h = !0) : s.lineNumber > e ? (n = e,
            r = this.#b,
            h = !0) : this.#b = r,
            h && (this.#v = !0,
            this.#a.setPosition({
                lineNumber: n,
                column: r
            }),
            this.#v = !1)
        }
        #T(t) {
            if (!this.#w || this.#v)
                return;
            const i = t.selection
              , [e,s] = this.#F();
            let n = i.selectionStartLineNumber
              , r = i.selectionStartColumn
              , h = i.positionLineNumber
              , o = i.positionColumn
              , a = !1
              , l = !1;
            h < e ? (h = this.#g,
            o = this.#b,
            a = !0) : h > s ? (h = s,
            o = this.#b,
            l = !0,
            a = !0) : this.#b = o,
            n < e ? (n = this.#g,
            r = this.#b,
            a = !0,
            l && (r = 1,
            o = 1 / 0)) : n > s && (n = s,
            r = this.#b,
            a = !0),
            a && (this.#v = !0,
            this.#a.setSelection(new bp.Selection(n,r,h,o)),
            this.#v = !1)
        }
        #E(t) {
            if (this.#w) {
                if ("Delete" === t.key || "Backspace" === t.key) {
                    if (this.BK())
                        return;
                    const [i,e] = this.#F()
                      , s = this.#a.getPosition()
                      , n = s.lineNumber
                      , r = s.column;
                    let h = !1;
                    if (n === i && 1 === r && "Backspace" === t.key)
                        h = !0;
                    else if (n === e && "Delete" === t.key) {
                        r > this.#a.getModel().getLineLength(e) && (h = !0)
                    }
                    h && (t.preventDefault(),
                    t.stopPropagation())
                }
                "F1" === t.key && this.#h && (t.preventDefault(),
                t.stopPropagation())
            }
        }
        #C(t) {
            t.stopPropagation()
        }
        Tgt() {
            this.#a && this.#a.focus()
        }
        G7t() {
            return !!this.#a && this.#a.hasTextFocus()
        }
        O7t() {
            return !!this.#a && this.#a.hasWidgetFocus()
        }
        tqe() {
            return this.G7t() || this.O7t()
        }
        #A() {
            this.#p && this.#L()
        }
        #R() {
            this.#p && !this.tqe() && this.#D()
        }
        #L() {
            this.#m || (this.#m = !0,
            document.body.appendChild(this.#p),
            this.#p.style.display = "",
            this.Fgt(),
            globalThis.app.aj() && (this.#p.style.zIndex = 99999))
        }
        #D() {
            this.#m && (this.#m = !1,
            this.#p.style.display = "none")
        }
        Fgt() {
            if (!this.#m)
                return;
            const t = this.#t.getBoundingClientRect()
              , i = this.#t.ownerDocument.defaultView;
            this.#p.style.left = t.left + "px",
            this.#p.style.top = t.top + "px",
            this.#p.style.width = i.innerWidth - t.left + "px",
            this.#p.style.height = t.height + "px"
        }
        #k(t) {
            "Enter" === t.key ? (t.stopPropagation(),
            t.preventDefault(),
            this.#B("acceptRenameInput")) : "Escape" === t.key && (t.stopPropagation(),
            t.preventDefault(),
            this.#B("cancelRenameInput"))
        }
        async F7t() {
            if (this.#i && this.#a) {
                const t = await this.#i.KAs();
                if (this.#o)
                    return;
                this.#a.setModel(t)
            }
        }
        #S() {
            if (!this.#a || this.#h)
                return;
            const t = globalThis.app.r0();
            this.#a.updateOptions({
                fontSize: t.textEditorFontSize || 12,
                autoIndent: t.textEditorAutoIndent ? "advanced" : "keep",
                wordWrap: t.textEditorEnableWordWrap ? "on" : "off",
                minimap: {
                    enabled: t.textEditorEnableMinimap,
                    scale: t.textEditorMinimapScale
                },
                stickyScroll: {
                    enabled: t.textEditorEnableStickyScrolling
                },
                folding: t.textEditorEnableCodeFolding
            })
        }
        Ngt() {
            return this.#t
        }
        Dgt() {
            return this.#n
        }
        fA() {
            this.#a && this.#a.layout()
        }
        Vgt() {
            return this.#a ? this.#a.getContentHeight() : 0
        }
        #I() {
            const t = globalThis.app
              , i = this.#u
              , e = this.#a.getModel().getValueLength();
            if (this.#u = e,
            this.#i && !t.jU()) {
                if (this.#i.mte()instanceof globalThis.fh)
                    this.#i.ZAs(this.#a.getModel().getLineCount());
                else if (this.#w) {
                    const [t,i] = this.#F();
                    this.#i.ZAs(i - t)
                }
                if (e > i && this.#i.yn().xni() > t.rri())
                    return this.F_(),
                    void t.gU(this.#i.yn(), 2)
            }
            if (this.dispatchEvent(new cp.Event("change")),
            this.#s && "imports-for-events" === this.#s.BU() && this.#e.cgt(this.#l).rPs(),
            this.#s && !this.#i) {
                if (this.#c)
                    return;
                const t = this.#a.getValue();
                this.#s.Yxs(t)
            }
        }
        #P() {
            this.dispatchEvent(new cp.Event("contentsizechange"))
        }
        iqe() {
            return this.#a ? this.#a.getModel().getVersionId() : 0
        }
        VB() {
            return this.#a ? this.#a.getValue() : ""
        }
        pa(t) {
            this.#a && this.#a.setValue(t)
        }
        LA() {
            if (this.#a)
                return this.#a.getModel().canUndo()
        }
        F_() {
            this.#B("undo")
        }
        zA() {
            if (this.#a)
                return this.#a.getModel().canRedo()
        }
        K_() {
            this.#B("redo")
        }
        Cut() {
            this.#B("editor.action.clipboardCutAction")
        }
        u6s() {
            this.#B("editor.action.clipboardCopyAction")
        }
        eH() {
            this.#B("editor.action.clipboardPasteAction")
        }
        lD() {
            this.#B("deleteAllRight")
        }
        BK() {
            if (!this.#a)
                return !1;
            const t = this.#a.getSelection();
            return !!t && (t.selectionStartLineNumber !== t.positionLineNumber || t.selectionStartColumn !== t.positionColumn)
        }
        M7t(t, i) {
            this.#a && this.#a.setPosition({
                column: i,
                lineNumber: t
            })
        }
        R7t(t, i, e, s) {
            this.#a && this.#a.setSelection({
                startLineNumber: t,
                startColumn: i,
                endLineNumber: e,
                endColumn: s
            })
        }
        kgt(t, i) {
            if (!this.#a)
                return;
            const e = this.#a.getTargetAtClientPoint(t, i);
            e && e.position && this.#a.setPosition(e.position)
        }
        y7t() {
            this.#a && this.#a.revealRangeInCenter(this.#a.getSelection(), 0)
        }
        #G(t) {
            t.event.browserEvent.stopPropagation();
            const i = cp.p.Ok("ui.bars.textEditor.context-menu");
            t.event.preventDefault();
            const e = t.event.posx
              , s = t.event.posy
              , n = cp.v(cp.qs.Ek, this.#t);
            "javascript" !== this.#l && "typescript" !== this.#l || (n.Pk(null, i(".go-to-definition"), () => this.eqe()),
            n.Pk(null, i(".peek-definition"), () => this.ZKe()),
            n.Pk(null, i(".find-references"), () => this.sqe()),
            n.Pk(null, i(".go-to-symbol"), () => this.nqe()),
            n.Pk("edit", i(".rename"), () => this.GB()),
            this.#h || (n.Pk(null, i(".change-all-occurrences"), () => this.rqe()),
            n.Pk(null, i(".format-document"), () => this.hqe())),
            n.Nk()),
            "json" === this.#l && (n.Pk("json", dp("ui.bars.textEditor.beautify"), () => this.hqe()),
            n.Pk("json", dp("ui.bars.textEditor.minify"), () => this.#U()),
            n.Nk()),
            "html" !== this.#l && "css" !== this.#l || (n.Pk(null, i(".format-document"), () => this.hqe()),
            n.Nk());
            const r = this.LA()
              , h = this.zA();
            (r || h) && (n.BD(),
            r && n.Pk("undo", dp("main-menu.undo"), () => this.F_()),
            h && n.Pk("redo", dp("main-menu.redo"), () => this.K_()),
            n.MD(),
            n.Nk());
            let o = !1;
            this.BK() && (n.Pk("delete", dp("common.delete"), () => this.lD()),
            n.Nk(),
            n.BD(),
            o = !0,
            n.Pk("cut", dp("common.cut"), () => this.Cut(), {
                Ck: !0
            }),
            n.Pk("copy", dp("common.copy"), () => this.u6s(), {
                Ck: !0
            })),
            n.Pk("paste", dp("common.paste"), () => this.eH(), {
                Ck: !0
            }),
            o && n.MD(),
            this.#h || (n.Nk(),
            n.Pk(null, i(".command-palette"), () => this.oqe())),
            n.nF(e, s)
        }
        eqe() {
            this.#B("editor.action.revealDefinition")
        }
        sqe() {
            this.#B("editor.action.goToReferences")
        }
        nqe() {
            this.#B("editor.action.quickOutline")
        }
        ZKe() {
            this.#B("editor.action.peekDefinition")
        }
        aqe() {
            this.#B("editor.action.peekReferences")
        }
        GB() {
            this.#B("editor.action.rename")
        }
        rqe() {
            this.#B("editor.action.changeAll")
        }
        hqe() {
            this.#B("editor.action.formatDocument")
        }
        #U() {
            if (!this.#a)
                return;
            const t = this.#a.getValue();
            let i = null;
            try {
                i = JSON.parse(t)
            } catch (t) {
                (() => {})("Error parsing JSON: ", t);
                return void cp.qs.Ys.$s("OK").Qa(dp("ui.bars.textEditor.validation-error"))
            }
            this.#a.setValue(JSON.stringify(i))
        }
        oqe() {
            this.#B("editor.action.quickCommand")
        }
        zgt() {
            this.#B("hideSuggestWidget")
        }
        #B(t) {
            this.#a && this.#a.trigger("construct", t)
        }
        Wgt() {
            if (!this.#a)
                return !1;
            const t = this.#p.querySelector(".suggest-widget");
            if (!t)
                return !1;
            return "none" !== globalThis.getComputedStyle(t).getPropertyValue("display")
        }
        async #O(t) {
            if (t.mAs)
                return;
            const i = await cp.gle(this.#s.xc());
            this.#o || (this.#c = !0,
            this.#a.setValue(i),
            this.#c = !1)
        }
        C7t() {
            return this.#c
        }
        static #N(t) {
            return "file://" + encodeURI(t).replace(/[^A-Za-z0-9%_\-\.\\/]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`)
        }
        static async kni(i) {
            const e = await t.#j(i, "javascript");
            return e || await t.#j(i, "typescript")
        }
        static async #j(i, e) {
            if (!i.VU(e, !0))
                return null;
            try {
                await cp.fgt._gt()
            } catch (t) {
                return console.error("Failed to load code editor: ", t),
                null
            }
            const s = [...i.TPs(e)].map(t => t.Egt())
              , [n,r] = await Promise.all([Promise.all(s.map(t => t.KAs())), i.cgt(e).KAs()])
              , h = [...n, r];
            s.push(i.cgt(e));
            const o = await bp.languages.typescript["javascript" === e ? "getJavaScriptWorker" : "getTypeScriptWorker"]()
              , a = h.map(t => t.uri)
              , l = await o(...a)
              , u = Promise.all(a.map(i => l.getSyntacticDiagnostics(t.#N(i.path))));
            let c = Promise.resolve([]);
            "typescript" === e && (c = Promise.all(a.map(i => l.getSemanticDiagnostics(t.#N(i.path)))));
            const [d,f] = await Promise.all([u, c])
              , p = t.#$(d, f, s, h);
            return p || null
        }
        static #$(t, i, e, s) {
            for (let n = 0, r = t.length; n < r; ++n) {
                const r = t[n]
                  , h = i[n]
                  , o = r.slice(0);
                Array.isArray(h) && cp.bp(o, h);
                const a = e[n]
                  , l = s[n];
                for (const t of o)
                    if (1 === t.category) {
                        const i = "string" == typeof t.messageText ? t.messageText : t.messageText.messageText
                          , e = l.getPositionAt(t.start).lineNumber;
                        if (a instanceof globalThis.QAs) {
                            const t = a.dPs(e);
                            if (!t) {
                                (() => {})("Failed to identify event sheet script for script error; ignoring");
                                continue
                            }
                            const s = t.VP;
                            if (s instanceof globalThis.fh)
                                return {
                                    D5s: s,
                                    WPe: {
                                        line: e - 1,
                                        message: i
                                    }
                                };
                            if (!s.wgt())
                                continue;
                            const n = Math.min(e - t.pPs - 1, cp.YAs(s.vgt(), "\n"));
                            return {
                                D5s: s,
                                WPe: {
                                    line: n,
                                    message: i
                                }
                            }
                        }
                        return {
                            D5s: a.mte(),
                            WPe: {
                                line: e - 1,
                                message: i
                            }
                        }
                    }
            }
            return null
        }
        static MPs() {
            Ep && Ep.dispose(),
            Ep = bp.languages.typescript.typescriptDefaults.addExtraLib(`/* dummy lib ${Math.floor(1e6 * Math.random())} */`, "construct-internal/__dummy_lib__.js")
        }
        static async Fni(i, e) {
            if (!cp.fgt.dgt())
                return;
            const s = new Set([...Mp.keys()]);
            for (const [t,e] of i)
                if (s.delete(t),
                Mp.has(t)) {
                    const i = Mp.get(t);
                    i.model.getValue() !== e && (i.model.setValue(e),
                    i.lqe.dispose(),
                    i.lqe = bp.languages.typescript.typescriptDefaults.addExtraLib(e, t))
                } else {
                    const i = bp.editor.createModel(e, "typescript", bp.Uri.parse(t))
                      , s = bp.languages.typescript.typescriptDefaults.addExtraLib(e, t);
                    Mp.set(t, {
                        model: i,
                        lqe: s
                    })
                }
            for (const t of s) {
                const {model: i, lqe: e} = Mp.get(t);
                e.dispose(),
                i.dispose(),
                Mp.delete(t)
            }
            t.#M(e)
        }
        static async ixe(i) {
            if (!i.VU("typescript"))
                return null;
            try {
                await cp.fgt._gt()
            } catch (t) {
                return console.error("Failed to load code editor: ", t),
                null
            }
            const e = globalThis.app.ZPe(globalThis.lang("ui.bars.textEditor.compiling-typescript"));
            e.Ej();
            try {
                const e = [...i.TPs("typescript")].filter(t => "imports-for-events" !== t.BU())
                  , s = e.map(t => t.Egt())
                  , n = await Promise.all(s.map(t => t.KAs()));
                let r = null;
                if (i.Oii("typescript")) {
                    const t = i.cgt("typescript")
                      , e = await t.lPs(!0);
                    r = bp.editor.createModel(e, "typescript", bp.Uri.parse("/" + cp.Ars.cPs() + `project/__c3_tsInEvents_temp${Math.floor(1e6 * Math.random())}__.ts`)),
                    n.push(r)
                }
                const h = await bp.languages.typescript.getTypeScriptWorker()
                  , o = n.map(t => t.uri)
                  , a = await h(...o)
                  , l = await Promise.all(o.map(i => a.getEmitOutput(t.#N(i.path))))
                  , u = {
                    nxe: null,
                    exe: []
                };
                let c = 0;
                for (const t of l) {
                    const i = n[c]
                      , s = e[c];
                    ++c;
                    const h = t.outputFiles.filter(t => t.name.toLowerCase().endsWith(".js"));
                    if (0 === h.length)
                        continue;
                    if (h.length > 1)
                        throw console.error("Unexpected TypeScript compiler output - got multiple output files: ", h),
                        new Error("typescript compile error");
                    const o = h[0];
                    i === r ? u.nxe = o.text : u.exe.push([s, o.text])
                }
                return r && r.dispose(),
                u
            } finally {
                e.he()
            }
        }
        static YKe(t, i, e) {
            const s = bp.languages.CompletionItemKind
              , n = e.triggerCharacter;
            if (!vp)
                return null;
            let r = null;
            const h = t.uri.path
              , o = globalThis.QAs.XAs(h);
            if (o)
                r = o.yn();
            else {
                const t = globalThis.eAs.XAs(h);
                t && (r = t.yn())
            }
            const a = Sp.get(h)
              , l = t.getValueInRange({
                startLineNumber: i.lineNumber,
                startColumn: 0,
                endLineNumber: i.lineNumber,
                endColumn: i.column
            })
              , u = globalThis.Gas.Pxe(l);
            if (0 === u.length)
                return;
            if (u.reverse(),
            cp.qcs(cp.eu(u[0])))
                return;
            const c = new Map
              , d = [];
            function f(t) {
                let i = c.get(t.name);
                i ? t.interfaceName && i.uqe.add(t.interfaceName) : (t.uqe = new Set(t.interfaceName ? [t.interfaceName] : []),
                c.set(t.name, t),
                d.push(t))
            }
            let p = !0;
            if ("runtime" === u[0] || "#runtime" === u[0])
                for (const t of vp.properties.IRuntime)
                    f({
                        name: t,
                        kind: "Property",
                        interfaceName: "IRuntime"
                    });
            else if ("behaviors" === u[0]) {
                if (r)
                    for (const t of r.MDt())
                        if (t.Ja().$N())
                            for (const i of t.yus())
                                f({
                                    name: i.Fa(),
                                    kind: "Field",
                                    description: i.sxt().Fa()
                                })
            } else if ("localVars" === u[0]) {
                if (r && a && a.Dgt())
                    for (const t of r.SPs(a.Dgt()))
                        t.pX() || f({
                            name: t.ZSt(),
                            kind: "Variable",
                            description: t.Ret() || " "
                        })
            } else if (u.length >= 2 && ("runtime" === u[1] || "#runtime" === u[1])) {
                const t = u[0]
                  , i = new Map([["mouse", "IMouseObjectType"], ["keyboard", "IKeyboardObjectType"], ["touch", "ITouchObjectType"], ["layout", "ILayout"], ["assets", "IAssetManager"], ["collisions", "ICollisionEngine"], ["storage", "IStorage"], ["platformInfo", "IPlatformInfo"]]);
                if ("objects" === t) {
                    if (r)
                        for (const t of r.MDt())
                            f({
                                name: t.Fa(),
                                kind: "Field",
                                description: t.Ja().Fa()
                            })
                } else if ("globalVars" === t) {
                    if (r)
                        for (const t of r.bPs())
                            f({
                                name: t.ZSt(),
                                kind: "Variable",
                                description: t.Ret() || " "
                            })
                } else if (i.has(t)) {
                    const e = i.get(t);
                    for (const t of vp.properties[e])
                        f({
                            name: t,
                            kind: "Property",
                            interfaceName: e
                        })
                }
            } else if ("." === n) {
                p = !1;
                for (const [t,i] of Object.entries(vp.properties))
                    if ("global" !== t)
                        for (const e of i)
                            f({
                                name: e,
                                kind: "Property",
                                interfaceName: t
                            })
            }
            d.sort( (t, i) => cp.vhi(t.name, i.name));
            const m = new Intl.ListFormat(globalThis.app.iwt(),{
                style: "long",
                type: "conjunction"
            });
            return {
                suggestions: d.map(t => {
                    let i = t.description
                      , e = null;
                    if (!i) {
                        const s = t.uqe;
                        1 === s.size ? i = cp.eu(s) : (i = fp("ui.bars.textEditor.autocomplete.multiple-interfaces-description", null, s.size),
                        e = m.format([...s].sort(cp.vhi)))
                    }
                    const n = {
                        insertText: t.name,
                        documentation: e,
                        kind: s[t.kind],
                        label: {
                            description: i,
                            label: t.name
                        }
                    };
                    return p && (n.sortText = " " + t.name),
                    n
                }
                )
            }
        }
    }
}
{
    const Rp = self.t
      , kp = self.assert;
    Rp.E0t = {},
    Rp.E0t.ces = function(t) {
        return Rp.L5s((((i = t).startsWith("/") || i.startsWith("\\")) && (i = i.substring(1)),
        (i.endsWith("/") || i.endsWith("\\")) && (i = i.substring(0, i.length - 1)),
        i), "\\", "/");
        var i
    }
    ;
    const Op = Rp.v(Rp.j1t, 8);
    async function Dp(t, i) {
        const e = await t.createWritable();
        await e.write(i),
        await e.close()
    }
    Rp.E0t.B0t = function(t, i) {
        return Rp.U(t, FileSystemFileHandle),
        Op.cR( () => Dp(t, i))
    }
    ,
    Rp.E0t.yPs = async function(t, i, e) {
        Rp.U(t, FileSystemDirectoryHandle),
        Rp.zt(i);
        const s = await t.getFileHandle(i, {
            create: !0
        });
        await Rp.E0t.B0t(s, e)
    }
    ;
    const Fp = Rp.v(Rp.j1t, 8);
    async function Lp(t) {
        const i = await Rp.fAs(t);
        return await Rp.Crypto.dAs(i)
    }
    async function Bp(t, i) {
        try {
            const e = await t.getFile();
            if ("string" == typeof i) {
                let t = await Rp.gle(e);
                if (t = Rp.L5s(t, "\r\n", "\n"),
                i === t)
                    return
            } else if (e.size === i.size) {
                const t = await Lp(e);
                if (t === await Lp(i))
                    return
            }
        } catch (i) {
            (() => {})(`Error reading file '${t.name}' to check for changes; proceeding to overwrite file: `, i)
        }
        await Rp.E0t.B0t(t, i)
    }
    function Up(t) {
        const i = Rp.qs.Ys.$s("Confirm");
        return new Promise( (e, s) => {
            i.sOe = async () => {
                Rp.qs.cqe.Ej();
                try {
                    "granted" === await t.requestPermission({
                        mode: "readwrite"
                    }) ? e() : s(new Error("folder write permission denied"))
                } catch (t) {
                    s(t)
                } finally {
                    Rp.qs.cqe.Cj()
                }
            }
            ;
            const n = "ui.folder-write-access-prompt";
            i.Qa({
                caption: self.lang(n + ".caption"),
                message: self.lang(n + ".message"),
                jD: self.lang(n + ".confirm-text")
            }).then(t => {
                null === t && s(new Error("folder write permission denied"))
            }
            )
        }
        )
    }
    Rp.E0t.dqe = async function(t, i, e) {
        Rp.U(t, FileSystemDirectoryHandle),
        Rp.zt(i);
        const s = await t.getFileHandle(i, {
            create: !0
        });
        await Fp.cR( () => Bp(s, e))
    }
    ,
    Rp.E0t.ues = async function(t, i, e) {
        if (Rp.U(t, FileSystemDirectoryHandle),
        Rp.zt(i),
        e = !!e,
        !(i = Rp.E0t.ces(i)))
            return t;
        const s = i.split("/");
        let n = t;
        for (const t of s)
            n = await n.getDirectoryHandle(t, {
                create: e
            });
        return n
    }
    ,
    Rp.E0t.uAs = async function(t, i) {
        if (Rp.U(t, FileSystemDirectoryHandle),
        Rp.zt(i),
        !(i = Rp.E0t.ces(i)))
            throw new Error("empty path");
        const e = i.split("/");
        let s = t;
        for (let t = 0, i = e.length - 1; t < i; ++t) {
            const i = e[t];
            s = await s.getDirectoryHandle(i, {
                create: !1
            })
        }
        return s.getFileHandle(e.at(-1), {
            create: !1
        })
    }
    ,
    Rp.E0t.fqe = async function(t, i) {
        return Rp.E0t.ues(t, i, !0)
    }
    ,
    Rp.E0t.pqe = async function(t) {
        if (Rp.U(t, FileSystemDirectoryHandle),
        navigator.userActivation && navigator.userActivation.isActive)
            return;
        const i = await t.queryPermission({
            mode: "readwrite"
        });
        if ("granted" !== i) {
            if ("denied" === i)
                throw new Error("folder write permission denied");
            "prompt" === i && await Up(t)
        }
    }
    ,
    Rp.E0t.PPs = async function(t, i, e, s=!1) {
        Rp.U(t, FileSystemDirectoryHandle),
        Rp.U(i, Map),
        Rp.X_t(e);
        const n = new Map;
        for (const t of i.keys())
            n.set(Rp.tk(t), null);
        for (const i of n.keys()) {
            const e = await Rp.E0t.fqe(t, i);
            n.set(i, e)
        }
        const r = [];
        for (const [t,e] of i) {
            const i = Rp.des(t)
              , h = n.get(Rp.tk(t));
            kp(void 0 !== h, "cannot find folder handle"),
            s ? r.push(Rp.E0t.dqe(h, i, e)) : r.push(Rp.E0t.yPs(h, i, e))
        }
        return e ? Rp.RPe(r, e) : Promise.all(r)
    }
    ,
    Rp.E0t.mqe = async function(t, i) {
        Rp.U(t, FileSystemDirectoryHandle);
        const e = new Map;
        for (const t of i)
            e.set(Rp.tk(t), null);
        for (const i of e.keys()) {
            const s = await Rp.E0t.ues(t, i, !1);
            e.set(i, s)
        }
        const s = [];
        for (const t of i) {
            const i = Rp.des(t)
              , n = e.get(Rp.tk(t));
            kp(void 0 !== n, "cannot find folder handle"),
            s.push((async () => {
                try {
                    await n.removeEntry(i, {
                        recursive: !1
                    })
                } catch (t) {
                    if ("NotFoundError" !== t.name)
                        throw t
                }
            }
            )())
        }
        return Promise.all(s)
    }
    ,
    Rp.E0t.wqe = async function(t, i) {
        Rp.U(t, FileSystemDirectoryHandle);
        for (let e of i) {
            (e.endsWith("\\") || e.endsWith("/")) && (e = e.substr(0, e.length - 1));
            const i = Rp.des(e)
              , s = Rp.tk(e)
              , n = await Rp.E0t.ues(t, s, !1);
            try {
                await n.removeEntry(i, {
                    recursive: !1
                })
            } catch (t) {
                if ("NotFoundError" !== t.name)
                    throw t
            }
        }
    }
    ,
    Rp.E0t.gqe = async function(t, i) {
        Rp.U(t, FileSystemDirectoryHandle),
        Rp.zt(i),
        i = i.toLowerCase();
        for await(const e of t.values())
            if ("file" === e.kind && e.name.toLowerCase().endsWith(i))
                return e;
        return null
    }
    ,
    Rp.E0t.gPs = async function(t, i) {
        Rp.U(t, FileSystemDirectoryHandle),
        Rp.zt(i);
        try {
            return !!await Rp.E0t.uAs(t, i)
        } catch (t) {
            return !1
        }
    }
    ,
    Rp.E0t.JHi = async function(t, i) {
        Rp.U(t, FileSystemDirectoryHandle),
        Rp.zt(i);
        const e = await Rp.E0t.uAs(t, i);
        if (e)
            return await e.getFile()
    }
}
{
    const Np = self.t;
    Np.p.ik("lib/ui/lang");
    const jp = ["fr", "px", "mm", "cm", "in", "pt", "pc", "vh", "vw", "vmin", "vmax", "em", "ex", "ch", "rem"]
      , $p = ["auto", "top", "bottom", "options"];
    let zp = !1
      , Vp = null
      , Wp = window.innerWidth
      , Hp = window.innerHeight;
    window.addEventListener("resize", () => {
        Wp = window.innerWidth,
        Hp = window.innerHeight,
        document.scrollingElement.scrollTop = 0,
        setTimeout( () => {
            Wp = window.innerWidth,
            Hp = window.innerHeight,
            document.scrollingElement.scrollTop = 0;
            const t = new CustomEvent("after-resize",{
                bubbles: !0,
                cancelable: !0,
                detail: {}
            });
            window.dispatchEvent(t)
        }
        , 250)
    }
    , !0);
    let Kp = NaN
      , qp = NaN
      , Xp = NaN;
    if (Np.qs = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static yqe() {
            return zp
        }
        static JNe(t) {
            (t = !!t) !== zp && (zp = t,
            document.getElementsByTagName("body")[0].dir = t ? "rtl" : "ltr")
        }
        static BW(t) {
            Np.Hdt(t),
            t && t.parentElement && t.parentElement.removeChild(t)
        }
        static bqe(t) {
            Np.zt(t),
            Np.qs.BW(document.getElementById(t))
        }
        static vqe(t) {
            Np.zt(t);
            let i = document.querySelectorAll(t);
            for (let t = 0, e = i.length; t < e; ++t)
                Np.qs.BW(i[t])
        }
        static lk(t, i, e, s, n, r) {
            Np.zt(t),
            Np.Hdt(i),
            Np.Kq(e),
            Np.Wat(n),
            Np.cO(r);
            let h = document;
            i && (h = i.ownerDocument);
            let o = h.createElement(t);
            if (e && (o.id = e),
            s && (o.className = s),
            n)
                for (let[t,i] of Object.entries(n))
                    "string" == typeof i ? o.setAttribute(t, i) : o.setAttribute(t, "");
            return i ? (Np.qs.DHt(o, i, r),
            o) : o
        }
        static DHt(t, i, e) {
            if (Np.zlt(t),
            Np.zlt(i),
            Np.cO(e),
            Np.Go(e)) {
                const s = i.children;
                s.length > 0 ? e <= 0 ? i.insertBefore(t, s[0]) : e > 0 && e < s.length ? i.insertBefore(t, s[e]) : i.appendChild(t) : i.appendChild(t)
            } else
                i.appendChild(t)
        }
        static BYt(t) {
            Np.Hdt(t),
            t && (t.replaceChildren ? t.replaceChildren() : t.innerHTML = "")
        }
        static Sqe(t) {
            Np.zlt(t),
            t.offsetHeight
        }
        static CD(t, i, e) {
            Np.zlt(t),
            Np.zt(i),
            e ? t.setAttribute(i, "") : t.removeAttribute(i)
        }
        static xqe(t, i) {
            Np.zlt(t),
            Np.zt(i),
            Np.qs.CD(t, i, !t.hasAttribute(i))
        }
        static Mqe(t) {
            Vp = t
        }
        static Eqe() {
            return Vp
        }
        static Cqe(t) {
            return t === Vp
        }
        static _qe() {
            return Wp
        }
        static Tqe() {
            return Hp
        }
        static Iqe() {
            let t = Np.qs.Eqe();
            t && t.Pqe(),
            Np.qs.RW.Gqe(!0)
        }
        static Aqe(t) {
            Np.zt(t);
            let i = parseFloat(t);
            if (i < 0)
                return !1;
            if (0 === i)
                return !0;
            let e = t.toLowerCase();
            for (let t = 0, i = jp.length; t < i; ++t)
                if (e.endsWith(jp[t]))
                    return !0;
            return !1
        }
        static WB(t, i, e="auto", s={}) {
            if (Np.zlt(t),
            Np.Hdt(i),
            Np.zt(e),
            Np._U(s),
            !$p.includes(e))
                throw new Error(`"${e}" is not a supported value. Use any of: ${$p.toString()}`);
            i || (i = Np.Yke(t));
            const n = t.getBoundingClientRect()
              , r = i.getBoundingClientRect();
            switch (e) {
            case "auto":
                n.top < r.top ? (t.scrollIntoView(!0),
                i.scrollTop -= 5) : n.bottom > r.bottom && (t.scrollIntoView(!1),
                i.scrollTop += 5);
                break;
            case "top":
                t.scrollIntoView(!0),
                i.scrollTop -= 5;
            case "bottom":
                t.scrollIntoView(!1),
                i.scrollTop += 5;
            case "options":
                n.top >= r.top && n.left >= r.left && n.bottom <= r.bottom && n.right <= r.right || t.scrollIntoView(s)
            }
        }
        static yQ(t, i) {
            if (Np.Wat(i),
            i || (i = {}),
            !Np.doe(t) && !Np.kft(t))
                throw new Error("unexpected argument");
            let e = i.parent || document.body
              , s = i.tag || "div"
              , n = i.vQ || null
              , r = i.Rqe
              , h = i.className
              , o = i.id
              , a = !1;
            n || (n = document.createElement(s),
            a = !0),
            r && n.setAttribute(r, ""),
            h && (n.className = h),
            o && (n.id = o),
            a && e.appendChild(n);
            let l, u = window.getComputedStyle(n);
            if (Np.doe(t))
                l = u.getPropertyValue(t);
            else if (Np.kft(t))
                for (let i of t)
                    if (l = u.getPropertyValue(i),
                    l)
                        break;
            return a && e.removeChild(n),
            l
        }
        static uA() {
            if (isNaN(Kp)) {
                let t = Np.qs.yQ("width", {
                    className: "width100em"
                });
                if (!t.endsWith("px"))
                    throw new Error("expected em size in px");
                Kp = parseFloat(t) / 100
            }
            return Kp
        }
        static pGt() {
            if (isNaN(qp)) {
                const t = Np.qs.yQ("--window-border-size");
                if (!t.endsWith("px"))
                    throw new Error("--window-border-size must specify size in units of 'px'");
                qp = parseFloat(t) || 7
            }
            return qp
        }
        static kqe() {
            if (isNaN(Xp)) {
                let t = Np.qs.yQ("--window-thin-border-size");
                if (!t.endsWith("px"))
                    throw new Error("--window-border-size must specify size in units of 'px'");
                Xp = parseFloat(t) || 1
            }
            return Xp
        }
        static Oqe() {
            return Np.qs.pGt()
        }
        static Lzt(t) {
            t.preventDefault()
        }
        static dot(t) {
            t.stopPropagation()
        }
        static ck(t) {
            t.preventDefault(),
            t.stopPropagation()
        }
        static GY(t, i, e, s) {
            return Np.Ge(t),
            Np.Ge(i),
            Np.Mw(e, Np.qs.fA.W6t),
            e && !s && (s = e.jW()),
            Np.qs.Ek.DTi(t, i, s) || Np.qs.HY.DTi(t, i, s) || Np.qs.RW.Dqe(t, i, e)
        }
        static Fqe() {
            const t = document.body.parentElement;
            if (t.removeAttribute("mobile"),
            t.removeAttribute("desktop"),
            Np.kt && Np.kt.mj ? t.setAttribute("mobile", "") : t.setAttribute("desktop", ""),
            Np.kt.V7i) {
                const t = document.createElement("link");
                t.rel = "stylesheet",
                t.href = "loader/iosOnlyStyles.css",
                document.head.appendChild(t)
            }
        }
        static Lqe() {
            return "function" == typeof window.getScreenDetails
        }
        static async Bqe() {
            if (Np.qs.Lqe())
                try {
                    await window.getScreenDetails()
                } catch (t) {
                    (() => {})("Failed to get window management permission: ", t)
                }
        }
    }
    ,
    "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", Np.qs.Fqe) : (Np.qs.Fqe(),
    CSS.supports("contain", "content") || document.body.parentElement.setAttribute("no-containment", "")),
    !Np.Vl) {
        let Yp = new Set(["input", "textarea", "datalist"]);
        document.addEventListener("contextmenu", t => {
            let i = t.target
              , e = i.tagName.toLowerCase();
            Yp.has(e) || Np.Uis(i) || t.preventDefault()
        }
        ),
        document.addEventListener("mousewheel", t => {
            (Np.OF.j1(t) || t.ctrlKey) && t.preventDefault()
        }
        , {
            passive: !1
        }),
        document.addEventListener("wheel", t => {
            (Np.OF.j1(t) || t.ctrlKey) && t.preventDefault()
        }
        , {
            passive: !1
        })
    }
}
{
    const Jp = self.t
      , Zp = new WeakMap;
    function Qp(t) {
        let i = Zp.get(t);
        return i || (i = Jp.v(Jp.qs.SH.Document, t),
        Zp.set(t, i)),
        i
    }
    class tm {
        constructor() {
            throw new Error("static class")
        }
        static u(t, i) {
            Jp.rAe(t, "#document"),
            Jp.Mw(i, Jp.qs.Ys),
            Qp(t).u(i)
        }
        static j(t) {
            Qp(t).j()
        }
        static gAt(t, i, e) {
            return Qp(t).Uqe().gAt(i, e)
        }
        static gH(t, i, e, s, n) {
            return Qp(i).Uqe().Nqe(t, e, s, n)
        }
        static CH(t) {
            Jp.Mw(t, Jp.qs.SH.jqe),
            t && t.dMt().$qe(t)
        }
        static vDt(t) {
            const i = Qp(t);
            return [i.M1(), i.G1()]
        }
    }
    Jp.qs.SH = tm
}
{
    const im = self.t;
    class em {
        constructor(t) {
            im.rAe(t, "#document"),
            this.AYi = t,
            this.zqe = [],
            this.C3 = 0,
            this.R3 = 0,
            this.AYi.addEventListener("pointermove", t => {
                this.C3 = t.clientX,
                this.R3 = t.clientY
            }
            , !0),
            this.u()
        }
        PH() {
            return this.AYi
        }
        Uqe() {
            return this.zqe.at(-1)
        }
        M1() {
            return this.C3
        }
        G1() {
            return this.R3
        }
        u(t) {
            this.zqe.length > 0 && this.zqe.at(-1).Vqe(),
            this.zqe.push(im.v(im.qs.SH.Tj, this, t))
        }
        j() {
            if (this.zqe.length <= 1)
                throw new Error("cannot pop last context");
            this.zqe.pop().he(),
            this.zqe.at(-1).ski()
        }
    }
    im.qs.SH.Document = em
}
{
    const sm = self.t
      , nm = 128
      , rm = "default"
      , hm = new Map([["progress", "cursorBackgroundWait"], ["wait", "cursorWait"], ["crosshair", "cursorCrosshair"], ["move", "cursorMove"], ["not-allowed", "cursorNotAllowed"], ["col-resize", "cursorResizeCol"], ["row-resize", "cursorResizeRow"], ["ns-resize", "cursorResizeNS"], ["ew-resize", "cursorResizeEW"], ["nwse-resize", "cursorResizeNWSE"], ["nesw-resize", "cursorResizeNESW"], ["grab", "cursorGrab"], ["grabbing", "cursorGrabbing"], ["rotate-topleft", "cursorRotateTL"], ["rotate-top", "cursorRotateTop"], ["rotate-topright", "cursorRotateTR"], ["rotate-right", "cursorRotateRight"], ["rotate-bottomright", "cursorRotateBR"], ["rotate-bottom", "cursorRotateBottom"], ["rotate-bottomleft", "cursorRotateBL"], ["rotate-left", "cursorRotateLeft"], ["pointer", "cursorPointer"]]);
    class om {
        constructor(t, i) {
            sm.U(t, sm.qs.SH.Document),
            this.Wqe = t,
            this.bWt = i,
            this.jbi = i ? i.hk() : t.PH().body,
            this.Vd = !0,
            this.Hqe = [],
            this.Kqe = null,
            this.qqe = "",
            this.Xqe = t => {
                this.Yqe(t.clientX - nm / 2, t.clientY - nm / 2)
            }
            ,
            this.Kqe = sm.qs.lk("div", this.jbi, null, "docCursorOverlayElem"),
            this.Jqe()
        }
        he() {
            this.Vd && this.Vqe(),
            sm.sc(this.Hqe),
            sm.qs.BW(this.Kqe),
            this.Kqe = null,
            this.Xqe = null,
            this.jbi = null,
            this.Wqe = null
        }
        PH() {
            return this.Wqe.PH()
        }
        jW() {
            return this.PH().defaultView
        }
        Zqe() {
            return this.Kqe
        }
        Qqe() {
            return this.qqe
        }
        tXe(t) {
            sm.zt(t),
            this.qqe = t
        }
        Yqe(t, i) {
            sm.Ge(t),
            sm.Ge(i);
            let e = 0
              , s = 0;
            this.bWt && (e = this.bWt.byi(),
            s = this.bWt.yyi()),
            this.Kqe.style.transform = `translate(${t - e}px,${i - s}px)`
        }
        Jqe() {
            this.Yqe(2 * -nm, 2 * -nm)
        }
        ski() {
            if (this.Vd)
                throw new Error("already active");
            const t = this.Hqe;
            t.length > 0 && (this.jW().addEventListener("pointermove", this.Xqe, !0),
            t.at(-1).iXe()),
            this.Vd = !0
        }
        Vqe() {
            if (!this.Vd)
                throw new Error("already inactive");
            const t = this.Hqe;
            t.length > 0 && (t.at(-1).bx(),
            this.jW().removeEventListener("pointermove", this.Xqe, !0),
            this.Jqe()),
            this.Vd = !1
        }
        eXe(t) {
            sm.U(t, sm.qs.SH.jqe);
            const i = this.Hqe
              , e = i.length;
            return e > 0 && i[e - 1] === t
        }
        Nqe(t, i, e, s) {
            if (sm.zt(t),
            t !== rm && !hm.has(t))
                throw new RangeError(`invalid mouse cursor name '${t}'`);
            sm.Go(i) && sm.Go(e) || (i = this.Wqe.M1(),
            e = this.Wqe.G1());
            const n = this.Hqe;
            if (n.length >= 100)
                throw new Error("pushed too many mouse cursors");
            const r = sm.v(sm.qs.SH.jqe, this, t, s);
            return this.Vd && (0 === n.length ? this.jW().addEventListener("pointermove", this.Xqe, !0) : n.at(-1).bx(),
            r.iXe(),
            this.Yqe(i - nm / 2, e - nm / 2)),
            n.push(r),
            r
        }
        $qe(t) {
            if (sm.Mw(t, sm.qs.SH.jqe),
            !t)
                return;
            if (t.dMt() !== this)
                throw new Error("popping cursor in wrong context");
            const i = this.Hqe
              , e = i.indexOf(t);
            if (e < 0)
                return;
            const s = e === i.length - 1;
            i.splice(e, 1),
            t.he(),
            this.Vd && (0 === i.length ? (this.jW().removeEventListener("pointermove", this.Xqe, !0),
            this.Jqe()) : s && i.at(-1).iXe())
        }
        gAt(t, i) {
            sm.Ge(t),
            sm.Ge(i);
            const e = this.PH()
              , s = sm.Tnt(e, t, i);
            return s.length > 0 && s[0] === this.Kqe && s.shift(),
            s.length > 0 ? s[0] : null
        }
        static sXe() {
            return rm
        }
        static nXe() {
            return hm
        }
    }
    sm.qs.SH.Tj = om
}
{
    const am = self.t;
    class lm {
        constructor(t, i, e) {
            am.U(t, am.qs.SH.Tj),
            am.zt(i),
            am.Wat(e),
            this.TTt = t,
            this.rXe = i,
            this.gTt = e,
            this.hXe = null
        }
        dMt() {
            return this.TTt
        }
        PH() {
            return this.dMt().PH()
        }
        Zqe() {
            return this.dMt().Zqe()
        }
        Qqe() {
            return this.TTt.Qqe()
        }
        tXe(t) {
            this.TTt.tXe(t)
        }
        Set(t) {
            am.zt(t),
            this.rXe !== t && (this.rXe = t,
            this.TTt.eXe(this) && this.oXe())
        }
        iXe() {
            this.oXe(),
            this.aXe()
        }
        bx() {
            this.kYt(),
            this.lXe()
        }
        oXe() {
            if (this.rXe === am.qs.SH.Tj.sXe())
                return void this.kYt();
            const t = am.qs.SH.Tj.nXe().get(this.rXe);
            self.assert(t, "invalid cursor class"),
            this.Qqe() !== t && (this.kYt(),
            this.Zqe().classList.add(t),
            this.tXe(t))
        }
        kYt() {
            const t = this.Qqe();
            t && this.Zqe().classList.remove(t),
            this.tXe("")
        }
        aXe() {
            const t = this.Zqe()
              , i = this.gTt;
            if (!i)
                return;
            const e = i.y_t;
            e ? (this.hXe = t => am.Unt(t, e),
            t.addEventListener("pointerdown", this.hXe),
            t.addEventListener("mousewheel", this.hXe, {
                passive: !1
            })) : (i.onpointerdown && t.addEventListener("pointerdown", i.onpointerdown),
            i.onpointermove && t.addEventListener("pointermove", i.onpointermove),
            i.onpointerup && t.addEventListener("pointerup", i.onpointerup),
            i.onpointercancel && t.addEventListener("pointercancel", i.onpointercancel),
            i.onwheel && t.addEventListener("wheel", i.onwheel),
            i.contextmenu && t.addEventListener("contextmenu", i.contextmenu))
        }
        lXe() {
            const t = this.Zqe()
              , i = this.gTt;
            this.hXe ? (t.removeEventListener("pointerdown", this.hXe),
            t.removeEventListener("mousewheel", this.hXe, {
                passive: !1
            }),
            this.hXe = null) : i && (i.onpointerdown && t.removeEventListener("pointerdown", i.onpointerdown),
            i.onpointermove && t.removeEventListener("pointermove", i.onpointermove),
            i.onpointerup && t.removeEventListener("pointerup", i.onpointerup),
            i.onpointercancel && t.removeEventListener("pointercancel", i.onpointercancel),
            i.onwheel && t.removeEventListener("wheel", i.onwheel),
            i.contextmenu && t.removeEventListener("contextmenu", i.contextmenu))
        }
        he() {
            this.bx(),
            this.TTt = null,
            this.gTt = null
        }
    }
    am.qs.SH.jqe = lm
}
{
    const um = self.t;
    let cm = ""
      , dm = !1
      , fm = null
      , pm = null;
    const mm = new Map;
    um.qs.oX = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static SIt(t) {
            um.zt(t);
            const i = `theme/${t}/import.html`;
            return window.addImport(i, !0).then(t => {
                if (dm)
                    throw new Error("can't change theme at runtime yet");
                cm = um.tk(t.URL),
                dm = !0
            }
            )
        }
        static zrt() {
            if (!dm)
                throw new Error("theme not loaded yet");
            return cm
        }
        static uXe() {
            if (!dm)
                throw new Error("theme not loaded yet");
            return cm + "icons/"
        }
        static cXe() {
            return pm ? Promise.resolve(pm) : fm || (fm = um.Z1t(um.qs.oX.uXe() + "precompiled-icons.json").then(t => (pm = t,
            fm = null,
            pm)),
            fm)
        }
        static dXe() {
            return um.qs.oX.rX("--default-icon-color")
        }
        static rX(t, i) {
            um.zt(t),
            um.Hdt(i);
            let e = mm.get(t);
            return e || (e = um.qs.yQ(t, i ? {
                vQ: i
            } : null),
            mm.set(t, e),
            e)
        }
        static async fXe() {
            const t = [];
            for (const i of self.app.pXe())
                t.push(i.mXe());
            await Promise.all(t)
        }
        static wXe() {
            mm.clear(),
            um.qs.oX.fXe()
        }
        static qKe() {
            return "dark" === um.qs.oX.rX("--c3logo-type").trim()
        }
    }
}
{
    const wm = self.t
      , gm = self.assert
      , ym = new Map
      , bm = "PersistantMap"
      , vm = localforage.sBe({
        name: bm
    });
    function Sm() {
        Pm || vm.setItem(Cm, [...Mm]).catch(t => self.app.OA(t))
    }
    function xm() {
        Gm || vm.setItem(_m, [...Em]).catch(t => self.app.OA(t))
    }
    let Mm = new Map
      , Em = new Map;
    const Cm = "UI_STATE"
      , _m = "UI_USERDATA"
      , Tm = wm.v(wm.gP, Sm, 1e3)
      , Im = wm.v(wm.gP, xm, 1e3);
    let Pm = !1
      , Gm = !1;
    async function Am() {
        try {
            const t = await Promise.all([vm.getItem(Cm), vm.getItem(_m)]);
            Mm = new Map(t[0]),
            Em = new Map(t[1])
        } catch (t) {
            Mm = new Map,
            Em = new Map,
            console.error("[Construct] Error loading persistance data: ", t)
        }
    }
    wm.M9s.lVs("default-layout") || wm.KTe(Am());
    let Rm = -1
      , km = null;
    wm.qs.Window = class extends wm.Event.aG {
        constructor(t, i) {
            wm.zlt(t),
            wm.Kq(i),
            super(),
            this.Get = t,
            this.Get.addEventListener("focusin", t => {
                this.Wp() && (t.stopPropagation(),
                -1 !== Rm && window.clearTimeout(Rm),
                km = this,
                Rm = window.setTimeout( () => {
                    Rm = -1,
                    km = null,
                    wm.qs.iA.SF(this)
                }
                , 50))
            }
            ),
            this.rVt = i || "",
            this.gXe = null,
            this.yXe = !1,
            this.kys = -1,
            this.bXe = null,
            this.vXe = !1,
            this.L9 = 0,
            this.W9 = 0,
            this.SXe = 0,
            this.xXe = 0,
            this.MXe = "",
            this.Q7 = 0,
            this.ttt = 0,
            this.itt = 0,
            this.stt = 0,
            this.EXe = !1,
            wm.qs.iA.CXe(this)
        }
        _Xe() {
            km === this && (window.clearTimeout(Rm),
            Rm = -1,
            km = null)
        }
        bx() {
            gm(!this.EXe, "window already removed"),
            this._Xe(),
            wm.qs.iA.VW(this),
            wm.qs.BW(this.Get),
            this.Get = null,
            this.EXe = !0,
            this.gXe && ym.delete(this.gXe),
            this.gXe = null,
            super.he()
        }
        TXe() {
            return this.EXe
        }
        hk() {
            return gm(!this.EXe, "using removed window"),
            this.Get
        }
        PH() {
            return this.Get.ownerDocument
        }
        jW() {
            const t = this.PH();
            return t ? t.defaultView : null
        }
        Fa() {
            return this.rVt
        }
        I(t) {
            wm.zt(t),
            this.rVt = t
        }
        eue(t) {
            if (wm.zt(t),
            ym.has(t))
                throw new Error("Identifier already in use");
            ym.set(t, this),
            this.gXe = t
        }
        IXe() {
            return this.gXe
        }
        jye(t) {
            Em.set(this.gXe, t),
            Im.IF()
        }
        PXe() {
            Em.clear(),
            xm(),
            Gm = !0
        }
        Oye() {
            return Em.get(this.gXe)
        }
        GXe() {
            return Em.has(this.gXe)
        }
        Y4i(t) {
            Mm.set(this.gXe, t),
            Tm.IF()
        }
        AXe() {
            Mm.clear(),
            Sm(),
            Pm = !0
        }
        uWt() {
            return Mm.get(this.gXe)
        }
        cge() {
            return Mm.has(this.gXe)
        }
        RXe() {
            throw new Error("derived class must override")
        }
        lX() {
            this.RXe() && wm.qs.iA.lX(this)
        }
        Qbs(t) {
            wm.Ge(t);
            let i = this.hk();
            i.style.zIndex = t < 0 ? "" : t,
            this.kys = t
        }
        kXe() {
            return this.kys
        }
        static Z$(t, i) {
            return t.kXe() - i.kXe()
        }
        Bj() {
            wm.E4()
        }
        Wp() {
            return !0
        }
        Yct() {
            return this.yXe
        }
        OXe(t) {
            t = !!t,
            this.yXe !== t && (this.yXe = t,
            wm.qs.CD(this.Get, "active", this.yXe))
        }
        v7t() {
            this.bXe = null
        }
        DXe() {
            this.bXe = this.hk().getBoundingClientRect()
        }
        Kpt() {
            return gm(!this.EXe, "using removed window"),
            this.bXe || this.DXe(),
            this.bXe
        }
        uH(t, i) {
            wm.Ge(t),
            wm.Ge(i);
            let e = this.Kpt();
            return t >= e.left && t < e.right && i >= e.top && i < e.bottom
        }
        FXe() {
            return this
        }
        FP(t) {
            let i = new wm.Event("keydown",!0);
            i.which = t.which,
            i.altKey = t.altKey,
            i.ctrlKey = t.ctrlKey,
            i.shiftKey = t.shiftKey,
            i.metaKey = t.metaKey,
            this.dispatchEvent(i) || t.preventDefault()
        }
        Pz(t) {
            let i = new wm.Event("keyup",!0);
            i.which = t.which,
            i.altKey = t.altKey,
            i.ctrlKey = t.ctrlKey,
            i.shiftKey = t.shiftKey,
            i.metaKey = t.metaKey,
            this.dispatchEvent(i) || t.preventDefault()
        }
        sNt(t) {
            let i = new wm.Event("keypress",!0);
            i.which = t.which,
            i.altKey = t.altKey,
            i.ctrlKey = t.ctrlKey,
            i.shiftKey = t.shiftKey,
            i.metaKey = t.metaKey,
            i.key = t.key,
            this.dispatchEvent(i) || t.preventDefault()
        }
        BP(t) {
            let i = new wm.Event("cut",!0);
            i.clipboardData = t.clipboardData,
            this.dispatchEvent(i) || t.preventDefault()
        }
        DP(t) {
            let i = new wm.Event("copy",!0);
            i.clipboardData = t.clipboardData,
            this.dispatchEvent(i) || t.preventDefault()
        }
        HP(t) {
            let i = new wm.Event("paste",!0);
            i.clipboardData = t.clipboardData,
            i.Vq = t.Vq,
            this.dispatchEvent(i) || t.preventDefault()
        }
        TP(t) {
            let i = new wm.Event("keyboardshortcut",!0);
            return i.label = t,
            this.dispatchEvent(i),
            i.defaultPrevented
        }
        LXe(t, i) {
            wm.Ge(t),
            wm.Ge(i),
            this.L9 = t,
            this.W9 = i
        }
        BXe() {
            return this.L9
        }
        UXe() {
            return this.W9
        }
        NXe(t, i) {
            wm.Ge(t),
            wm.Ge(i),
            this.SXe = t,
            this.xXe = i
        }
        jXe() {
            return this.SXe
        }
        $Xe() {
            return this.xXe
        }
        zXe(t) {
            this.MXe = t
        }
        VXe() {
            return this.MXe
        }
        WXe(t, i) {
            wm.Ge(t),
            wm.Ge(i),
            this.Q7 = t,
            this.ttt = i
        }
        HXe() {
            return this.Q7
        }
        KXe() {
            return this.ttt
        }
        qXe(t, i) {
            wm.Ge(t),
            wm.Ge(i),
            this.itt = t,
            this.stt = i
        }
        XXe() {
            return this.itt
        }
        YXe() {
            return this.stt
        }
        sP(t) {
            this.vXe = !!t
        }
        JXe() {
            return !self.app.aj() && this.vXe
        }
        xY() {
            return !1
        }
    }
}
{
    const Om = self.t
      , Dm = self.assert;
    let Fm = []
      , Lm = null
      , Bm = null;
    const Um = []
      , Nm = 8;
    function jm(t) {
        t && ($m(t),
        Um.push(t),
        Um.length > Nm && Um.shift())
    }
    function $m(t) {
        Om.sni(Um, t)
    }
    let zm = 0
      , Vm = ""
      , Wm = -1;
    const Hm = 1e3;
    function Km() {
        Vm = "",
        Wm = -1
    }
    function qm(t) {
        t.document.addEventListener("pointerdown", i => {
            Om.yc() && Om.qs.iA.ZXe() && Om.qs.iA.Dgi(t, i.clientX, i.clientY, i.pointerId, i.button) && (i.preventDefault(),
            i.stopPropagation())
        }
        ),
        t.document.addEventListener("keydown", t => {
            Om.qs.iA.FP(t)
        }
        ),
        t.document.addEventListener("keypress", t => {
            Om.qs.iA.sNt(t)
        }
        ),
        t.document.addEventListener("keyup", t => {
            Om.qs.iA.Pz(t)
        }
        ),
        t.document.addEventListener("cut", t => {
            Om.qs.iA.BP(t)
        }
        ),
        t.document.addEventListener("copy", t => {
            Om.qs.iA.DP(t)
        }
        ),
        t.document.addEventListener("paste", t => {
            Om.qs.iA.HP(t)
        }
        ),
        t.addEventListener("blur", t => {
            Bm = Lm,
            Om.qs.iA.SF(null)
        }
        ),
        t.addEventListener("focus", t => {
            !Lm && Bm && Om.qs.iA.SF(Bm),
            Bm = null
        }
        )
    }
    window.C3_IsPopupWindow || qm(window);
    class Xm extends Om.Event.aG {
        constructor() {
            super()
        }
        d7t(t) {
            Om.zlt(t);
            for (const i of Fm)
                if (i.hk() === t)
                    return i;
            return null
        }
        CXe(t) {
            Om.U(t, Om.qs.Window),
            Fm.push(t)
        }
        VW(t) {
            Om.U(t, Om.qs.Window),
            this.QXe(t),
            Bm === t && (Bm = null);
            let i = Fm.indexOf(t);
            Dm(i >= 0, "cannot find window"),
            Fm.splice(i, 1),
            this.tYe()
        }
        *w7t(t) {
            for (let i = Fm.length - 1; i >= 0; --i) {
                const e = Fm[i];
                t && e.jW() !== t || (yield e)
            }
        }
        *Qke(t) {
            for (let i of Fm)
                t && i.jW() !== t || (yield i)
        }
        Dgi(t, i, e, s, n) {
            Om.Ge(i),
            Om.Ge(e),
            Om.Ge(s);
            let r = Om.qs.HY.N$i();
            if (r && r.gX()) {
                for (let t of r.iYe())
                    if (t.uH(i, e))
                        return this.SF(t.FXe()),
                        !1;
                if (r.uH(i, e))
                    return this.SF(r.FXe()),
                    !1
            } else
                for (let s of this.w7t(t))
                    if (s.uH(i, e) && (!r || s === r) && (!(s instanceof Om.qs.Ys) || !s.Pme()))
                        return this.SF(s.FXe()),
                        !1
        }
        lX(t) {
            Om.U(t, Om.qs.Window);
            let i = Fm.indexOf(t);
            i < 0 || (Fm.splice(i, 1),
            Fm.push(t),
            this.tYe())
        }
        tYe() {
            let t = [];
            for (let i of Fm)
                i.RXe() || (i.Qbs(-1),
                t.push(i));
            let i = Om.zk.R$i ? 1 : 100;
            for (let e of Fm)
                e.RXe() && (e.Qbs(i++),
                t.push(e));
            if (!Om.lSt(t, Fm)) {
                Om.lw(Fm, t);
                let i = new Om.Event("zindexchanged");
                this.dispatchEvent(i)
            }
        }
        eYe(t) {
            return t instanceof Om.qs.Ys && t.M6i()
        }
        SF(t, i) {
            if (Om.Mw(t, Om.qs.Window),
            Lm === t)
                return;
            const e = Om.qs.HY.N$i();
            if (e && e.Wp() && e !== t && !e.kJ().includes(t) && !this.eYe(t))
                return;
            Vm = "",
            -1 !== Wm && (window.clearTimeout(Wm),
            Wm = -1),
            Lm && Lm.OXe(!1),
            Lm = t,
            Lm && (i || this.lX(Lm),
            Lm.OXe(!0)),
            jm(t);
            let s = new Om.Event("activewindowchange");
            this.dispatchEvent(s)
        }
        RA() {
            return Lm
        }
        FP(t) {
            t.which === Om.kE.IE && Om.qs.HY.sYe() ? t.preventDefault() : Lm && Lm.FP(t)
        }
        Pz(t) {
            Lm && Lm.Pz(t)
        }
        sNt(t) {
            if (!t.key || !Lm)
                return;
            const i = Lm.hk().ownerDocument;
            if (Lm && Lm.sNt(t),
            Om.Lat(i))
                return;
            Vm += t.key,
            -1 !== Wm && window.clearTimeout(Wm),
            Wm = window.setTimeout(Km, Hm);
            const e = new Om.Event("searchinput");
            e.nYe = Vm,
            Lm.dispatchEvent(e)
        }
        BP(t) {
            self.app.UD() || Lm && Lm.BP(t)
        }
        DP(t) {
            self.app.UD() || Lm && Lm.DP(t)
        }
        HP(t) {
            self.app.UD() || Lm && Lm.HP(t)
        }
        QXe(t) {
            if (Om.U(t, Om.qs.Window),
            $m(t),
            t === Lm) {
                for (let t = Um.length - 1; t >= 0; --t) {
                    const i = Um[t];
                    if (i.Wp() && i.Bj() && !i.xY())
                        return void this.SF(i, !0)
                }
                for (let i = Fm.length - 1; i >= 0; --i) {
                    const e = Fm[i];
                    if (e !== t && e.Wp() && e.Bj() && !e.xY())
                        return void this.SF(e, !0)
                }
                this.SF(null)
            }
        }
        DTi(t, i, e, s) {
            Om.Ge(t),
            Om.Ge(i),
            Om.Mw(e, Om.qs.Window);
            let n = Om.qs.HY.N$i();
            if (n && n.gX()) {
                for (let s of n.iYe())
                    if (s !== e && s.uH(t, i))
                        return !0;
                if (n === e)
                    return !1;
                if (n.uH(t, i))
                    return !0
            } else
                for (let n of this.w7t(s))
                    if (n !== e && n.uH(t, i))
                        return !0;
            return !1
        }
        rYe(t, i, e, s) {
            Om.Ge(t),
            Om.Ge(i),
            Om.U(e, Om.qs.Window);
            let n = Om.qs.HY.N$i();
            if (n && n.gX()) {
                for (let s of n.iYe()) {
                    if (s === e)
                        return !1;
                    if (s.uH(t, i))
                        return !0
                }
                if (n === e)
                    return !1;
                if (n.uH(t, i))
                    return !0
            } else
                for (let n of this.w7t(s)) {
                    if (n === e)
                        return !1;
                    if (n.uH(t, i))
                        return !0
                }
            throw new Error("couldn't find window")
        }
        hYe(t) {
            t ? --zm : ++zm,
            Dm(zm >= 0, "disabled window sizing too many times")
        }
        ZXe() {
            return 0 === zm
        }
    }
    Om.qs.iA = Om.v(Xm)
}
{
    const Ym = self.t;
    !!window.C3_IsPopupWindow ? (window.addEventListener("cut", () => {
        window.opener.postMessage({
            type: "clipboard",
            event: "cut"
        }, location.origin)
    }
    ),
    window.addEventListener("copy", () => {
        window.opener.postMessage({
            type: "clipboard",
            event: "copy"
        }, location.origin)
    }
    ),
    window.addEventListener("paste", t => {
        window.opener.postMessage({
            type: "clipboard",
            event: "paste",
            clipboardDataString: t.clipboardData.getData("text/plain")
        }, location.origin)
    }
    )) : window.addEventListener("message", t => {
        t.origin === location.origin && Ym.qs.oYe.MHe(t.source, t.data)
    }
    );
    let Jm = new Set
      , Zm = new Map;
    const Qm = {
        features: "",
        name: null,
        Owt: null,
        aYe: !0
    };
    Ym.qs.oYe = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static lYe(t, i, e, s, n, r) {
            let h, o;
            Ym.zt(t),
            Ym.zt(i),
            Ym.Ge(e),
            Ym.Ge(s),
            Ym.cO(n),
            Ym.cO(r),
            h = "number" == typeof n ? n : window.screenX + window.outerWidth / 2 - e / 2,
            o = "number" == typeof r ? r : window.screenY + window.outerHeight / 2 - s / 2;
            let a = `width=${e},height=${s},left=${h},top=${o},menubar=no,toolbar=no,location=no,personalbar=no,status=no,dependent=yes,dialog=yes,resizable=yes,scrollbars=no`
              , l = window.open(t, i, a);
            return new Promise( (t, i) => {
                l ? Zm.set(l, {
                    resolve: t,
                    reject: i
                }) : i()
            }
            )
        }
        static MHe(t, i) {
            if (i && "object" == typeof i && "string" == typeof i.type)
                switch (i.type) {
                case "ready":
                    Ym.qs.oYe.uYe(t);
                    break;
                case "popup-keyboard-shortcut":
                    Ym.qs.oYe.cYe(i.event);
                    break;
                case "popup-keydown":
                    Ym.qs.oYe.dYe(i.event);
                    break;
                case "popup-keyup":
                    Ym.qs.oYe.fYe(i.event);
                    break;
                case "popup-keypress":
                    Ym.qs.oYe.pYe(i.event);
                    break;
                case "clipboard":
                    Ym.qs.oYe.mYe(i);
                    break;
                case "closed":
                    Ym.qs.oYe.wYe(t)
                }
        }
        static uYe(t) {
            Jm.add(t);
            let i = Zm.get(t);
            i || 1 !== Zm.size || (i = Ym.eu(Zm.values())),
            i && i.resolve({
                window: t
            }),
            Zm.delete(t);
            let e = [];
            const s = Ym.lj.gYe();
            s && (e = s.yYe()),
            Ym.qs.oYe.bYe(t, "init-settings", {
                uiEffectsEnabled: self.app.J1(),
                themeStyles: e
            }),
            Ym.qs.HY.vYe(t)
        }
        static wYe(t) {
            Jm.delete(t);
            let i = Zm.get(t);
            i && i.reject(t),
            Zm.delete(t)
        }
        static bYe(t, i, e) {
            t.postMessage({
                type: i,
                param: e
            }, location.origin)
        }
        static cYe(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ,
            t.SYe = !1;
            const i = new Ym.Event("external-keyboard-shortcut");
            if (i.Rst = t,
            self.app.dispatchEvent(i),
            !t.SYe) {
                const i = Ym.qs.iA.RA();
                i && i.FP(t)
            }
        }
        static dYe(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ;
            const i = new Ym.Event("external-keydown");
            i.Rst = t,
            self.app.dispatchEvent(i),
            window.dispatchEvent(new KeyboardEvent("external-keydown",t));
            const e = Ym.qs.iA.RA();
            e && e.FP(t)
        }
        static fYe(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ;
            const i = new Ym.Event("external-keyup");
            i.Rst = t,
            self.app.dispatchEvent(i),
            window.dispatchEvent(new KeyboardEvent("external-keyup",t));
            const e = Ym.qs.iA.RA();
            e && e.Pz(t)
        }
        static pYe(t) {
            t.preventDefault = function() {}
            ,
            t.stopPropagation = function() {}
            ;
            const i = new Ym.Event("external-keypress");
            i.Rst = t,
            self.app.dispatchEvent(i),
            window.dispatchEvent(new KeyboardEvent("external-keypress",t));
            const e = Ym.qs.iA.RA();
            e && e.sNt(t)
        }
        static mYe(t) {
            const i = t.event
              , e = {
                clipboardData: null,
                preventDefault() {},
                stopPropagation() {}
            }
              , s = Ym.qs.iA.RA();
            s && ("cut" === i ? s.BP(e) : "copy" === i ? s.DP(e) : (e.Vq = t.clipboardDataString,
            s.HP(e)))
        }
        static xYe(t) {
            t = !!t;
            for (let i of Jm)
                Ym.qs.oYe.bYe(i, "show-dimmer", t)
        }
        static MYe() {
            return Jm.size > 0
        }
        static EYe(t, i) {
            Ym.zt(t),
            Ym.Wat(i),
            i = Object.assign({}, Qm, i),
            Ym.zt(i.features),
            Ym.Kq(i.name),
            Ym.Hdt(i.Owt);
            const e = !!i.aYe;
            return self.rOe.nOe( () => {
                const s = window.open(t, i.name, i.features);
                if (s)
                    return {
                        window: s
                    };
                if (e) {
                    return Ym.qs.Ys.$s("OpenPopupWindow").Qa(t, i)
                }
                return null
            }
            )
        }
    }
}
{
    const tw = self.t;
    let iw = new Map
      , ew = new Set
      , sw = new Set
      , nw = new Map
      , rw = new Map
      , hw = new Map
      , ow = new Map
      , aw = !1
      , lw = null;
    const uw = new Set
      , cw = new Set
      , dw = Symbol()
      , fw = Symbol()
      , pw = Symbol()
      , mw = Symbol();
    function ww(t) {
        const i = i => {
            tw.yc() && tw.qs.HY.Dgi(t, i.clientX, i.clientY, i.pointerId, i.button) && (i.preventDefault(),
            i.stopPropagation())
        }
        ;
        t.document.addEventListener("pointerdown", i),
        t.document[dw] = i;
        const e = i => {
            tw.yc() && tw.qs.HY.Bgi(t, i.clientX, i.clientY, i.pointerId) && (i.preventDefault(),
            i.stopPropagation())
        }
        ;
        t.document.addEventListener("pointermove", e),
        t.document[fw] = e;
        const s = i => {
            tw.yc() && tw.qs.HY.Ugi(t, i.clientX, i.clientY, i.screenX, i.screenY, i.pointerId) && (i.preventDefault(),
            i.stopPropagation())
        }
        ;
        t.document.addEventListener("pointerup", s),
        t.document[pw] = s;
        const n = i => {
            tw.qs.HY.Ugi(t, i.clientX, i.clientY, i.screenX, i.screenY, i.pointerId)
        }
        ;
        t.document.addEventListener("pointercancel", n),
        t.document[mw] = n
    }
    window.C3_IsPopupWindow || ww(window),
    window.addEventListener("focus", t => {
        let i = tw.qs.HY.N$i();
        i && tw.qs.iA.SF(i)
    }
    );
    let gw = null
      , yw = tw.v(tw.Event.aG);
    tw.qs.HY = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static CYe(t, i) {
            if (tw.zt(t),
            tw.qd(i),
            iw.has(t))
                throw new Error(`dialog name '${t}' already in use`);
            iw.set(t, {
                _Ye: i,
                _s: []
            })
        }
        static TYe(t, i) {
            tw.zt(t);
            let e = iw.get(t);
            if (!e)
                throw new Error(`dialog name '${t}' not found`);
            let s = null;
            if (i) {
                for (let t of e._s)
                    if (!t.Bj()) {
                        s = t;
                        break
                    }
            } else
                e._s.length && (s = e._s[0]);
            return s || (aw = i,
            s = tw.v(e._Ye, i),
            e._s.push(s),
            s.I(t),
            s.eue("DIALOG_" + t + e._s.length),
            s.Qfi(),
            aw = !1),
            s
        }
        static IYe() {
            return aw
        }
        static IJi() {
            return !!this.N$i()
        }
        static N$i() {
            const t = [...sw];
            return t.length ? t.at(-1) : null
        }
        static*Bzt() {
            yield*ew,
            yield*sw
        }
        static T6i(t) {
            tw.X_t(t);
            const i = [...ew];
            return i.reverse(),
            t ? i.filter(t) : i
        }
        static PYe(t) {
            const i = [];
            for (const e of ew)
                t === e.PH() && i.push(e);
            return i
        }
        static GYe(t) {
            const i = [];
            for (const e of ew)
                t && t !== e.jW() || i.push(e);
            return i
        }
        static AYe(t) {
            let i = tw.qs.HY.N$i()
              , e = tw.qs.HY.T6i();
            return i ? (tw.ote(e, e => !e.lFs() || !e.bF() === i || t && e.jW() !== t),
            t && i.jW() !== t || e.push(i)) : tw.ote(e, i => i.O6i() || t && i.jW() !== t),
            e
        }
        static RYe() {
            let t = tw.qs.iA.RA();
            return t instanceof tw.qs.Ys ? t : null
        }
        static vYe(t) {
            ww(t)
        }
        static kYe(t, i) {
            tw.U(t, tw.qs.Ys),
            i ? (ew.add(t),
            t.M6i() && (sw.add(t),
            this.OYe("showmodal", t)),
            tw.qs.iA.SF(t)) : (ew.delete(t),
            t.M6i() && (sw.delete(t),
            this.OYe("hidemodal", t)))
        }
        static DTi(t, i, e) {
            tw.Ge(t),
            tw.Ge(i);
            for (const s of tw.qs.HY.GYe(e))
                if (s.uH(t, i))
                    return !0;
            return !1
        }
        static DYe(t) {
            tw.U(t, tw.qs.Ys);
            const i = t._a()
              , e = t.Da();
            for (const s of tw.qs.HY.GYe(t.jW()))
                if (t !== s && s._a() === i && s.Da() === e)
                    return !0;
            return !1
        }
        static X1() {
            return ew.size > 0
        }
        static FYe(t) {
            return ew.size >= 2 || 1 === ew.size && tw.eu(ew) !== t
        }
        static sYe() {
            for (const t of ew)
                if (t.Pme())
                    return !0;
            return !1
        }
        static DY() {
            return sw.size > 0
        }
        static LYe() {
            return [...sw].filter(t => "Progress" !== t.Fa()).length > 0
        }
        static BYe(t) {
            return tw.qs.HY.UYe(t, "dialogshow")
        }
        static NYe() {
            return Promise.all([...ew].filter(t => t.Pme()).map(t => t.IR()))
        }
        static jYe(t) {
            return tw.qs.HY.UYe(t, "dialogok")
        }
        static $Ye(t) {
            return tw.qs.HY.UYe(t, "dialogcancel")
        }
        static zYe(t) {
            return tw.qs.HY.UYe(t, "dialogclose")
        }
        static VYe() {
            return tw.qs.HY.IJi() ? new Promise(t => {
                const i = () => {
                    tw.qs.HY.IJi() ? self.setTimeout(i, 250) : t()
                }
                ;
                self.setTimeout(i, 250)
            }
            ) : Promise.resolve()
        }
        static UYe(t, i) {
            return tw.zt(t),
            tw.zt(i),
            new Promise(e => {
                const s = n => {
                    n.nWt.Fa() === t && (tw.qs.HY.removeEventListener(i, s),
                    e(n))
                }
                ;
                tw.qs.HY.addEventListener(i, s)
            }
            )
        }
        static WYe(t) {
            if (cw.clear(),
            !t)
                for (const t of tw.qs.HY.Bzt())
                    cw.add(t)
        }
        static HYe(t) {
            return !cw.has(t) && tw.qs.HY.npi(t)
        }
        static KYe(t) {
            if (uw.clear(),
            !t)
                for (const t of tw.qs.HY.Bzt())
                    uw.add(t)
        }
        static npi(t) {
            return !uw.has(t)
        }
        static Uht(t) {
            return tw.U(t, tw.qs.Ys),
            !!rw.get(t)
        }
        static sit(t) {
            return tw.U(t, tw.qs.Ys),
            !!ow.get(t)
        }
        static qYe(t) {
            return tw.U(t, tw.XYe),
            lw = t,
            tw.qs.HY.jAe()
        }
        static jAe() {
            const t = new tw.Event("load");
            return t.app = lw,
            tw.qs.HY.ipt.ize(t)
        }
        static YYe(t, i, e, s) {
            tw.U(t, tw.qs.Ys),
            tw.Ge(i),
            tw.Ge(e),
            tw.Ge(s),
            rw.has(t) || ow.has(t) || tw.qs.Ek.DTi(i, e, t.jW()) || (tw.qs.HY.Dgi(t.jW(), i, e, s),
            ow.has(t) || (nw.set(s, t),
            rw.set(t, s),
            t.LXe(i, e),
            t.NXe(t._a() - i, t.Da() - e),
            t.JLt("startdragging"),
            t.JYe()))
        }
        static Dgi(t, i, e, s, n) {
            if (tw.Ge(i),
            tw.Ge(e),
            tw.Ge(s),
            nw.has(s) || hw.has(s) || tw.qs.Ek.DTi(i, e, t))
                return !1;
            for (const r of tw.qs.HY.AYe(t)) {
                const h = r.ZYe(i, e);
                if ("m" === h)
                    return !1;
                if (h && n === tw.f1.e5) {
                    if (rw.has(r))
                        return !1;
                    if (tw.qs.iA.rYe(i, e, r, t))
                        break;
                    return hw.set(s, r),
                    ow.set(r, s),
                    r.JLt("startresizing"),
                    r.zXe(h),
                    r.LXe(i, e),
                    r.WXe(r._a(), r.Da()),
                    r.qXe(r.ns(), r.Kn()),
                    r.QYe(),
                    !0
                }
            }
            return !1
        }
        static Bgi(t, i, e, s) {
            if (tw.Ge(i),
            tw.Ge(e),
            tw.Ge(s),
            tw.m1.Cze(s))
                return !1;
            if (nw.has(s))
                return tw.qs.HY.tJe(i, e, s, nw.get(s)),
                !0;
            if (hw.has(s))
                return tw.qs.HY.iJe(i, e, s, hw.get(s)),
                !0;
            if (tw.qs.Ek.DTi(i, e, t))
                return gw && gw.Set("default"),
                !1;
            for (const s of tw.qs.HY.AYe(t)) {
                const n = s.ZYe(i, e);
                if (n) {
                    if (tw.qs.iA.rYe(i, e, s, t))
                        break;
                    if (gw)
                        "e" === n || "w" === n ? gw.Set("ew-resize") : "n" === n || "s" === n ? gw.Set("ns-resize") : "nw" === n || "se" === n ? gw.Set("nwse-resize") : "ne" === n || "sw" === n ? gw.Set("nesw-resize") : "m" === n && (tw.qs.SH.CH(gw),
                        gw = null);
                    else {
                        const t = s.PH()
                          , r = {
                            onpointerdown: t[dw],
                            onpointermove: t[fw],
                            onpointerup: t[pw],
                            onpointercancel: t[mw]
                        };
                        "e" === n || "w" === n ? gw = tw.qs.SH.gH("ew-resize", t, i, e, r) : "n" === n || "s" === n ? gw = tw.qs.SH.gH("ns-resize", t, i, e, r) : "nw" === n || "se" === n ? gw = tw.qs.SH.gH("nwse-resize", t, i, e, r) : "ne" !== n && "sw" !== n || (gw = tw.qs.SH.gH("nesw-resize", t, i, e, r))
                    }
                    return !!gw
                }
            }
            return tw.qs.SH.CH(gw),
            gw = null,
            !1
        }
        static tJe(t, i, e, s) {
            tw.Ge(t),
            tw.Ge(i),
            tw.Ge(e),
            tw.U(s, tw.qs.Ys),
            s.kp(t + s.jXe()),
            s.Gp(i + s.$Xe())
        }
        static iJe(t, i, e, s) {
            tw.Ge(t),
            tw.Ge(i),
            tw.Ge(e),
            tw.U(s, tw.qs.Ys);
            let n = t - s.BXe()
              , r = i - s.UXe()
              , h = s.HXe()
              , o = s.KXe()
              , a = s.XXe()
              , l = s.YXe()
              , u = s.VXe();
            if ("e" === u || "se" === u || "ne" === u)
                s.Qx(a + n);
            else if ("w" === u || "sw" === u || "nw" === u) {
                let t = h + a - s.qnt();
                s.kp(Math.min(h + n, t)),
                s.Qx(a - n)
            }
            if ("s" === u || "sw" === u || "se" === u)
                s.Kx(l + r);
            else if ("n" === u || "nw" === u || "ne" === u) {
                let t = o + l - s.Xnt();
                s.Gp(Math.min(o + r, t)),
                s.Kx(l - r)
            }
        }
        static Ugi(t, i, e, s, n, r) {
            if (tw.Ge(i),
            tw.Ge(e),
            tw.Ge(r),
            nw.has(r)) {
                let t = nw.get(r);
                if (tw.qs.HY.tJe(i, e, r, t),
                (i < 0 || e < 0 || i > window.innerWidth || e > window.innerHeight) && t.eJe()) {
                    const i = self.devicePixelRatio;
                    t.J_t(s / i + t.jXe(), n / i + t.$Xe()).catch(i => t.sJe())
                } else
                    t.sJe();
                return nw.delete(r),
                rw.delete(t),
                t.lWt(),
                t.JLt("finishdragging"),
                t.nJe(),
                !0
            }
            if (hw.has(r)) {
                let t = hw.get(r);
                tw.qs.HY.iJe(i, e, r, t),
                t.sJe(),
                hw.delete(r),
                ow.delete(t),
                t.rJe(),
                t.lWt(),
                t.JLt("finishresizing")
            }
            return !1
        }
        static OYe(t, i, e) {
            tw.zt(t),
            tw.Mw(i, tw.qs.Ys);
            let s = new tw.Event(t);
            s.nWt = i,
            void 0 !== e && (s.hJe = e),
            this.dispatchEvent(s)
        }
        static addEventListener(t, i, e) {
            yw.addEventListener(t, i, e)
        }
        static removeEventListener(t, i, e) {
            yw.removeEventListener(t, i, e)
        }
        static dispatchEvent(t) {
            return yw.dispatchEvent(t)
        }
    }
    ,
    tw.qs.HY.ipt = tw.v(tw.Event.aG)
}
{
    const bw = self.t
      , vw = self.assert
      , Sw = {
        duration: bw.M9s.lVs("slow-animations") ? 3e3 : 200,
        easing: "ease-out"
    }
      , xw = 125
      , Mw = 300
      , Ew = 50
      , Cw = 200
      , _w = 30
      , Tw = 200
      , Iw = bw.v(bw.j1t, 1);
    let Pw = new Map;
    bw.qs.Ys = class extends bw.qs.Window {
        constructor(t) {
            if (bw.zlt(t, "dialog"),
            bw.qs.HY.IYe() && (t = t.cloneNode(!0)),
            super(t),
            Pw.has(t))
                throw new Error("dialog class already created");
            Pw.set(t, this),
            this.oJe = t.querySelector("ui-dialog-caption"),
            this.aJe = t.querySelector("ui-dialog-contents"),
            this.lJe = t.querySelector("ui-dialog-footer"),
            this.uJe = this.Get.ownerDocument,
            this.cJe = null,
            this.Get.hasAttribute("role") || this.Get.setAttribute("role", "dialog"),
            this.dJe = this.Get.hasAttribute("resizable") && !bw.kt.mj,
            this.fJe = !0,
            this.pJe = !1,
            this.mJe = !1,
            this.wJe = null,
            this.gJe = null,
            this.yJe = null,
            this.bJe = null,
            this.vJe = this.Get.querySelector("ui-dialog-caption"),
            this.SJe = null,
            this._Wt = !1,
            this.xJe = null,
            this.MJe = !1,
            this.Dge = !1,
            this.EJe = !1,
            this.CJe = !0,
            this._Je = !1,
            this.TJe = "",
            this.kd = 0,
            this.Gd = 0,
            this.ZC = 0,
            this.tv = 0,
            this.IJe = 0,
            this.PJe = 0,
            this.GJe = t => this.sJe(),
            this.l1 = null,
            this.AJe = null,
            this.RJe = !0,
            this.kJe = !1,
            this.OJe = !1,
            this.DJe = null,
            this.FJe = t => this.G_t(),
            this.LJe = null,
            this.SCe = null,
            this.BJe = null,
            this.UJe = null,
            this.NJe = !0,
            this.vJe && (this.TJe = this.vJe.textContent,
            bw.qs.BYt(this.vJe),
            this.SJe = bw.qs.lk("span", this.vJe, null, "dialog-caption-text"),
            this.SJe.textContent = this.TJe,
            this.l1 = t => {
                t.button === bw.f1.e5 && t.isPrimary && this.sot(t.clientX, t.clientY, t.pointerId)
            }
            ,
            this.AJe = t => this.jJe(t),
            this.vJe.addEventListener("contextmenu", this.AJe),
            this.Get.hasAttribute("closebutton") && (this.LJe = bw.v(bw.qs.Jj.X5t, this.vJe),
            this.LJe.onclick = () => this.tWt()),
            this.Get.hasAttribute("menudotsbutton") && (this.BJe = bw.v(bw.qs.Jj.$Je, this.vJe)),
            this.Get.hasAttribute("backbutton") && (this.SCe = bw.v(bw.qs.Jj.zJe, this.vJe),
            this.SCe.onclick = () => this.bge())),
            this.VJe = null,
            this.WJe = -1,
            this.HJe = window.orientation,
            bw.kt.mj && (this.VJe = t => this.KJe(t)),
            this.hVt = null,
            this.zIs = [],
            this.qJe = [],
            this.XJe = 0,
            this.YJe = 0,
            this.JJe = null,
            this.ZJe = null,
            this.QJe = t => this.tZe(t),
            this.iZe = t => this.eZe(t),
            this.sZe = t => this.nZe(t),
            this.rZe = !1,
            this.pWe = () => this.hZe()
        }
        Qfi() {}
        cge() {
            if (super.cge()) {
                return this.uWt().devicePixelRatio === window.devicePixelRatio
            }
            return !1
        }
        lWt(...t) {
            if (this.Uht() || this.sit())
                return;
            if (!self.app.ULt())
                return;
            if (this.rZe)
                return;
            if (!this.rVt)
                return;
            if (!this.fJe)
                return;
            if (bw.qs.Ys.$s(this.rVt) !== this)
                return;
            let i = this.cJe && this.cJe.defaultView
              , e = {
                popup: this.NBi(),
                nested: this.lFs(),
                width: this.ZC,
                height: this.tv,
                resizable: this.dJe,
                devicePixelRatio: window.devicePixelRatio,
                xRatio: i && this.kd / i.innerWidth,
                yRatio: i && this.Gd / i.innerHeight,
                xParentRatio: i && this.oZe() / i.innerWidth,
                yParentRatio: i && this.aZe() / i.innerHeight
            };
            Object.assign(e, ...t),
            this.Y4i(e)
        }
        FLt() {
            if (!self.app.ULt())
                return;
            this.rZe = !0;
            let t = this.uWt();
            if ((this.OJe || this.DJe) && (t = null),
            this.fJe && t)
                if (t.popup)
                    this.J_t(screen.width / 2, screen.height / 2);
                else {
                    const i = this.cJe ? this.cJe.defaultView : null
                      , e = t.xRatio
                      , s = t.yRatio
                      , n = t.xParentRatio
                      , r = t.yParentRatio
                      , h = t.nested;
                    if (i && Number.isFinite(e) && Number.isFinite(s))
                        if (h && Number.isFinite(n) && Number.isFinite(r)) {
                            let t = this.oZe()
                              , h = this.aZe()
                              , o = t - n * i.innerWidth
                              , a = h - r * i.innerHeight;
                            this.Zps(e * i.innerWidth - o, s * i.innerHeight - a)
                        } else
                            this.Zps(e * i.innerWidth, s * i.innerHeight);
                    t.resizable && (this.Qx(t.width),
                    this.Kx(t.height)),
                    this.sJe()
                }
            this.rZe = !1
        }
        static opt(t, i) {
            bw.qs.HY.CYe(t, i)
        }
        static $s(t, i) {
            return bw.qs.HY.TYe(t, i)
        }
        static lZe(t) {
            return Pw.get(t) || null
        }
        Ya(t) {
            if (bw.Kq(t),
            this.SJe) {
                let i = t || window.app.Fa();
                this.TJe !== i && (this.SJe.textContent = i,
                this.TJe = i)
            }
        }
        _wt() {
            return !0
        }
        Fwt() {
            return !1
        }
        RXe() {
            return this.Bj()
        }
        Bj() {
            return !!(this.MJe || this.Dge || this.xJe) || this._Wt
        }
        Wp() {
            return this._Wt && !this.Dge
        }
        Bmi() {
            return !!(this.MJe || this.Dge || this.xJe)
        }
        uZe() {
            return this.MJe
        }
        Pme() {
            return this.Dge
        }
        NBi() {
            return !!this.DJe
        }
        xY() {
            return this.NBi()
        }
        cZe() {
            return this.cJe === document
        }
        fjt() {
            return bw.qs.HY.N$i() === this
        }
        Uht() {
            return bw.qs.HY.Uht(this)
        }
        sit() {
            return bw.qs.HY.sit(this)
        }
        Cwt() {
            return !this.M6i()
        }
        bF() {
            return this.hVt || this.JJe
        }
        lFs() {
            return !!this.hVt || !!this.JJe
        }
        dZe() {
            return !!this.lFs() && -1 !== this.bF().kJ().indexOf(this)
        }
        fZe() {
            return !!this.lFs() && -1 !== this.bF().pZe().indexOf(this)
        }
        zmt() {
            return self.app.zmt()
        }
        v6i() {
            return this.oJe
        }
        y5t() {
            return this.aJe
        }
        mZe() {
            return this.lJe
        }
        wZe() {
            return this.LJe
        }
        B6i() {
            return this.BJe
        }
        dwt(t) {
            bw.zt(t);
            let i = this.Get.querySelector("." + t);
            if (!i)
                throw new Error(`missing dialog element with class name: ${t}`);
            return i
        }
        y$t(t) {
            bw.zt(t);
            let i = this.Get.querySelector("#" + t);
            if (!i)
                throw new Error(`missing dialog element with id: ${t}`);
            return i
        }
        Ajt(t) {
            bw.zt(t);
            let i = this.Get.getElementsByTagName(t);
            if (!i)
                throw new Error(`tag '${t}' does not match any element`);
            return i
        }
        uKi(t, i=!1) {
            let e;
            if (bw.zt(t),
            i = !!i) {
                if (e = this.Get.querySelectorAll(t),
                !e)
                    throw new Error(`CSS selector '${t}' does not match any element`);
                if (!e.length)
                    throw new Error(`CSS selector '${t}' does not match any element`)
            } else if (e = this.Get.querySelector(t),
            !e)
                throw new Error(`CSS selector '${t}' does not match any element`);
            return e
        }
        A_t() {
            return this.DJe
        }
        gZe(t) {
            t ? this.cJe = t.ownerDocument : this.DJe ? this.cJe = this.DJe.document : this.cJe = document,
            vw(this.cJe, "no display document for dialog")
        }
        yZe(t) {
            bw.U(t, bw.qs.Ys);
            let i = this.qJe.indexOf(t);
            vw(-1 === i, "child popup window is already part of parent dialog"),
            this.qJe.push(t),
            t.addEventListener("afterpopupclose", this.sZe)
        }
        bZe(t) {
            bw.U(t, bw.qs.Ys);
            let i = this.qJe.indexOf(t);
            vw(-1 !== i, "child popup window is not part of parent dialog"),
            this.qJe.splice(i, 1),
            t.removeEventListener("afterpopupclose", this.sZe)
        }
        nZe(t) {
            let i = t.nWt
              , e = i.bF();
            vw(e, "parent can not be null when a child popup is closed"),
            e.bZe(i)
        }
        vZe(t) {
            bw.U(t, bw.qs.Ys);
            let i = this.zIs.indexOf(t);
            vw(-1 === i, "child dialog is already part of parent dialog"),
            t.hVt = this,
            this.zIs.length || (this.addEventListener("positionchange", this.iZe),
            this.addEventListener("widthchange", this.iZe),
            this.addEventListener("heightchange", this.iZe),
            this.addEventListener("startdragging", this.QJe),
            this.addEventListener("startresizing", this.QJe)),
            this.zIs.push(t)
        }
        HWs(t) {
            bw.U(t, bw.qs.Ys);
            let i = this.zIs.indexOf(t);
            vw(-1 !== i, "child dialog is not part of parent dialog"),
            this.zIs.splice(i, 1),
            t.hVt = null,
            this.zIs.length || (this.removeEventListener("positionchange", this.iZe),
            this.removeEventListener("widthchange", this.iZe),
            this.removeEventListener("heightchange", this.iZe),
            this.removeEventListener("startdragging", this.QJe),
            this.removeEventListener("startresizing", this.QJe))
        }
        OEs() {
            for (let t of this.zIs)
                if (t.OJe || t.vwt(),
                t.hVt) {
                    let i = t.hVt.zIs.indexOf(t);
                    t.hVt.zIs.splice(i, 1),
                    t.hVt = null
                }
            if (bw.sc(this.zIs),
            !this.OJe) {
                for (let t of this.qJe)
                    t.OJe || t.vwt(),
                    t.removeEventListener("afterpopupclose", this.sZe),
                    t.JJe = null;
                bw.sc(this.qJe)
            }
            this.removeEventListener("positionchange", this.iZe),
            this.removeEventListener("widthchange", this.iZe),
            this.removeEventListener("heightchange", this.iZe),
            this.removeEventListener("startdragging", this.QJe),
            this.removeEventListener("startresizing", this.QJe)
        }
        gX() {
            return !!this.zIs.length
        }
        SZe() {
            return !!this.qJe.length
        }
        kJ() {
            return this.zIs
        }
        pZe() {
            return this.qJe
        }
        *iYe() {
            for (let t = this.zIs.length - 1; t >= 0; --t)
                yield this.zIs[t]
        }
        oZe() {
            let t = this.hVt;
            return t ? t.kd + t.uge() : 0
        }
        aZe() {
            let t = this.hVt;
            return t ? t.Gd + t.uge() : 0
        }
        eZe(t) {
            let i = this._a() - this.XJe
              , e = this.Da() - this.YJe;
            for (let t of this.zIs)
                t.Zps(t.XJe - i, t.YJe - e)
        }
        tZe(t) {
            this.XJe = this._a(),
            this.YJe = this.Da();
            for (let t of this.zIs)
                t.XJe = t._a(),
                t.YJe = t.Da()
        }
        Qa(t) {
            return this.xZe(),
            this.MZe(!0, t)
        }
        Ej(t) {
            return this.xZe(),
            this.MZe(!1, t)
        }
        xZe() {
            vw(!1 === this.OJe, "_isPopupTransfer must be false"),
            vw(null === this.hVt, "_parent must be null"),
            vw(null === this.JJe, "_parentBeforeDetach must be null")
        }
        MZe(t, i) {
            if (t = !!t,
            bw.Hdt(i),
            this.yJe = null,
            bw.kt.mj && (t = !0),
            this.Bj() && this.M6i() !== t)
                throw new Error("dialog already showing with different modal setting");
            this.pJe = t;
            let e = this.EZe();
            if (e)
                return e;
            if (this.Dge && this.hZe(),
            this.bJe = null,
            this.gZe(i),
            this.Bj())
                return this.ZJe;
            if (bw.qs.CD(this.Get, "modal", this.pJe),
            bw.qs.CD(this.Get, "non-modal", !this.pJe),
            this.CJe && this.CZe(),
            this.pJe && (bw.qs.cqe.Ej(i),
            this.EJe = !0,
            this.NJe && (this.UJe = bw.wHe.cR( () => {
                this.SCe ? this.bge() : this.LJe ? this.tWt() : this.gwt()
            }
            , this.TJe))),
            this.mJe ? this.Get.style.display = "" : this.uJe !== this.cJe && (bw.qs.BW(this.Get),
            this.cJe.body.appendChild(this.Get)),
            bw.zk.R$i ? this.pJe ? this.Get.showModal() : this.Get.show() : this.Get.setAttribute("polyfill", ""),
            this._Wt = !0,
            this._Ze(),
            bw.qs.HY.kYe(this, !0),
            this.CJe ? (this.TZe(),
            this.IZe()) : this._Je ? (this.Get.style.width = `${this.ZC}px`,
            this.Get.style.height = `${this.tv}px`,
            this.TZe()) : !bw.kt.mj && (this.dJe || this.fJe) && self.app.ULt() || this.JIe(),
            !this._Je && this.cge() && this.FLt(),
            this.pJe && bw.qs.SH.u(this.cJe, this),
            this.CJe = !1,
            this._Je = !1,
            this.lge(),
            this.O6i() || this.FIe(),
            this.O6i() || this.cJe.defaultView.addEventListener("resize", this.GJe),
            this.vJe && !bw.kt.mj && (this.O6i() || this.vJe.addEventListener("pointerdown", this.l1)),
            bw.kt.mj && window.addEventListener("orientationchange", this.VJe),
            this.MJe = !this.O6i(),
            !this.zmt() || this.OJe || this.O6i())
                this.PZe();
            else {
                let t = this.Kpt()
                  , i = t.left + t.width / 2 - this.oZe()
                  , e = t.top + t.height / 2 - this.aZe()
                  , s = [{
                    transform: `perspective(600px) translate3d(${this.kd}px, ${this.Gd}px, -20px)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "0"
                }, {
                    transform: `perspective(600px) translate3d(${this.kd}px, ${this.Gd}px, 0)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "1"
                }];
                this.Get.style.transform = "",
                this.xJe = this.Get.animate(s, Sw),
                this.xJe.onfinish = t => this.PZe(),
                document.addEventListener("visibilitychange", this.pWe)
            }
            return this.OJe ? this.ZJe : (this.aJe && (this.aJe.scrollTop = 0),
            Promise.resolve().then( () => {
                this.O6i() || bw.qs.HY.OYe("dialogshow", this)
            }
            ),
            this.O6i() || this.lWt(),
            this.ZJe ? this.ZJe : this.GZe())
        }
        _Ze() {
            if (!this.pJe && !this.NBi()) {
                let t = bw.qs.HY.N$i();
                if (t && !t.NBi() && t.Wp()) {
                    if (this.mJe)
                        throw new Error("not supported");
                    bw.qs.BW(this.Get),
                    t.hk().appendChild(this.Get),
                    t.vZe(this)
                }
            }
        }
        EZe() {
            if (!this.pJe && !this.NBi()) {
                let t = bw.qs.HY.N$i();
                if (t && t.NBi()) {
                    if (this.JJe = t,
                    this.cge()) {
                        let t = this.uWt();
                        this.Qx(t.width),
                        this.Kx(t.height)
                    } else
                        this.IZe();
                    return this.J_t().then( () => this.GZe())
                }
            }
        }
        GZe() {
            return this.ZJe = new Promise( (t, i) => {
                this.wJe = t,
                this.gJe = i
            }
            ),
            this.ZJe
        }
        CZe() {
            this.TJe || this.Ya(null),
            this.Swt()
        }
        Swt() {}
        AZe(t=!1) {
            if (this.EJe && (bw.qs.cqe.Cj(),
            this.EJe = !1),
            !this.Bj())
                return this.yJe ? void (this.yJe = null) : void (() => {})(`[Dialog] Closing dialog '${this.TJe}' which is not currently open`);
            if (this.yJe = null,
            bw.qs.Ek.RZe(),
            bw.qs.Jj.QY.kZe(this),
            !this.lFs() && this.NBi() && bw.qs.HY.PYe(this.PH()).forEach(t => {
                t !== this && t.vwt(!0)
            }
            ),
            this.pJe && bw.qs.SH.j(this.cJe),
            this.cJe.defaultView.removeEventListener("resize", this.GJe),
            bw.kt.mj && (clearTimeout(this.WJe),
            window.removeEventListener("orientationchange", this.VJe)),
            this.vJe && this.vJe.removeEventListener("pointerdown", this.l1),
            this._Xe(),
            this.xJe) {
                if (!t)
                    return this.MJe && (this.MJe = !1,
                    this.Dge = !0,
                    this.xJe.playbackRate *= -1),
                    bw.qs.iA.QXe(this),
                    (this.gX() || this.SZe()) && this.OEs(),
                    void (this.dZe() && this.bF().HWs(this));
                this.xJe = null,
                document.removeEventListener("visibilitychange", this.pWe)
            }
            if (this.Dge = !0,
            bw.qs.iA.QXe(this),
            (this.gX() || this.SZe()) && this.OEs(),
            this.lWt(),
            this.dZe() && this.bF().HWs(this),
            !this.zmt() || this.OJe || this.DJe || t)
                this.PZe();
            else {
                let t = this.Kpt()
                  , i = t.left + t.width / 2 - this.oZe()
                  , e = t.top + t.height / 2 - this.aZe()
                  , s = [{
                    transform: `perspective(600px) translate3d(${this.kd}px, ${this.Gd}px, 0)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "1"
                }, {
                    transform: `perspective(600px) translate3d(${this.kd}px, ${this.Gd}px, -20px)`,
                    transformOrigin: `${i}px ${e}px`,
                    opacity: "0"
                }];
                this.Get.style.transform = "",
                this.xJe = this.Get.animate(s, Sw),
                this.xJe.onfinish = t => this.PZe(),
                document.addEventListener("visibilitychange", this.pWe)
            }
            bw.qs.HY.OYe("dialogclose", this)
        }
        O6i() {
            return this.Dge || !this.Bj()
        }
        gwt() {
            this.PR(!0)
        }
        tWt() {
            this.vwt()
        }
        bge() {
            this.tWt()
        }
        PR(t) {
            this.Dge || bw.qs.HY.npi(this) && (this.OZe(t),
            this.AZe(),
            bw.qs.HY.OYe("dialogok", this, t))
        }
        OZe(t) {
            this.yJe ? Iw.lVe(this.yJe, t) : (this.wJe && this.wJe(t),
            this.ZJe = null)
        }
        vwt(t=!1) {
            t = !!t,
            this.Dge || bw.qs.HY.HYe(this) && (this.DZe(),
            this.AZe(t),
            bw.qs.HY.OYe("dialogcancel", this, null))
        }
        DZe() {
            this.yJe ? Iw.lVe(this.yJe, null) : (this.wJe && this.wJe(null),
            this.ZJe = null)
        }
        FZe(t) {
            this.Dge || (this.LZe(t),
            this.AZe())
        }
        LZe(t) {
            this.yJe ? Iw.uVe(this.yJe, t) : (this.gJe && this.gJe(t),
            this.ZJe = null)
        }
        HLt() {}
        jLt() {}
        BZe() {
            bw.qs.HY.OYe("dialogpositioningchange", this)
        }
        hZe() {
            this.xJe && (this.xJe.cancel(),
            this.xJe = null,
            this.PZe())
        }
        PZe() {
            if (this.xJe && this.xJe.cancel(),
            document.removeEventListener("visibilitychange", this.pWe),
            this.Dge) {
                if (this.OJe || (this.VW(),
                bw.qs.HY.kYe(this, !1),
                this.UJe && (this.UJe.he(),
                this.UJe = null)),
                bw.zk.R$i) {
                    const t = document.activeElement;
                    this.Get.close(),
                    t && t !== document.activeElement && bw.qs.HY.FYe(this) && bw.Edi(t, "dialog") !== this.hk() && t.focus()
                }
                this._Wt = !1,
                !this.OJe && this.DJe && (this.G_t(),
                this._Je = !0),
                this.mJe ? this.Get.style.display = "none" : this.uJe !== this.cJe && (bw.qs.BW(this.Get),
                this.uJe.body.appendChild(this.Get)),
                this.cJe = null,
                this.bJe && (this.bJe(),
                this.bJe = null),
                this.jLt()
            }
            this.MJe && this.HLt();
            let t = this.MJe;
            this.MJe = !1,
            this.Dge = !1,
            this.xJe = null,
            t && !this.OJe && (bw.kt.mj ? this.JIe() : (this.fge(),
            this.sJe())),
            this.v7t(),
            t && this.BZe()
        }
        VW() {}
        IR() {
            return new Promise( (t, i) => {
                this.bJe = t
            }
            )
        }
        PH() {
            return this.cJe
        }
        M6i() {
            return this.pJe
        }
        eJe() {
            return this.hit() && this.JXe()
        }
        UZe(t) {
            this.RJe = !!t
        }
        jJe(t) {
            if (t.preventDefault(),
            !this.RJe || this.kJe)
                return;
            if (this.Pme())
                return;
            bw.p.u("ui.dialogs.caption-menu");
            let i = bw.v(bw.qs.Ek, this.vJe);
            this.eJe() && i.Pk("open-popup", self.lang(".open-to-popup-window"), () => this.J_t(), {
                Ck: !0
            }),
            i.Pk("close", self.lang(".close"), () => this.tWt()),
            i.nF(t.clientX, t.clientY),
            bw.p.j()
        }
        J_t(t, i) {
            if (bw.cO(t),
            bw.cO(i),
            this.kJe)
                throw new Error("already awaiting popup window");
            if (this.DJe)
                throw new Error("already in popup window");
            if (!this.eJe())
                return;
            this.kJe = !0,
            this.JLt("beforepopupopen");
            let e = "window.html";
            return bw.jii() || (e += "?mode=dev"),
            bw.qs.oYe.lYe(e, this.rVt, this.ns(), this.Kn(), t, i).then(t => {
                const i = t.window;
                return i.addEventListener("unload", t => this.NZe(i)),
                this.jZe(i)
            }
            ).catch(t => {
                this.kJe = !1,
                this.lWt(),
                bw.qs.Ys.$s("OK").Qa(self.lang("ui.cannot-open-popup")),
                this.JLt("afterpopupclose")
            }
            )
        }
        $Ze() {
            return this.gX() ? Promise.resolve().then( () => Promise.all(this.kJ().map(t => (this.yZe(t),
            t.J_t())))) : Promise.resolve()
        }
        jZe(t) {
            return Promise.resolve().then( () => this.$Ze()).then( () => {
                if (this.OJe = !0,
                this.JJe = this.bF(),
                this.lFs() && !this.fZe() && this.JJe.yZe(this),
                this.Bj())
                    return this.AZe()
            }
            ).then( () => (this.kJe = !1,
            this.DJe = t,
            window.addEventListener("unload", this.FJe),
            this.Get.setAttribute("inPopupWindow", ""),
            this.Get.style.transform = "",
            this.Get.style.width = "",
            this.Get.style.height = "",
            this.MZe(this.pJe),
            this.OJe = !1,
            t.document.title = this.TJe,
            this.JLt("afterpopupopen"),
            bw.qs.oYe.bYe(t, "dialog-transferred", null),
            this.lWt(),
            t))
        }
        NZe(t) {
            this.DJe && (bw.qs.HY.GYe(t).forEach(t => {
                t !== this && t.vwt(!0)
            }
            ),
            this.JLt("beforepopupclose"),
            this.OJe = !0,
            this.ZC = bw.Ne(this.DJe.innerWidth, this.IJe, bw.IOt(.9 * window.innerWidth)),
            this.tv = bw.Ne(this.DJe.innerHeight, this.PJe, bw.IOt(.9 * window.innerHeight)),
            window.removeEventListener("unload", this.FJe),
            this.AZe(),
            this.DJe = null,
            this.Get.removeAttribute("inPopupWindow"),
            this._Je = !0,
            !this.lFs() || this.lFs() && !this.bF().NBi() ? this.MZe(this.pJe) : this.DZe(),
            this.JLt("afterpopupclose"),
            this.OJe = !1,
            this.JJe = null,
            this.lWt())
        }
        G_t() {
            if (this.DJe) {
                this.ZC = bw.Ne(this.DJe.innerWidth, this.IJe, bw.IOt(.9 * window.innerWidth)),
                this.tv = bw.Ne(this.DJe.innerHeight, this.PJe, bw.IOt(.9 * window.innerHeight));
                let t = this.DJe;
                this.DJe = null,
                t.close(),
                this.Get.removeAttribute("inPopupWindow"),
                this.kJe = !1
            }
        }
        DXe() {
            if (!this.Bj())
                return;
            super.DXe(),
            this.kd = bw.IOt(this.bXe.left),
            this.Gd = bw.IOt(this.bXe.top);
            let t = 2 * this.uge();
            this.ZC = this.bXe.right - this.bXe.left - t,
            this.tv = this.bXe.bottom - this.bXe.top - t
        }
        TZe() {
            this.JIe(),
            this.Get.style.margin = "0",
            this.Get.style.position = "absolute",
            this.Get.style.left = "0px",
            this.Get.style.top = "0px",
            this.v7t()
        }
        lge() {}
        JIe() {
            if (!this.cJe || !this.cJe.defaultView)
                return;
            this.v7t(),
            super.Kpt();
            let t = 2 * this.uge()
              , i = (this.ZC + t) / 2
              , e = (this.tv + t) / 2
              , s = this.cJe.defaultView.innerWidth / 2
              , n = this.cJe.defaultView.innerHeight / 2;
            this.kd = bw.IOt(s - i - this.oZe()),
            this.Gd = bw.IOt(n - e - this.aZe()),
            this.fge()
        }
        IZe() {
            let t = bw.qs.yQ("min-width", {
                vQ: this.Get
            });
            if ("auto" === t && (t = "0px"),
            !t.endsWith("px"))
                throw new Error("CSS style for dialog min-width must specify the size in units of 'px'");
            let i = parseInt(t, 10);
            isFinite(i) || (i = this.hit() ? Mw : xw),
            this.IJe = i;
            let e = bw.qs.yQ("min-height", {
                vQ: this.Get
            });
            if ("auto" === e && (e = "0px"),
            !e.endsWith("px"))
                throw new Error("CSS style for dialog min-height must specify the size in units of 'px'");
            let s = parseInt(e, 10);
            isFinite(s) || (s = this.hit() ? Cw : Ew),
            this.PJe = s
        }
        Kpt() {
            if (!this.CJe || this.lFs()) {
                let t = 2 * this.uge()
                  , i = this.oZe()
                  , e = this.aZe();
                return {
                    left: this.kd + i,
                    top: this.Gd + e,
                    right: this.kd + this.ZC + t + i,
                    bottom: this.Gd + this.tv + t + e,
                    width: this.ZC + t,
                    height: this.tv + t
                }
            }
            return super.Kpt()
        }
        fge() {
            this.MJe || this.Dge || (this.NBi() ? this.Get.style.transform = "" : this.Get.style.transform = `translate(${this.kd}px,${this.Gd}px)`)
        }
        Zps(t, i) {
            bw.Ge(t),
            bw.Ge(i),
            t = bw.IOt(t),
            i = bw.IOt(i),
            this.kd === t && this.Gd === i || this.DJe || (this.kd = t,
            this.Gd = i,
            this.fge(),
            this.v7t(),
            this.JLt("positionchange"),
            this.lWt())
        }
        kp(t) {
            bw.Ge(t),
            t = bw.IOt(t),
            this.kd === t || this.DJe || (this.kd = t,
            this.fge(),
            this.v7t(),
            this.JLt("positionchange"),
            this.lWt())
        }
        _a() {
            return this.Kpt(),
            this.kd
        }
        byi() {
            return this._a() + this.uge() + this.oZe()
        }
        Gp(t) {
            bw.Ge(t),
            t = bw.IOt(t),
            this.Gd === t || this.DJe || (this.Gd = t,
            this.fge(),
            this.v7t(),
            this.JLt("positionchange"),
            this.lWt())
        }
        Da() {
            return this.Kpt(),
            this.Gd
        }
        yyi() {
            return this.Da() + this.uge() + this.aZe()
        }
        Qx(t) {
            bw.Ge(t),
            (t = bw.IOt(t)) < this.IJe && (t = this.IJe),
            this.ZC !== t && (this.ZC = t,
            this.Get.style.width = `${this.ZC}px`,
            this.v7t(),
            this.JLt("widthchange"),
            this.lWt())
        }
        ns() {
            return this.Kpt(),
            this.ZC
        }
        qnt() {
            return this.IJe
        }
        Kx(t) {
            bw.Ge(t),
            (t = bw.IOt(t)) < this.PJe && (t = this.PJe),
            this.tv !== t && (this.tv = t,
            this.Get.style.height = `${this.tv}px`,
            this.v7t(),
            this.JLt("heightchange"),
            this.lWt())
        }
        Kn() {
            return this.Kpt(),
            this.tv
        }
        Xnt() {
            return this.PJe
        }
        hit() {
            return this.dJe
        }
        sJe() {
            if (-1 === this.WJe && !this.DJe) {
                if (this.Kpt(),
                bw.kt.mj)
                    this.JIe();
                else {
                    if (!this.cJe)
                        return;
                    const t = this.cJe.defaultView.innerWidth
                      , i = this.cJe.defaultView.innerHeight
                      , e = 2 * this.uge()
                      , s = -this.oZe()
                      , n = -this.aZe();
                    this.dJe ? (this.ZC + e > t && this.Qx(t - e),
                    this.tv + e > i && this.Kx(i - e),
                    this.kd < s ? this.kp(s) : this.kd - s + this.ZC + e > t && this.kp(t - this.ZC - e + s),
                    this.Gd < n ? this.Gp(n) : this.Gd - n + this.tv + e > i && this.Gp(i - this.tv - e + n)) : (this.kd < s || this.kd - s + this.ZC + e > t || this.Gd < n || this.Gd - n + this.tv + e > i) && this.JIe()
                }
                this.JLt("resize")
            }
        }
        KJe(t) {
            bw.kt.lA || -1 === this.WJe && this.HJe !== window.orientation && (this.HJe = window.orientation,
            this.WJe = setTimeout( () => {
                this.WJe = -1,
                this.GJe()
            }
            , Tw))
        }
        FIe() {
            if (!bw.kt.mj && !this.NBi())
                for (; bw.qs.HY.DYe(this); )
                    this.Zps(this._a() + _w, this.Da() + _w)
        }
        uH(t, i) {
            return bw.Ge(t),
            bw.Ge(i),
            !!this.Bj() && super.uH(t, i)
        }
        sot(t, i, e) {
            bw.Ge(t),
            bw.Ge(i),
            bw.cO(e),
            bw.qs.HY.YYe(this, t, i, e)
        }
        FP(t) {
            const i = t.which;
            if (this.Dge)
                return t.preventDefault(),
                void t.stopPropagation();
            i === bw.kE.IE ? (t.preventDefault(),
            t.stopPropagation(),
            this.tWt()) : i !== bw.kE.w9 || t.shiftKey || (t.preventDefault(),
            t.stopPropagation(),
            this.gwt())
        }
        QYe() {}
        rJe() {}
        JYe() {}
        nJe() {}
        uge() {
            return this.NBi() ? 0 : this.hit() ? bw.qs.Oqe() : bw.qs.kqe()
        }
        ZYe(t, i) {
            if (bw.Ge(t),
            bw.Ge(i),
            !this.hit())
                return "";
            if (bw.kt.mj)
                return "";
            let e = this.Kpt()
              , s = this.uge()
              , n = 2 * s
              , r = "";
            return t > e.left + s && t < e.right - s && i > e.top + s && i < e.bottom - s ? r = "m" : bw.qs.iA.ZXe() ? t >= e.left && t <= e.left + n ? i >= e.top && i <= e.top + n ? r = "nw" : i <= e.bottom && i >= e.bottom - n ? r = "sw" : i > e.top + n && i < e.bottom - n && t <= e.left + s && (r = "w") : t <= e.right && t >= e.right - n ? i >= e.top && i <= e.top + n ? r = "ne" : i <= e.bottom && i >= e.bottom - n ? r = "se" : i > e.top + n && i < e.bottom - n && t >= e.right - s && (r = "e") : t > e.left + n && t < e.right - n && (i >= e.top && i <= e.top + s ? r = "n" : i <= e.bottom && i >= e.bottom - s && (r = "s")) : r = "",
            r
        }
        JLt(t, i) {
            bw.zt(t),
            bw._U(i);
            let e = new bw.Event(t);
            e.nWt = this,
            i && Object.assign(e, i),
            this.dispatchEvent(e)
        }
        zZe() {
            if (this.mJe)
                throw new Error("already keeping in main document");
            this.mJe = !0,
            this.uJe = document,
            document.body.appendChild(this.Get),
            this.Get.style.display = "none"
        }
        kge(t) {
            this.SCe && this.SCe.x_(t)
        }
    }
}
{
    const Gw = self.t;
    Gw.qs.Qyi = class {
        constructor() {
            this.Xbi = null,
            this.jet = null,
            this.VZe = !1,
            this.WZe = null
        }
        Qa(t, i, e, s) {
            return Gw.Kq(t),
            Gw.Hdt(i),
            e = !!e,
            s = !!s,
            this.Xbi = i ? i.ownerDocument : document,
            this.jet = Gw.qs.lk("input", this.Xbi.body),
            this.jet.setAttribute("hidden", ""),
            this.jet.setAttribute("type", "file"),
            t && this.jet.setAttribute("accept", t),
            e && this.jet.setAttribute("multiple", ""),
            s && (this.jet.setAttribute("webkitdirectory", ""),
            this.jet.setAttribute("mozdirectory", "")),
            new Promise( (t, i) => {
                this.WZe = i => {
                    if (this.VZe = !0,
                    this.jet.files.length)
                        if (e)
                            t(this.jet.files);
                        else {
                            const i = this.jet.files[0];
                            t(i)
                        }
                    else
                        t(null);
                    this.VW()
                }
                ,
                this.jet.addEventListener("change", this.WZe),
                this.jet.click()
            }
            )
        }
        VW() {
            this.jet.removeEventListener("change", this.WZe),
            this.WZe = null,
            Gw.qs.BW(this.jet),
            this.jet = null,
            this.Xbi = null
        }
        static async tbi(t, i, e, s) {
            const n = new Gw.qs.Qyi;
            return await n.Qa(t, i, e, s)
        }
    }
}
{
    const Aw = self.t
      , Rw = Aw.ek(import.meta.url).getElementById("okDialog")
      , kw = "OK"
      , Ow = {
        message: "",
        align: "center",
        HZe: !1,
        h8i: null,
        KZe: null
    }
      , Dw = Aw.qs.Ys.OK = class extends Aw.qs.Ys {
        constructor() {
            super(Rw),
            this.qZe = this.dwt("okMessage"),
            this.XZe = this.dwt("okList"),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.YZe = this.dwt("okDialogDoNotShowAgainWrapper"),
            this.JZe = this.dwt("doNotShowAgainInput"),
            this.ZZe = this.dwt("doNotShowAgainLabel"),
            this.QZe = null,
            this.fJe = !1
        }
        Swt() {
            this.lKi.textContent = self.lang("common.ok")
        }
        Qa(t, i) {
            let e;
            Aw.wke(t) ? (e = Object.assign({}, Ow),
            e.message = t) : (Aw.Yq(t),
            e = Object.assign({}, Ow, t));
            let s = e.message;
            if (Aw.qs.CD(this.y5t(), "alignleft", "left" === e.align),
            Aw.qs.CD(this.y5t(), "selectable", e.HZe),
            "function" == typeof e.h8i ? (Aw.odt(this.ZZe, self.lang("common.do-not-show-again")),
            this.QZe = () => {
                e.h8i(this.JZe.value)
            }
            ,
            this.JZe.addEventListener("input", this.QZe),
            this.YZe.style.display = "") : this.YZe.style.display = "none",
            Aw.odt(this.qZe, s),
            Aw.qs.BYt(this.XZe),
            e.KZe && Aw.kft(e.KZe)) {
                this.XZe.style.display = "";
                for (const t of e.KZe) {
                    Aw.u7t(t);
                    const i = Aw.qs.lk("li", this.XZe, null, "okListItem");
                    Aw.odt(i, t)
                }
            } else
                this.XZe.style.display = "none";
            return super.Qa(i)
        }
        VW() {
            this.JZe.removeEventListener("input", this.QZe),
            this.JZe.value = !1,
            this.Ya(null)
        }
    }
    ;
    Aw.qs.HY.ipt.addEventListener("load", function() {
        Aw.qs.Ys.opt(kw, Dw)
    })
}
{
    const Fw = self.t
      , Lw = Fw.ek(import.meta.url).getElementById("confirmDialog")
      , Bw = "Confirm"
      , Uw = Fw.qs.Ys.tQe = class extends Fw.qs.Ys {
        constructor() {
            super(Lw),
            this.sOe = null,
            this.c3s = this.dwt("confirmMessage"),
            this.iQe = this.dwt("confirmButton"),
            this.fJe = !1,
            this.iQe.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelConfirmButton"),
            this.lhs.onclick = () => this.tWt()
        }
        Swt() {}
        Qa(t, i) {
            Fw.Hut(t),
            Fw.Hdt(i);
            let e = t.caption || ""
              , s = t.message || ""
              , n = t.jD || self.lang("common.ok")
              , r = t.vD || self.lang("common.cancel");
            const h = !t.eQe;
            return e && this.Ya(e),
            Fw.odt(this.c3s, s),
            this.iQe.textContent = n,
            this.lhs.textContent = r,
            h ? this.iQe.classList.add("bold") : this.iQe.classList.remove("bold"),
            this.NJe = !t.sQe,
            super.Qa(i)
        }
        gwt() {
            this.sOe && this.sOe(),
            super.gwt()
        }
        VW() {
            this.sOe = null
        }
    }
    ;
    Fw.qs.HY.ipt.addEventListener("load", function() {
        Fw.qs.Ys.opt(Bw, Uw)
    })
}
{
    const Nw = self.t
      , jw = Nw.ek(import.meta.url).getElementById("confirmCheckDialog")
      , $w = "ConfirmCheck"
      , zw = Nw.qs.Ys.nQe = class extends Nw.qs.Ys {
        constructor() {
            super(jw),
            this.sOe = null,
            this.c3s = this.dwt("confirmMessage"),
            this.iQe = this.dwt("confirmButton"),
            this.rQe = this.dwt("confirmCheckbox"),
            this.hQe = this.dwt("confirmCheckLabel"),
            this.oQe = !1,
            this.fJe = !1,
            this.iQe.onclick = () => (this.sOe && this.sOe(),
            this.gwt()),
            this.lhs = this.dwt("cancelConfirmButton"),
            this.lhs.onclick = () => this.tWt(),
            this.aQe = this.dwt("buttonSpacer")
        }
        Swt() {}
        Qa(t, i) {
            Nw.Hut(t),
            Nw.Hdt(i),
            Nw.zt(t.lQe);
            let e = t.caption || ""
              , s = t.message || ""
              , n = t.jD || self.lang("common.ok")
              , r = t.vD || self.lang("common.cancel");
            const h = !!t.uQe;
            this.rQe.checked = h,
            this.oQe = h,
            this.hQe.textContent = t.lQe,
            e && this.Ya(e),
            Nw.odt(this.c3s, s),
            this.iQe.textContent = n,
            this.lhs.textContent = r,
            this.NJe = !t.sQe,
            t.cQe ? (this.lhs.style.display = "none",
            this.aQe.style.display = "none",
            this.iQe.classList.remove("bold")) : (this.lhs.style.display = "",
            this.aQe.style.display = "",
            this.iQe.classList.add("bold"));
            const o = super.Qa(i);
            return this.iQe.focus(),
            o
        }
        gwt() {
            this.oQe = this.rQe.checked,
            super.gwt()
        }
        tWt() {
            this.oQe = this.rQe.checked,
            super.tWt()
        }
        dQe() {
            return this.oQe
        }
        VW() {
            this.sOe = null
        }
    }
    ;
    Nw.qs.HY.ipt.addEventListener("load", function() {
        Nw.qs.Ys.opt($w, zw)
    })
}
{
    const Vw = self.t
      , Ww = Vw.ek(import.meta.url).getElementById("confirmMultipleDialog")
      , Hw = "ConfirmMultiple"
      , Kw = Vw.qs.Ys.fQe = class extends Vw.qs.Ys {
        constructor() {
            super(Ww),
            this.sOe = null,
            this.c3s = this.dwt("confirmMultipleMessage"),
            this.pQe = this.dwt("optionButtonsWrap"),
            this.mQe = this.dwt("cancelButtonWrap"),
            this.wQe = ""
        }
        Swt() {}
        Qa(t, i) {
            Vw.Hut(t),
            Vw.Hdt(i),
            Vw._D(t.options);
            const e = t.caption || ""
              , s = t.message || "";
            e && this.Ya(e),
            Vw.odt(this.c3s, s);
            const n = super.Qa(i);
            for (let i = 0, e = t.options.length; i < e; ++i) {
                const s = t.options[i]
                  , n = s.text
                  , r = s.tag;
                Vw.zt(n),
                Vw.zt(r);
                const h = Vw.qs.lk("button", this.pQe);
                if (h.textContent = n,
                h.onclick = () => this.gwt(r),
                0 === i && (this.wQe = r,
                h.setAttribute("main", "")),
                i < e - 1) {
                    Vw.qs.lk("span", this.pQe).setAttribute("button-spacer", "")
                }
            }
            if (t.PD) {
                const t = Vw.qs.lk("button", this.mQe);
                t.textContent = self.lang("common.cancel"),
                t.onclick = () => this.gwt("cancel"),
                t.setAttribute("cancel", "")
            }
            return n
        }
        gwt(t) {
            Vw.Kq(t),
            t || (t = this.wQe),
            "cancel" === t ? this.vwt() : (this.sOe && this.sOe(t),
            this.PR(t))
        }
        VW() {
            this.sOe = null,
            Vw.qs.BYt(this.pQe),
            Vw.qs.BYt(this.mQe)
        }
    }
    ;
    Vw.qs.HY.ipt.addEventListener("load", function() {
        Vw.qs.Ys.opt(Hw, Kw)
    })
}
{
    const qw = self.t
      , Xw = qw.ek(import.meta.url)
      , Yw = Xw.getElementById("progressDialog")
      , Jw = qw.tk(Xw.URL);
    qw.p.ik(Jw + "lang");
    const Zw = "Progress"
      , Qw = 100
      , tg = qw.qs.Ys.gQe = class extends qw.qs.Ys {
        constructor() {
            super(Yw),
            this.yQe = this.dwt("progressBar"),
            this.onprogress = null,
            this.bQe = !0,
            this.fVe = -1,
            this.vQe = 0,
            this.SQe = "",
            this.o1 = null,
            this.fJe = !1,
            this.xQe = null,
            this.lhs = this.dwt("cancelConfirmButton"),
            this.lhs.onclick = () => this.tWt()
        }
        Swt() {}
        Qa(t, i, e) {
            qw.Kq(t),
            this.vQe = 0,
            t ? this.SQe = t : this.onprogress ? this.SQe = `${self.lang("ui.dialogs.progress.titleBase")} ({0}%)...` : this.SQe = `${self.lang("ui.dialogs.progress.titleBase")}...`,
            this.lhs.textContent = self.lang("ui.dialogs.progress.cancelButton"),
            this.onprogress ? (this.MQe(!1),
            this.EQe(!0),
            this.fVe = window.setInterval( () => this.EQe(), Qw)) : (this.MQe(!0),
            this.Ya(this.SQe)),
            e ? (this.xQe = e,
            this.lhs.style.display = "") : (this.xQe = null,
            this.lhs.style.display = "none"),
            this.NJe = !!e;
            const s = super.Qa(i);
            return this.o1 || (this.o1 = qw.qs.SH.gH("wait", this.PH())),
            s
        }
        MQe(t) {
            t = !!t,
            this.bQe !== t && (this.bQe = t,
            this.bQe ? (this.yQe.removeAttribute("value"),
            this.yQe.removeAttribute("max")) : (this.yQe.value = this.vQe,
            this.yQe.max = 1))
        }
        EQe(t) {
            if (!this.onprogress)
                return;
            let i = this.onprogress();
            (this.vQe !== i || t) && (this.vQe = i,
            null === this.vQe ? (this.MQe(!0),
            this.Ya(this.SQe.replace("{0}", "0"))) : (isFinite(this.vQe) || (this.vQe = 0),
            this.vQe = qw.Ne(this.vQe, 0, 1),
            this.MQe(!1),
            this.yQe.value = this.vQe,
            this.Ya(this.SQe.replace("{0}", Math.round(1e3 * i) / 10))))
        }
        AZe() {
            -1 !== this.fVe && (window.clearInterval(this.fVe),
            this.fVe = -1),
            qw.qs.SH.CH(this.o1),
            this.o1 = null,
            this.onprogress = null,
            this.vQe = 0,
            super.AZe()
        }
        gwt() {}
        tWt() {
            this.xQe && (this.xQe(),
            super.tWt())
        }
    }
    ;
    qw.qs.HY.ipt.addEventListener("load", function() {
        qw.qs.Ys.opt(Zw, tg)
    })
}
{
    const ig = self.t
      , eg = ig.ek(import.meta.url)
      , sg = eg.getElementById("downloadDialog")
      , ng = ig.tk(eg.URL);
    ig.p.ik(ng + "lang");
    const rg = "Download"
      , hg = 10
      , og = ig.qs.Ys.qU = class extends ig.qs.Ys {
        constructor() {
            super(sg),
            this.yQe = this.dwt("downloadProgressBar"),
            this.CQe = this.dwt("downloadDetails"),
            this.fVe = -1,
            this.gEe = "",
            this.Oxs = "",
            this._Qe = 0,
            this.TQe = 0,
            this.IQe = 0,
            this.PQe = [],
            this.GQe = 0,
            this.AQe = !1,
            this.o1 = null,
            this.fJe = !1
        }
        Swt() {}
        Qa(t, i) {
            ig.zt(t),
            this.gEe = t,
            this._Qe = 0,
            this.TQe = 0,
            this.GQe = 0,
            this.IQe = 0,
            ig.sc(this.PQe),
            this.AQe = !0;
            let e = this.gEe.lastIndexOf("/");
            this.Oxs = this.gEe.substring(e + 1),
            this.Ya(self.lang("ui.dialogs.download.caption")),
            this.NJe = !1;
            let s = super.Qa(i);
            return this.o1 || (this.o1 = ig.qs.SH.gH("progress", this.PH())),
            ig.Kl(t, t => this.RQe(t)).then(t => {
                ig.qs.SH.CH(this.o1),
                this.o1 = null,
                this.PR(t)
            }
            ).catch(t => {
                ig.qs.SH.CH(this.o1),
                this.o1 = null,
                this.FZe(t)
            }
            ),
            this.fVe = window.setInterval( () => this.kQe(!0), 1e3),
            this.kQe(),
            s
        }
        RQe(t) {
            if (!t.lengthComputable)
                return;
            this.GQe = t.total,
            this.TQe = t.loaded,
            this.AQe && (this.AQe = !1,
            this.kQe(!1));
            let i = 100 * this.TQe / this.GQe;
            this.yQe.value = i,
            this.Ya(self.tP("ui.dialogs.download.caption-progress", Math.round(i)))
        }
        OQe(t) {
            ig.Ge(t),
            this.PQe.length >= hg && this.PQe.shift(),
            this.PQe.push(t)
        }
        DQe() {
            if (0 === this.PQe.length)
                return 0;
            let t = 0;
            for (let i of this.PQe)
                t += i;
            return t / this.PQe.length
        }
        kQe(t) {
            t && (this.IQe = this.TQe - this._Qe,
            this.OQe(this.IQe),
            this._Qe = this.TQe);
            const i = self.lang;
            ig.p.u("ui.dialogs.download");
            let e = i(".downloading-label") + this.Oxs;
            this.GQe > 0 && (e += " (" + ig.Iye(this.GQe) + ")"),
            e += "<br/>",
            e += i(".speed-label"),
            0 === this.IQe ? e += i(".calculating") : e += ig.Iye(this.IQe, !0);
            let s = navigator.connection || navigator.FQe || navigator.LQe
              , n = s ? s.type : "";
            n && "other" !== n && "unknown" !== n && (e += " (" + n + ")"),
            e += "<br/>",
            e += i(".time-remaining-label");
            let r = -1;
            if (this.PQe.length < 2)
                e += i(".calculating");
            else {
                let t = this.DQe();
                0 === t ? e += i(".stalled") : (r = (this.GQe - this.TQe) / t,
                r = 5 * Math.round(r / 5),
                e += r < 5 ? i("common.time.a-few-seconds") : ig.PBe(r, {
                    EBe: !0
                }))
            }
            this.CQe.innerHTML = e,
            ig.p.j(),
            this.JIe()
        }
        AZe() {
            window.clearInterval(this.fVe),
            this.fVe = -1,
            super.AZe()
        }
        gwt() {}
        tWt() {}
    }
    ;
    ig.qs.HY.ipt.addEventListener("load", function() {
        ig.qs.Ys.opt(rg, og)
    })
}
{
    const ag = self.t
      , lg = ag.ek(import.meta.url)
      , ug = lg.getElementById("openPopupWindowDialog")
      , cg = ag.tk(lg.URL)
      , dg = "OpenPopupWindow";
    ag.p.ik(cg + "lang");
    const fg = ag.qs.Ys.BQe = class extends ag.qs.Ys {
        constructor() {
            super(ug),
            this.c3s = this.dwt("openPopupWindowMessage"),
            this.UQe = this.dwt("openPopupWindowTryAgain"),
            this.UQe.onclick = () => this.gwt(),
            this.lhs = this.dwt("openPopupWindowCancel"),
            this.lhs.onclick = () => this.tWt(),
            this.gEe = "",
            this.gTt = null,
            this.fJe = !1
        }
        Swt() {
            const t = self.lang;
            this.Ya(t("ui.dialogs.openPopupWindow.caption")),
            ag.p.u("ui.dialogs.openPopupWindow"),
            this.c3s.textContent = t(".body"),
            this.lhs.textContent = t("common.cancel"),
            this.UQe.textContent = t(".try-again"),
            ag.p.j()
        }
        Qa(t, i) {
            return this.gEe = t,
            this.gTt = i,
            super.Qa(i.Owt)
        }
        gwt() {
            const t = Object.assign({}, this.gTt);
            t.aYe = !1,
            ag.qs.oYe.EYe(this.gEe, t).then(t => {
                t && this.PR(t)
            }
            )
        }
    }
    ;
    ag.qs.HY.ipt.addEventListener("load", function() {
        ag.qs.Ys.opt(dg, fg)
    })
}
{
    const pg = self.t
      , mg = pg.ek(import.meta.url).getElementById("fontPickerDialog")
      , wg = "FontPicker"
      , gg = 250
      , yg = {
        Ore: "",
        _re: "",
        Rre: 20,
        Fre: [],
        Hre: ""
    }
      , bg = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
      , vg = pg.qs.Ys.NQe = class extends pg.qs.Ys {
        constructor() {
            super(mg),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.jQe = this.dwt("fontPickerLocalHeaderText"),
            this.$Qe = this.dwt("localFontSelect"),
            this.$Qe.addEventListener("change", () => this.zQe()),
            this.VQe = this.dwt("additionalFontSection"),
            this.WQe = this.dwt("fontPickerAdditionalHeaderText"),
            this.HQe = this.dwt("additionalFontSelect"),
            this.HQe.addEventListener("change", () => this.KQe()),
            this.qQe = this.dwt("sampleTextHeader"),
            this.XQe = this.dwt("sampleText"),
            this.YQe = "",
            this.JQe = this.dwt("fontPickerMorePreview"),
            this.JQe.onclick = () => this.ZQe(),
            this.QQe = "",
            this.t0e = "",
            this.i0e = !1,
            this.hn = !1,
            this.fJe = !1
        }
        Swt() {
            pg.p.u("ui.dialogs.std.font-picker");
            const t = self.lang;
            this.Ya(t(".caption")),
            this.jQe.textContent = t(".loading-message"),
            this.lKi.textContent = t("common.ok"),
            this.lhs.textContent = t("common.cancel"),
            this.JQe.textContent = t(".more-preview"),
            pg.p.j()
        }
        Qa(t, i) {
            pg.Yq(t),
            t = Object.assign({}, yg, t),
            pg.zt(t.Ore),
            pg.zt(t._re),
            pg._D(t.Fre),
            pg.zt(t.Hre),
            this.i0e || this.hn || this.e0e(),
            this.QQe = t.Ore || "",
            this.t0e = this.QQe,
            this.YQe = t._re || "";
            let e = t.Rre;
            return e > 72 && (e = 72),
            this.XQe.style.fontSize = `${e}pt`,
            this.YQe.length > gg && (this.YQe = this.YQe.substr(0, gg) + "..."),
            t.Fre.length ? (this.VQe.removeAttribute("hidden"),
            this.WQe.textContent = t.Hre || self.lang("ui.dialogs.std.font-picker.default-additional-fonts-header"),
            this.s0e(t.Fre)) : this.VQe.setAttribute("hidden", ""),
            this.i0e && (this.XQe.textContent = this.YQe || self.lang("ui.dialogs.std.font-picker.default-sample-text"),
            this.n0e()),
            super.Qa(i)
        }
        e0e() {
            this.hn = !0;
            const t = this.hk().ownerDocument
              , i = pg.p.Ok("ui.dialogs.std.font-picker")
              , e = t.createElement("option");
            e.value = "",
            e.textContent = i(".none-selected"),
            this.$Qe.appendChild(e);
            const s = t.createElement("optgroup");
            s.label = i(".generic-font-families-group");
            for (const e of bg) {
                const n = t.createElement("option");
                n.value = e,
                n.textContent = i(`.generic-font-families.${e}`),
                n.style.fontFamily = e,
                n.setAttribute("title", e),
                n.addEventListener("UIDoubleTap", () => this.PR(e)),
                s.appendChild(n)
            }
            this.$Qe.appendChild(s),
            pg.lBe.uBe().then(t => this.r0e(t))
        }
        r0e(t) {
            this.hn = !1,
            this.i0e = !0;
            const i = this.hk().ownerDocument
              , e = pg.p.Ok("ui.dialogs.std.font-picker")
              , s = i.createElement("optgroup");
            s.label = e(".other-fonts-group");
            for (const e of t) {
                const t = i.createElement("option");
                t.value = e,
                t.textContent = e,
                t.style.fontFamily = e,
                t.setAttribute("title", e),
                t.addEventListener("UIDoubleTap", () => this.PR(e)),
                s.appendChild(t)
            }
            this.$Qe.appendChild(s),
            this.n0e(),
            this.jQe.textContent = e(".local-font-header"),
            this.qQe.textContent = e(".sample-text-header"),
            this.XQe.textContent = this.YQe || e(".default-sample-text")
        }
        s0e(t) {
            let i = this.hk().ownerDocument
              , e = i.createElement("option");
            e.value = "",
            e.textContent = self.lang("ui.dialogs.std.font-picker.none-selected"),
            this.HQe.appendChild(e);
            for (let e of t) {
                let t = i.createElement("option");
                t.value = e,
                t.textContent = e,
                t.style.fontFamily = e,
                t.setAttribute("title", e),
                t.addEventListener("UIDoubleTap", () => this.PR(e)),
                this.HQe.appendChild(t)
            }
        }
        n0e() {
            this.QQe && (this.$Qe.value = this.QQe,
            -1 === this.$Qe.selectedIndex ? (this.HQe.value = this.QQe,
            -1 === this.HQe.selectedIndex ? (this.$Qe.selectedIndex = 0,
            this.zQe()) : this.KQe()) : this.zQe())
        }
        zQe() {
            0 !== this.$Qe.selectedIndex ? (this.t0e = this.$Qe.value,
            this.$Qe.style.fontFamily = this.t0e,
            this.HQe.selectedIndex = 0,
            this.HQe.style.fontFamily = "",
            this.h0e()) : this.$Qe.style.fontFamily = ""
        }
        KQe() {
            0 !== this.HQe.selectedIndex ? (this.t0e = this.HQe.value,
            this.HQe.style.fontFamily = this.t0e,
            this.$Qe.selectedIndex = 0,
            this.$Qe.style.fontFamily = "",
            this.h0e()) : this.HQe.style.fontFamily = ""
        }
        h0e() {
            this.XQe.style.fontFamily = this.t0e
        }
        ZQe() {
            pg.qs.Ys.$s("FontPreview").Qa(this.t0e, this.hk())
        }
        gwt() {
            this.PR(this.t0e)
        }
        VW() {
            pg.qs.BYt(this.HQe)
        }
    }
    ;
    pg.qs.HY.ipt.addEventListener("load", function() {
        pg.qs.Ys.opt(wg, vg)
    })
}
{
    const Sg = self.t
      , xg = Sg.ek(import.meta.url)
      , Mg = xg.getElementById("fontPreviewDialog")
      , Eg = Sg.tk(xg.URL);
    Sg.p.ik(Eg + "lang");
    const Cg = "FontPreview"
      , _g = [5, 8, 11, 14, 20, 36, 48, 72]
      , Tg = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"])
      , Ig = Sg.qs.Ys.o0e = class extends Sg.qs.Ys {
        constructor() {
            super(Mg),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.a0e = this.dwt("fontPreviewBody"),
            this.fJe = !1,
            this.l0e = "",
            this.u0e = null
        }
        Swt() {
            this.lKi.textContent = self.lang("common.close-dialog")
        }
        async Qa(t, i) {
            if (Sg.doe(t))
                this.l0e = t;
            else {
                const i = await Sg.yLe(t);
                if (!i)
                    return;
                this.u0e = i,
                document.fonts.add(this.u0e),
                this.l0e = this.u0e.family
            }
            Sg.p.u("ui.dialogs.fontPreview"),
            this.Ya(self.tP(".caption", this.l0e));
            let e = self.lang(".example-text");
            Sg.p.j();
            for (let t = 0; t < _g.length; ++t) {
                let i = document.createElement("span");
                i.className = "exampleText",
                i.textContent = e,
                i.style.fontSize = _g[t] + "pt",
                i.style.fontFamily = Tg.has(this.l0e) ? this.l0e : `'${this.l0e}'`,
                this.a0e.appendChild(i)
            }
            return super.Qa(i)
        }
        VW() {
            this.l0e = "",
            this.u0e = null,
            Sg.qs.BYt(this.a0e)
        }
    }
    ;
    Sg.qs.HY.ipt.addEventListener("load", () => {
        Sg.qs.Ys.opt(Cg, Ig)
    }
    )
}
{
    const Pg = self.t
      , Gg = Pg.ek(import.meta.url).getElementById("inputDialog")
      , Ag = "Input"
      , Rg = {
        caption: "",
        message: "",
        label: "",
        inputType: "text",
        c0e: "",
        A7t: "",
        Xei: !1,
        spellcheck: !0,
        jD: "",
        vD: "",
        Yei: [],
        size: NaN
    }
      , kg = Pg.qs.Ys.d0e = class extends Pg.qs.Ys {
        constructor() {
            super(Gg),
            this.c3s = this.dwt("inputMessage"),
            this.dat = this.dwt("inputLabel"),
            this.jet = this.dwt("input"),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.fJe = !1,
            this.f0e = null
        }
        Swt() {}
        Qa(t, i) {
            Pg.Yq(t),
            t = Object.assign({}, Rg, t),
            Pg.zt(t.caption),
            Pg.u7t(t.message),
            Pg.u7t(t.label),
            Pg.Kq(t.inputType),
            Pg.Kq(t.c0e),
            Pg.Kq(t.A7t),
            Pg.Kq(t.jD),
            Pg.Kq(t.vD),
            Pg.zAt(t.Yei),
            Pg.U6(t.size),
            this.Ya(t.caption),
            Pg.odt(this.c3s, t.message),
            Pg.odt(this.dat, t.label),
            this.jet.setAttribute("type", t.inputType || "text"),
            this.jet.setAttribute("placeholder", t.c0e || ""),
            this.jet.setAttribute("spellcheck", t.spellcheck ? "true" : "false"),
            Pg.Go(t.size) && (this.jet.setAttribute("size", t.size),
            this.jet.setAttribute("maxLength", t.size)),
            this.jet.value = t.A7t || "",
            t.Xei && this.jet.select(),
            this.lKi.textContent = t.jD || self.lang("common.ok"),
            this.lhs.textContent = t.vD || self.lang("common.cancel"),
            this.f0e = t.Yei;
            const e = super.Qa(i);
            return this.jet.focus(),
            e
        }
        gwt() {
            for (const t of this.f0e)
                if (!t.check(this.jet.value))
                    return void Pg.qs.Jj.QY.nF(this.jet, "warning", t.qei.title, t.qei.message, {
                        align: "bottom"
                    });
            this.jet.value ? this.PR(this.jet.value) : this.PR(0)
        }
        VW() {
            this.Ya(null)
        }
    }
    ;
    Pg.qs.HY.ipt.addEventListener("load", function() {
        Pg.qs.Ys.opt(Ag, kg)
    })
}
{
    const Og = self.t
      , Dg = Og.ek(import.meta.url).getElementById("inputCheckDialog")
      , Fg = "InputCheck"
      , Lg = {
        caption: "",
        message: "",
        label: "",
        inputType: "text",
        c0e: "",
        A7t: "",
        spellcheck: !0,
        jD: "",
        vD: "",
        uQe: !1,
        lQe: ""
    }
      , Bg = Og.qs.Ys.p0e = class extends Og.qs.Ys {
        constructor() {
            super(Dg),
            this.c3s = this.dwt("inputMessage"),
            this.dat = this.dwt("inputLabel"),
            this.jet = this.dwt("input"),
            this.rQe = this.dwt("inputCheckbox"),
            this.hQe = this.dwt("inputCheckLabel"),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.fJe = !1
        }
        Swt() {}
        Qa(t, i) {
            Og.Yq(t),
            t = Object.assign({}, Lg, t),
            Og.zt(t.caption),
            Og.u7t(t.message),
            Og.u7t(t.label),
            Og.Kq(t.inputType),
            Og.Kq(t.c0e),
            Og.Kq(t.A7t),
            Og.Kq(t.jD),
            Og.Kq(t.vD),
            Og.Kq(t.lQe),
            this.Ya(t.caption),
            Og.odt(this.c3s, t.message),
            Og.odt(this.dat, t.label),
            this.jet.setAttribute("type", t.inputType || "text"),
            this.jet.setAttribute("placeholder", t.c0e || ""),
            this.jet.setAttribute("spellcheck", t.spellcheck ? "true" : "false"),
            this.jet.value = t.A7t || "",
            this.rQe.checked = !!t.uQe,
            this.hQe.textContent = t.lQe,
            this.lKi.textContent = t.jD || self.lang("common.ok"),
            this.lhs.textContent = t.vD || self.lang("common.cancel");
            const e = super.Qa(i);
            return this.jet.focus(),
            e
        }
        gwt() {
            this.PR({
                value: this.jet.value,
                check: this.rQe.checked
            })
        }
        VW() {
            this.Ya(null)
        }
    }
    ;
    Og.qs.HY.ipt.addEventListener("load", function() {
        Og.qs.Ys.opt(Fg, Bg)
    })
}
{
    const Ug = self.t
      , Ng = self.assert;
    Ug.qs.fA = class extends Ug.Me {
        constructor(t, i, e) {
            Ug.zt(t),
            Ug.Mw(e, Ug.qs.fA.W6t),
            super(),
            this.phs = t,
            this.m0e = i,
            this.w0e = e || null,
            this.g0e = !1,
            this.w0e ? (this.Get = this.w0e.Get,
            this.Get.id = t,
            this.g0e = e.g0e) : (this.Get = Ug.qs.lk("ui-pane", null, t),
            document.body.appendChild(this.Get),
            Ug.qs.Mqe(this)),
            this.y0e = [],
            this.b0e = !0,
            this.Get.removeAttribute(this.m0e ? "vgrid" : "hgrid"),
            this.Get.setAttribute(this.m0e ? "hgrid" : "vgrid", ""),
            this.v0e = null,
            this.S0e = !0,
            this.cn = !1
        }
        bx() {
            if (this.cn)
                throw new Error("layout has already been released");
            if (Ug.qs.Cqe(this))
                throw new Error("main layout can not be removed");
            this.cn = !0,
            this.Get = null,
            this.w0e = null,
            this.v0e = null,
            Ug.he(this)
        }
        x0e(t) {
            t ? (this.Get.style.position = "relative",
            this.Get.style.top = window.innerHeight + 100 + "px") : (this.Get.style.position = "",
            this.Get.style.top = "")
        }
        vR() {
            return this.phs
        }
        GZi() {
            return this.m0e
        }
        M0e() {
            return this.w0e
        }
        E0e(t) {
            return this.y0e.includes(t)
        }
        hk() {
            return this.Get
        }
        C0e() {
            return this.y0e
        }
        _0e() {
            return this.g0e
        }
        T0e(t) {
            if (t = !!t,
            this.g0e !== t) {
                this.g0e = t;
                for (let i = 0, e = this.y0e.length; i < e; ++i)
                    this.y0e[i].T0e(t)
            }
        }
        I0e(t, i, e) {
            this.P0e(t);
            let s = Ug.v(Ug.qs.fA.W6t, this, t, i, e);
            return this.y0e.push(s),
            this.b0e = !0,
            this.v7t(),
            Ug.qs.iA.tYe(),
            s
        }
        G0e(t, i, e) {
            this.P0e(t);
            let s = Ug.v(Ug.qs.fA.A0e, this, t, i, e);
            return s.R0e(t),
            Ug.qs.iA.tYe(),
            s
        }
        fG(t, i, e, s) {
            this.P0e(t);
            let n = Ug.v(Ug.qs.fA.k0e, this, t, i, e, s);
            return n.R0e(t),
            Ug.qs.iA.tYe(),
            n
        }
        J5t(t, i, e) {
            this.P0e(t);
            let s = Ug.v(Ug.qs.fA.O0e, this, t, i, e);
            return this.y0e.push(s),
            this.b0e = !0,
            this.v7t(),
            Ug.qs.iA.tYe(),
            s
        }
        P0e(t) {
            if (!Ug.qs.Aqe(t))
                throw new Error(`invalid CSS length: '${t}'`)
        }
        D0e(t) {
            let i = this.y0e.indexOf(t);
            -1 !== i && (this.y0e.splice(i, 1),
            this.Get.removeChild(t.hk()),
            this.b0e = !0,
            this.v7t())
        }
        F0e(t, i, e) {
            if (Ng(!this.y0e.includes(t), "Cannot link a pane already in grid"),
            this.b0e = !0,
            i)
                e || (e = i.L0e()),
                Ng(this.GZi() && ("left" === e || "right" === e) || !this.GZi() && ("top" === e || "bottom" === e), "Dock side incompatible with direction of this layout"),
                "left" === e || "top" === e ? (this.Get.insertBefore(t.hk(), i.hk()),
                this.y0e.splice(this.y0e.indexOf(i), 0, t)) : (this.Get.insertBefore(t.hk(), i.hk().nextSibling),
                this.y0e.splice(this.y0e.indexOf(i) + 1, 0, t));
            else {
                let i = t.L0e();
                i && Ng(this.GZi() && ("left" === i || "right" === i) || !this.GZi() && ("top" === i || "bottom" === i), "Dock side incompatible with direction of this layout"),
                "left" === i || "top" === i ? (this.Get.insertBefore(t.hk(), this.Get.firstChild),
                this.y0e.unshift(t)) : (this.Get.appendChild(t.hk()),
                this.y0e.push(t))
            }
            this.v7t()
        }
        B0e(t, i) {
            let e = this.y0e.indexOf(t);
            Ng(e >= 0, "Cannot find old pane to replace"),
            t.bx(),
            this.y0e[e] = i,
            this.b0e = !0,
            this.v7t(),
            this.U0e()
        }
        N0e() {
            for (let t = 0; t < this.y0e.length; ++t) {
                if (this.y0e[t].j0e())
                    return !0
            }
            return !1
        }
        so(t) {
            if (!this.b0e && !t)
                return;
            this.b0e = !1;
            let i = this.N0e()
              , e = ""
              , s = !1;
            for (let t = 0, n = this.y0e.length; t < n; ++t) {
                let r = this.y0e[t]
                  , h = r.$0e();
                !i && t > 0 && t === n - 1 ? r.z0e(!0) : t < n - 1 && r.z0e(!1),
                r.V0e() && (h = "1fr"),
                0 !== t && (e += " "),
                e += h,
                this.m0e ? r.W0e(t + 1) : r.H0e(t + 1),
                r.K0e() && !r.j0e() && "" !== r.q0e ? this.m0e ? r.X0e(s ? "right" : "left") : r.X0e(s ? "bottom" : "top") : s = !0
            }
            this.m0e ? (this.Get.style.gridTemplateColumns = e,
            this.Get.style.gridTemplateRows = "") : (this.Get.style.gridTemplateColumns = "",
            this.Get.style.gridTemplateRows = e)
        }
        Kpt() {
            return this.S0e && (this.v0e = this.Get.getBoundingClientRect(),
            this.S0e = !1),
            this.v0e
        }
        ns() {
            let t = this.Kpt();
            return t.right - t.left
        }
        Kn() {
            let t = this.Kpt();
            return t.bottom - t.top
        }
        v7t() {
            this.S0e = !0;
            for (let t = 0, i = this.y0e.length; t < i; ++t)
                this.y0e[t].v7t()
        }
        uH(t, i) {
            Ug.Ge(t),
            Ug.Ge(i);
            let e = this.Kpt();
            return t >= e.left && t < e.right && i >= e.top && i < e.bottom
        }
        Y0e(t, i, e) {
            if (Ug.Ge(t),
            Ug.Ge(i),
            !this.uH(t, i))
                return null;
            for (let s = 0, n = this.y0e.length; s < n; ++s) {
                let n = this.y0e[s];
                if (n.uH(t, i, e)) {
                    if (n.J0e()) {
                        return n.Z0e().Y0e(t, i, e)
                    }
                    return n
                }
            }
            return null
        }
        Q0e(t) {
            Ng(!t != !this.GZi(), "No point subdividing a Layout in the same direction"),
            Ng(this.w0e, "Subdividing the top level layout is not yet supported");
            let i = Ug.v(Ug.qs.fA, Ug.yR(this.phs), t, this.w0e);
            this.w0e.t1e(i);
            let e = i.I0e("1fr");
            return e.i1e(this),
            this.Get = e.Get,
            this.Get.id = this.phs,
            this.g0e = e.g0e,
            this.b0e = !0,
            this.v7t(),
            this.U0e(),
            i.so(),
            this.so(),
            i
        }
        e1e(t, i) {
            Ug.U(t, Ug.qs.fA.W6t),
            Ng(!i != !this.GZi(), "No point subdividing a Layout in the same direction");
            let e = this.y0e.indexOf(t);
            Ng(e >= 0, "Cannot find pane to split");
            let s, n = Ug.yR(this.phs);
            if (t.K0e()) {
                s = Ug.v(Ug.qs.fA.A0e, this, t.$0e(), n);
                let e = t.L0e();
                e || (e = i ? "left" : "top"),
                s.s1e() || s.X0e(e)
            } else
                s = Ug.v(Ug.qs.fA.W6t, this, t.$0e(), n);
            let r = s.n1e(Ug.yR(n), i);
            return r.y0e.push(t),
            this.y0e[e] = s,
            r.U0e(),
            this.U0e(),
            r.so(),
            this.so(),
            Ug.qs.iA.tYe(),
            r
        }
        r1e(t) {
            Ug.U(t, Ug.qs.fA.W6t),
            Ng(!(t instanceof Ug.qs.fA.O0e), "cannot replace tabbed pane with another tabbed pane");
            let i = this.y0e.indexOf(t);
            Ng(i >= 0, "Cannot find pane to replace");
            let e = Ug.yR(this.phs)
              , s = Ug.v(Ug.qs.fA.O0e, this, t.$0e(), e);
            return t instanceof Ug.qs.fA.A0e && (s.h1e = t.h1e,
            s.X0e(t.L0e())),
            Ug.qs.BW(t.hk()),
            this.y0e[i] = s,
            this.b0e = !0,
            this.v7t(),
            this.U0e(),
            this.so(),
            Ug.qs.iA.tYe(),
            s
        }
        o1e(t) {
            Ug.U(t, Ug.qs.fA.O0e),
            Ng(1 === t.Q6t(), "expected tabbed pane with a single tab"),
            Ng(!t.a1e(), "should keep tabbed pane");
            let i = t.L0e()
              , e = this.y0e.indexOf(t);
            Ng(e >= 0, "Cannot find tabbed pane to remove");
            let s = t.l1e();
            s.u1e(null),
            s.c1e(t.$0e()),
            s.K0e() && s.X0e(i),
            t.bx(),
            this.y0e[e] = s,
            this.b0e = !0,
            this.v7t(),
            this.U0e(),
            this.so(),
            s.d1e()
        }
        U0e() {
            for (let t = 0, i = this.y0e.length; t < i; ++t) {
                let i = this.y0e[t]
                  , e = i.hk();
                Ug.qs.BW(e),
                this.Get.appendChild(e),
                i.SG = this
            }
        }
        f1e() {
            return 1 === this.y0e.length
        }
        p1e(t) {
            !this.m0e != !t && (this.m0e = !!t,
            this.Get.removeAttribute(this.m0e ? "vgrid" : "hgrid"),
            this.Get.setAttribute(this.m0e ? "hgrid" : "vgrid", ""),
            this.b0e = !0,
            this.v7t())
        }
        m1e() {
            if (Ng(this.y0e.length > 0, "Layout has ended up with 0 panes, how did this happen?"),
            this.y0e.length > 1)
                return this;
            return this.y0e[0].J0e() ? this.w1e() : this.w0e && this.w0e.SG && this.w0e.SG._0e() ? this.g1e() : this
        }
        w1e() {
            Ng(1 === this.y0e.length, "Cannot merge down unless layout has exactly 1 pane");
            let t = this.y0e[0];
            Ng(t.J0e(), "Cannot merge down unless pane has sub grid");
            let i = t.Z0e()
              , e = i.phs;
            return this.y0e = i.y0e,
            t.z0e(!1),
            t.bx(),
            this.U0e(),
            this.m0e = i.m0e,
            this.Get.removeAttribute(this.m0e ? "vgrid" : "hgrid"),
            this.Get.setAttribute(this.m0e ? "hgrid" : "vgrid", ""),
            this.phs = e,
            this.Get.id = e,
            this.b0e = !0,
            this.v7t(),
            this.so(),
            this
        }
        g1e() {
            Ng(1 === this.y0e.length, "Cannot merge up unless layout has exactly 1 pane");
            let t = this.y0e[0]
              , i = this.w0e.SG;
            Ng(i && i._0e(), "Must have parent grid which is dock target to merge up"),
            this.w0e.K0e() && t.c1e(this.w0e.$0e());
            const e = this.phs;
            return t.z0e(!1),
            i.B0e(this.w0e, t),
            i.so(),
            i.phs.startsWith(e) && (i.phs = e,
            i.Get.id = e),
            i
        }
        y1e() {
            if (!this._0e())
                return;
            let t = []
              , i = !1
              , e = !1;
            for (let s = 0, n = this.y0e.length; s < n; ++s) {
                let n = this.y0e[s]
                  , r = n.Z0e();
                if (n.j0e() && (e = !0),
                n.K0e()) {
                    let t = n.L0e();
                    this.GZi() ? "top" !== t && "bottom" !== t || n.X0e(e ? "right" : "left") : "left" !== t && "right" !== t || n.X0e(e ? "bottom" : "top")
                }
                r && (r.GZi() === this.GZi() || r.f1e()) ? (this.phs.startsWith(r.phs) && (this.phs = r.phs,
                this.Get.id = r.phs),
                Ug.bp(t, r.y0e),
                n.bx(),
                i = !0) : t.push(n)
            }
            i && (this.y0e = t,
            this.b0e = !0,
            this.v7t(),
            this.U0e(),
            this.so()),
            this.w0e && this.w0e.SG && this.w0e.SG.y1e()
        }
        qnt() {
            let t = 0;
            if (this.GZi())
                for (let i = 0, e = this.y0e.length; i < e; ++i) {
                    let e = this.y0e[i];
                    e.K0e() && !e.j0e() ? t += e.ns() : t += e.qnt()
                }
            else
                for (let i = 0, e = this.y0e.length; i < e; ++i) {
                    let e = this.y0e[i].qnt();
                    t < e && (t = e)
                }
            return t
        }
        Xnt() {
            let t = 0;
            if (this.GZi())
                for (let i = 0, e = this.y0e.length; i < e; ++i) {
                    let e = this.y0e[i].Xnt();
                    t < e && (t = e)
                }
            else
                for (let i = 0, e = this.y0e.length; i < e; ++i) {
                    let e = this.y0e[i];
                    e.K0e() && !e.j0e() ? t += e.Kn() : t += e.Xnt()
                }
            return t
        }
        b1e(t) {
            let i = this.Kpt()
              , e = 0;
            e = this.GZi() ? i.right - i.left : i.bottom - i.top;
            for (let i = 0, s = this.y0e.length; i < s; ++i) {
                let s = this.y0e[i];
                s !== t && (s.K0e() && !s.j0e() ? e -= this.GZi() ? s.ns() : s.Kn() : e -= this.GZi() ? s.qnt() : s.Xnt())
            }
            return e < 0 ? 1 / 0 : Math.floor(.9 * e)
        }
        v1e() {
            let t = 0;
            for (let i = 0, e = this.y0e.length; i < e; ++i) {
                let e = this.y0e[i];
                this.GZi() ? t += Math.max(e.ns(), e.qnt()) : t += Math.max(e.Kn(), e.Xnt())
            }
            return t
        }
        S1e(t, i) {
            Ug.Ge(t),
            Ug.Ge(i);
            let e = t / i;
            for (let t = 0, i = this.y0e.length; t < i; ++t) {
                let i = this.y0e[t];
                i.K0e() && !i.s1e() && (this.GZi() ? i.Qx(Ug.IOt(i.ns() * e), !0) : i.Kx(Ug.IOt(i.Kn() * e), !0))
            }
        }
        x1e() {
            let t = this.Kpt()
              , i = 0;
            i = this.GZi() ? t.right - t.left : t.bottom - t.top;
            let e = this.v1e();
            e > i && this.S1e(i, e);
            for (let t = 0, i = this.y0e.length; t < i; ++t) {
                let i = this.y0e[t].Z0e();
                i && i.x1e()
            }
        }
        Pqe() {
            this.v7t(),
            this.x1e(),
            this.M1e()
        }
        M1e(t) {
            for (let t of this.y0e)
                t.d1e()
        }
        static E1e(t) {
            if (t)
                for (let i of t)
                    if ("main" === i.id) {
                        if (!i.layout || !i.layout.children)
                            throw new Error("[Load UI State] main pane does not have a layout");
                        let t = i.layout.size;
                        for (let e of i.layout.children) {
                            t && !e.fixedSize && e.size.includes("px") && (Ug.qs.fA.C1e(t, "Load UI State"),
                            Ug.qs.fA._1e(e.size, "Load UI State"));
                            let i = e.layout && e.layout.children;
                            i && 1 === i.length && "TabPane" !== e.type ? (Ug.qs.fA._1e(e.size, "Load UI State"),
                            i[0].size = e.size,
                            Ug.qs.fA.T1e(i[0])) : Ug.qs.fA.T1e(e)
                        }
                    } else
                        Ug.qs.fA.T1e(i)
        }
        static T1e(t) {
            let i;
            switch ("midPane" === t.id && (t.size = "1fr",
            t.side = ""),
            Ug.qs.fA._1e(t.size, "Load UI State"),
            t.type) {
            case "CaptionPane":
            case "TabPane":
            case "DockingPane":
                i = !0;
                break;
            case "Pane":
                i = !1;
                break;
            default:
                throw new Error("unknown type of pane")
            }
            if (t.layout && t.layout.children.length > 0) {
                let i = t.layout.size
                  , e = t.layout.frame;
                e && (Ug.qs.fA.I1e(e.width, "Load UI State"),
                Ug.qs.fA.I1e(e.height, "Load UI State"));
                for (let e of t.layout.children) {
                    i && !e.fixedSize && e.size.includes("px") && (Ug.qs.fA.C1e(i, "Load UI State"),
                    Ug.qs.fA._1e(e.size, "Load UI State"));
                    let t = e.layout && e.layout.children;
                    t && 1 === t.length ? (Ug.qs.fA._1e(e.size, "Load UI State"),
                    t[0].size = e.size,
                    Ug.qs.fA.T1e(t[0])) : Ug.qs.fA.T1e(e)
                }
            }
        }
        static P1e(t, i, e=!1) {
            if (t) {
                for (let s of t)
                    if ("main" === s.id) {
                        Ug.qs.fA.G1e(s);
                        let t = i.Z0e();
                        for (let i of t.y0e.slice(0))
                            t.D0e(i),
                            i instanceof Ug.qs.fA.A0e && i.A1e();
                        Ng(0 === t.y0e.length, "Layout subgrid should be empty!"),
                        Ng(s.layout && s.layout.children, "Main pane does not have a layout");
                        let n = s.layout.size
                          , r = s.layout.isHorizontal ? i.ns() : i.Kn();
                        for (let t of s.layout.children) {
                            n && !t.fixedSize && t.size.includes("px") && (Ug.qs.fA.C1e(n, "Load UI State"),
                            Ug.qs.fA._1e(t.size, "Load UI State"),
                            t.size = Math.floor(t.size.slice(0, -2) / n * r) + "px");
                            let s = t.layout && t.layout.children;
                            s && 1 === s.length && "TabPane" !== t.type ? (Ug.qs.fA._1e(t.size, "Load UI State"),
                            s[0].size = t.size,
                            s[0].side = t.side,
                            s[0].docked = t.docked,
                            Ug.qs.fA.R1e(i, s[0], e)) : Ug.qs.fA.R1e(i, t, e)
                        }
                        t && t.so(!0)
                    } else
                        Ug.qs.fA.R1e(i, s, e);
                Ug.qs.iA.tYe()
            }
        }
        static G1e(t) {
            if (!t.layout.tabSide && t.layout.children.length > 1) {
                const i = [];
                if (t.layout.isHorizontal)
                    for (let e of t.layout.children) {
                        if ("left" !== e.side)
                            break;
                        i.push(e)
                    }
                else
                    for (let e of t.layout.children) {
                        if ("top" !== e.side)
                            break;
                        i.push(e)
                    }
                i.length > 1 && (i.reverse(),
                t.layout.children.splice(0, i.length, ...i))
            }
        }
        static R1e(t, i, e) {
            let s = self.eP.k1e(i.id, e);
            if (!s) {
                let t = i.id && self.app.yk(i.id);
                s = t && t.gk()
            }
            let n = s && s.dH()
              , r = t.Z0e()
              , h = !0;
            if ("midPane" === i.id && (i.size = "1fr",
            i.side = ""),
            Ug.qs.fA._1e(i.size, "Load UI State"),
            n)
                n.A1e(),
                n.x_(!0);
            else
                switch (i.type) {
                case "CaptionPane":
                    n = Ug.v(Ug.qs.fA.k0e, r, i.size, i.name, i.id);
                    break;
                case "TabPane":
                    n = Ug.v(Ug.qs.fA.O0e, r, i.size, i.name, i.id);
                    break;
                case "DockingPane":
                    n = Ug.v(Ug.qs.fA.A0e, r, i.size, i.name, i.id);
                    break;
                case "Pane":
                    n = r.I0e(i.size, i.name, i.id),
                    h = !1;
                    break;
                default:
                    throw new Error("unknown type of pane")
                }
            if (h)
                if (n.SG && n.R0e(),
                i.docked)
                    if (t instanceof Ug.qs.fA.O0e)
                        t.H6t(n),
                        i.activeTab && t.O1e(n);
                    else {
                        const t = i.side ? "left" === i.side || "right" === i.side : null;
                        null !== t && r.p1e(t),
                        n.SE(r, i.side),
                        null !== t && i.size.includes("px") ? t ? n.Qx(+i.size.slice(0, -2), !0) : n.Kx(+i.size.slice(0, -2), !0) : n.c1e("1fr")
                    }
                else if (i.popup) {
                    const t = i.popupWindowScreenX ?? screen.width / 2
                      , e = i.popupWindowScreenY ?? screen.height / 2;
                    n.J_t(t, e, i.popupWindowWidth, i.popupWindowHeight)
                } else if (!1 === i.docked) {
                    let t = i.position;
                    n.gG(),
                    n.kp(t.x),
                    n.Gp(t.y),
                    n.Qx(t.width, !0),
                    n.Kx(t.height, !0)
                }
            if (n && "TabPane" !== i.type && i.layout && !n.J0e() && n.n1e(i.layout.id, i.layout.isHorizontal),
            r && r.v7t(),
            r && r.so(!0),
            n && i.layout && i.layout.children.length > 0) {
                Ug.qs.fA.G1e(i);
                let t = n.Z0e();
                if (t)
                    for (let i of t.y0e.slice(0))
                        t.D1e(i),
                        i instanceof Ug.qs.fA.A0e && i.A1e();
                let s = i.layout.size
                  , h = i.layout.frame
                  , o = null;
                h && (Ug.qs.fA.I1e(h.width, "Load UI State"),
                Ug.qs.fA.I1e(h.height, "Load UI State")),
                o = i.layout.isHorizontal ? h ? window.innerWidth / h.width : n.ns() / s : h ? window.innerHeight / h.height : n.Kn() / s;
                for (let t of i.layout.children) {
                    if (s && !t.fixedSize && t.size.includes("px")) {
                        Ug.qs.fA.C1e(s, "Load UI State"),
                        Ug.qs.fA._1e(t.size, "Load UI State");
                        const i = t.size.slice(0, -2) * o;
                        t.size = Math.floor(i) + "px"
                    }
                    let i = t.layout && t.layout.children;
                    i && 1 === i.length && "TabPane" !== t.type ? (Ug.qs.fA._1e(t.size, "Load UI State"),
                    i[0].size = t.size,
                    i[0].side = t.side,
                    i[0].docked = t.docked,
                    Ug.qs.fA.R1e(n, i[0], e)) : Ug.qs.fA.R1e(n, t, e)
                }
                r && r.v7t(),
                r && r.so(!0)
            }
        }
        static F1e(t, i, e) {
            if (!Ug.Go(t))
                throw new Error(`[${i}] ${e} size must be a finite number`);
            if (t <= 0)
                throw new Error(`[${i}] ${e} size must be greater than 0`)
        }
        static I1e(t, i="") {
            this.F1e(t, i, "frame")
        }
        static C1e(t, i="") {
            this.F1e(t, i, "layout")
        }
        static _1e(t, i="") {
            if (Ug.doe(t)) {
                if (!Ug.qs.Aqe(t))
                    throw new Error(`[${i}] pane string size must be a valid css length`);
                this.F1e(parseFloat(t), i, "pane string")
            } else {
                if (!Ug.Go(t))
                    throw new Error(`[${i}] invalid pane size`);
                this.F1e(t, i, "pane numeric")
            }
        }
    }
}
{
    const jg = self.t
      , $g = self.assert
      , zg = 20
      , Vg = 40
      , Wg = new Set;
    jg.qs.fA.W6t = class extends jg.qs.Window {
        constructor(t, i, e, s) {
            jg.U(t, jg.qs.fA),
            jg.zt(i),
            jg.Kq(e),
            jg.Kq(s),
            e = e || s || "(no name)",
            super(jg.qs.lk("ui-pane", t.hk(), s), e),
            this.SG = t,
            this.Nd = i.toLowerCase(),
            this.L1e = !1,
            this.phs = s || "",
            this.g0e = t.g0e,
            this.B1e = null,
            this.U1e = null,
            this.N1e = "",
            this.j1e = !0,
            this.IJe = zg,
            this.PJe = Vg,
            this.$1e = 0,
            this.z1e = 0,
            this.hWs = null,
            this.oWs = null,
            this.V1e = !0,
            this.W1e = !0,
            this.H1e = !0,
            this.K1e = "",
            this.q1e = "",
            this.X1e = !1,
            Wg.add(this)
        }
        eue(t) {
            if (t)
                super.eue("PANE_" + t);
            else {
                const t = "abcdefghijklmnopqrstuvwxyz0123456789"
                  , i = t.length;
                let e = "";
                for (let s = 0; s < 11; ++s)
                    e += t.charAt(Math.floor(Math.random() * i));
                super.eue("PANE_" + e)
            }
        }
        Y1e() {
            const t = this instanceof jg.qs.fA.k0e && this.DJe
              , i = this.SG && this.SG.w0e
              , e = this.eX()
              , s = !("main" === this.phs) && (!(this instanceof jg.qs.fA.A0e && void 0 !== this.h1e) || this.h1e);
            if (!t && s && (i || e))
                return;
            const n = {
                width: jg.qs._qe(),
                height: jg.qs.Tqe()
            };
            return jg.qs.fA.I1e(n.width, "Save UI State"),
            jg.qs.fA.I1e(n.height, "Save UI State"),
            this.J1e( (t, i) => {
                jg.qs.fA._1e(t.Nd, "Save UI State");
                const e = {
                    id: t.phs,
                    size: t.Nd,
                    name: t.rVt,
                    devicePixelRatio: window.devicePixelRatio,
                    type: null,
                    activeTab: t.Z1e()
                };
                if ("CaptionPane" === t.constructor.name && t.xY()) {
                    e.popup = !0,
                    e.popupWindowWidth = t.ns(),
                    e.popupWindowHeight = t.Kn();
                    const [i,s] = t.Q1e();
                    Number.isFinite(i) && Number.isFinite(s) && (e.popupWindowScreenX = i,
                    e.popupWindowScreenY = s)
                }
                switch (t.constructor) {
                case jg.qs.fA.O0e:
                    e.side = t.q0e,
                    e.type = "TabPane",
                    e.docked = "main" !== t.phs && t.h1e;
                    break;
                case jg.qs.fA.k0e:
                    e.caption = t.t2e,
                    e.side = t.q0e,
                    e.type = "CaptionPane",
                    e.docked = "main" !== t.phs && t.h1e;
                    break;
                case jg.qs.fA.A0e:
                    e.side = t.q0e,
                    e.type = "DockingPane",
                    e.docked = "main" !== t.phs && t.h1e;
                    break;
                default:
                    e.type = "Pane"
                }
                if ("main" !== t.phs && !1 === t.h1e && (e.position = {
                    x: t.i2e,
                    y: t.e2e,
                    width: t.s2e,
                    height: t.n2e
                }),
                t.U1e) {
                    const i = t.U1e.m0e ? t.ns() : t.Kn();
                    jg.qs.fA.C1e(i, "Save UI State"),
                    e.layout = {
                        frame: n,
                        tabSide: !1,
                        size: i,
                        id: t.U1e.vR(),
                        isHorizontal: t.U1e.m0e,
                        children: []
                    }
                } else
                    "TabPane" === e.type && (e.layout = {
                        tabSide: t.h2e.r2e,
                        children: []
                    });
                return i && i.layout && i.layout.children.push(e),
                e
            }
            )
        }
        o2e() {
            return this.uWt()
        }
        bx() {
            if (!this.Get)
                throw new Error("removing pane which has already been removed");
            let t = new jg.Event("remove");
            t.xRt = this,
            this.dispatchEvent(t),
            this.U1e && (this.U1e.bx(),
            this.U1e = null),
            Wg.delete(this),
            super.bx()
        }
        qm() {
            return this.SG
        }
        a2e() {
            if (this.s1e())
                throw new Error("pane has flex size");
            return parseInt(this.Nd, 10)
        }
        $0e() {
            return this.Nd
        }
        c1e(t) {
            if (jg.zt(t),
            t = t.toLowerCase(),
            !jg.qs.Aqe(t))
                throw new Error(`invalid CSS length: '${t}'`);
            this.Nd = t
        }
        s1e() {
            return this.Nd.includes("fr")
        }
        j0e() {
            return this.s1e() || this.V0e()
        }
        V0e() {
            return this.L1e
        }
        z0e(t) {
            t = !!t,
            this.L1e = t
        }
        l2e() {
            this.j1e = !1
        }
        u2e() {
            return !!this.j1e || "midPane" === this.phs
        }
        c2e(t) {
            for (const i of t) {
                if (i.u2e())
                    if (i.U1e && i.U1e.y0e) {
                        if (i.c2e(i.U1e.y0e))
                            return !0
                    } else {
                        if (i.constructor !== jg.qs.fA.O0e)
                            return !0;
                        if (i.c2e(i.h2e.d2e.map(t => t.Bd)))
                            return !0
                    }
            }
            return "midPane" === this.phs
        }
        J1e(t, i) {
            if (!this.u2e())
                return;
            if (!this.phs)
                if (this.U1e && this.U1e.y0e) {
                    if (!this.c2e(this.U1e.y0e))
                        return
                } else if (this.constructor === jg.qs.fA.O0e && !this.c2e(this.h2e.d2e.map(t => t.Bd)))
                    return;
            const e = t(this, i);
            if (this.U1e && this.U1e.y0e)
                for (let i of this.U1e.y0e)
                    i.J1e(t, e);
            else if (this.constructor === jg.qs.fA.O0e)
                for (let i of this.h2e.d2e)
                    i.Bd.J1e(t, e);
            return e
        }
        RXe() {
            return !1
        }
        K0e() {
            return !1
        }
        _0e() {
            return this.g0e
        }
        T0e(t) {
            t = !!t,
            this.g0e !== t && (this.g0e = t,
            this.U1e && this.U1e.T0e(t))
        }
        u1e(t) {
            this.B1e = t
        }
        sX() {
            return this.B1e
        }
        eX() {
            return !!this.B1e
        }
        Z1e() {
            return this.B1e && this.B1e.f2e() === this
        }
        D1e() {
            this.dispatchEvent(new jg.Event("beforeunlink")),
            this.SG && (this.SG.D0e(this),
            this.SG.so(),
            this.SG = null),
            jg.qs.BW(this.Get),
            this.p2e(),
            this.m2e(),
            this.v7t()
        }
        JW(t) {
            return !!this.Get.parentElement
        }
        __() {
            return this.JW()
        }
        Bj() {
            return this.__()
        }
        n1e(t, i) {
            if (jg.zt(t),
            i = !!i,
            this.U1e)
                throw new Error("cannot create a sub-grid on a pane which already has one");
            return this.U1e = jg.v(jg.qs.fA, t, i, this),
            this.U1e
        }
        i1e(t) {
            if (jg.U(t, jg.qs.fA),
            this.U1e)
                throw new Error("cannot attach a sub grid on a pane which already has one");
            this.U1e = t,
            this.U1e.w0e = this;
            let i = t.GZi();
            this.Get.removeAttribute(i ? "vgrid" : "hgrid"),
            this.Get.setAttribute(i ? "hgrid" : "vgrid", "")
        }
        t1e(t) {
            jg.U(t, jg.qs.fA),
            $g(this.U1e, "Should not replace a sub grid on a pane which does not already have one"),
            $g(this.U1e !== t, "Should not replace a sub grid with the same grid"),
            this.U1e = t,
            this.U1e.w0e = this;
            let i = new jg.Event("replacesubgrid");
            i.xRt = this,
            i.w2e = t,
            this.dispatchEvent(i)
        }
        Z0e() {
            return this.U1e
        }
        J0e() {
            return !!this.U1e
        }
        uH(t, i, e) {
            return jg.Ge(t),
            jg.Ge(i),
            !(!e && this.J0e()) && super.uH(t, i)
        }
        Cj() {
            this.Get.setAttribute("hide", "")
        }
        Ej() {
            this.Get.removeAttribute("hide")
        }
        G6t() {
            if (!this.V1e)
                return;
            this.V1e = !1;
            let t = this.Get.style.gridTemplateColumns;
            if (t)
                this.K1e = t,
                this.X1e = !0;
            else {
                let t = this.Get.style.gridTemplateRows;
                t && (this.K1e = t,
                this.X1e = !1)
            }
            this.q1e = this.$0e(),
            this.g2e(!1),
            this.B6t(!1)
        }
        I6t() {
            this.V1e || (this.V1e = !0,
            this.g2e(!0),
            this.B6t(!0),
            this.K1e && (this.X1e ? this.Get.style.gridTemplateColumns = this.K1e : this.Get.style.gridTemplateRows = this.K1e),
            this.q1e && this.c1e(this.q1e),
            this.K1e = "",
            this.q1e = "",
            this.v7t())
        }
        U6t() {
            if (this.V1e)
                return;
            let t = this.Get.style.gridTemplateColumns;
            if (t)
                this.K1e = t,
                this.X1e = !0;
            else {
                let t = this.Get.style.gridTemplateRows;
                t && (this.K1e = t,
                this.X1e = !1)
            }
            this.q1e = this.$0e()
        }
        g2e(t) {
            (t = !!t) !== this.W1e && (this.W1e = t,
            t ? this.Get.removeAttribute("disablegridtemplates") : this.Get.setAttribute("disablegridtemplates", ""))
        }
        B6t(t) {
            (t = !!t) !== this.H1e && (this.H1e = t,
            t ? this.Get.removeAttribute("disablegridstartandend") : this.Get.setAttribute("disablegridstartandend", ""))
        }
        p2e() {
            this.Get.style.gridColumn = "",
            this.Get.style.gridRow = ""
        }
        m2e() {
            this.N1e && (this.Get.removeAttribute(this.N1e),
            this.v7t()),
            this.N1e = ""
        }
        H0e(t) {
            jg.Ge(t),
            $g(t >= 1 && t <= 20, "Invalid grid row number, must be 1-20");
            let i = "row" + t;
            this.N1e !== i && (this.m2e(),
            this.N1e = i,
            this.Get.setAttribute(this.N1e, ""),
            this.v7t())
        }
        W0e(t) {
            jg.Ge(t),
            $g(t >= 1 && t <= 20, "Invalid grid column number, must be 1-20");
            let i = "col" + t;
            this.N1e !== i && (this.m2e(),
            this.N1e = i,
            this.Get.setAttribute(this.N1e, ""),
            this.v7t())
        }
        v7t() {
            super.v7t(),
            this.U1e && this.U1e.v7t()
        }
        _a() {
            return this.Kpt().left
        }
        Da() {
            return this.Kpt().top
        }
        ns() {
            let t = this.Kpt();
            return t.right - t.left
        }
        Kn() {
            let t = this.Kpt();
            return t.bottom - t.top
        }
        qnt() {
            return this.J0e() ? this.U1e.qnt() : this.IJe
        }
        Xnt() {
            return this.J0e() ? this.U1e.Xnt() : this.PJe
        }
        y2e() {
            "PANE_main" === this.gXe && this.AXe()
        }
        b2e(t=!0) {
            if ("PANE_main" === this.gXe) {
                const i = [];
                let e;
                for (const t of Wg)
                    e = t.Y1e(),
                    e && i.push(e);
                return jg.M9s.lVs("log-pane") && console.info("Saving layout", JSON.stringify(i, null, 4)),
                t && this.Y4i(i),
                i
            }
            return null
        }
        v2e() {
            Wg.delete(this)
        }
        d1e() {
            if (this.EXe)
                return;
            let t = this.ns()
              , i = this.Kn();
            if (t !== this.$1e || i !== this.z1e) {
                this.$1e = t,
                this.z1e = i;
                let e = new jg.Event("resize");
                e.xRt = this,
                this.dispatchEvent(e),
                this.U1e && this.U1e.M1e()
            }
        }
        dG(t) {
            jg.Mw(t, jg.Ha),
            this.hWs = t ? t.clone() : null
        }
        pG() {
            return this.hWs ? this.hWs.clone() : null
        }
        wG(t) {
            jg.Mw(t, jg.Ha),
            this.oWs = t ? t.clone() : null
        }
        mG() {
            return this.oWs ? this.oWs.clone() : null
        }
        S2e() {
            return ""
        }
        static x2e(t) {
            return !!Wg.has(t) && this.u2e()
        }
    }
}
{
    const Hg = self.t
      , Kg = self.assert
      , qg = ["left", "top", "right", "bottom"]
      , Xg = 300
      , Yg = 350;
    let Jg = 0;
    const Zg = 100
      , Qg = 100
      , ty = 100
      , iy = 100;
    Hg.qs.fA.A0e = class extends Hg.qs.fA.W6t {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.Get.setAttribute("role", "section"),
            this.h1e = !0,
            this.M2e = !1,
            this.E2e = !1,
            this.C2e = !1,
            this._2e = !0,
            this.T2e = 0,
            this.q0e = "",
            this.xJe = null,
            this.l1 = t => this.lX(),
            this.Get.addEventListener("pointerdown", this.l1),
            this.I2e = Zg,
            this.P2e = Qg,
            this.i2e = 0,
            this.e2e = 0,
            this.s2e = 0,
            this.n2e = 0,
            this.IJe = ty,
            this.PJe = iy,
            this.G2e = !0,
            this.lct = !1,
            this.A2e = null,
            this.R2e = 0,
            Hg.qs.RW.k2e(this)
        }
        static O2e(t) {
            Hg.Ge(t),
            Jg = t
        }
        R0e(t) {
            Hg.Kq(t),
            this.h1e = !1,
            this.L1e = !1,
            this.q0e = this.SG.GZi() ? "left" : "top";
            const i = parseInt(t, 10) || Xg;
            this.c1e(`${i}px`),
            this.p2e(),
            this.m2e(),
            this.D2e(),
            this.F2e(this.P2e, this.I2e, i, Jg || Yg),
            Jg = 0,
            document.body.appendChild(this.Get),
            this.v7t(),
            this.lX()
        }
        bx() {
            this.G2e = !1,
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            Hg.qs.RW.L2e(this),
            super.bx()
        }
        K0e() {
            return !0
        }
        X0e(t) {
            Hg.zt(t),
            Kg(qg.includes(t), "Invalid dock side parameter"),
            this.q0e !== t && (this.B2e() && this.V0e() ? this.q0e = t : (this.A1e(),
            this.U2e(t),
            this.SG && this.SG.v7t()))
        }
        N2e() {
            return this.M2e
        }
        j2e() {
            return this._2e
        }
        EOt() {
            this._2e = !1
        }
        zOt() {
            this._2e = !0
        }
        $2e() {
            Kg(!this.B1e && !this.h1e, "should not be tabbed or docked to go in swipe-in mode"),
            this.M2e = !0,
            this.Get.setAttribute("swipe-in-" + this.q0e, ""),
            this.Get.removeAttribute("floating"),
            this.Get.setAttribute("role", "complementary"),
            this.z2e(!0),
            this.V2e(),
            Hg.qs.RW.W2e(this)
        }
        H2e() {
            let t = document.activeElement;
            for (; t; )
                if (t = t.parentElement,
                t === this.Get)
                    return void document.activeElement.blur()
        }
        LN(t) {
            t = !!t,
            this.K2e();
            let i = Hg.qs._qe();
            this.E2e = t,
            this.E2e && this.z2e(!1),
            this.E2e ? (this.q2e("left" === this.q0e ? 0 : i - this.ns()),
            Hg.qs.iA.SF(this)) : (this.q2e("left" === this.q0e ? -this.ns() : i),
            this.H2e())
        }
        K2e() {
            this.xJe && (this.xJe.cancel(),
            this.PZe())
        }
        q2e(t) {
            if (Hg.Ge(t),
            this.i2e === t)
                return void this.PZe();
            let i = this.i2e;
            this.kp(t),
            self.app.zmt() ? (this.xJe = this.Get.animate([{
                transform: `translate(${i}px,${this.e2e}px)`
            }, {
                transform: `translate(${t}px,${this.e2e}px)`
            }], {
                duration: 200,
                easing: "ease"
            }),
            this.xJe.onfinish = () => this.PZe()) : this.PZe()
        }
        PZe() {
            this.xJe = null,
            this.E2e || this.z2e(!0)
        }
        z2e(t) {
            t = !!t,
            this.C2e !== t && (t ? (this.Kpt(),
            this.C2e = !0,
            this.Get.style.display = "none",
            this.Get.setAttribute("aria-hidden", "true")) : (this.Get.style.display = "",
            this.Get.removeAttribute("aria-hidden"),
            this.C2e = !1,
            this.v7t()),
            this.X2e(!t))
        }
        v7t() {
            this.C2e || super.v7t()
        }
        Kpt() {
            return this.RXe() ? {
                left: this.i2e,
                top: this.e2e,
                right: this.i2e + this.s2e,
                bottom: this.e2e + this.n2e,
                width: this.s2e,
                height: this.n2e
            } : super.Kpt()
        }
        uH(t, i, e) {
            return !(this.M2e && !this.E2e) && super.uH(t, i, e)
        }
        Y2e(t) {
            Hg.Ge(t),
            t = Hg.Ne(t, 0, 1),
            this.K2e();
            let i = Hg.qs._qe()
              , e = "left" === this.q0e ? -this.ns() : i
              , s = "left" === this.q0e ? 0 : i - this.ns()
              , n = Hg.IOt(Hg.mi(e, s, t));
            this.kp(n),
            this.z2e(!1)
        }
        J2e() {
            return "left" === this.q0e ? (this._a() + this.ns() + this.T2e) / 2 : (this._a() + this.T2e - Hg.qs._qe()) / 2
        }
        V2e() {
            this.Gp(0),
            this.Kx(Math.min(Hg.qs.Tqe())),
            this.Qx(Math.min(Hg.qs._qe() - 50, 375)),
            this.LN(this.E2e)
        }
        A1e() {
            this.q0e && this.Get.removeAttribute(`dock${this.q0e}`)
        }
        U2e(t) {
            t && (this.q0e = t),
            "" !== this.q0e && this.Get.setAttribute(`dock${this.q0e}`, "")
        }
        z0e(t) {
            (t = !!t) !== this.V0e() && (super.z0e(t),
            this.B2e() && (t ? this.A1e() : this.U2e(),
            this.SG.v7t()))
        }
        L0e() {
            return this.B1e ? this.B1e.q0e : this.q0e
        }
        B2e() {
            return this.h1e && !this.M2e
        }
        RXe() {
            return !this.h1e || this.M2e
        }
        x_(t) {
            t = !!t,
            this.G2e !== t && (this.G2e = t,
            this.G2e ? (this.Get.style.display = "",
            this.v7t()) : this.Get.style.display = "none")
        }
        __() {
            return this.M2e ? this.E2e : this.G2e && super.__()
        }
        fGt() {
            return !!this.K0e() && (this.RXe() || "right" === this.q0e)
        }
        Z2e() {
            return !!this.K0e() && (this.RXe() || "left" === this.q0e)
        }
        Q2e() {
            return !!this.K0e() && (this.RXe() || "bottom" === this.q0e)
        }
        t3e() {
            return !!this.K0e() && (this.RXe() || "top" === this.q0e)
        }
        fge() {
            this.Get.style.transform = `translate(${this.i2e}px, ${this.e2e}px)`
        }
        kp(t, i) {
            if (Hg.Ge(t),
            t = Hg.IOt(t),
            i = !!i,
            this.B2e())
                throw new Error("cannot set the position of a docked pane");
            this.i2e = t,
            this.fge(),
            this.v7t(),
            i || (this.I2e = t)
        }
        Gp(t, i) {
            if (Hg.Ge(t),
            t = Hg.IOt(t),
            i = !!i,
            this.B2e())
                throw new Error("cannot set the position of a docked pane");
            this.e2e = t,
            this.fge(),
            this.v7t(),
            i || (this.P2e = t)
        }
        i3e(t) {
            if ((t = !!t) ? ++this.R2e : --this.R2e,
            this.R2e < 0)
                throw new Error("invalid unlock");
            0 === this.R2e && this.d1e()
        }
        d1e() {
            this.R2e > 0 || this.lct || (++this.R2e,
            super.d1e(),
            this.B2e() && this.SG && this.SG.M1e(),
            --this.R2e)
        }
        Qx(t, i) {
            if (Hg.Ge(t),
            t = Hg.IOt(t),
            i = !!i,
            this.B2e() && ("top" === this.q0e || "bottom" === this.q0e))
                throw new Error("cannot set width of vertically docked bar");
            let e = this.qnt();
            if (t < e && (t = e),
            this.B2e()) {
                if (!i) {
                    let i = this.SG.b1e(this);
                    t > i && (t = i)
                }
                this.c1e(`${t}px`),
                this.SG.so(!0),
                this.SG.v7t()
            } else
                this.s2e = t,
                this.Get.style.width = `${t}px`,
                this.v7t();
            this.d1e()
        }
        Kx(t, i) {
            if (Hg.Ge(t),
            t = Hg.IOt(t),
            i = !!i,
            this.B2e() && ("left" === this.q0e || "right" === this.q0e))
                throw new Error("cannot set height of horizontally docked bar");
            let e = this.Xnt();
            if (t < e && (t = e),
            this.B2e()) {
                if (!i) {
                    let i = this.SG.b1e(this);
                    t > i && (t = i)
                }
                this.c1e(`${t}px`),
                this.SG.so(!0),
                this.SG.v7t()
            } else
                this.n2e = t,
                this.Get.style.height = `${t}px`,
                this.v7t();
            this.d1e()
        }
        D1e() {
            super.D1e(),
            this.Qbs(-1),
            this.q0e && (this.A1e(),
            this.q0e = ""),
            this.e3e(),
            this.SG && this.SG.v7t(),
            Hg.qs.iA.tYe()
        }
        u1e(t) {
            super.u1e(t),
            t && (this.q0e = t.L0e(),
            this.h1e = !0,
            t.a1e() && (this.A2e = t))
        }
        gG() {
            if (!this.h1e)
                return;
            const t = new Hg.Event("beforeundock");
            t.xRt = this,
            this.dispatchEvent(t);
            const i = new Hg.Event("beforeanyundock");
            i.xRt = this,
            Hg.qs.RW.dispatchEvent(i),
            this.i3e(!0);
            let e = null
              , s = null;
            this.eX() && (s = this.B1e.Kpt(),
            this.SG = this.B1e.qm(),
            this.q0e = this.B1e.L0e(),
            this.B1e.L2e(this),
            1 === this.B1e.Q6t() && (e = this.B1e),
            this.B1e = null);
            let n = "left" === this.q0e || "right" === this.q0e;
            "" === this.q0e && (n = this.SG.GZi());
            let r, h = this.SG.M0e();
            if (h && h.K0e()) {
                let t = h.L0e();
                n = "left" === t || "right" === t
            }
            s || (s = this.Kpt()),
            n ? (r = s.right - s.left,
            r > window.innerWidth / 2 && (r = window.innerWidth / 2)) : (r = s.bottom - s.top,
            r > window.innerHeight / 2 && (r = window.innerHeight / 2)),
            r <= 0 && (r = Xg),
            this.SG.D0e(this),
            this.p2e(),
            this.SG.so(),
            this.m2e(),
            this.A1e(),
            this.D2e(),
            this.F2e(this.P2e, this.I2e, r, Yg),
            this.c1e(`${r}px`),
            h && h.K0e() && h.q0e ? this.q0e = h.q0e : this.q0e || (this.q0e = n ? "left" : "top"),
            document.body.appendChild(this.Get),
            this.h1e = !1,
            this.L1e = !1,
            this.v7t(),
            this.SG = this.SG.m1e(),
            this.SG.y1e(),
            e && !e.a1e() && (e.B2e() ? this.SG.o1e(e) : Hg.qs.fA.O0e.s3e(e)),
            this.lX(),
            this.i3e(!1),
            this.SG.M1e();
            const o = new Hg.Event("afterundock");
            o.xRt = this,
            this.dispatchEvent(o);
            const a = new Hg.Event("afteranyundock");
            a.xRt = this,
            Hg.qs.RW.dispatchEvent(a),
            this.Get.setAttribute("role", "complementary")
        }
        SE(t, i, e) {
            if (Hg.Mw(t, Hg.qs.fA),
            Hg.Kq(i),
            Hg.Mw(e, Hg.qs.fA.W6t),
            this.h1e)
                return;
            if (Hg.kt.mj)
                return this.q0e = "left" === i || "top" === i ? "left" : "right",
                void this.$2e();
            if (!t && !i && !e && this.A2e)
                return this.A2e.H6t(this),
                void this.A2e.N6t(this);
            const s = new Hg.Event("beforedock");
            s.xRt = this,
            this.dispatchEvent(s);
            const n = new Hg.Event("beforeanydock");
            n.xRt = this,
            Hg.qs.RW.dispatchEvent(n),
            this.i3e(!0),
            t || (t = this.SG),
            t.hk() || (t = Hg.qs.RW.n3e(),
            Kg(t && t.hk(), "Nowhere to dock this pane to"));
            let r = i;
            if (i || (this.q0e = ""),
            e && e.K0e()) {
                let t = e.L0e();
                t && (r = t)
            }
            t.GZi() ? "top" === r ? r = "left" : "bottom" === r && (r = "right") : "left" === r ? r = "top" : "right" === r && (r = "bottom");
            let h = this.Kpt()
              , o = "left" === r || "right" === r ? h.right - h.left : h.bottom - h.top;
            this.SG = t,
            e && e.K0e() ? "left" === r || "right" === r ? e.s1e() ? o = Math.min(e.ns() / 2, Math.max(o, this.qnt())) : (o = Math.max(e.ns() / 2, this.qnt()),
            e.Qx(e.ns() / 2)) : "top" !== r && "bottom" !== r || (e.s1e() ? o = Math.min(e.Kn() / 2, Math.max(o, this.Xnt())) : (o = Math.max(e.Kn() / 2, this.Xnt()),
            e.Kx(e.Kn() / 2))) : e || ("left" === r || "right" === r ? o = Math.min(this.SG.ns() / 2, o) : "top" !== r && "bottom" !== r || (o = Math.min(this.SG.Kn() / 2, o))),
            this.U2e(r),
            this.h1e = !0,
            document.body.removeChild(this.Get),
            i && this.c1e(`${o}px`),
            this.e3e(),
            this.SG.F0e(this, e, i),
            this.SG.so(),
            Hg.qs.iA.tYe(),
            this.i3e(!1);
            const a = new Hg.Event("afterdock");
            a.xRt = this,
            this.dispatchEvent(a);
            const l = new Hg.Event("afteranydock");
            l.xRt = this,
            Hg.qs.RW.dispatchEvent(l),
            this.Get.setAttribute("role", "section")
        }
        g_() {
            this.lct = !0,
            this.gG(),
            this.bx(),
            this.lct = !1
        }
        NF() {
            return this.lct
        }
        lX() {
            this.eX() ? (this.B1e.N6t(this),
            this.B1e.lX()) : super.lX()
        }
        r3e(t) {
            if (t = !!t,
            !this.K0e() || this.B2e() || this.N2e())
                return;
            t && (this.kp(this.I2e, !0),
            this.Gp(this.P2e, !0));
            let i = this.Kpt()
              , e = window.innerWidth
              , s = window.innerHeight;
            i.right > e && this.kp(Math.max(this._a() - (i.right - e), 0), !0),
            i.left < 0 && this.kp(this._a() - i.left, !0),
            i.bottom > s && this.Gp(Math.max(this.Da() - (i.bottom - s), 0), !0),
            i.top < 0 && this.Gp(this.Da() - i.top, !0)
        }
        h3e() {
            let t = new Hg.Event("activate");
            t.xRt = this,
            this.dispatchEvent(t)
        }
        X2e(t) {
            let i = new Hg.Event("displaystylechange");
            i.xRt = this,
            i.visible = t,
            this.dispatchEvent(i)
        }
        ZYe(t, i) {
            if (Hg.Ge(t),
            Hg.Ge(i),
            this.eX() || !this.q0e)
                return "";
            if (self.app.Ik().wj() && !Hg.kt.mj)
                return "";
            let e = this.Kpt()
              , s = Hg.qs.pGt()
              , n = 2 * s
              , r = "";
            if (t > e.left + s && t < e.right - s && i > e.top + s && i < e.bottom - s ? r = "m" : Hg.qs.iA.ZXe() ? this.V0e() || (t >= e.left && t <= e.left + n ? i >= e.top && i <= e.top + n ? r = "nw" : i <= e.bottom && i >= e.bottom - n ? r = "sw" : i > e.top + n && i < e.bottom - n && t <= e.left + s && (r = "w") : t <= e.right && t >= e.right - n ? i >= e.top && i <= e.top + n ? r = "ne" : i <= e.bottom && i >= e.bottom - n ? r = "se" : i > e.top + n && i < e.bottom - n && t >= e.right - s && (r = "e") : t > e.left + n && t < e.right - n && (i >= e.top && i <= e.top + s ? r = "n" : i <= e.bottom && i >= e.bottom - s && (r = "s"))) : r = "",
            this.B2e())
                if ("left" === this.q0e)
                    r = "ne" === r || "se" === r || "e" === r ? "e" : "";
                else if ("right" === this.q0e)
                    r = "nw" === r || "sw" === r || "w" === r ? "w" : "";
                else if ("top" === this.q0e)
                    r = "sw" === r || "se" === r || "s" === r ? "s" : "";
                else if ("bottom" === this.q0e)
                    r = "nw" === r || "ne" === r || "n" === r ? "n" : "";
                else if ("tab" === this.q0e)
                    return "";
            return r
        }
        D2e() {
            let t = Hg.qs.RW.o3e(this.I2e, this.P2e);
            this.I2e = t.x,
            this.P2e = t.y
        }
        F2e(t, i, e, s) {
            this.Get.setAttribute("floating", ""),
            this.i2e = i,
            this.e2e = t,
            this.fge(),
            this.s2e = e,
            this.n2e = s,
            this.Get.style.width = `${e}px`,
            this.Get.style.height = `${s}px`
        }
        e3e() {
            this.Get.style.transform = "",
            this.Get.style.width = "",
            this.Get.style.height = "",
            this.Get.removeAttribute("floating")
        }
        static a3e(t) {
            Hg.U(t, Hg.qs.fA.W6t),
            Kg(!(t instanceof Hg.qs.fA.O0e), "cannot replace tabbed pane with another tabbed pane"),
            Kg(t.K0e() && t.RXe(), "expected floating docking pane");
            let i = Hg.yR(t.phs)
              , e = Hg.v(Hg.qs.fA.O0e, t.qm(), t.$0e(), i);
            return e.gG(),
            e.X0e(t.L0e()),
            e.Qx(t.ns()),
            e.Kx(t.Kn()),
            e.kp(t._a()),
            e.Gp(t.Da()),
            Hg.qs.BW(t.hk()),
            t.v7t(),
            Hg.qs.iA.tYe(),
            e
        }
    }
}
{
    const ey = self.t
      , sy = 350
      , ny = 2e3;
    let ry = -1;
    function hy() {
        for (const t of oy)
            t.l3e()
    }
    const oy = new Set;
    ey.qs.fA.k0e = class extends ey.qs.fA.A0e {
        constructor(t, i, e, s, n) {
            super(t, i, e, s),
            this.vJe = ey.qs.lk("ui-caption", this.Get),
            this.t2e = this.Fa(),
            this.SJe = ey.qs.lk("span", this.vJe, null, "pane-caption-text"),
            this.SJe.textContent = this.t2e,
            this.u3e = "",
            this.BJe = null,
            n?.tqt && (this.BJe = ey.v(ey.qs.Jj.$Je, this.vJe),
            this.BJe.onclick = () => this.c3e(),
            n?.sqt && this.BJe.$6i(self.lang(n?.sqt))),
            this.LJe = ey.v(ey.qs.Jj.X5t, this.vJe),
            this.LJe.onclick = () => this.d3e(),
            this.f3e = !1,
            this.p3e = "",
            this.dP = ey.qs.lk("ui-body", this.Get),
            this.dP.setAttribute("row2", ""),
            this.Get.setAttribute("captioned", ""),
            this.m3e = !1,
            this.w3e = !1,
            this.DJe = null,
            this.kJe = !1,
            this.g3e = !0,
            this.y3e = !1,
            this.FJe = t => this.G_t(),
            this.b3e = t => this.v3e(),
            this.S3e = NaN,
            this.x3e = NaN,
            this.M3e = t => this.E3e(),
            this.l1 = t => {
                t.button === ey.f1.e5 && this.C3e(t.clientX, t.clientY, t.pointerId)
            }
            ,
            this.vJe.addEventListener("pointerdown", this.l1),
            this.gpt = t => this._3e(),
            this.vJe.addEventListener("UIDoubleTap", this.gpt),
            this.P8 = t => {
                t.preventDefault(),
                this.T3e(t.clientX, t.clientY)
            }
            ,
            this.vJe.addEventListener("contextmenu", this.P8),
            this.I3e = null,
            oy.add(this)
        }
        v6i() {
            return this.vJe
        }
        mP() {
            return this.dP
        }
        bx() {
            this.y3e = !0,
            this.G_t(),
            this.vJe.removeEventListener("pointerdown", this.l1),
            this.vJe.removeEventListener("UIDoubleTap", this.gpt),
            this.vJe.removeEventListener("contextmenu", this.P8),
            this.l1 = null,
            this.gpt = null,
            this.P8 = null,
            this.I3e = null,
            this.LJe.he(),
            this.LJe = null,
            this.BJe && (this.BJe.he(),
            this.BJe = null),
            ey.qs.BW(this.SJe),
            ey.qs.BW(this.vJe),
            ey.qs.BW(this.dP),
            this.SJe = null,
            this.vJe = null,
            this.dP = null,
            oy.delete(this),
            super.bx()
        }
        iP(t, i) {
            this.f3e = !!t,
            this.f3e && (ey.zt(i),
            this.p3e = i)
        }
        async d3e() {
            const t = self.app
              , i = self.lang;
            if (this.f3e) {
                const e = "close-bar-dont-ask-again";
                if (!await localforage.getItem(e)) {
                    t.Lii("CloseBarPrompt", "Shown"),
                    ey.p.u("ui.bars.confirm-close-prompt");
                    const s = ey.qs.Ys.$s("ConfirmCheck")
                      , n = s.Qa({
                        caption: i(".caption"),
                        message: ey.v(ey.MC, self.tP(".message", this.p3e), {
                            O0: !0
                        }),
                        jD: i(".close-bar"),
                        lQe: i("common.dont-ask-again")
                    });
                    ey.p.j();
                    if (null === await n)
                        return void t.Lii("CloseBarPrompt", "Cancelled");
                    if (s.dQe()) {
                        t.Lii("CloseBarPrompt", "Confirmed-DontAskAgain");
                        try {
                            await localforage.setItem(e, !0)
                        } catch (t) {
                            (() => {})('Failed to save "Don\'t ask again" preference: ', t)
                        }
                    } else
                        t.Lii("CloseBarPrompt", "Confirmed")
                }
            }
            this.g_()
        }
        c3e() {
            if (this.NF() || this.TXe() || !globalThis.app.a7t())
                return;
            let t = new ey.Event("showmenudots");
            t.xRt = this,
            this.dispatchEvent(t)
        }
        $2e() {
            super.$2e(),
            this.LJe.he(),
            this.LJe = null
        }
        C3e(t, i, e) {
            ey.Ge(t),
            ey.Ge(i),
            ey.Ge(e),
            ey.qs.RW.YYe(this, t, i, e)
        }
        _3e() {
            this.N2e() || (this.RXe() ? this.P3e() : this.gG())
        }
        K_t() {
            return this.kJe
        }
        async J_t(t, i, e, s) {
            if (ey.cO(t),
            ey.cO(i),
            ey.cO(e),
            ey.cO(s),
            this.kJe)
                throw new Error("already awaiting popup window");
            if (this.DJe)
                throw new Error("already in popup window");
            if (!this.JXe())
                throw new Error("opening to popup window disabled for this pane");
            this.kJe = !0;
            let n = new ey.Event("beforepopupopen");
            n.xRt = this,
            this.dispatchEvent(n);
            let r = "window.html";
            ey.jii() || (r += "?mode=dev"),
            Number.isFinite(t) && Number.isFinite(i) || !Number.isFinite(this.S3e) || !Number.isFinite(this.x3e) || (t = this.S3e,
            i = this.x3e),
            Number.isFinite(e) || (e = this.ns()),
            Number.isFinite(s) || (s = sy);
            try {
                const n = (await ey.qs.oYe.lYe(r, this.phs, e, s, t, i, e, s)).window;
                return this.S3e = n.screenX,
                this.x3e = n.screenY,
                -1 === ry && (ry = globalThis.setInterval(hy, ny)),
                this.jZe(n),
                self.app.M_(),
                n.addEventListener("unload", t => this.NZe(n)),
                n
            } catch (t) {
                this.kJe = !1,
                ey.qs.Ys.$s("OK").Qa(self.lang("ui.cannot-open-popup"));
                let i = new ey.Event("afterpopupclose");
                return i.xRt = this,
                this.dispatchEvent(i),
                null
            }
        }
        jZe(t) {
            this.B2e() ? (this.g3e = !0,
            this.gG()) : this.g3e = !1,
            this.x_(!1),
            ey.qs.BW(this.dP),
            t.document.body.setAttribute("id", this.phs),
            t.document.body.className = this.hk().className,
            t.document.body.appendChild(this.dP),
            this.kJe = !1,
            this.DJe = t,
            window.addEventListener("unload", this.FJe),
            t.addEventListener("resize", this.b3e),
            t.addEventListener("focus", this.M3e),
            t.document.title = this.t2e,
            this.d1e(),
            this.E3e();
            let i = new ey.Event("afterpopupopen");
            i.xRt = this,
            this.dispatchEvent(i)
        }
        NZe(t) {
            if (this.y3e)
                return;
            let i = new ey.Event("beforepopupclose");
            i.xRt = this,
            this.dispatchEvent(i);
            for (const t of ey.qs.HY.GYe(this.DJe))
                t.vwt(!0);
            ey.qs.BW(this.dP),
            this.Get.appendChild(this.dP),
            this.DJe = null,
            t.removeEventListener("resize", this.b3e),
            t.removeEventListener("focus", this.M3e),
            window.removeEventListener("unload", this.FJe),
            this.SJe.textContent = this.t2e,
            this.x_(!0),
            this.g3e ? this.P3e() : this.r3e(),
            [...oy].some(t => t.xY()) || -1 !== ry && (globalThis.clearInterval(ry),
            ry = -1),
            i = new ey.Event("afterpopupclose"),
            i.xRt = this,
            this.dispatchEvent(i)
        }
        uH(t, i, e) {
            return !this.xY() && super.uH(t, i, e)
        }
        ZYe(t, i) {
            return ey.Ge(t),
            ey.Ge(i),
            this.xY() ? "" : super.ZYe(t, i)
        }
        G_t() {
            this.DJe && (this.DJe.close(),
            this.DJe = null,
            this.kJe = !1)
        }
        xY() {
            return !!this.DJe
        }
        A_t() {
            return this.DJe
        }
        v3e() {
            this.d1e(),
            globalThis.app.G3e()
        }
        E3e() {
            ey.qs.iA.SF(this)
        }
        l3e() {
            if (!this.xY())
                return;
            const t = this.DJe.screenX
              , i = this.DJe.screenY;
            this.S3e === t && this.x3e === i || (this.S3e = t,
            this.x3e = i,
            globalThis.app.G3e())
        }
        __() {
            return super.__() || this.xY()
        }
        x_(t) {
            t = !!t,
            this.__() !== t && super.x_(t)
        }
        ns() {
            return this.DJe ? this.DJe.innerWidth : super.ns()
        }
        Kn() {
            return this.DJe ? this.DJe.innerHeight : super.Kn()
        }
        Q1e() {
            return [this.S3e, this.x3e]
        }
        gV() {
            return this.dP.clientWidth
        }
        aV() {
            return this.dP.clientHeight
        }
        T3e(t, i) {
            if (ey.Ge(t),
            ey.Ge(i),
            this.N2e())
                return;
            if (this.kJe)
                return;
            ey.p.u("ui.bars.captionMenu");
            let e = ey.v(ey.qs.Ek, this.vJe);
            ey.kt.lA && (e.Pk(null, this.B2e() ? self.lang(".undock") : self.lang(".dock"), this.gpt),
            this.JXe() && e.Pk("open-popup", self.lang(".open-to-popup-window"), () => this.J_t(), {
                Ck: !0
            })),
            e.Pk("close", self.lang(".close"), () => this.d3e()),
            e.nF(t, i),
            ey.p.j()
        }
        yG(t) {
            ey.qd(t),
            this.I3e = t
        }
        vG(t) {
            this.I3e && this.I3e(t)
        }
        uG() {
            this.m3e = !0
        }
        A3e(t) {
            (t = !!t) && !this.w3e ? (this.Get.setAttribute("caption-hidden", ""),
            this.vJe.setAttribute("hidden", "")) : !t && this.w3e && (this.Get.removeAttribute("caption-hidden"),
            this.vJe.removeAttribute("hidden")),
            this.w3e = t
        }
        u1e(t) {
            super.u1e(t),
            this.m3e && (t ? this.A3e(t.a1e()) : this.A3e(!1))
        }
        t$(t) {
            if (ey.zt(t),
            this.t2e === t)
                return;
            this.t2e = t,
            this.DJe ? this.DJe.document.title = t : this.SJe.textContent = t;
            let i = this.sX();
            i && i.R3e(this, this.t2e)
        }
        k3e() {
            return this.t2e
        }
        sQ(t) {
            if (ey.zt(t),
            this.u3e === t)
                return;
            this.u3e = t;
            let i = this.sX();
            i && i.O3e(this, this.u3e)
        }
        S2e() {
            return this.u3e
        }
        dG(t) {
            super.dG(t);
            const i = this.sX();
            i && i.D3e(this)
        }
        wG(t) {
            super.wG(t);
            const i = this.sX();
            i && i.D3e(this)
        }
        gG() {
            this.A3e(!1),
            super.gG()
        }
        SE(t, i, e) {
            this.m3e || (this.A2e = null),
            super.SE(t, i, e)
        }
        P3e() {
            let t = this.A2e ? null : this.L0e();
            this.SE(null, t)
        }
        static F3e() {
            for (const t of oy)
                t.g_()
        }
    }
}
{
    const ay = self.t
      , ly = self.assert
      , uy = -30
      , cy = -16
      , dy = new Set(["top", "bottom"]);
    ay.qs.fA.O0e = class extends ay.qs.fA.A0e {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.r2e = "",
            this.dP = ay.qs.lk("ui-body", this.Get),
            this.h2e = ay.v(ay.qs.Jj.L3e, this.Get, {
                B3e: !0,
                U3e: !0
            }),
            this.N3e = !1,
            this.j3e = null,
            this.Hye = ay.v(ay.kh, ay.jh.Gh(this.h2e, "activetabchanged", t => this.$3e(t)), ay.jh.Gh(this.h2e, "tearofftab", t => this.z3e(t)), ay.jh.Gh(this.h2e, "tabmiddleclick", t => this.V3e(t.tab)), ay.jh.Gh(this.h2e, "tabcontextmenu", t => {
                t.preventDefault(),
                this.W3e(t.tab, t.clientX, t.clientY)
            }
            ), ay.jh.Gh(this.h2e, "tabclose", t => this.Z6t(t.tab)), ay.jh.Gh(ay.qs.iA, "activewindowchange", t => this.WW())),
            this.H3e = -1,
            this.N5t("bottom")
        }
        bx() {
            -1 !== this.H3e && (window.clearTimeout(this.H3e),
            this.H3e = -1),
            this.Hye.Vh(),
            this.Hye = null,
            ay.qs.BW(this.dP),
            this.dP = null,
            this.h2e.he(),
            this.h2e = null,
            super.bx()
        }
        mP() {
            return this.dP
        }
        Sk() {
            return this.h2e
        }
        Q6t() {
            return this.h2e.Q6t()
        }
        D5t() {
            this.N3e = !0
        }
        a1e() {
            return this.N3e
        }
        N5t(t) {
            if (!dy.has(t))
                throw new Error(`invalid tab side '${t}'`);
            this.r2e !== t && ("bottom" === this.r2e ? (this.Get.removeAttribute("tabbed-bottom"),
            this.dP.removeAttribute("row1"),
            this.h2e.hk().removeAttribute("row2")) : (this.Get.removeAttribute("tabbed-top"),
            this.dP.removeAttribute("row2"),
            this.h2e.hk().removeAttribute("row1")),
            this.r2e = t,
            this.Get.setAttribute("tabbed-" + this.r2e, ""),
            "bottom" === this.r2e ? (this.dP.setAttribute("row1", ""),
            this.h2e.hk().setAttribute("row2", "")) : (this.dP.setAttribute("row2", ""),
            this.h2e.hk().setAttribute("row1", "")),
            this.h2e.N5t(this.r2e))
        }
        l1e() {
            return ly(1 === this.h2e.Q6t(), "should have only one tab"),
            this.h2e.K3e(0).Pp()
        }
        H6t(t, i) {
            if (ay.U(t, ay.qs.fA.W6t),
            t instanceof ay.qs.fA.O0e) {
                let e = t.h2e;
                for (let t of e.tabs()) {
                    let e = t.Pp();
                    e.D1e();
                    let s = this.h2e.L6t(e.Fa(), i);
                    s.Fie(e),
                    s.Kvt(e.pG()),
                    s.Hvt(e.mG()),
                    e.u1e(this)
                }
                t.bx(),
                this.h2e.X6t(this.h2e.Q6t() - 1)
            } else {
                let e;
                t.D1e(),
                t.u1e(this),
                e = t instanceof ay.qs.fA.k0e ? t.k3e() : t.Fa();
                let s = this.h2e.L6t(e, i);
                s.Fie(t),
                s.Kvt(t.pG()),
                s.Hvt(t.mG());
                const n = t.S2e();
                n && s.$6i(n),
                this.j3e || this.q3e(t)
            }
            this.d1e()
        }
        X3e(t) {
            ay.U(t, ay.qs.fA.W6t);
            for (let i of this.h2e.tabs())
                if (i.Pp() === t)
                    return i;
            return null
        }
        Y3e(t) {
            ay.U(t, ay.qs.fA.W6t);
            let i = 0;
            for (let e of this.h2e.tabs()) {
                if (e.Pp() === t)
                    return i;
                ++i
            }
            return -1
        }
        L2e(t) {
            ay.U(t, ay.qs.fA.W6t);
            let i = this.Y3e(t);
            ly(i > -1, "Cannot find tab for pane to remove"),
            this.j3e === t && (this.j3e = null),
            this.h2e.J3e(i),
            this.j3e && this.j3e.v7t()
        }
        f2e() {
            return this.j3e
        }
        O1e(t) {
            if (ay.U(t, ay.qs.fA.W6t),
            this.j3e !== t)
                for (let i of this.h2e.tabs())
                    i.Pp() === t && this.h2e.Z3e(i)
        }
        q3e(t, i) {
            if (ay.U(t, ay.qs.fA.W6t),
            ay.Kq(i),
            this.j3e !== t) {
                if (this.j3e && this.j3e.D1e(),
                this.dP.appendChild(t.hk()),
                this.j3e = t,
                this.j3e.v7t(),
                this.j3e.d1e(),
                -1 !== this.H3e && window.clearTimeout(this.H3e),
                "removal" === i) {
                    const t = this.j3e;
                    this.H3e = window.setTimeout( () => {
                        if (ay.Vl) {
                            if (ay.dn(t))
                                return
                        } else if (t.dn())
                            return;
                        t.h3e()
                    }
                    , 5)
                } else
                    this.j3e.h3e();
                ay.qs.iA.SF(this.j3e)
            }
        }
        d1e() {
            super.d1e(),
            this.j3e && this.j3e.d1e()
        }
        N6t(t) {
            ay.U(t, ay.qs.fA.W6t);
            let i = this.Y3e(t);
            i < 0 || this.h2e.X6t(i)
        }
        R3e(t, i) {
            ay.U(t, ay.qs.fA.W6t),
            ay.zt(i);
            let e = this.X3e(t);
            e && e.iyt(i)
        }
        O3e(t, i) {
            ay.U(t, ay.qs.fA.W6t),
            ay.zt(i);
            const e = this.X3e(t);
            e && e.$6i(i)
        }
        D3e(t) {
            ay.U(t, ay.qs.fA.W6t);
            const i = this.X3e(t);
            i && (i.Kvt(t.pG()),
            i.Hvt(t.mG()))
        }
        $3e(t) {
            let i = t.tab.Pp();
            i && this.q3e(i, t.Q3e)
        }
        z3e(t) {
            let i = t.tab.Pp();
            self.app.aj() || i.K0e() && (i.NXe(uy, cy),
            ay.qs.RW.t4e(i, t.pointerId),
            ay.qs.RW.Bgi(t.clientX, t.clientY, t.pointerId),
            ay.qs.iA.SF(i),
            this.j3e && this.j3e.v7t())
        }
        W3e(t, i, e) {
            ay.U(t, ay.qs.Jj.Tab),
            ay.Ge(i),
            ay.Ge(e);
            let s = t.i4e()
              , n = t.Y6t()
              , r = t.e4e();
            if (!s && !n && !r)
                return;
            ay.p.u("ui.bars.tabPaneMenu");
            let h = ay.v(ay.qs.Ek, this.dP);
            const o = t.Pp();
            o.vG(h),
            ay.kt.lA && s && h.Pk(null, self.lang(".undock"), () => o.gG()),
            n && h.Pk("close", self.lang(".close"), () => this.Z6t(t)),
            this.Q6t() > 1 && r && h.Pk(null, self.lang(".close-others"), () => this.s4e(t)),
            h.nF(i, e),
            ay.p.j()
        }
        Z6t(t) {
            t.Pp().g_()
        }
        V3e(t) {
            t.Y6t() && t.n4e() && this.Z6t(t)
        }
        s4e(t) {
            ay.U(t, ay.qs.Jj.Tab);
            let i = t.Pp()
              , e = [];
            for (let t of this.h2e.tabs()) {
                let s = t.Pp();
                s !== i && e.push(s)
            }
            for (let t of e)
                t.g_()
        }
        v7t() {
            super.v7t(),
            this.j3e && this.j3e.v7t()
        }
        r4e() {
            for (let t of this.h2e.tabs()) {
                if (!t.Pp().K0e())
                    return !0
            }
            return !1
        }
        FXe() {
            return this.j3e || this
        }
        Yct() {
            return this.Get.hasAttribute("active")
        }
        WW() {
            let t = ay.qs.iA.RA() === this.j3e;
            ay.qs.CD(this.Get, "active", t)
        }
        static s3e(t) {
            ay.U(t, ay.qs.fA.O0e),
            ly(!t.a1e(), "should keep tabbed pane"),
            ay.U(t, ay.qs.fA.O0e),
            ly(1 === t.Q6t(), "expected tab pane with a single tab");
            let i = t.l1e();
            i.gG(),
            i.X0e(t.L0e()),
            i.Qx(t.ns()),
            i.Kx(t.Kn()),
            i.kp(t._a()),
            i.Gp(t.Da()),
            t.bx()
        }
    }
}
{
    const fy = self.t
      , py = self.assert
      , my = 80
      , wy = 40
      , gy = 30
      , yy = 30
      , by = 40;
    let vy = !1
      , Sy = new Map
      , xy = new Map
      , My = !1
      , Ey = null
      , Cy = null
      , _y = null
      , Ty = new Map
      , Iy = new Map
      , Py = []
      , Gy = []
      , Ay = null;
    function Ry() {
        fy.qs.SH.CH(Ay),
        Ay = null
    }
    let ky = NaN;
    function Oy() {
        if (isNaN(ky)) {
            let t = fy.qs.yQ("width", {
                className: "dockIndicator"
            });
            if (!t.endsWith("px"))
                throw new Error("CSS style for dock indicators must specify the size in units of 'px'");
            ky = parseInt(t, 10) || by
        }
        return ky
    }
    function Dy() {
        return window.innerWidth <= 600 ? 30 : 50
    }
    let Fy = []
      , Ly = []
      , By = null
      , Uy = null
      , Ny = null
      , jy = null
      , $y = null
      , zy = -2
      , Vy = 0
      , Wy = -2
      , Hy = 0
      , Ky = 0;
    function qy(t) {
        let i = t.L0e()
          , e = Ly.indexOf(t);
        py(-1 !== e, "cannot find swipe-in pane");
        for (let t = 1, s = Ly.length; t < s; ++t) {
            let n = Ly[(e + t) % s];
            if (n.L0e() === i)
                return n
        }
        return t
    }
    const Xy = t => {
        t.button === fy.f1.e5 && vy && fy.yc() && fy.qs.RW.Dgi(t.clientX, t.clientY, t.pointerId) && (t.preventDefault(),
        t.stopPropagation())
    }
    ;
    document.addEventListener("pointerdown", Xy);
    const Yy = t => {
        vy && fy.yc() && fy.qs.RW.Bgi(t.clientX, t.clientY, t.pointerId) && (t.preventDefault(),
        t.stopPropagation())
    }
    ;
    document.addEventListener("pointermove", Yy);
    const Jy = t => {
        vy && fy.yc() && (fy.qs.RW.Ugi(t.clientX, t.clientY, t.screenX, t.screenY, t.pointerId) && (t.preventDefault(),
        t.stopPropagation()),
        void 0 !== self.app && self.app.h4e() && self.app.M_())
    }
    ;
    document.addEventListener("pointerup", Jy);
    const Zy = t => {
        Jy(t)
    }
    ;
    document.addEventListener("pointercancel", Zy);
    const Qy = "iOS" === fy.kt.OS ? "after-resize" : "resize";
    window.addEventListener(Qy, () => {
        if (void 0 === self.app || !self.app.h4e())
            return;
        const t = fy.qs.Eqe();
        t && t.Pqe(),
        fy.qs.RW.o4e(),
        fy.qs.RW.Gqe(!0),
        self.app.M_()
    }
    ),
    fy.qs.iA.addEventListener("zindexchanged", () => fy.qs.RW.a4e()),
    fy.qs.HY.addEventListener("showmodal", () => {
        fy.qs.RW.l4e() && fy.qs.RW.u4e()
    }
    ),
    fy.qs.HY.addEventListener("hidemodal", () => {
        fy.qs.HY.DY() || fy.qs.RW.c4e()
    }
    );
    class tb extends fy.Event.aG {
        constructor() {
            if (vy)
                throw new Error("already created DockManager");
            super(),
            vy = !0
        }
        d4e() {
            return !(!Sy.size && !Ty.size)
        }
        k2e(t) {
            fy.U(t, fy.qs.fA.A0e),
            py(!Fy.includes(t), "Docking pane already exists in dock manager, don't try to add again"),
            Fy.push(t)
        }
        L2e(t) {
            fy.U(t, fy.qs.fA.A0e);
            let i = Fy.indexOf(t);
            py(i >= 0, "Cannot find docking pane to remove"),
            Fy.splice(i, 1)
        }
        W2e(t) {
            fy.U(t, fy.qs.fA.A0e),
            py(t.N2e(), "should be in swipe-in mode"),
            Ly.push(t),
            By || "left" !== t.L0e() ? Uy || "right" !== t.L0e() || (Uy = t) : By = t
        }
        a4e() {
            Fy.sort(fy.qs.Window.Z$)
        }
        f4e(t, i) {
            fy.Ge(t),
            fy.Ge(i);
            for (let e = 0, s = Fy.length; e < s; ++e) {
                let s = Fy[e];
                if (!s.B2e() && (s._a() === t && s.Da() === i))
                    return !0
            }
            return !1
        }
        o3e(t, i) {
            for (fy.Ge(t),
            fy.Ge(i); this.f4e(t, i); )
                t += wy,
                i += wy;
            return {
                x: t,
                y: i
            }
        }
        YYe(t, i, e, s) {
            if (fy.U(t, fy.qs.fA.A0e),
            fy.Ge(i),
            fy.Ge(e),
            fy.Ge(s),
            t.N2e())
                return;
            if (xy.has(t) || Iy.has(t))
                return;
            if (fy.qs.HY.DY() || fy.qs.Ek.DTi(i, e, window))
                return;
            if (fy.qs.RW.Dgi(i, e, s),
            Ty.has(s))
                return;
            let n = t;
            if (n.h3e(),
            n.eX()) {
                let t = n.sX();
                if (!t.r4e() && !t.a1e()) {
                    if (xy.has(t))
                        return;
                    n = t
                }
            }
            Sy.set(s, n),
            xy.set(n, s),
            n.LXe(i, e),
            n.NXe(n._a() - i, n.Da() - e),
            n.RXe() && n.lX()
        }
        p4e(t) {
            return fy.Ge(t),
            t <= Dy()
        }
        m4e(t) {
            return fy.Ge(t),
            t >= fy.qs._qe() - Dy()
        }
        CY(t) {
            return fy.Ge(t),
            this.p4e(t) || this.m4e(t)
        }
        Dgi(t, i, e) {
            if (fy.Ge(t),
            fy.Ge(i),
            fy.Ge(e),
            Sy.has(e) || Ty.has(e) || fy.qs.HY.DY() || fy.qs.Ek.DTi(t, i, window))
                return !1;
            if (Ly.length && -2 === zy) {
                if (this.p4e(t) && By)
                    return !(jy && !jy.j2e()) && (jy && "left" === jy.L0e() && (By = qy(jy)),
                    By !== jy && (Ny = By,
                    Ny.lX(),
                    zy = e,
                    Vy = 0),
                    !0);
                if (this.m4e(t) && Uy)
                    return !(jy && !jy.j2e()) && (jy && "right" === jy.L0e() && (Uy = qy(jy)),
                    Uy !== jy && (Ny = Uy,
                    Ny.lX(),
                    zy = e,
                    Vy = 0),
                    !0)
            }
            for (let s = Fy.length - 1; s >= 0; --s) {
                let n = Fy[s]
                  , r = n.ZYe(t, i);
                if ("m" === r)
                    return n !== jy || -2 !== zy || fy.qs.GY(t, i, n) || (Wy = e,
                    Hy = t,
                    Ky = i,
                    Vy = "left" === jy.L0e() ? jy.ns() - t : jy._a() - t),
                    !1;
                if (r && !n.N2e()) {
                    if (xy.has(n))
                        return !1;
                    if (fy.qs.iA.rYe(t, i, n, window))
                        break;
                    return Ty.set(e, n),
                    Iy.set(n, e),
                    n.zXe(r),
                    n.LXe(t, i),
                    n.WXe(n._a(), n.Da()),
                    n.qXe(n.ns(), n.Kn()),
                    n.h3e(),
                    fy.qs.RW.w4e(),
                    !0
                }
            }
            return !1
        }
        g4e(t, i) {
            fy.Ge(t),
            fy.Ge(i);
            for (let e = 0, s = Py.length; e < s; ++e) {
                let s = Py[e];
                if (s.uH(t, i))
                    return s
            }
            return null
        }
        Dqe(t, i, e) {
            fy.Ge(t),
            fy.Ge(i),
            fy.Mw(e, fy.qs.fA.W6t);
            for (let s = Fy.length - 1; s >= 0; --s) {
                let n = Fy[s];
                if (n === e)
                    return !1;
                if (n.RXe() && n.uH(t, i))
                    return !0
            }
            return !1
        }
        y4e(t, i, e) {
            if (fy.Ge(t),
            fy.Ge(i),
            fy.U(e, fy.qs.fA.A0e),
            !fy.qs.HY.DTi(t, i, window) && !fy.qs.Ek.DTi(t, i, window)) {
                for (let s = Fy.length - 1; s >= 0; --s) {
                    let n = Fy[s];
                    if (n !== e && n.RXe() && n.uH(t, i))
                        return n
                }
                return null
            }
        }
        Bgi(t, i, e, s) {
            if (fy.Ge(t),
            fy.Ge(i),
            fy.Ge(e),
            s = !!s,
            fy.m1.Cze(e))
                return !1;
            if (fy.qs.HY.DY() || fy.qs.Ek.DTi(t, i, window))
                return Ry(),
                !1;
            if (jy && jy.N2e() && !jy.j2e())
                return !1;
            if (jy && Wy === e)
                return ("left" === jy.L0e() && t <= Hy - gy || "right" === jy.L0e() && t >= Hy + gy) && !fy.qs.GY(t, i, jy) && (zy = Wy,
                Wy = -2,
                Ny = jy,
                jy = null),
                Math.abs(Ky - i) >= yy && (Wy = -2),
                !0;
            if (Ny && zy === e)
                return fy.qs.RW.Jgi(t + Vy, i),
                !0;
            if (Sy.has(e))
                return fy.qs.RW.b4e(t, i, e, Sy.get(e), s),
                !0;
            if (Ty.has(e))
                return fy.qs.RW.v4e(t, i, e, Ty.get(e)),
                !0;
            for (let e = Fy.length - 1; e >= 0; --e) {
                let s = Fy[e];
                if (s.N2e())
                    continue;
                let n = s.ZYe(t, i);
                if (n) {
                    if (fy.qs.iA.rYe(t, i, s, window))
                        break;
                    if (Ay)
                        "e" === n || "w" === n ? Ay.Set("ew-resize") : "n" === n || "s" === n ? Ay.Set("ns-resize") : "nw" === n || "se" === n ? Ay.Set("nwse-resize") : "ne" === n || "sw" === n ? Ay.Set("nesw-resize") : "m" === n && Ry();
                    else {
                        const e = {
                            onpointerdown: Xy,
                            onpointermove: Yy,
                            onpointerup: Jy,
                            onpointercancel: Zy
                        };
                        "e" === n || "w" === n ? Ay = fy.qs.SH.gH("ew-resize", document, t, i, e) : "n" === n || "s" === n ? Ay = fy.qs.SH.gH("ns-resize", document, t, i, e) : "nw" === n || "se" === n ? Ay = fy.qs.SH.gH("nwse-resize", document, t, i, e) : "ne" !== n && "sw" !== n || (Ay = fy.qs.SH.gH("nesw-resize", document, t, i, e))
                    }
                    return !!Ay
                }
            }
            return Ry(),
            !1
        }
        t4e(t, i) {
            fy.U(t, fy.qs.fA.A0e),
            fy.Ge(i),
            t.lX();
            let e = t.L0e()
              , s = "top" === e || "bottom" === e;
            t.gG(),
            s && t.NXe(t.ns() / -2, t.$Xe()),
            Sy.set(i, t),
            xy.set(t, i),
            1 === Sy.size ? fy.qs.RW.S4e() : fy.qs.RW.x4e()
        }
        Jgi(t, i) {
            fy.Ge(t),
            fy.Ge(i);
            let e = fy.qs._qe()
              , s = Ny.ns()
              , n = 0;
            if ("left" === Ny.L0e()) {
                let i = t - s;
                i > 0 && (i = 0),
                n = t / s
            } else {
                let i = t
                  , r = e - s;
                t < r && (i = r),
                n = 1 - (t - r) / s
            }
            Ny.Y2e(n),
            jy && jy !== Ny && jy.Y2e(1 - n),
            this.M4e()
        }
        b4e(t, i, e, s, n) {
            if (fy.Ge(t),
            fy.Ge(i),
            fy.Ge(e),
            fy.U(s, fy.qs.fA.A0e),
            n = !!n,
            s.TXe())
                return Sy.delete(e),
                xy.delete(s),
                fy.qs.RW.E4e(),
                fy.qs.RW.x4e(),
                fy.qs.RW.C4e(),
                Ey = null,
                void (Cy = null);
            if (!s.RXe() && fy.di(s.BXe(), s.UXe(), t, i) > my && fy.qs.RW.t4e(s, e),
            s.RXe()) {
                s.kp(t + s.jXe()),
                s.Gp(i + s.$Xe());
                const e = new fy.Event("move");
                e.xRt = s,
                s.dispatchEvent(e);
                let r = fy.qs.RW.g4e(t, i);
                n || 1 !== Sy.size ? fy.qs.RW.x4e() : s.BXe() === t && s.UXe() === i || fy.qs.RW.S4e(),
                r !== Ey && (Ey && fy.qs.RW.C4e(),
                r && fy.qs.RW._4e(r, s),
                Ey = r);
                let h = fy.qs.Eqe();
                if (h && 1 === Sy.size) {
                    let e = fy.qs.RW.y4e(t, i, s);
                    e || (e = h.Y0e(t, i, !0)),
                    e && !e._0e() && (e = null),
                    Iy.has(e) && (e = null),
                    e !== Cy && (Cy && fy.qs.RW.E4e(),
                    e && fy.qs.RW.T4e(e),
                    Cy = e)
                }
            }
        }
        v4e(t, i, e, s) {
            if (fy.Ge(t),
            fy.Ge(i),
            fy.Ge(e),
            fy.U(s, fy.qs.fA.A0e),
            s.TXe())
                return Ty.delete(e),
                void Iy.delete(s);
            let n = t - s.BXe()
              , r = i - s.UXe()
              , h = s.HXe()
              , o = s.KXe()
              , a = s.XXe()
              , l = s.YXe()
              , u = s.VXe();
            if ("e" === u || "se" === u || "ne" === u)
                s.Qx(a + n);
            else if ("w" === u || "sw" === u || "nw" === u) {
                if (s.RXe()) {
                    let t = h + a - s.qnt();
                    s.kp(Math.min(h + n, t))
                }
                s.Qx(a - n)
            }
            if ("s" === u || "sw" === u || "se" === u)
                s.Kx(l + r);
            else if ("n" === u || "nw" === u || "ne" === u) {
                if (s.RXe()) {
                    let t = o + l - s.Xnt();
                    s.Gp(Math.min(o + r, t))
                }
                s.Kx(l - r)
            }
        }
        Ugi(t, i, e, s, n) {
            if (fy.Ge(t),
            fy.Ge(i),
            fy.Ge(e),
            fy.Ge(s),
            fy.Ge(n),
            Wy === n && (Wy = -2),
            Ny && zy === n)
                return t += Vy,
                "left" === Ny.L0e() ? t < Ny.ns() / 2 ? (Ny.LN(!1),
                jy && jy !== Ny && jy.LN(!0),
                jy === Ny && (jy = null)) : (Ny.LN(!0),
                jy && jy !== Ny && jy.LN(!1),
                jy = Ny) : t > fy.qs._qe() - Ny.ns() / 2 ? (Ny.LN(!1),
                jy && jy !== Ny && jy.LN(!0),
                jy === Ny && (jy = null)) : (Ny.LN(!0),
                jy && jy !== Ny && jy.LN(!1),
                jy = Ny),
                Ny = null,
                zy = -2,
                this.M4e(),
                !0;
            if (Sy.has(n)) {
                let r = Sy.get(n);
                if (fy.qs.RW.b4e(t, i, n, r, !0),
                Ey)
                    fy.qs.RW.I4e(r);
                else {
                    let t = r.Kpt();
                    if (r instanceof fy.qs.fA.k0e && r.JXe() && (t.right <= 0 || t.bottom <= 0 || t.left > fy.qs._qe() || t.top > fy.qs.Tqe())) {
                        const t = self.devicePixelRatio;
                        r.J_t(e / t + r.jXe(), s / t + r.$Xe()).catch(t => {
                            r.r3e()
                        }
                        )
                    } else
                        r.r3e()
                }
                return Sy.delete(n),
                xy.delete(r),
                fy.qs.RW.E4e(),
                fy.qs.RW.x4e(),
                fy.qs.RW.C4e(),
                Ey = null,
                Cy = null,
                !0
            }
            if (Ty.has(n)) {
                let e = Ty.get(n);
                return fy.qs.RW.Bgi(t, i, n),
                e.r3e(),
                Ty.delete(n),
                Iy.delete(e),
                fy.qs.RW.P4e(),
                !0
            }
            return !1
        }
        w4e() {
            fy.qs.RW.dispatchEvent(new fy.Event("paneresizestart"))
        }
        P4e() {
            fy.qs.RW.dispatchEvent(new fy.Event("paneresizeend"))
        }
        o4e() {
            for (let t = 0, i = Fy.length; t < i; ++t)
                Fy[t].v7t()
        }
        Gqe(t) {
            t = !!t;
            for (let i of Fy)
                i.r3e(t);
            for (let t of Ly)
                t.V2e()
        }
        G4e(t) {
            if (fy.U(t, fy.qs.fA),
            t._0e())
                return t;
            let i, e, s = t.C0e();
            for (let t = 0, n = s.length; t < n; ++t)
                if (i = s[t].Z0e(),
                i && (e = fy.qs.RW.G4e(i),
                e))
                    return e;
            return null
        }
        n3e() {
            let t = fy.qs.Eqe();
            return t ? fy.qs.RW.G4e(t) : null
        }
        A4e(t, i, e, s) {
            fy.Ge(i),
            fy.Ge(e),
            fy.zt(s);
            let n = Oy()
              , r = fy.v(fy.qs.R4e, t, i, e, n, n, s);
            return r.k4e(),
            r
        }
        S4e() {
            if (My)
                return;
            let t = fy.qs.RW.n3e();
            if (!t)
                return;
            py(t._0e(), "Expected to find a dock target to show dock indicators for");
            let i = t.Kpt();
            const e = Oy()
              , s = e / 2
              , n = e + s
              , r = (i.left + i.right) / 2 - s
              , h = (i.top + i.bottom) / 2 - s;
            let o = fy.qs.RW.A4e(t, i.left + s, h - n, "left")
              , a = fy.qs.RW.A4e(t, r + n, i.top + s, "top")
              , l = fy.qs.RW.A4e(t, i.right - e - s, h - n, "right")
              , u = fy.qs.RW.A4e(t, r + n, i.bottom - e - s, "bottom");
            Py.push(o, a, l, u),
            My = !0
        }
        x4e() {
            fy.qs.RW.C4e(),
            fy.qs.RW.E4e();
            for (let t = 0, i = Py.length; t < i; ++t)
                Py[t].O4e();
            fy.sc(Py),
            My = !1
        }
        _4e(t, i) {
            fy.U(t, fy.qs.R4e),
            fy.U(i, fy.qs.fA.W6t),
            fy.qs.RW.C4e();
            let e = t.D4e()
              , s = e.Kpt()
              , n = i.Kpt()
              , r = e instanceof fy.qs.fA.A0e
              , h = e instanceof fy.qs.fA.W6t && e.s1e() || !(e instanceof fy.qs.fA.W6t)
              , o = s.left
              , a = s.top
              , l = s.right - s.left
              , u = s.bottom - s.top
              , c = t._gi();
            if ("left" === c || "right" === c) {
                const t = n.right - n.left;
                h ? l = Math.min(t, l / 2) : r ? l /= 2 : l = t
            } else if ("top" === c || "bottom" === c) {
                const t = n.bottom - n.top;
                h ? u = Math.min(t, u / 2) : r ? u /= 2 : u = t
            }
            "right" === c ? o = s.right - l : "bottom" === c && (a = s.bottom - u),
            _y = fy.v(fy.qs.F4e, o, a, l, u, c),
            _y.k4e()
        }
        C4e() {
            _y && (_y.O4e(),
            _y = null)
        }
        I4e(t) {
            fy.U(t, fy.qs.fA.W6t),
            py(t && Ey, "Must have dragging pane and hovered indicator to dock");
            let i = Ey.D4e();
            py(i, "No dock target available when docking");
            let e = Ey._gi();
            i instanceof fy.qs.fA ? fy.qs.RW.L4e(t, i, e) : i instanceof fy.qs.fA.W6t ? fy.qs.RW.B4e(t, i, e) : py(!1, "Unexpected dock target type")
        }
        L4e(t, i, e) {
            if (fy.U(t, fy.qs.fA.W6t),
            fy.zt(e),
            py("tab" !== e, "Cannot dock as tabbed to a layout"),
            i.f1e() && i.p1e("left" === e || "right" === e),
            i.GZi() && ("left" === e || "right" === e) || !i.GZi() && ("top" === e || "bottom" === e))
                t.SE(i, e);
            else {
                let s = i.Q0e(!i.GZi());
                t.SE(s, e)
            }
        }
        B4e(t, i, e) {
            if (fy.U(t, fy.qs.fA.W6t),
            fy.zt(e),
            i instanceof fy.qs.fA.A0e && i.N2e())
                return;
            t.i3e(!0),
            i.i3e(!0);
            let s = i.qm();
            if ("tab" === e)
                if (i instanceof fy.qs.fA.O0e)
                    i.H6t(t),
                    t instanceof fy.qs.fA.O0e || i.N6t(t);
                else {
                    let e;
                    e = i.K0e() && i.RXe() ? fy.qs.fA.A0e.a3e(i) : s.r1e(i),
                    e.H6t(i),
                    e.H6t(t),
                    t instanceof fy.qs.fA.O0e || e.N6t(t)
                }
            else if (s.GZi() && ("left" === e || "right" === e) || !s.GZi() && ("top" === e || "bottom" === e))
                t.SE(s, e, i);
            else {
                let n = s.GZi() ? i.Kn() : i.ns()
                  , r = i.ns() / 2
                  , h = i.Kn() / 2
                  , o = s.e1e(i, !s.GZi());
                if (t.SE(o, e),
                i.K0e())
                    if (t.V0e()) {
                        let t = o.C0e();
                        if (t.length >= 2) {
                            let i = t.at(-2);
                            s.GZi() ? i.Kx(n / 2) : i.Qx(n / 2)
                        }
                    } else
                        s.GZi() ? (!i.s1e() || t.Kn() > h) && t.Kx(n / 2) : (!i.s1e() || t.ns() > r) && t.Qx(n / 2);
                s.so(!0)
            }
            i.i3e(!1),
            t.i3e(!1)
        }
        E4e() {
            for (let t = 0, i = Gy.length; t < i; ++t) {
                let i = Gy[t];
                i.O4e(),
                fy.sni(Py, i)
            }
            fy.sc(Gy)
        }
        T4e(t) {
            if (!My)
                return;
            py(t._0e(), "Expected to find a dock target to show dock indicators for");
            let i = t.Kpt();
            const e = Oy()
              , s = e / 2
              , n = e / 8
              , r = (i.left + i.right) / 2 - s
              , h = (i.top + i.bottom) / 2 - s;
            let o, a, l, u, c;
            t.K0e() && !t.B2e() || (o = fy.qs.RW.A4e(t, r - n - e, h, "left"),
            a = fy.qs.RW.A4e(t, r, h - n - e, "top"),
            l = fy.qs.RW.A4e(t, r + n + e, h, "right"),
            u = fy.qs.RW.A4e(t, r, h + n + e, "bottom"),
            Py.push(o, a, l, u),
            Gy.push(o, a, l, u)),
            c = fy.qs.RW.A4e(t, r, h, "tab"),
            Py.push(c),
            Gy.push(c)
        }
        M4e() {
            let t = 0;
            Ny && (t += Ny.J2e()),
            jy && (t += jy.J2e());
            let i = new fy.Event("swipeinviewoffset");
            i.offsetX = t,
            this.dispatchEvent(i)
        }
        l4e() {
            return jy && !Ny
        }
        u4e(t=!0) {
            jy && ($y = t ? jy : null,
            jy.LN(!1),
            jy = null)
        }
        c4e() {
            $y && (jy = $y,
            jy.LN(!0),
            $y = null)
        }
        U4e(t) {
            jy = t,
            jy.LN(!0)
        }
    }
    fy.qs.RW = fy.v(tb)
}
{
    const ib = self.t
      , eb = self.assert
      , sb = ["left", "top", "right", "bottom", "tab"]
      , nb = -50
      , rb = -50
      , hb = 50
      , ob = 50;
    let ab = {
        duration: 300,
        easing: "ease",
        direction: null
    };
    ib.qs.R4e = class extends ib.Me {
        constructor(t, i, e, s, n, r) {
            ib.Ge(i),
            ib.Ge(e),
            ib.Ge(s),
            ib.Ge(n),
            super(),
            eb(t._0e(), "Must be a dock target"),
            eb(sb.includes(r), "Invalid dock indicator side"),
            this.jbi = document.body,
            this.Get = ib.qs.lk("div", this.jbi, null, "dockIndicator"),
            this.N4e = t,
            this.Qgi = r,
            this.j4e = 0,
            this.$4e = 0,
            this.kd = i,
            this.Gd = e,
            this.ZC = s,
            this.tv = n,
            this.xJe = null,
            this.z4e = !1,
            "left" === this.Qgi ? this.j4e = rb : "top" === this.Qgi ? this.$4e = nb : "right" === this.Qgi ? this.j4e = hb : "bottom" === this.Qgi && (this.$4e = ob)
        }
        V4e(t) {
            t = !!t,
            eb(!this.xJe, "Should not start new dock indicator animation if already playing animation");
            let i = [{
                transform: `translate(${this.kd + this.j4e}px, ${this.Gd + this.$4e}px)`,
                opacity: "0"
            }, {
                transform: `translate(${this.kd}px, ${this.Gd}px)`,
                opacity: "1"
            }];
            ab.direction = t ? "reverse" : "normal",
            this.xJe = this.Get.animate(i, ab),
            this.xJe.onfinish = t => this.W4e()
        }
        k4e() {
            self.app.zmt() ? this.V4e(!1) : this.W4e()
        }
        O4e() {
            eb(!this.z4e, "Animating out dock indicator which is already animating out"),
            this.z4e = !0,
            this.Get.style.transform = "",
            self.app.zmt() ? this.xJe ? this.xJe.playbackRate *= -1 : this.V4e(!0) : (this.H4e(),
            window.setTimeout( () => this.W4e(), 10))
        }
        W4e() {
            this.xJe = null,
            this.z4e ? this.bx() : this.H4e()
        }
        H4e() {
            this.Get && (this.Get.style.transform = `translate(${this.kd}px, ${this.Gd}px)`)
        }
        bx() {
            this.xJe = null,
            this.z4e = !1,
            this.jbi && this.Get && this.jbi.removeChild(this.Get),
            this.Get = null,
            this.jbi = null,
            this.N4e = null,
            ib.he(this)
        }
        uH(t, i) {
            return ib.Ge(t),
            ib.Ge(i),
            t >= this.kd && i >= this.Gd && t <= this.kd + this.ZC && i <= this.Gd + this.tv
        }
        _gi() {
            return this.Qgi
        }
        D4e() {
            return this.N4e
        }
    }
}
{
    const lb = self.t
      , ub = "0.5"
      , cb = [{
        transform: "scale(0.9)",
        opacity: "0"
    }, {
        transform: "scale(1)",
        opacity: ub
    }];
    let db = {
        duration: 300,
        easing: "ease",
        fill: "forwards",
        direction: null
    };
    lb.qs.F4e = class extends lb.Me {
        constructor(t, i, e, s, n) {
            switch (lb.Ge(t),
            lb.Ge(i),
            lb.Ge(e),
            lb.Ge(s),
            lb.zt(n),
            super(),
            this.jbi = document.body,
            this.Get = lb.qs.lk("div", this.jbi, null, "dockGhost"),
            this.xJe = null,
            this.z4e = !1,
            n) {
            case "left":
                this.Get.classList.add("originLeft");
                break;
            case "top":
                this.Get.classList.add("originTop");
                break;
            case "right":
                this.Get.classList.add("originRight");
                break;
            case "bottom":
                this.Get.classList.add("originBottom");
                break;
            case "tab":
                this.Get.classList.add("originMiddle")
            }
            this.K4e(t, i, e, s)
        }
        V4e(t) {
            t = !!t,
            self.assert(!this.xJe, "Should not start new dock ghost animation if already playing animation"),
            db.direction = t ? "reverse" : "normal",
            this.xJe = this.Get.animate(cb, db),
            this.xJe.onfinish = t => this.q4e()
        }
        k4e() {
            self.app.zmt() ? this.V4e(!1) : this.Get.style.opacity = ub
        }
        O4e() {
            this.z4e = !0,
            self.app.zmt() ? this.xJe ? this.xJe.playbackRate *= -1 : this.V4e(!0) : this.q4e()
        }
        q4e() {
            this.xJe = null,
            this.z4e && this.bx()
        }
        bx() {
            this.xJe = null,
            this.z4e = !1,
            this.jbi && this.Get && this.jbi.removeChild(this.Get),
            this.Get = null,
            this.jbi = null,
            lb.he(this)
        }
        K4e(t, i, e, s) {
            lb.Ge(t),
            lb.Ge(i),
            lb.Ge(e),
            lb.Ge(s),
            this.Get.style.left = `${t}px`,
            this.Get.style.top = `${i}px`,
            this.Get.style.width = `${e}px`,
            this.Get.style.height = `${s}px`
        }
    }
}
{
    const fb = self.t
      , pb = 1
      , mb = 2048
      , wb = new Set(["normal", "mask"]);
    let gb = new Map;
    const yb = {
        name: null,
        source: null,
        og: !1
    };
    fb.qs.O_ = class extends fb.Me {
        constructor(t, i, e, s, n) {
            fb.U(t, fb.qs.X4e),
            fb.Ge(i),
            fb.Ge(e),
            fb.Kq(s),
            fb.Kq(n),
            super(),
            this.ghs = t;
            const r = fb.qs.X4e.Od();
            this.Y4e = i,
            this.J4e = e,
            this.Z4e = i / r,
            this.Q4e = e / r,
            this.t5e = null,
            this.i0e = !1,
            this.i5e = null,
            this.g_t = null,
            this.e5e = !1,
            this.s5e = !1,
            this.rVt = "",
            this.SLt = "",
            this.cxs(s, n)
        }
        cxs(t, i) {
            if (this.rVt = t || "",
            this.SLt = i || "",
            this.e5e = !1,
            this.s5e = !1,
            this.g_t = new Promise(t => this.i5e = t),
            this.SLt) {
                let t = `${this.ghs.n5e()},${this.SLt}`;
                self.assert(!gb.has(t), "icon already cached"),
                gb.set(t, this)
            }
        }
        he() {
            if (!this.e5e) {
                if (this.e5e = !0,
                this.s5e = !1,
                this.ghs.r5e(this),
                this.SLt) {
                    let t = `${this.ghs.n5e()},${this.SLt}`;
                    gb.delete(t)
                }
                this.i0e = !1,
                this.i5e = null,
                this.g_t = null,
                this.rVt = "<removed>",
                this.SLt = ""
            }
        }
        h5e() {
            return this.n5e() <= self.app.T_()
        }
        o5e() {
            return this.n5e() > self.app.T_() && this.n5e() <= self.app.Gk()
        }
        a5e() {
            return this.n5e() > self.app.Gk()
        }
        pds() {
            return this.e5e
        }
        l5e() {
            return this.s5e
        }
        Vns() {
            return this.ghs
        }
        u5e() {
            return this.ghs.u5e()
        }
        c5e() {
            return this.ghs.c5e()
        }
        d5e() {
            return this.ghs.d5e()
        }
        f5e() {
            return this.ghs.yEe()
        }
        n5e() {
            return this.ghs.n5e()
        }
        p5e() {
            return this.Z4e
        }
        m5e() {
            return this.Q4e
        }
        w5e() {
            return this.ghs.w5e()
        }
        g5e() {
            return this.Y4e
        }
        y5e() {
            return this.J4e
        }
        b5e(t) {
            fb.Mw(t, fb.qs.pAe),
            this.t5e = t
        }
        RGe() {
            return this.t5e
        }
        S1t() {
            return this.i0e
        }
        U_() {
            this.i0e || (this.i0e = !0,
            this.i5e && (this.i5e(),
            this.i5e = null))
        }
        W7t() {
            return this.g_t
        }
        addEventListener(t, i, e) {
            return this.ghs.addEventListener(t, i, e)
        }
        removeEventListener(t, i, e) {
            return this.ghs.removeEventListener(t, i, e)
        }
        async v5e(t, i) {
            fb.zt(t),
            fb.Wat(i),
            this.ghs.S5e();
            try {
                if (fb.zk.ImageBitmap && !i.og) {
                    const e = await fb.Kl(t);
                    let s = null;
                    s = fb.zk.Qhs ? await createImageBitmap(e, {
                        premultiplyAlpha: "none"
                    }) : await createImageBitmap(e),
                    this.so(s, i)
                } else {
                    const e = await fb.yAs(t);
                    this.so(e, i)
                }
            } catch (i) {
                console.error(`Error updating icon from URL '${t}': `, i),
                this.s5e = !0
            } finally {
                this.ghs.x5e()
            }
        }
        so(t, i) {
            fb.cwi(t),
            fb.Wat(i),
            i && i.og && (t.width <= 0 || t.height <= 0) && (i.width = this.n5e(),
            i.height = this.n5e()),
            this.ghs.M5e(this, t, i)
        }
        async P_(t) {
            fb._D(t);
            const i = []
              , e = [];
            for (const s of t) {
                let t = null
                  , n = "normal";
                if (s instanceof fb.qs.O_)
                    t = s;
                else if (fb.Yq(s),
                t = s.icon,
                n = s.type,
                fb.U(t, fb.qs.O_),
                !wb.has(n))
                    throw new Error("invalid overlay icon type");
                if (t.n5e() !== this.n5e())
                    throw new Error("overlay icons must be same size");
                e.push(t.W7t()),
                i.push({
                    icon: t,
                    type: n
                })
            }
            await Promise.all(e);
            for (const t of i)
                this.E5e(t.icon, t.type)
        }
        E5e(t, i) {
            this.Vns().E5e(this, t, i)
        }
        static mAe(t, i, e) {
            fb.zt(t),
            fb.qs.O_.C5e(i),
            fb.Wat(e),
            e = Object.assign({}, yb, e);
            let s = gb.get(`${i},${t}`);
            if (s)
                return s;
            let n = fb.qs.T5e._5e(i, e.name, e.source || t);
            return n.v5e(t, {
                HJt: !0,
                og: e.og
            }),
            n
        }
        static y_(t, i, e) {
            fb.BM(t),
            fb.qs.O_.C5e(i),
            fb.Wat(e),
            e = Object.assign({}, yb, e);
            let s = fb.qs.T5e._5e(i, e.name, e.source);
            return t && s.so(t, {
                HJt: !0,
                og: e.og
            }),
            s
        }
        static C5e(t) {
            if (fb.Ge(t),
            t < pb || t > mb)
                throw new RangeError("invalid icon size")
        }
    }
}
{
    const bb = self.t
      , vb = self.assert;
    let Sb = NaN;
    const xb = 24
      , Mb = 48
      , Eb = 96
      , Cb = 128
      , _b = 256
      , Tb = 512
      , Ib = 1024
      , Pb = 2048
      , Gb = 50
      , Ab = 250
      , Rb = 500
      , kb = {
        HJt: !1,
        og: !1,
        width: 0,
        height: 0,
        I5e: !1
    };
    let Ob = new Set;
    bb.qs.X4e = class extends bb.Event.aG {
        constructor(t, i) {
            super(),
            bb.qs.O_.C5e(t),
            bb.Ge(i);
            const e = bb.qs.X4e.Od();
            this.P5e = t,
            this.G5e = Math.ceil(t * e),
            this.A5e = Math.floor(t * e),
            this.R5e = 2,
            this.k5e = 0,
            this.O5e = 0,
            this.D5e = i,
            this.xG = null,
            this.YG = null,
            this.F5e = !1,
            this.bhs = null,
            this.gEe = "",
            this.ott = !1,
            this.L5e = 0,
            this.B5e = -1,
            this.U5e = -1,
            this.N5e = () => {
                this.B5e = -1,
                this.j5e()
            }
            ,
            this.$5e = [],
            this.z5e = [],
            this.V5e = [],
            this.W5e = [],
            this.H5e = 0,
            this.K5e = 0,
            this.q5e = !1,
            this.P5e <= xb ? this.k5e = Cb : this.P5e <= Mb ? this.k5e = _b : this.P5e <= Eb ? this.k5e = Tb : this.k5e = Ib,
            this.k5e * e > Pb && (this.k5e = Math.floor(Pb / e));
            let s = this.k5e / this.P5e;
            this.O5e = Math.ceil((this.G5e + this.R5e) * s),
            Ob.add(this)
        }
        static Od() {
            return isNaN(Sb) && (Sb = self.devicePixelRatio),
            Sb
        }
        n5e() {
            return this.P5e
        }
        w5e() {
            return this.G5e
        }
        u5e() {
            return this.k5e
        }
        c5e() {
            return this.O5e / bb.qs.X4e.Od()
        }
        d5e() {
            return this.O5e
        }
        X5e() {
            return this.xG
        }
        Y5e() {
            return this.V5e.length - this.W5e.length
        }
        Sos() {
            return this.q5e && 0 === this.W5e.length
        }
        S5e() {
            this.L5e++
        }
        x5e() {
            if (this.L5e--,
            this.L5e < 0)
                throw new Error("too many pending icons removed")
        }
        j5e() {
            if (!this.xG)
                return;
            if (this.F5e || this.gEe && !this.ott)
                return;
            this.F5e = !0,
            this.ott = !1,
            bb.lw(this.z5e, this.$5e),
            bb.sc(this.$5e),
            this.U5e = Date.now();
            let t = this.gEe;
            bb.eUt(this.xG).then(t => (this.bhs = t,
            this.gEe = URL.createObjectURL(t),
            bb.yAs(this.gEe))).then(i => {
                this.F5e = !1,
                this.J5e(),
                t && URL.revokeObjectURL(t)
            }
            )
        }
        J5e() {
            for (let t of this.z5e)
                t.U_();
            bb.sc(this.z5e),
            this.dispatchEvent(new bb.Event("change")),
            this.ott && this.Z5e()
        }
        yEe() {
            return this.gEe
        }
        Z5e() {
            if (this.F5e || -1 !== this.B5e)
                return;
            let t = self.app.J1() && bb.kt.lA ? Ab : Rb;
            Date.now() - this.U5e >= t && (t = Gb),
            this.B5e = window.setTimeout(this.N5e, t)
        }
        Q5e() {
            if (!this.YG && (this.xG = document.createElement("canvas"),
            this.xG.width = this.O5e,
            this.xG.height = this.O5e,
            this.YG = this.xG.getContext("2d"),
            this.YG.imageSmoothingEnabled = !0,
            this.YG.imageSmoothingQuality = "high",
            !this.YG))
                throw new Error("failed to create 2d context")
        }
        t6e() {
            if (this.q5e)
                throw new Error("no icon spaces left");
            const t = this.G5e + this.R5e;
            this.H5e += t,
            this.H5e > this.O5e - t && (this.K5e += t,
            this.H5e = 0,
            this.K5e > this.O5e - t && (this.q5e = !0))
        }
        r5e(t) {
            if (bb.U(t, bb.qs.O_),
            t.Vns() !== this)
                throw new Error("icon from wrong sheet");
            vb(!this.W5e.includes(t), "icon already removed"),
            this.W5e.push(t),
            this.YG && this.YG.clearRect(t.g5e(), t.y5e(), this.G5e, this.G5e)
        }
        i6e(t, i) {
            if (bb.Kq(t),
            bb.Kq(i),
            this.Sos())
                throw new Error("icon sheet is already full");
            if (this.W5e.length) {
                let e = this.W5e.pop();
                return e.cxs(t, i),
                e
            }
            {
                let e = bb.v(bb.qs.O_, this, this.H5e, this.K5e, t, i);
                return this.V5e.push(e),
                this.t6e(),
                e
            }
        }
        M5e(t, i, e) {
            if (bb.U(t, bb.qs.O_),
            bb.cwi(i),
            bb.Wat(e),
            e = Object.assign({}, kb, e),
            t.pds())
                return;
            if (t.Vns() !== this)
                throw new Error("updating icon from wrong sheet");
            if (i instanceof Image && !i.complete)
                throw new Error("image is not complete");
            const s = i.width || e.width
              , n = i.height || e.height;
            if (!isFinite(s) || s <= 0 || !isFinite(n) || n <= 0)
                throw new Error("invalid size");
            let r, h;
            const o = bb.qs.X4e.Od();
            if (s < this.P5e && n < this.P5e && !e.og)
                r = s * o,
                h = n * o;
            else {
                let t = Math.max(s, n)
                  , i = this.A5e / t;
                r = Math.min(s * i, this.A5e),
                h = Math.min(n * i, this.A5e)
            }
            let a = Math.max(Math.floor((this.G5e - r) / 2), 0)
              , l = Math.max(Math.floor((this.G5e - h) / 2), 0)
              , u = t.g5e()
              , c = t.y5e();
            this.Q5e(),
            e.HJt || this.YG.clearRect(u, c, this.G5e, this.G5e),
            e.I5e && (i = bb.rUt(i, r, h)),
            this.YG.drawImage(i, u + a, c + l, r, h),
            this.$5e.push(t),
            this.ott = !0,
            this.Z5e()
        }
        E5e(t, i, e) {
            bb.U(t, bb.qs.O_),
            bb.U(i, bb.qs.O_),
            vb(t.Vns() === this, "icon from wrong sheet"),
            vb(t !== i, "icon and overlay are the same"),
            vb(t.n5e() === i.n5e(), "icon sizes must match"),
            bb.zt(e),
            this.Q5e();
            let s = this.w5e();
            const n = i.Vns();
            "mask" === e && (this.YG.globalCompositeOperation = "destination-out"),
            this.YG.drawImage(n.xG, i.g5e(), i.y5e(), s, s, t.g5e(), t.y5e(), s, s),
            "mask" === e && (this.YG.globalCompositeOperation = "source-over"),
            this.$5e.push(t),
            this.ott = !0,
            this.Z5e()
        }
        YZ() {
            let t = 0;
            return this.xG && (t += this.O5e * this.O5e * 4),
            this.bhs && (t += this.bhs.size),
            t
        }
        static all() {
            return Ob.values()
        }
    }
}
{
    const Db = self.t
      , Fb = new Map;
    let Lb = 0;
    Db.qs.T5e = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static e6e(t) {
            Db.qs.O_.C5e(t);
            let i = Fb.get(t);
            if (i) {
                for (let t of i)
                    if (!t.Sos())
                        return t;
                let e = Db.v(Db.qs.X4e, t, Lb++);
                return i.push(e),
                e
            }
            {
                let i = Db.v(Db.qs.X4e, t, Lb++);
                return Fb.set(t, [i]),
                i
            }
        }
        static _5e(t, i, e) {
            return Db.qs.O_.C5e(t),
            Db.Kq(i),
            Db.Kq(e),
            Db.qs.T5e.e6e(t).i6e(i, e)
        }
        static*s6e() {
            for (let t of Fb.values())
                yield*t
        }
    }
}
{
    const Bb = self.t;
    let Ub = [{
        opacity: 0
    }, {
        opacity: 1
    }];
    const Nb = {
        duration: 200,
        easing: "linear"
    }
      , jb = {
        icon: null,
        n6e: null,
        r6e: !1,
        ariaLabel: null
    };
    Bb.qs.kmt = class extends Bb.Me {
        constructor(t, i) {
            let e;
            if (super(),
            t instanceof Bb.qs.O_)
                e = Object.assign({}, jb),
                e.icon = t;
            else if ("number" == typeof t)
                e = Object.assign({}, jb),
                e.n6e = t;
            else {
                if (!Bb.$nt(t))
                    throw new TypeError("invalid parameter");
                e = Object.assign({}, jb, t)
            }
            this.X1t = null,
            this.P5e = 0,
            this.h6e = "",
            this.o6e = !!e.r6e,
            this.Get = document.createElement("ui-icon"),
            this.a6e = "",
            this.l6e = null,
            this.u6e = null,
            this.c6e = !1,
            this.d6e = !1,
            this.xJe = null,
            this.G2e = !0,
            this.f6e = t => this.p6e(),
            Bb.nke(e.n6e) ? (Bb.qs.O_.C5e(e.n6e),
            this.P5e = e.n6e) : this.m6e(e.icon),
            this.w6e(),
            this.p6e(),
            e.ariaLabel && (Bb.zt(e.ariaLabel),
            this.Get.setAttribute("aria-label", e.ariaLabel)),
            i && i.appendChild(this.Get)
        }
        he(t) {
            this.r5e(),
            this.f6e = null,
            this.u6e = null,
            t || Bb.qs.BW(this.Get),
            this.Get = null,
            Bb.he(this)
        }
        g6e(t) {
            const i = this.P5e;
            this.Get.parentElement.insertBefore(t, this.Get),
            this.he(),
            t.setAttribute("width", i),
            t.setAttribute("height", i)
        }
        NN(t) {
            if (Bb.qd(t),
            this.X1t)
                throw new Error("already got an icon");
            this.u6e = t,
            this.c6e = !0
        }
        $Jt() {
            if (!this.u6e)
                return;
            let t = this.u6e();
            Bb.Mw(t, Bb.qs.O_),
            t && (t.S1t() || (this.d6e = !0),
            this.CA(t))
        }
        jp() {
            return this.P5e
        }
        SYt() {
            return this.X1t
        }
        CA(t) {
            this.u6e = null,
            this.X1t !== t && (this.r5e(),
            this.m6e(t),
            this.w6e(),
            this.p6e())
        }
        Kyt(t) {
            if (this.Get.parentElement)
                return this.Get.parentElement !== t ? (Bb.qs.BW(this.Get),
                void t.appendChild(this.Get)) : void 0;
            t.appendChild(this.Get)
        }
        hk() {
            return this.Get
        }
        y6e(t) {
            t = !!t,
            this.o6e !== t && (this.o6e = t,
            this.w6e(!0))
        }
        b6e() {
            return this.o6e
        }
        x_(t) {
            t = !!t,
            this.G2e !== t && (this.G2e = t,
            Bb.qs.CD(this.Get, "hidden", !this.G2e))
        }
        Cj() {
            this.x_(!1)
        }
        Ej() {
            this.x_(!0)
        }
        sGt(t) {
            Bb.zt(t),
            this.h6e !== t && (this.h6e = t,
            this.w6e(!0),
            this.p6e())
        }
        m6e(t) {
            Bb.Mw(t, Bb.qs.O_),
            this.v6e(),
            this.X1t = t,
            this.X1t && (this.P5e = this.X1t.n5e(),
            this.X1t.addEventListener("change", this.f6e))
        }
        r5e() {
            this.X1t && (this.v6e(),
            this.X1t.removeEventListener("change", this.f6e),
            this.X1t = null)
        }
        S6e(t) {
            return Bb.Ge(t),
            this.h6e ? `calc(${t}px * var(${this.h6e}))` : `${t}px`
        }
        w6e(t) {
            if (!t && this.P5e === this.l6e)
                return;
            const i = this.S6e(this.P5e);
            this.Get.style.width = i,
            this.Get.style.height = i,
            this.o6e && (this.Get.style.borderRadius = this.P5e / 2 + "px"),
            this.l6e = this.P5e
        }
        p6e() {
            let t = this.a6e;
            this.X1t && this.X1t.S1t() ? (this.d6e && (this.x6e(),
            this.d6e = !1),
            t = `url("${this.X1t.f5e()}") ${this.S6e(-this.X1t.p5e())} ${this.S6e(-this.X1t.m5e())} / ${this.S6e(this.X1t.c5e())} ${this.S6e(this.X1t.c5e())} no-repeat`) : this.X1t || (t = ""),
            t !== this.a6e && (this.Get.style.background = t,
            this.a6e = t)
        }
        x6e() {
            Bb.zk.WRe && (this.xJe = this.Get.animate(Ub, Nb),
            this.xJe.onfinish = () => this.M6e())
        }
        v6e() {
            this.xJe && (this.xJe.cancel(),
            this.xJe = null)
        }
        M6e() {
            this.xJe = null
        }
    }
}
{
    const $b = self.t;
    $b.qs.pAe = class extends $b.Me {
        constructor(t, i, e) {
            super(),
            $b.U(t, $b.XYe),
            $b.Kq(i),
            $b.Yq(e),
            $b.Kq(e.name),
            $b.Kq(e.source),
            this.yAe = t,
            this.E6e = i || "",
            this.C6e = "",
            this._6e = null,
            this.T6e = null,
            this.rVt = e.name,
            this.SLt = e.source,
            this.mp = e.color,
            this.Xus = null,
            this.Yus = null,
            this.qus = null,
            this.I6e = new Map,
            this.P6e = null,
            this.G6e = !1,
            this.E6e || ($b.zt(e.A6e),
            this.C6e = e.A6e)
        }
        he() {
            this.Xus && this.Xus.he(),
            this.Yus && this.Yus.he(),
            this.qus && this.qus.he();
            for (const t of this.I6e.values())
                t.he();
            this.I6e.clear(),
            this.I6e = null,
            this.R6e(),
            this.Xus = null,
            this.Yus = null,
            this.qus = null,
            this.yAe = null,
            this.E6e = "",
            this.C6e = "",
            this._6e = null,
            this.T6e = null,
            this.rVt = "",
            this.P6e = null,
            $b.he(this)
        }
        k6e() {
            return this.rVt.endsWith("-color")
        }
        yAs() {
            return this.T6e ? Promise.resolve(this.T6e) : this.P6e ? this.P6e : this.G6e ? Promise.resolve(null) : (this.P6e = this.O6e(),
            this.P6e)
        }
        async O6e() {
            try {
                if (!this.C6e) {
                    const t = await self.app.D6e(this.E6e);
                    this.R6e(),
                    this.C6e = t
                }
                const t = $b.v($b.oT.Document);
                await t.MVe(this.C6e, "image/svg+xml"),
                this._6e = t.mT().Kbe(),
                await this.F6e();
                const i = new Blob([this.C6e],{
                    type: "image/svg+xml"
                })
                  , e = await $b.jv(i);
                return await $b._Ct( () => this.L6e(e))
            } catch (t) {
                return console.error("Error fetching icon: ", t),
                this.G6e = !0,
                this._6e = document.createElement("svg"),
                null
            }
        }
        R6e() {
            this.E6e.match(/^blob:.+$/) && URL.revokeObjectURL(this.E6e)
        }
        async F6e(t) {
            const i = this.mp || self.app.B6e();
            i && ("#000000" !== i || t) && await $b._Ct( () => {
                this._6e.setAttribute("fill", i),
                this._6e.hasAttribute("stroke") && "none" !== this._6e.getAttribute("stroke") && this._6e.setAttribute("stroke", i);
                const t = new XMLSerializer;
                this.C6e = t.serializeToString(this._6e.ownerDocument)
            }
            )
        }
        async Xn(t) {
            this.mp === t || this.k6e() || (this.mp = t,
            await this.mXe())
        }
        async mXe() {
            if (!this._6e || this.G6e)
                return;
            await this.F6e(!0);
            const t = new Blob([this.C6e],{
                type: "image/svg+xml"
            })
              , i = await $b.jv(t);
            this.T6e = i,
            this.U6e({
                HJt: !1,
                og: !0
            })
        }
        L6e(t) {
            return this.T6e = t,
            this.P6e = null,
            this.U6e({
                HJt: !0,
                og: !0
            }),
            this.T6e
        }
        U6e(t) {
            this.Xus && this.Xus.so(this.T6e, t),
            this.Yus && this.Yus.so(this.T6e, t),
            this.qus && this.qus.so(this.T6e, t);
            for (const i of this.I6e.values())
                i.so(this.T6e, t)
        }
        xA() {
            return this.Xus || (this.Xus = $b.qs.O_.y_(this.T6e, this.yAe.T_(), {
                name: this.rVt,
                source: this.SLt,
                og: !0
            }),
            this.Xus.b5e(this),
            $b.VTe() && this.yAs()),
            this.Xus
        }
        uj() {
            return this.Yus || (this.Yus = $b.qs.O_.y_(this.T6e, this.yAe.Gk(), {
                name: this.rVt,
                source: this.SLt,
                og: !0
            }),
            this.Yus.b5e(this),
            $b.VTe() && this.yAs()),
            this.Yus
        }
        nus() {
            return this.qus || (this.qus = $b.qs.O_.y_(this.T6e, this.yAe.BJt(), {
                name: this.rVt,
                source: this.SLt,
                og: !0
            }),
            this.qus.b5e(this),
            $b.VTe() && this.yAs()),
            this.qus
        }
        SYt(t) {
            $b.Ge(t),
            self.assert(t > 0, "custom icon size must be larger than 0");
            const i = t.toString();
            if (this.I6e.has(i))
                return this.I6e.get(i);
            const e = $b.qs.O_.y_(this.T6e, t, {
                name: this.rVt,
                source: this.SLt,
                og: !0
            });
            return e.b5e(this),
            $b.VTe() && this.yAs(),
            this.I6e.set(i, e),
            e
        }
        async N6e() {
            return await this.yAs(),
            this._6e
        }
        async pat() {
            const t = await this.N6e();
            return t ? t.cloneNode(!0) : null
        }
    }
}
self.t.qs.Jj = {};
{
    const zb = self.t
      , Vb = [{
        opacity: "0"
    }, {
        opacity: "1"
    }]
      , Wb = zb.M9s.lVs("slow-animations") ? 3e3 : 200
      , Hb = {
        duration: Wb,
        easing: "ease-out"
    }
      , Kb = {
        duration: Wb,
        easing: "ease-out",
        direction: "reverse"
    };
    let qb = null
      , Xb = null
      , Yb = !1
      , Jb = !1
      , Zb = null
      , Qb = 0
      , tv = -1;
    function iv() {
        -1 !== tv && (self.clearTimeout(tv),
        tv = -1)
    }
    document.addEventListener("visibilitychange", () => {
        Xb && (Xb.cancel(),
        zb.qs.cqe.PZe())
    }
    ),
    zb.qs.cqe = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static Ej(t) {
            if (Zb = document,
            ++Qb,
            iv(),
            Xb)
                return Jb && (Jb = !1,
                Yb = !0,
                Xb.playbackRate *= -1),
                void (window.C3_IsPopupWindow || zb.qs.oYe.xYe(!0));
            qb || (window.C3_IsPopupWindow || zb.qs.oYe.xYe(!0),
            qb = zb.qs.lk("div", Zb.body, null, "c3-dimmer"),
            Yb = !0,
            zb.zk.R$i || qb.setAttribute("polyfill", ""),
            self.app.zmt() ? (Xb = qb.animate(Vb, Hb),
            Xb.onfinish = zb.qs.cqe.PZe) : zb.qs.cqe.PZe())
        }
        static Cj() {
            0 !== Qb && (--Qb,
            Qb > 0 || qb && (window.C3_IsPopupWindow || zb.qs.oYe.xYe(!1),
            iv(),
            tv = self.setTimeout( () => {
                tv = -1,
                zb.qs.cqe.PZe()
            }
            , 2 * Wb),
            Xb ? Yb && (Jb = !0,
            Yb = !1,
            Xb.playbackRate *= -1) : (Jb = !0,
            self.app.zmt() ? (Xb = qb.animate(Vb, Kb),
            Xb.onfinish = zb.qs.cqe.PZe) : zb.qs.cqe.PZe())))
        }
        static j6e() {
            qb && (qb.style.backgroundColor = "rgba(128, 0, 0, 0.4)")
        }
        static PZe() {
            Jb && (iv(),
            zb.qs.BW(qb),
            qb = null),
            Xb = null,
            Zb = null,
            Yb = !1,
            Jb = !1
        }
    }
}
{
    const ev = self.t
      , sv = [{
        opacity: "0"
    }, {
        opacity: "1"
    }]
      , nv = ev.M9s.lVs("slow-animations") ? 3e3 : 200
      , rv = 350
      , hv = {
        duration: nv,
        easing: "ease-out"
    }
      , ov = {
        duration: nv,
        easing: "ease-out",
        direction: "reverse"
    }
      , av = {
        message: null,
        $6e: "outside-auto",
        z6e: "",
        V6e: 12,
        W6e: !0,
        H6e: !0,
        K6e: !1,
        q6e: !1
    };
    let lv = "outside-auto"
      , uv = ""
      , cv = 12
      , dv = !0
      , fv = !0
      , pv = !1
      , mv = !1;
    const wv = 6;
    let gv = null
      , yv = null
      , bv = null
      , vv = null
      , Sv = null
      , xv = null
      , Mv = null
      , Ev = null
      , Cv = null
      , _v = null
      , Tv = null
      , Iv = null
      , Pv = !1
      , Gv = !1;
    document.addEventListener("visibilitychange", () => {
        Iv && (Iv.cancel(),
        ev.qs.ySe.PZe())
    }
    ),
    window.addEventListener("resize", async () => {
        gv && vv && (await ev.Mme(),
        ev.qs.ySe.X6e())
    }
    ),
    ev.qs.HY.addEventListener("dialogpositioningchange", () => {
        yv && ev.qs.ySe.X6e()
    }
    );
    const Av = new Set(["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", " ", "PageUp", "PageDown", "Home", "End"]);
    function Rv(t) {
        ("Tab" === t.key || dv && Av.has(t.key)) && (t.preventDefault(),
        t.stopPropagation())
    }
    function kv(t) {
        const i = ev.Rect.lvt(gv.getBoundingClientRect());
        "#document" !== t.target.nodeName && (i.a8(t.clientX, t.clientY) || t.target === Ev || ev.vX(t.target, Ev) || ev.jgt(t.target, ["ui-menu"]) || ev.Lgt(t.target, ["autoCompleteWrap"]) || ev.Lgt(t.target, ["construct-monaco-overlay"])) || (t.preventDefault(),
        t.stopPropagation())
    }
    ev.qs.ySe = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static Ej(t, i) {
            if (ev.zlt(t),
            gv = t,
            i = Object.assign({}, av, i),
            cv = i.V6e,
            dv = !!i.W6e,
            fv = !!i.H6e,
            pv = !!i.K6e,
            mv = !!i.q6e,
            bv = ev.Yke(gv),
            bv === document.body ? bv = null : (ev.qs.WB(gv, bv),
            dv && (bv.addEventListener("scroll", ev.qs.Lzt, {
                capture: !0,
                passive: !1
            }),
            bv.addEventListener("wheel", ev.qs.Lzt, {
                capture: !0,
                passive: !1
            }))),
            window.addEventListener("pointerdown", kv, {
                capture: !0,
                passive: !1
            }),
            window.addEventListener("pointermove", kv, {
                capture: !0,
                passive: !1
            }),
            window.addEventListener("pointerup", kv, {
                capture: !0,
                passive: !1
            }),
            mv && window.addEventListener("contextmenu", ev.qs.ck, {
                capture: !0
            }),
            pv ? ev.qs.HY.KYe(!1) : fv && ev.qs.HY.WYe(!1),
            yv = ev.Edi(gv, "dialog"),
            vv && (yv ? yv.appendChild(vv) : document.body.appendChild(vv)),
            Iv && Gv && (Gv = !1,
            Iv.playbackRate *= -1),
            Pv = !0,
            !vv) {
                vv = ev.qs.lk("div", yv || document.body, null, "c3-dimmer-cutout-container");
                for (let t = 0; t < 4; ++t)
                    ev.qs.lk("div", vv, null, "c3-dimmer-cutout-filler");
                Sv = ev.qs.lk("div", vv, null, "c3-dimmer-cutout-gap");
                for (let t = 0; t < 4; ++t)
                    ev.qs.lk("div", vv, null, "c3-dimmer-cutout-filler");
                for (let t = 0; t < 4; ++t)
                    ev.qs.lk("div", Sv, null, "c3-dimmer-gap-filler");
                ev.qs.lk("div", Sv, null, "c3-dimmer-gap-gap");
                for (let t = 0; t < 4; ++t)
                    ev.qs.lk("div", Sv, null, "c3-dimmer-gap-filler");
                xv = ev.qs.lk("div", vv, null, "c3-dimmer-cutout-outline"),
                Mv = ev.qs.lk("div", vv, null, "c3-dimmer-smallwindowmessage"),
                Mv.textContent = self.lang("tours.window-too-small")
            }
            i.message ? (lv = i.$6e,
            uv = i.z6e,
            Ev || (Ev = ev.qs.lk("div", vv, null, "c3-dimmer-cutout-message"),
            Cv = ev.qs.lk("div", Ev),
            _v = ev.qs.lk("div", Ev),
            Tv = ev.qs.lk("div", vv, null, "c3-dimmer-cutout-message-arrow")),
            ev.odt(Cv, i.message),
            _v.className = "",
            ev.qs.BYt(_v)) : (ev.qs.BW(Ev),
            ev.qs.BW(Tv),
            Ev = null,
            Cv = null,
            _v = null,
            Tv = null),
            ev.qs.ySe.X6e(),
            requestAnimationFrame( () => ev.qs.ySe.X6e()),
            ev.qs.iA.hYe(!1),
            window.addEventListener("keydown", Rv, !0),
            self.app.zmt() ? Iv || (Iv = vv.animate(sv, hv),
            Iv.onfinish = ev.qs.ySe.PZe) : ev.qs.ySe.PZe()
        }
        static Cj() {
            window.removeEventListener("pointerdown", kv, {
                capture: !0,
                passive: !1
            }),
            window.removeEventListener("pointermove", kv, {
                capture: !0,
                passive: !1
            }),
            window.removeEventListener("pointerup", kv, {
                capture: !0,
                passive: !1
            }),
            mv && window.removeEventListener("contextmenu", ev.qs.ck, {
                capture: !0
            }),
            pv ? ev.qs.HY.KYe(!0) : fv && ev.qs.HY.WYe(!0),
            ev.qs.iA.hYe(!0),
            window.removeEventListener("keydown", Rv, !0),
            bv && (dv && (bv.removeEventListener("scroll", ev.qs.Lzt, {
                capture: !0,
                passive: !1
            }),
            bv.removeEventListener("wheel", ev.qs.Lzt, {
                capture: !0,
                passive: !1
            })),
            bv = null),
            gv = null,
            yv = null,
            ev.qs.BW(Ev),
            ev.qs.BW(Tv),
            Ev = null,
            Cv = null,
            _v = null,
            Tv = null,
            Iv ? Pv && (Gv = !0,
            Pv = !1,
            Iv.playbackRate *= -1) : (Gv = !0,
            self.app.zmt() && vv ? (Iv = vv.animate(sv, ov),
            Iv.onfinish = ev.qs.ySe.PZe) : ev.qs.ySe.PZe())
        }
        static PZe() {
            Gv ? (ev.qs.BW(vv),
            vv = null,
            xv = null,
            Mv = null) : Pv && gv && gv.focus(),
            Iv = null,
            Pv = !1,
            Gv = !1
        }
        static X6e() {
            if (!gv)
                return;
            ev.qs.WB(gv),
            gv.focus();
            const t = ev.Rect.lvt(gv.getBoundingClientRect())
              , i = ev.v(ev.Rect, 0, 0, 0, 0);
            if (yv) {
                const t = ev.qs.Ys.lZe(yv)
                  , e = t.uge();
                i.set(-t._a() - e, -t.Da() - e, Math.min(t._a() + t.ns() - window.innerWidth, 0) + e, Math.min(t.Da() + t.Kn() - window.innerHeight, 0) + e)
            }
            ev.qs.ySe.Y6e(t, i)
        }
        static Y6e(t, i) {
            ev.U(t, ev.Rect),
            ev.U(i, ev.Rect);
            const e = window.innerHeight < rv
              , s = cv
              , n = wv;
            let r = cv
              , h = cv
              , o = t.Kr() - s
              , a = t.width() + 2 * s;
            o < 0 && (h = Math.max(h + o, 0),
            a = Math.max(a + o, 0),
            o = 0);
            let l = t.Zr() - s
              , u = t.height() + 2 * s
              , c = "1fr";
            l < 0 && (r += l,
            u += l,
            l = 0),
            e && (o = 0,
            a = 0,
            l = 0,
            u = 0),
            "WebKit" === ev.kt.NRe && (c = window.innerHeight - u - l + "px"),
            vv.style.gridTemplateColumns = `${o}px ${a}px 1fr`,
            vv.style.gridTemplateRows = `${l}px ${u}px ${c}`,
            Sv.style.gridTemplateColumns = `${h}px 1fr ${s}px`,
            Sv.style.gridTemplateRows = `${r}px 1fr ${s}px`;
            const d = t.Kr() - s - n
              , f = t.Zr() - s - n;
            if (xv.style.left = d + "px",
            xv.style.top = f + "px",
            xv.style.width = t.width() + 2 * s + 2 * n + "px",
            xv.style.height = t.height() + 2 * s + 2 * n + "px",
            xv.style.display = e ? "none" : "",
            Mv.style.display = e ? "" : "none",
            vv.style.left = (i ? i.Kr() : 0) + "px",
            vv.style.top = (i ? i.Zr() : 0) + "px",
            vv.style.right = (i ? i.gl() : 0) + "px",
            vv.style.bottom = (i ? i.wl() : 0) + "px",
            Ev && (Ev.style.display = e ? "none" : "",
            Tv.style.display = e ? "none" : "",
            !e))
                if ("outside-auto" === lv)
                    ev.qs.ySe.J6e(t);
                else {
                    if ("screen-bottom" !== lv)
                        throw new Error("invalid message positioning");
                    ev.qs.ySe.Z6e()
                }
        }
        static J6e(t) {
            const i = ev.v(ev.Rect, Math.max(t.Kr(), 0), Math.max(t.Zr(), 0), Math.min(t.gl(), window.innerWidth), Math.min(t.wl(), window.innerHeight))
              , e = cv
              , s = wv
              , n = window.innerWidth
              , r = window.innerHeight
              , h = [];
            "left" !== uv && h.push([i.Kr(), "left"]),
            "top" !== uv && h.push([i.Zr(), "top"]),
            "right" !== uv && h.push([n - i.gl(), "right"]),
            "bottom" !== uv && h.push([r - i.wl(), "bottom"]),
            h.sort( (t, i) => i[0] - t[0]);
            const o = h[0][1];
            Ev.style.left = "0px",
            Ev.style.top = "0px",
            Ev.style.width = "",
            Ev.style.maxHeight = "";
            let a = Ev.getBoundingClientRect();
            const l = 2 * (e + s) + 10;
            let u = 0
              , c = a.width
              , d = 0
              , f = r - 10;
            if ("left" === o || "right" === o) {
                if ("left" === o) {
                    const t = i.Kr() - l;
                    u = Math.max(5, t - a.width),
                    c = t - u
                } else
                    "right" === o && (u = i.gl() + l,
                    c = Math.min(c, n - 5 - u));
                Ev.style.width = c + "px",
                a = Ev.getBoundingClientRect();
                const t = Math.min(a.height, f);
                d = ev.Ne(i.yl() - t / 2, 5, r - 5 - t)
            } else {
                if ("top" === o) {
                    const t = i.Zr() - l;
                    d = Math.max(5, t - a.height),
                    f = t - d
                } else
                    "bottom" === o && (d = i.wl() + l,
                    f = Math.min(f, r - 5 - d));
                c = Math.min(a.width, n - 10),
                u = ev.Ne(i.bl() - c / 2, 5, n - 5 - c)
            }
            Ev.style.left = u + "px",
            Ev.style.top = d + "px",
            Ev.style.width = c + "px",
            Ev.style.maxHeight = f + "px";
            const p = ev.Rect.lvt(Ev.getBoundingClientRect())
              , m = 12;
            Tv.className = "c3-dimmer-cutout-message-arrow " + o;
            let w = 0
              , g = 0;
            "left" === o ? (w = p.gl(),
            g = i.yl() - m) : "right" === o ? (w = p.Kr() - m,
            g = i.yl() - m) : "top" === o ? (w = i.bl() - m,
            g = p.wl()) : "bottom" === o && (w = i.bl() - m,
            g = p.Zr() - m),
            Tv.style.display = "",
            Tv.style.left = w + "px",
            Tv.style.top = g + "px"
        }
        static Z6e() {
            Tv.style.display = "none",
            Ev.style.left = "0px",
            Ev.style.top = "0px",
            Ev.style.width = "",
            Ev.style.maxHeight = "10em";
            const t = Ev.getBoundingClientRect();
            Ev.style.left = window.innerWidth / 2 - t.width / 2 + "px",
            Ev.style.top = window.innerHeight - t.height - 25 + "px"
        }
        static Bj() {
            return !!gv
        }
        static bSe() {
            return vv
        }
        static Q6e() {
            return _v
        }
    }
}
{
    const Ov = self.t;
    Ov.qs.Jj.Sfe = class extends Ov.Me {
        constructor(t, i, e, s) {
            Ov.U(t, Ov.qs.Jj.HWt),
            Ov.zt(i),
            Ov.Kq(e),
            super(),
            this.WWt = t,
            this.rVt = i,
            this.Eos = e,
            this.hVt = s,
            this.phs = this.WWt.t8e(),
            this._Wt = !0,
            this.cn = !1,
            this.i8e = "",
            this.Get = Ov.qs.lk("ui-proprow", this.WWt.e8e()),
            this.aVi = t => this.OW(t),
            this.Get.addEventListener("contextmenu", this.aVi)
        }
        LUt() {
            this.cn = !0,
            this.WWt.s8e(this),
            this.Get.removeEventListener("contextmenu", this.aVi),
            this.aVi = null,
            Ov.qs.BW(this.Get),
            this.Get = null,
            this.WWt = null,
            Ov.he(this)
        }
        OW(t) {
            this.WWt.fgs("contextmenu", this, t)
        }
        n8e() {
            this.WWt.r8e(this)
        }
        dn() {
            return this.cn
        }
        Tgt() {}
        h8e() {
            let t = 0
              , i = this.hVt;
            for (; i; )
                ++t,
                i = i.hVt;
            return t
        }
        vte() {
            return this.WWt
        }
        bF() {
            return this.hVt
        }
        Fa() {
            return this.rVt
        }
        dj() {
            return this.Eos
        }
        Pte() {
            return this.Get
        }
        vR() {
            return this.phs
        }
        Ope() {
            return !1
        }
        Vie(t) {
            Ov.zt(t),
            this.i8e = t
        }
        o8e() {
            return this.i8e
        }
        OB() {
            return !0
        }
        a8e(t, i) {
            if (t = !!t,
            !(i = !!i) && this.WWt.l8e() && this.WWt.u8e(),
            t && !this._Wt)
                if (this._Wt = !0,
                i)
                    this.WWt.c8e(this);
                else {
                    this.Get.removeAttribute("collapsed");
                    let t = this.WWt.d8e();
                    t && t()
                }
            else if (!t && this._Wt)
                if (this._Wt = !1,
                i)
                    this.WWt.f8e(this);
                else {
                    this.Get.setAttribute("collapsed", "");
                    let t = this.WWt.d8e();
                    t && t()
                }
        }
        Cmt() {
            let t = this.hVt;
            for (; t; ) {
                if (!t.OB())
                    return !1;
                t = t.hVt
            }
            return !0
        }
        aZ() {
            return !0
        }
        p8e() {}
        ofe() {}
        Uht() {}
        kH() {}
        QL() {}
        tU(t) {}
    }
}
{
    const Dv = self.t;
    Dv.qs.Jj.m8e = class extends Dv.qs.Jj.Sfe {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.VSt = Dv.qs.lk("ui-propname", this.Get);
            let n = this.h8e();
            n > 0 && this.VSt.setAttribute("level" + n, ""),
            this.w8e = t => {
                t.button === Dv.f1.e5 && t.isPrimary && (this.WWt.bq(this) && t.preventDefault(),
                this.n8e())
            }
            ,
            this.VSt.addEventListener("pointerdown", this.w8e),
            this.wvt = Dv.qs.lk("div", this.VSt, null, "propname-wrap"),
            this.pCe = Dv.qs.lk("label", this.wvt, null, "propname-label"),
            this.pCe.textContent = this.rVt,
            this.pCe.setAttribute("for", this.phs),
            this.g8e = Dv.qs.lk("ui-propvalue", this.Get),
            this.C1 = !0,
            this.Bd = null
        }
        LUt() {
            this.VSt.removeEventListener("pointerdown", this.w8e),
            this.w8e = null,
            Dv.qs.BW(this.pCe),
            this.pCe = null,
            Dv.qs.BW(this.wvt),
            this.wvt = null,
            Dv.qs.BW(this.VSt),
            this.VSt = null,
            Dv.qs.BW(this.g8e),
            this.g8e = null,
            super.LUt()
        }
        n8e() {
            super.n8e(),
            this.WB()
        }
        WB() {
            this.WWt.Bwt(this)
        }
        Fie(t) {
            return this.Bd = t,
            this
        }
        Pp() {
            return this.Bd
        }
        Ope() {
            return !0
        }
        y8e() {
            return this.VSt
        }
        b8e() {
            return this.g8e
        }
        _K(t) {
            t = !!t,
            this.C1 !== t && (Dv.qs.CD(this.pCe, "disabled", !t),
            Dv.qs.CD(this.g8e, "disabled", !t),
            t || this.WWt.s8e(this),
            this.C1 = t,
            this.v8e(t))
        }
        aZ() {
            return this.C1
        }
        v8e(t) {}
        *Pfe() {}
        S8e() {
            return this.WWt.x8e(this)
        }
    }
}
{
    const Fv = self.t;
    let Lv = null;
    const Bv = new Map([["text", "text"], ["integer", "number"], ["float", "number"], ["percent", "text"], ["angle", "text"], ["custom-numeric", "text"], ["email", "email"], ["password", "password"], ["tel", "tel"], ["url", "url"]]);
    Fv.qs.Jj.M8e = class extends Fv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r, h, o, a) {
            if (super(t, i, e, n),
            Fv.Kq(s),
            Fv.X_t(r),
            Fv.X_t(h),
            Fv.X_t(o),
            s = s || "text",
            !Bv.has(s))
                throw new Error(`invalid InputProperty type '${s}'`);
            this.lVt = s,
            this.jet = Fv.qs.lk("input", this.g8e),
            this.jet.id = this.vR(),
            this.E8e = !0;
            let l = Bv.get(this.lVt);
            this.$Vs() && this.C8e() && (l = "text"),
            this.jet.type = l,
            "text" === l && this.jet.setAttribute("spellcheck", "false"),
            this.$Vs() && this.jet.setAttribute("numeric", ""),
            this.jet.setAttribute("autocomplete", "off"),
            this._8e = r,
            this.T8e = h,
            this.I8e = o,
            this.P8e = this.WWt.G8e(),
            this.A8e = !1,
            this.R8e = a,
            this.k8e = !1,
            this.O8e = null,
            this.KKs = null,
            this.D8e = !1,
            this.F8e = !0,
            this.L8e = !1,
            this.B8e = !1,
            this.U8e = !1,
            this.N8e = NaN,
            this.j8e = !1,
            this.$8e = NaN,
            this.z8e = () => !0,
            this.V8e = () => !0,
            this.W8e = !0,
            this.H8e = 6,
            this.K8e = "",
            this.q8e = !1,
            this.X8e = "",
            this.Y8e = t => this.J8e(),
            this.jet.addEventListener("change", this.Y8e),
            this.Z8e = t => {
                if (Fv.qs.RW.d4e())
                    return t.preventDefault(),
                    void this.jet.blur();
                this.n8e(),
                this.F8e = !1,
                this.WWt.Q8e( () => {
                    this.jet && this.WB()
                }
                )
            }
            ,
            this.jet.addEventListener("focus", this.Z8e),
            this.t7e = t => {
                this.WWt.s8e(this),
                this.F8e = !0,
                this.L8e = !1,
                this.i7e() && (this.WWt.vee(this),
                this.KKs = this.e7e())
            }
            ,
            this.jet.addEventListener("blur", this.t7e),
            this.s7e = -1,
            this.n7e = () => {
                if (this.Kft)
                    return;
                const {value: t} = this.r7e();
                t !== this.O8e && (this.B8e || (this.Clt(t),
                this.B8e = !0),
                this.A8e = !0,
                this.J8e(t),
                this.A8e = !1),
                this.s7e = requestAnimationFrame(this.n7e)
            }
            ,
            this.h7e = () => {
                this.F8e && (this.L8e = !0,
                this.F8e = !1),
                this.o7e() && -1 === this.s7e && (this.B8e = !1,
                this.s7e = requestAnimationFrame(this.n7e),
                this.jet.ownerDocument.addEventListener("pointerup", this.a7e),
                this.jet.ownerDocument.addEventListener("pointercancel", this.l7e))
            }
            ,
            this.jet.addEventListener("pointerdown", this.h7e),
            this.qG = -1,
            this.u7e = t => {
                this.L8e && (this.L8e = !1,
                this.qG = requestAnimationFrame( () => {
                    this.jet && this.jet.select(),
                    this.qG = -1
                }
                ))
            }
            ,
            this.jet.addEventListener("pointerup", this.u7e),
            this.c7e = t => {
                this.L8e = !0,
                this.F8e = !1,
                cancelAnimationFrame(this.qG),
                this.qG = -1
            }
            ,
            this.jet.addEventListener("pointercancel", this.c7e),
            this.a7e = null,
            this.l7e = null,
            this.d7e = !0,
            this.f7e = t => {
                t.preventDefault(),
                this.d7e && this.bwt(t.clientX, t.clientY)
            }
            ,
            this.jet.addEventListener("dragstart", this.f7e),
            this.p7e = t => this.FP(t),
            this.jet.addEventListener("keydown", this.p7e),
            this.Mz = null,
            this.Oz = null,
            this.Kft = !1,
            this.GLi = 0,
            this.CLi = 0,
            this.m7e = 0,
            this.w7e = 1,
            this.$Vs() && (this.Mz = t => this.Gz(t),
            this.Oz = t => this.Cz(t),
            this.a7e = t => {
                -1 !== this.s7e && (cancelAnimationFrame(this.s7e),
                this.s7e = -1),
                this.jet.ownerDocument.removeEventListener("pointerup", this.a7e),
                this.jet.ownerDocument.removeEventListener("pointercancel", this.l7e)
            }
            ,
            this.l7e = t => {
                this.Kft = !1,
                Fv.qs.SH.CH(Lv),
                Lv = null,
                cancelAnimationFrame(this.s7e),
                this.s7e = -1,
                this.jet.ownerDocument.removeEventListener("pointerup", this.a7e),
                this.jet.ownerDocument.removeEventListener("pointercancel", this.l7e),
                this.jet.ownerDocument.removeEventListener("pointermove", this.Mz),
                this.jet.ownerDocument.removeEventListener("pointerup", this.Oz)
            }
            ),
            this._8e && (this.O8e = this.e7e(),
            this.KKs = this.O8e,
            this.g7e(this.O8e))
        }
        e7e() {
            return this._8e ? this.R8e ? this.WWt.y7e(this._8e, this) : this._8e(this) : null
        }
        b7e(t) {
            this.T8e && (this.R8e ? this.WWt.v7e(this.T8e, t, this, this.O8e) : this.T8e(t, this, this.O8e))
        }
        Clt(t) {
            this.P8e && this.P8e(this.Fa(), t)
        }
        i7e() {
            let t;
            if (this.$Vs() && Fv.Go(this.KKs)) {
                let i, e, s, n;
                if ("integer" === this.lVt ? (t = parseInt(this.jet.value),
                i = this.j8e,
                e = this.U8e,
                s = this.N8e,
                n = this.$8e) : "float" === this.lVt ? (t = parseFloat(this.jet.value),
                i = this.j8e,
                e = this.U8e,
                s = this.N8e,
                n = this.$8e) : "percent" === this.lVt ? (t = parseFloat(this.jet.value) / 100,
                i = !0,
                e = !0,
                s = Fv.Go(this.N8e) ? this.N8e : 0,
                n = Fv.Go(this.$8e) ? this.$8e : 1) : "angle" === this.lVt || "custom-numeric" === this.lVt ? (t = parseFloat(this.jet.value),
                i = !0,
                e = !0,
                s = Fv.Go(this.N8e) ? this.N8e : 0,
                n = Fv.Go(this.$8e) ? this.$8e : 360) : "custom-numeric" === this.lVt && (t = parseFloat(this.jet.value),
                i = this.j8e,
                e = this.U8e,
                s = this.N8e,
                n = this.$8e),
                this.z8e() && i && t < s && this.KKs === s)
                    return !1;
                if (this.V8e() && e && t > n && this.KKs === n)
                    return !1;
                if (t === this.KKs)
                    return !1
            } else {
                if (Fv.fO(this.KKs))
                    return !1;
                if (this.jet.value === this.KKs)
                    return !1
            }
            return !0
        }
        g7e(t) {
            this.D8e = !0,
            this.S7e(t),
            this.D8e = !1
        }
        LUt() {
            -1 !== this.s7e && cancelAnimationFrame(this.s7e),
            this.n7e = null,
            this._8e = null,
            this.T8e = null,
            this.I8e = null,
            this.P8e = null,
            this.O8e = null,
            this.KKs = null,
            this.$Vs() && (this.jet.ownerDocument.removeEventListener("pointermove", this.Mz),
            this.Mz = null,
            this.jet.ownerDocument.removeEventListener("pointerup", this.Oz),
            this.Oz = null,
            this.jet.ownerDocument.removeEventListener("pointerup", this.a7e),
            this.a7e = null,
            this.jet.ownerDocument.removeEventListener("pointercancel", this.l7e),
            this.l7e = null),
            this.jet.removeEventListener("keydown", this.p7e),
            this.p7e = null,
            this.jet.removeEventListener("dragstart", this.f7e),
            this.f7e = null,
            this.jet.removeEventListener("change", this.Y8e),
            this.Y8e = null,
            this.jet.removeEventListener("blur", this.t7e),
            this.t7e = null,
            this.jet.removeEventListener("focus", this.Z8e),
            this.Z8e = null,
            this.jet.removeEventListener("pointerdown", this.h7e),
            this.h7e = null,
            this.jet.removeEventListener("pointerup", this.u7e),
            this.u7e = null,
            this.jet.removeEventListener("pointercancel", this.c7e),
            this.c7e = null,
            Fv.qs.BW(this.jet),
            this.jet = null,
            super.LUt()
        }
        Xie() {
            return this.k8e = !0,
            this
        }
        x7e() {
            return this.k8e
        }
        $Vs() {
            return "integer" === this.lVt || "float" === this.lVt || "percent" === this.lVt || "angle" === this.lVt || "custom-numeric" === this.lVt
        }
        o7e() {
            return "integer" === this.lVt || "float" === this.lVt
        }
        gne(t) {
            Fv.Ge(t),
            this.w7e = t
        }
        vhe(t) {
            return this.d7e = !!t,
            this
        }
        YWt(t) {
            if (Fv.Ge(t),
            !this.$Vs())
                throw new Error("cannot set minimum value on this property type");
            if ("integer" === this.lVt && (t = Math.floor(t)),
            this.j8e && t > this.$8e)
                throw new Error("cannot set a minimum value greater than the maximum value");
            return this.U8e = !0,
            this.N8e = t,
            this.jet.setAttribute("min", t.toString()),
            this
        }
        Boe(t) {
            if (Fv.Ge(t),
            !this.$Vs())
                throw new Error("cannot set maximum value on this property type");
            if ("integer" === this.lVt && (t = Math.floor(t)),
            this.U8e && t < this.N8e)
                throw new Error("cannot set a maximum value less than the minimum value");
            return this.j8e = !0,
            this.$8e = t,
            this.jet.setAttribute("max", t.toString()),
            this
        }
        rse(t, i) {
            if (Fv.Ge(t),
            Fv.Ge(i),
            !this.$Vs())
                throw new Error("cannot set minimum/maximum value on this property type");
            if (i < t)
                throw new Error("cannot set a maximum value less than the minimum value");
            return this.j8e = !1,
            this.YWt(t),
            this.U8e = !1,
            this.Boe(i),
            this.U8e = !0,
            this.j8e = !0,
            this
        }
        eoe(t) {
            return Fv.qd(t),
            this.z8e = t,
            this
        }
        Yie(t) {
            return Fv.qd(t),
            this.V8e = t,
            this
        }
        joe(t, i) {
            if (t) {
                if (Fv.Ge(i),
                (i = Math.floor(i)) < 0 || i > 20)
                    throw new Error("invalid rounding digit count");
                if ("float" !== this.lVt)
                    throw new Error("can only round 'float' input type");
                this.H8e = i
            }
            this.W8e = !!t,
            this.O8e = null,
            this.ofe()
        }
        M7e(t) {
            if (Fv.Ge(t),
            t = Math.floor(t),
            this.$Vs())
                throw new Error("cannot set a max length on this property type");
            return t < 0 ? this.jet.removeAttribute("maxlength") : this.jet.setAttribute("maxlength", t.toString()),
            this
        }
        Nte(t) {
            if (Fv.zt(t),
            this.$Vs())
                throw new Error("cannot set a placeholder on this property type");
            return this.K8e = t,
            this.q8e || this.jet.setAttribute("placeholder", t),
            this
        }
        E7e() {
            this.q8e && (this.K8e ? this.jet.setAttribute("placeholder", this.K8e) : this.jet.removeAttribute("placeholder"),
            this.q8e = !1)
        }
        C8e() {
            return this.E8e && Fv.kt.lA && this.WWt.C7e()
        }
        Loe(t) {
            if (t = !!t,
            this.E8e === t)
                return;
            this.E8e = t;
            let i = Bv.get(this.lVt);
            if (this.$Vs() && this.C8e() && (i = "text"),
            this.jet.type !== i) {
                let t = this.jet.value;
                this.jet.type = i,
                this.jet.value = t
            }
        }
        efe(t) {
            return Fv.zt(t),
            this.X8e = t,
            this._8e && (this.O8e = this.e7e(),
            this.KKs = this.O8e,
            this.g7e(this.O8e)),
            this
        }
        S7e(t) {
            if (null === t)
                return this.jet.value = "",
                this.jet.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder")),
                void (this.q8e = !0);
            if (this.E7e(),
            "integer" === this.lVt)
                Fv.VY(t),
                t = Math.floor(t),
                this.V8e() && this.j8e && t > this.$8e && (t = this.$8e),
                this.z8e() && this.U8e && t < this.N8e && (t = this.N8e),
                this.jet.value = t.toString();
            else if ("float" === this.lVt)
                Fv.VY(t),
                this.V8e() && this.j8e && t > this.$8e && (t = this.$8e),
                this.z8e() && this.U8e && t < this.N8e && (t = this.N8e),
                this.W8e ? this.jet.value = Fv.toFixed(t, this.H8e) : this.jet.value = t.toString();
            else if ("percent" === this.lVt)
                Fv.VY(t),
                this.V8e() && this.j8e && t > this.$8e && (t = this.$8e),
                this.z8e() && this.U8e && t < this.N8e && (t = this.N8e),
                t *= 100,
                this.jet.value = Fv.toFixed(t, 2) + self.lang("ui.bars.properties.percent-suffix");
            else if ("angle" === this.lVt)
                Fv.VY(t),
                this.V8e() && this.j8e && t > this.$8e && (t = this.$8e),
                this.z8e() && this.U8e && t < this.N8e && (t = this.N8e),
                (t %= 360) < 0 && (t += 360),
                this.jet.value = Fv.toFixed(t, 1) + self.lang("ui.bars.properties.angle-suffix");
            else if ("custom-numeric" === this.lVt) {
                Fv.VY(t),
                this.V8e() && this.j8e && t > this.$8e && (t = this.$8e),
                this.z8e() && this.U8e && t < this.N8e && (t = this.N8e);
                const i = this.X8e ? this.X8e : "";
                this.W8e ? this.jet.value = Fv.toFixed(t, this.H8e) + i : this.jet.value = t.toString() + i
            } else
                Fv.zt(t),
                this.jet.value = t
        }
        _7e(t) {
            if (Fv.zt(t),
            this.jet.value !== t && (!this.$Vs() || t)) {
                if (this.$Vs() && this.C8e()) {
                    let i = this.T7e(t);
                    return "number" == typeof i && isFinite(i) && this.S7e(i),
                    this.A8e = !0,
                    this.J8e(),
                    void (this.A8e = !1)
                }
                if ("integer" === this.lVt) {
                    let i = parseInt(t, 10);
                    if (!isFinite(i))
                        return;
                    this.S7e(i)
                } else if ("float" === this.lVt || "angle" === this.lVt || "custom-numeric" === this.lVt) {
                    let i = parseFloat(t);
                    if (!isFinite(i))
                        return;
                    this.S7e(i)
                } else if ("percent" === this.lVt) {
                    let i = parseFloat(t);
                    if (!isFinite(i))
                        return;
                    i /= 100,
                    this.S7e(i)
                } else
                    this.jet.value = t;
                this.A8e = !0,
                this.J8e(),
                this.A8e = !1
            }
        }
        r7e() {
            const t = this.jet.value;
            let i = null
              , e = !1
              , s = !1;
            return "integer" === this.lVt ? (i = parseInt(t, 10),
            isFinite(i) ? s = !0 : i = NaN) : "float" === this.lVt ? (i = parseFloat(t),
            isFinite(i) ? s = !0 : i = NaN) : "percent" === this.lVt ? (i = parseFloat(t),
            isFinite(i) ? (i /= 100,
            s = !0) : i = NaN) : "angle" === this.lVt ? (i = parseFloat(t),
            isFinite(i) ? (i %= 360,
            i < 0 && (i += 360),
            s = !0) : i = NaN) : "custom-numeric" === this.lVt ? (i = parseFloat(t),
            isFinite(i) ? s = !0 : i = NaN) : i = t,
            s && (this.V8e() && this.j8e && i > this.$8e && (i = this.$8e,
            e = !0),
            this.z8e() && this.U8e && i < this.N8e && (i = this.N8e,
            e = !0)),
            {
                value: i,
                I7e: e
            }
        }
        P7e() {
            return null === this.O8e ? "" : "percent" === this.lVt || "angle" === this.lVt || "custom-numeric" === this.lVt ? this.jet.value : this.r7e().value.toString()
        }
        n8e() {
            this.jet.select(),
            super.n8e()
        }
        Tgt() {
            this.jet && this.jet.focus()
        }
        T7e(t) {
            let i = this.WWt.fQs();
            if ("percent" === this.lVt) {
                let i = self.lang("ui.bars.properties.percent-suffix");
                t.endsWith(i) && (t = t.substr(0, t.length - i.length))
            } else if ("angle" === this.lVt) {
                let i = self.lang("ui.bars.properties.angle-suffix");
                t.endsWith(i) && (t = t.substr(0, t.length - i.length))
            } else if ("custom-numeric" === this.lVt && this.X8e) {
                let i = this.X8e;
                t.endsWith(i) && (t = t.substr(0, t.length - i.length))
            }
            let e = i(t);
            return null === e ? NaN : ("integer" === this.lVt ? e = Math.round(e) : "percent" === this.lVt && (e /= 100),
            e)
        }
        J8e(t) {
            if (this.D8e || !this.T8e)
                return;
            const i = this.WWt;
            let e = !1
              , s = !1;
            if (void 0 === t)
                if (this.$Vs() && this.C8e())
                    t = this.T7e(this.jet.value),
                    isFinite(t) && (e = !0,
                    this.z8e() && this.U8e && t < this.N8e && (t = this.N8e),
                    this.V8e() && this.j8e && t > this.$8e && (t = this.$8e));
                else {
                    const i = this.r7e();
                    t = i.value,
                    s = i.I7e
                }
            let n = !("number" == typeof t && isNaN(t));
            if (n && (this.Kft || this.A8e || this.B8e || this.Clt(t),
            this.A8e || (this.B8e = !1),
            this.b7e(t),
            this.O8e = t),
            this.E7e(),
            this._8e) {
                let t = this.e7e();
                const i = this.X8e || "percent" === this.lVt || "angle" === this.lVt;
                (!n || e || s || t !== this.O8e || i) && (this.O8e = t,
                this.g7e(this.O8e))
            }
            n && (this.G7e(),
            i.kee(this))
        }
        G7e() {
            this.hVt && this.hVt instanceof Fv.qs.Jj.A7e && this.hVt.R7e()
        }
        Ite() {
            return this.jet
        }
        bwt(t, i) {
            Fv.Ge(t),
            Fv.Ge(i),
            this.$Vs() && (this.Kft || null !== this.O8e && (this.Kft = !0,
            this.GLi = t,
            this.CLi = i,
            this.m7e = 0,
            Lv = Fv.qs.SH.gH("ns-resize", this.jet.ownerDocument, t, i),
            this.Clt(this.O8e),
            this.jet.ownerDocument.addEventListener("pointermove", this.Mz),
            this.jet.ownerDocument.addEventListener("pointerup", this.Oz)))
        }
        Gz(t) {
            if (!t.isPrimary)
                return;
            if (!this.Kft)
                return;
            t.preventDefault();
            let i = t.clientX
              , e = t.clientY
              , s = Fv.OF.j1(t)
              , n = t.shiftKey
              , r = this.CLi - e;
            if (r *= this.w7e,
            s ? r *= 10 : n && (r /= 10),
            "integer" === this.lVt && (this.m7e += r,
            r = 0 | this.m7e,
            this.m7e -= r),
            "percent" === this.lVt ? r /= 1e3 : "angle" === this.lVt && (r /= 5),
            0 !== r) {
                let t = this.O8e + r;
                this.z8e() && this.U8e && (this.O8e < this.N8e || t < this.N8e) && (t = this.N8e),
                this.V8e() && this.j8e && (this.O8e > this.$8e || t > this.$8e) && (t = this.$8e),
                this.g7e(t),
                this.J8e(t),
                this.O8e = t
            }
            this.jet.select(),
            this.GLi = i,
            this.CLi = e
        }
        Cz(t) {
            t.isPrimary && this.Kft && (t.preventDefault(),
            this.Gz(t),
            this.Kft = !1,
            Fv.qs.SH.CH(Lv),
            Lv = null,
            this.jet.ownerDocument.removeEventListener("pointermove", this.Mz),
            this.jet.ownerDocument.removeEventListener("pointerup", this.Oz))
        }
        FP(t) {
            t.which === Fv.kE.w9 && (t.preventDefault(),
            this.jet.blur(),
            this.WWt.k7e(this))
        }
        p8e() {
            this.I8e && !this.Kft && (this.R8e ? this._K(this.WWt.O7e(this.I8e)) : this._K(this.I8e()))
        }
        v8e(t) {
            this.jet.disabled = !t,
            this.jet.readOnly = !t
        }
        ofe() {
            if (this.Kft || !this._8e)
                return;
            let t = this.e7e();
            t !== this.O8e && (this.O8e = t,
            this.g7e(this.O8e),
            this.G7e())
        }
        *Pfe() {
            yield*super.Pfe(),
            yield this.jet
        }
        Uht() {
            return this.Kft
        }
        kH() {
            this.Kft && this.l7e && this.l7e()
        }
    }
}
{
    const Uv = self.t
      , Nv = /\\/g
      , jv = /\n/g
      , $v = /\t/g;
    function zv(t) {
        let i = t.replace(Nv, "\\\\");
        return i = i.replace($v, "\\t"),
        i.replace(jv, "\\n")
    }
    function Vv(t) {
        let i = [];
        for (let e of t)
            i.push(e);
        let e = "";
        for (let t = 0, s = i.length; t < s; ++t) {
            let n = i[t];
            if ("\\" === n && t < s - 1) {
                let s = i[t + 1];
                switch (s) {
                case "\\":
                    e += "\\";
                    break;
                case "n":
                    e += "\n";
                    break;
                case "t":
                    e += "\t";
                    break;
                default:
                    e += "\\" + s
                }
                ++t
            } else
                e += n
        }
        return e
    }
    Uv.qs.Jj.W7s = class extends Uv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            Uv.X_t(n),
            Uv.X_t(r),
            Uv.X_t(h),
            this.D7e = Uv.qs.lk("div", this.g8e, null, "flexVstretch"),
            this.jet = Uv.qs.lk("input", this.D7e, null, "longTextProperty"),
            this.jet.type = "text",
            this.jet.id = this.vR(),
            this.jet.setAttribute("spellcheck", "false"),
            this.jet.setAttribute("autocomplete", "off"),
            this.nJi = Uv.qs.lk("button", this.D7e, null, "longTextProperty"),
            this.nJi.textContent = self.lang("common.ellipsis"),
            this.F7e = null,
            this._8e = n,
            this.T8e = r,
            this.I8e = h,
            this.P8e = this.WWt.G8e(),
            this.R8e = o,
            this.O8e = null,
            this.D8e = !1,
            this.F8e = !0,
            this.L8e = !1,
            this.K8e = "",
            this.q8e = !1,
            this.L7e = t => this.B7e(),
            this.nJi.addEventListener("click", this.L7e),
            this.U7e = null,
            this.Y8e = t => this.J8e(),
            this.jet.addEventListener("change", this.Y8e),
            this.Z8e = t => {
                this.n8e(),
                this.F8e = !1,
                this.WWt.Q8e( () => {
                    this.jet && this.WB()
                }
                )
            }
            ,
            this.jet.addEventListener("focus", this.Z8e),
            this.t7e = t => {
                this.WWt.s8e(this),
                this.F8e = !0,
                this.L8e = !1
            }
            ,
            this.jet.addEventListener("blur", this.t7e),
            this.h7e = t => {
                this.F8e && (this.L8e = !0,
                this.F8e = !1)
            }
            ,
            this.jet.addEventListener("pointerdown", this.h7e),
            this.u7e = t => {
                this.L8e && (t.preventDefault(),
                this.L8e = !1)
            }
            ,
            this.jet.addEventListener("pointerup", this.u7e),
            this.c7e = t => {
                this.L8e = !1,
                this.F8e = !1
            }
            ,
            this.jet.addEventListener("pointercancel", this.c7e),
            this.p7e = t => this.FP(t),
            this.jet.addEventListener("keydown", this.p7e),
            this.jet.addEventListener("dragstart", Uv.qs.Lzt),
            this._8e && (this.O8e = this.e7e(),
            this.g7e(this.O8e))
        }
        e7e() {
            return this._8e ? this.R8e ? this.WWt.y7e(this._8e, this) : this._8e(this) : null
        }
        b7e(t) {
            this.T8e && (this.R8e ? this.WWt.v7e(this.T8e, t, this) : this.T8e(t, this))
        }
        Clt() {
            this.P8e && this.P8e(this.Fa())
        }
        LUt() {
            this.N7e(),
            this._8e = null,
            this.T8e = null,
            this.I8e = null,
            this.P8e = null,
            this.O8e = null,
            this.jet.removeEventListener("change", this.Y8e),
            this.Y8e = null,
            this.jet.removeEventListener("blur", this.t7e),
            this.t7e = null,
            this.jet.removeEventListener("focus", this.Z8e),
            this.Z8e = null,
            this.jet.removeEventListener("pointerdown", this.h7e),
            this.h7e = null,
            this.jet.removeEventListener("pointerup", this.u7e),
            this.u7e = null,
            this.jet.removeEventListener("pointercancel", this.c7e),
            this.c7e = null,
            this.jet.removeEventListener("keydown", this.p7e),
            this.p7e = null,
            this.jet.removeEventListener("dragstart", Uv.qs.Lzt),
            Uv.qs.BW(this.jet),
            this.jet = null,
            this.nJi.removeEventListener("click", this.L7e),
            this.L7e = null,
            this.U7e = null,
            Uv.qs.BW(this.nJi),
            this.nJi = null,
            Uv.qs.BW(this.D7e),
            this.D7e = null,
            super.LUt()
        }
        N7e() {
            this.jet.removeAttribute("list"),
            Uv.qs.BW(this.F7e),
            this.F7e = null
        }
        Are(t) {
            Uv.qd(t),
            this.U7e = t
        }
        Mre(t) {
            Uv.zt(t),
            this.nJi.textContent = t
        }
        M7e(t) {
            return Uv.Ge(t),
            (t = Math.floor(t)) < 0 ? this.jet.removeAttribute("maxlength") : this.jet.setAttribute("maxlength", t.toString()),
            this
        }
        Nte(t) {
            return Uv.zt(t),
            this.K8e = t,
            this.q8e || this.jet.setAttribute("placeholder", t),
            this
        }
        E7e() {
            this.q8e && (this.K8e ? this.jet.setAttribute("placeholder", this.K8e) : this.jet.removeAttribute("placeholder"),
            this.q8e = !1)
        }
        $oe(t) {
            if (this.dn())
                return;
            this.N7e();
            const i = "list" + Math.floor(1e6 * Math.random());
            this.F7e = document.createElement("datalist"),
            this.F7e.id = i;
            for (const i of t) {
                const t = document.createElement("option");
                t.value = i,
                this.F7e.appendChild(t)
            }
            this.jet.parentElement.insertBefore(this.F7e, this.jet),
            this.jet.setAttribute("list", i)
        }
        n8e() {
            this.jet.select(),
            super.n8e()
        }
        Tgt() {
            this.jet && this.jet.focus()
        }
        g7e(t) {
            this.D8e = !0,
            this.S7e(t),
            this.D8e = !1
        }
        S7e(t) {
            if (null === t)
                return this.jet.value = "",
                this.jet.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder")),
                void (this.q8e = !0);
            this.E7e(),
            this.jet.value = zv(t)
        }
        r7e() {
            return Vv(this.jet.value)
        }
        J8e() {
            if (this.D8e || !this.T8e)
                return;
            this.Clt();
            let t = this.r7e();
            if (this.b7e(t),
            this.O8e = t,
            this._8e) {
                let t = this.e7e();
                t === this.O8e && zv(t) === this.jet.value || (this.O8e = t,
                this.g7e(this.O8e))
            }
            this.WWt.kee(this)
        }
        B7e() {
            if (this.n8e(),
            this.U7e) {
                let t = this.U7e(this);
                return void (t.then && t.then(t => {
                    "string" == typeof t && this.jet && (this.S7e(t),
                    this.J8e())
                }
                ))
            }
            let t = Uv.qs.Ys.$s("LongTextPropertyDialog");
            t.Ya(this.rVt),
            t.Qa(this.r7e()).then(t => {
                null !== t && this.jet && (t || null !== this.O8e) && (this.S7e(t),
                this.J8e())
            }
            )
        }
        FP(t) {
            t.which === Uv.kE.w9 && (t.preventDefault(),
            this.jet.blur(),
            this.WWt.k7e(this))
        }
        Ite() {
            return this.jet
        }
        p8e() {
            this.I8e && (this.R8e ? this._K(this.WWt.O7e(this.I8e)) : this._K(this.I8e()))
        }
        v8e(t) {
            this.jet.disabled = !t,
            this.jet.readOnly = !t,
            this.nJi.disabled = !t
        }
        ofe() {
            if (!this._8e)
                return;
            let t = this.e7e();
            t !== this.O8e && (this.O8e = t,
            this.g7e(this.O8e))
        }
        *Pfe() {
            yield*super.Pfe(),
            yield this.jet
        }
        static K7s(t) {
            return Uv.zt(t),
            zv(t)
        }
        static z7s(t) {
            return Uv.zt(t),
            Vv(t)
        }
    }
}
{
    const Wv = self.t
      , Hv = "__multiple__";
    Wv.qs.Jj.j7e = class extends Wv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            Wv.X_t(n),
            Wv.X_t(r),
            Wv.X_t(h),
            this.Ywe = Wv.qs.lk("select", this.g8e),
            this.Ywe.id = this.vR(),
            this._8e = n,
            this.T8e = r,
            this.I8e = h,
            this.P8e = this.WWt.G8e(),
            this.R8e = o,
            this.$7e = !1,
            this.z7e = null,
            this.D8e = !1,
            this.O8e = null,
            this._8e && (this.O8e = this.e7e(),
            null === this.O8e && this.V7e()),
            this.Y8e = t => this.J8e(),
            this.Ywe.addEventListener("change", this.Y8e),
            this.Z8e = t => this.n8e(),
            this.Ywe.addEventListener("focus", this.Z8e),
            this.t7e = t => this.WWt.s8e(this),
            this.Ywe.addEventListener("blur", this.t7e),
            this.W7e = null
        }
        LUt() {
            this._8e = null,
            this.T8e = null,
            this.I8e = null,
            this.P8e = null,
            this.Ywe.removeEventListener("change", this.Y8e),
            this.Y8e = null,
            this.Ywe.removeEventListener("focus", this.Z8e),
            this.Z8e = null,
            this.Ywe.removeEventListener("blur", this.t7e),
            this.t7e = null,
            Wv.qs.BW(this.Ywe),
            this.Ywe = null,
            this.W7e && (this.W7e.clear(),
            this.W7e = null),
            super.LUt()
        }
        e7e() {
            return this._8e ? this.R8e ? this.WWt.y7e(this._8e, this) : this._8e(this) : null
        }
        b7e(t) {
            this.T8e && (this.R8e ? this.WWt.v7e(this.T8e, t, this) : this.T8e(t, this))
        }
        Clt(t) {
            this.P8e && this.P8e(this.Fa(), t)
        }
        H7e(t) {
            this.D8e = !0,
            null === t ? this.V7e() : this.Ywe.value = t,
            this.D8e = !1
        }
        V7e() {
            this.$7e || (this.Pk(self.lang("ui.bars.properties.multiple-placeholder"), Hv),
            this.$7e = !0),
            this.Ywe.value = Hv
        }
        K7e() {
            this.z7e && (Wv.qs.BW(this.z7e),
            this.$7e = !1)
        }
        J8e() {
            !this.D8e && this.T8e && this.Ywe.value !== Hv && (this.Clt(this.Ywe.value),
            this.b7e(this.Ywe.value),
            this._8e && (this.O8e = this.e7e(),
            null !== this.O8e && this.K7e(),
            this.Ywe.value !== this.O8e && this.H7e(this.O8e)),
            this.WWt.kee(this))
        }
        Mle() {
            return this.Ywe
        }
        Pk(t, i, e=!1, s="") {
            let n;
            if (Wv.zt(t),
            Wv.Kq(i),
            Wv.Kq(s),
            e = !!e,
            null == i && (i = t),
            s) {
                const t = this.W7e.get(s);
                if (!t)
                    throw new Error("missing options group");
                n = t
            } else
                n = this.Ywe;
            let r = Wv.qs.lk("option", n);
            return r.text = t,
            r.value = i,
            e && r.setAttribute("hidden", ""),
            i === this.O8e && (r.selected = !0),
            i === Hv && (this.z7e = r),
            this
        }
        ayt(t, i) {
            Wv.zt(t),
            Wv.zt(i);
            const e = Wv.qs.lk("optgroup", this.Ywe);
            return e.setAttribute("label", i),
            this.W7e || (this.W7e = new Map),
            this.W7e.set(t, e),
            this
        }
        Tgt() {
            this.Ywe && this.Ywe.focus()
        }
        p8e() {
            this.I8e && (this.R8e ? this._K(this.WWt.O7e(this.I8e)) : this._K(this.I8e()))
        }
        v8e(t) {
            this.Ywe.disabled = !t
        }
        ofe() {
            if (!this._8e)
                return;
            let t = this.e7e();
            t !== this.O8e && (this.O8e = t,
            this.H7e(this.O8e))
        }
        *Pfe() {
            yield*super.Pfe(),
            yield this.Ywe
        }
    }
}
{
    const Kv = self.t;
    let qv = function(t) {
        t.preventDefault();
        let i = this.getAttribute("for")
          , e = this.ownerDocument.getElementById(i);
        e && e.focus()
    };
    Kv.qs.Jj.q7e = class extends Kv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r, h, o) {
            if (super(t, i, e, s),
            Kv.X_t(n),
            Kv.X_t(r),
            Kv.X_t(h),
            this.D7e = Kv.qs.lk("div", this.g8e, null, "flexVstretch"),
            this.X7e = Kv.qs.lk("input", this.D7e, null, "colorProperty"),
            this.X7e.type = "color",
            this.X7e.id = this.vR(),
            this.Y7e = Kv.qs.lk("input", this.D7e, null, "colorProperty"),
            this.Y7e.type = "text",
            this.Y7e.setAttribute("spellcheck", "false"),
            this._8e = n,
            this.T8e = r,
            this.I8e = h,
            this.P8e = this.WWt.G8e(),
            this.R8e = o,
            this.D8e = !1,
            this.J7e = Kv.v(Kv.Ha, 0, 0, 0, 1),
            this.Z7e = !1,
            this.O8e = Kv.v(Kv.Ha, 0, 0, 0, 1),
            this.KKs = null,
            this._8e) {
                let t = this.e7e();
                null === t ? (this.Z7e = !0,
                this.O8e = null) : t instanceof Kv.Ha && (this.J7e.set(t),
                this.O8e.set(t))
            }
            this.X7e.value = this.J7e.DK(),
            this.Z7e ? (this.Y7e.value = "",
            this.Y7e.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder"))) : this.Y7e.value = this.J7e.EDe(),
            this.pCe.addEventListener("click", qv),
            this.Q7e = t => this.lUi(),
            this.X7e.addEventListener("change", this.Q7e),
            this.t9e = t => this.n8e(),
            this.X7e.addEventListener("focus", this.t9e),
            this.i9e = t => this.e9e(),
            this.X7e.addEventListener("blur", this.i9e),
            this.s9e = t => this.n9e(),
            this.Y7e.addEventListener("change", this.s9e),
            this.r9e = t => {
                if (Kv.qs.RW.d4e())
                    return t.preventDefault(),
                    void this.Y7e.blur();
                this.n8e()
            }
            ,
            this.Y7e.addEventListener("focus", this.r9e),
            this.h9e = t => this.WWt.s8e(this),
            this.Y7e.addEventListener("blur", this.h9e),
            this.o9e = t => this.FP(t),
            this.Y7e.addEventListener("keydown", this.o9e),
            this.Y7e.addEventListener("dragstart", Kv.qs.Lzt)
        }
        LUt() {
            this.pCe.removeEventListener("click", qv),
            this._8e = null,
            this.T8e = null,
            this.I8e = null,
            this.P8e = null,
            this.X7e.removeEventListener("change", this.Q7e),
            this.Q7e = null,
            this.X7e.removeEventListener("focus", this.t9e),
            this.t9e = null,
            this.X7e.removeEventListener("blur", this.i9e),
            this.i9e = null,
            Kv.qs.BW(this.X7e),
            this.X7e = null,
            this.Y7e.removeEventListener("change", this.s9e),
            this.s9e = null,
            this.Y7e.removeEventListener("focus", this.r9e),
            this.r9e = null,
            this.Y7e.removeEventListener("blur", this.h9e),
            this.h9e = null,
            this.Y7e.removeEventListener("keydown", this.o9e),
            this.o9e = null,
            this.Y7e.removeEventListener("dragstart", Kv.qs.Lzt),
            Kv.qs.BW(this.Y7e),
            this.Y7e = null,
            Kv.qs.BW(this.D7e),
            this.D7e = null,
            super.LUt()
        }
        b7e() {
            if (!this.T8e)
                return;
            let t = Kv.v(Kv.Ha, this.J7e)
              , i = Kv.v(Kv.Ha, this.O8e);
            this.R8e ? this.WWt.v7e(this.T8e, t, this, i) : this.T8e(t, this, i),
            this.WWt.kee(this)
        }
        e7e() {
            if (!this._8e)
                return null;
            if (this.R8e) {
                const t = this.WWt.y7e(this._8e, this);
                return t && !this.KKs && (this.KKs = Kv.v(Kv.Ha, 0, 0, 0, 1),
                this.KKs.set(t)),
                t
            }
            {
                const t = this._8e(this);
                return t && !this.KKs && (this.KKs = Kv.v(Kv.Ha, 0, 0, 0, 1),
                this.KKs.set(t)),
                t
            }
        }
        Clt() {
            this.P8e && this.P8e(this.Fa())
        }
        e9e() {
            this.lUi(!1),
            this.WWt.s8e(this)
        }
        lUi(t=!0) {
            if (this.D8e || !this.T8e)
                return;
            if (!t && this.Z7e)
                return;
            const i = this.X7e.value
              , e = this.KKs && this.KKs.DK();
            this.J7e.HK(this.X7e.value),
            this.D8e = !0,
            this.Y7e.value = this.J7e.EDe(),
            this.D8e = !1,
            this.KKs = null,
            this.a9e(),
            e && e !== i && this.WWt.vee(this),
            t && this.X7e.focus()
        }
        n9e() {
            if (!this.D8e && this.T8e) {
                if (!this.J7e.AC(this.Y7e.value))
                    return this.D8e = !0,
                    this.Z7e ? (this.Y7e.value = "",
                    this.Y7e.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder"))) : (this.Y7e.value = this.J7e.EDe(),
                    this.Y7e.removeAttribute("placeholder")),
                    void (this.D8e = !1);
                this.D8e = !0,
                this.X7e.value = this.J7e.DK(),
                this.Y7e.value = this.J7e.EDe(),
                this.D8e = !1,
                this.a9e()
            }
        }
        a9e() {
            if (this.O8e && this.J7e && !this.O8e.Oae(this.J7e) && this.Clt(),
            this.b7e(),
            this.O8e.set(this.J7e),
            this.Z7e = !1,
            this.Y7e.removeAttribute("placeholder"),
            this._8e) {
                let t = this.e7e();
                null === t ? (this.Z7e = !0,
                this.J7e.Eo(0, 0, 0),
                this.O8e.Eo(0, 0, 0),
                this.D8e = !0,
                this.X7e.value = this.J7e.DK(),
                this.Y7e.value = "",
                this.Y7e.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder")),
                this.D8e = !1) : this.J7e.Oae(t) || (this.Z7e = !1,
                this.D8e = !0,
                this.J7e.Eo(t.r, t.g, t.b),
                this.O8e.Eo(t.r, t.g, t.b),
                this.X7e.value = this.J7e.DK(),
                this.Y7e.value = this.J7e.EDe(),
                this.D8e = !1)
            }
        }
        FP(t) {
            t.which === Kv.kE.w9 && (t.preventDefault(),
            this.Y7e.blur(),
            this.WWt.k7e(this))
        }
        Tgt() {
            this.X7e && this.X7e.focus()
        }
        l9e() {
            return this.X7e
        }
        p8e() {
            this.I8e && (this.R8e ? this._K(this.WWt.O7e(this.I8e)) : this._K(this.I8e()))
        }
        v8e(t) {
            this.X7e.disabled = !t,
            this.Y7e.disabled = !t,
            this.Y7e.readOnly = !t
        }
        ofe() {
            if (!this._8e)
                return;
            let t = this.e7e();
            this.Z7e && null === t || !this.Z7e && null !== t && t.Oae(this.J7e) || (this.Z7e = null === t,
            this.Z7e ? (this.J7e.Eo(0, 0, 0),
            this.O8e && this.O8e.Eo(0, 0, 0),
            this.X7e.value = this.J7e.DK(),
            this.Y7e.value = "",
            this.Y7e.setAttribute("placeholder", self.lang("ui.bars.properties.multiple-placeholder"))) : (this.J7e.Eo(t.r, t.g, t.b),
            this.O8e || (this.O8e = Kv.v(Kv.Ha, 0, 0, 0, 1)),
            this.O8e.Eo(t.r, t.g, t.b),
            this.X7e.value = this.J7e.DK(),
            this.Y7e.value = this.J7e.EDe(),
            this.Y7e.removeAttribute("placeholder")))
        }
        *Pfe() {
            yield*super.Pfe(),
            yield this.X7e,
            yield this.Y7e
        }
    }
}
{
    const Xv = self.t;
    function Yv(t) {
        t.preventDefault();
        let i = this.getAttribute("for")
          , e = this.ownerDocument.getElementById(i);
        e && e.focus()
    }
    Xv.qs.Jj.u9e = class extends Xv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            Xv.X_t(n),
            Xv.X_t(r),
            Xv.X_t(h),
            this.c9e = Xv.qs.lk("div", this.g8e, null, "checkpropertywrap"),
            this.rQe = Xv.qs.lk("input", this.c9e),
            this.rQe.type = "checkbox",
            this.rQe.id = this.vR(),
            this.pCe.addEventListener("click", Yv),
            this._8e = n,
            this.T8e = r,
            this.I8e = h,
            this.P8e = this.WWt.G8e(),
            this.O8e = null,
            this.R8e = o,
            this.D8e = !1,
            this._8e && (this.O8e = this.e7e(),
            this.d9e(this.O8e)),
            this.Y8e = t => this.J8e(),
            this.rQe.addEventListener("change", this.Y8e),
            this.Z8e = t => this.n8e(),
            this.rQe.addEventListener("focus", this.Z8e),
            this.t7e = t => this.WWt.s8e(this),
            this.rQe.addEventListener("blur", this.t7e),
            this.f9e = !1,
            this.l1 = t => {
                t.button === Xv.f1.e5 && t.isPrimary && t.target === this.c9e && ("mouse" !== !t.pointerType && t.preventDefault(),
                this.f9e = !0,
                this.rQe.focus())
            }
            ,
            this.c9e.addEventListener("pointerdown", this.l1),
            this.A8 = t => {
                t.target === this.c9e && this.f9e && (t.preventDefault(),
                this.rQe.click()),
                this.f9e = !1
            }
            ,
            this.c9e.addEventListener("UITap", this.A8)
        }
        LUt() {
            this.pCe.removeEventListener("click", Yv),
            this._8e = null,
            this.T8e = null,
            this.I8e = null,
            this.P8e = null,
            this.O8e = null,
            this.rQe.removeEventListener("change", this.Y8e),
            this.Y8e = null,
            this.rQe.removeEventListener("focus", this.Z8e),
            this.Z8e = null,
            this.rQe.removeEventListener("blur", this.t7e),
            this.t7e = null,
            this.c9e.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.c9e.removeEventListener("UITap", this.A8),
            this.A8 = null,
            Xv.qs.BW(this.rQe),
            this.rQe = null,
            Xv.qs.BW(this.c9e),
            this.c9e = null,
            super.LUt()
        }
        e7e() {
            return this._8e ? this.R8e ? this.WWt.y7e(this._8e, this) : this._8e(this) : null
        }
        b7e(t) {
            this.T8e && (t = !!t,
            this.R8e ? this.WWt.v7e(this.T8e, t, this) : this.T8e(t, this))
        }
        Clt() {
            this.P8e && this.P8e(this.Fa(), !!this.rQe.checked)
        }
        d9e(t) {
            this.D8e = !0,
            null === t ? this.rQe.indeterminate = !0 : (this.rQe.indeterminate = !1,
            this.rQe.checked = !!t),
            this.D8e = !1
        }
        J8e() {
            !this.D8e && this.T8e && (this.Clt(),
            this.b7e(!!this.rQe.checked),
            this._8e && (this.O8e = this.e7e(),
            !!this.rQe.checked !== this.O8e && this.d9e(this.O8e)),
            this.WWt.kee(this))
        }
        Tgt() {
            this.rQe && this.rQe.focus()
        }
        Nle() {
            return this.rQe
        }
        p8e() {
            this.I8e && (this.R8e ? this._K(this.WWt.O7e(this.I8e)) : this._K(this.I8e()))
        }
        v8e(t) {
            this.rQe.disabled = !t
        }
        ofe() {
            if (!this._8e)
                return;
            let t = this.e7e();
            t !== this.O8e && (this.O8e = t,
            this.d9e(this.O8e))
        }
        *Pfe() {
            yield*super.Pfe(),
            yield this.g8e
        }
    }
}
{
    const Jv = self.t;
    Jv.qs.Jj.p9e = class extends Jv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r, h) {
            super(t, i, e, s),
            Jv.X_t(n),
            this.m9e = Jv.qs.lk("span", this.g8e, null, "infoProperty"),
            this.m9e.setAttribute("tabindex", "-1"),
            this.w9e = n,
            this.O8e = null,
            this.I8e = r,
            this.R8e = h,
            this.ofe(),
            this._K(!1)
        }
        e7e() {
            return this.w9e ? this.R8e ? this.WWt.y7e(this.w9e, this) : this.w9e(this) : null
        }
        ofe() {
            if (!this.w9e)
                return;
            let t = this.e7e();
            null === t ? t = self.lang("ui.bars.properties.multiple-placeholder") : Jv.wke(t) || (t = t.toString()),
            Jv.bBe(this.O8e, t) || (this.O8e = t,
            Jv.odt(this.m9e, this.O8e))
        }
        Tgt() {
            this.m9e && this.m9e.focus()
        }
        LUt() {
            Jv.qs.BW(this.m9e),
            this.m9e = null,
            this.w9e = null,
            this.I8e = null,
            this.O8e = null,
            super.LUt()
        }
        g9e() {
            return this.m9e
        }
        p8e() {
            this.I8e && (this.R8e ? this._K(this.WWt.O7e(this.I8e)) : this._K(this.I8e()))
        }
    }
}
{
    const Zv = self.t;
    Zv.qs.Jj.y9e = class extends Zv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r, h, o) {
            super(t, i, e, s),
            Zv.X_t(n),
            Zv.X_t(r),
            Zv.X_t(h),
            this.D7e = Zv.qs.lk("div", this.g8e, null, "flexVstretch"),
            this.b9e = Zv.qs.lk("div", this.D7e, null, "iconPropertyWrap"),
            this.b9e.id = this.vR(),
            this.wat = Zv.v(Zv.qs.kmt, self.app.T_(), this.b9e),
            this.v9e = Zv.qs.lk("div", this.b9e, null, "iconPropertyLabel"),
            this.nJi = Zv.qs.lk("button", this.D7e, null, "iconProperty"),
            this.nJi.textContent = self.lang("common.ellipsis"),
            this._8e = n,
            this.T8e = r,
            this.I8e = h,
            this.P8e = this.WWt.G8e(),
            this.R8e = o,
            this.O8e = null,
            this.L7e = t => this.B7e(),
            this.nJi.addEventListener("click", this.L7e),
            this.S9e = null,
            this.x9e = null
        }
        LUt() {
            this._8e = null,
            this.T8e = null,
            this.I8e = null,
            this.P8e = null,
            this.O8e = null,
            this.wat.he(),
            this.wat = null,
            Zv.qs.BW(this.v9e),
            this.v9e = null,
            Zv.qs.BW(this.b9e),
            this.b9e = null,
            this.nJi.removeEventListener("click", this.L7e),
            this.L7e = null,
            this.S9e = null,
            this.x9e = null,
            Zv.qs.BW(this.nJi),
            this.nJi = null,
            Zv.qs.BW(this.D7e),
            this.D7e = null,
            super.LUt()
        }
        e7e() {
            return this._8e ? this.R8e ? this.WWt.y7e(this._8e, this) : this._8e(this) : null
        }
        b7e(t) {
            this.T8e && (this.R8e ? this.WWt.v7e(this.T8e, t, this) : this.T8e(t, this))
        }
        Clt() {
            this.P8e && this.P8e(this.Fa())
        }
        xLs(t) {
            if (null === t)
                this.wat.CA(null),
                this.v9e.textContent = self.lang("ui.bars.properties.multiple-placeholder");
            else {
                if (!this.x9e)
                    throw new Error("no display info function");
                const i = this.x9e(t);
                null === i ? (this.wat.CA(null),
                this.v9e.textContent = "") : (this.wat.CA(i.icon),
                this.v9e.textContent = i.text)
            }
        }
        Tgt() {
            this.nJi && this.nJi.focus()
        }
        Are(t) {
            Zv.qd(t),
            this.S9e = t
        }
        Mre(t) {
            Zv.zt(t),
            this.nJi.textContent = t
        }
        async B7e() {
            if (!this.S9e)
                throw new Error("no button click handler");
            const t = await this.S9e(this.O8e);
            this.nJi && null !== t && t !== this.O8e && (this.b7e(t),
            this.O8e = t,
            this.xLs(t),
            this.WWt.kee(this))
        }
        eae(t) {
            Zv.qd(t),
            this.x9e = t,
            this._8e && (this.O8e = this.e7e(),
            this.xLs(this.O8e))
        }
        p8e() {
            this.I8e && (this.R8e ? this._K(this.WWt.O7e(this.I8e)) : this._K(this.I8e()))
        }
        v8e(t) {
            this.nJi.disabled = !t
        }
        ofe() {
            if (!this._8e)
                return;
            const t = this.e7e();
            t !== this.O8e && (this.O8e = t,
            this.xLs(this.O8e))
        }
        *Pfe() {
            yield*super.Pfe(),
            yield this.b9e
        }
    }
}
{
    const Qv = self.t;
    Qv.qs.Jj.M9e = class extends Qv.qs.Jj.m8e {
        constructor(t, i, e, s, n, r) {
            if (super(t, i, e, s),
            Qv.zt(n),
            this.E9e = Qv.qs.lk("a", this.g8e),
            this.E9e.setAttribute("tabindex", -1),
            this.dj() && this.E9e.setAttribute("title", this.dj()),
            this.B6s = null,
            "string" == typeof r)
                this.E9e.href = r,
                this.B6s = t => {
                    t.preventDefault(),
                    self.app.e_(r, "PropertiesBar-LinkProperty")
                }
                ;
            else {
                if ("function" != typeof r)
                    throw new TypeError("expected string or function");
                this.B6s = r
            }
            this.E9e.addEventListener("click", this.B6s),
            this.E9e.textContent = n,
            this.Z8e = t => this.n8e(),
            this.E9e.addEventListener("focus", this.Z8e),
            this.t7e = t => this.WWt.s8e(this),
            this.E9e.addEventListener("blur", this.t7e)
        }
        LUt() {
            this.E9e.removeEventListener("focus", this.Z8e),
            this.Z8e = null,
            this.E9e.removeEventListener("blur", this.t7e),
            this.t7e = null,
            this.B6s && (this.E9e.removeEventListener("click", this.B6s),
            this.B6s = null),
            Qv.qs.BW(this.E9e),
            this.E9e = null,
            super.LUt()
        }
        Tgt() {
            this.E9e && this.E9e.focus()
        }
        $le() {
            return this.E9e
        }
        C9e(t) {
            if (Qv.zt(t),
            this.B6s)
                throw new Error("not an external link");
            this.E9e.href = t
        }
        _9e(t) {
            Qv.zt(t),
            this.E9e.textContent = t
        }
    }
}
{
    const tS = self.t;
    tS.qs.Jj.T9e = class extends tS.qs.Jj.Sfe {
        constructor(t, i, e, s) {
            super(t, i, e, s),
            this.Ibt = tS.qs.lk("td", this.Get),
            this.Ibt.setAttribute("colspan", "2"),
            this.Ibt.setAttribute("tabindex", "-1"),
            this.Ibt.setAttribute("propgroup", ""),
            this.Ibt.setAttribute("role", "heading"),
            this.wvt = tS.qs.lk("div", this.Ibt, null, "propgroup-wrap");
            let n = this.h8e();
            n > 0 && this.wvt.setAttribute("level" + n, ""),
            this.pCe = tS.qs.lk("label", this.wvt, null, "propgroup-label"),
            this.pCe.textContent = i,
            this.I9e = tS.v(tS.qs.kmt, self.app.oi("expanded"), this.wvt),
            this.ali = !0,
            this.P9e = [],
            this.G9e = t => this.n8e(),
            this.Ibt.addEventListener("focus", this.G9e),
            this.A9e = t => this.WWt.s8e(this),
            this.Ibt.addEventListener("blur", this.A9e),
            this.R9e = t => this.Lmt(!0),
            this.pCe.addEventListener("UIDoubleTap", this.R9e),
            this.I9e.hk().addEventListener("pointerdown", this.R9e),
            this.Get.classList.add("propertyGroup")
        }
        LUt() {
            this.I9e.hk().removeEventListener("pointerdown", this.R9e),
            this.I9e.he(),
            this.I9e = null,
            this.pCe.removeEventListener("UIDoubleTap", this.R9e),
            this.R9e = null,
            tS.qs.BW(this.pCe),
            this.pCe = null,
            tS.qs.BW(this.wvt),
            this.wvt = null,
            this.Ibt.removeEventListener("blur", this.A9e),
            this.A9e = null,
            this.Ibt.removeEventListener("focus", this.G9e),
            this.G9e = null,
            tS.qs.BW(this.Ibt),
            this.Ibt = null,
            super.LUt()
        }
        Tgt() {
            this.Ibt && this.Ibt.focus()
        }
        y8e() {
            return this.Ibt
        }
        xoe() {
            return this.pCe
        }
        k9e() {
            if (this.P9e.length <= 2) {
                for (let t of this.P9e)
                    if (t instanceof tS.qs.Jj.T9e)
                        return !0;
                return !1
            }
            return !0
        }
        OB() {
            return this.ali
        }
        VE(t, i) {
            t = !!t,
            i = !!i,
            this.ali !== t && (this.WWt.l8e() || (this.k9e() || (i = !1),
            this.ali = t,
            this.I9e.CA(self.app.oi(this.ali ? "expanded" : "collapsed")),
            this.O9e(i)))
        }
        Lmt(t) {
            t = !!t,
            this.VE(!this.OB(), t)
        }
        a8e(t, i) {
            t = !!t,
            i = !!i,
            super.a8e(t, i),
            this.O9e(i)
        }
        O9e(t) {
            let i = this.ali && this.Cmt();
            for (let e of this.P9e)
                e.a8e(i, t)
        }
        XWt(t, i, e, s, n, r, h) {
            let o = tS.v(tS.qs.Jj.M8e, this.WWt, t, i, e, this, s, n, r, !!h);
            return o.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(o),
            this.P9e.push(o),
            o
        }
        Mte(t, i, e, s, n, r) {
            let h = tS.v(tS.qs.Jj.W7s, this.WWt, t, i, this, e, s, n, !!r);
            return h.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(h),
            this.P9e.push(h),
            h
        }
        Kte(t, i, e, s, n, r) {
            let h = tS.v(tS.qs.Jj.j7e, this.WWt, t, i, this, e, s, n, !!r);
            return h.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(h),
            this.P9e.push(h),
            h
        }
        qte(t, i, e, s, n, r) {
            let h = tS.v(tS.qs.Jj.q7e, this.WWt, t, i, this, e, s, n, !!r);
            return h.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(h),
            this.P9e.push(h),
            h
        }
        zte(t, i, e, s, n, r) {
            let h = tS.v(tS.qs.Jj.u9e, this.WWt, t, i, this, e, s, n, !!r);
            return h.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(h),
            this.P9e.push(h),
            h
        }
        cse(t, i, e, s, n) {
            let r = tS.v(tS.qs.Jj.p9e, this.WWt, t, i, this, e, s, n);
            return r.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(r),
            this.P9e.push(r),
            r
        }
        Jre(t, i, e, s, n, r) {
            let h = tS.v(tS.qs.Jj.y9e, this.WWt, t, i, this, e, s, n, r);
            return h.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(h),
            this.P9e.push(h),
            h
        }
        Xse(t, i, e, s) {
            let n = tS.v(tS.qs.Jj.M9e, this.WWt, t, i, this, e, s);
            return n.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(n),
            this.P9e.push(n),
            n
        }
        VWt(t, i) {
            let e = tS.v(tS.qs.Jj.T9e, this.WWt, t, i, this);
            return e.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(e),
            this.P9e.push(e),
            e
        }
        ise(t, i, e, s) {
            let n = tS.v(tS.qs.Jj.A7e, this.WWt, t, i, e, this, s);
            return n.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(n),
            this.P9e.push(n),
            n
        }
        *children() {
            for (let t of this.P9e)
                yield t
        }
        QL() {
            return {
                name: this.Fa(),
                expanded: this.OB(),
                children: this.P9e.map(t => t.QL()).filter(t => t)
            }
        }
        tU(t) {
            if (t) {
                for (let i of t.children) {
                    let t = this.D9e(i.name);
                    t && t.tU(i)
                }
                this.VE(t.expanded)
            }
        }
        D9e(t) {
            tS.zt(t);
            for (let i of this.P9e)
                if (i.Fa() === t)
                    return i
        }
    }
}
{
    const iS = self.t
      , eS = 3;
    iS.qs.Jj.A7e = class extends iS.qs.Jj.m8e {
        constructor(t, i, e, s, n, r) {
            if (super(t, i, e, n),
            iS.zt(s),
            !s)
                throw new Error("non-empty separator required");
            this.F9e = s,
            this.L9e = [],
            this.I8e = r,
            this.B9e = iS.qs.lk("input", this.g8e),
            this.B9e.type = "text",
            this.B9e.id = this.vR(),
            this.B9e.setAttribute("spellcheck", "false"),
            this.I9e = iS.v(iS.qs.kmt, self.app.oi("collapsed"), this.wvt),
            this.U9e = t => this.Lmt(!0),
            this.I9e.hk().addEventListener("pointerdown", this.U9e),
            this.D8e = !1,
            this.F8e = !0,
            this.L8e = !1,
            this.P8e = this.WWt.G8e(),
            this.KKs = null,
            this.ali = !1,
            this.P9e = [],
            this.Y8e = t => this.J8e(),
            this.B9e.addEventListener("change", this.Y8e),
            this.Z8e = t => {
                if (iS.qs.RW.d4e())
                    return t.preventDefault(),
                    void this.B9e.blur();
                this.n8e(),
                this.F8e = !1,
                this.WWt.Q8e( () => {
                    this.B9e && this.WB()
                }
                )
            }
            ,
            this.B9e.addEventListener("focus", this.Z8e),
            this.t7e = t => {
                this.WWt.s8e(this),
                this.F8e = !0,
                this.L8e = !1,
                this.KKs !== this.B9e.value && (this.WWt.vee(this),
                this.KKs = this.B9e.value)
            }
            ,
            this.B9e.addEventListener("blur", this.t7e),
            this.l1 = t => {
                this.F8e && (this.L8e = !0,
                this.F8e = !1)
            }
            ,
            this.B9e.addEventListener("pointerdown", this.l1),
            this.qG = -1,
            this.Oz = t => {
                this.L8e && (this.L8e = !1,
                this.qG = requestAnimationFrame( () => {
                    this.B9e && this.B9e.select(),
                    this.qG = -1
                }
                ))
            }
            ,
            this.B9e.addEventListener("pointerup", this.Oz),
            this.N9e = t => {
                this.F8e = !1,
                this.L8e = !1,
                cancelAnimationFrame(this.qG),
                this.qG = -1
            }
            ,
            this.B9e.addEventListener("pointercancel", this.N9e),
            this.Rz = t => this.FP(t),
            this.B9e.addEventListener("keydown", this.Rz),
            this.B9e.addEventListener("dragstart", iS.qs.Lzt),
            this.R9e = t => this.Lmt(!0),
            this.pCe.addEventListener("UIDoubleTap", this.R9e)
        }
        LUt() {
            this.P8e = null,
            this.I8e = null,
            this.KKs = null,
            this.pCe.removeEventListener("UIDoubleTap", this.R9e),
            this.R9e = null,
            this.B9e.removeEventListener("change", this.Y8e),
            this.Y8e = null,
            this.B9e.removeEventListener("focus", this.Z8e),
            this.Z8e = null,
            this.B9e.removeEventListener("blur", this.t7e),
            this.t7e = null,
            this.B9e.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.B9e.removeEventListener("pointerup", this.Oz),
            this.Oz = null,
            this.B9e.removeEventListener("pointercancel", this.N9e),
            this.N9e = null,
            this.B9e.removeEventListener("keydown", this.Rz),
            this.Rz = null,
            this.B9e.removeEventListener("dragstart", iS.qs.Lzt),
            iS.qs.BW(this.B9e),
            this.B9e = null,
            this.I9e.hk().removeEventListener("pointerdown", this.U9e),
            this.U9e = null,
            this.I9e.he(),
            this.I9e = null,
            super.LUt()
        }
        n8e() {
            this.B9e.select(),
            super.n8e()
        }
        Tgt() {
            this.B9e && this.B9e.focus()
        }
        Clt() {
            this.P8e && this.P8e(this.Fa())
        }
        j9e() {
            let t = [];
            for (let i of this.P9e)
                i.x7e() || t.push(i);
            return t
        }
        ose(t) {
            if ("string" == typeof t)
                this.L9e = [t];
            else {
                if (!Array.isArray(t))
                    throw new Error("expected string or array");
                this.L9e = t
            }
        }
        J8e() {
            if (this.D8e)
                return;
            this.Clt(),
            this.D8e = !0;
            const t = this.B9e.value.trim()
              , i = this.F9e.trim();
            let e = t.split(i);
            if (1 === e.length)
                for (const i of this.L9e) {
                    const s = i.trim()
                      , n = t.split(s);
                    if (n.length >= 2) {
                        e = n;
                        break
                    }
                }
            const s = this.j9e()
              , n = Math.min(e.length, s.length);
            for (let t = 0; t < n; ++t) {
                const i = e[t].trim();
                s[t]._7e(i)
            }
            this.R7e(),
            this.D8e = !1
        }
        R7e() {
            let t = ""
              , i = this.j9e();
            for (let e = 0, s = i.length; e < s; ++e) {
                t += i[e].P7e(),
                e < s - 1 && (t += this.F9e)
            }
            this.B9e.value !== t && (this.D8e = !0,
            this.B9e.value = t,
            this.D8e = !1)
        }
        ooe() {
            this.R7e(),
            this.KKs = this.B9e.value
        }
        FP(t) {
            t.which === iS.kE.w9 && (t.preventDefault(),
            this.B9e.blur(),
            this.WWt.k7e(this))
        }
        p8e() {
            this.I8e && this._K(this.I8e())
        }
        v8e(t) {
            this.B9e.disabled = !t,
            this.B9e.readOnly = !t
        }
        $9e() {
            return this.B9e
        }
        OB() {
            return this.ali
        }
        VE(t, i) {
            t = !!t,
            i = !!i,
            this.ali !== t && (this.P9e.length <= eS && (i = !1),
            this.ali = t,
            this.I9e.CA(self.app.oi(this.ali ? "expanded" : "collapsed")),
            this.O9e(i))
        }
        Lmt(t) {
            t = !!t,
            this.VE(!this.OB(), t)
        }
        a8e(t, i) {
            t = !!t,
            i = !!i,
            super.a8e(t, i),
            this.O9e(i)
        }
        O9e(t) {
            let i = this.ali && this.Cmt();
            for (let e of this.P9e)
                e.a8e(i, t)
        }
        XWt(t, i, e, s, n, r, h) {
            let o = iS.v(iS.qs.Jj.M8e, this.WWt, t, i, e, this, s, n, r, !!h);
            return o.a8e(this.ali && this.Cmt()),
            this.WWt.pHs.push(o),
            this.P9e.push(o),
            this.R7e(),
            this.KKs = this.B9e.value,
            o
        }
        QL() {
            return {
                name: this.Fa(),
                expanded: this.OB(),
                children: this.P9e.map(t => t.QL()).filter(t => t)
            }
        }
        tU(t) {
            if (t) {
                for (let i of t.children) {
                    let t = this.D9e(i.name);
                    t && t.tU(i)
                }
                this.VE(t.expanded)
            }
        }
        D9e(t) {
            iS.zt(t);
            for (let i of this.P9e)
                if (i.Fa() === t)
                    return i
        }
        *Pfe() {
            yield*super.Pfe(),
            yield this.B9e
        }
    }
}
{
    const sS = self.t
      , nS = 2
      , rS = 300
      , hS = {
        resizable: !1,
        z9e: {
            borderTop: !0,
            borderLeft: !1,
            borderRight: !1,
            borderBottom: !1
        }
    };
    sS.qs.Jj.HWt = class extends sS.Event.aG {
        constructor(t, i) {
            super(),
            sS.Wat(i),
            i = Object.assign({}, hS, i),
            this.hVt = t,
            this.Get = sS.qs.lk("ui-propertygrid", this.hVt),
            this.V9e = sS.qs.lk("ui-propertygrid-container", this.Get),
            this.W9e = sS.qs.lk("ui-propertygrid-table", this.V9e),
            this.W9e.setAttribute("role", "none"),
            this.H9e = sS.qs.lk("tr", this.W9e),
            this.K9e = sS.qs.lk("td", this.H9e, null, "firstRow"),
            this.K9e.style.width = "50%",
            this.K9e.classList.add("firstRow"),
            this.q9e = sS.qs.lk("td", this.H9e, null, "firstRow"),
            this.X9e = sS.qs.lk("ui-propertygrid-footer", this.Get),
            this.X9e.style.display = "none",
            i.z9e.borderTop && this.X9e.setAttribute("useBorderTop", ""),
            i.z9e.borderLeft && this.X9e.setAttribute("useBorderLeft", ""),
            i.z9e.borderRight && this.X9e.setAttribute("useBorderRight", ""),
            i.z9e.borderBottom && this.X9e.setAttribute("useBorderBottom", ""),
            this.Y9e = sS.qs.lk("span", this.X9e, null, "property-footer-title"),
            this.J9e = sS.qs.lk("span", this.X9e, null, "property-footer-description"),
            this.Z9e = !!i.resizable,
            this.pHs = [],
            this.P8e = null,
            this.Q9e = null,
            this.rQs = null,
            this.ttn = 0,
            this.itn = null,
            this.etn = 0,
            this.stn = [],
            this.ntn = -1,
            this.rtn = [],
            this.htn = () => this.otn(!1),
            this.atn = -1,
            this.ltn = [],
            this.utn = () => this.ctn(!1),
            this.dtn = !0,
            this.ftn = 1,
            this.l1 = t => this.IW(t),
            this.Mz = t => this.Gz(t),
            this.N9e = t => this.b2(t),
            this.ptn = t => this.mtn(t),
            this.a7e = t => this.wtn(t),
            this.l7e = t => this.gtn(t),
            this.o1 = null,
            this.URi = {
                onpointerdown: this.l1,
                onpointermove: this.ptn,
                onpointerup: this.a7e,
                onpointercancel: this.l7e
            },
            this.ytn = !1,
            this.LCt = 0,
            this.WCt = null,
            this.btn = -1,
            this.Z9e && (this.W9e.addEventListener("pointerdown", this.l1, !0),
            this.W9e.addEventListener("pointermove", this.Mz),
            this.W9e.addEventListener("pointercancel", this.N9e),
            this.PH().addEventListener("pointermove", this.ptn),
            this.PH().addEventListener("pointerup", this.a7e),
            this.PH().addEventListener("pointercancel", this.l7e)),
            this.vtn = 0
        }
        he() {
            this.Stn(),
            this.tC(),
            this.H_t(),
            this.W9e.removeEventListener("pointerdown", this.l1, !0),
            this.l1 = null,
            this.W9e.removeEventListener("pointermove", this.Mz),
            this.Mz = null,
            this.PH().removeEventListener("pointermove", this.ptn),
            this.ptn = null,
            this.PH().removeEventListener("pointerup", this.a7e),
            this.a7e = null,
            this.W9e.removeEventListener("pointercancel", this.N9e),
            this.N9e = null,
            this.PH().removeEventListener("pointercancel", this.l7e),
            this.l7e = null,
            sS.qs.BW(this.WCt),
            this.WCt = null,
            sS.qs.BW(this.q9e),
            this.q9e = null,
            sS.qs.BW(this.K9e),
            this.K9e = null,
            sS.qs.BW(this.H9e),
            this.H9e = null,
            sS.qs.BW(this.W9e),
            this.W9e = null,
            sS.qs.BW(this.V9e),
            this.V9e = null,
            sS.qs.BW(this.X9e),
            this.X9e = null,
            sS.qs.BW(this.Get),
            this.Get = null,
            this.hVt = null,
            this.htn = null,
            this.utn = null,
            this.rQs = null,
            super.he()
        }
        tC() {
            this.Stn(),
            this.H2e(),
            sS.sc(this.stn),
            this.xtn("", ""),
            -1 !== this.ntn && (this.jW().cancelAnimationFrame(this.ntn),
            this.ntn = -1),
            sS.sc(this.rtn),
            -1 !== this.atn && (this.jW().cancelAnimationFrame(this.atn),
            this.atn = -1),
            sS.sc(this.ltn);
            for (let t = this.pHs.length - 1; t >= 0; --t)
                this.pHs[t].LUt();
            this.P8e = null,
            this.Q9e = null,
            sS.sc(this.pHs),
            this.ttn = 0
        }
        H_t() {
            sS.qs.SH.CH(this.o1),
            this.o1 = null
        }
        H2e() {
            let t = document.activeElement;
            for (; t; )
                if (t = t.parentElement,
                t === this.W9e)
                    return void document.activeElement.blur()
        }
        hk() {
            return this.Get
        }
        t8e() {
            return "propid" + this.ttn++
        }
        e8e() {
            return this.W9e
        }
        PH() {
            return this.hk().ownerDocument
        }
        jW() {
            return this.PH().defaultView
        }
        xtn(t, i) {
            sS.zt(t),
            sS.zt(i);
            let e = this.V9e.scrollTop;
            if (t && "" !== t) {
                let i = self.lang("ui.bars.properties.footer-title-prefix")
                  , e = self.lang("ui.bars.properties.footer-title-suffix");
                this.Y9e.textContent = i + t + e
            } else
                sS.qs.BYt(this.Y9e);
            i ? this.J9e.textContent = i : sS.qs.BYt(this.J9e),
            this.X9e.style.display = t || i ? "" : "none",
            this.V9e.scrollTop = e
        }
        vie(t) {
            if (sS._D(t),
            !t.length)
                throw new Error("cannot set empty item array");
            sS.lw(this.stn, t)
        }
        Kyt(t) {
            sS.zlt(t),
            this.hVt !== t && (this.hVt && this.hVt.removeChild(this.Get),
            this.hVt = t,
            this.hVt.appendChild(this.Get))
        }
        jte(t) {
            sS.X_t(t),
            this.P8e = t
        }
        G8e() {
            return this.P8e
        }
        ene(t) {
            sS.X_t(t),
            this.Q9e = t
        }
        d8e() {
            return this.Mtn() ? null : this.Q9e
        }
        y7e(t, i) {
            if (!this.stn.length)
                throw new Error("no item array available");
            let e = t(this.stn[0], i)
              , s = e instanceof sS.Ha;
            for (let n = 1, r = this.stn.length; n < r; ++n) {
                let r = t(this.stn[n], i);
                if (s) {
                    if (!e.Oae(r))
                        return null
                } else if (r !== e)
                    return null
            }
            return e
        }
        v7e(t, i, e, s) {
            if (!this.stn.length)
                throw new Error("no item array available");
            for (let n of this.stn)
                t(n, i, e, s)
        }
        O7e(t) {
            sS.qd(t);
            for (let i of this.stn)
                if (t(i))
                    return !0;
            return !1
        }
        bq(t) {
            return sS.U(t, sS.qs.Jj.Sfe),
            this.itn === t
        }
        r8e(t) {
            if (sS.U(t, sS.qs.Jj.Sfe),
            !this.pHs.includes(t))
                throw new Error("property not from this grid");
            this.Stn(),
            this.itn && this.itn.y8e().removeAttribute("selected"),
            this.itn = t,
            this.itn.y8e().setAttribute("selected", ""),
            this.xtn(this.itn.Fa(), this.itn.dj())
        }
        k7e(t) {
            sS.U(t, sS.qs.Jj.Sfe);
            let i = this.pHs.indexOf(t);
            if (!(i < 0)) {
                ++i;
                for (let t = this.pHs.length; i < t; ++i) {
                    let t = this.pHs[i];
                    if (t.Cmt())
                        return this.r8e(t),
                        void t.Tgt()
                }
            }
        }
        s8e(t) {
            if (sS.U(t, sS.qs.Jj.Sfe),
            this.itn === t) {
                let t = this.itn.y8e();
                t && t.removeAttribute("selected"),
                this.itn = null,
                this.Stn()
            }
        }
        Q8e(t) {
            sS.qd(t),
            this.Stn(),
            this.btn = self.setTimeout( () => {
                this.btn = -1,
                t()
            }
            , rS)
        }
        Stn() {
            -1 !== this.btn && (self.clearTimeout(this.btn),
            this.btn = -1)
        }
        Bwt(t) {
            this.Stn(),
            sS.qs.WB(t.y8e(), this.V9e)
        }
        l8e() {
            return -1 !== this.ntn || -1 !== this.atn
        }
        u8e() {
            for (; -1 !== this.ntn; )
                this.otn(!0);
            for (; -1 !== this.atn; )
                this.ctn(!0)
        }
        c8e(t) {
            sS.U(t, sS.qs.Jj.Sfe),
            -1 !== this.atn && this.u8e(),
            -1 === this.ntn && (this.ntn = this.jW().requestAnimationFrame(this.htn),
            this.dtn = !0),
            this.rtn.push(t)
        }
        f8e(t) {
            sS.U(t, sS.qs.Jj.Sfe),
            -1 !== this.ntn && this.u8e(),
            -1 === this.atn && (this.atn = this.jW().requestAnimationFrame(this.utn),
            this.dtn = !0),
            this.ltn.push(t)
        }
        otn(t) {
            this.ntn = -1,
            this.dtn && (this.ftn = Math.max(Math.round(this.rtn.length / 10), 1),
            this.dtn = !1);
            for (let t = 0; t < this.ftn && this.rtn.length; ++t) {
                this.rtn.shift().Pte().removeAttribute("collapsed")
            }
            if (this.rtn.length && !t)
                return void (this.ntn = this.jW().requestAnimationFrame(this.htn));
            let i = this.d8e();
            i && i()
        }
        ctn(t) {
            this.atn = -1,
            this.dtn && (this.ftn = Math.max(Math.round(this.ltn.length / 10), 1),
            this.dtn = !1);
            for (let t = 0; t < this.ftn && this.ltn.length; ++t) {
                this.ltn.pop().Pte().setAttribute("collapsed", "")
            }
            if (this.ltn.length && !t)
                return void (this.atn = this.jW().requestAnimationFrame(this.utn));
            let i = this.d8e();
            i && i()
        }
        kee(t) {
            this.cte();
            const i = new sS.Event("afteranypropertychanged");
            i.Mnt = t,
            this.dispatchEvent(i)
        }
        vee(t) {
            this.cte();
            const i = new sS.Event("anypropertychangedafterblur");
            i.Mnt = t,
            this.dispatchEvent(i)
        }
        fgs(t, i, e) {
            const s = new sS.Event(t);
            s.Mnt = i,
            s.Cpe = e,
            this.dispatchEvent(s)
        }
        x8e(t) {
            return new Promise(i => {
                const e = s => {
                    s.Mnt === t && (this.removeEventListener("afteranypropertychanged", e),
                    i(t))
                }
                ;
                this.addEventListener("afteranypropertychanged", e)
            }
            )
        }
        cte() {
            this.qWt(),
            this.Etn()
        }
        qWt() {
            for (let t of this.pHs)
                t.p8e()
        }
        Etn() {
            for (let t of this.pHs)
                t.ofe()
        }
        pte() {
            return this.etn = this.V9e.scrollTop,
            this.etn
        }
        dte(t) {
            sS.cO(t),
            this.V9e.scrollTop = "number" == typeof t ? t : this.etn
        }
        eee(t) {
            sS.X_t(t),
            this.rQs = t
        }
        C7e() {
            return !!this.rQs
        }
        fQs() {
            return this.rQs
        }
        XWt(t, i, e, s, n, r, h) {
            let o = sS.v(sS.qs.Jj.M8e, this, t, i, e, null, s, n, r, !!h);
            return this.pHs.push(o),
            o
        }
        Mte(t, i, e, s, n, r) {
            let h = sS.v(sS.qs.Jj.W7s, this, t, i, null, e, s, n, !!r);
            return this.pHs.push(h),
            h
        }
        Kte(t, i, e, s, n, r) {
            let h = sS.v(sS.qs.Jj.j7e, this, t, i, null, e, s, n, !!r);
            return this.pHs.push(h),
            h
        }
        qte(t, i, e, s, n, r) {
            let h = sS.v(sS.qs.Jj.q7e, this, t, i, null, e, s, n, !!r);
            return this.pHs.push(h),
            h
        }
        zte(t, i, e, s, n, r) {
            let h = sS.v(sS.qs.Jj.u9e, this, t, i, null, e, s, n, !!r);
            return this.pHs.push(h),
            h
        }
        cse(t, i, e, s, n) {
            let r = sS.v(sS.qs.Jj.p9e, this, t, i, null, e, s, n);
            return this.pHs.push(r),
            r
        }
        Jre(t, i, e, s, n, r) {
            let h = sS.v(sS.qs.Jj.y9e, this, t, i, null, e, s, n, r);
            return this.pHs.push(h),
            h
        }
        Xse(t, i, e, s) {
            let n = sS.v(sS.qs.Jj.M9e, this, t, i, null, e, s);
            return this.pHs.push(n),
            n
        }
        VWt(t, i) {
            let e = sS.v(sS.qs.Jj.T9e, this, t, i, null);
            return this.pHs.push(e),
            e
        }
        ise(t, i, e) {
            let s = sS.v(sS.qs.Jj.A7e, this, t, i, e, null);
            return this.pHs.push(s),
            s
        }
        Ctn(t, i) {
            if (sS.Ge(t),
            sS.Ge(i),
            !sS.qs.iA.ZXe())
                return !1;
            let e = this.V9e.getBoundingClientRect()
              , s = this.K9e.getBoundingClientRect().width
              , n = e.left + s;
            return Math.abs(t - n) <= nS && i > e.top && i < e.bottom
        }
        IW(t) {
            let i = t.clientX
              , e = t.clientY;
            t.button === sS.f1.e5 && t.isPrimary && (this.ytn || this.Ctn(i, e) && (t.preventDefault(),
            t.stopPropagation(),
            this.ytn = !0,
            this.LCt = i,
            this.WCt = sS.qs.lk("div", this.V9e, null, "columnResizeIndicator"),
            this.WCt.style.height = this.W9e.getBoundingClientRect().height + "px",
            this.yGt(i)))
        }
        Gz(t) {
            if (!t.isPrimary)
                return;
            const i = t.clientX
              , e = t.clientY;
            this.Ctn(i, e) && (this.o1 || (this.o1 = sS.qs.SH.gH("col-resize", this.PH(), i, e, this.URi)))
        }
        b2(t) {
            this.H_t()
        }
        mtn(t) {
            const i = t.clientX
              , e = t.clientY;
            t.isPrimary && (this.ytn ? (this.o1 || (this.o1 = sS.qs.SH.gH("col-resize", this.PH(), i, e, this.URi)),
            this.ytn && this.yGt(i)) : this.o1 && !this.Ctn(i, e) && this.H_t())
        }
        yGt(t) {
            sS.Ge(t),
            t -= 2;
            let i = this.W9e.getBoundingClientRect()
              , e = i.left
              , s = Math.round(.1 * i.width)
              , n = Math.round(.9 * i.width)
              , r = sS.Ne(t - e, s, n);
            this.WCt.style.transform = `translate(${r}px,0px)`
        }
        wtn(t) {
            let i = t.clientX;
            t.clientY;
            if (!this.ytn)
                return;
            if (!t.isPrimary)
                return;
            this.ytn = !1,
            sS.qs.BW(this.WCt),
            this.WCt = null;
            let e = this.W9e.getBoundingClientRect()
              , s = sS.Ne((i - e.left) / e.width, .1, .9);
            this.K9e.style.width = 100 * s + "%"
        }
        gtn(t) {
            this.ytn = !1,
            sS.qs.BW(this.WCt),
            this.WCt = null,
            this.H_t()
        }
        QL() {
            let t = {
                properties: []
            };
            for (let i of this.pHs) {
                if (null !== i.bF())
                    continue;
                let e = i.QL();
                e && t.properties.push(e)
            }
            return this.pte(),
            t.scrollPosition = this.etn,
            t
        }
        tU(t) {
            if (t && t.properties) {
                this.vtn++;
                for (let i of t.properties) {
                    let t = this.D9e(i.name);
                    t && t.tU(i)
                }
                sS.Go(t.scrollPosition) && (this.etn = t.scrollPosition,
                this.dte()),
                this.vtn--
            }
        }
        Mtn() {
            return this.vtn > 0
        }
        D9e(t) {
            sS.zt(t);
            for (const i of this.pHs)
                if (i.Fa() === t)
                    return i
        }
        ubi(t) {
            sS.zt(t);
            for (const i of this.pHs)
                if (i.o8e() === t)
                    return i;
            return null
        }
        Fbi() {
            for (const t of this.pHs)
                if (t.Uht())
                    return !0;
            return !1
        }
        kH() {
            if (this.Fbi())
                for (const t of this.pHs)
                    t.kH()
        }
    }
}
{
    const oS = self.t
      , aS = oS.ek(import.meta.url)
      , lS = aS.getElementById("longTextPropertyDialog")
      , uS = "LongTextPropertyDialog"
      , cS = oS.qs.Jj._tn = class extends oS.qs.Ys {
        constructor() {
            super(lS),
            this.Ttn = aS.getElementById("longTextArea"),
            this.lKi = aS.getElementById("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = aS.getElementById("cancelButton"),
            this.lhs.onclick = () => this.tWt()
        }
        Swt() {
            this.lKi.textContent = self.lang("common.ok"),
            this.lhs.textContent = self.lang("common.cancel")
        }
        Qa(t, i) {
            return oS.zt(t),
            this.Ttn.value = t,
            super.Qa(i)
        }
        gwt() {
            this.PR(this.Ttn.value)
        }
    }
    ;
    oS.qs.HY.ipt.addEventListener("load", function() {
        oS.qs.Ys.opt(uS, cS)
    })
}
{
    const dS = self.t
      , fS = 80
      , pS = 20
      , mS = 10
      , wS = {
        title: "",
        Dk: "",
        Itn: !1,
        Ptn: !0,
        Gtn: !0,
        Atn: !0,
        Rtn: !0
    };
    dS.qs.Jj.Tab = class extends dS.Me {
        constructor(t, i) {
            super(),
            dS.Wat(i),
            i = Object.assign({}, wS, i),
            dS.zt(i.title),
            this.h2e = t,
            this.Get = dS.qs.lk("ui-tab"),
            this.Get.setAttribute("role", "tab");
            const e = this.h2e.hk();
            if ("front" !== i.ktn || this.h2e.lN())
                e.appendChild(this.Get);
            else {
                const t = this.h2e.K3e(0);
                e.insertBefore(this.Get, t.hk())
            }
            this.Otn = dS.qs.lk("span", this.Get),
            this.Otn.textContent = i.title,
            this.Vd = !1,
            this.pXs = i.title,
            this.Dtn = i.Dk,
            this.LJe = null,
            this.Ftn = !0,
            this.Ltn = !0,
            this.Dtn && this.Get.setAttribute("title", this.Dtn),
            this.Kft = !1,
            this.L9 = 0,
            this.W9 = 0,
            this.Btn = !1,
            this.Bd = null,
            this.yh = dS.v(dS.kh, dS.jh.Gh(this.Get, "pointerdown", t => this.IW(t)), dS.jh.Gh(this.Get, "contextmenu", t => this.OW(t)), dS.jh.Gh(this.Get, "auxclick", t => this.Utn(t)), dS.jh.Gh(this.Get, "click", t => this.Utn(t))),
            this.Mz = t => this.Gz(t),
            this.Oz = t => this.Cz(t),
            this.N9e = t => this.b2(t),
            i.Itn && (this.Get.setAttribute("closebutton", ""),
            this.LJe = dS.v(dS.qs.Jj.X5t, this.Get),
            this.LJe.onclick = () => this.Ntn()),
            i.className && this.Get.classList.add(i.className),
            this.VRi = !1,
            this.jtn = !1,
            this.$tn = !1,
            this.ztn = !1,
            dS.XOt(i.Ptn) ? this.VRi = i.Ptn : this.VRi = !!i.Ptn,
            dS.XOt(i.Gtn) ? this.jtn = i.Gtn : this.jtn = !!i.Gtn,
            dS.XOt(i.Atn) ? this.$tn = i.Atn : this.$tn = !!i.Atn,
            dS.XOt(i.Rtn) ? this.ztn = i.Rtn : this.ztn = !!i.Rtn,
            this.cn = !1
        }
        LUt() {
            this.yh.he(),
            this.yh = null,
            this.Get.ownerDocument.removeEventListener("pointerup", this.Oz),
            this.Oz = null,
            this.Get.ownerDocument.removeEventListener("pointercancel", this.N9e),
            this.N9e = null,
            this.Get.ownerDocument.removeEventListener("pointermove", this.Mz),
            this.Mz = null,
            this.LJe && (this.LJe.he(),
            this.LJe = null),
            dS.qs.BW(this.Otn),
            this.Otn = null,
            dS.qs.BW(this.Get),
            this.Get = null,
            this.Bd = null,
            this.h2e = null,
            this.cn = !0,
            dS.he(this)
        }
        dn() {
            return this.cn
        }
        Vtn() {
            return dS.XOt(this.VRi) ? this.VRi() : this.VRi
        }
        i4e() {
            return dS.XOt(this.jtn) ? this.jtn() : this.jtn
        }
        Y6t() {
            return dS.XOt(this.$tn) ? this.$tn() : this.$tn
        }
        e4e() {
            return dS.XOt(this.ztn) ? this.ztn() : this.ztn
        }
        Ntn() {
            this.h2e.Wtn(this, "tabclose")
        }
        Htn(t) {
            t = !!t,
            this.Ftn = t,
            this.LJe && this.LJe._K(t)
        }
        n4e() {
            return this.Ftn
        }
        Cj() {
            this.Get && this.Get.setAttribute("hide", "")
        }
        Ej() {
            this.Get && this.Get.removeAttribute("hide")
        }
        IW(t) {
            let i = t.clientX
              , e = t.clientY;
            this.Kft || 1 !== t.button && (2 !== t.button || this.Ltn) && (this.h2e.Z3e(this),
            this.Vtn() && 0 === t.button && (this.Kft = !0,
            this.L9 = i,
            this.W9 = e,
            this.Btn = !1,
            this.Get.ownerDocument.addEventListener("pointermove", this.Mz),
            this.Get.ownerDocument.addEventListener("pointerup", this.Oz),
            this.Get.ownerDocument.addEventListener("pointercancel", this.N9e)))
        }
        Utn(t) {
            if (1 === t.button)
                return t.preventDefault(),
                void this.Sk().Wtn(this, "tabmiddleclick")
        }
        Gz(t) {
            let i = t.clientX
              , e = t.clientY
              , s = t.pointerId;
            if (this.Kft) {
                if (this.h2e.Ktn() && Math.abs(i - this.L9) >= mS && (this.Btn = !0),
                this.Btn) {
                    let t = this.h2e.qtn(i, e);
                    if (t && t !== this && t.Vtn()) {
                        let s = this.ns()
                          , n = t.ns() - s
                          , r = !0;
                        return n > 0 && (this._a() < t._a() ? t.uH(i - n, e) || (r = !1) : t.uH(i + n, e) || (r = !1)),
                        void (r && this.h2e.Xtn(this, t))
                    }
                }
                if (this.jtn) {
                    let t = this.h2e.hk().getBoundingClientRect();
                    const n = pS;
                    let r = i >= t.left - n && e >= t.top - n && i <= t.right + n && e <= t.bottom + n;
                    dS.di(this.L9, this.W9, i, e) > fS && !r && dS.kt.lA && (this.Cz(),
                    this.Sk().z3e(this, i, e, s))
                }
            }
        }
        Cz(t) {
            this.Kft = !1,
            this.Btn = !1,
            this.Get.ownerDocument.removeEventListener("pointerup", this.Oz),
            this.Get.ownerDocument.removeEventListener("pointermove", this.Mz),
            this.Get.ownerDocument.removeEventListener("pointercancel", this.N9e)
        }
        b2(t) {
            this.Cz(t)
        }
        Ytn(t) {
            this.Ltn = !!t
        }
        OW(t) {
            this.Ltn && (this.h2e.W3e(this, t.clientX, t.clientY) || t.preventDefault())
        }
        Jtn(t) {
            t = !!t,
            this.Vd !== t && (dS.qs.CD(this.Get, "active", t),
            this.Vd = t)
        }
        _a() {
            return this.Get.getBoundingClientRect().left
        }
        ns() {
            let t = this.Get.getBoundingClientRect();
            return t.right - t.left
        }
        uH(t, i) {
            dS.Ge(t),
            dS.Ge(i);
            let e = this.Get.getBoundingClientRect();
            return t >= e.left && i >= e.top && t < e.right && i < e.bottom
        }
        Sk() {
            return this.h2e
        }
        iyt(t) {
            dS.zt(t),
            this.pXs !== t && (this.pXs = t,
            this.Otn.textContent = this.pXs)
        }
        cU() {
            return this.pXs
        }
        $6i(t) {
            dS.zt(t),
            this.Dtn !== t && (this.Dtn = t,
            this.Dtn ? this.Get.setAttribute("title", this.Dtn) : this.Get.removeAttribute("title"))
        }
        DYi() {
            return this.Dtn
        }
        Fie(t) {
            this.Bd = t
        }
        Pp(t) {
            return this.Bd
        }
        Kvt(t) {
            dS.Mw(t, dS.Ha),
            this.Get.style.backgroundColor = t ? t.MDe() : ""
        }
        Hvt(t) {
            dS.Mw(t, dS.Ha),
            this.Get.style.color = t ? t.MDe() : ""
        }
        hk() {
            return this.Get
        }
    }
}
{
    const gS = self.t
      , yS = new Set(["top", "bottom"])
      , bS = {
        B3e: !1,
        U3e: !1
    };
    gS.qs.Jj.L3e = class extends gS.Event.aG {
        constructor(t, i) {
            super(),
            gS.Wat(i),
            i = Object.assign({}, bS, i),
            this.hVt = t,
            this.r2e = "",
            this.Get = gS.qs.lk("ui-tabbar", this.hVt),
            this.Get.setAttribute("role", "tablist"),
            this.Ztn = !!i.B3e,
            this.Qtn = !!i.U3e,
            this.d2e = [],
            this.tin = null,
            this.N5t("bottom")
        }
        he() {
            for (let t = 0, i = this.d2e.length; t < i; ++t)
                this.d2e[t].LUt();
            gS.sc(this.d2e),
            gS.qs.BW(this.Get),
            this.Get = null,
            this.hVt = null,
            this.tin = null,
            super.he()
        }
        hk() {
            return this.Get
        }
        hX() {
            return this.tin
        }
        Ktn() {
            return this.Qtn
        }
        N5t(t) {
            if (gS.zt(t),
            !yS.has(t))
                throw new Error(`invalid tab side '${t}'`);
            this.r2e !== t && (this.Get.removeAttribute("tabbed-" + this.r2e),
            this.r2e = t,
            this.Get.setAttribute("tabbed-" + this.r2e, ""))
        }
        Q6t() {
            return this.d2e.length
        }
        K6t(t) {
            gS.U(t, gS.qs.Jj.Tab),
            self.assert(this.d2e.includes(t), "tab is not part of this tab bar");
            for (let i = 0, e = this.d2e.length; i < e; ++i)
                if (this.d2e[i] === t)
                    return i
        }
        K3e(t) {
            return gS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.d2e.length ? null : this.d2e[t]
        }
        *tabs() {
            for (let t = 0, i = this.d2e.length; t < i; ++t)
                yield this.d2e[t]
        }
        lN() {
            return 0 === this.Q6t()
        }
        L6t(t, i) {
            gS.zt(t);
            let e = Object.assign({}, {
                title: t,
                Itn: this.Ztn
            }, i)
              , s = gS.v(gS.qs.Jj.Tab, this, e);
            return "front" === e.ktn ? this.d2e.unshift(s) : this.d2e.push(s),
            this.tin || (this.tin = s,
            this.iin()),
            this.Wtn(s, "tabadd"),
            s
        }
        J3e(t) {
            if (gS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.d2e.length)
                throw new RangeError("tab index out of range");
            let i = this.d2e[t];
            if (i.LUt(),
            this.d2e.splice(t, 1),
            this.tin === i) {
                const i = Math.max(t - 1, 0);
                i < this.d2e.length ? this.Z3e(this.d2e[i], !0) : this.tin = null
            }
            this.Wtn(null, "tabremove")
        }
        X6t(t) {
            if (gS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this.d2e.length)
                throw new RangeError("tab index out of range");
            this.Z3e(this.d2e[t])
        }
        qtn(t, i) {
            gS.Ge(t),
            gS.Ge(i);
            for (let e of this.d2e)
                if (e.uH(t, i))
                    return e;
            return null
        }
        Z3e(t, i=!1) {
            if (gS.U(t, gS.qs.Jj.Tab),
            this.tin !== t) {
                if (!this.d2e.includes(t))
                    throw new Error("tab does not belong to this tab bar");
                this.tin = t,
                this.iin(),
                this.Wtn(t, "activetabchanged", i)
            }
        }
        iin() {
            for (let t = 0, i = this.d2e.length; t < i; ++t) {
                let i = this.d2e[t];
                i.Jtn(i === this.tin)
            }
        }
        Xtn(t, i) {
            gS.U(t, gS.qs.Jj.Tab),
            gS.U(i, gS.qs.Jj.Tab);
            const e = this.d2e.indexOf(t)
              , s = this.d2e.indexOf(i);
            if (e < 0 || s < 0)
                throw new Error("cannot find tab");
            this.d2e.splice(e, 1),
            this.d2e.splice(s, 0, t),
            this.ein();
            const n = new gS.Event("taborderchanged");
            n.h7t = t,
            n.nin = i,
            this.dispatchEvent(n)
        }
        ein() {
            for (let t of this.d2e)
                gS.qs.BW(t.hk());
            for (let t of this.d2e)
                this.Get.appendChild(t.hk())
        }
        z3e(t, i, e, s) {
            gS.U(t, gS.qs.Jj.Tab),
            gS.Ge(i),
            gS.Ge(e),
            gS.Ge(s);
            let n = new gS.Event("tearofftab");
            n.tab = t,
            n.clientX = i,
            n.clientY = e,
            n.pointerId = s,
            this.dispatchEvent(n)
        }
        W3e(t, i, e) {
            gS.U(t, gS.qs.Jj.Tab),
            gS.Ge(i),
            gS.Ge(e);
            let s = new gS.Event("tabcontextmenu",!0);
            return s.tab = t,
            s.clientX = i,
            s.clientY = e,
            this.dispatchEvent(s)
        }
        Wtn(t, i, e=!1) {
            gS.Mw(t, gS.qs.Jj.Tab),
            gS.zt(i);
            let s = new gS.Event(i);
            s.tab = t,
            s.Q3e = e ? "removal" : "",
            this.dispatchEvent(s)
        }
    }
}
{
    const vS = self.t
      , SS = {
        kJt: -1,
        CP: !1,
        IP: !1,
        n9t: !1,
        VJi: !1,
        kP: !1,
        LKt: !1,
        bZt: !0,
        pZt: !1,
        SKt: .5,
        gZt: " ",
        yZt: "auto",
        vZt: []
    }
      , xS = 400
      , MS = 10
      , ES = 100;
    vS.qs.Jj.OP = class extends vS.Event.aG {
        constructor(t, i) {
            super(),
            vS.Hdt(t),
            vS.Wat(i),
            i = Object.assign({}, SS, i),
            vS.Ge(i.kJt),
            this.hVt = t,
            this.rin = i.kJt,
            this.rin < 0 && (this.rin = self.app.T_()),
            this.hin = !!i.CP && vS.kt.lA,
            this.lSe = !!i.IP,
            this.oin = !!i.kP,
            this.ain = !!i.LKt,
            this.lin = !!i.n9t,
            this.uin = !!i.VJi,
            this.cin = !!i.bZt,
            this.din = !!i.pZt,
            this.fin = i.SKt,
            vS.Ge(this.fin),
            this.Get = vS.qs.lk("ui-tree", this.hVt),
            this.Get.setAttribute("role", "tree"),
            this.Get.setAttribute("tabindex", 0),
            this.Z8e = t => this.xSe(),
            this.t7e = t => this.DUt(),
            this.Get.addEventListener("focus", this.Z8e),
            this.Get.addEventListener("blur", this.t7e),
            this.l1 = t => this.IW(t),
            this.Get.addEventListener("pointerdown", this.l1),
            this.Rz = t => this.FP(t),
            this.ain ? this.Get.setAttribute("fullrowselect", "") : this.Get.setAttribute("itemselect", ""),
            this.cin && this.Get.setAttribute("wraplongitems", ""),
            this.E2t = vS.v(vS.qs.Jj.WE, this, null, null, "<root>"),
            this.pin = self.app.oi("expanded"),
            this.win = self.app.oi("collapsed"),
            this.gin = new Set,
            this.yin = 0,
            this.bin = null,
            this.vin = 0,
            this.Sin = new Set,
            this.ZCt = vS.qs.lk("div", null, null, "tree-insert-mark"),
            this.xin = null,
            this.i_t = "",
            this.Min = null,
            this.qG = -1,
            this.Xft = () => this.Ein(),
            this.Cin = 0,
            this._in = 0,
            this.Tin = 0,
            this.Iin = 0,
            this.Pin = "",
            this.Gin = new vS.gP( () => this.Ain(),ES),
            this.Gin.lW(!0),
            this.Rin = !1,
            this.kin = !0,
            this.Oin = null,
            this.Din = vS.qs.lk("div", this.Get, null, "treeNoItems"),
            this.Din.textContent = i.gZt || self.lang("ui.controls.tree.no-items-showing"),
            this.Din.setAttribute("position", i.yZt),
            this.Fin = vS.qs.lk("div", this.Din, null, "treeNoItemsOptions");
            for (const t of i.vZt) {
                vS.zt(t.text),
                vS.zt(t.tag);
                const i = vS.qs.lk("button", this.Fin, null, "treeNoItemsOption");
                i.textContent = t.text,
                i.addEventListener("click", () => this.Lin("noitemsoptionclick", {
                    tag: t.tag
                }))
            }
            this.Bin = !0,
            this.Uin = vS.qs.lk("div", null, null, "treeNoSearchResults"),
            this.Uin.setAttribute("position", i.yZt),
            this.Nin = !1
        }
        he() {
            this.Gin.he(),
            this.Gin = null,
            this.PH().removeEventListener("keydown", this.Rz),
            this.Rz = null,
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.gin.clear(),
            this.bin = null,
            this.IH(),
            this.ZCt = null,
            this.jin(),
            this.Xft = null,
            this.E2t.he(!0),
            this.E2t = null,
            vS.qs.BW(this.Uin),
            this.Uin = null,
            vS.qs.BW(this.Din),
            this.Din = null,
            this.Get.removeEventListener("focus", this.Z8e),
            this.Get.removeEventListener("blur", this.t7e),
            this.Z8e = null,
            this.t7e = null,
            vS.qs.BW(this.Get),
            this.Get = null,
            this.hVt = null,
            super.he()
        }
        LE(t) {
            t = !!t,
            this.E2t.PXt(t)
        }
        GE(t, i, e) {
            let s;
            s = t instanceof vS.qs.Jj.WE ? t : this.AE(i => i.Pp() === t),
            s && (i = !!i,
            (e = !!e) ? s.PXt(i) : s.VE(!1, i))
        }
        $E(t) {
            t = !!t,
            this.E2t.vXt(t)
        }
        JE(t, i, e) {
            let s;
            s = t instanceof vS.qs.Jj.WE ? t : this.AE(i => i.Pp() === t),
            i = !!i,
            (e = !!e) ? s.vXt(i) : s.VE(!0, i)
        }
        $in(t) {
            if (vS.U(t, vS.qs.Jj.WE),
            t.mXt() !== this)
                throw new Error("item from different tree")
        }
        zin(t) {
            if (vS.Mw(t, vS.qs.Jj.WE),
            t && t.mXt() !== this)
                throw new Error("item from different tree")
        }
        AE(t) {
            return this.E2t.AE(t)
        }
        tC() {
            this.IH(),
            this.E2t.oN(),
            this.wXt(!1),
            this.Vin()
        }
        Igs() {
            return this.rin
        }
        UE() {
            return this.E2t
        }
        hk() {
            return this.Get
        }
        PH() {
            return this.Get.ownerDocument
        }
        jW() {
            return this.PH().defaultView
        }
        Win() {
            return this.pin
        }
        Hin() {
            return this.win
        }
        Kin() {
            return this.hin
        }
        qin() {
            return this.lSe
        }
        Xin() {
            return this.lin
        }
        Yin() {
            return this.uin
        }
        Jin() {
            return this.oin
        }
        Zin(t) {
            this.oin = !!t
        }
        Qin() {
            return this.ain
        }
        ten() {
            return this.din
        }
        _zi(t) {
            this.$in(t),
            this.gin.add(t),
            this.ien(t, "itemselect")
        }
        een(t) {
            this.$in(t),
            this.gin.delete(t)
        }
        lN() {
            return ![...this.rh()].length
        }
        wF() {
            let t = 0;
            for (const i of this.qB())
                ++t;
            return t
        }
        Gwt() {
            for (const t of this.gin)
                t.sen(),
                t.bEi();
            for (const t of this.Sin.values())
                t.sen(),
                t.bEi()
        }
        gF(t=!1) {
            const i = this.bin;
            this.yin++;
            for (const t of this.gin)
                t.Dwt(!1);
            this.yin--,
            this.bin = t ? i : null,
            self.assert(0 === this.gin.size, "should have deleted all selected items")
        }
        nen(t=!1) {
            const i = this.bin;
            this.yin++;
            for (const t of this.gin)
                t.ren(!1);
            this.yin--,
            this.gin.clear(),
            this.bin = t ? i : null,
            self.assert(0 === this.gin.size, "should have deleted all selected items")
        }
        *qB() {
            for (const t of this.gin.values())
                t.OYt() || (yield t)
        }
        yF() {
            return vS.eu(this.qB())
        }
        KH() {
            let t = [];
            for (let i of this.qB())
                t.push(i);
            return this.hen(t),
            t
        }
        oen(t) {
            this.zin(t),
            this.bin = t
        }
        aen() {
            return this.bin
        }
        rh() {
            return this.E2t.rh()
        }
        $Ie() {
            return this.E2t.$Ie()
        }
        _Vt(t, i) {
            vS.zt(t);
            const e = t.toLowerCase();
            for (const t of this.rh())
                if ((i || t.Cmt()) && t.VB().toLowerCase().startsWith(e))
                    return t;
            return null
        }
        bHi() {
            return this.yin > 0
        }
        len(t, i) {
            if (this.$in(t),
            this.$in(i),
            t === i)
                return void t.Dwt(!0);
            this.yin++;
            let e = !1
              , s = null
              , n = [];
            for (let r of this.rh())
                if (e || (r === t ? (e = !0,
                s = i) : r === i && (e = !0,
                s = t)),
                e && (n.push(r),
                r === s))
                    break;
            s === t && n.reverse();
            for (let t of n)
                t.Dwt(!0);
            this.yin--
        }
        OR(t) {
            this.yin++;
            for (const i of t)
                this.$in(i),
                i.Dwt(!0);
            this.yin--
        }
        uen(t) {
            let i;
            this.yin++;
            for (const e of t)
                i || (i = e),
                e.ren(!0);
            this.gin = new Set(t),
            this.yin--,
            this.oen(i)
        }
        xSe() {
            this.PH().addEventListener("keydown", this.Rz)
        }
        DUt() {
            this.PH().removeEventListener("keydown", this.Rz)
        }
        IW(t) {
            if (t.target !== this.Get || vS.OF.j1(t) || t.shiftKey)
                return;
            const i = this.Get.getBoundingClientRect()
              , e = i.left + this.Get.clientWidth
              , s = i.top + this.Get.clientHeight;
            i.left < t.clientX && e > t.clientX && i.top < t.clientY && s > t.clientY && (this.Lin("emptyspaceclick"),
            this.gF())
        }
        FP(t) {
            if (1 !== this.wF())
                return;
            const i = t.which;
            if (i !== vS.kE.K7 && i !== vS.kE.j7)
                return;
            const e = this.yF()
              , s = [...this.$Ie()];
            let n = s.indexOf(e);
            n < 0 || (i === vS.kE.K7 ? --n : ++n,
            n < 0 || n >= s.length || (s[n].YB(),
            s[n].WB(),
            t.preventDefault()))
        }
        cen() {
            return this.fin
        }
        uH(t, i, e, s, n) {
            vS.Ge(t),
            vS.Ge(i),
            vS.Kq(e),
            vS.E$(n, vS.qs.Jj.WE),
            e = e || "full",
            s = !!s;
            const r = this.Get.getBoundingClientRect();
            if (t < r.left || i < r.top || t > r.right || i > r.bottom)
                return null;
            for (const s of n ?? this.rh()) {
                if (!s || s.WXt())
                    continue;
                const n = s.uH(t, i, e);
                if (n)
                    return {
                        item: s,
                        FH: n.FH,
                        BH: n.BH
                    }
            }
            return s && t > r.left && i > r.top && t < r.right && i < r.bottom ? {
                item: this,
                FH: "tree",
                BH: !1
            } : null
        }
        JH(t, i) {
            if (this.$in(t),
            vS.zt(i),
            t !== this.xin || i !== this.i_t) {
                if (this.IH(),
                "inside" === i)
                    t.QE().setAttribute("insert-inside", "");
                else {
                    if ("before" !== i && "after" !== i)
                        throw new Error("invalid insert mark type");
                    {
                        let e = t.hk();
                        e.parentElement.insertBefore(this.ZCt, "before" === i ? e : e.nextSibling)
                    }
                }
                this.xin = t,
                this.i_t = i
            }
        }
        IH() {
            this.i_t && ("inside" === this.i_t ? this.xin.QE().removeAttribute("insert-inside") : "before" !== this.i_t && "after" !== this.i_t || vS.qs.BW(this.ZCt),
            this.xin = null,
            this.i_t = "")
        }
        den() {
            return this.xin
        }
        yE(t) {
            !this.Min && this.jW() && (this.Min = t,
            this.Iin = 0,
            this.Cin = performance.now(),
            this.qG = this.jW().requestAnimationFrame(this.Xft))
        }
        bE(t, i) {
            this.Min && (this._in = t,
            this.Tin = i)
        }
        Ein() {
            if (this.qG = -1,
            !this.Min || !this.jW())
                return;
            let t = performance.now()
              , i = (t - this.Cin) / 1e3;
            this.Cin = t;
            let e = this.Get.getBoundingClientRect();
            if (this._in >= e.left && this._in <= e.right)
                if (this.Tin < e.top + MS) {
                    let t = this.Get.scrollTop - xS * i - this.Iin;
                    this.Iin = Math.ceil(t) - t,
                    t = Math.ceil(t),
                    this.Get.scrollTop = t
                } else if (this.Tin > e.bottom - MS) {
                    let t = this.Get.scrollTop + xS * i + this.Iin;
                    this.Iin = t - Math.floor(t),
                    t = Math.floor(t),
                    this.Get.scrollTop = t
                }
            this.qG = this.jW().requestAnimationFrame(this.Xft)
        }
        bXt() {
            return this.Min
        }
        OH() {
            return !!this.Min
        }
        Uht() {
            return this.OH()
        }
        jin() {
            this.Min = null,
            -1 !== this.qG && this.jW() && (this.jW().cancelAnimationFrame(this.qG),
            this.qG = -1)
        }
        kH() {
            if (this.Min)
                this.Min.fen(),
                this.Min.pen(),
                this.jin();
            else
                for (const t of this.rh())
                    t.fen()
        }
        men(t, i) {
            this.vin += t ? 1 : -1,
            t ? this.Sin.add(i) : this.Sin.delete(i)
        }
        RD() {
            return this.vin > 0
        }
        hen(t) {
            vS._D(t);
            for (let i of t)
                this.$in(i);
            this.wen(),
            t.sort(vS.qs.Jj.WE.gen)
        }
        wen() {
            let t = 0;
            for (let i of this.rh())
                i.yen(t++)
        }
        Lin(t, i) {
            vS.zt(t);
            let e = new vS.Event(t,!0);
            return e.BXt = this,
            this.dispatchEvent(Object.assign(e, i))
        }
        ien(t, i, e) {
            this.$in(t),
            vS.zt(i);
            let s = new vS.Event(i,!0);
            return s.item = t,
            s.ctrlKey = vS.OF.PF(vS.kE.oSi),
            s.metaKey = vS.OF.PF(vS.kE.w$e),
            s.shiftKey = vS.OF.PF(vS.kE.CF),
            this.dispatchEvent(Object.assign(s, e))
        }
        ben(t, i, e, s) {
            this.$in(t),
            vS.zt(i),
            vS.Ge(e),
            vS.Ge(s);
            let n = new vS.Event(i,!0);
            return n.item = t,
            n.clientX = e,
            n.clientY = s,
            n.ctrlKey = vS.OF.PF(vS.kE.oSi),
            n.metaKey = vS.OF.PF(vS.kE.w$e),
            n.shiftKey = vS.OF.PF(vS.kE.CF),
            this.dispatchEvent(n)
        }
        uE(t, i) {
            this.$in(t);
            let e = new vS.Event("itemcontextmenu",!0);
            return e.item = t,
            e.clientX = i.clientX,
            e.clientY = i.clientY,
            this.dispatchEvent(e)
        }
        _E(t, i) {
            vS.zt(t),
            vS.Wat(i),
            this.Rin = !1,
            this.kin = !0,
            i && (this.Rin = !!i.FE,
            this.kin = !!i.ven,
            vS.cke(i.Sen),
            this.Oin = i.Sen),
            this.Pin = t,
            i && i.TE ? this.Ain() : this.Gin.IF()
        }
        Ain() {
            const t = this.Pin.toLowerCase();
            let i = !0
              , e = !1;
            const s = new Set;
            for (const n of this.rh())
                if (t) {
                    let r = n.VB().toLowerCase().includes(t);
                    if (this.Oin && !r)
                        for (const i of this.Oin)
                            if (r = i(n, n.Pp(), t),
                            r)
                                break;
                    if (n.xen(r),
                    r)
                        e = !0,
                        i && (this.Rin && n.YB(),
                        i = !1);
                    else {
                        const t = n.bF();
                        t && !t.vF() && t.OZs() && (s.add(n),
                        n.Men())
                    }
                } else
                    n.Men(),
                    e = !0;
            for (const t of this.rh()) {
                if (!t.OZs() || !t.gX())
                    continue;
                const i = t.CJ().some(t => t.OZs());
                t.Een(i, !0)
            }
            for (const t of s.values()) {
                const i = t.Pp();
                if (vS.$l(i, self.jF) || vS.XOt(i.PB)) {
                    if (!t.gX()) {
                        t.xen(!1);
                        break
                    }
                    t.CJ().some(t => t.OZs()) || t.xen(!1)
                }
            }
            if (!t) {
                for (const t of this.rh())
                    t.Cen();
                if (this.kin) {
                    const t = this.yF();
                    t && t.Cmt() && t.WB()
                }
            }
            this.wXt(t && !e),
            this.Vin();
            const n = new vS.Event("searchresultsupdate");
            this.dispatchEvent(n)
        }
        zXt(t) {
            vS.zt(t),
            this.Din.textContent = t
        }
        HXt(t) {
            t = !!t,
            this.Fin.style.display = t ? "" : "none"
        }
        Vin() {
            const t = ![...this.rh()].length;
            this.Bin = t,
            this.Bin ? (this.Get.contains(this.Din) || this.Get.appendChild(this.Din),
            this.Din.contains(this.Fin) || this.Din.appendChild(this.Fin)) : this.Get.contains(this.Din) && vS.qs.BW(this.Din)
        }
        dXt() {
            return this.Nin
        }
        wXt(t) {
            this.Nin !== t ? (this.Nin = t,
            this.Nin ? (this.Get.contains(this.Uin) || this.Get.appendChild(this.Uin),
            this.Uin.textContent = self.tP("ui.controls.tree.no-text-search-results", this.Pin)) : vS.qs.BW(this.Uin)) : this.Nin && (this.Get.contains(this.Uin) || this.Get.appendChild(this.Uin),
            this.Uin.textContent = self.tP("ui.controls.tree.no-text-search-results", this.Pin))
        }
        QL() {
            return {
                name: this.E2t.VB(),
                children: [...this.E2t.children()].map(t => t.QL())
            }
        }
        tU(t) {
            if (vS._U(t),
            !t)
                return;
            if (this.Pin)
                return;
            this.ien(this.E2t, "setjson");
            const i = [...this.E2t.children()];
            for (let e = 0; e < i.length; e++) {
                const s = i[e];
                s && s.tU(this._en(s, t.children), [])
            }
            this.ien(this.E2t, "setjsonfinish")
        }
        _en(t, i) {
            const e = t.VB();
            for (let t = 0; t < i.length; t++) {
                if (e === i[t].name)
                    return i[t]
            }
        }
        oV(t, i, e) {
            if (vS._U(t),
            vS.Ge(i),
            vS.qd(e),
            !t)
                return;
            if (this.Pin)
                return;
            let s = this.AE(e)
              , n = t.children[i];
            s && n && s.tU(n)
        }
    }
}
{
    const CS = self.t
      , _S = self.assert;
    let TS = [{
        height: ""
    }, {
        height: ""
    }];
    const IS = {
        duration: 200,
        easing: "ease"
    }
      , PS = {
        enable: !0,
        addToParent: !0
    }
      , GS = 700
      , AS = 10;
    CS.qs.Jj.WE = class t extends CS.Me {
        constructor(t, i, e, s, n, r, h) {
            if (CS.U(t, CS.qs.Jj.OP),
            CS.Mw(i, CS.qs.Jj.WE),
            CS.zt(s),
            CS.cO(r),
            CS._U(h),
            super(),
            h = Object.assign({}, PS, h),
            !(null == e || CS.doe(e) || e instanceof CS.qs.O_))
                throw new TypeError("invalid icon");
            this.PP = t,
            this.hVt = i || null,
            this.X1t = CS.doe(e) ? self.app.oi(e) : e,
            this.win = null,
            this._S = s,
            this.Bd = n,
            this.BLs = h.enable,
            this.Get = null,
            this.Pbt = null,
            this.ali = !0,
            this.Ten = !1,
            this.Rmt = null,
            this.Ien = "",
            this.zIs = [],
            this.Pen = !1,
            this.Gen = !1,
            this.Aen = null,
            this.l1 = null,
            this.Ren = -1,
            this.ken = t => this.Oen(),
            this.Den = !0,
            this.Fen = t => this.Len(t),
            this.Ben = 0,
            this.Uen = 0,
            this.XCt = -1,
            this.L9 = 0,
            this.W9 = 0,
            this.Kft = !1,
            this.Mz = null,
            this.Oz = null,
            this.N9e = null,
            this.Nen = null,
            this.jen = 0,
            this.$en = 0,
            this.gpt = t => this.GW(t),
            this.Ubt = t => this.Vbt(t),
            this.Pmt = t => this.Umt(),
            this.zen = null,
            this.wpt = !1,
            this.P8 = t => this.OW(t),
            this.Ven = null,
            this.Wen = null,
            this.Hen = null,
            this.wat = null,
            this.Ken = null,
            this.qen = null,
            this.v9e = null,
            this.jet = null,
            this.Xen = null,
            this.Yen = null,
            this.p7e = null,
            this.Jen = null,
            this.Zen = null,
            this.Qen = -1,
            this.vF() || (h.addToParent ? this.Get = CS.qs.lk("ui-treeitem", this.hVt.GYt(), null, null, null, r) : this.Get = CS.qs.lk("ui-treeitem"),
            this.Get.setAttribute("role", "treeitem"),
            this.Get.addEventListener("contextmenu", this.P8),
            this.BLs || this.Get.setAttribute("disable", ""),
            this.Pbt = CS.v(CS.qs.kmt, this.PP.Win().n5e(), this.Get),
            this.zen = CS.qs.lk("div", this.Get, null, "tree-item-wrap"),
            this.kN().addEventListener("UIDoubleTap", this.gpt),
            this.wat = CS.v(CS.qs.kmt, this.X1t || this.PP.Igs(), this.zen),
            this.Ken = t => this.tsn(t),
            this.wat.hk().addEventListener("pointerdown", this.Ken),
            this.v9e = CS.qs.lk("span", this.zen, null, "tree-item-name"),
            this.v9e.textContent = this._S,
            this.Jen = t => this.isn(),
            this.l1 = t => this.IW(t),
            this.kN().addEventListener("pointerdown", this.l1),
            this.Mz = t => this.Gz(t),
            this.Oz = t => this.Cz(t),
            this.N9e = t => this.b2(t)),
            this.esn = !1,
            this.cn = !1,
            this.O6t = !1
        }
        ssn(t) {
            t = !!t,
            this.Gen = t
        }
        IB(t) {
            return this.Gen
        }
        oN() {
            this.Nmt(),
            this.Pen = !0;
            for (let t = this.zIs.length - 1; t >= 0; --t) {
                let i = this.zIs[t];
                i.ssn(!0),
                i.he()
            }
            CS.sc(this.zIs),
            this.Pen = !1,
            this.gYt()
        }
        HWs(t) {
            if (CS.U(t, CS.qs.Jj.WE),
            t.WXt())
                return;
            if (this.Pen)
                return;
            let i = this.zIs.indexOf(t);
            _S(i >= 0, "cannot find child to remove"),
            this.zIs.splice(i, 1),
            this.zIs.length || this.gYt()
        }
        DXt() {
            _S(this.mXt().ten(), "configure tree to use detachable items"),
            this.mXt().Gwt();
            const t = [];
            for (const i of this.rh())
                i.Fpt(),
                t.push(i);
            return this.GYt() && CS.qs.BYt(this.GYt()),
            CS.sc(this.zIs),
            this.gYt(),
            t
        }
        Fpt() {
            this.bEi(),
            this.sen(),
            this.Nmt(),
            this.Dwt(!1),
            this.esn = !0,
            CS.sc(this.zIs),
            this.gYt()
        }
        he(t) {
            if (!this.cn) {
                if (this.cn = !0,
                this.vF() && !t)
                    throw new Error("root item cannot be removed");
                if (this.sen(),
                this.Fen = null,
                this.bEi(),
                this.Nmt(),
                this.Dwt(!1),
                this.PP.aen() === this && (this.PP.wF() >= 1 ? this.PP.oen(this.PP.yF()) : this.PP.oen(null)),
                this.PP.den() === this && this.PP.IH(),
                this.Kft && this.PP.kH(),
                this.oN(),
                this.Pmt = null,
                this.Jen = null,
                this.vF() || (this.kN().removeEventListener("UIDoubleTap", this.gpt),
                this.kN().removeEventListener("pointerdown", this.l1),
                this.PH().removeEventListener("pointermove", this.Mz),
                this.PH().removeEventListener("pointerup", this.Oz),
                this.PH().removeEventListener("pointercancel", this.N9e)),
                this.Pbt && (this.Pbt.hk().removeEventListener("UITap", this.Ubt),
                this.Pbt.he(),
                this.Pbt = null),
                this.Aen && (CS.qs.BW(this.Aen),
                this.Aen = null),
                this.v9e && (CS.qs.BW(this.v9e),
                this.v9e = null),
                this.Nen && (CS.qs.BW(this.Nen),
                this.Nen = null),
                this.Ven && (this.Ven.removeEventListener("change", this.Wen),
                this.Wen = null,
                this.Ven.removeEventListener("UIDoubleTap", this.Hen),
                this.Hen = null,
                this.Ven.removeEventListener("pointerdown", CS.qs.ck),
                CS.qs.BW(this.Ven),
                this.Ven = null),
                this.wat && (this.wat.hk().removeEventListener("pointerdown", this.Ken),
                this.Ken = null,
                this.wat.he(),
                this.wat = null),
                this.qen) {
                    for (const t of this.qen.values())
                        t.nsn.he();
                    this.qen.clear(),
                    this.qen = null
                }
                this.zen && (CS.qs.BW(this.zen),
                this.zen = null),
                this.Get && (this.Get.removeEventListener("contextmenu", this.P8),
                CS.qs.BW(this.Get),
                this.Get = null),
                this.P8 = null,
                this.gpt = null,
                this.l1 = null,
                this.Mz = null,
                this.Oz = null,
                this.N9e = null,
                this.ken = null,
                this.Ubt = null,
                this.hVt && -1 !== this.hVt.RE(this) && this.hVt.HWs(this),
                this.hVt && !this.hVt.gX() && this.gYt(),
                this.vF() || this.PP.ien(this, "itemremove"),
                this.X1t = null,
                this.Bd = null,
                this.PP = null,
                this.hVt = null,
                CS.he(this)
            }
        }
        hk() {
            return this.Get
        }
        QE() {
            return this.zen
        }
        nZi() {
            return this.v9e
        }
        kN() {
            return this.PP.Qin() ? this.Get : this.zen
        }
        mXt() {
            return this.PP
        }
        rsn(t) {
            this.PP = t
        }
        PH() {
            return this.Get.ownerDocument
        }
        _K(t) {
            t = !!t,
            this.BLs !== t && (this.BLs = t,
            this.BLs ? this.Get.removeAttribute("disable") : this.Get.setAttribute("disable", ""))
        }
        aZ() {
            return this.BLs
        }
        WXt() {
            return this.esn
        }
        dn() {
            return this.cn
        }
        *rh() {
            this.vF() || (yield this);
            for (const t of this.zIs)
                yield*t.rh()
        }
        *$Ie() {
            if (this.vF() || (yield this),
            this.hsn())
                for (const t of this.zIs)
                    t.OYt() || (yield*t.$Ie())
        }
        *children() {
            for (let t of this.zIs)
                yield t
        }
        IW(t) {
            if (t.button !== CS.f1.e5)
                return;
            const i = t.clientX
              , e = t.clientY;
            this.PP.ben(this, "itemdown", i, e),
            this.kN().setAttribute("pointerheld", ""),
            this.PH().addEventListener("pointermove", this.Mz),
            this.PH().addEventListener("pointerup", this.Oz),
            this.PH().addEventListener("pointercancel", this.N9e),
            this.XCt = t.pointerId,
            this.L9 = i,
            this.W9 = e,
            this.Kft = !1,
            "match" === this.Ien && this.osn(!0),
            t.stopPropagation()
        }
        Gz(t) {
            if (t.pointerId !== this.XCt)
                return;
            const i = t.clientX
              , e = t.clientY;
            if (t.stopPropagation(),
            this.PP.Jin() && !this.Kft && CS.di(this.L9, this.W9, i, e) >= AS) {
                if (this.kN().removeAttribute("pointerheld", ""),
                !this.PP.ben(this, "dragstart", i, e))
                    return this.XCt = -1,
                    this.PH().removeEventListener("pointermove", this.Mz),
                    this.PH().removeEventListener("pointerup", this.Oz),
                    this.PH().removeEventListener("pointercancel", this.N9e),
                    void (this.bq() || this.YB());
                {
                    this.Kft = !0,
                    this.sen(),
                    this.PP.oen(this),
                    this.bq() || this.YB();
                    for (let t of this.PP.qB())
                        t.kN().setAttribute("dragged", "");
                    1 === this.PP.wF() ? (this.Nen = this.zen.cloneNode(!0),
                    this.Nen.removeAttribute("selected"),
                    this.Nen.setAttribute("drag-thumbnail", "")) : (this.Nen = this.v9e.cloneNode(!0),
                    this.Nen.setAttribute("drag-thumbnail", ""),
                    this.Nen.textContent = self.iG("ui.controls.tree.multi-select-drag-tooltip", null, this.PP.wF()));
                    let t = CS.Edi(this.Get, "dialog");
                    if (t) {
                        t.appendChild(this.Nen);
                        let i = CS.qs.Ys.lZe(t);
                        this.jen = i.byi(),
                        this.$en = i.yyi()
                    } else
                        this.PH().body.appendChild(this.Nen);
                    this.PP.yE(this)
                }
            }
            this.Kft && (t.preventDefault(),
            this.PP.ben(this, "dragmove", i, e),
            this.Nen.style.left = i - this.jen + "px",
            this.Nen.style.top = e - this.$en + "px",
            this.PP.bE(i, e))
        }
        Len(t) {
            this.Ben = t.clientX,
            this.Uen = t.clientY
        }
        Cz(t) {
            if (t.pointerId !== this.XCt)
                return;
            const i = t.clientX
              , e = t.clientY;
            if (this.kN().removeAttribute("pointerheld", ""),
            this.PH().removeEventListener("pointermove", this.Mz),
            this.PH().removeEventListener("pointerup", this.Oz),
            this.PH().removeEventListener("pointercancel", this.N9e),
            this.Kft)
                this.pen(),
                this.PP.jin(),
                this.PP.ben(this, "drop", i, e);
            else {
                if (t.target === this.Ven)
                    return;
                let s = !1;
                s = 1 === this.PP.wF() || this.PP.Yin(),
                this.PP.Kin() && this.bq() && s && this.uH(i, e, "label") && (this.sen(),
                t.target !== this.wat.hk() && (this.Ben = i,
                this.Uen = e,
                this.PH().addEventListener("pointermove", this.Fen),
                this.Ren = setTimeout(this.ken, GS))),
                this.PP.ben(this, "itemclick", i, e);
                let n = this.PP.aen();
                if (this.PP.qin()) {
                    let t = CS.OF.j1()
                      , s = CS.OF.PF(CS.kE.CF);
                    if (t && s && n)
                        return this.PP.len(this, n),
                        this.bq() && this.PP.oen(this),
                        this.PP.Xin() && this.asn(!0),
                        void this.PP.ben(this, "afteritemclick", i, e);
                    if (t) {
                        let t = !this.bq();
                        return this.Dwt(t),
                        this.bq() && this.PP.oen(this),
                        this.PP.Xin() && this.asn(t),
                        void this.PP.ben(this, "afteritemclick", i, e)
                    }
                    if (s && n)
                        return this.PP.gF(!0),
                        this.PP.len(this, n),
                        this.PP.Xin() && (this.asn(!0),
                        n.asn(!0)),
                        void this.PP.ben(this, "afteritemclick", i, e)
                }
                this.PP.oen(this),
                this.lsn(!1),
                this.PP.gF(),
                this.Dwt(!0),
                this.lsn(!0),
                this.PP.Xin() && this.asn(!0),
                this.PP.ben(this, "afteritemclick", i, e)
            }
        }
        b2(t) {
            this.kN().removeAttribute("pointerheld", ""),
            this.PH().removeEventListener("pointermove", this.Mz),
            this.PH().removeEventListener("pointerup", this.Oz),
            this.PH().removeEventListener("pointercancel", this.N9e),
            this.bEi(),
            this.sen(),
            this.PP.gF(),
            this.pen(),
            this.PP.jin()
        }
        fen() {
            -1 !== this.XCt && (this.kN().removeAttribute("pointerheld", ""),
            this.PH().removeEventListener("pointermove", this.Mz),
            this.PH().removeEventListener("pointerup", this.Oz),
            this.PH().removeEventListener("pointercancel", this.N9e))
        }
        pen() {
            this.Kft = !1,
            this.XCt = -1;
            for (const t of this.PP.qB())
                t.kN().removeAttribute("dragged");
            CS.qs.BW(this.Nen),
            this.Nen = null
        }
        asn(t) {
            if (t = !!t,
            this.gX())
                for (let i of this.children())
                    i.Dwt(t)
        }
        GW(t) {
            this.sen(),
            this.PP.ien(this, "itemdoubletap") && this.Aen && this.Lmt(!0)
        }
        tsn(t) {
            this.sen(),
            t.button === CS.f1.e5 && (this.PP.ien(this, "itemiconclick") || t.stopPropagation())
        }
        AE(t) {
            if (CS.qd(t),
            t(this))
                return this;
            for (let i = 0; i < this.zIs.length; i++) {
                let e = this.zIs[i].AE(t);
                if (e)
                    return e
            }
        }
        GYt() {
            return this.vF() ? this.PP.hk() : this.Aen
        }
        gX() {
            return this.zIs.length > 0
        }
        kJ() {
            return this.zIs
        }
        *CJ() {
            for (const t of this.zIs)
                yield t,
                yield*t.CJ()
        }
        usn() {
            return this.zIs.length
        }
        RE(t) {
            return CS.U(t, CS.qs.Jj.WE),
            this.zIs.indexOf(t)
        }
        vF() {
            return !this.hVt
        }
        bF() {
            return this.hVt
        }
        VH(i) {
            let e, s;
            CS.XOt(i) ? s = i : e = i,
            e && CS.U(e, t),
            s && CS.qd(s);
            for (let t of this.tpt())
                if (e) {
                    if (t === e)
                        return !0
                } else if (s && s(t))
                    return !0;
            return !1
        }
        *tpt() {
            let t = this.bF();
            for (; t; )
                yield t,
                t = t.vF() ? null : t.bF()
        }
        VB() {
            return this._S
        }
        pa(t) {
            CS.zt(t),
            this._S !== t && (this._S = t,
            this.jet || (this.v9e.textContent = t))
        }
        Fie(t) {
            this.Bd = t
        }
        Pp(t) {
            return this.Bd
        }
        uH(t, i, e) {
            let s;
            if (CS.Ge(t),
            CS.Ge(i),
            CS.zt(e),
            "label" === e)
                s = this.zen.getBoundingClientRect();
            else {
                if ("full" !== e)
                    throw new Error("invalid hit test type");
                s = this.Get.getBoundingClientRect()
            }
            if (t < s.left || t > s.right || i < s.top || i > s.bottom)
                return null;
            const n = (1 - this.PP.cen()) / 2;
            let r = s.bottom - s.top
              , h = s.top + r * n
              , o = s.bottom - r * n
              , a = i >= s.top + r / 2
              , l = i > h && i <= o;
            return a && !l && this.hsn() && this.gX() && (l = !0),
            {
                FH: a ? "after" : "before",
                BH: l
            }
        }
        csn() {
            if (this.$Jt(),
            this.hsn())
                for (let t of this.zIs)
                    t.csn()
        }
        CA(t) {
            if (!(CS.doe(t) || t instanceof CS.qs.O_))
                throw new TypeError("invalid icon");
            this.wat && (CS.doe(t) ? this.wat.CA(self.app.oi(t)) : this.wat.CA(t))
        }
        dsn(t, i) {
            if (CS.zt(t),
            !(CS.doe(i) || i instanceof CS.qs.O_))
                throw new TypeError("invalid icon");
            const e = this.qen.get(t);
            e && (CS.doe(i) ? e.nsn.CA(self.app.oi(i)) : e.nsn.CA(i))
        }
        NN(t) {
            CS.qd(t),
            this.wat && (this.wat.NN(t),
            this.Cmt() && this.$Jt())
        }
        $Jt() {
            this.wat.$Jt()
        }
        Cmt() {
            let t = this.hVt;
            for (; t; ) {
                if (!t.hsn())
                    return !1;
                t = t.hVt
            }
            return !0
        }
        osn(t) {
            t = !!t;
            for (const i of this.tpt())
                i.vF() || (i.ali = t)
        }
        Vbt(t) {
            t.detail.PY === CS.f1.e5 && this.Lmt(!0)
        }
        OB() {
            return this.ali
        }
        hsn() {
            return this.OZs() ? this.Ten : this.OB() || this.Ten
        }
        fsn(t) {
            return !!((t = !!t) && this.Cmt() && self.app.zmt())
        }
        psn(t) {
            return (!(t = !!t) || t && this.$mt()) && !!this.Rmt
        }
        VE(t, i, e) {
            if (this.vF())
                throw new Error("cannot change expanded state of root item");
            if (t = !!t,
            i = !!(i && this.Cmt() && self.app.zmt()),
            !this.Aen)
                return e || (this.ali = t),
                void this.Pbt.CA(null);
            (!i || i && this.$mt()) && (this.Nmt(),
            i = !1);
            if (this.hsn() !== t)
                if (t) {
                    if (e ? this.Ten = !0 : this.ali = !0,
                    this.Aen.removeAttribute("collapsed"),
                    this.gX() ? (this.Pbt.CA(this.PP.Win()),
                    this.win && this.wat.CA(this.X1t)) : (this.Pbt.CA(null),
                    this.wat.CA(this.X1t)),
                    e || this.msn(i),
                    this.Cmt() && this.csn(),
                    i) {
                        let t = this.Aen.getBoundingClientRect()
                          , i = t.bottom - t.top;
                        TS[0].height = "0px",
                        TS[1].height = `${i}px`,
                        this.Aen.style.overflow = "hidden",
                        this.Rmt = this.Aen.animate(TS, IS),
                        this.Rmt.onfinish = this.Pmt
                    }
                } else if (this.Ten = !1,
                e || (this.ali = !1),
                this.gX() ? (this.Pbt.CA(this.PP.Hin()),
                this.win && this.wat.CA(this.win)) : (this.Pbt.CA(null),
                this.wat.CA(this.X1t)),
                e || this.msn(i),
                i) {
                    let t = this.Aen.getBoundingClientRect()
                      , i = t.bottom - t.top;
                    TS[0].height = `${i}px`,
                    TS[1].height = "0px",
                    this.Aen.style.overflow = "hidden",
                    this.Rmt = this.Aen.animate(TS, IS),
                    this.Rmt.onfinish = this.Pmt
                } else
                    this.Aen.setAttribute("collapsed", "")
        }
        Cen() {
            this.ali ? this.Aen && this.Aen.hasAttribute("collapsed") ? (this.ali = !1,
            this.Ten = !1,
            this.VE(!0, !1)) : this.VE(this.ali, !1) : this.Aen && !this.Aen.hasAttribute("collapsed") ? (this.ali = !0,
            this.Ten = !1,
            this.VE(!1, !1)) : this.VE(this.ali, !1)
        }
        msn(t) {
            this.O6t || this.PP.ien(this, "itemexpand", {
                EYt: t
            })
        }
        wsn() {
            let t = this.hVt;
            for (; t; ) {
                if (!t.vF() && t.hsn())
                    return !0;
                t = t.bF()
            }
            return !1
        }
        gsn() {
            let t = this.hVt;
            for (; t; ) {
                if (!t.vF() && !t.hsn())
                    return !0;
                t = t.bF()
            }
            return !1
        }
        ysn() {
            if (!this.vF() && this.hsn())
                return !0;
            for (const t of this.rh())
                if (t.hsn())
                    return !0;
            return !1
        }
        bsn() {
            if (!this.vF() && !this.hsn())
                return !0;
            for (const t of this.rh())
                if (!t.hsn())
                    return !0;
            return !1
        }
        vXt(t, i=!0, e=[]) {
            let s;
            t = !!t,
            (i = !!i) && (s = this.bsn(),
            s && this.PP.ien(this, "itemexpandmany"));
            let n = null;
            if (!this.vF()) {
                if (t = this.fsn(t),
                (t = this.psn(t)) && this.Aen && !this.hsn()) {
                    const t = new Promise(t => {
                        n = i => {
                            i.item === this && t()
                        }
                        ,
                        this.PP.addEventListener("itemexpandfinish", n)
                    }
                    );
                    e.push({
                        promise: t,
                        item: this,
                        vsn: n
                    })
                }
                this.VE(!0, t)
            }
            let r = this.zIs.length;
            for (let i = 0; i < r; i++)
                this.zIs[i].vXt(t, !1, e);
            i && CS.Dee(s) && s ? e.length ? Promise.all(e.map(t => t.promise)).then( () => {
                e.forEach(t => this.PP.removeEventListener("itemexpandfinish", t.vsn)),
                this.PP.ien(this, "itemexpandmanyfinish")
            }
            ) : this.PP.ien(this, "itemexpandmanyfinish") : e.forEach(t => this.PP.removeEventListener("itemexpandfinish", t.vsn))
        }
        PXt(t, i=!0, e=[]) {
            let s;
            t = !!t,
            (i = !!i) && (s = this.ysn(),
            s && this.PP.ien(this, "itemexpandmany"));
            let n = null;
            if (!this.vF()) {
                if (t = this.fsn(t),
                (t = this.psn(t)) && this.Aen && this.hsn()) {
                    const t = new Promise(t => {
                        n = i => {
                            i.item === this && t()
                        }
                        ,
                        this.PP.addEventListener("itemexpandfinish", n)
                    }
                    );
                    e.push({
                        promise: t,
                        item: this,
                        vsn: n
                    })
                }
                this.VE(!1, t)
            }
            let r = this.zIs.length;
            for (let i = 0; i < r; i++)
                this.zIs[i].PXt(t, !1);
            i && CS.Dee(s) && s ? e.length ? Promise.all(e.map(t => t.promise)).then( () => {
                e.forEach(t => this.PP.removeEventListener("itemexpandfinish", t.vsn)),
                this.PP.ien(this, "itemexpandmanyfinish")
            }
            ) : this.PP.ien(this, "itemexpandmanyfinish") : e.forEach(t => this.PP.removeEventListener("itemexpandfinish", t.vsn))
        }
        Lmt(t) {
            this.VE(!this.hsn(), t, this.OZs())
        }
        $mt() {
            return !!this.Rmt
        }
        Umt() {
            this.Rmt && (this.hsn() || this.Aen.setAttribute("collapsed", ""),
            this.Aen.style.overflow = "",
            this.Rmt = null,
            this.PP.ien(this, "itemexpandfinish"))
        }
        Nmt() {
            this.Rmt && (this.Rmt.cancel(),
            this.Umt())
        }
        YB() {
            this.bq() && 1 === this.PP.wF() || (this.PP.gF(),
            this.Dwt(!0))
        }
        xD() {
            this.Dwt(!1)
        }
        bq(t) {
            return this.wpt
        }
        Dwt(t) {
            this.vF() || (t = !!t,
            this.sen(),
            this.wpt !== t && (t ? (this.PP.ien(this, "beforeitemselect"),
            this.kN().setAttribute("selected", ""),
            this.PP._zi(this),
            this.PP.aen() || this.PP.oen(this)) : (this.kN().removeAttribute("selected"),
            this.PP.een(this),
            this.PP.aen() === this && (this.PP.wF() >= 1 ? this.PP.oen(this.PP.yF()) : this.PP.oen(null))),
            this.wpt = t))
        }
        ren(t) {
            this.vF() || (t = !!t,
            this.sen(),
            this.wpt !== t && (t ? this.kN().setAttribute("selected", "") : this.kN().removeAttribute("selected"),
            this.wpt = t))
        }
        FYt() {
            if (!this.vF() && !this.Aen) {
                if (this.Get.classList.add("parentItem"),
                this.Aen = CS.qs.lk("ui-treeitem-children"),
                this.zIs.length && this.Pbt) {
                    this.Pbt.CA(null),
                    this.Pbt.hk().removeEventListener("UITap", this.Ubt);
                    let t = this.hsn() ? this.PP.Win() : this.PP.Hin();
                    this.Pbt.CA(t),
                    this.win && (t = this.hsn() ? this.X1t : this.win,
                    this.wat.CA(t)),
                    this.Pbt.hk().addEventListener("UITap", this.Ubt)
                }
                this.Get.parentElement || CS.qs.DHt(this.Get, this.hVt.GYt()),
                this.Get.parentElement.insertBefore(this.Aen, this.Get.nextSibling),
                this.hsn() || this.Aen.setAttribute("collapsed", "")
            }
        }
        Ssn() {
            for (let t of this.zIs) {
                let i = t.GYt();
                if (!i)
                    continue;
                let e = t.hk();
                if (i.previousSibling === e)
                    return;
                i.parentElement && i.parentElement.removeChild(i),
                e.parentElement && e.parentElement.insertBefore(i, e.nextSibling)
            }
        }
        jYt() {
            const t = this.GYt();
            for (let i = 0; i < this.zIs.length; i++) {
                const e = this.zIs[i]
                  , s = e.GYt();
                e && e.hk().parentElement === t && t.appendChild(e.hk()),
                s && s.parentElement === t && t.appendChild(s)
            }
        }
        gYt() {
            this.vF() || this.Aen && (this.Get.classList.remove("parentItem"),
            this.Pbt.CA(null),
            this.win && this.wat.CA(this.X1t),
            this.Pbt.hk().removeEventListener("UITap", this.Ubt),
            CS.qs.BW(this.Aen),
            this.Aen = null)
        }
        hN(t, i, e, s, n) {
            if (!(null == t || CS.doe(t) || t instanceof CS.qs.O_))
                throw new TypeError("invalid icon");
            CS.zt(i),
            this.FYt();
            let r = CS.v(CS.qs.Jj.WE, this.PP, this, t, i, e, s, n);
            return this.xsn(r, s),
            (!n || n && n.repositionChildContainers) && this.Ssn(),
            r
        }
        Pk(t, i, e, s) {
            return CS.U(t, CS.qs.Jj.WE),
            CS.Kq(i),
            CS.cO(e),
            _S(this.mXt().ten(), "configure tree to use detachable items"),
            _S(!t.dn(), "item already released"),
            _S(!t.vF(), "can not add root item"),
            _S(t.WXt(), "item is not detached"),
            this.FYt(),
            i && t.pa(i),
            t.hVt = this,
            t.esn = !1,
            (!s || s && s.addToParent) && CS.qs.DHt(t.hk(), this.GYt(), e),
            this.xsn(t, e),
            (!s || s && s.repositionChildContainers) && this.Ssn(),
            t
        }
        xsn(t, i) {
            if (CS.U(t, CS.qs.Jj.WE),
            CS.cO(i),
            CS.Go(i) ? i < 0 ? this.zIs.unshift(t) : this.zIs.splice(i, 0, t) : this.zIs.push(t),
            this.zIs.length && this.Pbt && !this.vF()) {
                this.Pbt.CA(null),
                this.Pbt.hk().removeEventListener("UITap", this.Ubt);
                let t = this.hsn() ? this.PP.Win() : this.PP.Hin();
                this.Pbt.CA(t),
                this.win && (t = this.hsn() ? this.X1t : this.win,
                this.wat.CA(t)),
                this.Pbt.hk().addEventListener("UITap", this.Ubt)
            }
            this.PP.Vin()
        }
        YF(t) {
            t ? this.Get.setAttribute("fade", "") : this.Get.removeAttribute("fade", "")
        }
        _B(t) {
            CS.U(t, CS.qs.O_),
            this.vF() || (this.win = t,
            this.Aen && !this.hsn() && this.wat.CA(this.win))
        }
        EB(t) {
            CS.U(t, CS.qs.O_),
            this.vF() || (this.X1t = t,
            this.Aen && this.hsn() && this.wat.CA(this.X1t))
        }
        OW(t) {
            this.bq() || this.YB(),
            this.sen(),
            this.PP.uE(this, t) || (t.preventDefault(),
            t.stopPropagation())
        }
        M4t(t) {
            t = !!t;
            const i = this.gsn();
            i && this.PP.ien(this, "itemexpandmany");
            const e = [];
            let s = this.hVt;
            for (; s; ) {
                if (!s.vF()) {
                    let i = this.fsn(t);
                    i = this.psn(i);
                    let n = null;
                    if (i && this.Aen && !this.hsn()) {
                        const t = new Promise(t => {
                            n = i => {
                                i.item === this && t()
                            }
                            ,
                            this.PP.addEventListener("itemexpandfinish", n)
                        }
                        );
                        e.push({
                            promise: t,
                            item: this,
                            vsn: n
                        })
                    }
                    s.VE(!0, i)
                }
                s = s.bF()
            }
            i ? e.length ? Promise.all(e.map(t => t.promise)).then( () => {
                e.forEach(t => this.PP.removeEventListener("itemexpandfinish", t.vsn)),
                this.PP.ien(this, "itemexpandmanyfinish")
            }
            ) : this.PP.ien(this, "itemexpandmanyfinish") : e.forEach(t => this.PP.removeEventListener("itemexpandfinish", t.vsn))
        }
        WB(t="auto") {
            this.PP && CS.qs.WB(this.Get, this.PP.hk(), t)
        }
        zE(t) {
            t = !!t,
            this.M4t(t),
            this.WB()
        }
        Oen() {
            this.Ren = -1,
            this.Get && this.PH().removeEventListener("pointermove", this.Fen),
            this.uH(this.Ben, this.Uen, "label") && this.PP.ien(this, "itemedit")
        }
        lsn(t) {
            this.Den = !!t
        }
        sen() {
            this.Den && (this.Get && this.PH().removeEventListener("pointermove", this.Fen),
            -1 !== this.Ren && (clearTimeout(this.Ren),
            this.Ren = -1))
        }
        aHi() {
            return !!this.jet
        }
        $B(t=this.VB(), i=0, e=t.length) {
            if (CS.Kq(t),
            this.jet || this.cn)
                return Promise.resolve("");
            this.YB(),
            this.zE();
            const s = this.PP.hk()
              , n = s.getBoundingClientRect();
            let r = this.v9e.getBoundingClientRect();
            const h = CS.Ne(r.width + 5, 30, s.clientWidth - (r.left - n.left) - 15)
              , o = r.left - n.left
              , a = r.top - n.top + s.scrollTop;
            return this.jet = CS.qs.lk("input", this.PP.hk(), null, "tree-edit-text"),
            this.jet.type = "text",
            this.jet.style.left = `${o}px`,
            this.jet.style.top = `${a}px`,
            this.jet.style.width = `${h}px`,
            this.jet.style.maxWidth = `${h}px`,
            this.jet.setAttribute("spellcheck", "false"),
            this.Xen = t => this.vWe(),
            this.jet.addEventListener("blur", this.Xen),
            this.Yen = t => this.Msn(),
            this.jet.addEventListener("input", this.Yen),
            this.p7e = t => this.Esn(t),
            this.jet.addEventListener("keydown", this.p7e, !0),
            this.PP.hk().addEventListener("scroll", this.Jen),
            this.PP.men(!0, this),
            this.jet.value = t,
            this.jet.focus(),
            this.jet.setSelectionRange(i, e),
            this.v9e.textContent = ".",
            r = this.v9e.getBoundingClientRect(),
            this.jet.style.height = r.bottom - r.top + "px",
            new Promise(t => this.Zen = t)
        }
        Esn(t) {
            t.which === CS.kE.w9 ? (t.preventDefault(),
            t.stopPropagation(),
            this.vWe()) : t.which === CS.kE.IE && (t.preventDefault(),
            t.stopPropagation(),
            this.bEi())
        }
        Msn() {
            const t = this.PP.hk()
              , i = t.getBoundingClientRect();
            this.v9e.textContent = this.jet.value;
            const e = this.v9e.getBoundingClientRect()
              , s = CS.Ne(e.width + 5, 30, t.clientWidth - (e.left - i.left) - 15);
            this.jet.style.width = `${s}px`,
            this.jet.style.maxWidth = `${s}px`,
            this.v9e.textContent = "."
        }
        isn() {
            let t = this.PP.hk().getBoundingClientRect()
              , i = this.v9e.getBoundingClientRect();
            this.jet.style.left = i.left - t.left + "px",
            this.jet.style.top = `${i.top - t.top + this.PP.hk().scrollTop}px`;
            let e = this.jet.getBoundingClientRect();
            (e.bottom > t.bottom + 1 || e.top < t.top - 1) && this.bEi()
        }
        Csn() {
            this.jet && (this.v9e.textContent = this._S,
            this.PP.hk().removeEventListener("scroll", this.Jen, {
                passive: !0
            }),
            this.PP.men(!1, this),
            this.jet.removeEventListener("keydown", this.p7e, !0),
            this.p7e = null,
            this.jet.removeEventListener("input", this.Yen),
            this.Yen = null,
            this.jet.removeEventListener("blur", this.Xen),
            this.Xen = null,
            CS.qs.BW(this.jet),
            this.jet = null)
        }
        bEi() {
            this.jet && (this.Csn(),
            this.Zen && this.Zen(null),
            this.Zen = null)
        }
        vWe() {
            if (!this.jet)
                return;
            let t = this.jet.value;
            this.Csn(),
            this.Zen && this.Zen(t),
            this.Zen = null,
            this.YB(),
            this.PP.hk().focus()
        }
        DVt() {
            if (this.vF())
                throw new Error("cannot add checkbox to root item");
            this.Ven || (this.Ven = this.PH().createElement("input"),
            this.Ven.className = "tree-checkbox",
            this.Ven.type = "checkbox",
            this.Wen = t => this._sn(t),
            this.Ven.addEventListener("change", this.Wen),
            this.Hen = t => t.stopPropagation(),
            this.Ven.addEventListener("UIDoubleTap", this.Hen),
            this.Ven.addEventListener("pointerdown", CS.qs.ck),
            this.zen.insertBefore(this.Ven, this.zen.firstChild))
        }
        Tsn(t, i) {
            this.xVt(t, i, this.wat.hk())
        }
        xVt(t, i, e) {
            if (CS.zt(t),
            this.vF())
                throw new Error("cannot add extra icons to root item");
            if (this.qen || (this.qen = new Map),
            this.qen.has(t))
                return;
            const s = CS.doe(i) ? self.app.oi(i) : i
              , n = CS.v(CS.qs.kmt, s, null);
            e = e || this.v9e,
            this.zen.insertBefore(n.hk(), e),
            this.qen.set(t, {
                nsn: n,
                Isn: i => {
                    this.sen(),
                    i.button === CS.f1.e5 && (this.PP.ien(this, "itemiconclick", {
                        Psn: t
                    }) || i.stopPropagation())
                }
            }),
            n.hk().addEventListener("pointerdown", this.qen.get(t).Isn),
            n.hk().addEventListener("UIDoubleTap", CS.qs.ck)
        }
        SVt(t) {
            if (CS.zt(t),
            !this.qen)
                return;
            const i = this.qen.get(t);
            i && (i.nsn && (i.nsn.hk().removeEventListener("pointerdown", i.Isn),
            i.nsn.hk().removeEventListener("UIDoubleTap", CS.qs.ck),
            i.nsn.he()),
            this.qen.delete(t))
        }
        _sn(t) {
            this.sen(),
            this.PP.ien(this, "itemcheckchange") || t.stopPropagation()
        }
        RVt(t) {
            if (!this.Ven)
                throw new Error("no checkbox added");
            this.Ven.checked = !!t
        }
        HVt() {
            if (!this.Ven)
                throw new Error("no checkbox added");
            return !!this.Ven.checked
        }
        xen(t) {
            this.Gsn(t ? "match" : "no-match")
        }
        Men() {
            this.Gsn(""),
            this.Een(!1)
        }
        Asn() {
            return this.Ien
        }
        OYt() {
            return "no-match" === this.Asn()
        }
        OZs() {
            return "match" === this.Asn()
        }
        Rsn() {
            return "" === this.Asn()
        }
        Gsn(t) {
            if ("match" === t || this.Ien !== t) {
                if ("" === t)
                    this.Get.classList.remove("searchMatch"),
                    this.Get.classList.remove("searchNoMatch");
                else if ("match" === t) {
                    "match" !== this.Ien && (this.Get.classList.add("searchMatch"),
                    this.Get.classList.remove("searchNoMatch"));
                    for (const t of this.tpt())
                        t.Een(!0),
                        "no-match" === t.Asn() && t.Gsn("")
                } else
                    "no-match" === t && (this.Get.classList.add("searchNoMatch"),
                    this.Get.classList.remove("searchMatch"));
                this.Ien = t
            }
        }
        Een(t, i=!1) {
            t = !!t,
            this.vF() || (i ? (this.Ten === t && (this.Ten = !this.Ten),
            this.VE(t, !1, !0)) : this.VE(this.OB() || t, !1, !0))
        }
        yen(t) {
            CS.Ge(t),
            this.Qen = t
        }
        ksn() {
            return this.Qen
        }
        static gen(t, i) {
            return t.ksn() - i.ksn()
        }
        QL() {
            return {
                name: this.VB(),
                expanded: this.OB(),
                children: [...this.children()].map(t => t.QL())
            }
        }
        tU(t) {
            if (!t)
                return;
            this.O6t = !0,
            this.vF() || this.VE(t.expanded);
            const i = this.Pp();
            CS.$l(i, self.jF) && i.PB(this.OB()),
            CS.XOt(i.PB) && i.PB(this.OB());
            const e = [...this.children()];
            if (e.length)
                for (let i = 0; i < e.length; i++) {
                    const s = e[i];
                    s && s.tU(this.PP._en(e[i], t.children))
                }
            this.O6t = !1
        }
    }
}
{
    const RS = globalThis.t
      , kS = globalThis.assert
      , OS = ["static", "sortable", "draggable"]
      , DS = ["left", "right"]
      , FS = ["label-under", "label-right"]
      , LS = 100
      , BS = {
        kJt: -1,
        Qpe: "label-under",
        itemType: "static",
        IP: !1,
        gZt: "",
        yZt: "auto",
        vZt: [],
        NYt: NaN
    };
    RS.qs.Jj.PJt = class extends RS.Event.aG {
        constructor(t, i) {
            if (super(),
            RS.Hdt(t),
            RS.Wat(i),
            i = Object.assign({}, BS, i),
            RS.Ge(i.kJt),
            RS.zt(i.Qpe),
            RS.zt(i.itemType),
            !OS.includes(i.itemType))
                throw new Error("invalid item type");
            if (!FS.includes(i.Qpe))
                throw new Error("invalid item style");
            this.hVt = null,
            this.Get = null,
            this.rin = i.kJt,
            this.rin < 0 && (this.rin = self.app.Gk()),
            this.k2t = i.itemType,
            this.Osn = i.Qpe,
            this.lSe = !!i.IP,
            this._es = [],
            this.gin = new Set,
            this.Dsn = [],
            t && "ui-iconview" === t.tagName.toLowerCase() ? (this.hVt = t.parentElement,
            this.Get = t) : (this.hVt = t,
            this.Get = RS.qs.lk("ui-iconview", this.hVt)),
            this.Get.setAttribute(this.Osn, ""),
            this.l1 = t => this.IW(t),
            this.Get.addEventListener("pointerdown", this.l1),
            this.Get.setAttribute("tabindex", 0),
            this.Z8e = t => this.xSe(),
            this.t7e = t => this.DUt(),
            this.Get.addEventListener("focus", this.Z8e),
            this.Get.addEventListener("blur", this.t7e),
            this.Fsn = [],
            this.Rz = t => this.FP(t),
            this.Pin = "",
            this.Lsn = null,
            this.Gin = new RS.gP( () => this.Ain(),LS),
            this.Gin.lW(!0),
            this.Rin = !1,
            this.Uin = RS.qs.lk("div", null, null, "iconViewNoSearchResults"),
            this.Uin.setAttribute("position", i.yZt),
            this.Nin = !1,
            this.Din = RS.qs.lk("div", this.Get, null, "iconViewNoItems"),
            this.Din.textContent = i.gZt || self.lang("ui.controls.icon-view.no-items-showing"),
            this.Din.setAttribute("position", i.yZt),
            this.Fin = RS.qs.lk("div", this.Din, null, "iconViewNoItemsOptions");
            for (const t of i.vZt) {
                RS.zt(t.text),
                RS.zt(t.tag);
                const i = RS.qs.lk("button", this.Fin, null, "treeNoItemsOption");
                i.textContent = t.text,
                i.addEventListener("click", () => this.Bsn("noitemsoptionclick", {
                    tag: t.tag
                }))
            }
            this.Bin = !0,
            this.Usn = null,
            this.v0e = null,
            this.Nsn = RS.Go(i.NYt) && i.NYt > 0 ? i.NYt : NaN,
            this.jsn = [],
            this.$sn = 0,
            this.zsn = null,
            this.Vsn = null,
            this.Wsn = null,
            this.Hsn = null,
            this.Ksn = null,
            this.qsn = null,
            RS.Go(this.Nsn) && this.Nsn > 0 && (this.Vsn = RS.qs.lk("div", this.hVt, null, "icon-view-pagination-controls"),
            this.Vsn.setAttribute("hide", ""),
            this.Wsn = RS.qs.lk("button", this.Vsn),
            this.Wsn.textContent = self.lang("common.previous"),
            this.Wsn.addEventListener("click", () => this.Xsn()),
            this.zsn = RS.qs.lk("label", this.Vsn),
            this.zsn.textContent = self.lang("ui.controls.icon-view.pagination.pages"),
            this.Hsn = RS.qs.lk("select", this.Vsn),
            this.Hsn.addEventListener("change", () => this.Ysn()),
            this.Ksn = RS.qs.lk("label", this.Vsn),
            this.qsn = RS.qs.lk("button", this.Vsn),
            this.qsn.textContent = self.lang("common.next"),
            this.qsn.addEventListener("click", () => this.Jsn()),
            this.hVt && (this.hVt.style.display = "flex",
            this.hVt.style.flexFlow = "column"))
        }
        he() {
            this.tC(!0),
            this.PH().removeEventListener("keydown", this.Rz),
            this.Rz = null,
            this.Lsn = null,
            this.Gin.he(),
            this.Gin = null,
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            RS.qs.BW(this.Din),
            this.Din = null,
            RS.qs.BW(this.Uin),
            this.Uin = null,
            this.Get.removeEventListener("focus", this.Z8e),
            this.Get.removeEventListener("blur", this.t7e),
            this.Z8e = null,
            this.t7e = null,
            RS.qs.BW(this.Get),
            this.Get = null,
            this.Usn = null,
            this.hVt = null,
            super.he()
        }
        Kyt(t) {
            RS.zlt(t),
            this.hVt !== t && (this.hVt && (this.Vsn && (this.hVt.style.display = "",
            this.hVt.style.flexFlow = ""),
            this.hVt.removeChild(this.Get)),
            this.hVt = t,
            this.hVt.appendChild(this.Get),
            this.Vsn && (this.hVt.appendChild(this.Vsn),
            this.hVt.style.display = "flex",
            this.hVt.style.flexFlow = "column"))
        }
        PH() {
            return this.Get.ownerDocument
        }
        Zsn(t) {
            if (RS.U(t, RS.qs.Jj.n0t),
            t.Xwi() !== this)
                throw new Error("item from different icon view")
        }
        tC(t) {
            for (const i of this.Dsn)
                i.LUt(t);
            RS.sc(this.Dsn);
            for (const i of this._es)
                i.LUt(t);
            RS.sc(this._es);
            for (const i of this.jsn) {
                for (const e of i)
                    ("function" != typeof e.Xwi || e.Xwi()) && "function" == typeof e.LUt && e.LUt(t);
                RS.sc(i)
            }
            RS.sc(this.jsn),
            this.gin.clear(),
            RS.sc(this.Fsn),
            this.Hsn && (RS.qs.BYt(this.Hsn),
            RS.qs.BW(this.Vsn)),
            t ? RS.qs.BYt(this.Get) : (this.wXt(!1),
            this.Vin())
        }
        GWi(t) {
            this.Zsn(t),
            t.LUt(),
            this._es.splice(this._es.indexOf(t), 1),
            this.Vin()
        }
        Igs() {
            return this.rin
        }
        Qsn() {
            return this.Osn
        }
        tnn() {
            return RS.Go(this.Nsn)
        }
        inn() {
            return this.Nsn
        }
        enn() {
            return this.Vsn
        }
        Xsn() {
            if (!this.tnn())
                return;
            const t = this.$sn;
            if (this.$sn--,
            this.$sn < 0 && (this.$sn = 0),
            t === this.$sn)
                return;
            RS.sc(this._es),
            this.gin.clear(),
            RS.sc(this.Fsn),
            RS.qs.BYt(this.Get),
            this.Bsn("beforepagechange");
            const i = this.jsn[this.$sn];
            for (let t = 0; t < i.length; t++) {
                let e = i[t];
                if (!RS.$l(e, RS.qs.Jj.n0t) && !RS.$l(e, RS.qs.Jj.kWi) && !RS.$l(e, RS.qs.Jj.snn)) {
                    const s = e?.cQt;
                    "static" === this.k2t && (e = RS.v(RS.qs.Jj.n0t, this, e.icon, e.text, e.nnn, e.index, e.group, !0)),
                    "sortable" === this.k2t && (e = RS.v(RS.qs.Jj.kWi, this, e.icon, e.text, e.nnn, e.index, !0)),
                    "draggable" === this.k2t && (e = RS.v(RS.qs.Jj.snn, this, e.icon, e.text, e.nnn, e.index, !0)),
                    s && s(e),
                    i[t] = e
                }
                this.Get.appendChild(e.hk()),
                this._es.push(e)
            }
            this.Hsn.selectedIndex = this.$sn,
            this.wXt(!1),
            this.Vin(),
            this.Bsn("pagechange")
        }
        Ysn() {
            if (!this.tnn())
                return;
            this.$sn = this.Hsn.selectedIndex,
            RS.sc(this._es),
            this.gin.clear(),
            RS.sc(this.Fsn),
            RS.qs.BYt(this.Get),
            this.Bsn("beforepagechange");
            const t = this.jsn[this.$sn];
            for (let i = 0; i < t.length; i++) {
                let e = t[i];
                if (!RS.$l(e, RS.qs.Jj.n0t) && !RS.$l(e, RS.qs.Jj.kWi) && !RS.$l(e, RS.qs.Jj.snn)) {
                    const s = e?.cQt;
                    "static" === this.k2t && (e = RS.v(RS.qs.Jj.n0t, this, e.icon, e.text, e.nnn, e.index, e.group, !0)),
                    "sortable" === this.k2t && (e = RS.v(RS.qs.Jj.kWi, this, e.icon, e.text, e.nnn, e.index, !0)),
                    "draggable" === this.k2t && (e = RS.v(RS.qs.Jj.snn, this, e.icon, e.text, e.nnn, e.index, !0)),
                    s && s(e),
                    t[i] = e
                }
                this.Get.appendChild(e.hk()),
                this._es.push(e)
            }
            this.Hsn.selectedIndex = this.$sn,
            this.wXt(!1),
            this.Vin(),
            this.Bsn("pagechange")
        }
        Jsn() {
            if (!this.tnn())
                return;
            const t = this.$sn;
            if (this.$sn++,
            this.$sn >= this.jsn.length && (this.$sn = this.jsn.length - 1),
            t === this.$sn)
                return;
            RS.sc(this._es),
            this.gin.clear(),
            RS.sc(this.Fsn),
            RS.qs.BYt(this.Get),
            this.Bsn("beforepagechange");
            const i = this.jsn[this.$sn];
            for (let t = 0; t < i.length; t++) {
                let e = i[t];
                if (!RS.$l(e, RS.qs.Jj.n0t) && !RS.$l(e, RS.qs.Jj.kWi) && !RS.$l(e, RS.qs.Jj.snn)) {
                    const s = e?.cQt;
                    "static" === this.k2t && (e = RS.v(RS.qs.Jj.n0t, this, e.icon, e.text, e.nnn, e.index, e.group, !0)),
                    "sortable" === this.k2t && (e = RS.v(RS.qs.Jj.kWi, this, e.icon, e.text, e.nnn, e.index, !0)),
                    "draggable" === this.k2t && (e = RS.v(RS.qs.Jj.snn, this, e.icon, e.text, e.nnn, e.index, !0)),
                    s && s(e),
                    i[t] = e
                }
                this.Get.appendChild(e.hk()),
                this._es.push(e)
            }
            this.Hsn.selectedIndex = this.$sn,
            this.wXt(!1),
            this.Vin(),
            this.Bsn("pagechange")
        }
        qin() {
            return this.lSe
        }
        Mzi(t) {
            t = !!t,
            this.lSe !== t && (t || this.gF(),
            this.lSe = t)
        }
        hk() {
            return this.Get
        }
        Kpt() {
            return this.v0e || (this.v0e = this.Get.getBoundingClientRect()),
            this.v0e
        }
        bF() {
            return this.hVt
        }
        rnn() {
            return this.Usn
        }
        hnn(t) {
            RS.U(t, RS.qs.Jj.n0t),
            this.Usn = t
        }
        bXt() {
            return RS.qs.Jj.kWi.bXt()
        }
        OH() {
            return RS.qs.Jj.kWi.Uht()
        }
        Uht() {
            return RS.qs.Jj.kWi.Uht()
        }
        kH() {
            this.Uht() && RS.qs.Jj.kWi.kH()
        }
        items() {
            return this._es
        }
        *$Ie() {
            for (const t of this._es)
                t.Vpt() || (yield t)
        }
        OJt() {
            return this._es.length
        }
        WJt(t) {
            return RS.Ge(t),
            (t = Math.floor(t)) < 0 || t >= this._es.length ? null : this._es[t]
        }
        onn() {
            return RS.eu(this.items())
        }
        FWi(t) {
            this.Zsn(t);
            let i = this.AJt(t) - 1;
            return RS.Uke(i, this._es) ? this._es[i] : null
        }
        GSe(t) {
            this.Zsn(t);
            let i = this.AJt(t) + 1;
            return RS.Uke(i, this._es) ? this._es[i] : null
        }
        Ozi(t) {
            if (RS.zt(t),
            !OS.includes(t))
                throw new Error("invalid item type");
            this.k2t = t
        }
        L2t() {
            return "static" === this.k2t ? RS.qs.Jj.n0t : "sortable" === this.k2t ? RS.qs.Jj.kWi : "draggable" === this.k2t ? RS.qs.Jj.snn : void 0
        }
        vzi(t) {
            RS.qd(t);
            for (let i of this._es)
                if (t(i))
                    return i;
            return null
        }
        xWi() {
            this._es.reverse();
            let t = this.Get.firstChild;
            for (let i = this.Get.children.length - 1; i > 0; i--) {
                let i = this.Get.lastChild;
                this.Get.removeChild(i),
                this.Get.insertBefore(i, t)
            }
        }
        Hzi(t, i) {
            if (RS.Ge(t),
            RS.Ge(i),
            t < 0 || t >= this._es.length)
                throw new Error("invalid item index");
            if (i < 0 || i >= this._es.length)
                throw new Error("invalid item index");
            if (t === i)
                return;
            let e = this._es[t].hk();
            this.Get.removeChild(e);
            let s = this._es[i].hk();
            t < i ? this.Get.insertBefore(e, s.nextSibling) : this.Get.insertBefore(e, s),
            this._es.splice(i, 0, this._es.splice(t, 1)[0])
        }
        _zi(t) {
            this.Zsn(t),
            this.gin.add(t),
            this.Usn = t,
            this.ien(t, "itemselect")
        }
        een(t) {
            this.Zsn(t),
            this.gin.delete(t),
            this.Usn === t && (this.Usn = null),
            this.ien(t, "itemunselect")
        }
        wF() {
            return this.gin.size
        }
        Kzi(t) {
            t.Dwt(!0)
        }
        len(t, i) {
            if (RS.U(t, RS.qs.Jj.n0t),
            RS.U(i, RS.qs.Jj.n0t),
            this.Zsn(t),
            this.Zsn(i),
            t === i)
                return this.Bsn("beforeselectrange"),
                t.Dwt(!0),
                void this.Bsn("selectrange");
            let e = !1
              , s = null;
            const n = [];
            for (const r of this.items())
                if (e || (r === t ? (e = !0,
                s = i) : r === i && (e = !0,
                s = t)),
                e && (n.push(r),
                r === s))
                    break;
            s === t && n.reverse(),
            this.Bsn("beforeselectrange");
            for (const t of n)
                t.Vpt() || t.Dwt(!0);
            this.Bsn("selectrange")
        }
        gF() {
            for (let t of this.gin)
                t.Dwt(!1);
            self.assert(0 === this.gin.size, "should have deleted all selected items")
        }
        qB() {
            return this.gin.values()
        }
        ZYt() {
            return [...this.gin.values()].map(t => t.Pp())
        }
        yF() {
            return RS.eu(this.gin)
        }
        Xde() {
            const t = this.onn();
            t && t.YB()
        }
        pSe() {
            const t = this.onn();
            t && (t.YB(),
            t.WB())
        }
        xSe() {
            this.PH().addEventListener("keydown", this.Rz)
        }
        DUt() {
            this.PH().removeEventListener("keydown", this.Rz)
        }
        FP(t) {
            if (1 !== this.wF())
                return;
            const i = t.which;
            if (i !== RS.kE.K7 && i !== RS.kE.j7 && i !== RS.kE.F7 && i !== RS.kE.V7)
                return;
            const e = this.yF();
            let s = this._es.indexOf(e);
            if (!(s < 0)) {
                if (i === RS.kE.F7)
                    do {
                        --s
                    } while (s >= 0 && this._es[s].Vpt());
                else if (i === RS.kE.V7)
                    do {
                        ++s
                    } while (s < this._es.length && this._es[s].Vpt());
                else {
                    e.DXe();
                    const t = e.Kpt()
                      , n = i === RS.kE.j7 ? 1 : -1;
                    s += n;
                    for (let i = this._es.length; s >= 0 && s < i; s += n) {
                        const i = this._es[s];
                        if (i.Vpt())
                            continue;
                        i.DXe();
                        const e = i.Kpt();
                        if (!(e.right < t.left + 1 || e.left > t.right - 1) && (1 === n && e.top > t.bottom - 1 || -1 === n && e.bottom < t.top + 1))
                            break
                    }
                }
                s < 0 || s >= this._es.length || (this._es[s].YB(),
                this._es[s].WB(),
                t.preventDefault())
            }
        }
        IW(t) {
            if (t.target !== this.Get || RS.OF.j1(t) || t.shiftKey)
                return;
            const i = this.Get.getBoundingClientRect()
              , e = i.left + this.Get.clientWidth
              , s = i.top + this.Get.clientHeight;
            i.left < t.clientX && e > t.clientX && i.top < t.clientY && s > t.clientY && (this.Bsn("emptyspaceclick"),
            this.gF())
        }
        ann(t) {
            this.Zsn(t),
            this.Fsn.push(t),
            this.Fsn.length > 2 && this.Fsn.shift()
        }
        lnn() {
            return this.Fsn
        }
        Bsn(t, i) {
            RS.zt(t);
            let e = new RS.Event(t,!0);
            return e.unn = this,
            this.dispatchEvent(Object.assign(e, i))
        }
        ien(t, i) {
            this.Zsn(t),
            RS.zt(i);
            let e = new RS.Event(i,!0);
            return e.item = t,
            this.dispatchEvent(e)
        }
        uE(t, i) {
            this.Zsn(t);
            let e = new RS.Event("itemcontextmenu",!0);
            return e.item = t,
            e.clientX = i.clientX,
            e.clientY = i.clientY,
            this.dispatchEvent(e)
        }
        AJt(t) {
            return this.Zsn(t),
            this._es.indexOf(t)
        }
        cnn(t) {
            return this.Zsn(t),
            Array.prototype.indexOf.call(this.Get.children, t.hk())
        }
        dnn(t, i, e) {
            this.Zsn(t),
            RS.Ge(i),
            RS.zt(e);
            let s = this._es;
            if (i < 0 || i >= s.length)
                throw new Error("new index is out of bounds");
            if (!DS.includes(e))
                throw new Error(`invalid position, '${e}' was used. Only ${DS.toString()} are valid positions.`);
            let n = this._es[i];
            if (n === t)
                return;
            this.hk().removeChild(t.hk()),
            "left" === e && this.hk().insertBefore(t.hk(), n.hk()),
            "right" === e && n.hk().parentNode.insertBefore(t.hk(), n.hk().nextSibling);
            let r = this.AJt(t)
              , h = 0;
            return i > r ? ("left" === e && (h = i > 0 ? i - 1 : 0,
            s.splice(h, 0, s.splice(r, 1)[0])),
            "right" === e && (h = i,
            s.splice(h, 0, s.splice(r, 1)[0]))) : ("left" === e && (h = i,
            s.splice(h, 0, s.splice(r, 1)[0])),
            "right" === e && (h = i < s.length - 1 ? i + 1 : i,
            s.splice(h, 0, s.splice(r, 1)[0]))),
            h
        }
        fnn(t, i, e) {
            RS.Ge(i),
            RS.zt(e),
            this.Zsn(t);
            let s = this._es;
            if (i < 0 || i >= s.length)
                throw new Error("new index is out of bounds");
            if (!DS.includes(e))
                throw new Error(`invalid position, '${e}' was used. Only ${DS.toString()} are valid positions.`);
            let n = 0;
            return i > this.AJt(t) ? ("left" === e && (n = i > 0 ? i - 1 : 0),
            "right" === e && (n = i)) : ("left" === e && (n = i),
            "right" === e && (n = i < s.length - 1 ? i + 1 : i)),
            n
        }
        pnn() {
            this.v0e = this.Get.getBoundingClientRect();
            for (let t of this._es)
                t.DXe()
        }
        TWi() {}
        OWi() {}
        Pk(t, i, e, s, n, r) {
            let h;
            if (RS.Mw(t, RS.qs.O_),
            RS.u7t(i),
            RS.cO(s),
            RS.Mw(n, RS.qs.Jj.mnn),
            n && (s = null),
            this.tnn()) {
                if (kS(!n, "groups not supported with pagination"),
                kS(!s, "indexing not supported with pagination"),
                n = null,
                s = null,
                !(this._es.length <= this.inn())) {
                    "static" === this.k2t && (h = {
                        icon: t,
                        text: i,
                        nnn: e,
                        nnn: e,
                        index: s,
                        group: n,
                        cQt: r?.cQt
                    }),
                    "sortable" === this.k2t && (h = {
                        icon: t,
                        text: i,
                        nnn: e,
                        nnn: e,
                        index: s,
                        group: n,
                        cQt: r?.cQt
                    }),
                    "draggable" === this.k2t && (h = {
                        icon: t,
                        text: i,
                        nnn: e,
                        nnn: e,
                        index: s,
                        group: n,
                        cQt: r?.cQt
                    });
                    let o = this.jsn[this.jsn.length - 1];
                    return o || (o = this.wnn(!0)),
                    o.length >= this.inn() && (o = this.wnn(!0)),
                    void o.push(h)
                }
                {
                    "static" === this.k2t && (h = RS.v(RS.qs.Jj.n0t, this, t, i, e, s, n, !0)),
                    "sortable" === this.k2t && (h = RS.v(RS.qs.Jj.kWi, this, t, i, e, s, !0)),
                    "draggable" === this.k2t && (h = RS.v(RS.qs.Jj.snn, this, t, i, e, s, !0));
                    let o = this.jsn[this.jsn.length - 1];
                    o || (o = this.wnn()),
                    o.length >= this.inn() && (o = this.wnn()),
                    o.push(h),
                    this._es.push(h),
                    r?.cQt && r.cQt(h)
                }
            } else
                "static" === this.k2t && (h = RS.v(RS.qs.Jj.n0t, this, t, i, e, s, n, !0)),
                "sortable" === this.k2t && (h = RS.v(RS.qs.Jj.kWi, this, t, i, e, s, !0)),
                "draggable" === this.k2t && (h = RS.v(RS.qs.Jj.snn, this, t, i, e, s, !0)),
                RS.Go(s) ? s < 0 ? this._es.unshift(h) : this._es.splice(s, 0, h) : this._es.push(h),
                r?.cQt && r.cQt(h);
            return this.Vin(),
            h
        }
        wnn(t) {
            t = !!t;
            const i = []
              , e = RS.qs.lk("option", this.Hsn);
            return this.jsn.push(i),
            e.value = this.jsn.length - 1,
            e.textContent = String(this.jsn.length),
            t && (this.enn().removeAttribute("hide"),
            this.Vsn && this.hVt && (this.hVt.appendChild(this.Vsn),
            this.hVt.style.display = "flex",
            this.hVt.style.flexFlow = "column")),
            this.Ksn.textContent = self.tP("ui.controls.icon-view.pagination.total", this.jsn.length),
            i
        }
        ayt(t) {
            if (RS.zt(t),
            "sortable" === this.k2t)
                throw new Error("not yet implemented: groups for sortable icon views");
            let i = RS.v(RS.qs.Jj.mnn, this, t);
            return this.Dsn.push(i),
            this.Vin(),
            i
        }
        _E(t, i) {
            RS.zt(t),
            RS.Wat(i),
            this.Rin = !1,
            i && (this.Rin = !!i.FE),
            this.Pin = t,
            this.Lsn = null,
            this.Gin.IF()
        }
        pwe(t, i, e) {
            RS.qd(t),
            RS.Kq(i),
            RS.Wat(e),
            this.Pin = i || "",
            this.Lsn = t,
            this.Rin = !1,
            !e || (this.Rin = !!e.FE,
            void 0 === e.gnn || e.gnn) ? this.Gin.IF() : this.Ain()
        }
        Ain() {
            let t = this.Pin.toLowerCase()
              , i = !1
              , e = this.Lsn
              , s = !0;
            for (let n of this.items())
                if (e) {
                    let t = e(n);
                    n.Upt(!t),
                    t && (s && (this.Rin && n.YB(),
                    s = !1),
                    i = !0)
                } else if (t) {
                    let e = n.ynn(t);
                    n.Upt(!e),
                    e && (s && (this.Rin && n.YB(),
                    s = !1),
                    i = !0)
                } else
                    n.Upt(!1),
                    i = !0;
            this.wXt(!i),
            this.Lsn = null;
            const n = new RS.Event("searchresultsupdate");
            this.dispatchEvent(n)
        }
        zXt(t) {
            RS.zt(t),
            this.Din.textContent = t
        }
        HXt(t) {
            t = !!t,
            this.Fin.style.display = t ? "" : "none"
        }
        Vin() {
            let t = !this._es.length && !this.Dsn.length;
            this.Bin = t,
            this.Bin ? (this.Get.contains(this.Din) || this.Get.appendChild(this.Din),
            this.Din.contains(this.Fin) || this.Din.appendChild(this.Fin)) : this.Get.contains(this.Din) && RS.qs.BW(this.Din)
        }
        wXt(t) {
            this.Bin || (this.Nin !== t ? (this.Nin = t,
            this.Nin ? (this.Get.contains(this.Uin) || this.Get.appendChild(this.Uin),
            this.Lsn && !this.Pin ? this.Uin.textContent = self.lang("ui.controls.icon-view.no-search-results") : this.Uin.textContent = self.tP("ui.controls.icon-view.no-text-search-results", this.Pin)) : RS.qs.BW(this.Uin)) : this.Nin && (this.Get.contains(this.Uin) || this.Get.appendChild(this.Uin),
            this.Lsn && !this.Pin ? this.Uin.textContent = self.lang("ui.controls.icon-view.no-search-results") : this.Uin.textContent = self.tP("ui.controls.icon-view.no-text-search-results", this.Pin)))
        }
    }
}
{
    const US = self.t;
    US.qs.Jj.n0t = class extends US.Me {
        constructor(t, i, e, s, n, r, h) {
            if (US.U(t, US.qs.Jj.PJt),
            US.Mw(i, US.qs.O_),
            US.u7t(e),
            US.cO(n),
            US.Mw(r, US.qs.Jj.mnn),
            h = !!h,
            super(),
            this.IJt = t,
            this.X1t = i || null,
            this._S = e,
            this.Bd = s,
            this.wpt = !1,
            this.bnn = r,
            this.vnn = !1,
            this.XCt = -1,
            this.L9 = 0,
            this.W9 = 0,
            this.v0e = null,
            this.Get = null,
            US.Go(n)) {
                let t = null;
                h && (t = this.IJt.hk()),
                this.Get = US.qs.lk("ui-iconviewitem", t, null, null, null, n)
            } else {
                let t = null;
                h && (t = this.bnn ? this.bnn.Snn() : this.IJt.hk()),
                this.Get = US.qs.lk("ui-iconviewitem", t)
            }
            this.wvt = US.qs.lk("div", this.Get, null, "iconViewItemWrap"),
            this.wat = US.v(US.qs.kmt, this.X1t || this.IJt.Igs(), this.wvt),
            this.v9e = US.qs.lk("span", this.wvt, null, "iconViewItemText"),
            US.odt(this.v9e, this._S),
            this.gpt = t => this.GW(t),
            this.Get.addEventListener("UIDoubleTap", this.gpt),
            this.P8 = t => this.OW(t),
            this.Get.addEventListener("contextmenu", this.P8),
            this.l1 = t => this.IW(t),
            this.Get.addEventListener("pointerdown", this.l1),
            this.Mz = t => this.Gz(t),
            this.Oz = t => this.Cz(t),
            this.N9e = t => this.b2(t)
        }
        LUt(t) {
            this.Dwt(!1),
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.PH().removeEventListener("pointermove", this.Mz),
            this.Mz = null,
            this.PH().removeEventListener("pointerup", this.Oz),
            this.Oz = null,
            this.PH().removeEventListener("pointercancel", this.N9e),
            this.N9e = null,
            this.Get.removeEventListener("UIDoubleTap", this.gpt),
            this.gpt = null,
            this.Get.removeEventListener("contextmenu", this.P8),
            this.P8 = null,
            this.wat.he(t),
            this.wat = null,
            t || (US.qs.BW(this.v9e),
            US.qs.BW(this.wvt),
            US.qs.BW(this.Get)),
            this.v9e = null,
            this.wvt = null,
            this.Get = null,
            this.IJt = null,
            this.X1t = null,
            this.Bd = null,
            US.he(this)
        }
        PH() {
            return this.Get.ownerDocument
        }
        jW() {
            return this.PH().defaultView
        }
        CA(t) {
            US.U(t, US.qs.O_),
            this.wat && this.wat.CA(t)
        }
        NN(t) {
            US.qd(t),
            this.wat && this.wat.NN(t)
        }
        $Jt() {
            this.wat.$Jt()
        }
        IW(t) {
            t.stopPropagation(),
            t.button === US.f1.e5 && t.isPrimary && (this.IJt.ann(this),
            this.DXe(),
            this.Get.setAttribute("pointerheld", ""),
            this.PH().addEventListener("pointermove", this.Mz),
            this.PH().addEventListener("pointerup", this.Oz),
            this.PH().addEventListener("pointercancel", this.N9e),
            this.XCt = t.pointerId,
            this.L9 = t.clientX,
            this.W9 = t.clientY)
        }
        GW(t) {
            this.IJt.lnn().every(t => t === this) && this.IJt.ien(this, "itemdoubletap")
        }
        Gz(t) {
            t.pointerId === this.XCt && t.isPrimary
        }
        Cz(t) {
            if (this.Get && t.pointerId === this.XCt && t.isPrimary) {
                if (this.Get.removeAttribute("pointerheld", ""),
                this.PH().removeEventListener("pointermove", this.Mz),
                this.PH().removeEventListener("pointerup", this.Oz),
                this.PH().removeEventListener("pointercancel", this.N9e),
                this.IJt.ien(this, "itemclick"),
                this.IJt.qin()) {
                    let t = US.OF.j1()
                      , i = US.OF.PF(US.kE.CF)
                      , e = this.IJt.rnn();
                    if (t && i && e)
                        return this.IJt.len(this, e),
                        void this.IJt.hnn(this);
                    if (i && e)
                        return this.IJt.gF(),
                        this.IJt.len(this, e),
                        void this.IJt.hnn(this);
                    if (t)
                        return void this.Dwt(!this.bq())
                }
                this.xnn(t.clientX, t.clientY) && this.YB()
            }
        }
        b2(t) {
            this.Get && this.Get.removeAttribute("pointerheld", "");
            const i = t ? t.currentTarget : this.PH();
            i.removeEventListener("pointermove", this.Mz),
            i.removeEventListener("pointerup", this.Oz),
            i.removeEventListener("pointercancel", this.N9e),
            this.IJt && this.IJt.gF()
        }
        YB() {
            this.bq() && 1 === this.IJt.wF() || (this.IJt.gF(),
            this.Dwt(!0))
        }
        xD() {
            this.Dwt(!1)
        }
        bq() {
            return this.wpt
        }
        Dwt(t) {
            t = !!t,
            this.wpt !== t && (t ? (this.IJt.ien(this, "beforeitemselect"),
            this.Get.setAttribute("selected", ""),
            this.IJt._zi(this)) : (this.Get.removeAttribute("selected"),
            this.IJt.een(this)),
            this.wpt = t)
        }
        hk() {
            return this.Get
        }
        Xwi() {
            return this.IJt
        }
        Fie(t) {
            this.Bd = t
        }
        Pp() {
            return this.Bd
        }
        Kpt() {
            return this.v0e
        }
        pa(t) {
            US.u7t(t),
            US.bBe(this._S, t) || (this._S = t,
            US.odt(this.v9e, this._S))
        }
        VB() {
            return this._S
        }
        Upt(t) {
            t = !!t,
            this.vnn !== t && (this.vnn = t,
            this.vnn ? (this.Dwt(!1),
            this.Get.setAttribute("hidden", ""),
            this.bnn && this.bnn.Mnn(this, !0)) : (this.Get.removeAttribute("hidden"),
            this.bnn && this.bnn.Mnn(this, !1)))
        }
        Vpt() {
            return this.vnn
        }
        WB(t="auto") {
            US.qs.WB(this.Get, this.IJt.hk(), t)
        }
        ynn(t) {
            return this._S.toLowerCase().includes(t)
        }
        DXe() {
            this.v0e = this.Get.getBoundingClientRect()
        }
        OW(t) {
            this.Xwi().qin() && this.bq() || this.YB(),
            this.IJt.uE(this, t) || (t.preventDefault(),
            t.stopPropagation())
        }
        xnn(t, i) {
            if (US.Ge(t),
            US.Ge(i),
            !this.v0e)
                return !1;
            let e = this.v0e;
            return t >= e.left && i >= e.top && t < e.right && i < e.bottom
        }
    }
}
{
    const NS = self.t
      , jS = 500
      , $S = 20;
    let zS = 0
      , VS = 0
      , WS = 0
      , HS = 0
      , KS = null
      , qS = !1
      , XS = !0
      , YS = null
      , JS = null
      , ZS = null
      , QS = null
      , tx = 0
      , ix = 0
      , ex = 0
      , sx = !1
      , nx = !1
      , rx = -1;
    function hx(t, i) {
        -1 === rx && (sx || nx) && KS && YS && (rx = requestAnimationFrame( () => {
            if (rx = -1,
            !YS)
                return;
            let e = YS.hk()
              , s = YS.Kpt()
              , n = s.width
              , r = s.height
              , h = t - s.left
              , o = i - s.top
              , a = 0
              , l = 0;
            sx && (h <= $S || h >= n - $S) && (h <= $S ? a = -Math.abs(h - $S) : h >= n - $S && (a = Math.abs(h - (n - $S)))),
            nx && (o <= $S || o >= r - $S) && (o <= $S ? l = -Math.abs(o - $S) : o >= r - $S && (l = Math.abs(o - (r - $S)))),
            0 === a && 0 === l || (0 !== a && 0 !== l && (a /= Math.SQRT2,
            l /= Math.SQRT2),
            0 !== a && (e.scrollLeft += a / self.devicePixelRatio),
            0 !== l && (e.scrollTop += l / self.devicePixelRatio),
            YS.pnn(),
            hx(zS, VS))
        }
        ))
    }
    function ox(t, i) {
        zS = t.clientX,
        VS = t.clientY;
        let e = Math.abs(WS - zS)
          , s = Math.abs(HS - VS);
        if (KS && XS) {
            if ("sortable" === i)
                NS.qs.Jj.kWi.Bsn("attemptitemsort", JS, zS, VS);
            XS = !1
        }
        if (e * e + s * s < jS && !qS)
            return;
        if (KS && !qS) {
            switch (i) {
            case "sortable":
                NS.qs.Jj.kWi.Bsn("startitemsort", JS, zS, VS);
                break;
            case "draggable":
                NS.qs.Jj.kWi.Bsn("dragstart", JS, zS, VS)
            }
            KS.style.visibility = "visible",
            qS = !0
        }
        NS.qs.Jj.kWi.Enn(zS, VS);
        if (KS && YS)
            switch (hx(zS, VS),
            i) {
            case "sortable":
                if (ZS) {
                    if (ZS.xnn(zS, VS)) {
                        let t = ZS.hk();
                        return t.setAttribute("drop-target", ""),
                        void t.setAttribute("hit-side", ZS.Cnn(zS, VS))
                    }
                    ZS._nn()
                }
                for (let t of YS.items())
                    if (t !== JS && t.xnn(zS, VS)) {
                        ZS = t;
                        let i = ZS.hk();
                        return i.setAttribute("drop-target", ""),
                        void i.setAttribute("hit-side", t.Cnn(zS, VS))
                    }
                ZS = null;
                break;
            case "draggable":
                qS && NS.qs.Jj.kWi.Bsn("dragmove", JS, zS, VS)
            }
    }
    function ax(t, i) {
        if (KS)
            switch (KS.parentNode.removeChild(KS),
            i) {
            case "sortable":
                if (ZS !== JS && JS && ZS) {
                    const t = YS.wF();
                    if (t <= 1) {
                        let t = YS.cnn(ZS)
                          , i = YS.cnn(JS)
                          , e = ZS.hk().getAttribute("hit-side");
                        t = YS.dnn(JS, t, e),
                        NS.qs.Jj.kWi.Tnn(i, t, JS)
                    } else if (t > 1) {
                        let t = YS.cnn(ZS)
                          , i = ZS.Cnn(zS, VS);
                        const e = [...YS.qB()]
                          , s = e.map(t => ({
                            tWi: YS.cnn(t),
                            sWi: NaN,
                            item: t,
                            Inn: NaN,
                            delta: NaN
                        }));
                        let n = YS.cnn(JS);
                        const r = []
                          , h = [];
                        for (const t of s)
                            t.delta = Math.abs(t.tWi - n),
                            t.tWi < n ? (t.sWi = n - t.delta,
                            r.push(t)) : t.tWi > n && (t.sWi = n + t.delta,
                            h.push(t));
                        r.sort( (t, i) => i.sWi - t.sWi),
                        h.sort( (t, i) => t.sWi - i.sWi);
                        const o = []
                          , a = []
                          , l = YS.cnn(JS);
                        t = YS.dnn(JS, t, i),
                        o.push(l),
                        a.push(t);
                        for (let i = 0; i < r.length; i++) {
                            const e = r[i];
                            t = YS.cnn(JS),
                            e.tWi = YS.cnn(e.item),
                            e.sWi = t - e.delta;
                            let s = "right";
                            e.sWi < 0 && (e.sWi = 0,
                            s = "left"),
                            e.sWi = YS.dnn(e.item, e.sWi, s),
                            NS.Go(e.tWi) && NS.Go(e.sWi) && (o.push(e.tWi),
                            a.push(e.sWi))
                        }
                        for (let i = 0; i < h.length; i++) {
                            const e = h[i];
                            t = YS.cnn(JS),
                            e.tWi = YS.cnn(e.item),
                            e.sWi = t + e.delta;
                            let s = "left";
                            e.sWi >= YS.OJt() && (e.sWi = YS.OJt() - 1,
                            s = "right"),
                            e.sWi = YS.dnn(e.item, e.sWi, s),
                            NS.Go(e.tWi) && NS.Go(e.sWi) && (o.push(e.tWi),
                            a.push(e.sWi))
                        }
                        NS.qs.Jj.kWi.Pnn(o, a, e)
                    }
                }
                ux();
                break;
            case "draggable":
                qS && NS.qs.Jj.kWi.Bsn("drop", JS, t.clientX, t.clientY),
                ux()
            }
    }
    function lx(t, i) {
        KS && KS.parentNode.removeChild(KS),
        ux(),
        cancelAnimationFrame(rx),
        rx = -1
    }
    function ux() {
        ZS && ZS._nn(),
        KS = null,
        YS = null,
        ZS = null,
        JS = null
    }
    NS.qs.Jj.kWi = class extends NS.qs.Jj.n0t {
        constructor(t, i, e, s, n, r) {
            NS.U(t, NS.qs.Jj.PJt),
            NS.Mw(i, NS.qs.O_),
            NS.u7t(e),
            NS.cO(n),
            super(t, i, e, s, n, void 0, r = !!r),
            this.Gnn = NS.qs.lk("div", this.Get, null, "dropTargetDownArrow"),
            this.Ann = NS.qs.lk("div", this.Get, null, "dropTargetUpArrow"),
            this.Rnn = NS.qs.lk("div", this.Get, null, "dropTargetBorder")
        }
        LUt() {
            cancelAnimationFrame(rx),
            NS.qs.BW(this.Gnn),
            NS.qs.BW(this.Ann),
            NS.qs.BW(this.Rnn),
            this.Gnn = null,
            this.Ann = null,
            this.Rnn = null,
            super.LUt()
        }
        IW(t) {
            if (super.IW(t),
            t.button !== NS.f1.e5)
                return;
            if (!t.isPrimary)
                return;
            let i = this.Xwi();
            i.pnn();
            let e = this.Get.cloneNode(!0);
            e.setAttribute("ghost", ""),
            e.setAttribute(i.Qsn(), ""),
            e.style.visibility = "hidden",
            i.wF() > 1 && (e.textContent = self.iG("ui.controls.icon-view.multi-select-drag-tooltip", null, i.wF())),
            qS = !1,
            XS = !0;
            let s, n = NS.Edi(i.bF(), "dialog");
            s = n || this.Get.ownerDocument.body,
            s.appendChild(e),
            tx = s.offsetLeft,
            ix = s.offsetTop,
            ex = NS.qs.Jj.kWi.knn(s),
            QS = e.getBoundingClientRect(),
            KS = e,
            ZS = this,
            JS = this,
            YS = i,
            cancelAnimationFrame(rx),
            rx = -1,
            sx = YS.hk().clientWidth < YS.hk().scrollWidth,
            nx = YS.hk().clientHeight < YS.hk().scrollHeight,
            zS = t.clientX,
            VS = t.clientY,
            WS = t.clientX,
            HS = t.clientY,
            NS.qs.Jj.kWi.Enn(zS, VS)
        }
        Gz(t) {
            super.Gz(t),
            t.isPrimary && this.fgi(t, "sortable")
        }
        Cz(t) {
            super.Cz(t),
            t.isPrimary && this.ugi(t, "sortable")
        }
        b2(t) {
            super.b2(t),
            this.pgi(t, "sortable")
        }
        fgi(t, i) {
            NS.zt(i),
            ox(t, i)
        }
        ugi(t, i) {
            NS.zt(i),
            ax(t, i)
        }
        pgi(t, i) {
            NS.zt(i),
            lx()
        }
        xnn(t, i) {
            if (NS.Ge(t),
            NS.Ge(i),
            !this.v0e)
                return !1;
            let e = this.v0e;
            return t >= e.left && i >= e.top && t < e.right && i < e.bottom
        }
        Cnn(t, i) {
            if (NS.Ge(t),
            NS.Ge(i),
            !this.v0e)
                return "";
            let e = this.v0e;
            return t >= e.left && t <= e.left + e.width / 2 ? "left" : "right"
        }
        _nn() {
            let t = this.hk();
            t.removeAttribute("drop-target"),
            t.removeAttribute("hit-side")
        }
        static Enn(t, i) {
            if (NS.Ge(t),
            NS.Ge(i),
            KS) {
                let e = -tx + t - ex - QS.width / 2
                  , s = -ix + i - ex - QS.height / 2
                  , n = NS.Edi(KS, "dialog");
                if (n) {
                    let t = NS.qs.Ys.lZe(n);
                    e -= t._a(),
                    s -= t.Da()
                }
                KS.style.transform = `translateX(${e}px) translateY(${s}px)`
            }
        }
        static knn(t) {
            NS.zlt(t);
            let i = NS.qs.yQ(["border-width", "border-left-width", "border-right-width", "border-bottom-width", "border-top-width"], {
                vQ: t
            });
            if (!i.endsWith("px"))
                throw new Error("CSS style for menu border-width must be in units of 'px'");
            return parseFloat(i) || 0
        }
        static Bsn(t, i, e, s) {
            NS.zt(t);
            let n = new NS.Event(t);
            n.item = i,
            n.clientX = e,
            n.clientY = s,
            i.Xwi().dispatchEvent(n)
        }
        static Tnn(t, i, e) {
            NS.Ge(t),
            NS.Ge(i),
            NS.U(e, NS.qs.Jj.n0t);
            let s = new NS.Event("itemsorted");
            s.tWi = t,
            s.sWi = i,
            s.item = e,
            e.Xwi().dispatchEvent(s)
        }
        static Pnn(t, i, e) {
            NS._D(t),
            NS._D(i),
            NS.YJ(e, NS.qs.Jj.n0t);
            let s = new NS.Event("itemssorted");
            s.nWi = t,
            s.rWi = i,
            s.items = e,
            e[0].Xwi().dispatchEvent(s)
        }
        static Uht() {
            return !!KS
        }
        static bXt() {
            if (KS)
                return JS
        }
        static kH() {
            KS && (JS ? JS.b2() : lx())
        }
    }
}
{
    const cx = self.t;
    cx.qs.Jj.snn = class extends cx.qs.Jj.kWi {
        constructor(t, i, e, s, n, r) {
            cx.U(t, cx.qs.Jj.PJt),
            cx.Mw(i, cx.qs.O_),
            cx.u7t(e),
            cx.cO(n),
            super(t, i, e, s, n, r = !!r),
            this.Gnn.style.display = "none",
            this.Ann.style.display = "none",
            this.Rnn.style.display = "none"
        }
        fgi(t, i) {
            cx.zt(i),
            super.fgi(t, "draggable")
        }
        ugi(t, i) {
            cx.zt(i),
            super.ugi(t, "draggable")
        }
        pgi(t, i) {
            cx.zt(i),
            super.pgi(t, "draggable")
        }
    }
}
{
    const dx = self.t;
    dx.qs.Jj.mnn = class extends dx.Me {
        constructor(t, i) {
            dx.U(t, dx.qs.Jj.PJt),
            dx.zt(i),
            super(),
            this.IJt = t,
            this.rVt = i,
            this.Ibt = dx.qs.lk("div", this.IJt.hk(), null, "iconview-group"),
            this.Rbt = dx.qs.lk("div", this.Ibt, null, "iconview-grouptitle"),
            this.VSt = dx.qs.lk("span", this.Rbt, null, "iconview-groupname"),
            this.Onn = dx.qs.lk("span", this.Rbt, null, "iconview-grouprule"),
            this.b_i = dx.qs.lk("div", this.Ibt, null, "iconview-groupcontent"),
            this._es = [],
            this.Dnn = 0,
            this.vnn = !1,
            this.VSt.textContent = this.rVt
        }
        Snn() {
            return this.b_i
        }
        LUt(t) {
            dx.sc(this._es),
            t || (dx.qs.BW(this.b_i),
            dx.qs.BW(this.Onn),
            dx.qs.BW(this.VSt),
            dx.qs.BW(this.Rbt),
            dx.qs.BW(this.Ibt)),
            this.b_i = null,
            this.Onn = null,
            this.VSt = null,
            this.Rbt = null,
            this.Ibt = null,
            this.IJt = null,
            dx.he(this)
        }
        Pk(t, i, e, s) {
            let n = this.IJt.Pk(t, i, e, s, this);
            return this._es.push(n),
            n
        }
        Mnn(t, i) {
            dx.U(t, dx.qs.Jj.n0t),
            (i = !!i) ? this.Dnn++ : this.Dnn--,
            this.Upt(this.Dnn === this._es.length)
        }
        Upt(t) {
            t = !!t,
            this.vnn !== t && (this.vnn = t,
            dx.qs.CD(this.Ibt, "hidden", this.vnn))
        }
        Vpt() {
            return this.vnn
        }
    }
}
{
    const fx = self.t
      , px = {
        wrap: !0,
        flex: !0
    };
    fx.qs.rA = class extends fx.Event.aG {
        constructor(t, i, e) {
            fx.zlt(t),
            fx.U(i, fx.qs.Window),
            fx._U(e),
            super(),
            e = Object.assign({}, px, e),
            this.hVt = t,
            this.Fnn = i,
            this.Lnn = [],
            this.Bnn = new Map,
            this.Unn = !1,
            this.RBi = null,
            this.Nnn = [],
            this.xUt = e,
            this.xUt.flex && (this.hVt.style.display = "flex"),
            this.EUt = t => this.pW(),
            this.zUt = t => this.wW(),
            this.UUt = t => this.mW(),
            this.NUt = t => this.yW(),
            this.Fnn.addEventListener("beforepopupopen", this.EUt),
            this.Fnn.addEventListener("afterpopupopen", this.zUt),
            this.Fnn.addEventListener("beforepopupclose", this.UUt),
            this.Fnn.addEventListener("afterpopupclose", this.NUt),
            this.Tz()
        }
        he() {
            fx.sc(this.Nnn),
            this.Nnn = null,
            this.XW();
            for (let t = 0; t < this.Lnn.length; t++)
                this.Lnn[t].jnn() && this.Lnn[t].he();
            for (let t of this.Bnn)
                t.he();
            fx.qs.BW(this.RBi),
            Array.prototype.forEach.call(this.hVt.getElementsByTagName("ui-toolbar-remaining-space"), t => {
                fx.qs.BW(t)
            }
            ),
            Array.prototype.forEach.call(this.hVt.getElementsByTagName("ui-toolbar-container"), t => {
                fx.qs.BW(t)
            }
            ),
            this.Fnn.removeEventListener("beforepopupopen", this.EUt),
            this.EUt = null,
            this.Fnn.removeEventListener("afterpopupopen", this.zUt),
            this.zUt = null,
            this.Fnn.removeEventListener("beforepopupclose", this.UUt),
            this.UUt = null,
            this.Fnn.removeEventListener("afterpopupclose", this.NUt),
            this.NUt = null,
            this.Fnn = null,
            this.hVt.style.display = "",
            this.hVt = null,
            this.Lnn = null,
            this.RBi = null,
            this.Bnn = null,
            super.he()
        }
        YBt() {
            return this.RBi
        }
        rPt() {
            if (!this.hVt)
                throw new Error("missing parent element");
            let t = this.hVt.querySelector("ui-toolbar-container[level='0']");
            if (!t)
                throw new Error("missing root container element");
            return t
        }
        wA(t, i, e, s) {
            fx.zt(t),
            fx.Ge(i),
            fx._D(e),
            s = Object.assign({}, this.xUt, s);
            let n = fx.v(fx.qs.Jj.$nn, this, this.hVt, t, i, "horizontal", "required", s);
            return this.Lnn.push(n),
            this.Unn = !0,
            this.znn(n, e),
            n
        }
        mki(t, i, e, s) {
            fx.zt(t),
            fx.Ge(i),
            fx._D(e),
            s = Object.assign({}, this.xUt, s);
            let n = fx.v(fx.qs.Jj.$nn, this, this.hVt, t, i, "vertical", "required", s);
            return this.Lnn.push(n),
            this.Unn = !0,
            this.znn(n, e),
            n
        }
        wki(t, i, e, s) {
            fx.zt(t),
            fx.Ge(i),
            fx._D(e),
            s = Object.assign({}, this.xUt, s);
            let n = fx.v(fx.qs.Jj.$nn, this, this.hVt, t, i, "horizontal", "optional", s);
            this.Bnn.set(t, n),
            this.znn(n, e)
        }
        Vnn(t, i, e) {
            fx.zt(t),
            fx.Ge(i),
            fx._D(e);
            let s = fx.v(fx.qs.Jj.$nn, this, this.hVt, t, i, "vertical", "optional", this.xUt);
            this.Bnn.set(t, s),
            this.znn(s, e)
        }
        Ski(t) {
            fx.qd(t),
            this.Nnn.push(t)
        }
        Wnn() {
            return !!this.Nnn && (!!this.Nnn.length && this.Nnn.some(t => t()))
        }
        O_i(t, i) {
            fx.zt(t),
            i = !!i;
            let e = this.Bnn.get(t);
            if (self.assert(e, "optional toolbar is not present in this toolbar layout"),
            i) {
                if (-1 !== this.Lnn.indexOf(e))
                    return;
                this.Lnn.push(e)
            } else {
                if (-1 === this.Lnn.indexOf(e))
                    return;
                this.Lnn.splice(this.Lnn.indexOf(e), 1)
            }
            e.x_(i),
            this.Unn = !0
        }
        Eki(t) {
            t = !!t;
            for (let i of this.Bnn.keys())
                this.O_i(i, t)
        }
        xki() {
            for (let t = 0; t < this.Lnn.length; t++) {
                if (this.Lnn[t].Hnn())
                    return !0
            }
            return !1
        }
        _ki(t) {
            return fx.zt(t),
            !!this.Bnn.get(t)
        }
        rTi(t) {
            fx.zt(t);
            for (let i = 0; i < this.Lnn.length; i++) {
                let e = this.Lnn[i];
                e.Njt() == t && e.Knn()
            }
        }
        fA() {
            if (!this.Unn)
                return;
            this.Unn = !1;
            let t = 0
              , i = 0;
            this.RBi && (t = this.RBi.scrollLeft,
            i = this.RBi.scrollTop);
            let e = this.hVt.querySelector("ui-toolbar-container[level='0']");
            e && e.parentNode.removeChild(e);
            let s = this.Lnn.length
              , n = this.hVt
              , r = this.hVt.getBoundingClientRect();
            for (let t = 0; t < s; t++) {
                let i = this.Lnn[t]
                  , e = i.hk()
                  , h = fx.qs.lk("ui-toolbar-container", n);
                h.setAttribute("level", t.toString()),
                h.appendChild(e);
                let o, a = h.getBoundingClientRect();
                i.GZi() ? h.setAttribute("horizontal", "") : i.CZi() && h.setAttribute("vertical", ""),
                i.qnn() ? h.setAttribute("wrap", "") : i.__() ? (h.style.setProperty("--parent-x-offset", `${Math.abs(r.left - a.left)}px`),
                h.style.setProperty("--parent-y-offset", `${Math.abs(r.top - a.top)}px`)) : (h.style.setProperty("--parent-x-offset", "0px"),
                h.style.setProperty("--parent-y-offset", "0px")),
                t == s - 1 ? this.RBi ? o = h.appendChild(this.RBi) : (o = fx.qs.lk("ui-toolbar-layout-remaining-space", h),
                this.xUt.wrap && o.setAttribute("wrap", "")) : o = fx.qs.lk("ui-toolbar-remaining-space", h),
                n = o
            }
            for (let t = 0; t < s; t++)
                this.Lnn[t].dte();
            this.RBi = n,
            this.RBi.scrollLeft = t,
            this.RBi.scrollTop = i
        }
        G6i() {
            if (!this.xUt.wrap) {
                let t = this.hVt.getBoundingClientRect()
                  , i = this.hVt.querySelectorAll("ui-toolbar-container")
                  , e = i.length;
                for (let s = 0; s < e; s++) {
                    let e = i[s]
                      , n = e.getBoundingClientRect()
                      , r = (e.style,
                    Number(e.getAttribute("level")));
                    this.Lnn[r].__() ? (e.style.setProperty("--parent-x-offset", `${Math.abs(t.left - n.left)}px`),
                    e.style.setProperty("--parent-y-offset", `${Math.abs(t.top - n.top)}px`)) : (e.style.setProperty("--parent-x-offset", "0px"),
                    e.style.setProperty("--parent-y-offset", "0px"))
                }
            }
        }
        Bg(t) {
            if (fx.Ots(t))
                for (let i = 0; i < this.Lnn.length; i++)
                    this.Lnn[i].Bg(t);
            else if (fx.doe(t)) {
                let i = this.$s(t);
                i && i.Bg()
            } else
                for (let t = 0; t < this.Lnn.length; t++)
                    this.Lnn[t].Bg()
        }
        $s(t) {
            fx.zt(t);
            for (let i = 0; i < this.Lnn.length; i++)
                if (this.Lnn[i].Njt() === t)
                    return this.Lnn[i]
        }
        hk(t) {
            fx.zt(t);
            for (let i = 0; i < this.Lnn.length; i++) {
                let e = this.Lnn[i].bA(t);
                if (e && e.Njt() === t)
                    return e
            }
            throw new Error("id does not correspong to any toolbar element")
        }
        Xnn(t) {
            fx.zt(t);
            let i = this.hk(t);
            return !!i && i.__()
        }
        wO() {
            const t = {};
            for (const i of this.Lnn) {
                t[i.Njt()] = i.wO()
            }
            return t
        }
        yO(t) {
            if (t)
                for (const i of Object.keys(t)) {
                    const e = this.$s(i);
                    e && e.yO(t[i])
                }
        }
        Tz() {
            for (const t of this.Lnn)
                t.TWi()
        }
        XW() {
            for (const t of this.Lnn)
                t.OWi()
        }
        pW() {
            this.XW()
        }
        wW() {
            this.Tz()
        }
        mW() {
            this.XW()
        }
        yW() {
            this.Tz()
        }
        static Ynn(t) {
            t.group = "",
            t.ePt = function(i) {
                return fx.zt(i),
                t.group = i,
                t
            }
        }
        static Jnn(t) {
            t.options = {},
            t.sJt = function(i) {
                return fx.Hut(i),
                t.options = i,
                t
            }
        }
        static pA(t, i, e, s, n) {
            fx.zt(t),
            fx.U(i, fx.qs.O_),
            fx.Kq(e);
            let r = {
                type: "click",
                id: t,
                icon: i,
                Dk: e,
                Znn: s,
                disable: n = !!n
            };
            return this.Ynn(r),
            this.Jnn(r),
            r
        }
        static nPt(t, i, e, s, n) {
            fx.zt(t),
            fx.U(i, fx.qs.O_),
            fx.Kq(e);
            let r = {
                type: "check",
                id: t,
                icon: i,
                Dk: e,
                Qnn: s,
                disable: n = !!n
            };
            return this.Ynn(r),
            this.Jnn(r),
            r
        }
        static trn(t, i, e, s, n, r) {
            fx.zt(t),
            fx.U(i, fx.qs.O_),
            fx.U(e, fx.qs.O_),
            fx.Kq(s);
            let h = {
                type: "switch",
                id: t,
                irn: i,
                ern: e,
                Dk: s,
                Qnn: n,
                disable: r = !!r
            };
            return this.Ynn(h),
            this.Jnn(h),
            h
        }
        static sPt(t, i, e, s, n) {
            fx.zt(t),
            fx.U(i, fx.qs.O_),
            fx.Kq(e);
            let r = {
                type: "radio",
                id: t,
                icon: i,
                Dk: e,
                Qnn: s,
                disable: n = !!n
            };
            return this.Ynn(r),
            this.Jnn(r),
            r
        }
        static hA(t, i, e, s, n, r, h) {
            fx.zt(t),
            fx.U(i, fx.qs.O_),
            fx.Kq(e),
            fx.Kq(s);
            let o = {
                type: "split",
                id: t,
                icon: i,
                srn: e,
                nrn: s,
                rrn: n,
                hrn: r,
                disable: h = !!h
            };
            return this.Ynn(o),
            this.Jnn(o),
            o
        }
        static orn(t, i, e, s, n, r, h) {
            fx.zt(t),
            fx.U(i, fx.qs.O_),
            fx.Kq(e),
            fx.Kq(s);
            let o = {
                type: "splitcheck",
                id: t,
                icon: i,
                srn: e,
                nrn: s,
                rrn: n,
                hrn: r,
                disable: h = !!h
            };
            return this.Ynn(o),
            this.Jnn(o),
            o
        }
        static hPt(t, i, e, s, n, r, h) {
            fx.zt(t),
            fx.U(i, fx.qs.O_),
            fx.Kq(e),
            fx.Kq(s);
            let o = {
                type: "splitradio",
                id: t,
                icon: i,
                srn: e,
                nrn: s,
                rrn: n,
                hrn: r,
                disable: h = !!h
            };
            return this.Ynn(o),
            this.Jnn(o),
            o
        }
        static Nk(t, i, e) {
            fx.Kq(i);
            let s = {
                id: i,
                type: "separator",
                hidden: t = !!t,
                disable: e = !!e
            };
            return this.Ynn(s),
            this.Jnn(s),
            s
        }
        static bki(t, i, e, s, n, r, h, o, a) {
            fx.zt(t),
            fx.Ge(i),
            fx.Ge(e),
            fx.cO(s),
            fx.cO(n),
            fx.Kq(r);
            let l = {
                type: "slider",
                id: t,
                min: i,
                max: e,
                step: s,
                value: n,
                label: r,
                arn: h,
                disable: o = !!o,
                lrn: a = !!a
            };
            return this.Ynn(l),
            this.Jnn(l),
            l
        }
        static gki(t, i, e, s, n, r, h) {
            fx.zt(t),
            fx._D(i),
            fx.cO(e),
            fx.Kq(s);
            let o = {
                type: "stepslider",
                id: t,
                crn: i,
                value: e,
                label: s,
                arn: n,
                disable: r = !!r,
                lrn: h = !!h
            };
            return this.Ynn(o),
            this.Jnn(o),
            o
        }
        static drn(t, i, e) {
            fx.zt(t);
            let s = {
                type: "color",
                id: t,
                frn: i,
                disable: e = !!e
            };
            return this.Ynn(s),
            this.Jnn(s),
            s
        }
        static sue(t, i, e, s, n) {
            fx.zt(t),
            fx.Kq(i);
            let r = {
                type: "checkbox",
                id: t,
                label: i,
                Qnn: e,
                disable: s = !!s,
                lrn: n = !!n
            };
            return this.Ynn(r),
            this.Jnn(r),
            r
        }
        static aJt(t, i, e, s, n, r, h, o, a, l) {
            fx.zt(t),
            fx.cO(i),
            fx.cO(e),
            fx.cO(s),
            fx.cO(n),
            fx.Kq(r),
            fx.Kq(h);
            let u = {
                type: "spinner",
                id: t,
                min: i,
                max: e,
                step: s,
                value: n,
                label: r,
                Dk: h,
                prn: o,
                disable: a = !!a,
                lrn: l = !!l
            };
            return this.Ynn(u),
            this.Jnn(u),
            u
        }
        static fZt(t, i, e, s, n, r) {
            fx.zt(t),
            fx.X_t(s),
            fx.Kq(i);
            let h = {
                type: "textbox",
                value: i,
                label: e,
                id: t,
                frn: s,
                disable: n = !!n,
                lrn: r
            };
            return this.Ynn(h),
            this.Jnn(h),
            h
        }
        static lJt(t, i, e, s, n, r) {
            fx.zt(t),
            fx.X_t(s),
            fx.zAt(i);
            let h = {
                type: "dropdown",
                id: t,
                values: i,
                label: e,
                frn: s,
                disable: n = !!n,
                lrn: r
            };
            return this.Ynn(h),
            this.Jnn(h),
            h
        }
        static hJt(t, i, e, s, n, r) {
            fx.zt(t),
            fx.X_t(s),
            fx.zAt(i);
            let h = {
                type: "editable-dropdown",
                id: t,
                values: i,
                label: e,
                frn: s,
                disable: n = !!n,
                lrn: r
            };
            return this.Ynn(h),
            this.Jnn(h),
            h
        }
        static cA() {
            return this.uA(26)
        }
        static iPt() {
            return this.uA(35)
        }
        static mrn() {
            return this.uA(45)
        }
        static uA(t) {
            return fx.Ge(t),
            Math.round(fx.qs.uA() * (t / 13))
        }
        static hXi(t, i) {
            fx.zlt(t),
            fx.U(i, fx.qs.rA);
            for (let e = 0; e < i.Lnn.length; e++)
                for (const s of i.Lnn[e].elements())
                    if (fx.vX(t, s))
                        return !0;
            return !1
        }
        znn(t, i) {
            for (let e = 0; e < i.length; e++) {
                let s = i[e];
                switch (s.type) {
                case "click":
                    t.pA(s.id, s.icon, s.Dk, s.Znn, s.options, s.disable, s.group);
                    break;
                case "check":
                    t.nPt(s.id, s.icon, s.Dk, s.Qnn, s.options, s.disable, s.group);
                    break;
                case "switch":
                    t.trn(s.id, s.irn, s.ern, s.Dk, s.Qnn, s.options, s.disable, s.group);
                    break;
                case "radio":
                    t.sPt(s.id, s.icon, s.Dk, s.Qnn, s.options, s.disable, s.group);
                    break;
                case "split":
                    t.hA(s.id, s.icon, s.srn, s.nrn, s.rrn, s.hrn, s.disable, s.group);
                    break;
                case "splitcheck":
                    t.orn(s.id, s.icon, s.srn, s.nrn, s.rrn, s.hrn, s.disable, s.group);
                    break;
                case "splitradio":
                    t.hPt(s.id, s.icon, s.srn, s.nrn, s.rrn, s.hrn, s.disable, s.group);
                    break;
                case "separator":
                    t.Nk(s.hidden, s.id, s.disable, s.group);
                    break;
                case "slider":
                    t.bki(s.id, s.min, s.max, s.step, s.value, s.label, s.arn, s.disable, s.lrn, s.group);
                    break;
                case "stepslider":
                    t.gki(s.id, s.crn, s.value, s.label, s.arn, s.disable, s.lrn, s.group);
                    break;
                case "color":
                    t.drn(s.id, s.frn, s.disable, s.group);
                    break;
                case "checkbox":
                    t.sue(s.id, s.label, s.Qnn, s.disable, s.lrn, s.group);
                    break;
                case "textbox":
                    t.wrn(s.id, s.value, s.label, s.frn, s.disable, s.lrn, s.group, s.options);
                    break;
                case "dropdown":
                    t.lJt(s.id, s.values, s.label, s.frn, s.options, s.disable, s.lrn, s.group);
                    break;
                case "editable-dropdown":
                    t.hJt(s.id, s.values, s.label, s.frn, s.options, s.disable, s.lrn, s.group);
                    break;
                case "spinner":
                    t.aJt(s.id, s.min, s.max, s.step, s.value, s.label, s.Dk, s.prn, s.disable, s.lrn, s.group)
                }
            }
        }
    }
}
{
    const mx = self.t
      , wx = self.assert
      , gx = new Set(["horizontal", "vertical"])
      , yx = new Set(["required", "optional"]);
    mx.qs.Jj.$nn = class extends mx.Me {
        constructor(t, i, e, s, n, r, h) {
            if (mx.U(t, mx.qs.rA),
            mx.zlt(i),
            mx.zt(e),
            mx.Ge(s),
            mx.zt(n),
            mx.zt(r),
            mx.Hut(h),
            super(),
            !gx.has(n))
                throw new Error(`invalid toolbar layout '${n}'`);
            if (!yx.has(r))
                throw new Error(`invalid toolbar type '${r}'`);
            this.xUt = h,
            this.grn = t,
            this.aKi = i,
            this.Nd = s,
            this.phs = e,
            this.m0e = "horizontal" === n,
            this.lVt = r,
            this.G2e = !0,
            this.yrn = !0,
            this.brn = !!h.wrap,
            this.lui = [],
            this.Get = mx.qs.lk("ui-toolbar"),
            this.Get.setAttribute("role", "toolbar"),
            this.Get.setAttribute(n, ""),
            this.hde = null,
            this.vrn = !1,
            this.brn ? this.Get.setAttribute("wrap", "") : (this.hde = t => this.DG(t),
            this.Get.addEventListener("scroll", this.hde)),
            this.x_(!1),
            this.Jft = 0,
            this.tut = 0
        }
        he() {
            this.Get.removeEventListener("scroll", this.hde),
            this.hde = null;
            for (let t = 0; t < this.lui.length; t++)
                this.lui[t].he();
            mx.qs.BW(this.Get),
            this.Get = null,
            this.aKi = null,
            this.lui = null,
            mx.he(this)
        }
        x_(t, i) {
            if (t = !!t,
            i = !!i,
            this.Hnn() || i) {
                if (t) {
                    if (this.G2e)
                        return;
                    this.Get.style.display = ""
                } else {
                    if (!this.G2e)
                        return;
                    this.Get.style.display = "none"
                }
                this.G2e = t
            }
        }
        Nki(t) {
            t = !!t;
            for (let i = 0; i < this.lui.length; i++)
                this.lui[i].x_(t)
        }
        __() {
            return this.G2e
        }
        jp() {
            return this.Nd
        }
        Srn() {
            this.Jft = this.Get.scrollLeft,
            this.tut = this.Get.scrollTop
        }
        dte() {
            this.Get.scrollLeft = this.Jft,
            this.Get.scrollTop = this.tut
        }
        Njt() {
            return this.phs
        }
        hk() {
            return this.Get
        }
        YBt() {
            let t = this.Get.nextSibling;
            for (; t; ) {
                if ("UI-TOOLBAR-REMAINING-SPACE" === t.tagName)
                    return t;
                if ("UI-TOOLBAR-LAYOUT-REMAINING-SPACE" === t.tagName)
                    return t;
                t = t.nextSibling
            }
        }
        xrn() {
            return this.grn
        }
        YIt() {
            return this.xUt
        }
        jnn() {
            return "required" === this.lVt
        }
        Hnn() {
            return "optional" === this.lVt
        }
        GZi() {
            return this.m0e
        }
        CZi() {
            return !this.m0e
        }
        qnn() {
            return this.brn
        }
        vA() {
            this.Get.setAttribute("transparent", "")
        }
        pA(t, i, e, s, n, r, h) {
            mx.zt(t),
            mx.U(i, mx.qs.O_),
            mx.Kq(e),
            mx.X_t(s),
            mx.zt(h);
            let o = mx.v(mx.qs.Jj.$nn.Ar, this, t, i, e, "click", s, n);
            o.bet(!r),
            o.ePt(h),
            this.lui.push(o)
        }
        nPt(t, i, e, s, n, r, h) {
            mx.zt(t),
            mx.U(i, mx.qs.O_),
            mx.Kq(e),
            mx.X_t(s),
            mx.zt(h);
            let o = mx.v(mx.qs.Jj.$nn.Ar, this, t, i, e, "check", s, n);
            o.bet(!r),
            o.ePt(h),
            this.lui.push(o)
        }
        trn(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx.U(i, mx.qs.O_),
            mx.U(e, mx.qs.O_),
            mx.Kq(s),
            mx.X_t(n),
            mx.zt(o);
            let a = mx.v(mx.qs.Jj.$nn.Mrn, this, t, i, e, s, "check", n, r);
            a.bet(!h),
            a.ePt(o),
            this.lui.push(a)
        }
        sPt(t, i, e, s, n, r, h) {
            mx.zt(t),
            mx.U(i, mx.qs.O_),
            mx.Kq(e),
            mx.X_t(s),
            mx.zt(h);
            let o = mx.v(mx.qs.Jj.$nn.Ar, this, t, i, e, "radio", s, n);
            o.bet(!r),
            o.ePt(h),
            this.lui.push(o)
        }
        hA(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx.U(i, mx.qs.O_),
            mx.Kq(e),
            mx.Kq(s),
            mx.X_t(n),
            mx.X_t(r),
            mx.zt(o);
            let a = mx.v(mx.qs.Jj.$nn.Ern, this, t, i, e, s, n, r);
            a.bet(!h),
            a.ePt(o),
            a.Tzt("click"),
            this.lui.push(a)
        }
        orn(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx.U(i, mx.qs.O_),
            mx.Kq(e),
            mx.Kq(s),
            mx.X_t(n),
            mx.X_t(r),
            mx.zt(o);
            let a = mx.v(mx.qs.Jj.$nn.Ern, this, t, i, e, s, n, r);
            a.bet(!h),
            a.ePt(o),
            a.Tzt("check"),
            this.lui.push(a)
        }
        hPt(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx.U(i, mx.qs.O_),
            mx.Kq(e),
            mx.Kq(s),
            mx.X_t(n),
            mx.X_t(r),
            mx.zt(o);
            let a = mx.v(mx.qs.Jj.$nn.Ern, this, t, i, e, s, n, r);
            a.bet(!h),
            a.ePt(o),
            a.Tzt("radio"),
            this.lui.push(a)
        }
        Nk(t, i, e, s) {
            mx.Kq(i),
            mx.zt(s),
            t = !!t;
            let n = mx.v(mx.qs.Jj.$nn.Crn, this, t, i);
            n.bet(!e),
            n.ePt(s),
            this.lui.push(n)
        }
        bki(t, i, e, s, n, r, h, o, a, l) {
            mx.zt(t),
            mx.Ge(i),
            mx.Ge(e),
            mx.cO(s),
            mx.cO(n),
            mx.Kq(r),
            mx.X_t(h),
            mx.zt(l),
            a = !!a;
            let u = mx.v(mx.qs.Jj.$nn._rn, this, t, i, e, s, n, r, h, a);
            u.bet(!o),
            u.ePt(l),
            this.lui.push(u)
        }
        gki(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx._D(i),
            mx.cO(e),
            mx.Kq(s),
            mx.X_t(n),
            mx.zt(o),
            h = !!h;
            let a = mx.v(mx.qs.Jj.$nn.Trn, this, t, i, e, s, n, h);
            a.bet(!r),
            a.ePt(o),
            this.lui.push(a)
        }
        drn(t, i, e, s) {
            mx.zt(t),
            mx.X_t(i),
            mx.zt(s);
            let n = mx.v(mx.qs.Jj.$nn.Tbi, this, t, i);
            n.bet(!e),
            n.ePt(s),
            this.lui.push(n)
        }
        sue(t, i, e, s, n, r) {
            mx.zt(t),
            mx.Kq(i),
            mx.X_t(e),
            mx.zt(r),
            n = !!n;
            let h = mx.v(mx.qs.Jj.$nn.Irn, this, t, i, e, n);
            h.bet(!s),
            h.ePt(r),
            this.lui.push(h)
        }
        aJt(t, i, e, s, n, r, h, o, a, l, u) {
            mx.zt(t),
            mx.cO(i),
            mx.cO(e),
            mx.cO(s),
            mx.cO(n),
            mx.Kq(r),
            mx.Kq(h),
            mx.X_t(o),
            mx.zt(u),
            l = !!l;
            let c = mx.v(mx.qs.Jj.$nn.Prn, this, t, i, e, s, n, r, h, o, l);
            c.bet(!a),
            c.ePt(u),
            this.lui.push(c)
        }
        wrn(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx.X_t(s),
            mx.Kq(i),
            mx.zt(h);
            let a = mx.v(mx.qs.Jj.$nn.Grn, this, t, i, e, s, r, o);
            a.bet(!n),
            a.ePt(h),
            this.lui.push(a)
        }
        lJt(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx.X_t(s),
            mx.zAt(i),
            mx.zt(o);
            let a = mx.v(mx.qs.Jj.$nn.Arn, this, t, i, e, s, n, h);
            a.bet(!r),
            a.ePt(o),
            this.lui.push(a)
        }
        hJt(t, i, e, s, n, r, h, o) {
            mx.zt(t),
            mx.X_t(s),
            mx.zAt(i),
            mx.zt(o);
            let a = mx.v(mx.qs.Jj.$nn.Rrn, this, t, i, e, s, n, h);
            a.bet(!r),
            a.ePt(o),
            this.lui.push(a)
        }
        Bg(t) {
            if (mx.Ots(t)) {
                mx.zt(t["element-group"]),
                "no-group" === t["element-group"] && (t["element-group"] = "");
                for (let i = 0; i < this.lui.length; i++) {
                    let e = this.lui[i];
                    e.krn() === t["element-group"] && e.Bg()
                }
            } else if (mx.doe(t))
                this.Orn(t);
            else
                for (let t = 0; t < this.lui.length; t++)
                    this.lui[t].Bg()
        }
        Knn() {
            for (let t = 0; t < this.lui.length; t++)
                this.lui[t].Knn()
        }
        bet(t) {
            (t = !!t) !== this.yrn && (t ? this.Get.removeAttribute("disable") : this.Get.setAttribute("disable", ""),
            this.yrn = t)
        }
        aZ() {
            return this.yrn
        }
        Orn(t) {
            mx.zt(t);
            let i = this.bA(t);
            i && i.Bg()
        }
        UA(t, i) {
            mx.zt(t),
            i = !!i;
            let e = this.bA(t);
            wx(e, "element is not part of toolbar"),
            e.bet(i)
        }
        BPt(t, i) {
            mx.zt(t);
            let e = this.bA(t);
            wx(e, "element is not part of toolbar"),
            e.Drn(i)
        }
        bA(t) {
            mx.zt(t);
            for (let i = 0; i < this.lui.length; i++)
                if (this.lui[i].Njt() === t)
                    return this.lui[i]
        }
        *elements() {
            for (let t = 0; t < this.lui.length; t++)
                yield this.lui[t].hk()
        }
        fPt(t, ...i) {
            mx.zt(t);
            let e = this.bA(t);
            e && e.wJt(...i)
        }
        Frn() {
            return this.vrn
        }
        wO() {
            return {
                scrollLeft: this.Jft,
                scrollTop: this.tut
            }
        }
        yO(t) {
            t && (this.Jft = t.scrollLeft,
            this.tut = t.scrollTop,
            this.Get.scrollLeft = this.Jft,
            this.Get.scrollTop = this.tut)
        }
        TWi() {
            for (let t = 0; t < this.lui.length; t++)
                this.lui[t].TWi()
        }
        OWi() {
            for (let t = 0; t < this.lui.length; t++)
                this.lui[t].OWi()
        }
        Lrn() {
            this.vrn = !1
        }
        DG(t) {
            this.Srn(),
            this.vrn = !0
        }
    }
}
{
    const bx = self.t;
    bx.qs.Jj.$nn.Element = class extends bx.Me {
        constructor(t, i, e) {
            bx.U(t, bx.qs.Jj.$nn),
            bx.Kq(i),
            bx.X_t(e),
            super(),
            this.Brn = t,
            this.phs = i,
            this.Get = null,
            this.Urn = e,
            this.Hai = !0,
            this.BLs = !0,
            this.bnn = ""
        }
        hk() {
            return this.Get
        }
        Njt() {
            return this.phs
        }
        PH() {
            return this.Get.ownerDocument || document
        }
        Nrn() {
            this.Brn.YIt().wrap && this.Get.setAttribute("wrap", "")
        }
        x_(t) {
            t = !!t,
            this.Hai !== t && (this.Get.style.display = t ? "" : "none",
            this.Hai = t)
        }
        __() {
            return this.Hai
        }
        bet(t) {
            t = !!t,
            this.BLs !== t && (t ? this.Get.removeAttribute("disable") : this.Get.setAttribute("disable", ""),
            this.BLs = t)
        }
        aZ() {
            return this.BLs
        }
        Drn(t) {}
        ePt(t) {
            bx.zt(t),
            this.bnn = t
        }
        krn() {
            return this.bnn
        }
        EA(t) {
            bx.zt(t),
            this.Get.setAttribute("title", t)
        }
        jrn(...t) {
            this.Urn && this.Urn(...t)
        }
        he() {
            bx.qs.BW(this.Get),
            this.Get = null,
            this.Brn = null,
            this.Urn = null
        }
        so() {
            bx.E4()
        }
        Bg() {
            bx.E4()
        }
        Knn() {
            bx.E4()
        }
        wJt() {
            bx.E4()
        }
        TWi() {}
        OWi() {}
        $rn(t, i) {
            for (var e in bx.Hut(t),
            bx._D(i),
            t)
                t.hasOwnProperty(e) && self.assert(i.includes(e), `'${e}' is not a supported update property. Supported update properties for this control are '${i.toString()}'`)
        }
    }
}
{
    const vx = self.t
      , Sx = ["color"];
    vx.qs.Jj.$nn.Tbi = class extends vx.qs.Jj.$nn.Element {
        constructor(t, i, e) {
            super(t, i, e),
            this.zrn = t => this.lUi(t),
            this.Get = vx.qs.lk("ui-toolbar-color-picker", this.Brn.hk()),
            this.Vrn = vx.qs.lk("input", this.Get, null, null, {
                type: "color"
            }),
            this.Vrn.addEventListener("change", this.zrn),
            this.dat = vx.qs.lk("span", this.Get),
            this.dat.innerHTML = this.Vrn.value,
            this.Nrn()
        }
        he() {
            this.Vrn.removeEventListener("change", this.zrn),
            vx.qs.BW(this.Vrn),
            vx.qs.BW(this.dat),
            this.zrn = null,
            this.Vrn = null,
            this.dat = null,
            super.he()
        }
        so(t) {
            vx.Hut(t),
            this.$rn(t, Sx),
            t.hasOwnProperty("color") && vx.doe(t.color) && (this.Vrn.value = t.color)
        }
        Bg() {}
        Knn() {
            this.Wrn()
        }
        wJt() {
            this.aZ()
        }
        lUi(t) {
            this.dat.innerHTML = this.Vrn.value,
            this.Wrn()
        }
        Wrn() {
            let t = new vx.Event("colorchange");
            t.Hrn = this.Brn.Njt(),
            t.Krn = this.phs.toLowerCase(),
            t.color = this.Vrn.value,
            this.Brn.xrn().dispatchEvent(t),
            this.jrn(this.Vrn.value)
        }
    }
}
{
    const xx = self.t
      , Mx = ["min", "max", "step", "value", "label"];
    xx.qs.Jj.$nn._rn = class extends xx.qs.Jj.$nn.Element {
        constructor(t, i, e, s, n, r, h, o, a) {
            xx.Ge(e),
            xx.Ge(s),
            xx.Ge(n),
            xx.cO(r),
            xx.Kq(h),
            super(t, i, o),
            this.qrn = e,
            this.Xrn = s,
            this.fTs = n || 1,
            this.LIs = r || 0,
            this.Yrn = this.LIs,
            this.Get = xx.qs.lk("ui-toolbar-slider", this.Brn.hk()),
            this.Vrn = xx.qs.lk("input", this.Get, null, null, {
                type: "range",
                min: e.toString(),
                max: s.toString(),
                step: this.fTs.toString(),
                value: this.LIs.toString()
            }),
            this.Jrn = xx.qs.lk("input", this.Get, null, null, {
                type: "number",
                min: e.toString(),
                max: s.toString(),
                step: this.fTs.toString(),
                value: this.Vrn.value.toString()
            }),
            this.dat = xx.qs.lk("span"),
            a ? (this.dat.setAttribute("side", "right"),
            this.Get.appendChild(this.dat)) : (this.dat.setAttribute("side", "left"),
            this.Get.insertBefore(this.dat, this.Vrn)),
            this.dat.textContent = h || i.charAt(0).toUpperCase() + i.slice(1),
            this.yh = null,
            this.Zrn = null,
            this.Qrn(),
            this.thn(),
            this.Nrn()
        }
        he() {
            xx.qs.BW(this.Vrn),
            xx.qs.BW(this.dat),
            xx.qs.BW(this.Jrn),
            this.yh && (this.yh.Vh(),
            this.yh = null),
            this.Zrn && (this.Zrn.Vh(),
            this.Zrn = null),
            this.Vrn = null,
            this.dat = null,
            this.Jrn = null,
            super.he()
        }
        so(t) {
            if (xx.Hut(t),
            this.$rn(t, Mx),
            t.hasOwnProperty("min") && xx.Go(t.min) && (this.qrn = t.min,
            this.Vrn.min = this.qrn.toString(),
            this.Jrn.min = this.qrn.toString()),
            t.hasOwnProperty("max") && xx.Go(t.max) && (this.Xrn = t.max,
            this.Vrn.max = this.Xrn.toString(),
            this.Jrn.max = this.qrn.toString()),
            t.hasOwnProperty("step") && xx.Go(t.step) && (this.fTs = t.step,
            this.Vrn.step = t.step.toString(),
            this.Jrn.step = t.step.toString()),
            t.hasOwnProperty("value") && xx.Go(t.value)) {
                let i = t.value.toString();
                this.Vrn.value = i,
                this.Jrn.value = i
            }
            t.hasOwnProperty("label") && xx.doe(t.label) && (this.Vrn.label = t.label)
        }
        Bg() {}
        Knn() {
            this.ihn("sliderchange")
        }
        wJt() {
            this.aZ()
        }
        Qrn() {
            this.yh = xx.v(xx.kh, xx.jh.Gh(this.Vrn, "input change", t => this.ISi(t)), xx.jh.Gh(this.Jrn, "keypress", t => this.ehn(t)), xx.jh.Gh(this.Jrn, "change input", t => this.shn(t)), xx.jh.Gh(this.Jrn, "blur", t => this.DUt()))
        }
        thn() {
            this.Zrn = xx.$Ci(this.Jrn)
        }
        ISi(t) {
            this.Jrn.value = this.Vrn.value,
            this.Yrn = Number(this.Vrn.value),
            "change" === t.type && this.ihn("sliderchange"),
            "input" === t.type && this.ihn("sliderinput")
        }
        ehn(t) {
            t.key.match(/[0-9.e\-]/) || t.preventDefault()
        }
        shn(t) {
            let i = this.Jrn.value;
            if (i.length && (i = Number(i),
            !isNaN(i))) {
                let t = this.nhn()
                  , e = this.rhn();
                if ((i > e || i < t) && (i = xx.Ne(i, t, e),
                this.Jrn.value = i),
                this.Vrn.value === i.toString())
                    return;
                this.Vrn.value = i,
                this.Yrn = i,
                this.ihn("sliderinput")
            }
        }
        DUt() {
            let t = this.Jrn.value;
            if (t = Number(t),
            isNaN(t))
                this.Jrn.value = this.Yrn;
            else {
                let i = this.nhn()
                  , e = this.rhn();
                if (t = xx.Ne(t, i, e),
                t /= this.fTs,
                t = Math.round(t) * this.fTs,
                this.Jrn.value === t.toString())
                    return;
                this.Jrn.value = t,
                this.Vrn.value = t,
                this.Yrn = t,
                this.ihn("sliderinput")
            }
        }
        hhn(t) {
            this.qrn = t,
            this.Jrn.setAttribute("min", t)
        }
        nhn() {
            return this.qrn
        }
        ohn(t) {
            this.Xrn = t,
            this.Jrn.setAttribute("max", t)
        }
        rhn() {
            return this.Xrn
        }
        ihn(t) {
            xx.zt(t);
            let i = new xx.Event(t);
            i.Hrn = this.Brn.Njt(),
            i.aDi = this.phs.toLowerCase(),
            i.lDi = NaN;
            let e = Number(this.Vrn.value);
            xx.Go(e) ? i.lDi = xx.Ne(e, this.qrn, this.Xrn) : i.lDi = this.qrn,
            this.Brn.xrn().dispatchEvent(i),
            this.jrn(i.lDi)
        }
    }
}
{
    const Ex = self.t
      , Cx = self.assert
      , _x = ["steps", "percentage", "value", "label"]
      , Tx = ["linear", "logarithmic"];
    Ex.qs.Jj.$nn.Trn = class extends Ex.qs.Jj.$nn._rn {
        constructor(t, i, e, s, n, r, h) {
            Ex._D(e),
            super(t, i, 0, 100, 1, Ex.Ne(s, 0, 100), n, r, h),
            this.ahn = [],
            this.lhn(e),
            this.hhn(this.ahn[0].uhn),
            this.ohn(this.ahn.at(-1).chn),
            this.Vrn.value = Ex.Ne(s, 0, 100).toString(),
            this.Jrn.value = this.dhn()
        }
        he() {
            Ex.sc(this.ahn),
            this.ahn = null,
            super.he()
        }
        so(t) {
            if (Ex.Hut(t),
            this.$rn(t, _x),
            t.hasOwnProperty("steps") && Ex.kft(t.steps) && (this.lhn(t.steps),
            this.hhn(this.ahn[0].uhn),
            this.ohn(this.ahn.at(-1).chn),
            this.Jrn.value = this.dhn()),
            t.hasOwnProperty("percentage") && Ex.Go(t.percentage)) {
                let i = Math.floor(t.percentage);
                this.Vrn.value = Ex.Ne(i, 0, 100).toString(),
                this.Jrn.value = this.dhn()
            }
            if (t.hasOwnProperty("value") && Ex.Go(t.value)) {
                let i = Math.floor(t.value);
                this.Jrn.value = Ex.Ne(i, this.ahn[0].uhn, this.ahn.at(-1).chn).toString(),
                this.Vrn.value = this.fhn()
            }
            t.hasOwnProperty("label") && Ex.doe(t.label) && (this.Vrn.label = t.label)
        }
        Bg() {}
        Knn() {
            this.ihn("sliderchange")
        }
        wJt() {
            this.aZ()
        }
        Qrn() {
            this.yh = Ex.v(Ex.kh, Ex.jh.Gh(this.Vrn, "input change", t => this.ISi(t)), Ex.jh.Gh(this.Jrn, "keypress", t => this.ehn(t)), Ex.jh.Gh(this.Jrn, "change input", t => this.shn(t)))
        }
        lhn(t) {
            Ex._D(t),
            Cx(t.length, "no steps defined for the step slider"),
            Ex.sc(this.ahn);
            let i = 0;
            for (var e = 0; e < t.length; e++) {
                let s = t[e];
                if (Ex.Hut(s),
                Ex.Ge(s.pki),
                Ex.Ge(s.max),
                Ex.cO(s.min),
                Ex.zt(s.scale),
                Cx(s.pki <= 100, "percentage slice of a step can not be larger than 100%"),
                Cx(s.pki > 0, "percentage slice of a step can not be lower than 0%"),
                Cx(Tx.includes(s.scale), `unexpected scale value '${s.scale}' for step. Valid values are '${Tx}'`),
                e > 0 && Ex.Go(s.min) && (() => {})("only the first step of a step slider needs to define a minimum value"),
                "logarithmic" === s.scale && Cx(0 !== s.max, "maximum value must be different of 0 when using a logarithmic scale"),
                0 === e) {
                    switch (s.scale) {
                    case "linear":
                        this.ahn.push({
                            phn: 0,
                            mhn: s.pki,
                            uhn: s.min || 0,
                            chn: s.max,
                            scale: s.scale
                        });
                        break;
                    case "logarithmic":
                        this.ahn.push({
                            phn: 0,
                            mhn: s.pki,
                            uhn: s.min || 1,
                            chn: s.max,
                            scale: s.scale
                        })
                    }
                    i += s.pki
                } else {
                    let n = t[e - 1];
                    this.ahn.push({
                        phn: n.pki,
                        mhn: s.pki,
                        uhn: n.max,
                        chn: s.max,
                        scale: s.scale
                    }),
                    i += s.pki - n.pki
                }
            }
            Cx(100 === i, "steps can not add up to more than 100%")
        }
        ISi(t) {
            let i = this.dhn();
            this.Jrn.value = i,
            this.Yrn = Number(this.Vrn.value),
            "change" === t.type && this.ihn("sliderchange"),
            "input" === t.type && this.ihn("sliderinput")
        }
        ehn(t) {
            t.key.match(/[0-9.e\-]/) || t.preventDefault()
        }
        shn(t) {
            let i = this.Jrn.value
              , e = this.nhn()
              , s = this.rhn();
            (i > s || i < e) && (i = Ex.Ne(i, e, s),
            this.Jrn.value = i);
            let n = this.fhn();
            Ex.Go(n) && (n = Ex.Ne(n, 0, 100),
            this.Vrn.value = n,
            this.Yrn = n,
            this.whn("sliderinput"))
        }
        ihn(t) {
            Ex.zt(t);
            let i = this.dhn();
            this.fgs(t, i)
        }
        whn(t) {
            Ex.zt(t);
            let i = this.nhn()
              , e = this.rhn()
              , s = Number(this.Jrn.value);
            (s > e || s < i) && (s = Ex.Ne(s, i, e)),
            this.fgs(t, s)
        }
        fgs(t, i) {
            Ex.zt(t),
            Ex.Ge(i);
            let e = new Ex.Event(t);
            e.Hrn = this.Brn.Njt(),
            e.aDi = this.phs.toLowerCase(),
            e.lDi = i,
            this.Brn.xrn().dispatchEvent(e),
            this.jrn(e.lDi)
        }
        ghn() {
            let t = this.Vrn.value;
            for (let i of this.ahn)
                if (t >= i.phn && t <= i.mhn)
                    return i
        }
        yhn() {
            let t = this.Jrn.value;
            for (let i of this.ahn)
                if (t >= i.uhn && t <= i.chn)
                    return i
        }
        bhn(t) {
            for (let i = 0; i < this.ahn.length; i++) {
                if (t === this.ahn[i] && 0 !== i)
                    return this.ahn[i - 1]
            }
        }
        dhn() {
            let t = Number(this.Vrn.value)
              , i = this.ghn();
            if (Cx(!isNaN(t), "step slider value is not a number"),
            i)
                switch (i.scale) {
                case "linear":
                    let e, s = this.bhn(i);
                    return e = s ? this.vhn(s).chn : i.uhn,
                    Math.round(Ex.Mrt(t, i.phn, i.mhn, e, i.chn));
                case "logarithmic":
                    let n = i.phn
                      , r = i.mhn
                      , h = Math.log(i.uhn)
                      , o = (Math.log(i.chn) - h) / (r - n);
                    return Math.round(Math.exp(h + o * (t - n)))
                }
        }
        fhn() {
            let t = Number(this.Jrn.value)
              , i = this.yhn();
            if (Cx(!isNaN(t), "step slider value is not a number"),
            i)
                switch (i.scale) {
                case "linear":
                    let e, s = this.bhn(i);
                    return e = s ? this.vhn(s).chn : i.uhn,
                    Math.round(Ex.Mrt(t, e, i.chn, i.phn, i.mhn));
                case "logarithmic":
                    let n = i.phn
                      , r = i.mhn
                      , h = Math.log(i.uhn)
                      , o = (Math.log(i.chn) - h) / (r - n);
                    return Math.round((Math.log(t) - h) / o + n)
                }
        }
    }
}
{
    const Ix = self.t
      , Px = [];
    Ix.qs.Jj.$nn.Crn = class extends Ix.qs.Jj.$nn.Element {
        constructor(t, i, e) {
            i = !!i,
            super(t, e),
            this.Get = Ix.qs.lk("ui-toolbar-separator", this.Brn.hk()),
            this.Get.style.visibility = i ? "hidden" : "",
            this.Brn.GZi() && (this.Get.setAttribute("horizontal", ""),
            this.Get.style.height = `${this.Brn.jp()}px`),
            this.Brn.CZi() && (this.Get.setAttribute("vertical", ""),
            this.Get.style.width = `${this.Brn.jp()}px`),
            this.Nrn()
        }
        he() {
            super.he()
        }
        so(t) {
            Ix.Hut(t),
            this.$rn(t, Px)
        }
        Bg() {}
        Knn() {}
        wJt() {}
    }
}
{
    const Gx = self.t
      , Ax = ["tooltip"]
      , Rx = new Set(["click", "check", "radio"])
      , kx = 1e3
      , Ox = 5
      , Dx = 100;
    let Fx = !1;
    const Lx = {
        button: Gx.f1.e5,
        preventDefault: () => {}
        ,
        fireEvent: !0
    }
      , Bx = {
        Shn: !1,
        oJt: "",
        rJt: "default"
    }
      , Ux = new Map;
    Ux.set("select", ["border-color"]);
    const Nx = new Map;
    Nx.set("dropdown", "select");
    const jx = new Map;
    Gx.qs.Jj.$nn.Ar = class extends Gx.qs.Jj.$nn.Element {
        constructor(t, i, e, s, n, r, h) {
            if (Gx.U(e, Gx.qs.O_),
            Gx.Kq(s),
            Gx.zt(n),
            super(t, i, r),
            !Rx.has(n))
                throw new Error(`invalid button type "${n}"`);
            if (this.lVt = n,
            this.xUt = Object.assign({}, Bx, h),
            this.xhn = !1,
            this.Mhn = !1,
            this.Ehn = -1,
            this.Chn = -1,
            this._hn = !1,
            this.Thn = !1,
            this.Get = Gx.qs.lk("ui-toolbar-button", this.Brn.hk()),
            "default" !== this.xUt.rJt && this.Get.setAttribute("corners", this.xUt.rJt),
            this.xUt.oJt) {
                const t = Nx.get(this.xUt.oJt);
                if (t) {
                    this.Get.setAttribute("support", t);
                    const i = Ux.get(t);
                    if (i)
                        for (const e of i) {
                            const s = `${t}-${e}`;
                            if (jx.has(s)) {
                                const t = jx.get(s);
                                this.Get.style.setProperty(`--${e}`, t)
                            } else {
                                const n = Gx.qs.lk(t, document.body)
                                  , r = getComputedStyle(n).getPropertyValue(i);
                                this.Get.style.setProperty(`--${e}`, r),
                                jx.set(s, r),
                                Gx.qs.BW(n)
                            }
                        }
                }
            }
            this.wat = Gx.v(Gx.qs.kmt, e, this.Get);
            let o = this.Brn.jp();
            this.Get.style.width = `${o}px`,
            this.Get.style.height = `${o}px`,
            s && (this.Get.setAttribute("title", s),
            this.Get.setAttribute("aria-label", s)),
            "click" === this.lVt ? (this.TUt = this.Ihn(this.Phn),
            this.SUt = this.Ihn(this.Ghn),
            this.Ahn = this.Ihn(),
            this.xFi = this.Ihn(this.Rhn),
            this.khn = this.Ihn(this.Ohn),
            this.Dhn = this.Ihn(this.Fhn)) : "check" === this.lVt ? (this.TUt = this.Ihn(this.Lhn),
            this.SUt = this.Ihn(),
            this.Ahn = this.Ihn(this.Bhn),
            this.xFi = this.Ihn(this.Uhn),
            this.khn = this.Ihn(this.Nhn),
            this.Dhn = this.Ihn(this.jhn)) : "radio" === this.lVt && (this.TUt = this.Ihn(this.Lhn),
            this.SUt = this.Ihn(),
            this.Ahn = this.Ihn(this.$hn),
            this.xFi = this.Ihn(this.zhn),
            this.khn = this.Ihn(this.Nhn),
            this.Dhn = this.Ihn(this.jhn)),
            this.Vhn = this.Ihn(this.OW),
            this.Whn = this.Ihn(this.Hhn),
            this.Get.addEventListener("pointerdown", this.TUt),
            this.Get.addEventListener("pointerup", this.SUt),
            this.Get.addEventListener("pointerup", this.Ahn),
            this.Get.addEventListener("pointercancel", this.xFi),
            this.Get.addEventListener("contextmenu", this.Vhn),
            this.Get.addEventListener("mouseout", this.khn),
            this.Get.addEventListener("mouseover", this.Dhn),
            this.Nrn(),
            this.Khn = NaN,
            this.qhn = NaN,
            this.Xhn = t => {
                this.Khn = NaN,
                this.qhn = NaN
            }
            ,
            this.Yhn = t => {
                this.Khn = t.clientX,
                this.qhn = t.clientY
            }
            ,
            this.TWi()
        }
        he() {
            this.xUt = null,
            this.Get.removeEventListener("pointerdown", this.TUt),
            this.Get.removeEventListener("pointerup", this.SUt),
            this.Get.removeEventListener("pointerup", this.Ahn),
            this.Get.removeEventListener("pointercancel", this.xFi),
            this.Get.removeEventListener("mouseout", this.khn),
            this.Get.removeEventListener("mouseover", this.Dhn),
            Gx.qs.BW(this.Get),
            this.wat.he(),
            this.wat = null,
            this.TUt = null,
            this.SUt = null,
            this.khn = null,
            this.Dhn = null,
            clearTimeout(this.Ehn),
            this.Ehn = -1,
            clearTimeout(this.Chn),
            this.Chn = -1,
            super.he()
        }
        TWi() {
            const t = this.Get.ownerDocument;
            t.addEventListener("pointerdown", this.Xhn, !0),
            t.addEventListener("pointermove", this.Yhn, !0)
        }
        OWi() {
            const t = this.Get.ownerDocument;
            t.removeEventListener("pointerdown", this.Xhn, !0),
            t.removeEventListener("pointermove", this.Yhn, !0)
        }
        so(t) {
            Gx.Hut(t),
            this.$rn(t, Ax),
            t.hasOwnProperty("tooltip") && Gx.doe(t.tooltip) && (this.Get.setAttribute("title", t.tooltip),
            this.Get.setAttribute("aria-label", t.tooltip))
        }
        Bg() {
            this.Get.removeAttribute("mouse-down"),
            this.Get.removeAttribute("mouse-over"),
            this.xhn && !this._hn && (this.xhn = !1,
            this.Get.addEventListener("pointerup", this.SUt),
            this.Get.addEventListener("pointercancel", this.xFi),
            this.Get.addEventListener("mouseout", this.khn),
            this.Get.addEventListener("mouseover", this.Dhn)),
            clearTimeout(this.Ehn),
            this.Ehn = -1,
            clearTimeout(this.Chn),
            this.Chn = -1
        }
        Knn() {}
        wJt(t=!0) {
            if (this.aZ())
                if (t = !!t,
                this.Mhn = !1,
                "click" === this.lVt) {
                    if (this.Thn)
                        return;
                    this.Phn(Lx, !1),
                    this.Thn = !0,
                    this.Chn = setTimeout( () => {
                        this.Thn = !1,
                        this.Ghn(Lx, t, !1),
                        this.Chn = -1
                    }
                    , Dx)
                } else
                    "check" === this.lVt ? this.Jhn(t, !1, !0, !1) : "radio" === this.lVt && this.Zhn(t, !0, !1)
        }
        bet(t) {
            super.bet(t),
            t || this.Bg()
        }
        CA(t) {
            this.wat.CA(t)
        }
        Drn(t) {
            if ("check" === this.lVt)
                switch (t) {
                case "check":
                    return this.Jhn(!1, !0, !0, !1);
                case "uncheck":
                    return this.Bg()
                }
            else if ("radio" === this.lVt)
                switch (t) {
                case "check":
                    return this.Zhn(!1, !0, !1);
                case "uncheck":
                    return this.Bg()
                }
        }
        Ihn(t) {
            return i => {
                t && (this.Brn.xrn().Wnn() || t.call(this, i))
            }
        }
        Phn(t, i=void 0) {
            this.Brn.Lrn(),
            Fx = void 0 === i ? !(!t.pointerType || "mouse" === t.pointerType) : !!t.pointerType && "mouse" !== t.pointerType,
            (Fx || t.button === Gx.f1.e5) && (this.Thn || (this.Mhn = !1,
            this.Get.setAttribute("mouse-down", "")))
        }
        Ghn(t, i=!0, e=void 0) {
            const s = Fx;
            void 0 === e && (Fx = !(!t.pointerType || "mouse" === t.pointerType));
            let n = !1;
            if ((Fx || t.button === Gx.f1.e5) && this.Get.hasAttribute("mouse-down") ? this.Thn && (n = !0) : n = !0,
            n)
                return Fx = s,
                void (t.pointerType && "mouse" !== t.pointerType && this.Get.removeAttribute("mouse-over"));
            this.Mhn || this.Brn.Frn() || (t.preventDefault(),
            i && this.Qhn()),
            this.Get.removeAttribute("mouse-down"),
            t.pointerType && "mouse" !== t.pointerType && this.Get.removeAttribute("mouse-over")
        }
        Ohn(t) {
            Fx || this.Thn || (this.Get.removeAttribute("mouse-down"),
            this.Get.removeAttribute("mouse-over"))
        }
        Fhn(t) {
            Fx || this.Thn || this.Get.setAttribute("mouse-over", "")
        }
        Lhn(t) {
            this.Brn.Lrn(),
            Fx = !!t.pointerType && "mouse" !== t.pointerType,
            this.Mhn = !1,
            (Fx || t.button === Gx.f1.e5) && -1 === this.Ehn && (this.Ehn = Fx ? setTimeout(this.Whn, kx) : setTimeout(this.Whn, Ox))
        }
        Bhn(t) {
            -1 !== this.Ehn && (t.preventDefault(),
            clearTimeout(this.Ehn),
            this.Ehn = -1,
            this.Jhn())
        }
        Nhn(t) {
            this.Get.removeAttribute("mouse-down"),
            this.Get.removeAttribute("mouse-over")
        }
        jhn(t) {
            Fx || this.Get.setAttribute("mouse-over", "")
        }
        $hn(t) {
            -1 !== this.Ehn && (t.preventDefault(),
            clearTimeout(this.Ehn),
            this.Ehn = -1,
            this.Zhn())
        }
        b2(t) {
            this.Bg()
        }
        Rhn(t) {
            this.b2(t)
        }
        Uhn(t) {
            this.b2(t)
        }
        zhn(t) {
            this.b2(t)
        }
        OW(t) {
            t.preventDefault(),
            this.Brn.Frn() || t.button === Gx.f1.DOt && (this.Mhn = !0,
            this.ton(t))
        }
        Jhn(t=!0, i=!0, e=!1, s=!0) {
            if (!this.Mhn && (!this.Brn.Frn() || e)) {
                if (Gx.Go(this.Khn) && Gx.Go(this.qhn) && s) {
                    const t = this.Get.getBoundingClientRect();
                    if (!Gx.Rect.lvt(t).a8(this.Khn, this.qhn))
                        return
                }
                this._hn = !0,
                this.xhn = !this.xhn,
                t && this.ion(),
                this.xhn ? (this.Get.setAttribute("mouse-down", ""),
                this.Get.removeAttribute("mouse-over"),
                this.Get.removeEventListener("pointerup", this.SUt),
                this.Get.removeEventListener("pointercancel", this.xFi),
                this.Get.removeEventListener("mouseout", this.khn),
                this.Get.removeEventListener("mouseover", this.Dhn)) : (this.Get.removeAttribute("mouse-down"),
                Fx || this.Get.setAttribute("mouse-over", ""),
                i || this.Get.removeAttribute("mouse-over"),
                this.Get.addEventListener("pointerup", this.SUt),
                this.Get.addEventListener("pointercancel", this.xFi),
                this.Get.addEventListener("mouseout", this.khn),
                this.Get.addEventListener("mouseover", this.Dhn)),
                this._hn = !1
            }
        }
        Zhn(t=!0, i=!1, e=!0) {
            if (!this.Mhn && (!this.Brn.Frn() || i)) {
                if (Gx.Go(this.Khn) && Gx.Go(this.qhn) && e) {
                    const t = this.Get.getBoundingClientRect();
                    if (!Gx.Rect.lvt(t).a8(this.Khn, this.qhn))
                        return
                }
                this._hn = !0,
                this.xhn || (this.xhn = !0,
                t && this.eon(),
                this.Get.setAttribute("mouse-down", ""),
                this.Get.removeAttribute("mouse-over"),
                this.Get.removeEventListener("pointerup", this.SUt),
                this.Get.removeEventListener("pointercancel", this.xFi),
                this.Get.removeEventListener("mouseout", this.khn),
                this.Get.removeEventListener("mouseover", this.Dhn)),
                this._hn = !1
            }
        }
        Hhn() {
            "check" === this.lVt ? this.Jhn() : "radio" === this.lVt && this.Zhn(),
            this.Ehn = -1
        }
        Qhn() {
            let t = new Gx.Event("click");
            t.Hrn = this.Brn.Njt(),
            t.PPt = this.phs,
            this.Brn.xrn().dispatchEvent(t),
            this.jrn()
        }
        ion() {
            let t = new Gx.Event("check");
            t.Hrn = this.Brn.Njt(),
            t.PPt = this.phs,
            t.checked = this.xhn,
            this.Brn.xrn().dispatchEvent(t),
            this.jrn(this.xhn)
        }
        eon() {
            let t = new Gx.Event("radio");
            t.Hrn = this.Brn.Njt(),
            t.PPt = this.phs,
            t.checked = this.xhn,
            this.Brn.xrn().dispatchEvent(t),
            this.jrn(this.xhn)
        }
        ton(t) {
            let i = new Gx.Event("buttoncontextmenu");
            i.Hrn = this.Brn.Njt(),
            i.PPt = this.phs,
            i.clientX = t.clientX,
            i.clientY = t.clientY,
            this.Brn.xrn().dispatchEvent(i)
        }
        hk() {
            return this.Get
        }
    }
}
{
    const $x = self.t
      , zx = ["checked"];
    $x.qs.Jj.$nn.Irn = class extends $x.qs.Jj.$nn.Element {
        constructor(t, i, e, s, n) {
            $x.Kq(e),
            super(t, i, s),
            this.Get = $x.qs.lk("ui-toolbar-checkbox", this.Brn.hk()),
            this.son = $x.qs.lk("div", null, null, "checkboxWrapper"),
            this.Vrn = $x.qs.lk("input", this.son, null, null, {
                type: "checkbox"
            }),
            this.non = t => this.ion(this.Vrn.checked),
            this.Vrn.addEventListener("change", this.non),
            this.ron = t => {
                this.wJt(),
                this.non()
            }
            ,
            this.hon = t => {}
            ,
            this.dat = null,
            e && (this.dat = $x.qs.lk("span", null),
            $x.odt(this.dat, e),
            this.dat.addEventListener("pointerup", this.ron),
            this.dat.addEventListener("pointercancel", this.hon)),
            this.Get.style.height = `${this.Brn.jp()}px`,
            this.Brn.YIt().wrap && this.Get.setAttribute("wrap", ""),
            n ? (this.Get.appendChild(this.dat),
            this.Get.appendChild(this.son)) : (this.Get.appendChild(this.son),
            this.Get.appendChild(this.dat))
        }
        he() {
            this.Vrn.removeEventListener("change", this.non),
            this.dat && (this.dat.removeEventListener("pointerup", this.ron),
            this.dat.removeEventListener("pointercancel", this.hon)),
            $x.qs.BW(this.Vrn),
            $x.qs.BW(this.son),
            $x.qs.BW(this.dat),
            $x.qs.BW(this.Get),
            this.non = null,
            this.Brn = null,
            this.Get = null,
            this.son = null,
            this.Vrn = null,
            this.dat = null
        }
        Ft() {
            return this.Vrn.checked
        }
        ets(t) {
            this.Vrn.checked = !!t
        }
        so(t) {
            $x.Hut(t),
            this.$rn(t, zx),
            t.hasOwnProperty("checked") && (this.Vrn.checked = !!t.checked)
        }
        Bg() {}
        Knn() {
            this.ion()
        }
        wJt() {
            this.aZ() && (this.Vrn.checked = !this.Vrn.checked)
        }
        ion(t) {
            let i = new $x.Event("checkboxchecked");
            i.Hrn = this.Brn.Njt(),
            i.MUi = this.phs,
            i.checked = this.Vrn.checked,
            this.Brn.xrn().dispatchEvent(i),
            this.jrn(this.Vrn.checked)
        }
    }
}
{
    const Vx = self.t
      , Wx = ["min", "max", "step", "value", "label"]
      , Hx = "first"
      , Kx = "change"
      , qx = "focus"
      , Xx = "blur"
      , Yx = 10;
    Vx.qs.Jj.$nn.Prn = class extends Vx.qs.Jj.$nn.Element {
        constructor(t, i, e, s, n, r, h, o, a, l) {
            Vx.cO(e),
            Vx.cO(s),
            Vx.cO(n),
            Vx.cO(r),
            Vx.Kq(h),
            Vx.Kq(o),
            super(t, i, a),
            this.qrn = e,
            this.Xrn = s,
            this.fTs = n || 1,
            this.LIs = r || 0,
            this.oon = null,
            this.aon = !0,
            this.VTt = !1,
            this.lon = "",
            this.uon = !1,
            this.con = !1,
            this.don = !1,
            this.fon = -1,
            this.Get = Vx.qs.lk("ui-toolbar-spinner", this.Brn.hk()),
            o && this.Get.setAttribute("title", o),
            this.pon = {},
            this.pon.type = "number",
            this.pon.step = this.fTs.toString(),
            this.pon.value = this.LIs.toString(),
            Vx.Go(e) && (this.pon.min = e.toString()),
            Vx.Go(s) && (this.pon.max = s.toString()),
            this.Vrn = Vx.qs.lk("input", this.Get, null, null, this.pon),
            this.Vrn.style.height = `${this.Brn.jp()}px`,
            this.mon = null,
            this.won = null,
            this.gon = null,
            this.yon = h || i.charAt(0).toUpperCase() + i.slice(1),
            this.dat = document.createElement("span"),
            this.dat.textContent = this.yon,
            l ? this.Get.appendChild(this.dat) : this.Get.insertBefore(this.dat, this.Vrn),
            this.bon = t => this.von(t),
            this.xVi = t => this.AVi(t),
            this.$Gi = t => this.Son(t),
            this.HGi = t => this.xon(t),
            this.yCi = t => this.xSe(t),
            this.Vrn.addEventListener("focus", this.yCi),
            this.bCi = t => this.DUt(t),
            this.yh = Vx.v(Vx.kh, Vx.jh.Gh(this.Vrn, "pointerdown", t => this.IW(t)), Vx.jh.Gh(this.Vrn, "pointerup", t => this.Cz(t)), Vx.jh.Gh(this.Vrn, "pointercancel", t => this.b2(t)), Vx.jh.Gh(this.Vrn, "change", this.bon), Vx.jh.Gh(this.Vrn, "input", this.xVi), Vx.$Ci(this.Vrn)),
            this.Nrn()
        }
        GJt() {
            let t = 0;
            this.mon ? (t = this.mon.value,
            t = Vx.qs.Jj.$nn.Prn.see(t)) : t = parseFloat(this.Vrn.value),
            Vx.Go(t) || (t = 0);
            const i = parseFloat(this.Vrn.min)
              , e = parseFloat(this.Vrn.max);
            return Vx.Go(i) && t < i ? t = i : Vx.Go(e) && t > e && (t = e),
            t
        }
        he() {
            this.Mon(),
            this.Vrn.removeEventListener("focus", this.yCi),
            this.yCi = null,
            Vx.qs.BW(this.Vrn),
            Vx.qs.BW(this.dat),
            this.yh.Vh(),
            this.yh = null,
            this.con = null,
            this.won && this.won.Vh(),
            this.gon && this.gon.Vh(),
            this.won = null,
            this.gon = null,
            this.Vrn = null,
            this.dat = null,
            super.he()
        }
        TWi() {
            this.gon && this.gon.WWe()
        }
        so(t) {
            if (Vx.Hut(t),
            this.$rn(t, Wx),
            t.hasOwnProperty("min") && Vx.Go(t.min)) {
                let i = t.min;
                this.qrn = i,
                this.pon.min = i.toString(),
                this.Vrn.min = i.toString(),
                Number(this.Vrn.value) < i && (this.Vrn.value = i.toString(),
                this.pon.value = i.toString(),
                this.LIs = i),
                this.mon && (this.mon.min = i.toString(),
                Number(this.mon.value) < i && (this.mon.value = i.toString()))
            }
            if (t.hasOwnProperty("max") && Vx.Go(t.max)) {
                let i = t.max;
                this.Xrn = i,
                this.pon.max = i.toString(),
                this.Vrn.max = i.toString(),
                Number(this.Vrn.value) > i && (this.Vrn.value = i.toString(),
                this.pon.value = i.toString(),
                this.LIs = i),
                this.mon && (this.mon.max = i.toString(),
                Number(this.mon.value) > i && (this.mon.value = i.toString()))
            }
            if (t.hasOwnProperty("step") && Vx.Go(t.step)) {
                let i = t.step;
                this.fTs = i,
                this.pon.step = i.toString(),
                this.Vrn.step = i.toString(),
                this.mon && (this.mon.step = i.toString())
            }
            if (t.hasOwnProperty("value") && Vx.Go(t.value)) {
                let i = t.value;
                this.LIs = i,
                this.pon.value = i.toString(),
                this.Vrn.value = i.toString(),
                this.Vrn.min && this.LIs < Number(this.Vrn.min) && (this.Vrn.value = this.Vrn.min.toString(),
                this.pon.value = this.Vrn.min.toString(),
                this.LIs = Number(this.Vrn.min),
                i = Number(this.Vrn.min)),
                this.Vrn.max && this.LIs > Number(this.Vrn.max) && (this.Vrn.value = this.Vrn.max.toString(),
                this.pon.value = this.Vrn.max.toString(),
                this.LIs = Number(this.Vrn.max),
                i = Number(this.Vrn.min)),
                this.mon && this.Eon(i.toString())
            }
            t.hasOwnProperty("label") && Vx.doe(t.label) && (this.yon = t.label,
            this.dat.textContent = this.yon)
        }
        Bg() {}
        Knn() {
            this.Con("spinnerchange")
        }
        wJt() {
            this.aZ()
        }
        _on(t) {
            Vx.zt(t),
            this.yon !== t && (this.yon = t,
            this.dat.textContent = t)
        }
        Ton() {
            return this.yon
        }
        IW(t) {
            this.fon = Number(this.Vrn.value),
            this.uon = !0,
            this.Brn.Lrn(),
            this.VTt = !0
        }
        Cz(t) {
            this.VTt && (Vx.kt.V7i && t.preventDefault(),
            this.VTt = !1,
            this.aon = !0,
            this.fon === Number(this.Vrn.value) ? (this.xSe(),
            this.mon && this.uon && this.mon.ownerDocument.execCommand("selectAll", !1)) : this.Vrn.addEventListener("blur", this.bCi))
        }
        b2(t) {
            this.aon = !0,
            this.VTt = !1,
            this.lon = "",
            this.uon = !1,
            this.con = !1,
            this.don = !1,
            this.fon = -1,
            this.Vrn.addEventListener("focus", this.yCi),
            this.Vrn.removeEventListener("blur", this.bCi),
            this.Mon()
        }
        xSe(t) {
            if (this.VTt)
                return;
            if (this.mon)
                return;
            const i = this.Vrn.getBoundingClientRect();
            this.lon = this.Vrn.value,
            this.Vrn.style.display = "none",
            this.pon.value = this.Vrn.value,
            this.pon.min = this.Vrn.min.toString(),
            this.pon.max = this.Vrn.max.toString(),
            this.pon.step = this.Vrn.step.toString();
            const e = Object.assign({}, this.pon, {
                type: "text"
            });
            this.mon = Vx.qs.lk("input", this.Get, "spinnerEditInput", null, e, 1),
            this.mon.style.width = `${i.width}px`,
            this.mon.style.height = `${i.height}px`,
            this.won = Vx.$Ci(this.mon),
            this.gon = Vx.VWe(this.mon),
            this.mon.addEventListener("change", this.bon),
            this.mon.addEventListener("input", this.xVi),
            this.mon.addEventListener("blur", this.HGi),
            this.mon.addEventListener("focus", this.$Gi),
            this.don = !0,
            this.mon.focus(),
            this.don = !1
        }
        DUt(t) {
            this.VTt || (this.aon = !0,
            this.Vrn.removeEventListener("blur", this.bCi),
            this.fon !== Number(this.Vrn.value) && this.Ion(),
            this.fb(this.Vrn.value))
        }
        von(t) {
            if (this.con)
                return;
            this.mon && this.fb(this.GJt());
            this.GJt();
            const i = new Vx.Event("spinnerchange");
            i.Hrn = this.Brn.Njt(),
            i._8t = this.phs.toLowerCase(),
            i.F8t = this.GJt(),
            this.Brn.xrn().dispatchEvent(i),
            this.uon = !1
        }
        AVi(t) {
            this.con || (this.mon && this.fb(this.GJt()),
            this.aon ? (this.aon = !1,
            this.Pon()) : this.Con("spinnerinput"),
            this.uon = !1)
        }
        Son(t) {
            this.don = !1,
            this.mon && (this.mon.value = this.lon,
            this.mon.removeEventListener("focus", this.$Gi),
            this.Gon())
        }
        xon(t) {
            if (this.don)
                return;
            this.Vrn.removeEventListener("focus", this.yCi);
            const i = this.GJt();
            this.Vrn.style.display = "",
            this.Vrn.value = i,
            this.fb(i),
            this.Mon(),
            setTimeout( () => {
                this.Vrn && (this.Vrn.blur(),
                this.Vrn.addEventListener("focus", this.yCi),
                this.fon !== Number(this.Vrn.value) && this.Ion())
            }
            , Yx)
        }
        Mon() {
            this.mon && (this.aon = !0,
            this.won.Vh(),
            this.won = null,
            this.gon.Vh(),
            this.gon = null,
            this.mon.removeEventListener("change", this.bon),
            this.mon.removeEventListener("input", this.xVi),
            this.mon.removeEventListener("focus", this.$Gi),
            this.mon.removeEventListener("blur", this.HGi),
            Vx.qs.BW(this.mon),
            this.mon = null)
        }
        fb(t) {
            "" === t ? this.Vrn.value = "0" : this.qrn && Number(t) < this.qrn ? this.Vrn.value = this.qrn.toString() : this.Xrn && Number(t) > this.Xrn ? this.Vrn.value = this.Xrn.toString() : this.Vrn.value = t
        }
        Eon(t) {
            this.mon && (this.con = !0,
            this.mon.value = t,
            this.con = !1)
        }
        Pon() {
            let t = new Vx.Event("firstspinnerinput")
              , i = this.GJt();
            t.Hrn = this.Brn.Njt(),
            t._8t = this.phs.toLowerCase(),
            t.F8t = i,
            this.oon = i,
            this.Brn.xrn().dispatchEvent(t),
            this.jrn(this.GJt(), Hx)
        }
        Gon() {
            let t = new Vx.Event("focusspinnerinput")
              , i = this.GJt();
            t.Hrn = this.Brn.Njt(),
            t._8t = this.phs.toLowerCase(),
            t.F8t = i,
            this.Brn.xrn().dispatchEvent(t),
            this.jrn(this.GJt(), qx)
        }
        Ion() {
            let t = new Vx.Event("blurspinnerinput")
              , i = this.GJt();
            t.Hrn = this.Brn.Njt(),
            t._8t = this.phs.toLowerCase(),
            t.F8t = i,
            this.Brn.xrn().dispatchEvent(t),
            this.jrn(this.GJt(), Xx)
        }
        Con(t) {
            Vx.zt(t);
            let i = this.GJt();
            if (i === this.oon)
                return;
            let e = new Vx.Event(t);
            e.Hrn = this.Brn.Njt(),
            e._8t = this.phs.toLowerCase(),
            e.F8t = i,
            this.oon = i,
            this.Brn.xrn().dispatchEvent(e),
            this.jrn(i, Kx)
        }
        static see(t) {
            Vx.zt(t);
            try {
                const i = self.Ste.xte(t);
                return "number" == typeof i && isFinite(i) ? i : 0
            } catch (i) {
                if (t.trim().startsWith(".")) {
                    const i = parseFloat(t.trim());
                    if (isFinite(i))
                        return i
                }
                return 0
            }
        }
    }
}
{
    const Jx = self.t
      , Zx = ["value", "label"];
    Jx.qs.Jj.$nn.Grn = class extends Jx.qs.Jj.$nn.Element {
        constructor(t, i, e, s, n, r, h) {
            Jx.Kq(s),
            Jx.Kq(e),
            super(t, i, n),
            this.aon = !0,
            this.Get = Jx.qs.lk("ui-toolbar-textbox", this.Brn.hk()),
            this.Vrn = document.createElement("input"),
            this.Vrn.type = h?.type ?? "text",
            this.Vrn.value = e,
            this.Vrn.style.height = `${this.Brn.jp()}px`,
            this.Vrn.placeholder = h?.dZt ?? "",
            this.yh = Jx.v(Jx.kh, Jx.jh.Gh(this.Vrn, "input", t => this.g_s(t)), Jx.jh.Gh(this.Vrn, "change", t => this.g_s(t))),
            this.Get.appendChild(this.Vrn),
            this.dat = null,
            s && (this.dat = document.createElement("span"),
            r ? this.Get.insertBefore(this.dat, this.Vrn) : this.Get.appendChild(this.dat),
            Jx.odt(this.dat, s)),
            this.Nrn()
        }
        Ft() {
            return this.Vrn.value
        }
        ets(t) {
            Jx.zt(t),
            this.Vrn.value = t
        }
        Ite() {
            return this.Vrn
        }
        he() {
            Jx.qs.BW(this.Vrn),
            Jx.qs.BW(this.dat),
            this.yh.Vh(),
            this.yh = null,
            this.Vrn = null,
            this.dat = null,
            super.he()
        }
        so(t) {
            Jx.Hut(t),
            this.$rn(t, Zx),
            t.hasOwnProperty("value") && Jx.doe(t.value) && (this.Vrn.value = t.value.toString()),
            t.hasOwnProperty("label") && Jx.doe(t.label) && (this.Vrn.label = t.label)
        }
        Bg() {}
        Knn() {
            this.g_s()
        }
        wJt() {
            this.aZ()
        }
        g_s(t) {
            const i = t ? t.type : "input"
              , e = new Jx.Event("input" === i ? "textinput" : "textchange");
            e.Hrn = this.Brn.Njt(),
            e.Aon = this.phs.toLowerCase(),
            e.Ron = this.Ft(),
            this.Brn.xrn().dispatchEvent(e),
            this.jrn(this.Ft(), e.type)
        }
    }
}
{
    const Qx = self.t
      , tM = ["value", "label", "values", "subValues"]
      , iM = {
        rJt: "default"
    };
    Qx.qs.Jj.$nn.Arn = class extends Qx.qs.Jj.$nn.Element {
        constructor(t, i, e, s, n, r, h, o="ui-toolbar-dropdown") {
            Qx.Kq(s),
            Qx._D(e),
            super(t, i, n),
            r = Object.assign({}, iM, r),
            this.aon = !0,
            this.Get = Qx.qs.lk(o, this.Brn.hk()),
            this.Vrn = document.createElement("select"),
            this.Vrn.style.height = `${this.Brn.jp()}px`,
            this.Vrn.setAttribute("corners", r.rJt),
            this.Get.appendChild(this.Vrn);
            for (let t of e)
                if (!Qx.XOt(t.yxt) || t.yxt())
                    if (Qx.kft(t.aZt)) {
                        const i = document.createElement("optgroup");
                        i.setAttribute("value", t.value),
                        i.label = t.label;
                        for (const e of t.aZt) {
                            if (Qx.XOt(e.yxt) && !e.yxt())
                                continue;
                            const t = document.createElement("option");
                            t.value = e.value,
                            t.textContent = e.label,
                            e.selected && t.setAttribute("selected", ""),
                            e.disabled && t.setAttribute("disabled", ""),
                            i.appendChild(t)
                        }
                        this.Vrn.appendChild(i)
                    } else {
                        let i = document.createElement("option");
                        this.Vrn.appendChild(i),
                        i.value = t.value,
                        i.textContent = t.label,
                        t.selected && i.setAttribute("selected", ""),
                        t.disabled && i.setAttribute("disabled", "")
                    }
            this.Vrn.selectedIndex = 0,
            this.yh = Qx.v(Qx.kh, Qx.jh.Gh(this.Vrn, "change", t => this.g_s(t))),
            this.dat = null,
            s && (this.dat = document.createElement("span"),
            h ? this.Get.insertBefore(this.dat, this.Vrn) : this.Get.appendChild(this.dat),
            Qx.odt(this.dat, s)),
            this.Nrn()
        }
        Ft() {
            return this.Vrn.value
        }
        iZt(t) {
            Qx.Ge(t),
            this.Vrn.selectedIndex = t
        }
        ORe(t) {
            Qx.zt(t),
            this.Vrn.value = t
        }
        he() {
            Qx.qs.BW(this.Vrn),
            Qx.qs.BW(this.dat),
            this.yh.Vh(),
            this.yh = null,
            this.Vrn = null,
            this.dat = null,
            super.he()
        }
        so(t) {
            if (Qx.Hut(t),
            this.$rn(t, tM),
            t.hasOwnProperty("values") && Qx.kft(t.values)) {
                for (; this.Vrn.firstChild; )
                    this.Vrn.removeChild(this.Vrn.firstChild);
                let i = t.values;
                for (let t of i) {
                    if (Qx.XOt(t.yxt) && !t.yxt())
                        continue;
                    let i = document.createElement("option");
                    this.Vrn.appendChild(i),
                    i.value = t.value,
                    i.textContent = t.label,
                    t.selected && i.setAttribute("selected", ""),
                    t.disabled && i.setAttribute("disabled", "")
                }
            }
            if (t.hasOwnProperty("subValues") && Qx.$nt(t.subValues) && Qx.doe(t.subValues.parent) && Qx.kft(t.subValues.children)) {
                const i = t.subValues.parent
                  , e = Array.from(this.Vrn.children)
                  , s = e.filter(t => "OPTGROUP" === t.tagName)
                  , n = e.filter(t => "OPTION" === t.tagName).find(t => t.value === i)
                  , r = s.find(t => t.getAttribute("value") === i)
                  , h = n ?? r;
                if (h)
                    if (t.subValues.children.length) {
                        const i = document.createElement("optgroup");
                        i.setAttribute("value", h?.value ?? h?.getAttribute("value")),
                        i.label = h.label ?? h?.textContent;
                        for (const e of t.subValues.children) {
                            if (Qx.XOt(e.yxt) && !e.yxt())
                                continue;
                            const t = document.createElement("option");
                            t.value = e.value,
                            t.textContent = e.label,
                            e.selected && t.setAttribute("selected", ""),
                            e.disabled && t.setAttribute("disabled", ""),
                            i.appendChild(t)
                        }
                        this.Vrn.replaceChild(i, h)
                    } else {
                        const t = document.createElement("option");
                        t.value = h?.value ?? h?.getAttribute("value"),
                        t.textContent = h.label ?? h?.textContent,
                        t.setAttribute("selected", ""),
                        this.Vrn.replaceChild(t, h)
                    }
            }
            t.hasOwnProperty("value") && Qx.doe(t.value) && (this.Vrn.value = t.value.toString()),
            t.hasOwnProperty("label") && Qx.doe(t.label) && (this.Vrn.label = t.label)
        }
        Bg() {}
        Knn() {
            this.g_s()
        }
        wJt() {
            this.aZ()
        }
        g_s() {
            let t = new Qx.Event("optionselected");
            t.Hrn = this.Brn.Njt(),
            t.kon = this.phs.toLowerCase(),
            t.Oon = this.Ft(),
            this.Brn.xrn().dispatchEvent(t),
            this.jrn(this.Ft())
        }
    }
}
{
    const eM = self.t
      , sM = {
        eJt: null,
        nJt: !0
    };
    eM.qs.Jj.$nn.Rrn = class extends eM.qs.Jj.$nn.Arn {
        constructor(t, i, e, s, n, r, h) {
            super(t, i, e, s, n, r = Object.assign({}, sM, r), h, "ui-toolbar-editable-dropdown"),
            this.Don = r.eJt,
            this.xUt = r,
            this.Fon = eM.qs.lk("div", this.Get, null, "wrapper"),
            this.Fon.appendChild(this.Vrn),
            this.Y7e = eM.qs.lk("input", this.Fon, null, "textInput", {
                type: "text"
            }),
            this.Y7e.style.height = `${this.Brn.jp()}px`,
            r.nJt ? this.Vrn.setAttribute("pointer-edit", "") : (this.Y7e.tabIndex = "-1",
            this.Y7e.style.pointerEvents = "none"),
            this.Lon = t => this.Bon(t),
            this.Y7e.addEventListener("blur", this.Lon),
            this.Uon = t => this.Non(t),
            this.Y7e.addEventListener("focus", this.Uon),
            this.zat = t => this.FP(t),
            this.Y7e.addEventListener("keydown", this.zat),
            this.jon = -1,
            requestAnimationFrame( () => this.Vrn.blur(), 16)
        }
        he() {
            this.Don = null,
            this.xUt = null,
            this.Y7e.removeEventListener("change", this.Lon),
            this.Lon = null,
            this.Y7e.removeEventListener("focus", this.Uon),
            this.Uon = null,
            this.Y7e.removeEventListener("keydown", this.zat),
            this.zat = null,
            eM.qs.BW(this.Fon),
            this.Fon = null,
            eM.qs.BW(this.Y7e),
            this.Y7e = null,
            super.he()
        }
        wJt() {
            this.aZ() && (this.Y7e.style.pointerEvents = "",
            this.Y7e.focus())
        }
        Bon(t) {
            const i = this.jon;
            -1 !== i && (this.$on(i),
            this.Y7e.value = "",
            this.jon = -1,
            this.Vrn.selectedIndex = i,
            this.Vrn.removeAttribute("hide-drop-down"),
            !1 === this.xUt.nJt && (this.Y7e.style.pointerEvents = "none"),
            this.zon())
        }
        $on(t) {
            const i = [];
            for (let e = 0; e < this.Vrn.length; e++) {
                const s = this.Vrn.options[e];
                t === e ? i.push({
                    value: this.Y7e.value,
                    label: this.Y7e.value
                }) : i.push({
                    value: s.value,
                    label: s.text
                })
            }
            this.so({
                values: i
            })
        }
        Non(t) {
            this.Y7e.value = this.Ft(),
            this.jon = this.Vrn.selectedIndex,
            this.Vrn.selectedIndex = -1,
            this.Vrn.setAttribute("hide-drop-down", "")
        }
        FP(t) {
            this.Y7e.ownerDocument.activeElement === this.Y7e && (t.keyCode !== eM.kE.w9 && t.keyCode !== eM.kE.IE || this.Y7e.blur())
        }
        zon() {
            let t = new eM.Event("optionrenamed");
            t.Hrn = this.Brn.Njt(),
            t.kon = this.phs.toLowerCase(),
            t.Oon = this.Ft(),
            this.Brn.xrn().dispatchEvent(t),
            this.Don && this.Don(this.Ft())
        }
    }
}
{
    const nM = self.t
      , rM = ["tooltip"]
      , hM = ["primary", "secondary"]
      , oM = new Set(["click", "check", "radio"])
      , aM = 1e3
      , lM = 5;
    let uM = !1;
    nM.qs.Jj.$nn.Ern = class extends nM.qs.Jj.$nn.Element {
        constructor(t, i, e, s, n, r, h) {
            nM.U(e, nM.qs.O_),
            nM.Kq(s),
            nM.Kq(n),
            nM.X_t(h),
            super(t, i, r),
            this.Von = h,
            this.Mhn = !1,
            this.TNt = "click",
            this.Get = nM.qs.lk("ui-toolbar-split-button", this.Brn.hk()),
            this.Get.style.height = `${this.Brn.jp()}px`,
            this.Get.setAttribute("type", "split"),
            this.Won = nM.qs.lk("div", this.Get),
            this.Hon = nM.qs.lk("div", this.Get),
            this.Won.setAttribute("primary", ""),
            this.Hon.setAttribute("secondary", ""),
            s && (this.Won.setAttribute("title", s),
            this.Won.setAttribute("aria-label", s)),
            n && (this.Hon.setAttribute("title", n),
            this.Hon.setAttribute("aria-label", n)),
            this.Kon = nM.v(nM.qs.kmt, e, this.Won),
            this.qon = nM.qs.lk("div", this.Hon, null, "arrow"),
            this.Get.style.setProperty("--arrow-size", self.app.T_() / 2 + "px"),
            this.Get.style.setProperty("--arrow-color", self.app.B6e()),
            this.yh = nM.v(nM.kh, nM.jh.Gh(this.Won, "pointerdown", t => this.IW(t)), nM.jh.Gh(this.Won, "pointerup", t => this.Cz(t)), nM.jh.Gh(this.Won, "pointerup", t => this.Xon(t)), nM.jh.Gh(this.Won, "pointercancel", t => this.b2(t)), nM.jh.Gh(this.Won, "mouseout", t => this.Yon(t)), nM.jh.Gh(this.Won, "mouseover", t => this.Jon(t)), nM.jh.Gh(this.Won, "contextmenu", t => this.OW(t)), nM.jh.Gh(this.Hon, "pointerdown", t => this.IW(t)), nM.jh.Gh(this.Hon, "pointerup", t => this.Cz(t)), nM.jh.Gh(this.Hon, "pointerup", t => this.Xon(t)), nM.jh.Gh(this.Hon, "pointercancel", t => this.b2(t)), nM.jh.Gh(this.Hon, "mouseout", t => this.Yon(t)), nM.jh.Gh(this.Hon, "mouseover", t => this.Jon(t)), nM.jh.Gh(this.Hon, "contextmenu", t => this.OW(t)), nM.jh.Gh(self.app, "settingschange", t => this.Zon(t))),
            this.Whn = t => this.Hhn(t),
            this._hn = !1,
            this.Ehn = -1,
            this.xhn = !1,
            this.Qon = !1,
            this.ian = !1,
            this.ean = !1,
            this.san = !1,
            this.nan = !1,
            this.ran = !1,
            this.han = !1,
            this.oan = !1,
            this.Nrn()
        }
        he() {
            clearTimeout(this.Ehn),
            this.Ehn = -1,
            this.yh.Vh(),
            this.yh = null,
            this.Kon.he(),
            this.Kon = null,
            nM.qs.BW(this.qon),
            this.qon = null,
            nM.qs.BW(this.Won),
            this.Won = null,
            nM.qs.BW(this.Hon),
            this.Hon = null,
            super.he()
        }
        so(t) {
            nM.Hut(t),
            this.$rn(t, rM),
            nM._U(t.tooltip),
            t.tooltip && this.$rn(t.tooltip, hM),
            t.hasOwnProperty("tooltip") && nM.Ots(t.tooltip) && this.EA(t.tooltip.primary ?? "", t.tooltip.secondary ?? "")
        }
        bet(t) {
            super.bet(t),
            t || this.Bg()
        }
        EA(t, i) {
            nM.Kq(t),
            nM.Kq(i),
            t && (this.Won.setAttribute("title", t),
            this.Won.setAttribute("aria-label", t)),
            i && (this.Hon.setAttribute("title", i),
            this.Hon.setAttribute("aria-label", i))
        }
        CA(t) {
            this.Kon.CA(t)
        }
        Bg() {
            clearTimeout(this.Ehn),
            this.Ehn = -1,
            this.xhn && !this._hn && (this.xhn = !1),
            this.Qon = !1,
            this.ian = !1,
            this.ean = !1,
            this.san = !1,
            this.nan = !1,
            this.ran = !1,
            this.han = !1,
            this.oan = !1,
            this.Won.removeAttribute("mouse-down"),
            this.Won.removeAttribute("mouse-over-light"),
            this.Won.removeAttribute("mouse-over"),
            this.Hon.removeAttribute("mouse-down"),
            this.Hon.removeAttribute("mouse-over-light"),
            this.Hon.removeAttribute("mouse-over")
        }
        Tzt(t) {
            if (nM.zt(t),
            !oM.has(t))
                throw new Error(`invalid button mode "${t}"`);
            this.TNt = t
        }
        Knn() {}
        wJt(t=!0) {
            this.aZ() && this.aan(t => this.lan(t), t => this.uan(t), t => this.can(t), t)
        }
        lan(t) {
            this.Won.setAttribute("mouse-down", ""),
            this.Won.removeAttribute("mouse-down-light"),
            this.Hon.removeAttribute("mouse-down", ""),
            this.Hon.removeAttribute("mouse-down-light"),
            this.dan()
        }
        uan(t) {
            this.Jhn(t, !0, !0)
        }
        can(t) {
            this.Zhn(t, !0, !0)
        }
        cJt() {
            this.Get.setAttribute("type", "single"),
            this.Get.style.width = `${this.Brn.jp()}px`,
            this.Get.style.padding = "",
            this.Hon.setAttribute("hide", "")
        }
        dJt() {
            this.Get.setAttribute("type", "split"),
            this.Get.style.width = "",
            this.Get.style.padding = "",
            this.Hon.removeAttribute("hide")
        }
        fan() {
            this.Get.setAttribute("type", "wide"),
            this.Get.style.width = "",
            this.Get.style.padding = `0 ${self.app.T_() / 4 + 1}px`,
            this.Hon.setAttribute("hide", "")
        }
        IW(t) {
            this.Brn.Lrn(),
            uM = "mouse" !== t.pointerType,
            (uM || t.button === nM.f1.e5) && (this.Mhn = !1,
            this.aan(t => this.man(t), t => this.wan(t), t => this.wan(t), t))
        }
        man(t) {
            this.Get.setAttribute("mouse-down", ""),
            t.target === this.Won && (this.Qon || this.Won.setAttribute("mouse-down", ""),
            this.ian || this.Hon.removeAttribute("mouse-down")),
            t.target === this.Hon && (this.Qon || this.Won.removeAttribute("mouse-down"),
            this.ian || this.Hon.setAttribute("mouse-down", ""))
        }
        wan(t) {
            if (-1 === this.Ehn)
                if (t.target === this.Won)
                    this.Ehn = uM ? setTimeout(this.Whn, aM) : setTimeout(this.Whn, lM);
                else if (t.target === this.Hon) {
                    const i = this.Qon;
                    this.Qon = !0,
                    this.man(t),
                    i || (this.Qon = !1)
                }
        }
        Hhn() {
            "check" === this.TNt ? (this.Jhn(),
            this.Ehn = -1) : "radio" === this.TNt && (this.Zhn(),
            this.Ehn = -1)
        }
        Jhn(t=!0, i=!0, e=!1) {
            this.Mhn || this.Brn.Frn() && !e || (this._hn = !0,
            this.xhn = !this.xhn,
            t && this.gan(),
            this.xhn ? (this.Get.setAttribute("mouse-down", ""),
            this.Won.setAttribute("mouse-down", ""),
            this.Won.removeAttribute("mouse-over"),
            this.Won.removeAttribute("mouse-over-light"),
            this.Hon.setAttribute("mouse-over-light", ""),
            this.Hon.removeAttribute("mouse-over"),
            this.ean = !0,
            this.san = !1,
            this.nan = !0,
            this.ran = !1,
            this.han = !0,
            this.oan = !1) : (this.Get.removeAttribute("mouse-down"),
            this.Won.removeAttribute("mouse-down"),
            uM || (this.Get.setAttribute("mouse-over", ""),
            this.Won.setAttribute("mouse-over", ""),
            this.Won.setAttribute("mouse-over-light", "")),
            i || (this.Get.removeAttribute("mouse-over"),
            this.Won.removeAttribute("mouse-over"),
            this.Won.removeAttribute("mouse-over-light")),
            this.Hon.setAttribute("mouse-over-light", ""),
            this.Hon.removeAttribute("mouse-over"),
            this.ean = !1,
            this.san = !1,
            this.nan = !1,
            this.ran = !1,
            this.han = !1,
            this.oan = !1),
            this._hn = !1)
        }
        Zhn(t=!0, i=!1) {
            this.Mhn || this.Brn.Frn() && !i || (this._hn = !0,
            this.xhn || (this.xhn = !0,
            t && this.yan(),
            this.Get.setAttribute("mouse-down", ""),
            this.Won.setAttribute("mouse-down", ""),
            this.Won.removeAttribute("mouse-over"),
            this.Won.removeAttribute("mouse-over-light"),
            this.Hon.setAttribute("mouse-over-light", ""),
            this.Hon.removeAttribute("mouse-over"),
            this.ean = !0,
            this.san = !1,
            this.nan = !0,
            this.ran = !1,
            this.han = !0,
            this.oan = !1),
            this._hn = !1)
        }
        Cz(t) {
            t.preventDefault(),
            this.aan(t => this.ban(t), t => this.van(t), t => this.San(t), t)
        }
        ban(t) {
            (uM || t.button === nM.f1.e5) && this.Get.hasAttribute("mouse-down") && (this.Mhn || this.Brn.Frn() || (t.target === this.Won && "click" === this.TNt && this.dan(t),
            t.target === this.Hon && this.xan(t)),
            this.ean || this.san || this.Get.removeAttribute("mouse-down"),
            this.ean || (this.Won.removeAttribute("mouse-down"),
            this.Won.removeAttribute("mouse-down-light")),
            this.san || (this.Hon.removeAttribute("mouse-down"),
            this.Hon.removeAttribute("mouse-down-light")))
        }
        van(t) {
            const i = this.ean;
            this.ean = !0,
            this.ban(t),
            i || (this.ean = !1)
        }
        San(t) {
            const i = this.ean;
            this.ean = !0,
            this.ban(t),
            i || (this.ean = !1)
        }
        Xon(t) {
            t.preventDefault(),
            this.aan(t => this.Man(t), t => this.Ean(t), t => this.Can(t), t)
        }
        Man(t) {}
        Ean(t) {
            -1 !== this.Ehn && (clearTimeout(this.Ehn),
            this.Ehn = -1,
            this.Jhn())
        }
        Can(t) {
            -1 !== this.Ehn && (clearTimeout(this.Ehn),
            this.Ehn = -1,
            this.Zhn())
        }
        b2(t) {
            this.Get.removeAttribute("mouse-down"),
            this.Get.removeAttribute("mouse-over"),
            this.Bg()
        }
        Yon(t) {
            uM || (this.nan || this.ran || (this.Get.removeAttribute("mouse-down"),
            this.Get.removeAttribute("mouse-over")),
            this.nan || (this.Won.removeAttribute("mouse-down"),
            this.Won.removeAttribute("mouse-over")),
            this.ran || (this.xhn && this.Hon.setAttribute("mouse-over-light", ""),
            this.Hon.removeAttribute("mouse-down"),
            this.Hon.removeAttribute("mouse-over")))
        }
        Jon(t) {
            uM || (this.Get.setAttribute("mouse-over", ""),
            t.target === this.Won && (this.han || (this.Won.setAttribute("mouse-over", ""),
            this.Won.removeAttribute("mouse-over-light", "")),
            this.oan || (this.Hon.setAttribute("mouse-over-light", ""),
            this.Hon.removeAttribute("mouse-over"))),
            t.target !== this.Hon || this.oan || (this.han || (this.Won.setAttribute("mouse-over-light", ""),
            this.Won.removeAttribute("mouse-over")),
            this.oan || (this.Hon.setAttribute("mouse-over", ""),
            this.Hon.removeAttribute("mouse-over-light"))))
        }
        aan(t, i, e, s) {
            switch (this.TNt) {
            case "click":
                return t(s);
            case "check":
                return i(s);
            case "radio":
                return e(s)
            }
        }
        OW(t) {
            t.preventDefault(),
            this.Brn.Frn() || t.button === nM.f1.DOt && (this.Mhn = !0,
            this.ton(t))
        }
        Zon(t) {
            this.Get.style.setProperty("--arrow-color", self.app.B6e())
        }
        dan(t) {
            let i = new nM.Event("primaryclick");
            i.Hrn = this.Brn.Njt(),
            i.PPt = this.phs,
            i.clientX = t ? t.clientX : 0,
            i.clientY = t ? t.clientY : 0,
            this.Brn.xrn().dispatchEvent(i),
            this.jrn()
        }
        gan(t) {
            let i = new nM.Event("primarycheck");
            i.Hrn = this.Brn.Njt(),
            i.PPt = this.phs,
            i.clientX = t ? t.clientX : 0,
            i.clientY = t ? t.clientY : 0,
            i.checked = this.xhn,
            this.Brn.xrn().dispatchEvent(i),
            this.jrn()
        }
        yan(t) {
            let i = new nM.Event("primaryradio");
            i.Hrn = this.Brn.Njt(),
            i.PPt = this.phs,
            i.clientX = t ? t.clientX : 0,
            i.clientY = t ? t.clientY : 0,
            i.checked = this.xhn,
            this.Brn.xrn().dispatchEvent(i),
            this.jrn()
        }
        xan(t) {
            let i = new nM.Event("secondaryclick");
            i.Hrn = this.Brn.Njt(),
            i.PPt = this.phs,
            i.clientX = t.clientX,
            i.clientY = t.clientY,
            this.Brn.xrn().dispatchEvent(i),
            this.Von && this.Von()
        }
        ton(t) {
            let i = new nM.Event("splitbuttoncontextmenu");
            i.Hrn = this.Brn.Njt(),
            i.PPt = this.phs,
            i.clientX = t.clientX,
            i.clientY = t.clientY,
            this.Brn.xrn().dispatchEvent(i)
        }
        _an() {
            return this.Won
        }
    }
}
{
    const cM = self.t
      , dM = ["checked", "tooltip"];
    cM.qs.Jj.$nn.Mrn = class extends cM.qs.Jj.$nn.Ar {
        constructor(t, i, e, s, n, r, h, o) {
            cM.U(e, cM.qs.O_),
            cM.U(s, cM.qs.O_),
            cM.Kq(n),
            cM.zt(r),
            super(t, i, e, n, r, h, o),
            this.Tan = cM.v(cM.qs.kmt, s, this.Get),
            this.Tan.hk().setAttribute("hide", "")
        }
        he() {
            this.Tan.he(),
            this.Tan = null,
            super.he()
        }
        Bg() {
            super.Bg(),
            this.wat.hk().removeAttribute("hide"),
            this.Tan.hk().setAttribute("hide", "")
        }
        so(t) {
            cM.Hut(t),
            this.$rn(t, dM),
            t.hasOwnProperty("checked") && this.Drn(t.checked ? "check" : "uncheck"),
            t.hasOwnProperty("tooltip") && cM.doe(t.tooltip) && (this.Get.setAttribute("title", t.tooltip),
            this.Get.setAttribute("aria-label", t.tooltip)),
            this.Ian()
        }
        Jhn(t=!0, i=!0, e=!1, s=!0) {
            super.Jhn(t, i, e, s),
            this.Ian()
        }
        Zhn(t=!0, i=!1, e=!0) {
            super.Zhn(t, i, e),
            this.Ian()
        }
        Ian() {
            this.xhn ? (this.wat.hk().setAttribute("hide", ""),
            this.Tan.hk().removeAttribute("hide")) : (this.wat.hk().removeAttribute("hide"),
            this.Tan.hk().setAttribute("hide", ""))
        }
    }
}
{
    const fM = self.t
      , pM = 100
      , mM = 200
      , wM = 50;
    fM.qs.Jj.Pan = class extends fM.Event.aG {
        constructor() {
            super(),
            this.Get = null,
            this.Gan = [],
            this.Aan = -1,
            this.Ran = () => this.kan()
        }
        he() {
            fM.qs.BW(this.Get),
            this.Get = null;
            for (let t of this.Gan)
                t.he();
            fM.sc(this.Gan),
            this.Aan > -1 && (window.clearTimeout(this.Aan),
            this.Aan = -1),
            this.Ran = null,
            super.he()
        }
        Oan(t) {
            if (this.Gan.length >= pM)
                throw new Error("too much content added to status indicator");
            if (this.Gan.includes(t))
                throw new Error("already added");
            this.Gan.push(t),
            this.Dan()
        }
        Fan(t) {
            let i = this.Gan.indexOf(t);
            if (i < 0)
                throw new Error("content not added to status indicator");
            this.Gan.splice(i, 1),
            this.Dan()
        }
        Dan() {
            this.Aan > -1 || (this.Aan = window.setTimeout(this.Ran, this.Get ? wM : mM))
        }
        kan() {
            if (this.Aan = -1,
            this.Gan.length) {
                this.a8e(!0);
                let t = "";
                for (let i = 0; i < this.Gan.length; ++i)
                    i >= 1 && (t += "<br/>"),
                    t += this.Gan[i].Lan();
                fM.odt(this.Get, new fM.gke(t))
            } else
                this.a8e(!1)
        }
        a8e(t) {
            t = !!t,
            !!this.Get !== t && (t ? (this.Get = fM.qs.lk("ui-statusIndicator", document.body),
            this.Get.setAttribute("role", "status")) : (fM.qs.BW(this.Get),
            this.Get = null))
        }
    }
}
{
    const gM = self.t;
    gM.qs.Jj.Ban = class {
        constructor(t, i) {
            gM.U(t, gM.qs.Jj.Pan),
            gM.zt(i),
            this.Uan = t,
            this.Nan = i,
            this.L5e = 0
        }
        he() {
            this.L5e > 0 && (this.Uan.Fan(this),
            this.L5e = 0),
            this.Uan = null
        }
        cR() {
            0 === this.L5e && this.Uan.Oan(this),
            this.L5e++,
            this.Uan.Dan()
        }
        bx() {
            if (this.L5e <= 0)
                throw new Error("removed too many times");
            this.L5e--,
            0 === this.L5e ? this.Uan.Fan(this) : this.Uan.Dan()
        }
        Lan() {
            return gM.vBe(this.Nan, this.L5e)
        }
    }
}
{
    const yM = self.t;
    yM.qs.Jj.jan = class {
        constructor(t, i) {
            yM.U(t, yM.qs.Jj.Pan),
            yM.zt(i),
            this.Uan = t,
            this.Nan = i,
            this.$an = 0,
            this.Vd = !1
        }
        he() {
            this.Vd && (this.Uan.Fan(this),
            this.Vd = !1),
            this.Uan = null
        }
        zan(t) {
            yM.Ge(t),
            t = yM.Ne(t, 0, 1),
            this.Vd || (this.Uan.Oan(this),
            this.Vd = !0),
            this.$an !== t && (this.$an = t,
            this.Uan.Dan())
        }
        qV() {
            this.Vd && (this.Uan.Fan(this),
            this.Vd = !1,
            this.$an = 0)
        }
        Lan() {
            return yM.vBe(this.Nan, Math.round(1e3 * this.$an) / 10)
        }
    }
}
{
    const bM = self.t;
    bM.qs.Jj.Van = class {
        constructor(t, i) {
            bM.U(t, bM.qs.Jj.Pan),
            bM.zt(i),
            this.Uan = t,
            this._S = i,
            this.Vd = !1
        }
        he() {
            this.Vd && (this.Uan.Fan(this),
            this.Vd = !1),
            this.Uan = null
        }
        Ej() {
            !this.Vd && this.Uan && (this.Uan.Oan(this),
            this.Vd = !0)
        }
        pa(t) {
            bM.zt(t),
            this.Uan && (this.Ej(),
            this._S !== t && (this._S = t,
            this.Uan.Dan()))
        }
        Lan() {
            return this._S
        }
    }
}
{
    const vM = self.t
      , SM = [{
        opacity: "1"
    }, {
        opacity: "0"
    }]
      , xM = [{
        transform: "scale(0.85)",
        opacity: "0"
    }, {
        transform: "scale(1)",
        opacity: "1"
    }]
      , MM = {
        duration: 100,
        easing: "ease-out"
    }
      , EM = {
        z7t: 1e4,
        maxWidth: "300px",
        align: "center",
        anchor: "auto",
        clientX: null,
        clientY: null
    }
      , CM = 5
      , _M = new Set(["top-left", "top", "top-right", "left", "center", "right", "bottom-left", "bottom", "bottom-right"])
      , TM = new Set(["auto", "top", "bottom"]);
    let IM = null;
    const PM = {};
    vM.qs.Jj.QY = class extends vM.Me {
        constructor(t, i, e, s, n, r) {
            if (vM.Ike(t, HTMLElement, Range),
            vM.u7t(e),
            vM.u7t(s),
            vM.Wat(n),
            super(),
            r !== PM)
                throw new Error("Balloon tip can not be created directly. Use C3.UI.Controls.BalloonTip.ShowAt instead.");
            "string" == typeof i && (i = self.app.Tk(i)),
            vM.Mw(i, vM.qs.O_),
            this.bui = t,
            this.Wan = e,
            this.Han = s,
            this.cn = !1,
            n = Object.assign({}, EM, n),
            vM.zt(n.maxWidth),
            vM.Ge(n.z7t),
            vM.zt(n.align),
            vM.cO(n.clientX),
            vM.cO(n.clientY);
            let h = n.clientX
              , o = n.clientY
              , a = Number.isFinite(h) && Number.isFinite(o);
            if (!_M.has(n.align))
                throw new Error("invalid alignment");
            if (!TM.has(n.anchor))
                throw new Error("invalid alignment");
            IM && IM.Kan(),
            IM = this,
            this.KEs = n.maxWidth,
            this.qan = n.z7t,
            this.lji = n.align,
            this.Xan = n.anchor,
            this.Get = null,
            this.Yan = -1,
            this.l1 = t => this.IW(),
            this.Jan = !1;
            let l = this.bui;
            l instanceof Range && (l = this.bui.commonAncestorContainer);
            let u = null
              , c = vM.Edi(l, "dialog")
              , d = 0
              , f = 0;
            if (vM.qs.ySe.Bj())
                u = vM.qs.ySe.bSe();
            else if (c) {
                const t = vM.qs.Ys.lZe(c);
                t.NBi() || (d = t.byi(),
                f = t.yyi()),
                u = c
            } else
                u = l.ownerDocument.body;
            this.Get = vM.qs.lk("ui-balloontip", u),
            this.Zan = vM.qs.lk("ui-balloontip-icon", this.Get),
            this.Qan = vM.qs.lk("ui-balloontip-text", this.Get),
            this.VEt = vM.v(vM.qs.kmt, i || self.app.Gk()),
            this.Zan.appendChild(this.VEt.hk()),
            this.Rbt = vM.qs.lk("ui-balloontip-title", this.Qan),
            this.dP = vM.qs.lk("ui-balloontip-body", this.Qan),
            vM.odt(this.Rbt, this.Wan),
            vM.odt(this.dP, this.Han),
            this.Rbt.style.maxWidth = this.KEs,
            this.dP.style.maxWidth = this.KEs;
            let p = this.Zan.getBoundingClientRect()
              , m = this.Qan.getBoundingClientRect();
            this.Get.style.width = `${p.width + m.width}px`;
            let w = this.bui.getBoundingClientRect()
              , g = 0
              , y = 0;
            switch (this.lji) {
            case "top-left":
                g = 0,
                y = 0;
                break;
            case "top":
                g = w.width / 2,
                y = 0;
                break;
            case "top-right":
                g = w.width,
                y = 0;
                break;
            case "left":
                g = 0,
                y = w.height / 2;
                break;
            case "center":
                g = w.width / 2,
                y = w.height / 2;
                break;
            case "right":
                g = w.width,
                y = w.height / 2;
                break;
            case "bottom-left":
                g = 0,
                y = w.height;
                break;
            case "bottom":
                g = w.width / 2,
                y = w.height;
                break;
            case "bottom-right":
                g = w.width,
                y = w.height;
                break;
            default:
                throw new Error("invalid alignment")
            }
            let b = w.left + g
              , v = w.top + y;
            a && (b = h - d,
            v = o - f);
            let S = this.Get.ownerDocument.defaultView.getComputedStyle(this.Get);
            const x = parseInt(S.getPropertyValue("--balloontip-padding"));
            let M = x
              , E = x
              , C = b - 2 * M - d
              , _ = v + E - f
              , T = this.Get.ownerDocument.defaultView.getComputedStyle(this.Get)
              , I = parseInt(T.width)
              , P = parseInt(T.height)
              , G = I + 4 * M
              , A = P + 4 * E;
            this.Klt = vM.qs.Jj.QY.tln(),
            this.Klt.setAttributeNS(null, "width", G),
            this.Klt.setAttributeNS(null, "height", A),
            this.Get.style.setProperty("--balloontip-left", -M + "px"),
            this.Get.style.setProperty("--balloontip-top", -E + "px"),
            this.wLi = this.Klt.querySelector(".balloontipPath"),
            this.Get.insertBefore(this.Klt, this.Zan);
            let R = null;
            if (this.iln(C + 2 * M, I - M, d))
                switch (this.Xan) {
                case "auto":
                case "top":
                    this.eln(_ + E, P, f) ? (this.Get.style.top = `${_}px`,
                    this.Get.style.left = `${C}px`,
                    this.Get.style.transformOrigin = b - C - d + "px 0%",
                    R = this.sln) : (this.Get.style.top = _ - P - 4 * E + "px",
                    this.Get.style.left = `${C}px`,
                    this.Get.style.transformOrigin = b - C - d + "px 100%",
                    R = this.nln);
                    break;
                case "bottom":
                    this.rln(_ + E, P, f) ? (this.Get.style.top = _ - P - 4 * E + "px",
                    this.Get.style.left = `${C}px`,
                    this.Get.style.transformOrigin = b - C - d + "px 100%",
                    R = this.nln) : (this.Get.style.top = `${_}px`,
                    this.Get.style.left = `${C}px`,
                    this.Get.style.transformOrigin = b - C - d + "px 0%",
                    R = this.sln)
                }
            else
                switch (this.Xan) {
                case "auto":
                case "top":
                    if (this.eln(_ + E, P, f)) {
                        let t = C - I + 2 * M;
                        this.Get.style.top = `${_}px`,
                        this.Get.style.left = `${t}px`,
                        this.Get.style.transformOrigin = b - t - d + "px 0%",
                        R = this.hln
                    } else {
                        let t = C - I + 2 * M;
                        this.Get.style.top = _ - P - 4 * E + "px",
                        this.Get.style.left = `${t}px`,
                        this.Get.style.transformOrigin = b - t - d + "px 100%",
                        R = this.oln
                    }
                    break;
                case "bottom":
                    if (this.rln(_ + E, P, f)) {
                        let t = C - I + 2 * M;
                        this.Get.style.top = _ - P - 4 * E + "px",
                        this.Get.style.left = `${t}px`,
                        this.Get.style.transformOrigin = b - t - d + "px 100%",
                        R = this.oln
                    } else {
                        let t = C - I + 2 * M;
                        this.Get.style.top = `${_}px`,
                        this.Get.style.left = `${t}px`,
                        this.Get.style.transformOrigin = b - t - d + "px 0%",
                        R = this.hln
                    }
                }
            this.wLi.setAttributeNS(null, "d", R(M, E, G - M, A - E, M, E)),
            this.V4e(xM, MM, "show")
        }
        jHi() {
            let t = this.bui;
            return t instanceof Range && (t = this.bui.commonAncestorContainer),
            t.ownerDocument
        }
        aln() {
            return this.jHi().defaultView
        }
        V4e(t, i, e) {
            let s;
            "show" === e && (s = this.lln),
            "hide" === e && (s = this.uln),
            self.app.zmt() ? (this.xJe = this.Get.animate(t, i),
            this.xJe.onfinish = t => s.call(this)) : s.call(this)
        }
        lln() {
            vM.dn(this) || this.cn || (this.Yan = setTimeout( () => this.Kan(), this.qan),
            this.jHi().addEventListener("pointerdown", this.l1))
        }
        uln() {
            this.LUt()
        }
        IW() {
            this.Kan()
        }
        Kan() {
            this.cn || this.Jan || (IM === this && (IM = null),
            this.Jan = !0,
            this.V4e(SM, MM, "hide"))
        }
        LUt() {
            vM.dn(this) || this.cn || (this.cn = !0,
            IM === this && (IM = null),
            -1 !== this.Yan && (clearTimeout(this.Yan),
            this.Yan = -1),
            this.jHi().removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.VEt && this.VEt.he(),
            vM.qs.BW(this.Rbt),
            vM.qs.BW(this.Rbt),
            vM.qs.BW(this.Rbt),
            vM.qs.BW(this.Klt),
            vM.qs.BW(this.Zan),
            vM.qs.BW(this.Qan),
            vM.qs.BW(this.Get),
            this.Zan = null,
            this.Qan = null,
            this.VEt = null,
            this.Klt = null,
            this.Rbt = null,
            this.dP = null,
            this.bui = null,
            this.Get = null,
            vM.he(this))
        }
        sln(t, i, e, s, n, r) {
            return `M ${t + CM} ${i}\n\t\t\t\tL ${t + n} ${i}\n\t\t\t\tL ${t + 2 * n} ${i - r}\n\t\t\t\tL ${t + 2 * n} ${i}\n\t\t\t\tL ${e - CM} ${i}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e} ${i + CM}\n\t\t\t\tL ${e} ${s - CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e - CM} ${s}\n\t\t\t\tL ${t + CM} ${s}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t} ${s - CM}\n\t\t\t\tL ${t} ${i + CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t + CM} ${i}\n\t\t\t\tZ`
        }
        hln(t, i, e, s, n, r) {
            return `M ${e / 2} ${i}\n\t\t\t\tL ${t + e - 4 * n} ${i}\n\t\t\t\tL ${t + e - 4 * n + n} ${i - r}\n\t\t\t\tL ${t + e - 4 * n + n} ${i}\n\t\t\t\tL ${e - CM} ${i}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e} ${i + CM}\n\t\t\t\tL ${e} ${s - CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e - CM} ${s}\n\t\t\t\tL ${t + CM} ${s}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t} ${s - CM}\n\t\t\t\tL ${t} ${i + CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t + CM} ${i}\n\t\t\t\tZ`
        }
        nln(t, i, e, s, n, r) {
            return `M ${t + CM} ${i}\n\t\t\t\tL ${e - CM} ${i}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e} ${i + CM}\n\t\t\t\tL ${e} ${s - CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e - CM} ${s}\n\t\t\t\tL ${t + 2 * n} ${s}\n\t\t\t\tL ${t + 2 * n} ${s + r}\n\t\t\t\tL ${t + n} ${s}\n\t\t\t\tL ${t + CM} ${s}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t} ${s - CM}\n\t\t\t\tL ${t} ${i + CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t + CM} ${i}\n\t\t\t\tZ`
        }
        oln(t, i, e, s, n, r) {
            return `M ${t + CM} ${i}\n\t\t\t\tL ${e - CM} ${i}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e} ${i + CM}\n\t\t\t\tL ${e} ${s - CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${e - CM} ${s}\n\t\t\t\tL ${t + e - 4 * n + n} ${s}\n\t\t\t\tL ${t + e - 4 * n + n} ${s + r}\n\t\t\t\tL ${t + e - 4 * n} ${s}\n\t\t\t\tL ${t + CM} ${s}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t} ${s - CM}\n\t\t\t\tL ${t} ${i + CM}\n\t\t\t\tA ${CM} ${CM} 0 0 1 ${t + CM} ${i}\n\t\t\t\tZ`
        }
        iln(t, i, e) {
            return t + i + e < this.aln().innerWidth
        }
        cln(t, i, e) {
            return t - e > 0
        }
        rln(t, i, e) {
            return t - e > 0
        }
        eln(t, i, e) {
            return t + i + e < this.aln().innerHeight
        }
        dln(t) {
            return vM.U(t, vM.qs.Ys),
            vM.vX(this.Get, t.hk())
        }
        static nF(t, i, e, s, n) {
            let r = t;
            if (r instanceof Range && (r = t.commonAncestorContainer),
            r.ownerDocument.defaultView)
                return vM.v(vM.qs.Jj.QY, t, i, e, s, n, PM)
        }
        static X1() {
            return !!IM
        }
        static sgi() {
            IM && IM.Kan()
        }
        static fln(t) {
            vM.U(t, vM.qs.Ys),
            IM && IM.dln(t) && IM.Kan()
        }
        static RZe() {
            IM && IM.LUt()
        }
        static kZe(t) {
            vM.U(t, vM.qs.Ys),
            IM && IM.dln(t) && IM.LUt()
        }
        static tln() {
            return (new DOMParser).parseFromString('<svg id="balloontip-svg" xmlns="http://www.w3.org/2000/svg">\n\t\t    <path class="balloontipPath"></path>\n\t\t</svg>', "image/svg+xml").getElementById("balloontip-svg")
        }
    }
}
{
    const GM = self.t
      , AM = self.assert
      , RM = {
        kP: !1,
        IP: !1,
        border: !1,
        pEi: !0,
        overflow: "auto",
        Oot: !0,
        Sot: !0,
        yot: () => 1
    }
      , kM = 400
      , OM = ["auto", "scroll", "hidden"];
    GM.qs.Jj.Table = class extends GM.Event.aG {
        constructor(t, i) {
            super(),
            GM.zlt(t),
            GM.Wat(i),
            i = Object.assign({}, RM, i),
            this.hVt = t,
            this.oin = !!i.kP,
            this.lSe = !!i.IP,
            this.pln = !!i.pEi,
            this.mln = i.overflow,
            this.dJe = !!i.Oot,
            this.wln = i.yot,
            AM(OM.includes(this.mln), `unexpected 'overflow' value, valid values are '${OM}'`),
            this.Y0s = GM.qs.lk("ui-table", this.hVt),
            i.border && this.Y0s.setAttribute("own-border", ""),
            this.gln = null,
            this.fui = [],
            this.yln = new Set,
            this.MG = null,
            this.bln = t => this.DG(t),
            this.vln = () => this.Sln(),
            this.xln = 0,
            this.p_t = 0,
            this.qG = -1,
            this.ZCt = GM.qs.lk("div", null, null, "table-insert-mark"),
            this.Mln = null,
            this.i_t = "",
            this.Eln = !1,
            this.Cln = null,
            this.qG = -1,
            this.Xft = () => this.Ein(),
            this.Cin = 0,
            this._in = 0,
            this.Tin = 0,
            this.Iin = 0,
            this._ln = !1,
            this.Tln = null,
            this.Iln = null,
            this.Pln = null,
            this.Gln = i.Sot,
            this.G2e = !0,
            this.Aln = 0
        }
        he() {
            this.tC(),
            this.IH(),
            this.ZCt = null,
            this.Rln(),
            this.kln(),
            this.Xft = null,
            this.gln && (this.gln.he(),
            this.gln = null),
            this.Pln && (GM.qs.BW(this.Pln),
            this.Pln = null),
            this.Iln && (this.Iln.he(),
            this.Iln = null),
            -1 !== this.qG && (this.jW().cancelAnimationFrame(this.qG),
            this.qG = -1),
            this.MG && (this.MG.removeEventListener("scroll", this.bln, {
                passive: !0
            }),
            this.bln = null,
            GM.qs.BW(this.MG),
            this.MG = null),
            GM.qs.BW(this.Y0s),
            this.Y0s = null,
            this.vln = null,
            this.hVt = null,
            super.he()
        }
        tC() {
            this.yln.clear(),
            this.IH();
            for (let t of this.fui)
                t.he();
            for (const t of this.gln.Oln())
                t.Dln();
            GM.sc(this.fui)
        }
        so() {
            for (const t of this.gln.Oln())
                t.so();
            for (const t of this.fui)
                t.so()
        }
        jnt() {
            let t = 0;
            for (const i of this.gln.Oln())
                i.Fln() && (t += i.Lln());
            return t
        }
        Wnt() {
            let t = 0;
            for (const i of this.gln.Oln())
                i.Fln() || (t += i.Bln());
            return t
        }
        elt() {
            return !!this.fui.some(t => t.elt())
        }
        hk() {
            return this.Y0s
        }
        PH() {
            return this.hk().ownerDocument
        }
        jW() {
            return this.PH().defaultView
        }
        Jin() {
            return this.oin
        }
        qin() {
            return this.lSe
        }
        hit() {
            return this.dJe
        }
        Uln() {
            return this.wln()
        }
        Nln() {
            return this.pln
        }
        jln(t, i) {
            this._ln = t,
            this.Tln = i
        }
        $ln() {
            return this._ln
        }
        zln(t) {
            this.Vln(t),
            this.yln.add(t)
        }
        Wln(t) {
            this.Vln(t),
            this.yln.delete(t)
        }
        wF() {
            return this.yln.size
        }
        kH() {
            this.Uht() && (this.Eln && (this.Cln && this.Cln.kH(),
            this.Rln()),
            this._ln && (this.Tln && this.Tln.kH(),
            this.kln()))
        }
        Uht() {
            return !!this.Eln || !!this._ln
        }
        gF() {
            this.Hln();
            for (let t of this.yln)
                t.Dwt(!1);
            this.Kln(),
            this.qln("allunselected"),
            AM(0 === this.yln.size, "should have deleted all selected row")
        }
        PKt() {
            return this.yln.values()
        }
        ode() {
            return GM.eu(this.yln)
        }
        vEi() {
            return this.yln.size > 0
        }
        Xln() {
            return this.gln
        }
        Hln() {
            this.Aln++
        }
        Kln() {
            this.Aln--,
            AM(this.Aln >= 0, "missing matching call to block events")
        }
        Yln() {
            return this.Aln > 0
        }
        Jln() {
            return this.MG
        }
        Zln(t) {
            this.Gln ? this.MG.insertBefore(t, this.Iln.hk()) : this.MG.appendChild(t)
        }
        Sat(t) {
            for (const i of this.fui)
                if (i.Pp() === t)
                    return i;
            return null
        }
        Got() {
            if (this.fui.length)
                throw new Error("table must be empty before setting the top row");
            return this.gln && this.gln.he(),
            this.gln = GM.v(GM.qs.Jj.Table.Qln, this),
            this.MG = GM.qs.lk("div", this.Y0s, null, "table-scroll-container"),
            this.MG.addEventListener("scroll", this.bln, {
                passive: !0
            }),
            this.MG.style.overflow = this.mln,
            this.gln
        }
        Eot(t) {
            this.iKt();
            let i = GM.v(GM.qs.Jj.Table.pKt, t, this);
            return this.fui.push(i),
            i
        }
        iKt() {
            !this.Iln && this.Gln && (this.Iln = GM.v(GM.qs.Jj.Table.pKt, null, this, !0))
        }
        rme() {
            if (this.Pln)
                return this.Pln;
            if (!this.Iln)
                throw new Error("must create padding row before footer element");
            this.Pln = GM.qs.lk("div", null, null, "tableFooterElem");
            const t = this.Iln.hk();
            return t.insertBefore(this.Pln, t.firstChild),
            this.Pln
        }
        mZe() {
            return this.Pln
        }
        GEi(t) {
            GM.qd(t);
            for (let i of this.fui)
                if (t(i))
                    return i
        }
        J7t(t) {
            GM.U(t, GM.qs.Jj.Table.pKt);
            let i = this.fui.indexOf(t);
            if (i < 0)
                throw new Error("cannot find row");
            this.fui[i].he(),
            this.fui.splice(i, 1)
        }
        bEi() {
            for (let t of this.fui)
                t.bEi()
        }
        DG(t) {
            let i = this.MG.scrollLeft
              , e = this.MG.scrollTop;
            if ((this.xln !== i || this.p_t !== e) && (this.xln = i,
            this.p_t = e,
            -1 === this.qG)) {
                this.jW() && (this.qG = this.jW().requestAnimationFrame(this.vln))
            }
        }
        Sln() {
            const t = this.gln.hk()
              , i = `${this.xln}px`;
            t.style.marginLeft = `-${i}`,
            t.style.paddingRight = i;
            for (const t of this.rows()) {
                t.hk().style.setProperty("--width-offset", i)
            }
            this.qG = -1
        }
        Vln(t) {
            if (GM.U(t, GM.qs.Jj.Table.pKt),
            t.Nht() !== this)
                throw new Error("row from different table")
        }
        *rows() {
            for (let t of this.fui)
                yield t
        }
        uH(t, i) {
            GM.Ge(t),
            GM.Ge(i);
            let e = this.Y0s.getBoundingClientRect();
            if (t < e.left || i < e.top || t > e.right || i > e.bottom)
                return null;
            for (let e of this.rows()) {
                let s = e.uH(t, i);
                if (s)
                    return {
                        ght: e,
                        FH: s.FH
                    }
            }
            return null
        }
        JH(t, i) {
            if (this.Vln(t),
            GM.zt(i),
            "before" !== i && "after" !== i)
                throw new Error("invalid insert mark type");
            if (t === this.Mln && i === this.i_t)
                return;
            this.IH();
            let e = t.hk();
            e.parentElement.insertBefore(this.ZCt, "before" === i ? e : e.nextSibling),
            this.Mln = t,
            this.i_t = i
        }
        IH() {
            this.i_t && (GM.qs.BW(this.ZCt),
            this.Mln = null,
            this.i_t = "")
        }
        tun() {
            return this.Mln
        }
        sht(t) {
            !this.Eln && this.jW() && (this.Cln = t,
            this.Eln = !0,
            this.Iin = 0,
            this.Cin = performance.now(),
            this.qG = this.jW().requestAnimationFrame(this.Xft))
        }
        eht(t, i) {
            this.Eln && (this._in = t,
            this.Tin = i)
        }
        Ein() {
            if (this.qG = -1,
            !this.Eln || !this.jW())
                return;
            let t = performance.now()
              , i = (t - this.Cin) / 1e3;
            this.Cin = t;
            let e = this.Y0s.getBoundingClientRect();
            if (this._in >= e.left && this._in <= e.right)
                if (this.Tin < e.top) {
                    let t = this.MG.scrollTop - kM * i - this.Iin;
                    this.Iin = Math.ceil(t) - t,
                    t = Math.ceil(t),
                    this.yue(t)
                } else if (this.Tin > e.bottom) {
                    let t = this.MG.scrollTop + kM * i + this.Iin;
                    this.Iin = t - Math.floor(t),
                    t = Math.floor(t),
                    this.yue(t)
                }
            this.qG = this.jW().requestAnimationFrame(this.Xft)
        }
        R9i() {
            return this.MG.scrollTop
        }
        iun(t) {
            GM.Ge(t),
            this.MG.scrollLeft = t,
            this.xln = this.MG.scrollLeft
        }
        cvt() {
            return this.MG.scrollTop
        }
        yue(t) {
            GM.Ge(t),
            this.MG.scrollTop = t,
            this.p_t = this.MG.scrollTop
        }
        Rln() {
            this.Cln && this.Cln.kH(),
            this.Cln = null,
            this.Eln = !1,
            -1 !== this.qG && this.jW() && (this.jW().cancelAnimationFrame(this.qG),
            this.qG = -1)
        }
        kln() {
            this.Tln && this.Tln.kH(),
            this.Tln = null,
            this.jln(!1)
        }
        eun(t, i, e, s, n, r) {
            if (this.Yln())
                return;
            let h = new GM.Event(i)
              , o = null;
            return !e || (o = e.getAttribute("columnName"),
            o) ? (h.ght = t,
            h.fnt = o,
            r && (s = r.clientX,
            n = r.clientY,
            h.Rst = r),
            void 0 !== s && void 0 !== n && (h.clientX = s,
            h.clientY = n),
            h.lnt = e ? t.Xot(h.fnt) : null,
            this.dispatchEvent(h)) : void 0
        }
        qln(t, i, e, s) {
            if (this.Yln())
                return;
            let n = new GM.Event(t);
            return n.table = this,
            s && (i = s.clientX,
            e = s.clientY,
            n.Rst = s),
            void 0 !== i && void 0 !== e && (n.clientX = i,
            n.clientY = e),
            this.dispatchEvent(n)
        }
        __() {
            return this.G2e
        }
        x_(t) {
            t = !!t,
            this.G2e !== t && (this.G2e = t,
            this.G2e ? this.Y0s.style.display = "" : this.Y0s.style.display = "none")
        }
        QL() {
            const t = {};
            if (t.scrollLeft = this.xln,
            t.scrollTop = this.p_t,
            this.yln.size) {
                const i = [];
                for (let t of this.yln.values())
                    i.push({
                        number: t.mEi(),
                        selected: t.bq()
                    });
                t.selectedRows = i
            } else
                t.selectedRows = null;
            return t.columnsUIStateJson = this.gln.Oln().map(t => t.QL()),
            t
        }
        tU(t, i) {
            if (t) {
                if (GM.Go(t.scrollLeft) && (this.MG.scrollLeft = t.scrollLeft,
                this.xln = t.scrollLeft),
                GM.Go(t.scrollTop) && (this.MG.scrollTop = t.scrollTop,
                this.p_t = t.scrollTop),
                t.selectedRows && t.selectedRows.length) {
                    this.Hln();
                    for (let i of t.selectedRows)
                        for (let t of this.rows())
                            t.mEi() === i.number && i.selected && t.YB();
                    this.Kln(),
                    this.vEi() && this.qln("rowsselected")
                }
                if (t.columnsUIStateJson && t.columnsUIStateJson.length)
                    for (const e of t.columnsUIStateJson) {
                        const t = this.gln.sun(e.id);
                        t && t.tU(e, i)
                    }
                this.Sln(),
                this.so(),
                this.elt()
            }
        }
    }
}
{
    const DM = self.t
      , FM = 10
      , LM = {
        Hot: !1,
        cursor: ""
    };
    DM.qs.Jj.Table.pKt = class extends DM.Event.aG {
        constructor(t, i, e, s) {
            DM.U(i, DM.qs.Jj.Table),
            e = !!e,
            super(),
            this.xot = i,
            this.Bd = t,
            this.nun = e,
            this.wpt = !1,
            this.G2e = !0,
            this.gln = i.Xln(),
            this.hun = DM.qs.lk("ui-table-row"),
            this.hun.setAttribute("tabindex", -1),
            this.nun && this.hun.setAttribute("filler", ""),
            this.nun ? this.xot.Jln().appendChild(this.hun) : this.xot.Zln(this.hun),
            this.oun = [],
            this.aun = new Set,
            this.uui = this.gln.Oln(),
            this.lun = [];
            for (let t = 0; t < this.uui.length; t++) {
                let i, e = this.uui[t], s = e.Njt(), n = e.jp();
                const r = Object.assign({}, e.YIt());
                r.uun = r.Dot,
                r.cun = e,
                r.dun = !1,
                i = e.Fln() && t === this.uui.length - 1 ? DM.v(DM.qs.Jj.Table.V7t, this.xot, this.hun, -1, s, r) : DM.v(DM.qs.Jj.Table.V7t, this.xot, this.hun, n, s, r),
                e.fun(i),
                this.lun.push(i)
            }
            this.A8 = t => this.MW(t),
            this.gpt = t => this.GW(t),
            this.P8 = t => this.OW(t),
            this.Z8e = t => this.xSe(t),
            this.t7e = t => this.DUt(t),
            this.XCt = -1,
            this.L9 = 0,
            this.W9 = 0,
            this.Kft = !1,
            this.l1 = null,
            this.Mz = null,
            this.Oz = null,
            this.N9e = null,
            this.hun.addEventListener("UIDoubleTap", this.gpt),
            this.nun || (this.hun.addEventListener("focus", this.Z8e),
            this.hun.addEventListener("UITap", this.A8),
            this.xot.Nln() && this.hun.addEventListener("blur", this.t7e),
            this.xot.Jin() && (this.l1 = t => this.IW(t),
            this.Mz = t => this.Gz(t),
            this.Oz = t => this.Cz(t),
            this.N9e = t => this.b2(t),
            this.hun.addEventListener("pointerdown", this.l1))),
            this.hun.addEventListener("contextmenu", this.P8)
        }
        he() {
            this.xot.tun() === this && this.xot.IH();
            for (let t of this.oun)
                t.he();
            for (let t of this.lun)
                t.he();
            DM.sc(this.lun),
            DM.sc(this.oun),
            this.aun.clear(),
            this.Dwt(!1),
            DM.qs.BW(this.hun),
            this.hun.removeEventListener("focus", this.Z8e),
            this.Z8e = null,
            this.hun.removeEventListener("blur", this.t7e),
            this.t7e = null,
            this.hun.removeEventListener("UITap", this.A8),
            this.A8 = null,
            this.hun.removeEventListener("UIDoubleTap", this.gpt),
            this.gpt = null,
            this.hun.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.PH().removeEventListener("pointermove", this.Mz),
            this.Mz = null,
            this.PH().removeEventListener("pointerup", this.Oz),
            this.Oz = null,
            this.PH().removeEventListener("pointercancel", this.N9e),
            this.N9e = null,
            this.hun.removeEventListener("contextmenu", this.P8),
            this.P8 = null,
            this.aun = null,
            this.oun = null,
            this.hun = null,
            this.uui = null,
            this.xot = null,
            this.Bd = null,
            this.gln = null,
            this.lun = null,
            super.he()
        }
        so() {
            for (const t of this.oun)
                t.so();
            for (const t of this.lun)
                t.so()
        }
        elt() {
            const t = t => t.elt();
            return !!this.uui.some(t) || !!this.lun.some(t)
        }
        Pp() {
            return this.Bd
        }
        Nht() {
            return this.xot
        }
        hk() {
            return this.hun
        }
        PH() {
            return this.hk().ownerDocument
        }
        mEi() {
            return Array.prototype.indexOf.call(this.hun.parentElement.children, this.hun)
        }
        Xot(t) {
            DM.zt(t);
            for (let i of this.oun)
                if (i.pun() === t)
                    return i;
            return null
        }
        bEi() {
            for (let t of this.oun)
                t.fo() && t.bEi()
        }
        Lot(t, i, e) {
            DM.zt(t),
            this.mun(t),
            e = Object.assign({}, LM, e);
            let s = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.wun, s, i, e)),
            this
        }
        Tot(t, i, e) {
            DM.zt(t),
            this.mun(t),
            e = Object.assign({}, LM, e);
            let s = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.REi, s, i, e)),
            this
        }
        zot(t, i, e, s) {
            DM.zt(t),
            this.mun(t),
            (s = Object.assign({}, LM, s)).table = this.xot,
            s.ght = this,
            s.gun = e;
            let n = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.yun, n, i, s)),
            this
        }
        kEi(t, i, e) {
            DM.zt(t),
            this.mun(t),
            e = Object.assign({}, LM, e);
            let s = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.bun, s, i, e)),
            this
        }
        Aot(t, i, e) {
            DM.zt(t),
            this.mun(t),
            e = Object.assign({}, LM, e);
            let s = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.vun, s, i, e)),
            this
        }
        $Kt(t, i, e) {
            DM.zt(t),
            i && DM.U(i, i.ownerDocument.defaultView.DocumentFragment),
            this.mun(t),
            e = Object.assign({}, LM, e);
            let s = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.Sun, s, i, e)),
            this
        }
        Nlt(t, i, e) {
            DM.zt(t),
            this.mun(t),
            (e = Object.assign({}, LM, e)).table = this.xot,
            e.ght = this;
            let s = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.xun, s, i, e)),
            this
        }
        C5t(t, i, e) {
            DM.zt(t),
            this.mun(t),
            (e = Object.assign({}, LM, e)).table = this.xot,
            e.ght = this;
            let s = this.hun.querySelector(`[columnName="${t}"]`);
            return this.oun.push(DM.v(DM.qs.Jj.Table.Mun, s, i, e)),
            this
        }
        mun(t) {
            if (this.aun.has(t))
                throw new Error(`field '${t}' has already been set`);
            if (!this.uui.some(i => i.Njt() === t))
                throw new Error(`field '${t}' does not exist`);
            this.aun.add(t)
        }
        MW(t) {
            this.xot.eun(this, "rowtapped", t.target, t.clientX, t.clientY, t)
        }
        GW(t) {
            this.nun ? this.xot.qln("tablespacedoubletap", t.clientX, t.clientY, t) : this.xot.eun(this, "rowdoubletapped", t.target, t.clientX, t.clientY, t)
        }
        OW(t) {
            t.preventDefault(),
            t.stopPropagation(),
            this.nun ? this.xot.qln("tablecontextmenu", t.clientX, t.clientY, t) : this.xot.eun(this, "rowcontextmenu", t.target, t.clientX, t.clientY, t)
        }
        x_(t) {
            t = !!t,
            this.G2e !== t && (this.G2e = t,
            this.G2e ? this.hun.style.display = "" : this.hun.style.display = "none")
        }
        YB(t) {
            this.bq() || (this.xot.qin() && DM.OF.Gct() || this.xot.gF(),
            this.Dwt(!0))
        }
        xD() {
            this.Dwt(!1)
        }
        Dwt(t) {
            t = !!t,
            this.wpt !== t && (t ? (this.hun.setAttribute("selected", ""),
            this.xot.eun(this, "rowselected"),
            this.xot.zln(this)) : (this.hun.removeAttribute("selected"),
            this.xot.eun(this, "rowunselected"),
            this.xot.Wln(this)),
            this.wpt = t)
        }
        bq() {
            return this.wpt
        }
        xSe(t) {
            this.YB()
        }
        DUt(t) {
            this.xot.qin() ? DM.OF.Gct() || this.xot.gF() : this.Dwt(!1)
        }
        uH(t, i) {
            if (DM.Ge(t),
            DM.Ge(i),
            this.nun)
                return null;
            let e = this.hun.getBoundingClientRect();
            if (t < e.left || t > e.right || i < e.top || i > e.bottom)
                return null;
            let s = e.bottom - e.top;
            return {
                FH: i >= e.top + s / 2 ? "after" : "before"
            }
        }
        kH() {
            this.PH().removeEventListener("pointermove", this.Mz),
            this.PH().removeEventListener("pointerup", this.Oz),
            this.PH().removeEventListener("pointercancel", this.N9e),
            this.Kft = !1,
            this.XCt = -1
        }
        IW(t) {
            t.button === DM.f1.e5 && (this.xot.$ln() || -1 === this.XCt && (this.PH().addEventListener("pointermove", this.Mz),
            this.PH().addEventListener("pointerup", this.Oz),
            this.PH().addEventListener("pointercancel", this.N9e),
            this.XCt = t.pointerId,
            this.L9 = t.clientX,
            this.W9 = t.clientY,
            this.Kft = !1))
        }
        Gz(t) {
            if (t.preventDefault(),
            t.pointerId === this.XCt && !this.xot.$ln()) {
                if (this.xot.Jin() && !this.Kft && DM.di(this.L9, this.W9, t.clientX, t.clientY) >= FM) {
                    if (!this.xot.eun(this, "dragstart", t.target, t.clientX, t.clientY, t))
                        return this.XCt = -1,
                        this.PH().removeEventListener("pointermove", this.Mz),
                        this.PH().removeEventListener("pointerup", this.Oz),
                        void this.PH().removeEventListener("pointercancel", this.N9e);
                    this.Kft = !0,
                    this.xot.sht(this)
                }
                this.Kft && (this.xot.eun(this, "dragmove", null, t.clientX, t.clientY, t),
                this.xot.eht(t.clientX, t.clientY))
            }
        }
        Cz(t) {
            if (t.pointerId !== this.XCt)
                return;
            const i = this.Kft;
            if (this.kH(),
            i) {
                if (!this.xot)
                    return;
                this.xot.Rln(),
                this.xot.eun(this, "drop", null, t.clientX, t.clientY, t)
            }
        }
        b2(t) {
            this.Cz(t)
        }
    }
}
{
    const BM = self.t
      , UM = 3;
    BM.qs.Jj.Table.V7t = class extends BM.Event.aG {
        constructor(t, i, e, s, n) {
            BM.U(t, BM.qs.Jj.Table),
            BM.zlt(i),
            BM.Ge(e),
            BM.Kq(s),
            BM.Hut(n),
            super(),
            this.xot = t,
            this.hVt = i,
            this.Nd = e,
            this.phs = s,
            this.gTt = n,
            this.Get = null,
            this.Eun = null,
            this.Cun = null,
            this._un = null,
            this.Tun = null,
            this.lun = null,
            this.f7i = 0,
            this.Iun = 0,
            this.Pun = 0,
            this.Gun = -1,
            this.Aun = -1,
            this.Run = !!this.gTt.dun,
            this.kun = this.gTt.cun,
            this.Oun = "",
            this.Get = s ? BM.qs.lk("ui-table-column", i, null, null, {
                columnName: s
            }) : BM.qs.lk("ui-table-column", i),
            this.Run && this.Get.setAttribute("top-row-column", ""),
            this.Get.setAttribute("horizontal-align", n.uun),
            this.Get.setAttribute("has-size-styles", ""),
            this.Get.setAttribute("current-size", ""),
            this.Get.setAttribute("min-size", this.gTt.Pot),
            e && -1 !== e ? (this.Get.style.width = `${e}px`,
            this.Get.setAttribute("current-size", `${e}px`),
            this.Get.style.maxWidth = `${e}px`,
            this.Get.style.minWidth = `${e}px`) : (this.Get.removeAttribute("has-size-styles"),
            this.Get.style.width = `${this.gTt.Pot}px`,
            this.Get.setAttribute("current-size", `${this.gTt.Pot}px`)),
            this.Dun = -1,
            this.TUt = t => this.IW(t),
            this.PUt = t => this.Gz(t),
            this.SUt = t => this.Cz(t),
            this.Fun = t => this.Lun(t),
            this.xFi = t => this.b2(t),
            this.Get.addEventListener("pointerdown", this.TUt),
            this.Get.addEventListener("pointermove", this.Fun)
        }
        he() {
            this.Get.removeEventListener("pointerdown", this.TUt),
            this.Get.removeEventListener("pointermove", this.Fun),
            this.xot.PH().removeEventListener("pointermove", this.PUt, {
                passive: !0
            }),
            this.xot.PH().removeEventListener("pointerup", this.SUt),
            this.xot.PH().removeEventListener("pointercancel", this.xFi),
            BM.qs.BW(this.Get),
            this.Eun && BM.sc(this.Eun),
            this.Cun && BM.sc(this.Cun),
            this.lun && BM.sc(this.lun),
            this.TUt = null,
            this.PUt = null,
            this.SUt = null,
            this.Fun = null,
            this.Eun = null,
            this._un = null,
            this.Cun = null,
            this.Tun = null,
            this.lun = null,
            this.xot = null,
            this.hVt = null,
            this.Get = null,
            this.gTt = null,
            this.kun = null,
            super.he()
        }
        Dln() {
            this.lun && BM.sc(this.lun)
        }
        so() {
            if (!this.Fln())
                return;
            this.Bun();
            const t = this.Uun();
            -1 !== t && this.Nun(t)
        }
        elt() {
            this.Bun();
            const t = this.jp()
              , i = Number(this.Get.getAttribute("min-size"));
            return t !== i && (-1 !== i && -1 !== t && t < i && (this.jun(i),
            !0))
        }
        hk() {
            return this.Get
        }
        YIt() {
            return this.gTt
        }
        Fln() {
            return -1 === this.Nd
        }
        $un() {
            return 0 === this.zun(this.Get)
        }
        Vun() {
            return this.zun(this.Get) === this.xot.Xln().Oln().length - 1
        }
        Njt() {
            return this.phs
        }
        Bun() {
            this.Dun = -1
        }
        Lln() {
            return Number(this.Get.getAttribute("min-size"))
        }
        Bln() {
            const t = getComputedStyle(this.Get);
            return this.Get.getBoundingClientRect().width + parseInt(t.padding) + parseInt(t.borderWidth)
        }
        Wun() {
            return parseFloat(this.Get.style.width)
        }
        Nun(t) {
            BM.Ge(t);
            const i = `${t}px`;
            this.Get.style.width = i,
            this.Get.removeAttribute("has-size-styles"),
            this.Fln() || (this.Get.setAttribute("has-size-styles", ""),
            this.Get.style.maxWidth = i,
            this.Get.style.minWidth = i,
            this.Hr(t))
        }
        jun(t) {
            BM.Ge(t),
            this.Eun = this.Hun(0);
            for (let i of this.Eun) {
                const e = `${t}px`;
                i.style.width = e,
                i.removeAttribute("has-size-styles"),
                this.Fln() || (i.setAttribute("has-size-styles", ""),
                i.style.maxWidth = e,
                i.style.minWidth = e)
            }
            if (this.Hr(t),
            this.Kun())
                for (const i of this.Kun())
                    i.Hr(t);
            BM.sc(this.Eun),
            this.Eun = null
        }
        Uun() {
            return this.Run ? this.jp() : -1 === this.Nd ? (this.Dun = this.kun.jp(),
            this.Dun) : this.Nd
        }
        jp() {
            if (-1 !== this.Dun)
                return this.Dun;
            if (-1 === this.Nd) {
                let t = getComputedStyle(this.Get)
                  , i = parseInt(t.width);
                return BM.Go(i) && (this.Dun = i),
                this.Dun
            }
            return this.Nd
        }
        Hr(t) {
            BM.Ge(t),
            -1 !== this.Nd && (this.Nd = t)
        }
        fun(t) {
            BM.U(t, BM.qs.Jj.Table.V7t),
            this.lun || (this.lun = []),
            this.lun.push(t)
        }
        Kun() {
            return this.lun
        }
        kH() {
            this.b2()
        }
        zun(t) {
            const i = Array.prototype.filter.call(t.parentNode.childNodes, t => "ui-table-column" === t.tagName.toLowerCase());
            return Array.prototype.indexOf.call(i, t)
        }
        Hun(t) {
            BM.Ge(t);
            let i = this.zun(this.Get) + t
              , e = this.xot.hk().getElementsByTagName("ui-table-column");
            return 0 === t ? this._un = this.xot.Xln().Oln()[i] : this.Tun = this.xot.Xln().Oln()[i],
            Array.prototype.filter.call(e, t => this.zun(t) === i)
        }
        IW(t) {
            if (!this.xot.hit())
                return;
            this.xot.so();
            let i = this.Get
              , e = i.getBoundingClientRect()
              , s = t.clientX - e.left;
            if (this.f7i = t.clientX,
            i.style.width)
                this.Iun = parseFloat(i.style.width);
            else {
                let t = parseInt(getComputedStyle(i).padding);
                this.Iun = e.width - 2 * t
            }
            if (s <= UM) {
                if (this.$un())
                    return;
                return this.xot.jln(!0, this),
                this.Oun = "left",
                this.Eun = this.Hun(0),
                this.Cun = this.Hun(-1),
                this.Tun && (this.Tun.Bun(),
                this.Pun = this.Tun.jp()),
                this.xot.PH().addEventListener("pointermove", this.PUt, {
                    passive: !0
                }),
                this.xot.PH().addEventListener("pointerup", this.SUt),
                this.xot.PH().addEventListener("pointercancel", this.xFi),
                this.Get.removeEventListener("pointermove", this.Fun),
                void this.xot.qln("columnresizestart", void 0, void 0, t)
            }
            return s >= e.width - UM ? (this.xot.jln(!0, this),
            this.Oun = "right",
            this.Eun = this.Hun(0),
            this.Cun = this.Hun(1),
            this.Tun && (this.Tun.Bun(),
            this.Pun = this.Tun.jp()),
            this.xot.PH().addEventListener("pointermove", this.PUt),
            this.xot.PH().addEventListener("pointerup", this.SUt),
            this.xot.PH().addEventListener("pointercancel", this.xFi),
            this.Get.removeEventListener("pointermove", this.Fun, {
                passive: !0
            }),
            void this.xot.qln("columnresizestart", void 0, void 0, t)) : void 0
        }
        qun(t, i) {
            BM.Ge(t),
            BM._D(i);
            const e = `${Math.floor(t)}px`;
            for (let t of i) {
                if (t.getAttribute("current-size") === e)
                    continue;
                t.setAttribute("current-size", e),
                t.style.width = e;
                const i = t.hasAttribute("has-size-styles");
                i && (t.style.maxWidth = e),
                i && (t.style.minWidth = e)
            }
        }
        Gz(t) {
            const i = this.xot.Uln();
            let e = Math.floor((t.clientX - this.f7i) / i);
            "left" === this.Oun && (e *= -1),
            this.Gun = this.Iun + e;
            let s = Number(this.Get.getAttribute("min-size"));
            if (s = -1 === s ? 0 : s,
            this.Gun < s)
                return this.Gun = s,
                this.qun(this.Gun, this.Eun),
                void (this.Tun && (this.Aun = this.Pun + (this.Iun - s),
                this.qun(this.Aun, this.Cun)));
            if (this.Tun) {
                this.Aun = this.Pun - e;
                let t = Number(this.Cun[0].getAttribute("min-size"));
                if (t = -1 === t ? 0 : t,
                this.Aun < t)
                    return this.Aun = t,
                    this.qun(this.Aun, this.Cun),
                    this.Gun = this.Iun + (this.Pun - t),
                    void this.qun(this.Gun, this.Eun)
            }
            this.qun(this.Gun, this.Eun),
            this.qun(this.Aun, this.Cun),
            this.xot.qln("columnresizeupdate", void 0, void 0, t)
        }
        Lun(t) {
            if (!this.xot.hit())
                return;
            let i = this.Get
              , e = i.getBoundingClientRect()
              , s = t.clientX - e.left;
            return s <= UM ? 0 === this.zun(i) ? void this.xot.hk().removeAttribute("resizing-column") : void this.xot.hk().setAttribute("resizing-column", "") : s >= e.width - UM ? this.Fln() && this.Vun() ? void this.xot.hk().removeAttribute("resizing-column") : void this.xot.hk().setAttribute("resizing-column", "") : void this.xot.hk().removeAttribute("resizing-column")
        }
        Cz(t) {
            if (this._un && -1 !== this.Gun) {
                let t = this.Gun > 0 ? this.Gun : 0;
                if (this._un.Hr(t),
                this._un.Kun())
                    for (let i of this._un.Kun())
                        i.Hr(t)
            }
            if (this.Tun && -1 !== this.Aun) {
                let t = this.Aun > 0 ? this.Aun : 0;
                if (this.Tun.Hr(t),
                this.Tun.Kun())
                    for (let i of this.Tun.Kun())
                        i.Hr(t)
            }
            BM.sc(this.Eun),
            BM.sc(this.Cun),
            this.Gun = -1,
            this.Aun = -1,
            this._un = null,
            this.Tun = null,
            this.Oun = "",
            this.xot.jln(!1),
            this.xot.hk().removeAttribute("resizing-column"),
            this.xot.PH().removeEventListener("pointermove", this.PUt, {
                passive: !0
            }),
            this.xot.PH().removeEventListener("pointerup", this.SUt),
            this.xot.PH().removeEventListener("pointercancel", this.xFi),
            this.Get.addEventListener("pointermove", this.Fun),
            this.xot.qln("columnresize", void 0, void 0, t),
            this.xot.qln("columnresizeend", void 0, void 0, t)
        }
        b2(t) {
            this.xot && this.xot.$ln() && this.Cz(t)
        }
        QL() {
            const t = {};
            if (t.id = this.Njt(),
            t.computedSize = this.Fln() ? -1 : this.Wun(),
            t.hasSizeStyle = this.Get.hasAttribute("has-size-styles"),
            t.currentSize = this.Get.hasAttribute("current-size") ? this.Get.getAttribute("current-size") : "",
            this.Get.style.width)
                t.currentColumnSize = parseFloat(this.Get.style.width);
            else {
                let i = this.Get.getBoundingClientRect()
                  , e = parseInt(getComputedStyle(this.Get).padding);
                t.currentColumnSize = i.width - 2 * e
            }
            return this.Tun && (this.Tun.Bun(),
            t.currentAdjacentColumnSize = this.Tun.jp()),
            t
        }
        tU(t, i) {
            if (t) {
                if (t.hasOwnProperty("hasSizeStyle") && this.Get.setAttribute("has-size-styles", ""),
                t.hasOwnProperty("computedSize") && this.jun(t.computedSize),
                t.hasOwnProperty("currentColumnSize") && this._un) {
                    const i = t.currentColumnSize > 0 ? t.currentColumnSize : 0;
                    if (this._un.Hr(i),
                    this._un.Kun())
                        for (const t of this._un.Kun())
                            t.Hr(i)
                }
                if (t.hasOwnProperty("currentAdjacentColumnSize") && this.Tun && this._un) {
                    const i = t.currentAdjacentColumnSize > 0 ? t.currentAdjacentColumnSize : 0;
                    if (this.Tun.Hr(i),
                    this._un.Kun())
                        for (const t of this.Tun.Kun())
                            t.Hr(i)
                }
            }
        }
    }
}
{
    const NM = self.t
      , jM = self.assert
      , $M = {
        uun: "left",
        Rot: "left",
        Dot: "left",
        Pot: -1,
        dun: !1
    }
      , zM = ["left", "center", "right"];
    NM.qs.Jj.Table.Qln = class extends NM.Event.aG {
        constructor(t) {
            super(),
            this.xot = t,
            this.Get = NM.qs.lk("ui-table-row"),
            this.Get.setAttribute("topRow", ""),
            this.xot.hk().appendChild(this.Get),
            this.Xun = !1,
            this.uui = [],
            this.aVi = t => {
                t.preventDefault(),
                this.xot.qln("tablecontextmenu", t.clientX, t.clientY, t)
            }
            ,
            this.Get.addEventListener("contextmenu", this.aVi)
        }
        he() {
            this.Get.removeEventListener("contextmenu", this.aVi),
            this.aVi = null,
            NM.qs.BW(this.Get),
            this.Get = null;
            for (let t of this.uui)
                t.he();
            NM.sc(this.uui),
            this.uui = null,
            this.xot = null,
            this.Xun = !1,
            super.he()
        }
        hk() {
            return this.Get
        }
        Oln() {
            return this.uui
        }
        sun(t) {
            NM.zt(t);
            for (const i of this.uui)
                if (i.Njt() === t)
                    return i
        }
        Yun(t) {
            return NM.U(t, NM.qs.Jj.Table.V7t),
            -1 !== this.uui.indexOf(t)
        }
        kot(t, i, e, s) {
            if (NM.zt(t),
            NM.Ge(i),
            NM.Kq(e),
            NM._U(s),
            this.Xun)
                throw new Error("only one auto sizing column at the end of the table is allowed");
            s = Object.assign({}, $M, s),
            jM(zM.includes(s.Rot), `unexpected header horizontal align value ${s.Rot}, supported values are ${zM}`),
            jM(zM.includes(s.Dot), `unexpected content horizontal align value ${s.Dot}, supported values are ${zM}`),
            s.uun = s.Rot,
            s.dun = !0;
            let n = NM.v(NM.qs.Jj.Table.V7t, this.xot, this.Get, i, t, s);
            if (n.hk().classList.add("top-row-column"),
            e) {
                NM.qs.lk("div", n.hk()).textContent = e
            }
            return this.uui.push(n),
            this
        }
        Mot(t, i, e) {
            NM.zt(t),
            NM.Kq(i),
            NM._U(e),
            this.kot(t, -1, i, e),
            this.xot.hk().setAttribute("flex-filler", ""),
            this.Xun = !0
        }
    }
}
{
    const VM = self.t;
    VM.qs.Jj.Table.Jun = class {
        constructor() {
            this.Zun = !1
        }
        pun() {
            VM.E4()
        }
        he() {
            VM.E4()
        }
        so() {
            VM.E4()
        }
        hk() {
            VM.E4()
        }
        fo() {
            return this.Zun
        }
    }
}
{
    const WM = self.t
      , HM = {
        Hot: !1,
        cursor: null,
        qot: null
    };
    WM.qs.Jj.Table.wun = class extends WM.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            WM.zlt(t),
            super(),
            this.wat = null,
            e = Object.assign({}, HM, e),
            WM.$l(i, WM.qs.O_) && (this.wat = WM.v(WM.qs.kmt, i || {}, t),
            this.Qun(e, this.wat.hk())),
            WM.$l(i, WM.qs.pAe) && (this.wat = WM.qs.lk("div"),
            t.appendChild(this.wat),
            i.pat().then(t => {
                this.tcn(t, e, this.wat),
                this.Qun(e, this.wat),
                this.wat && this.hVt && this.wat.appendChild(t)
            }
            )),
            this.hVt = t,
            this.hVt.setAttribute("icon", "")
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        he() {
            WM.$l(this.wat, WM.qs.kmt) ? this.wat.he() : WM.qs.BW(this.wat),
            this.wat = null,
            this.hVt = null
        }
        so() {}
        hk() {
            return WM.$l(this.wat, WM.qs.kmt) ? this.wat.hk() : this.wat
        }
        CA(t) {
            WM.$l(this.wat, WM.qs.kmt) && this.wat.CA(t)
        }
        Qun(t, i) {
            (this.wat || this.hVt) && (t.Hot ? i.classList.add("table-column-content-with-pointer") : i.classList.add("table-column-content"),
            t.cursor && (i.style.cursor = t.cursor))
        }
        tcn(t, i, e) {
            (this.wat || this.hVt) && (i.qot && WM.Go(i.qot.width) && (e.style.width = `${i.qot.width}px`),
            i.qot && WM.Go(i.qot.height) && (e.style.height = `${i.qot.height}px`),
            i.qot && WM.Go(i.qot.width) && t.setAttribute("width", i.qot.width),
            i.qot && WM.Go(i.qot.height) && t.setAttribute("height", i.qot.height))
        }
    }
}
{
    const KM = self.t
      , qM = self.assert;
    KM.qs.Jj.Table.vun = class extends KM.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            KM.zlt(t),
            super();
            const s = typeof i;
            qM("function" === s || "string" === s || "number" === s || "object" === s, "unexpected type"),
            this._S = KM.qs.lk("div", t, null, "table-column-content"),
            this.icn = "function" === s ? i : null,
            KM.odt(this._S, "function" === s ? i() : i),
            this.hVt = t
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        he() {
            KM.qs.BW(this._S),
            this._S = null,
            this.hVt = null,
            this.icn = null
        }
        so() {
            this.icn && this._S && KM.odt(this._S, this.icn())
        }
        pa(t) {
            KM.u7t(t),
            KM.odt(this._S, t)
        }
        VB() {
            return this._S.textContent
        }
        hk() {
            return this._S
        }
    }
}
{
    const XM = self.t
      , YM = self.assert;
    XM.qs.Jj.Table.bun = class extends XM.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            XM.zlt(t),
            super();
            const s = typeof i;
            YM("function" === s || "string" === s || "number" === s || "object" === s, "unexpected type"),
            this.qYs = XM.qs.lk("div", t, null, "table-column-content"),
            this.ecn = "function" === s ? i : null,
            XM.odt(this.qYs, "function" === s ? i().toString() : i.toString()),
            this.hVt = t
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        he() {
            XM.qs.BW(this.qYs),
            this.qYs = null,
            this.hVt = null,
            this.ecn = null
        }
        so() {
            this.ecn && this.qYs && XM.odt(this.qYs, this.ecn().toString())
        }
        hk() {
            return this.qYs
        }
    }
}
{
    const JM = self.t
      , ZM = self.assert
      , QM = 30;
    JM.qs.Jj.Table.REi = class extends JM.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            JM.zlt(t),
            super();
            const s = typeof i;
            ZM("function" === s || "string" === s || "number" === s || "object" === s, "unexpected type"),
            this.hVt = t,
            this.scn = "function" === s ? i() : i,
            this.icn = "function" === s ? i : null,
            this._S = JM.qs.lk("div", this.hVt, null, "table-column-content"),
            JM.odt(this._S, this.scn),
            this.jet = null,
            this.Zen = null,
            this.ncn = null,
            this.Xen = null,
            this.p7e = null,
            this.rcn = null,
            this.hcn = t => this.isn(),
            this.Zun = !0,
            this.ocn = NaN
        }
        he() {
            this.Csn(),
            JM.qs.BW(this._S),
            this.scn = null,
            this._S = null,
            this.hVt = null,
            this.Zen = null,
            this.ncn = null,
            this.Xen = null,
            this.p7e = null,
            this.rcn = null,
            this.hcn = null,
            this.icn = null,
            JM.Go(this.ocn) && (self.clearTimeout(this.ocn),
            this.ocn = NaN)
        }
        so() {
            this.icn && this._S && (this.scn = this.icn(),
            this._S.textContent = this.scn)
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        hk() {
            return this._S
        }
        pa(t) {
            JM.zt(t),
            this.scn = t,
            this._S.textContent = this.scn
        }
        VB() {
            return this.scn
        }
        $B() {
            return this.jet ? Promise.resolve(null) : this.hVt ? (this.jet = JM.qs.lk("input", this.hVt, null, "table-edit-text"),
            this.jet.classList.add("table-column-input"),
            this.jet.type = "text",
            this.jet.setAttribute("spellcheck", "false"),
            this.jet.addEventListener("UITap", JM.qs.dot),
            this.jet.addEventListener("UIDoubleTap", JM.qs.dot),
            this.ocn = window.setTimeout(t => {
                this.ocn = NaN,
                this.jet && (this.Xen = t => this.vWe(),
                this.jet.addEventListener("blur", this.Xen),
                this.jet.select())
            }
            , QM),
            this.p7e = t => this.Esn(t),
            this.jet.addEventListener("keydown", this.p7e, !0),
            this.hVt.addEventListener("scroll", this.hcn, {
                passive: !0
            }),
            this.jet.value = this.scn,
            this.jet.focus(),
            this._S.textContent = "",
            new Promise( (t, i) => {
                this.Zen = t,
                this.ncn = i
            }
            )) : Promise.resolve(null)
        }
        Esn(t) {
            t.which === JM.kE.w9 ? (t.preventDefault(),
            t.stopPropagation(),
            this.vWe()) : t.which === JM.kE.IE && (t.preventDefault(),
            t.stopPropagation(),
            this.bEi())
        }
        vWe() {
            if (!this.jet)
                return;
            let t = this.jet.value;
            this.Csn(),
            this.Zen && this.Zen(t),
            this.Zen = null,
            this.ncn = null
        }
        bEi() {
            this.jet && (this.Csn(),
            this.Zen && this.Zen(null),
            this.Zen = null,
            this.ncn = null)
        }
        Csn() {
            this.jet && (this.scn = this.jet.value,
            this._S.textContent = this.scn,
            this.hVt.removeEventListener("scroll", this.hcn, {
                passive: !0
            }),
            this.jet.removeEventListener("keydown", this.p7e, !0),
            this.jet.removeEventListener("blur", this.Xen),
            this.jet.removeEventListener("contextmenu", this.rcn),
            this.jet.removeEventListener("UITap", JM.qs.dot),
            this.jet.removeEventListener("UIDoubleTap", JM.qs.dot),
            JM.qs.BW(this.jet),
            this.p7e = null,
            this.Xen = null,
            this.jet = null)
        }
        isn() {
            this.jet.style.left = `${this._S.offsetLeft}px`,
            this.jet.style.top = this._S.offsetTop - this.hVt.scrollTop + "px";
            let t = this.hVt.getBoundingClientRect()
              , i = this.jet.getBoundingClientRect();
            (i.bottom > t.bottom || i.top < t.top || i.left < t.left || i.right > t.right) && this.bEi()
        }
    }
}
{
    const tE = self.t
      , iE = self.assert
      , eE = 30;
    tE.qs.Jj.Table.yun = class extends tE.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            tE.zlt(t),
            super();
            let s = typeof e.gun;
            iE("function" === s || "string" === s, "unexpected type'"),
            this.hVt = t,
            this.acn = e.gun,
            this.xot = e.table,
            this.lcn = e.ght,
            this.ucn = e.Uot ? e.Uot : self.lang("common.ellipsis"),
            s = typeof i,
            iE("function" === s || "string" === s, "unexpected type"),
            this.icn = "function" === s ? i : null,
            this.jlt = tE.qs.lk("div", this.hVt, null, "table-column-content-long-text"),
            this.jlt.classList.add("table-column-content"),
            this.jet = tE.qs.lk("input", this.jlt),
            this.jet.type = "text",
            this.jet.value = "function" === s ? i() : i,
            this.jet.setAttribute("spellcheck", "false"),
            this.jet.setAttribute("autocomplete", "off"),
            this.nJi = tE.qs.lk("button", this.jlt),
            this.nJi.textContent = this.ucn,
            this.ccn = t => this.B7e(t),
            this.nJi.addEventListener("click", this.ccn),
            this.Zun = !0,
            this.dcn = null,
            this.ocn = NaN,
            this.Zen = null,
            this.ncn = null,
            this.fcn = t => this.vWe(),
            this.pcn = t => this.Esn(t),
            this.hcn = t => this.isn()
        }
        he() {
            this.Csn(),
            this.dcn = null,
            this.Zen = null,
            this.ncn = null,
            this.fcn = null,
            this.pcn = null,
            this.hcn = null,
            this.nJi.removeEventListener("click", this.ccn),
            this.ccn = null,
            tE.qs.BW(this.nJi),
            this.nJi = null,
            tE.qs.BW(this.jet),
            this.jet = null,
            tE.qs.BW(this.jlt),
            this.jlt = null,
            this.hVt = null,
            this.acn = null,
            this.xot = null,
            this.lcn = null,
            this.icn = null
        }
        so() {
            this.icn && this.jet && (this.jet.value = this.icn())
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        hk() {
            return this.jlt
        }
        VB() {
            return this.jet.value
        }
        unt() {
            return this.dcn ? Promise.resolve(null) : this.hVt ? (this.dcn = tE.qs.lk("input", this.hVt, null, "long-table-edit-text"),
            this.dcn.classList.add("table-column-input"),
            this.dcn.type = "text",
            this.dcn.setAttribute("spellcheck", "false"),
            this.dcn.addEventListener("UITap", tE.qs.dot),
            this.dcn.addEventListener("UIDoubleTap", tE.qs.dot),
            this.ocn = window.setTimeout(t => {
                this.ocn = NaN,
                this.dcn && (this.dcn.addEventListener("blur", this.fcn),
                this.dcn.select())
            }
            , eE),
            this.dcn.addEventListener("keydown", this.pcn, !0),
            this.hVt.addEventListener("scroll", this.hcn, {
                passive: !0
            }),
            this.dcn.value = this.jet.value,
            this.dcn.focus(),
            this.jet.textContent = ".",
            new Promise( (t, i) => {
                this.Zen = t,
                this.ncn = i
            }
            )) : Promise.resolve(null)
        }
        $B() {
            let t = tE.qs.Ys.$s("LongTextPropertyDialog");
            switch (typeof this.acn) {
            case "function":
                t.Ya(this.acn());
                break;
            case "string":
                t.Ya(this.acn)
            }
            const i = this.icn ? this.icn() : this.jet.value;
            return t.Qa(i).then(t => null === t ? null : (this.jet && (this.jet.value = t),
            t))
        }
        B7e(t) {
            this.xot.eun(this.lcn, "longtextedittapped", this.hVt, t.clientX, t.clientY, t)
        }
        Esn(t) {
            t.which === tE.kE.w9 ? (t.preventDefault(),
            t.stopPropagation(),
            this.vWe()) : t.which === tE.kE.IE && (t.preventDefault(),
            t.stopPropagation(),
            this.bEi())
        }
        vWe() {
            if (!this.dcn)
                return;
            let t = this.dcn.value;
            this.Csn(),
            this.Zen && this.Zen(t),
            this.Zen = null,
            this.ncn = null
        }
        bEi() {
            this.dcn && (this.Csn(),
            this.Zen && this.Zen(null),
            this.Zen = null,
            this.ncn = null)
        }
        Csn() {
            this.dcn && (this.jet.textContent = this.dcn.value,
            this.hVt.removeEventListener("scroll", this.hcn, {
                passive: !0
            }),
            this.dcn.removeEventListener("keydown", this.pcn, !0),
            this.dcn.removeEventListener("blur", this.fcn),
            this.dcn.removeEventListener("UITap", tE.qs.dot),
            this.dcn.removeEventListener("UIDoubleTap", tE.qs.dot),
            tE.qs.BW(this.dcn),
            this.dcn = null)
        }
        isn() {
            this.dcn.style.left = `${this.jet.offsetLeft}px`,
            this.dcn.style.top = this.jet.offsetTop - this.hVt.scrollTop + "px";
            let t = this.hVt.getBoundingClientRect()
              , i = this.dcn.getBoundingClientRect();
            (i.bottom > t.bottom || i.top < t.top || i.left < t.left || i.right > t.right) && this.bEi()
        }
    }
}
{
    const sE = self.t;
    sE.qs.Jj.Table.Sun = class extends sE.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            if (sE.zlt(t),
            i && sE.Mw(i, i.ownerDocument.defaultView.DocumentFragment),
            super(),
            this.hVt = t,
            i) {
                let t = i.childNodes;
                for (let i = 0, e = t.length; i < e; i++)
                    t[i].classList.add("table-column-content"),
                    sE.tOe(t[i]) && t[i].classList.add("table-column-input");
                this.hVt.appendChild(i)
            }
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        he() {
            this.hVt = null
        }
        so() {}
        hk() {
            return this.hVt
        }
    }
}
{
    const nE = self.t
      , rE = self.assert;
    nE.qs.Jj.Table.xun = class extends nE.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            nE.zlt(t),
            super(),
            rE(nE.XOt(i) || nE.kft(i), "unexpected type"),
            this.xot = e.table,
            this.lcn = e.ght,
            this.Ywe = nE.qs.lk("select", t, null, "table-column-content-select"),
            this.mcn = t => this.wlt(t),
            this.Ywe.addEventListener("change", this.mcn),
            this.wcn = i,
            this.gcn(),
            nE.Go(e.selectedIndex) && -1 !== e.selectedIndex && (this.Ywe.selectedIndex = e.selectedIndex),
            this.hVt = t
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        he() {
            this.Ywe.removeEventListener("change", this.mcn),
            this.mcn = null,
            nE.qs.BW(this.Ywe),
            this.Ywe = null,
            this.hVt = null,
            this.wcn = null,
            this.xot = null,
            this.lcn = null
        }
        VB() {
            return this.Ywe.options[this.Ywe.selectedIndex].textContent
        }
        Ft() {
            return this.Ywe.value
        }
        Pp() {
            const t = this.Ywe.selectedIndex;
            if (nE.XOt(this.wcn)) {
                const i = this.wcn()[t];
                if (nE.doe(i))
                    return null;
                if (nE.Ots(i))
                    return i.userData
            }
            if (nE.kft(this.wcn)) {
                const i = this.wcn[t];
                if (nE.doe(i))
                    return null;
                if (nE.Ots(i))
                    return i.userData
            }
            return null
        }
        so() {
            const t = this.Ywe.selectedIndex;
            this.wcn && this.Ywe && (this.Ywe.replaceChildren(),
            this.gcn(),
            this.Ywe.selectedIndex = t)
        }
        hk() {
            return this.Ywe
        }
        gcn() {
            if (nE.XOt(this.wcn))
                for (const t of this.wcn()) {
                    if (nE.doe(t)) {
                        nE.qs.lk("option", this.Ywe).textContent = t
                    }
                    if (nE.Ots(t)) {
                        nE.zt(t.value),
                        nE.zt(t.text);
                        const i = nE.qs.lk("option", this.Ywe);
                        i.value = t.value,
                        i.textContent = t.text
                    }
                }
            if (nE.kft(this.wcn))
                for (const t of this.wcn) {
                    if (nE.doe(t)) {
                        nE.qs.lk("option", this.Ywe).textContent = t
                    }
                    if (nE.Ots(t)) {
                        nE.zt(t.value),
                        nE.zt(t.text);
                        const i = nE.qs.lk("option", this.Ywe);
                        i.value = t.value,
                        i.textContent = t.text
                    }
                }
        }
        wlt(t) {
            this.xot.eun(this.lcn, "selectoptionchange", this.hVt, t.clientX, t.clientY, t)
        }
    }
}
{
    const hE = self.t
      , oE = self.assert;
    hE.qs.Jj.Table.Mun = class extends hE.qs.Jj.Table.Jun {
        constructor(t, i, e) {
            hE.zlt(t),
            super();
            const s = typeof i;
            oE("function" === s || "boolean" === s, "unexpected type"),
            this.xot = e.table,
            this.lcn = e.ght,
            this.jet = hE.qs.lk("input", t, null, "table-column-content"),
            this.jet.type = "checkbox",
            this.ycn = t => this.v5t(t),
            this.jet.addEventListener("change", this.ycn),
            this.bcn = "function" === s ? i : null,
            this.jet.checked = "function" === s ? !!this.bcn() : !!i,
            this.hVt = t
        }
        pun() {
            return this.hVt.getAttribute("columnName")
        }
        he() {
            this.jet.removeEventListener("change", this.ycn),
            this.ycn = null,
            hE.qs.BW(this.jet),
            this.jet = null,
            this.hVt = null,
            this.bcn = null,
            this.xot = null,
            this.lcn = null
        }
        so() {
            this.bcn && this.jet && (this.jet.checked = !!this.bcn())
        }
        ets(t) {
            this.jet.checked = !!t
        }
        Ft() {
            return this.jet.checked
        }
        hk() {
            return this.jet
        }
        v5t(t) {
            this.xot.eun(this.lcn, "checkboxchange", this.hVt, t.clientX, t.clientY, t)
        }
    }
}
{
    const aE = self.t;
    aE.qs.Jj.X5t = class extends aE.Event.aG {
        constructor(t) {
            super(),
            aE.zlt(t),
            this.Get = aE.qs.lk("ui-close-button", t),
            this.Get.setAttribute("title", self.lang("ui.controls.close-button.close-tooltip")),
            this.Get.setAttribute("aria-label", self.lang("ui.controls.close-button.close-tooltip")),
            this.Get.setAttribute("role", "button"),
            this._6e = null,
            self.app.Bot("close").pat().then(t => {
                aE.dn(this) || this.vcn(t)
            }
            ),
            this.onclick = null,
            this.C1 = !0,
            this.Scn = t => this.JGe(t),
            this.Get.addEventListener("click", this.Scn),
            this.l1 = t => this.IW(t),
            this.Get.addEventListener("pointerdown", this.l1),
            this.cn = !1
        }
        he() {
            this.cn = !0,
            aE.qs.BW(this._6e),
            this._6e = null,
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.Get.removeEventListener("click", this.Scn),
            this.Scn = null,
            this.onclick = null,
            aE.qs.BW(this.Get),
            this.Get = null,
            super.he()
        }
        vcn(t) {
            this.cn || (this._6e = t,
            this._6e.setAttribute("role", "none"),
            this.Get.appendChild(this._6e))
        }
        hk() {
            return this.Get
        }
        JGe(t) {
            0 === t.button && this.C1 && (t.stopPropagation(),
            this.onclick && this.onclick())
        }
        IW(t) {
            t.stopPropagation()
        }
        _K(t) {
            t = !!t,
            this.C1 !== t && (this.C1 = t,
            t ? (this.Get.classList.remove("disabled"),
            this.Get.setAttribute("title", self.lang("ui.controls.close-button.close-tooltip")),
            this.Get.setAttribute("aria-disabled", "true")) : (this.Get.classList.add("disabled"),
            this.Get.removeAttribute("title"),
            this.Get.removeAttribute("aria-disabled")))
        }
    }
}
{
    const lE = self.t;
    lE.qs.Jj.$Je = class extends lE.Event.aG {
        constructor(t) {
            super(),
            lE.zlt(t),
            this.Dtn = self.lang("ui.controls.menu-dots-button.options-tooltip"),
            this.Get = lE.qs.lk("ui-menu-dots-button", t),
            this.Get.setAttribute("title", this.Dtn),
            this.Get.setAttribute("aria-label", this.Dtn),
            this._6e = null,
            self.app.Bot("menu-dots").pat().then(t => {
                lE.dn(this) || this.vcn(t)
            }
            ),
            this.onclick = null,
            this.C1 = !0,
            this.l1 = t => this.IW(t),
            this.Get.addEventListener("pointerdown", this.l1),
            this.cn = !1
        }
        he() {
            this.cn = !0,
            lE.qs.BW(this._6e),
            this._6e = null,
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.onclick = null,
            lE.qs.BW(this.Get),
            this.Get = null,
            super.he()
        }
        vcn(t) {
            this.cn || (this._6e = t,
            this.Get.appendChild(this._6e))
        }
        hk() {
            return this.Get
        }
        $6i(t) {
            lE.zt(t),
            this.Dtn = t,
            this.Get.setAttribute("title", this.Dtn),
            this.Get.setAttribute("aria-label", this.Dtn)
        }
        IW(t) {
            0 === t.button && this.C1 && (t.stopPropagation(),
            this.onclick && this.onclick())
        }
        _K(t) {
            t = !!t,
            this.C1 !== t && (this.C1 = t,
            t ? (this.Get.classList.remove("disabled"),
            this.Get.setAttribute("title", this.Dtn),
            this.Get.setAttribute("aria-disabled", "true")) : (this.Get.classList.add("disabled"),
            this.Get.removeAttribute("title"),
            this.Get.removeAttribute("aria-disabled")))
        }
    }
}
{
    const uE = self.t;
    uE.qs.Jj.zJe = class extends uE.Event.aG {
        constructor(t) {
            super(),
            uE.zlt(t),
            this.Get = uE.qs.lk("ui-back-button"),
            t.insertBefore(this.Get, t.firstChild),
            this.Get.setAttribute("title", self.lang("ui.controls.back-button.back-tooltip")),
            this.Get.setAttribute("aria-label", self.lang("ui.controls.back-button.back-tooltip")),
            this._6e = null,
            self.app.Bot("back").pat().then(t => this.vcn(t)),
            this.onclick = null,
            this.l1 = t => this.IW(t),
            this.Get.addEventListener("pointerdown", this.l1),
            this.Hai = !0,
            this.cn = !1
        }
        he() {
            this.cn = !0,
            uE.qs.BW(this._6e),
            this._6e = null,
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            this.onclick = null,
            uE.qs.BW(this.Get),
            this.Get = null,
            super.he()
        }
        vcn(t) {
            this.cn || (this._6e = t,
            this.Get.appendChild(this._6e))
        }
        x_(t) {
            this.Hai !== t && (this.Get.style.visibility = t ? "visible" : "hidden",
            this.Hai = t)
        }
        hk() {
            return this.Get
        }
        IW(t) {
            0 === t.button && (t.stopPropagation(),
            this.onclick && this.onclick())
        }
    }
}
{
    const cE = self.t;
    cE.qs.Jj._Se = class extends cE.Event.aG {
        constructor(t) {
            cE.Tke(t, HTMLElement),
            super(),
            this.Get = t,
            this.Hye = cE.v(cE.kh, cE.jh.Gh(this.Get, "keydown", t => this.FP(t)), cE.jh.Gh(this.Get, "keypress", t => this.sNt(t)), cE.jh.Gh(this.Get, "paste", t => this.HP(t)), cE.jh.Gh(this.Get, "cut", t => this.BP(t)), cE.jh.Gh(this.Get, "blur", t => this.DUt(t))),
            this.q_ = [],
            this.J_ = [],
            this.Uli = null,
            this.xcn = new Map,
            this.xcn.set("delete", t => this.Mcn(t)),
            this.xcn.set("backspace", t => this.Ecn(t));
            const i = t => this.Ccn(t, this.J_, this.q_)
              , e = t => this.Ccn(t, this.q_, this.J_);
            cE.kt.w$t ? (this.xcn.set("cmd-shift-z", i),
            this.xcn.set("cmd-y", i),
            this.xcn.set("cmd-z", e)) : (this.xcn.set("ctrl-shift-z", i),
            this.xcn.set("ctrl-y", i),
            this.xcn.set("ctrl-z", e)),
            cE.qs.CD(this.Get, "contenteditable", !0)
        }
        he() {
            this.Get = null,
            this.Hye.Vh(),
            this.Hye = null,
            cE.sc(this.q_),
            cE.sc(this.J_),
            this.q_ = null,
            this.J_ = null,
            this.Uli = null,
            this.xcn.clear(),
            this.xcn = null,
            super.he()
        }
        hk() {
            return this.Get
        }
        pa(t, i) {
            cE.zt(t),
            i = !!i,
            this.Get.textContent !== t && (i || this.Clt(),
            this.Get.textContent = t)
        }
        _cn(t) {
            const i = [];
            return cE.kt.w$t && t.metaKey && i.push("cmd"),
            t.ctrlKey && i.push("ctrl"),
            t.shiftKey && i.push("shift"),
            i.push(t.key.toLowerCase()),
            i.join("-")
        }
        Tcn() {
            return cE.Sis.JSe(this.Get)
        }
        Icn(t) {
            t && cE.Sis.Mis(this.Get, t.start, t.end)
        }
        Clt() {
            cE.sc(this.J_);
            let t = this.Get.textContent
              , i = this.Tcn();
            this.q_.push( () => {
                const e = this.Get.textContent
                  , s = this.Tcn();
                this.Get.textContent = t,
                this.Icn(i),
                t = e,
                i = s,
                this.Get.dispatchEvent(new Event("modified"))
            }
            )
        }
        DUt(t) {
            this.Uli = null
        }
        FP(t) {
            const i = this._cn(t)
              , e = this.xcn.get(i);
            e && e(t)
        }
        sNt(t) {
            const i = this.Tcn();
            if (!i)
                return;
            const e = this.Uli
              , s = "Enter" === t.key ? "\n" : t.key;
            i.start === i.end ? (e && "insert" === e.type && e.cursor.end === i.end || this.Clt(),
            i.end = i.start = i.end + s.length,
            this.Uli = {
                type: "insert",
                cursor: i
            }) : (this.Clt(),
            i.end = i.start = i.start + s.length,
            this.Uli = {
                type: "insert",
                cursor: i
            })
        }
        HP(t) {
            const i = this.Tcn();
            if (!i)
                return;
            t.preventDefault();
            const {start: e, end: s} = i
              , n = t.clipboardData.getData("text")
              , r = this.Get.textContent
              , h = r.slice(0, e) + n + r.slice(s);
            this.pa(h),
            i.end = i.start = e + n.length,
            this.Icn(i),
            this.Get.dispatchEvent(new Event("modified")),
            this.Uli = {
                type: "paste",
                cursor: i
            }
        }
        BP(t) {
            const i = this.Tcn();
            i && (this.Clt(),
            i.end = i.start,
            this.Uli = {
                type: "cut",
                cursor: i
            })
        }
        Mcn(t) {
            const i = this.Tcn();
            if (!i)
                return;
            const e = this.Uli;
            i.start === i.end ? e && "delete" === e.type && e.cursor.end === i.end || (this.Clt(),
            this.Uli = {
                type: "delete",
                cursor: i
            }) : (this.Clt(),
            this.Uli = {
                type: "deleteRange",
                cursor: i
            })
        }
        Ecn(t) {
            const i = this.Tcn();
            if (!i)
                return;
            const e = this.Uli;
            i.start === i.end ? (e && "delete" === e.type && e.cursor.end === i.end || this.Clt(),
            i.end = i.start = i.end - 1,
            this.Uli = {
                type: "delete",
                cursor: i
            }) : (this.Clt(),
            i.end = i.start,
            this.Uli = {
                type: "deleteRange",
                cursor: i
            })
        }
        Ccn(t, i, e) {
            t.preventDefault();
            const s = i.pop();
            s && (s(),
            e.push(s))
        }
    }
}
{
    const dE = self.t
      , fE = self.assert
      , pE = [{
        opacity: "1"
    }, {
        opacity: "0"
    }]
      , mE = [{
        transform: "scale(0.85)",
        opacity: "0"
    }, {
        transform: "scale(1)",
        opacity: "1"
    }]
      , wE = [{
        opacity: "0"
    }, {
        opacity: "1"
    }]
      , gE = {
        duration: 100,
        easing: "ease-out"
    }
      , yE = ["top-left", "top", "top-right", "left", "center", "right", "bottom-left", "bottom", "bottom-right"]
      , bE = ["right", "left"]
      , vE = 4
      , SE = {
        Pcn: null,
        className: "",
        id: ""
    };
    let xE = null
      , ME = NaN;
    function EE(t) {
        xE && xE.Gz(t)
    }
    dE.qs.Ek = class extends dE.Me {
        constructor(t, i, e, s) {
            dE.zlt(t),
            dE.cO(i),
            dE.Mw(e, dE.qs.Ek.Gcn),
            dE.Wat(s),
            super(),
            s = Object.assign({}, SE, s),
            this.Acn = t,
            this.Xbi = null,
            this.phs = s.id,
            this.Rcn = s.className,
            this.kcn = s.Pcn || null,
            this.Ocn = !1,
            this.Get = dE.qs.lk("ui-menu"),
            this.Get.setAttribute("role", "menu"),
            this.Rcn && (this.Get.className = this.Rcn),
            this._es = [],
            this.v0e = null,
            this.Dcn = [],
            this.Fcn = null,
            this.xJe = null,
            this.MJe = !1,
            this.Dge = !1,
            this.Vd = !1,
            this.Lcn = e,
            this.G2e = !0,
            this.Bcn(!1),
            this.Ucn = 0,
            this.Ncn = !1,
            this.d6 = 0,
            this.p6 = 0,
            this.jcn = "right",
            this.wJe = null,
            this.agi = dE.kt.mj && window.matchMedia("(max-width: 500px), (max-height: 500px)").matches,
            this.EJe = !1,
            this.$cn = !1,
            this.UJe = null,
            this.agi && this.Get.setAttribute("compact", ""),
            this.hde = t => this.DG(t),
            this.Get.addEventListener("scroll", this.hde, {
                passive: !0
            }),
            this.Get.addEventListener("contextmenu", dE.qs.ck),
            this.XDs = () => dE.qs.Ek.sgi(),
            self.app.addEventListener("projectobjectdelete", this.XDs),
            this.rin = i || (this.agi ? self.app.Gk() : self.app.T_()),
            this.cn = !1
        }
        he() {
            fE(!this.cn, "already released"),
            this.zcn() && this.Vcn() && this.EJe && dE.qs.cqe.Cj(),
            self.app.removeEventListener("projectobjectdelete", this.XDs),
            this.XDs = null,
            this.Wcn(),
            this.xJe && (this.xJe.finish(),
            this.xJe = null);
            for (let t of this._es)
                t.LUt();
            dE.sc(this._es);
            for (let t of this.Dcn)
                dE.qs.BW(t);
            dE.sc(this.Dcn),
            this.Fcn = null,
            this.Get && (this.Get.removeEventListener("scroll", this.hde),
            this.hde = null,
            this.Get.removeEventListener("contextmenu", dE.qs.ck),
            dE.qs.BW(this.Get),
            this.Get = null),
            this.v0e = null,
            this.xJe = null,
            this.Acn = null,
            this.Lcn = null,
            this.cn = !0,
            dE.he(this)
        }
        dn() {
            return this.cn
        }
        hk() {
            return this.Get
        }
        PH() {
            return this.Get.ownerDocument
        }
        jW() {
            return this.PH().defaultView
        }
        vR() {
            return this.phs
        }
        Hcn() {
            return this.Rcn
        }
        Kcn() {
            return this.Fcn || this.Get
        }
        Igs() {
            return this.rin
        }
        qcn() {
            return this.Lcn
        }
        Xcn() {
            if (isNaN(ME)) {
                let t = dE.qs.yQ("padding-top", {
                    vQ: this.Get
                });
                if (!t.endsWith("px"))
                    throw new Error("CSS style for menu padding-top must be in units of 'px'");
                ME = parseFloat(t) || 0
            }
            return ME
        }
        Wp() {
            return this.Vd
        }
        Ycn() {
            return this.Ncn
        }
        DG(t) {
            this.Ncn = !0
        }
        Jcn() {
            this.Ncn = !1
        }
        Zcn() {
            this.Jcn();
            for (let t of this._es) {
                if (!t.Qcn())
                    continue;
                if (!t.tdn())
                    continue;
                let i = t.idn();
                i && i.edn().Zcn()
            }
        }
        u0t() {
            return this._es.length
        }
        JK() {
            return !!this._es.length
        }
        Pk(t, i, e, s) {
            "string" == typeof t && (t = self.app.sdn(t, this.rin)),
            dE.Mw(t, dE.qs.O_),
            dE.zt(i),
            dE.X_t(e),
            dE.Wat(s),
            this.$cn || (this.$cn = !0,
            this.agi && this.Vcn() && this.ndn());
            let n = dE.v(dE.qs.Ek.Gcn, this, t, i, e, s);
            return this._es.push(n),
            this.rdn(),
            n
        }
        Nk() {
            let t = dE.v(dE.qs.Ek.Crn, this);
            return this._es.push(t),
            this.rdn(),
            t
        }
        Uk(t, i, e, s) {
            "string" == typeof t && (t = self.app.sdn(t, this.rin)),
            dE.Mw(t, dE.qs.O_),
            dE.zt(i),
            dE.Wat(e),
            dE.Wat(s);
            let n = this.Pk(t, i, null, e);
            return n.hdn(s),
            n.idn()
        }
        BD() {
            if (!this.zcn()) {
                if (this.odn())
                    throw new Error("already in a group");
                this.Fcn = dE.qs.lk("div", this.hk(), null, "menuitemgroup"),
                this.Dcn.push(this.Fcn)
            }
        }
        MD() {
            if (!this.zcn()) {
                if (!this.odn())
                    throw new Error("not in a group");
                this.Fcn = null
            }
        }
        adn() {
            if (!this.odn())
                throw new Error("not in a group");
            dE.qs.BW(this.Fcn),
            this.Fcn = null,
            this.Dcn.pop()
        }
        odn() {
            return !!this.Fcn
        }
        ndn() {
            this.UJe = dE.wHe.cR( () => this.Cj());
            const t = this.odn();
            t && this.adn(),
            this.Pk(self.app.sdn("close", this.Igs()), self.lang("common.close-menu"), dE.Gv, {
                id: "compact-mode-close-button"
            }),
            this.Nk(),
            t && this.BD()
        }
        ldn(t) {
            dE.qd(t),
            fE(!this.UJe, "already set back stack entry"),
            this.UJe = dE.wHe.cR(t)
        }
        rdn() {
            null !== this.kcn && this._es.length > this.kcn && (this.Ocn = !0)
        }
        nF(t, i, e) {
            if (dE.Ge(t),
            dE.Ge(i),
            dE.cO(e),
            fE(!this.cn, "menu was released"),
            fE(!this.Vd, "showing already active menu"),
            this.Fcn)
                throw new Error("group not finished");
            if (this.Vcn()) {
                dE.qs.Ek.sgi(),
                dE.qs.Jj.QY.sgi(),
                xE = this;
                let e = new Promise(t => this.wJe = t);
                return this.agi && !dE.qs.ySe.Bj() && (this.EJe = !0,
                dE.qs.cqe.Ej(this.Acn)),
                this.udn(t, i),
                this.cdn(),
                this.Xbi.addEventListener("pointerdown", dE.qs.Ek.IW, !0),
                this.Xbi.addEventListener("keydown", dE.qs.Ek.FP),
                this.Xbi.defaultView.addEventListener("resize", dE.qs.Ek.sgi),
                this.Xbi.defaultView.addEventListener("unload", dE.qs.Ek.sgi),
                this.Xbi.addEventListener("pointermove", EE),
                !this.Ocn && this.Get.scrollHeight <= this.Get.offsetHeight && this.Xbi.addEventListener("wheel", dE.qs.Ek.ddn, !0),
                dE.Vl || this.Xbi.defaultView.addEventListener("blur", dE.qs.Ek.sgi),
                e
            }
            this.fdn() && (this.pdn() ? this.qcn().edn().Ycn() && this.udn(t, i, e) : this.udn(t, i, e),
            this.cdn(),
            this.Get.scrollHeight > this.Get.offsetHeight && this.Get.ownerDocument.removeEventListener("wheel", dE.qs.Ek.ddn, !0))
        }
        n_(t="top-left", i=0, e=0, s="right") {
            if (dE.zt(t),
            dE.Ge(i),
            dE.Ge(e),
            dE.zt(s),
            !yE.includes(t))
                throw new Error("invalid alignment");
            if (!bE.includes(s))
                throw new Error("invalid preferred expand direction");
            this.jcn = s;
            const n = this.Acn.getBoundingClientRect();
            switch (t) {
            case "top-left":
                return this.nF(n.left + i, n.top + e);
            case "top":
                return this.nF(n.left + n.width / 2 + i, n.top + e);
            case "top-right":
                return this.nF(n.right + i, n.top + e);
            case "left":
                return this.nF(n.left + i, n.top + n.height / 2 + e);
            case "center":
                return this.nF(n.left + n.width / 2 + i, n.top + n.height / 2 + e);
            case "right":
                return this.nF(n.right + i, n.top + n.height / 2 + e);
            case "bottom-left":
                return this.nF(n.left + i, n.bottom + e);
            case "bottom":
                return this.nF(n.left + n.width / 2 + i, n.bottom + e);
            case "bottom-right":
                return this.nF(n.right + i, n.bottom + e)
            }
        }
        Cj(t) {
            (t || !this.Dge && !this.mdn() && this.Vd) && (this.Vd = !1,
            this.wdn(),
            this.UJe && (this.UJe.he(),
            this.UJe = null),
            this.Vcn() && (xE === this && (xE = null),
            this.EJe && dE.qs.cqe.Cj(),
            this.Xbi && (this.Xbi.removeEventListener("pointerdown", dE.qs.Ek.IW, !0),
            this.Xbi.removeEventListener("keydown", dE.qs.Ek.FP),
            this.Xbi.removeEventListener("wheel", dE.qs.Ek.ddn, !0),
            this.Xbi.defaultView.removeEventListener("resize", dE.qs.Ek.sgi),
            this.Xbi.defaultView.removeEventListener("unload", dE.qs.Ek.sgi),
            this.Xbi.removeEventListener("pointermove", EE),
            dE.Vl || this.Xbi.defaultView.removeEventListener("blur", dE.qs.Ek.sgi)),
            this.Wcn()),
            this.Xbi = null,
            this.gdn())
        }
        Wcn() {
            this.wJe && (this.wJe(),
            this.wJe = null)
        }
        uH(t, i) {
            if (dE.Ge(t),
            dE.Ge(i),
            fE(!this.cn, "menu was released"),
            this.Dge || !this.Vd || this.mdn())
                return !1;
            let e = this.v0e;
            return e ? t >= e.left && i >= e.top && t < e.right && i < e.bottom : void 0
        }
        udn(t, i, e) {
            if (this.Xbi = this.Acn.ownerDocument,
            this.agi || (this.Get.style.left = "0px",
            this.Get.style.top = "0px",
            this.Get.style.width = "",
            this.Get.style.height = ""),
            !this.pdn()) {
                let t = this.Xbi.body;
                dE.qs.ySe.Bj() && (t = dE.qs.ySe.bSe()),
                t.appendChild(this.Get);
                let i = dE.Edi(this.Acn, "dialog");
                if (i && !dE.qs.ySe.Bj()) {
                    dE.qs.BW(this.Get),
                    i.appendChild(this.Get);
                    let t = dE.qs.Ys.lZe(i);
                    t && !t.NBi() && (this.d6 = t.byi(),
                    this.p6 = t.yyi())
                }
            }
            if (this.agi)
                return void (this.v0e = this.Get.getBoundingClientRect());
            let s = this.Get.getBoundingClientRect()
              , n = s.right - s.left
              , r = s.bottom - s.top;
            if (this.Ocn && this._es.length) {
                let t = this._es[this.kcn - 1].ydn();
                r = t.top - s.top,
                this.Get.style.maxHeight = t.top - s.top + "px",
                this.Get.style.overflowY = "scroll"
            }
            let h = ""
              , o = ""
              , a = this.Xbi.defaultView.innerWidth
              , l = this.Xbi.defaultView.innerHeight
              , u = 0;
            if (this.Lcn) {
                let t = this.Lcn.ydn();
                u = t.right - t.left
            }
            const c = t - (n + u) >= 0;
            if (!(t + n + vE <= a) || c && "right" !== this.jcn)
                if (c)
                    t -= n + u,
                    h = "100%";
                else {
                    t - u > a - t ? (t = 0,
                    dE.kt.mj && (i = e),
                    h = "100%") : (t = a - n,
                    h = "0%")
                }
            else
                h = "0%";
            let d = "number" == typeof e ? e : i;
            i + r + vE <= l ? o = "0%" : d - r >= 0 ? (i = d - r,
            o = "100%") : (o = 100 * i / l + "%",
            i = 0,
            this.Get.style.height = Math.min(r, l - 5) + "px"),
            this.Get.style.transformOrigin = `${h} ${o}`;
            const f = dE.IOt(t - this.d6)
              , p = dE.IOt(i - this.p6);
            this.Get.style.left = `${f}px`,
            this.Get.style.top = `${p}px`,
            "DIALOG" === this.bdn().tagName && (this.Get.style.width = `${n}px`)
        }
        cdn() {
            fE(!this.cn, "menu was released"),
            fE(!this.MJe, "already fading in"),
            this.Dge && this.xJe && (this.Dge = !1,
            this.xJe.onfinish = null,
            this.xJe.finish(),
            this.xJe = null),
            this.MJe = !0,
            this.Vd = !0,
            this.mdn() ? (this.Bcn(!0),
            this.V4e(this.agi ? wE : mE, gE)) : this.PZe()
        }
        gdn() {
            fE(!this.Dge, "already animating out"),
            fE(xE !== this, "should not be current menu"),
            dE.dn(this) || this.cn || (this.Dge = !0,
            this.MJe && (this.MJe = !1,
            this.xJe) ? this.xJe.reverse() : this.vdn() ? this.V4e(pE, gE) : this.PZe())
        }
        V4e(t, i) {
            self.app.zmt() ? (fE(!this.xJe, "already animating"),
            this.xJe = this.Get.animate(t, i),
            this.xJe.onfinish = t => this.PZe()) : this.PZe()
        }
        PZe() {
            if (dE.dn(this) || this.cn)
                return;
            let t = !1;
            this.Dge && (fE(xE !== this, "should not be current menu"),
            this.Vcn() && (t = !0),
            this.fdn() && this.Bcn(!1)),
            this.MJe && (this.v0e = this.Get.getBoundingClientRect()),
            this.MJe = !1,
            this.Dge = !1,
            this.xJe = null,
            t && this.he()
        }
        Sdn(t) {
            dE.Mw(t, dE.qs.Ek.Gcn);
            for (let i of this._es)
                i.Dwt(i === t)
        }
        wdn() {
            for (let t of this._es) {
                if (!t.Qcn())
                    continue;
                let i = t.idn();
                i && i.edn().Cj()
            }
        }
        xdn() {
            for (let t of this._es) {
                if (!t.Qcn())
                    continue;
                let i = t.idn();
                i && i.edn().he()
            }
        }
        Mdn(t, i, e=!1) {
            for (let s of this._es) {
                if (!s.Qcn())
                    continue;
                let n = s.idn();
                if (n) {
                    if (n.Edn().uH(t, i, e))
                        return !0;
                    if (n.edn().Cdn(t, i, e))
                        return !0
                }
            }
            return !1
        }
        Cdn(t, i, e=!1) {
            return this.uH(t, i, e) || this.Mdn(t, i, e)
        }
        Bcn(t) {
            if (t = !!t,
            this.G2e !== t && (this.G2e = t,
            this.Get.setAttribute("visible", this.G2e ? "true" : "false"),
            !this.G2e))
                for (let t of this._es)
                    t.Dwt(!1)
        }
        _dn() {
            return this.Dge
        }
        Ort() {
            return this.Vd
        }
        mdn() {
            return !this.G2e
        }
        vdn() {
            return this.G2e
        }
        fdn() {
            return !!this.Lcn
        }
        Vcn() {
            return !this.Lcn
        }
        zcn() {
            return this.agi
        }
        Tdn(t) {
            this.agi && (this.Vd = !!t,
            this.Bcn(this.Vd))
        }
        Idn() {
            return this.Get.scrollHeight > this.Get.clientHeight
        }
        pdn() {
            return !!this.Get.parentNode
        }
        bdn() {
            return this.Get.parentNode
        }
        static X1() {
            return !!xE
        }
        static sgi(t) {
            xE && (!t || "blur" !== t.type && "unload" !== t.type ? (fE(!xE.dn(), "menu was released"),
            xE.Cj(xE.zcn()),
            xE = null) : dE.qs.Ek.RZe())
        }
        static RZe() {
            xE && (fE(!xE.dn(), "menu was released"),
            xE.xdn(),
            xE.he(),
            xE = null)
        }
        static rXi(t) {
            return dE.zlt(t),
            dE.jgt(t, ["ui-menu"])
        }
        static DTi(t, i, e) {
            return !!xE && (fE(!xE.dn(), "menu was released"),
            (!e || xE.jW() === e) && xE.Cdn(t, i))
        }
        static IW(t) {
            xE && (fE(!xE.dn(), "menu was released"),
            xE.Zcn(),
            xE.Cdn(t.clientX, t.clientY) || (xE.zcn() && (t.stopPropagation(),
            t.preventDefault()),
            dE.qs.Ek.sgi()))
        }
        Gz(t) {
            if (this.dn())
                return;
            const i = dE.qs.Ek.Pdn(this, []).reverse();
            let e = !1
              , s = !1;
            for (const n of i) {
                for (let i of n._es) {
                    if (!i.Qcn())
                        continue;
                    i.Gz(t);
                    let n = i.idn();
                    n && n.Gdn(t),
                    s || n && n.JK() && n.Gz(t) && (e = !0)
                }
                e && (s = !0)
            }
        }
        static Pdn(t, i) {
            dE.U(t, dE.qs.Ek),
            dE._D(i),
            i.push(t);
            for (const e of t._es) {
                if (!e.Qcn() || !e.tdn())
                    continue;
                const t = e.idn();
                t.JK() && this.Pdn(t.edn(), i)
            }
            return i
        }
        static FP(t) {
            xE && t.which === dE.kE.IE && dE.qs.Ek.sgi()
        }
        static ddn(t) {
            dE.qs.Ek.X1() && (t.preventDefault(),
            t.stopPropagation())
        }
        Adn(t) {
            return dE.qs.Rdn.Adn(this.vR(), t)
        }
    }
}
{
    const CE = self.t
      , _E = 16
      , TE = 25
      , IE = {
        Ck: !1,
        bold: !1,
        Dk: "",
        Wj: !1,
        kdn: !1,
        id: ""
    };
    let PE = 0;
    CE.qs.Ek.Gcn = class extends CE.Me {
        constructor(t, i, e, s, n) {
            if (CE.U(t, CE.qs.Ek),
            CE.Mw(i, CE.qs.O_),
            CE.zt(e),
            CE.X_t(s),
            CE.Wat(n),
            n = Object.assign({}, IE, n),
            CE.zt(n.Dk),
            super(),
            this.Odn = t,
            this.Ddn = null,
            this.Get = CE.qs.lk("ui-menuitem", this.Odn.Kcn()),
            this.Get.setAttribute("role", "menuitem"),
            this.v0e = null,
            this.wpt = !1,
            this.phs = n.id,
            this.C1 = this.iN().Adn(this.phs),
            this.f7i = 0,
            this.d7i = 0,
            this.Fdn = !1,
            this.Ldn = !0,
            this.wat = null,
            this._6e = null,
            i) {
                this.wat = CE.v(CE.qs.kmt, {
                    icon: i,
                    r6e: n.Wj
                }, this.Get);
                let t = i.RGe();
                t && t.pat().then(t => {
                    this.wat && (this.wat.g6e(t),
                    this.wat = null,
                    this._6e = t)
                }
                )
            } else
                this.wat = CE.v(CE.qs.kmt, this.Odn.Igs(), this.Get);
            this.Bdn = CE.qs.lk("span", this.Get, null, "menu-item-text"),
            this.Bdn.textContent = e,
            this.B6s = s,
            this.Udn = !!n.Ck,
            this.Ndn = !!n.kdn,
            n.bold && this.Get.setAttribute("bold", ""),
            n.Dk && this.Get.setAttribute("title", n.Dk),
            this.C1 || this.Get.setAttribute("disabled", ""),
            this.l1 = t => this.IW(t),
            this.Get.addEventListener("pointerdown", this.l1),
            this.Oz = t => this.Cz(t),
            this.Get.addEventListener("pointerup", this.Oz, !0),
            this.N9e = t => this.b2(t),
            this.Get.addEventListener("pointercancel", this.N9e, !0),
            this.jdn = null,
            this.$dn = new Promise( (t, i) => {
                this.jdn = t
            }
            ),
            this.zdn = !1,
            this.Vdn = t => this.OW(t),
            this.Get.addEventListener("contextmenu", this.Vdn, !0),
            this.C1 && CE.qs.Rdn.Wdn() && "help" !== this.phs && this.Get.classList.add("highlight")
        }
        LUt() {
            this.Ddn && (this.Ddn.he(),
            this.Ddn = null),
            this.wat && (this.wat.he(),
            this.wat = null),
            CE.qs.BW(this._6e),
            this._6e = null,
            this.Bdn && (CE.qs.BW(this.Bdn),
            this.Bdn = null),
            this.Get && (this.Get.removeEventListener("contextmenu", this.Vdn, !0),
            this.Get.removeEventListener("pointerup", this.Oz, !0),
            this.Oz = null,
            this.Get.removeEventListener("pointerdown", this.l1),
            this.l1 = null,
            CE.qs.BW(this.Get),
            this.Get = null),
            this.jdn = null,
            this.$dn = null,
            this.Odn = null,
            this.B6s = null,
            this.v0e = null,
            CE.he(this)
        }
        hk() {
            return this.Get
        }
        idn() {
            return this.Ddn
        }
        edn() {
            return this.Odn
        }
        vR() {
            return this.phs
        }
        iN() {
            let t = this.edn();
            do {
                if (t.Vcn())
                    return t;
                t = t.qcn().edn()
            } while (t);
            throw new Error("unable to get root menu")
        }
        Qcn() {
            return !0
        }
        tdn() {
            return !!this.idn()
        }
        ydn(t) {
            return (t = !!t) ? (this.v0e = this.Get.getBoundingClientRect(),
            this.v0e) : (this.v0e || (this.v0e = this.Get.getBoundingClientRect()),
            this.v0e)
        }
        hdn(t) {
            CE.Wat(t),
            this.Ddn || (self.assert(!this.B6s, "submenu items should not have a callback function"),
            t = Object.assign({
                className: this.Odn.Hcn()
            }, t),
            this.Ddn = CE.v(CE.qs.Ek.Hdn, this, this.Odn.Igs(), t))
        }
        Kdn(t) {}
        qdn(t) {}
        IW(t) {
            this.Odn.Wp() && this.C1 && (t.button !== CE.f1.DOt || this.iN().zcn() ? this.zdn = !1 : this.zdn = !0,
            this.Odn.Idn() || (t.preventDefault(),
            t.stopPropagation()),
            this.f7i = t.clientX,
            this.d7i = t.clientY,
            "mouse" !== t.pointerType && this.Odn.Sdn(this))
        }
        Gz(t) {
            if (CE.dn(this))
                return;
            if (this.iN().zcn())
                return;
            let i = this.Ldn || this.Odn.Ycn()
              , e = this.uH(t.clientX, t.clientY, i);
            !this.Fdn && e ? (this.Fdn = !0,
            this.Ldn = !1,
            this.Kdn(t)) : this.Fdn && !e && (this.Fdn = !1,
            this.qdn(t))
        }
        Cz(t) {
            if (!this.Odn.Wp() || !this.C1)
                return;
            if (t.preventDefault(),
            t.button === CE.f1.c1)
                return;
            const i = "mouse" !== t.pointerType;
            if (i) {
                let i = this.edn();
                if (!this.uH(t.clientX, t.clientY))
                    return void i.Sdn(null);
                if (i.Ycn())
                    return void i.Sdn(null)
            }
            if (this.tdn())
                return void (this.Ddn.Wp() && !i || this.Odn.wdn());
            let e = t.clientX
              , s = t.clientY;
            if (CE.di(this.f7i, this.d7i, e, s) >= TE)
                return void this.Odn.Sdn(null);
            const n = this.B6s;
            n && (this.Udn ? (n(),
            CE.qs.Rdn.Xdn("menuitemchosen", this)) : (PE++,
            PE > 1 || (window.addEventListener("keydown", CE.qs.ck, !0),
            window.addEventListener("keyup", CE.qs.ck, !0),
            window.addEventListener("keypress", CE.qs.ck, !0)),
            window.setTimeout( () => {
                PE--,
                PE > 0 || (window.removeEventListener("keydown", CE.qs.ck, !0),
                window.removeEventListener("keyup", CE.qs.ck, !0),
                window.removeEventListener("keypress", CE.qs.ck, !0)),
                n(),
                CE.qs.Rdn.Xdn("menuitemchosen", this)
            }
            , _E))),
            this.Ndn || (this.zdn ? this.$dn.then( () => {
                CE.qs.Ek.sgi()
            }
            ) : CE.qs.Ek.sgi())
        }
        b2(t) {
            this.Fdn = !1,
            this.zdn = !1,
            this.Odn.Sdn(null)
        }
        OW(t) {
            t.preventDefault(),
            t.stopPropagation(),
            this.jdn()
        }
        uH(t, i, e) {
            CE.Ge(t),
            CE.Ge(i);
            let s = this.edn();
            return !(s._dn() || !s.Ort() || s.mdn()) && (e = !!e,
            this.v0e = this.ydn(e),
            t >= this.v0e.left && i >= this.v0e.top && t < this.v0e.right && i < this.v0e.bottom)
        }
        Dwt(t) {
            (t = !!t) && !this.wpt ? this.Get.setAttribute("selected", "") : !t && this.wpt && this.Get.removeAttribute("selected"),
            this.wpt = t
        }
    }
}
{
    const GE = self.t;
    GE.qs.Ek.Crn = class extends GE.Me {
        constructor(t) {
            GE.U(t, GE.qs.Ek),
            super(),
            this.Odn = t,
            this.Get = GE.qs.lk("ui-menuseparator", this.Odn.hk()),
            this.Get.setAttribute("role", "separator")
        }
        LUt() {
            GE.qs.BW(this.Get),
            this.Get = null,
            this.Odn = null,
            GE.he(this)
        }
        Qcn() {
            return !1
        }
        Dwt(t) {}
    }
}
{
    const AE = self.t
      , RE = 300
      , kE = 500;
    AE.qs.Ek.Hdn = class extends AE.Me {
        constructor(t, i, e) {
            AE.U(t, AE.qs.Ek.Gcn),
            AE.cO(i),
            AE.Wat(e),
            super(),
            this.Ydn = t,
            this.rin = i,
            this.Acn = this.Ydn.hk(),
            this.wat = null,
            this._6e = null,
            this.Jdn = !1,
            this.Zdn = !1,
            this.Qdn = !1,
            this.tfn = !1,
            this.ifn = !1,
            this.efn = !0,
            this.sfn = -1,
            this.nfn = -1,
            this.U6s = 0,
            this.BDe = 0,
            this.UDe = 0,
            this.Acn.setAttribute("sub-menu", "empty"),
            this.rfn = -1,
            this.Yan = -1,
            this.Oz = t => this.Cz(t),
            this.N9e = t => this.b2(t),
            this.l1 = t => this.IW(t),
            this.UJe = null,
            this.Odn = AE.v(AE.qs.Ek, this.Acn, this.rin, this.Ydn, e)
        }
        he() {
            this.hfn(),
            this.ofn(),
            this.Acn.removeEventListener("pointerup", this.Oz),
            this.Acn.removeEventListener("pointercancel", this.N9e),
            this.Acn.removeEventListener("pointerdown", this.l1),
            this.Acn.removeEventListener("contextmenu", AE.qs.ck, !0),
            this.wat && (this.wat.he(),
            this.wat = null),
            AE.qs.BW(this._6e),
            this._6e = null,
            this.Odn && !AE.dn(this.Odn) && this.Odn.hk() && this.Odn.he(),
            this.Odn = null,
            this.Oz = null,
            this.N9e = null,
            this.l1 = null,
            this.Acn = null,
            this.Ydn = null,
            AE.he(this)
        }
        edn() {
            return this.Odn
        }
        Edn() {
            return this.Ydn
        }
        JK() {
            return this.Jdn
        }
        iN() {
            let t = this.Ydn.edn();
            do {
                if (t.Vcn())
                    return t;
                t = t.qcn().edn()
            } while (t);
            throw new Error("unable to get root menu")
        }
        Pk(t, i, e, s) {
            return this.afn(),
            this.edn().Pk(t, i, e, s)
        }
        Nk() {
            return this.afn(),
            this.edn().Nk()
        }
        Uk(t, i, e) {
            return this.afn(),
            this.edn().Uk(t, i)
        }
        BD() {
            this.edn().BD()
        }
        MD() {
            this.edn().MD()
        }
        odn() {
            this.edn().odn()
        }
        IW(t) {
            this.Zdn = !1,
            this.Qdn = !1
        }
        b2(t) {
            this.tfn = !1,
            this.ifn = !1,
            this.hfn(),
            this.ofn(),
            this.Ydn.edn().Sdn(null)
        }
        Cz(t) {
            const i = "mouse" !== t.pointerType;
            if (!(i && this.Odn._dn() || t.button === AE.f1.c1)) {
                if (i) {
                    let i = this.Ydn.edn();
                    if (!this.Ydn.uH(t.clientX, t.clientY))
                        return void i.Sdn(null);
                    if (this.iN().zcn() && (this.Zdn || this.Qdn))
                        return void i.Sdn(null);
                    if (i.Ycn())
                        return void i.Sdn(null)
                }
                this.lfn()
            }
        }
        Kdn(t) {
            this.hfn(),
            this.ofn(),
            this.rfn = setTimeout( () => {
                this.ufn()
            }
            , RE)
        }
        qdn() {
            this.tfn = !1,
            this.ifn = !1,
            this.hfn(),
            this.ofn(),
            this.Yan = setTimeout( () => {
                this.cfn(this.sfn, this.nfn)
            }
            , kE)
        }
        Gz(t) {
            if (AE.dn(this))
                return;
            let i = this.efn || !this.Odn.Ycn()
              , e = !1
              , s = this.Ydn.uH(this.sfn, this.nfn, i);
            return s && (e = s),
            !this.tfn && s ? (this.tfn = !0,
            this.efn = !1,
            this.iN().zcn() || this.Kdn(t)) : this.tfn && !s && (this.tfn = !1,
            this.iN().zcn() ? this.Zdn = !0 : this.qdn(t)),
            s = this.Odn.uH(this.sfn, this.nfn),
            s && (e = s),
            !this.ifn && s ? this.ifn = !0 : this.ifn && !s && (this.ifn = !1,
            this.iN().zcn() ? this.Qdn = !0 : this.qdn(t)),
            e
        }
        Gdn(t) {
            this.sfn = t.clientX,
            this.nfn = t.clientY
        }
        hfn() {
            -1 !== this.rfn && (clearTimeout(this.rfn),
            this.rfn = -1)
        }
        ofn() {
            -1 !== this.Yan && (clearTimeout(this.Yan),
            this.Yan = -1)
        }
        Wp() {
            return this.edn().Wp()
        }
        lfn() {
            this.Ydn.edn().Tdn(!1);
            let t = this.Ydn.edn();
            const i = this.iN().zcn()
              , e = t._dn()
              , s = t.mdn()
              , n = t.Wp();
            if (!i && (e || s || !n))
                return;
            let r = this.edn();
            if (!r.Wp()) {
                if (this.hfn(),
                this.ofn(),
                0 === this.U6s && 0 === this.BDe && 0 === this.UDe) {
                    let i = t.Xcn()
                      , e = this.Ydn.ydn(!0);
                    this.U6s = e.left + e.width,
                    this.BDe = e.top - i,
                    this.UDe = e.bottom + i
                } else if (t.Ycn()) {
                    let i = t.Xcn()
                      , e = this.Ydn.ydn(!0);
                    this.U6s = e.left + e.width,
                    this.BDe = e.top - i,
                    this.UDe = e.bottom + i
                }
                r.nF(this.U6s, this.BDe, this.UDe),
                i && r.ldn( () => this.dfn())
            }
        }
        ufn() {
            this.rfn = -1,
            this.edn().Wp() || (this.Ydn.edn().wdn(),
            this.lfn())
        }
        cfn(t, i) {
            AE.Ge(t),
            AE.Ge(i),
            this.Yan = -1;
            const e = this.edn();
            e.Wp() && !e.Cdn(t, i) && e.Cj()
        }
        afn() {
            if (!this.Jdn) {
                this.Acn.setAttribute("sub-menu", "full");
                let t = self.app.oi("menu-submenu");
                this.wat = AE.v(AE.qs.kmt, t, this.Acn);
                let i = t.RGe();
                i && i.pat().then(t => {
                    this.wat && (this.wat.g6e(t),
                    this.wat = null,
                    this._6e = t)
                }
                ),
                this.Acn.addEventListener("pointerup", this.Oz),
                this.Acn.addEventListener("pointercancel", this.N9e),
                this.Acn.addEventListener("pointerdown", this.l1),
                this.Acn.addEventListener("contextmenu", AE.qs.ck, !0),
                this.Jdn = !0;
                const e = this.iN();
                if (e.zcn()) {
                    const t = this.edn()
                      , i = t.odn();
                    i && t.adn(),
                    t.Pk(self.app.sdn("back", e.Igs()), self.lang("common.back"), () => this.dfn(), {
                        kdn: !0,
                        id: "compact-mode-back-button"
                    }),
                    t.Nk(),
                    i && t.BD()
                }
            }
        }
        dfn() {
            this.Ydn && (this.Ydn.edn().Tdn(!0),
            this.Odn.Cj())
        }
    }
}
{
    const OE = self.t
      , DE = OE.v(OE.Event.aG)
      , FE = new Map;
    OE.qs.Rdn = class {
        constructor() {
            throw new TypeError("static class can't be instantiated")
        }
        static Xdn(t, i) {
            OE.zt(t),
            OE.Mw(i, OE.qs.Ek.Gcn);
            const e = new OE.Event(t);
            e.ffn = i,
            this.dispatchEvent(e)
        }
        static addEventListener(t, i, e) {
            DE.addEventListener(t, i, e)
        }
        static removeEventListener(t, i, e) {
            DE.removeEventListener(t, i, e)
        }
        static dispatchEvent(t) {
            return DE.dispatchEvent(t)
        }
        static pfn(t) {
            return OE.qs.Rdn.mfn(t, "menuitemchosen")
        }
        static mfn(t, i) {
            return OE._D(t),
            OE.zt(i),
            new Promise(e => {
                const s = n => {
                    t.includes(n.ffn.vR()) && (OE.qs.Rdn.removeEventListener(i, s),
                    e(n.ffn))
                }
                ;
                OE.qs.Rdn.addEventListener(i, s)
            }
            )
        }
        static wfn(t) {
            OE._D(t),
            FE.clear();
            for (const [i,e] of t)
                OE.zt(i),
                OE._D(e),
                FE.set(i, new Set(e))
        }
        static gfn() {
            FE.clear()
        }
        static Adn(t, i) {
            if (0 === FE.size)
                return !0;
            if ("compact-mode-close-button" === i || "compact-mode-back-button" === i)
                return !0;
            const e = FE.get(t);
            return !!e && e.has(i)
        }
        static Wdn() {
            return FE.size > 0
        }
    }
}
{
    const LE = self.t
      , BE = self.assert;
    function UE(t, i) {
        return !!t == !!i
    }
    LE.qs.yfn = class {
        constructor(...t) {
            if (t.length < 2)
                throw new Error("missing arguments");
            this.B6s = null,
            this.dat = "",
            this.bfn = t.at(-2),
            this.vfn = !1,
            this.Sfn = !1,
            this.xfn = !1,
            this.gUi = !1,
            this.Mfn = !1,
            this.Efn = !1,
            this.Cfn = !1;
            let i = [];
            for (let e = 0, s = t.length - 2; e < s; ++e) {
                let s = t[e];
                if (LE.zt(s),
                i.includes(s))
                    throw new Error("duplicate modifier");
                switch (i.push(s),
                s) {
                case "ctrl":
                    this.vfn = !0;
                    break;
                case "shift":
                    this.Sfn = !0;
                    break;
                case "alt":
                    this.xfn = !0;
                    break;
                case "meta":
                    this.gUi = !0;
                    break;
                case "alt-gr":
                    this.Mfn = !0;
                    break;
                default:
                    throw new Error("invalid modifier")
                }
            }
            let e = t.at(-1);
            if ("function" == typeof e)
                this.B6s = e;
            else {
                if ("string" != typeof e)
                    throw new TypeError("expected function or string");
                this.dat = e
            }
            BE(LE.Go(this.bfn) || LE.doe(this.bfn), "key must be a number or a string")
        }
        _fn() {
            return this.Efn = !0,
            this
        }
        Tfn() {
            return this.Efn
        }
        Ifn() {
            return this.Cfn = !0,
            this
        }
        Pfn() {
            return this.Cfn
        }
        eas(t) {
            return this.Mfn && t.getModifierState("AltGraph") ? (BE(!this.vfn, "alt-gr can not be pressed together with ctrl"),
            BE(!this.xfn, "alt-gr can not be pressed together with alt"),
            !!LE.kE.Zct(t.key, this.bfn) && (UE(t.shiftKey, this.Sfn) && UE(t.metaKey, this.gUi))) : !!LE.kE.Zct(t.which, this.bfn) && (UE(t.ctrlKey, this.vfn) && UE(t.shiftKey, this.Sfn) && UE(t.altKey, this.xfn) && UE(t.metaKey, this.gUi))
        }
        Gfn(t) {
            if (this.B6s)
                return this.B6s(t),
                !0;
            {
                let t = LE.qs.iA.RA();
                return !!t && t.TP(this.dat)
            }
        }
    }
}
{
    const NE = self.t;
    NE.qs.Afn = class {
        constructor(t) {
            this.yAe = t,
            this.Rfn = [],
            this.kfn = window.C3_IsPopupWindow,
            this.Ofn = !0,
            window.addEventListener("keydown", t => this.FP(t, !1)),
            this.kfn && (window.addEventListener("keyup", t => this.Pz(t)),
            window.addEventListener("keypress", t => this.sNt(t))),
            t.addEventListener("external-keyboard-shortcut", t => this.FP(t.Rst, !0))
        }
        Dfn(t) {
            NE.YJ(t, NE.qs.yfn),
            NE.bp(this.Rfn, t)
        }
        Ffn() {
            this.Ofn = !1
        }
        FP(t, i) {
            const e = NE.Lat();
            for (const s of this.Rfn)
                if ((!e || s.Tfn()) && (!self.app.aj() || s.Pfn()) && s.eas(t)) {
                    if (this.kfn)
                        t.preventDefault(),
                        window.opener.postMessage({
                            type: "popup-keyboard-shortcut",
                            event: {
                                key: t.key,
                                keyCode: t.keyCode,
                                keyIdentifier: t.keyIdentifier,
                                keyLocation: t.keyLocation,
                                code: t.code,
                                location: t.location,
                                char: t.char,
                                charCode: t.charCode,
                                which: t.which,
                                ctrlKey: t.ctrlKey,
                                shiftKey: t.shiftKey,
                                altKey: t.altKey,
                                metaKey: t.metaKey,
                                repeat: t.repeat,
                                isComposing: t.isComposing
                            }
                        }, location.origin);
                    else {
                        this.Ofn = !0;
                        const e = s.Gfn(this.yAe);
                        i && (t.SYe = e),
                        NE.qs.Ek.sgi(),
                        e && !i && this.Ofn && t.preventDefault()
                    }
                    return
                }
            this.kfn && !e && window.opener.postMessage({
                type: "popup-keydown",
                event: {
                    key: t.key,
                    keyCode: t.keyCode,
                    keyIdentifier: t.keyIdentifier,
                    keyLocation: t.keyLocation,
                    code: t.code,
                    location: t.location,
                    char: t.char,
                    charCode: t.charCode,
                    which: t.which,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    altKey: t.altKey,
                    metaKey: t.metaKey,
                    repeat: t.repeat,
                    isComposing: t.isComposing
                }
            }, location.origin)
        }
        Pz(t) {
            NE.Lat() || window.opener.postMessage({
                type: "popup-keyup",
                event: {
                    key: t.key,
                    keyCode: t.keyCode,
                    keyIdentifier: t.keyIdentifier,
                    keyLocation: t.keyLocation,
                    code: t.code,
                    location: t.location,
                    char: t.char,
                    charCode: t.charCode,
                    which: t.which,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    altKey: t.altKey,
                    metaKey: t.metaKey,
                    repeat: t.repeat,
                    isComposing: t.isComposing
                }
            }, location.origin)
        }
        sNt(t) {
            NE.Lat() || window.opener.postMessage({
                type: "popup-keypress",
                event: {
                    key: t.key,
                    keyCode: t.keyCode,
                    keyIdentifier: t.keyIdentifier,
                    keyLocation: t.keyLocation,
                    code: t.code,
                    location: t.location,
                    char: t.char,
                    charCode: t.charCode,
                    which: t.which,
                    ctrlKey: t.ctrlKey,
                    shiftKey: t.shiftKey,
                    altKey: t.altKey,
                    metaKey: t.metaKey,
                    repeat: t.repeat,
                    isComposing: t.isComposing
                }
            }, location.origin)
        }
    }
}
{
    const jE = self.t;
    jE.Lfn = class extends jE.Me {
        constructor(t, i) {
            super(),
            jE.U(t, jE.PW.constructor),
            jE.zt(i),
            this.VYi = t,
            this.rVt = i,
            this.Bfn = `@font-face {\n\t\t\tfont-family: '${this.rVt}';\n\t\t\tsrc: `,
            this.Ufn = null,
            this.Nfn = "",
            this.jfn = [],
            this.$fn = null
        }
        Fa() {
            return this.rVt
        }
        CXe(t, i, e, s) {
            jE.U(t, Blob),
            jE.zt(i),
            jE.zt(e);
            let n = URL.createObjectURL(t);
            this.jfn.push(n),
            this.Bfn += `url('${n}')`;
            let r = jE.PW.zfn(i, e);
            r && (this.Bfn += ` format('${r}')`),
            this.Bfn += s ? ";\n}" : ", "
        }
        async Vfn() {
            return this.Ufn = new Blob([this.Bfn],{
                type: "text/css"
            }),
            this.Nfn = URL.createObjectURL(this.Ufn),
            this.$fn = await jE.dOe(this.Nfn),
            this.$fn.setAttribute("data-comment", "webfont-" + this.rVt),
            void 0 !== document.fonts && "function" == typeof document.fonts.load && await document.fonts.load("1em '" + this.rVt + "'"),
            jE.PW.Wfn(this),
            this
        }
        he() {
            if (this.VYi) {
                this.VYi.Hfn(this),
                this.VYi = null;
                for (let t of this.jfn)
                    URL.revokeObjectURL(t);
                jE.sc(this.jfn),
                this.Nfn && (URL.revokeObjectURL(this.Nfn),
                this.Nfn = ""),
                this.Ufn = null,
                jE.qs.BW(this.$fn),
                this.$fn = null
            }
        }
    }
}
{
    const $E = self.t;
    class zE extends $E.Event.aG {
        constructor() {
            super(),
            this.Kfn = new Map
        }
        SIt(t, i, e, s) {
            if ($E.zt(t),
            $E.zt(i),
            $E.zt(e),
            $E.U(s, Blob),
            this.Kfn.has(t.toLowerCase()))
                return Promise.resolve(this.Kfn.get(t.toLowerCase()));
            const n = $E.v($E.Lfn, this, t);
            return n.CXe(s, i.toLowerCase(), e.toLowerCase(), !0),
            this.Kfn.set(t.toLowerCase(), n),
            n.Vfn()
        }
        Hfn(t) {
            $E.U(t, $E.Lfn),
            this.Kfn.delete(t.Fa().toLowerCase())
        }
        Wfn(t) {
            $E.U(t, $E.Lfn);
            let i = new $E.Event("fontload");
            i.font = t,
            this.dispatchEvent(i)
        }
        zfn(t, i) {
            return $E.zt(t),
            $E.zt(i),
            t = t.toLowerCase(),
            i = i.toLowerCase(),
            "application/font-woff" === t || i.endsWith("woff") ? "woff" : "font/woff2" === t || i.endsWith("woff2") ? "woff2" : "application/vnd.ms-fontobject" === t || i.endsWith("eot") ? "embedded-opentype" : i.endsWith("ttf") ? "truetype" : i.endsWith("otf") ? "opentype" : ""
        }
    }
    $E.PW = $E.v(zE)
}
{
    const VE = self.t;
    VE.qs.HY.addEventListener("showmodal", t => {
        t.nWt.M6i() && !t.nWt.Fwt() || VE.qs.Xfn.qfn()
    }
    ),
    VE.qs.HY.addEventListener("hidemodal", t => {
        t.nWt.M6i() && !t.nWt.Fwt() || VE.qs.Xfn.he()
    }
    ),
    VE.qs.Xfn = class {
        constructor() {}
        static he() {
            for (let t of this.Yfn.values()) {
                for (let i of t)
                    i.LUt(!1);
                VE.sc(t)
            }
        }
        static Jfn(t) {
            VE.U(t, VE.qs.Notification);
            let i = this.Yfn.get(t.Zfn());
            i.unshift(t);
            for (let t = 0; t < i.length; t++)
                i[t].Qfn(t);
            if (i.length >= this.tpn + 1) {
                let t = i.at(-1);
                this.ipn(t),
                t.Kan()
            }
        }
        static epn(t) {
            VE.U(t, VE.qs.Notification),
            this.ipn(t)
        }
        static spn(t) {
            VE.U(t, VE.qs.Notification);
            let i = this.Yfn.get(t.Zfn());
            for (let t = 0; t < i.length; t++) {
                let e = i[t];
                e.ofn(),
                t === i.length - 1 && e.npn()
            }
        }
        static qfn() {
            for (let t of this.Yfn.values())
                for (let i of t)
                    i.Kan()
        }
        static rpn(t) {
            VE.U(t, VE.qs.Notification);
            let i = this.Yfn.get(t.Zfn())
              , e = i.indexOf(t);
            if (e > 0) {
                let t = 0;
                for (var s = e - 1; s >= 0; s--)
                    t += i[s].Zie();
                return t
            }
            return 0
        }
        static ipn(t) {
            VE.U(t, VE.qs.Notification);
            let i = this.Yfn.get(t.Zfn())
              , e = i.indexOf(t);
            -1 !== e && i.splice(e, 1),
            i.length && this.spn(i[0])
        }
    }
    ,
    VE.qs.Xfn.Yfn = new Map([["top-left", []], ["top-right", []], ["bottom-left", []], ["bottom-right", []]]),
    VE.qs.Xfn.tpn = 4
}
{
    const WE = self.t
      , HE = new Set(["top-left", "top-right", "bottom-left", "bottom-right"])
      , KE = 5
      , qE = 5e3
      , XE = {
        align: "top-right",
        z7t: 1300,
        C6i: !1,
        onclick: null
    }
      , YE = {};
    WE.qs.Notification = class extends WE.Event.aG {
        constructor(t, i, e, s, n) {
            if (WE.u7t(i),
            WE.u7t(e),
            WE.Wat(s),
            n !== YE)
                throw new Error("notifications can only be created using C3.UI.Notification.ShowAt() method");
            if (super(),
            "string" == typeof t && (t = self.app.Tk(t)),
            t || (t = self.app.Tk("info")),
            WE.Mw(t, WE.qs.O_),
            !t.o5e())
                throw new Error("notifications can only use medium icons");
            if (this.Wan = i,
            this.Han = e,
            s = Object.assign({}, XE, s),
            WE.zt(s.align),
            WE.Ge(s.z7t),
            !HE.has(s.align))
                throw new Error("invalid alignment");
            this.cn = !1,
            this.hpn = -1,
            this.lji = s.align,
            this.opn = !!s.C6i,
            this.apn = 0,
            this.Yan = -1,
            this.lpn = !1,
            this.qan = s.z7t,
            this.upn = () => this.cpn(),
            this.dpn = () => this.fpn(),
            this.ppn = () => this.mpn(),
            this.wpn = () => this.Kan(),
            this.gpn = t => this.ypn(t),
            this.bpn = t => this.vpn(t),
            this.Get = WE.qs.lk("ui-notification"),
            this.Spn = null,
            this.opn && (this.Spn = WE.qs.HY.N$i()),
            this.Spn ? (this.Spn.hk().appendChild(this.Get),
            this.Spn.addEventListener("positionchange", this.upn),
            this.Spn.addEventListener("widthchange", this.upn),
            this.Spn.addEventListener("heightchange", this.upn),
            this.Spn.addEventListener("startdragging", this.ppn),
            this.Spn.addEventListener("finishdragging", this.dpn),
            this.Spn.addEventListener("startresizing", this.ppn),
            this.Spn.addEventListener("finishresizing", this.dpn)) : (document.body.appendChild(this.Get),
            this.Get.setAttribute("document-parent", "")),
            this.OLt = !1,
            this.Zan = null,
            this.Qan = null,
            this.VEt = null,
            this.Rbt = null,
            this.dP = null,
            this.Get.ownerDocument.defaultView && (!this.Spn || !this.Spn.Bmi() && this.Spn.Bj()) && (this.OLt = !0,
            this.Get.setAttribute("align", this.lji),
            this.Get.style.transitionDuration = s.duration,
            this.Zan = WE.qs.lk("ui-notification-icon", this.Get),
            this.Qan = WE.qs.lk("ui-notification-text", this.Get),
            this.VEt = WE.v(WE.qs.kmt, t),
            this.Zan.appendChild(this.VEt.hk()),
            this.Rbt = WE.qs.lk("ui-notification-title", this.Qan),
            this.dP = WE.qs.lk("ui-notification-body", this.Qan),
            WE.odt(this.Rbt, this.Wan),
            WE.odt(this.dP, this.Han),
            this.tv = this.Get.getBoundingClientRect().height,
            "function" == typeof s.onclick && this.Get.addEventListener("click", () => {
                this.Kan(),
                s.onclick()
            }
            ),
            WE.qs.Xfn.Jfn(this),
            self.app.zmt() || (this.Get.style.transition = "none"),
            this.xpn())
        }
        LUt(t=!0) {
            WE.dn(this) || this.cn || (clearTimeout(this.hpn),
            this.cn = !0,
            (t = !!t) && WE.qs.Xfn.epn(this),
            this.Spn && (this.Spn.removeEventListener("positionchange", this.upn),
            this.Spn.removeEventListener("widthchange", this.upn),
            this.Spn.removeEventListener("heightchange", this.upn),
            this.Spn.removeEventListener("startdragging", this.ppn),
            this.Spn.removeEventListener("finishdragging", this.dpn),
            this.Spn.removeEventListener("startresizing", this.ppn),
            this.Spn.removeEventListener("finishresizing", this.dpn),
            this.Spn = null,
            this.upn = null,
            this.ppn = null,
            this.dpn = null),
            this.Get.removeEventListener("transitionend", this.gpn),
            this.gpn = null,
            this.Get.removeEventListener("transitionend", this.bpn),
            this.bpn = null,
            this.ofn(),
            this.VEt && this.VEt.he(),
            WE.qs.BW(this.Rbt),
            WE.qs.BW(this.Zan),
            WE.qs.BW(this.Qan),
            WE.qs.BW(this.Get),
            this.Zan = null,
            this.Qan = null,
            this.VEt = null,
            this.Rbt = null,
            this.dP = null,
            this.Get = null,
            WE.he(this))
        }
        Mpn() {
            return this.OLt
        }
        Zfn() {
            return this.lji
        }
        Epn() {
            return this.qan
        }
        Zie() {
            return this.tv + KE
        }
        Qfn(t) {
            WE.Ge(t),
            t >= WE.qs.Xfn.tpn - 1 && (t = WE.qs.Xfn.tpn - 1),
            this.apn !== t && (this.apn = t,
            this.cpn())
        }
        xpn() {
            this.cpn(),
            this.Get.setAttribute("showing", this.lji),
            self.app.zmt() ? this.Get.addEventListener("transitionend", this.gpn) : WE.qs.Xfn.spn(this)
        }
        ypn(t) {
            WE.dn(this) || this.cn || "transform" === t.propertyName && (this.Get.removeEventListener("transitionend", this.gpn),
            WE.qs.Xfn.spn(this))
        }
        Cpn() {
            this.lpn || (this.lpn = !0,
            this.Get.removeAttribute("showing"),
            "top-left" !== this.lji && "bottom-left" !== this.lji || this.Get.setAttribute("hiding-left", ""),
            "top-right" !== this.lji && "bottom-right" !== this.lji || this.Get.setAttribute("hiding-right", ""),
            self.app.zmt() ? (this.Get.addEventListener("transitionend", this.bpn),
            this.hpn = setTimeout( () => {
                this.LUt()
            }
            , qE)) : this.LUt())
        }
        vpn(t) {
            WE.dn(this) || this.cn || "transform" === t.propertyName && (this.Get.removeEventListener("transitionend", this.bpn),
            this.LUt())
        }
        ofn() {
            clearTimeout(this.Yan)
        }
        npn() {
            this.Yan = setTimeout(this.wpn, this.qan)
        }
        _pn() {
            this.Get.setAttribute("no-position-transitions", "")
        }
        mpn() {
            this.Get.setAttribute("no-transitions", "")
        }
        fpn() {
            this.Get.removeAttribute("no-transitions")
        }
        Tpn() {
            return !this.Get.hasAttribute("no-transitions")
        }
        Kan() {
            this.ofn(),
            this.Tpn() || (this.fpn(),
            this._pn()),
            this.Cpn()
        }
        cpn() {
            let t = this.Get.style
              , i = WE.qs.Xfn.rpn(this);
            if (this.Spn && !this.Spn.NBi()) {
                let e = this.Get.ownerDocument
                  , s = e.defaultView
                  , n = s.innerWidth || e.documentElement.clientWidth || e.body.clientWidth
                  , r = s.innerHeight || e.documentElement.clientHeight || e.body.clientHeight
                  , h = this.Spn.byi()
                  , o = this.Spn.yyi()
                  , a = n - (h + this.Spn.ns())
                  , l = r - (o + this.Spn.Kn());
                "top-left" === this.lji ? (t.left = -h + "px",
                t.top = `${-o + i}px`) : "top-right" === this.lji ? (t.right = -a + "px",
                t.top = `${-o + i}px`) : "bottom-left" === this.lji ? (t.left = -h + "px",
                t.bottom = `${-l + i}px`) : "bottom-right" === this.lji && (t.right = -a + "px",
                t.bottom = `${-l + i}px`)
            } else
                "top-left" === this.lji ? (t.left = "0px",
                t.top = `${i}px`) : "top-right" === this.lji ? (t.right = "0px",
                t.top = `${i}px`) : "bottom-left" === this.lji ? (t.left = "0px",
                t.bottom = `${i}px`) : "bottom-right" === this.lji && (t.right = "0px",
                t.bottom = `${i}px`)
        }
        static nF(t, i, e, s) {
            if (!self.app.Ipn())
                return;
            const n = WE.qs.HY.N$i();
            if (n && n.M6i() && !s.C6i && !n._wt())
                return;
            const r = WE.v(WE.qs.Notification, t, i, e, s, YE);
            r.Mpn() || r.LUt(!1)
        }
    }
}
{
    const JE = self.t
      , ZE = JE.ek(import.meta.url).getElementById("ui-loader-template")
      , QE = !1;
    JE.qs.Cgt = class {
        constructor(t) {
            JE.Mw(t, HTMLElement),
            this.element = document.createElement("ui-loader");
            const i = ZE.content.cloneNode(!0);
            QE ? this.element.createShadowRoot().appendChild(i) : this.element.appendChild(i),
            t && t.appendChild(this.element)
        }
        x_(t) {
            t ? this.element.removeAttribute("hidden", "") : this.element.setAttribute("hidden", "")
        }
        E7t() {
            this.element.setAttribute("pause", "")
        }
        Ppn() {
            this.element.removeAttribute("pause")
        }
        get Sgt() {
            return this.element.getElementsByTagName("ui-loader-message")[0].textContent
        }
        set Sgt(t) {
            this.element.getElementsByTagName("ui-loader-message")[0].textContent = t
        }
        remove() {
            this.element.remove()
        }
    }
}
{
    const tC = self.t;
    tC.fk = tC.v(tC.Event.aG),
    tC.UWt = class {
        constructor(t, i, e) {
            if (tC.zt(t),
            tC.Yq(i),
            tC.rAe(e, "#document"),
            e === document)
                throw new Error("component cannot reference main document");
            this.phs = t,
            this.Gpn = i,
            this.oAe = e,
            this.aAe = e.documentURI
        }
        he() {
            this.phs = null,
            this.Gpn = null,
            this.oAe = null,
            this.aAe = null
        }
        vR() {
            return this.phs
        }
        gk() {
            return this.Gpn
        }
        ek() {
            return this.oAe
        }
        wAe() {
            return this.aAe
        }
    }
}
{
    const iC = self.t
      , eC = "c3-user-settings"
      , sC = ["account", "account-access-code", "account-login", "account-logout", "account-register", "add", "add-folder", "addon", "align-bottom", "align-top", "align-left", "align-vcenter", "align-hcenter", "align-right", "align-edge-left", "align-edge-top", "align-edge-right", "align-edge-bottom", "all-frames", "all-columns", "all-rows", "ambiguous", "animation", "animation-column", "animation-row", "array", "arrow-pointer", "archive", "async-action", "async-end", "audio", "auto-keyframes", "back", "bar", "bookmark", "breakpoint", "breakpoint-active-left", "breakpoint-active-right", "brush", "bucket", "build", "c3-mono", "check", "cleanup", "clear", "cloud", "cloud-upload", "close", "closed-folder", "code", "collapsed", "compress", "color", "copy", "crop", "cross", "csv", "cut", "debug", "default-interpolation", "delete", "delete-all", "delete-column", "delete-row", "dictionary", "disabled", "dot", "download", "dpad", "dropbox", "duplicate", "edit", "ellipse", "eraser", "error", "event-comment", "event-sheet", "exit-fullscreen", "expanded", "export", "external", "eye-dropper", "file", "file-preview", "flag", "flash", "flowchart", "focus", "font", "frame", "fullscreen", "function", "generic-file", "globe", "global-variable", "google-drive", "goto", "grid", "guided-tour", "hand", "help", "home", "html", "html-tag", "image", "import", "import-files", "insert-row-before", "insert-row-after", "insert-column-before", "insert-column-after", "install-app", "instance-variable", "info", "invert-ease", "invisible", "javascript", "javascript-color", "json", "language", "layers", "layout", "line", "link", "link-anchor", "local-variable", "location-pin", "locked", "loop-condition", "menu-dots", "menu-submenu", "mesh", "mirror-h", "mirror-v", "move-down", "move-up", "new", "next", "numbers", "offline", "onedrive", "open", "open-folder", "open-popup", "origin", "output", "paste", "patch", "pause", "pause-timeline", "pdf", "pin", "pin-off", "play", "polygon", "preview", "preview-debug", "previous", "print", "rectangle", "rectangle-select", "redo", "reload", "remote-preview", "remove", "replace", "replica", "resize", "reverse", "rotate-acw", "rotate-cw", "save", "scene-graph", "scirra-store", "scroll", "search", "security-shield", "select-all", "send-to-back", "send-to-front", "set-keyframes", "settings", "share-arrow", "shared-folder", "shopping-cart", "skip-first", "skip-last", "skip-next", "skip-previous", "sort", "sound", "space-horiz", "space-vert", "star", "statistics", "stop", "style", "support", "template", "terms", "text-overlay-l", "text-overlay-r", "text-short", "thumbnail", "tiles", "timeline", "timeline-ui", "timer", "toggle-background", "tools", "touch", "transition", "translucent", "trigger-condition", "typescript", "typescript-color", "undo", "unknown-file", "unlocked", "update", "upload", "up-arrow", "video", "videogame", "view", "visible", "warning", "wrap-selection", "xml", "z-order", "zoom-in", "zoom-out", "zoom-reset", "family-overlay-mask", "custom-ace-overlay-mask", {
        name: "effect",
        color: "--effect-icon-color"
    }, {
        name: "family-overlay",
        color: "--family-overlay-icon-color"
    }, {
        name: "custom-ace",
        color: "--custom-ace-icon-color"
    }, {
        name: "custom-ace-overlay",
        color: "--custom-ace-overlay-icon-color"
    }, {
        name: "image-point",
        color: "#FF0000"
    }, {
        name: "invert",
        color: "--invert-icon-color"
    }, {
        _je: "origin",
        name: "origin-cursor",
        color: "#FFFFFF"
    }, {
        _je: "image-point",
        name: "image-point-cursor",
        color: "#00FFFF"
    }, {
        _je: "animation",
        name: "default-animation",
        color: "--default-icon-color"
    }]
      , nC = new Set(["save", "undo", "redo", "preview", "preview-debug", "menu-submenu", "account", "open-folder", "closed-folder"])
      , rC = new Set(["animation", "event-sheet", "instance-variable", "layout", "loop-condition", "trigger-condition"])
      , hC = !!window.C3_IsPopupWindow;
    let oC = !1;
    iC.XYe = class extends iC.Event.aG {
        constructor() {
            if (super(),
            oC)
                throw new Error("only one C3.App should be instantiated");
            oC = !0,
            this.rVt = "MyApp",
            this._st = new Map,
            this.kfn = hC,
            this.Apn = null,
            this.Rpn = 0,
            this.kpn = 0,
            this.Opn = 0,
            this.Dpn = {},
            this.Fpn = !1,
            "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", () => {
                this.Rpn = Math.round(1.54 * iC.qs.uA()),
                this.kpn = 2 * this.Rpn,
                this.Opn = 2 * this.kpn
            }
            ) : (this.Rpn = Math.round(1.54 * iC.qs.uA()),
            this.kpn = 2 * this.Rpn,
            this.Opn = 2 * this.kpn),
            this.Lpn = new Map,
            this.Bpn = new Map,
            this.Upn = new Map,
            window.app = this
        }
        Npn() {
            this.kfn || (this.Apn = iC.v(iC.qs.fA, "main", !1),
            this.Apn.x0e(!0))
        }
        jpn() {
            self.C3_HideLoader(),
            iC.qs.bqe("supportMessage"),
            iC.qs.vqe("noscript"),
            iC.qs.vqe("script[src$='supportCheck.js']"),
            iC.qs.vqe("script[src$='es2015check.js']"),
            this.Apn.x0e(!1)
        }
        Fa() {
            return this.rVt
        }
        Eqe() {
            return this.Apn
        }
        T_() {
            return this.Rpn
        }
        Gk() {
            return this.kpn
        }
        BJt() {
            return this.Opn
        }
        Igs(t) {
            switch (iC.zt(t),
            t) {
            case "small":
                return this.Rpn;
            case "medium":
                return this.kpn;
            case "large":
                return this.Opn;
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        NBi() {
            return this.kfn
        }
        $pn() {
            const t = new iC.Event("load");
            return t.app = this,
            t.jH = this.kfn,
            iC.fk.ize(t)
        }
        zpn() {
            const t = new iC.Event("afterload");
            return t.app = this,
            t.jH = this.kfn,
            iC.fk.ize(t)
        }
        yk(t) {
            return iC.zt(t),
            this._st.get(t)
        }
        Vpn(t) {
            return iC.zt(t),
            this._st.has(t)
        }
        bk(t, i, e) {
            if (iC.zt(t),
            iC.Yq(i),
            iC.rAe(e, "#document"),
            e === document)
                throw new Error("cannot register component with main document");
            if (this.Vpn(t))
                throw new Error(`component id '${t}' already registered`);
            let s = iC.v(iC.UWt, t, i, e);
            this._st.set(t, s);
            let n = new iC.Event("registercomponent");
            n.app = this,
            n.component = s,
            iC.fk.dispatchEvent(n)
        }
        Wpn(t) {
            if (iC.zt(t),
            !this.Vpn(t))
                throw new Error(`component id '${t}' is not registered`);
            let i = this._st.get(t)
              , e = new iC.Event("unregistercomponent");
            e.app = this,
            e.component = i,
            iC.fk.dispatchEvent(e),
            i.he(),
            this._st.delete(t)
        }
        zj(t) {
            const i = this.yk(t);
            return i ? i.gk() : null
        }
        Hpn() {
            return {}
        }
        async Kpn() {
            const t = await localforage.getItem(eC)
              , i = Object.assign({}, this.Hpn(), t);
            return this.Dpn = i,
            this.Fpn = !0,
            i
        }
        qpn() {
            return this.Fpn
        }
        r0() {
            return this.Dpn
        }
        X6i() {
            return localforage.setItem(eC, this.Dpn).catch(t => this.OA(t))
        }
        Xpn(t) {
            iC.zt(t);
            let i = new iC.Event(t);
            i.Ypn = this.Dpn,
            this.dispatchEvent(i)
        }
        zmt() {
            return !0
        }
        J1() {
            return !0
        }
        Jpn() {
            let t = document.body.parentElement
              , i = this.J1() ? "highgfxmode" : "lowgfxmode"
              , e = this.J1() ? "lowgfxmode" : "highgfxmode";
            t.removeAttribute(e),
            t.setAttribute(i, "")
        }
        Zpn() {
            this.Jpn(),
            iC.zTe();
            const t = [];
            for (const i of nC)
                t.push(this.Lpn.get(i).yAs());
            return Promise.all(t)
        }
        async Qpn() {
            iC.n0("PrefetchAllIcons");
            const t = [];
            for (const [i,e] of this.Lpn.entries())
                nC.has(i) || t.push(e.yAs());
            await Promise.all(t),
            iC.I0("PrefetchAllIcons")
        }
        tmn() {
            let t = iC.qs.oX.uXe();
            for (let i of sC) {
                let e, s = null, n = null;
                "object" == typeof i ? (e = i.name,
                s = i.color,
                n = i._je,
                s.startsWith("--") && (s = iC.qs.oX.rX(s))) : (e = i,
                rC.has(i) && (s = iC.qs.oX.rX("--project-item-icon-color")));
                let r = n || e
                  , h = iC.v(iC.qs.pAe, this, `${t}${r}.svg`, {
                    name: e,
                    color: s
                });
                this.Lpn.set(e, h)
            }
        }
        async imn() {
            const t = [];
            for (let i of sC) {
                let e = ""
                  , s = null;
                "object" == typeof i ? (e = i.name,
                s = i.color,
                s.startsWith("--") && (s = iC.qs.oX.rX(s))) : (e = i,
                rC.has(i) && (s = iC.qs.oX.rX("--project-item-icon-color"))),
                e && s && t.push(this.Lpn.get(e).Xn(s))
            }
            await Promise.all(t)
        }
        oi(t) {
            iC.zt(t);
            let i = this.Lpn.get(t);
            if (i)
                return i.xA();
            throw new Error(`common small icon '${t}' not found`)
        }
        Tk(t) {
            iC.zt(t);
            let i = this.Lpn.get(t);
            if (i)
                return i.uj();
            throw new Error(`common medium icon '${t}' not found`)
        }
        bds(t) {
            iC.zt(t);
            let i = this.Lpn.get(t);
            if (i)
                return i.nus();
            throw new Error(`common large icon '${t}' not found`)
        }
        wAs(t, i) {
            switch (iC.zt(t),
            iC.zt(i),
            i) {
            case "small":
                return this.oi(t);
            case "medium":
                return this.Tk(t);
            case "large":
                return this.bds(t);
            default:
                throw new Error("invalid icon size")
            }
        }
        sdn(t, i) {
            return iC.zt(t),
            iC.Ge(i),
            i <= this.T_() ? this.oi(t) : i <= this.Gk() ? this.Tk(t) : this.bds(t)
        }
        async D6e(t) {
            const i = iC.qs.oX.uXe();
            if (t.startsWith(i)) {
                const i = iC.des(t).toLowerCase()
                  , e = await iC.qs.oX.cXe();
                return e.hasOwnProperty(i) ? e[i] : iC.Nxe(t)
            }
            return iC.Nxe(t)
        }
        Bot(t) {
            return iC.zt(t),
            this.Lpn.get(t) || null
        }
        MA(t) {
            if (iC.zt(t),
            this.Bpn.has(t))
                return this.Bpn.get(t);
            let i = new Blob([`<svg version="1.1"\n\t\t\tbaseProfile="full"\n\t\t\twidth="100%" height="100%"\n\t\t\tstyle="text-rendering:geometricPrecision; image-rendering:optimizeQuality;"\n\t\t\txmlns="http://www.w3.org/2000/svg"\n\t\t\tstroke="black"\n\t\t\tfill="black">\n\t\n\t\t\t<text x="50%" y="50%" dy=".45em" font-size="10" text-anchor="middle" stroke-width="1.1px">${t}</text>\n\t\t</svg>`],{
                type: "image/svg+xml"
            })
              , e = URL.createObjectURL(i)
              , s = iC.v(iC.qs.pAe, self.app, e, {});
            return this.Bpn.set(t, s),
            s
        }
        nX(t, i) {
            if (iC.Hut(i),
            iC.zt(i.name),
            iC.zt(i.color),
            this.Upn.has(i.name))
                return this.Upn.get(i.name);
            const e = iC.v(iC.qs.pAe, self.app, t.emn(), {
                name: "plugin-" + t.vR() + "-" + i.name,
                color: i.color
            });
            return this.Upn.set(i.name, e),
            e
        }
        pXe() {
            return this.Lpn.values()
        }
        OA(t) {
            (() => {})("Storage write error:", t)
        }
    }
}
{
    const aC = self.t
      , lC = self.sG
      , uC = lC.hG
      , cC = lC.dys
      , dC = lC.eG
      , fC = uC.create()
      , pC = uC.create()
      , mC = uC.create()
      , wC = cC.create()
      , gC = dC.create()
      , yC = uC.create()
      , bC = uC.create()
      , vC = uC.create()
      , SC = uC.create()
      , xC = uC.create()
      , MC = uC.create()
      , EC = uC.create()
      , CC = uC.create()
      , _C = cC.rMe(0, 0, 1, 1);
    function TC(t, i, e, s) {
        const n = mC;
        uC.mMe(fC, e, i),
        uC.mMe(pC, t, i),
        uC.QMe(n, fC, pC),
        uC.normalize(n, n),
        s.set(n[0], n[1], n[2], uC.dot(t, n))
    }
    function IC(t, i, e, s, n, r, h) {
        const o = h.x
          , a = h.y
          , l = h.z
          , u = h.w
          , c = h.xF
          , d = h.yF
          , f = h.zF
          , p = 1 - c
          , m = 1 - d
          , w = 1 - f;
        if (o * t * c + o * s * p + a * i * d + a * n * m + l * e * f + l * r * w >= u)
            return !0;
        return o * s * c + o * t * p + a * n * d + a * i * m + l * r * f + l * e * w > u
    }
    function PC(t, i, e, s) {
        return s.x * t + s.y * i + s.z * e >= s.w
    }
    aC.ra = {
        gh(t, i, e, s, n, r, h) {
            const o = s[0] * t + s[4] * i + s[8] * e + s[12]
              , a = s[1] * t + s[5] * i + s[9] * e + s[13]
              , l = s[2] * t + s[6] * i + s[10] * e + s[14]
              , u = s[3] * t + s[7] * i + s[11] * e + s[15];
            let c = n[0] * o + n[4] * a + n[8] * l + n[12] * u
              , d = n[1] * o + n[5] * a + n[9] * l + n[13] * u
              , f = n[2] * o + n[6] * a + n[10] * l + n[14] * u
              , p = n[3] * o + n[7] * a + n[11] * l + n[15] * u;
            return 0 !== p && (p = 1 / p,
            c *= p,
            d *= p,
            f *= p,
            h[0] = (.5 * c + .5) * r[2] + r[0],
            h[1] = (.5 * d + .5) * r[3] + r[1],
            h[2] = .5 * (1 + f),
            !0)
        },
        smn(t, i, e, s, n, r, h) {
            const o = gC
              , a = wC;
            return dC.multiply(o, n, s),
            null !== dC.oMe(o, o) && (a[0] = (t - r[0]) / r[2] * 2 - 1,
            a[1] = (i - r[1]) / r[3] * 2 - 1,
            a[2] = 2 * e - 1,
            a[3] = 1,
            cC.sTe(a, a, o),
            0 !== a[3] && (a[3] = 1 / a[3],
            h[0] = a[0] * a[3],
            h[1] = a[1] * a[3],
            h[2] = a[2] * a[3],
            !0))
        },
        Izs(t, i, e, s, n, r, h) {
            const o = fC
              , a = pC;
            if (!aC.ra.smn(t, i, 0, s, n, r, o))
                return !1;
            if (!aC.ra.smn(t, i, 1, s, n, r, a))
                return !1;
            const l = pC;
            uC.mMe(l, a, o);
            const u = mC;
            uC.set(u, 0, 0, 1);
            const c = -e
              , d = uC.dot(u, l);
            let f = 0;
            if (0 === d) {
                if (0 !== uC.dot(u, o) + c)
                    return !1
            } else if (f = -(uC.dot(o, u) + c) / d,
            f < 0)
                return !1;
            return uC.qMe(h, o, l, f),
            !0
        }
    };
    class GC {
        constructor() {
            this.x = NaN,
            this.y = NaN,
            this.z = NaN,
            this.w = NaN,
            this.xF = NaN,
            this.yF = NaN,
            this.zF = NaN
        }
        set(t, i, e, s) {
            this.x = t,
            this.y = i,
            this.z = e,
            this.w = s,
            this.xF = t > 0 ? 1 : 0,
            this.yF = i > 0 ? 1 : 0,
            this.zF = e > 0 ? 1 : 0
        }
    }
    aC.ra.Ezs = class {
        constructor() {
            this.nmn = new GC,
            this.rmn = new GC,
            this.hmn = new GC,
            this.omn = new GC,
            this.amn = new GC,
            this.lmn = new GC
        }
        xzs(t, i) {
            const e = _C;
            aC.ra.smn(0, 1, 0, t, i, e, yC),
            aC.ra.smn(1, 1, 0, t, i, e, bC),
            aC.ra.smn(0, 0, 0, t, i, e, vC),
            aC.ra.smn(1, 0, 0, t, i, e, SC),
            aC.ra.smn(0, 1, 1, t, i, e, xC),
            aC.ra.smn(1, 1, 1, t, i, e, MC),
            aC.ra.smn(0, 0, 1, t, i, e, EC),
            aC.ra.smn(1, 0, 1, t, i, e, CC),
            TC(vC, yC, xC, this.nmn),
            TC(yC, bC, MC, this.rmn),
            TC(bC, SC, CC, this.hmn),
            TC(SC, vC, EC, this.omn),
            TC(EC, xC, MC, this.lmn),
            TC(SC, bC, yC, this.amn)
        }
        eCs(t, i, e, s, n, r) {
            return IC(t, i, e, s, n, r, this.nmn) && IC(t, i, e, s, n, r, this.rmn) && IC(t, i, e, s, n, r, this.hmn) && IC(t, i, e, s, n, r, this.omn) && IC(t, i, e, s, n, r, this.amn) && IC(t, i, e, s, n, r, this.lmn)
        }
        umn(t, i, e) {
            return !PC(t, i, e, this.amn)
        }
    }
}
{
    const AC = self.t;
    AC.ra.cmn = class {
        constructor(t, i, e, s, n, r, h) {
            this.an = t,
            this.dKe = 0,
            this.dmn = null,
            this.fmn = "",
            this.xys = e,
            this.mp = AC.v(AC.Ha),
            this.mp.set(s),
            this.mys = n,
            this.pmn = r,
            this.mmn = h,
            "string" == typeof i ? this.fmn = i : (this.dmn = i,
            this.fmn = this.dmn.Fa())
        }
        he() {
            if (this.dKe > 0)
                throw new Error("releasing state group still in use");
            this.an = null,
            this.dmn = null,
            this.fmn = ""
        }
        iXe() {
            const t = this.an;
            t.Yw(this.dmn),
            t.ac(this.xys),
            t.Xn(this.mp),
            t.lK(this.mys),
            t.Ww(this.pmn),
            t.Xw(this.mmn),
            t.wmn(this)
        }
        gmn() {
            return AC.ra.cmn.ymn(this.fmn, this.xys, this.mp, this.mys, this.pmn, this.mmn)
        }
        bmn() {
            ++this.dKe
        }
        vmn() {
            --this.dKe
        }
        Smn() {
            return this.dKe
        }
        Vs() {
            this.dmn = null
        }
        Lv(t) {
            if (this.dmn = t.xmn(this.fmn),
            !this.dmn)
                throw new Error("failed to restore shader program")
        }
        static ymn(t, i, e, s, n, r) {
            return ("string" == typeof t ? t : t.Fa()) + "," + i + "," + e.getR() + "," + e.getG() + "," + e.getB() + "," + e.getA() + "," + s + "," + n + "," + r
        }
    }
}
{
    const RC = globalThis.t
      , kC = globalThis.assert
      , OC = 65535;
    function DC(t, i, e) {
        const s = e.Jn()
          , n = e.Qn()
          , r = e.Hw() - s
          , h = e.rl() - n;
        return [s + r * t + (e.zc() - s) * i, n + h * t + (e.Ec() - n) * i]
    }
    RC.ra.KZ = class {
        constructor(t, i, e) {
            this.Mmn = t,
            this.Emn = i,
            this.lcn = e,
            this.kd = NaN,
            this.Gd = NaN,
            this.mys = NaN,
            this._u = NaN,
            this._v = NaN,
            this.kd = 0,
            this.Gd = 0,
            this.mys = 0,
            this._u = 0,
            this._v = 0
        }
        cxs(t, i, e, s) {
            this.kd = t,
            this.Gd = i,
            this._u = e,
            this._v = s
        }
        _a() {
            return this.kd
        }
        kp(t) {
            this.kd !== t && (this.kd = t,
            this.Mmn.Cmn())
        }
        Da() {
            return this.Gd
        }
        Gp(t) {
            this.Gd !== t && (this.Gd = t,
            this.Mmn.Cmn())
        }
        aK() {
            return this.mys
        }
        Qne(t) {
            this.mys !== t && (this.mys = Math.max(t, 0),
            this.Mmn.Cmn())
        }
        B3() {
            return this._u
        }
        t8(t) {
            this._u = t
        }
        Y3() {
            return this._v
        }
        i8(t) {
            this._v = t
        }
        _mn(t, i, e) {
            [this.kd,this.Gd] = DC(t.kd, t.Gd, i),
            this.mys = t.mys,
            this._u = RC.mi(e.Kr(), e.gl(), t._u),
            this._v = RC.mi(e.Zr(), e.wl(), t._v)
        }
        Tmn(t, i, e) {
            [this.kd,this.Gd] = DC(t.kd, t.Gd, i),
            this.mys = t.mys,
            [this._u,this._v] = DC(t._u, t._v, e)
        }
        wO() {
            return {
                x: this._a(),
                y: this.Da(),
                z: this.aK(),
                u: this.B3(),
                v: this.Y3()
            }
        }
        xfs(t) {
            this.kp(t.x),
            this.Gp(t.y),
            t.hasOwnProperty("z") && this.Qne(t.z),
            this.t8(t.u),
            this.i8(t.v)
        }
        So() {
            return this.Mmn
        }
        lle() {
            return this.Emn
        }
        cle() {
            return this.lcn
        }
    }
    ,
    RC.ra.OCs = class {
        constructor(t, i, e) {
            if (t < 2 || i < 2)
                throw new Error("invalid mesh size");
            this.Imn = t,
            this.Pmn = i,
            this.HIs = e || null,
            this.Gmn = [],
            this.Amn = 0,
            this.Rmn = 0,
            this.kmn = 1,
            this.Omn = 1,
            this.Dmn = 0,
            this.Fmn = !1,
            this.Lmn = [],
            this.Bmn = 0,
            this.Umn = !0;
            const s = t - 1
              , n = i - 1;
            for (let e = 0; e < i; ++e) {
                const i = [];
                for (let r = 0; r < t; ++r) {
                    const t = RC.v(RC.ra.KZ, this, r, e)
                      , h = r / s
                      , o = e / n;
                    t.cxs(h, o, h, o),
                    i.push(t)
                }
                this.Gmn.push(i)
            }
        }
        he() {
            RC.sc(this.Gmn),
            RC.sc(this.Lmn)
        }
        ka() {
            return this.Imn
        }
        Ga() {
            return this.Pmn
        }
        mte() {
            return this.HIs
        }
        UCs() {
            return this.Gmn
        }
        Cmn() {
            this.Fmn = !0,
            this.Umn = !0
        }
        Nmn() {
            if (!this.Fmn)
                return;
            let t = 1 / 0
              , i = 1 / 0
              , e = -1 / 0
              , s = -1 / 0
              , n = 0;
            for (const r of this.Gmn)
                for (const h of r) {
                    const r = h._a()
                      , o = h.Da();
                    t = Math.min(t, r),
                    i = Math.min(i, o),
                    e = Math.max(e, r),
                    s = Math.max(s, o),
                    n = Math.max(n, h.aK())
                }
            this.Amn = t,
            this.Rmn = i,
            this.kmn = e,
            this.Omn = s,
            this.Dmn = n,
            this.Fmn = !1
        }
        Gtt() {
            return this.Nmn(),
            this.Amn
        }
        Ott() {
            return this.Nmn(),
            this.Rmn
        }
        Ctt() {
            return this.Nmn(),
            this.kmn
        }
        Rtt() {
            return this.Nmn(),
            this.Omn
        }
        jmn() {
            return this.Nmn(),
            this.Dmn
        }
        Gni() {
            return this.jmn() > 0
        }
        ja(t, i) {
            return t = Math.floor(t),
            i = Math.floor(i),
            t < 0 || t >= this.Imn || i < 0 || i >= this.Pmn ? null : this.Gmn[i][t]
        }
        RCs(t, i, e) {
            RC.U(t, RC.ra.OCs),
            RC.U(i, RC.Nn),
            RC.cT(e, RC.Rect, RC.Nn);
            const s = e instanceof RC.Rect;
            if (t.ka() !== this.ka() || t.Ga() !== this.Ga())
                throw new Error("source mesh wrong size");
            const n = t.Gmn
              , r = this.Gmn;
            for (let t = 0, h = r.length; t < h; ++t) {
                const h = n[t]
                  , o = r[t];
                for (let t = 0, n = o.length; t < n; ++t) {
                    const n = h[t]
                      , r = o[t];
                    s ? r._mn(n, i, e) : r.Tmn(n, i, e)
                }
            }
            this.Umn = !0
        }
        $mn(t) {
            if (!this.Umn && this.Bmn === t)
                return;
            const i = this.Imn
              , e = this.Pmn
              , s = this.Lmn
              , n = Math.floor(OC / i) - 1;
            if (n <= 0)
                throw new Error("mesh too large");
            const r = Math.ceil((e - 1) / n);
            r < s.length && (s.length = r);
            let h = 0;
            for (let o = 0; o < r; ++o) {
                const r = Math.min(n, e - h - 1);
                kC(r > 0, "invalid mesh chunk");
                const a = (r + 1) * i
                  , l = 3 * a
                  , u = 2 * a
                  , c = (i - 1) * r * 6;
                if (o === s.length)
                    s.push({
                        zmn: new Float32Array(l),
                        Vmn: new Float32Array(u),
                        Wmn: new Uint16Array(c)
                    });
                else {
                    const t = s[o];
                    t.zmn.length !== l && (t.zmn = new Float32Array(l)),
                    t.Vmn.length !== u && (t.Vmn = new Float32Array(u)),
                    t.Wmn.length !== c && (t.Wmn = new Uint16Array(c))
                }
                const {zmn: d, Vmn: f, Wmn: p} = s[o];
                this.Hmn(h, r, t, d, f, p),
                h += n
            }
            this.Bmn = t,
            this.Umn = !1
        }
        Hmn(t, i, e, s, n, r) {
            const h = this.Gmn
              , o = this.Imn;
            let a = 0
              , l = 0
              , u = 0;
            for (let c = t, d = t + i + 1; c < d; ++c) {
                const i = h[c]
                  , f = c + 1
                  , p = c - t
                  , m = p * o
                  , w = (p + 1) * o;
                for (let t = 0, h = i.length; t < h; ++t) {
                    const o = i[t]
                      , c = t + 1;
                    if (s[a++] = o._a(),
                    s[a++] = o.Da(),
                    s[a++] = o.aK() + e,
                    n[l++] = o.B3(),
                    n[l++] = o.Y3(),
                    c < h && f < d) {
                        const i = t + m
                          , e = c + m
                          , s = c + w
                          , n = t + w;
                        r[u++] = i,
                        r[u++] = e,
                        r[u++] = s,
                        r[u++] = i,
                        r[u++] = s,
                        r[u++] = n
                    }
                }
            }
        }
        Un(t, i) {
            this.$mn(i);
            for (const {zmn: i, Vmn: e, Wmn: s} of this.Lmn)
                t.jo(i, e, s)
        }
        LGs(t, i) {
            i || (i = (t, i, e) => [t, i, e]);
            const e = this.Gmn;
            let s = e[0];
            for (let n = 1, r = e.length; n < r; ++n) {
                const h = e[n];
                let o = s[0]
                  , a = h[0];
                for (let e = 1, l = h.length; e < l; ++e) {
                    const u = s[e]
                      , c = h[e]
                      , [d,f,p] = i(o._a(), o.Da(), o.aK())
                      , [m,w,g] = i(u._a(), u.Da(), u.aK())
                      , [y,b,v] = i(c._a(), c.Da(), c.aK())
                      , [S,x,M] = i(a._a(), a.Da(), a.aK());
                    t.Wo(d, f, p, m, w, g),
                    t.Wo(d, f, p, y, b, v),
                    t.Wo(d, f, p, S, x, M),
                    e === l - 1 && t.Wo(m, w, g, y, b, v),
                    n === r - 1 && t.Wo(S, x, M, y, b, v),
                    o = u,
                    a = c
                }
                s = h
            }
        }
        zbs(t) {
            const i = .001
              , e = .99999999
              , s = t.Aps()
              , n = []
              , r = this.ka() - 1
              , h = this.Ga() - 1
              , o = 1 / r
              , a = 1 / h
              , l = r - 1
              , u = h - 1;
            let c = s[0]
              , d = s[1]
              , f = RC.Ne(Math.floor(c * r), 0, l)
              , p = RC.Ne(Math.floor(d * h), 0, u)
              , m = !0
              , w = 0
              , g = 0
              , y = 0;
            let b = -1;
            const v = () => {
                c = RC.Ne(RC.mi(c, w, y), 0, 1),
                d = RC.Ne(RC.mi(d, g, y), 0, 1),
                n.push(c, d)
            }
            ;
            for (let t = 0, S = s.length; t < S; t += 2) {
                c = s[t],
                d = s[t + 1],
                n.push(c, d),
                f = RC.Ne(Math.floor(c * r), 0, l),
                p = RC.Ne(Math.floor(d * h), 0, u);
                const x = (t + 2) % S;
                for (w = s[x],
                g = s[x + 1],
                b = -1; ; ) {
                    if (n.length > 1e6)
                        throw new Error("Too many mesh poly points");
                    const t = f * o
                      , s = p * a
                      , r = (f + 1) * o
                      , h = (p + 1) * a;
                    if (m = RC.sDe(c, d, t, s, r, s, r, h),
                    0 !== b && (y = RC.eDe(c, d, w, g, t, s, r, h, -.001),
                    y >= 0 && y <= e))
                        v(),
                        m = !m,
                        b = 0;
                    else if (p > 0 && 2 !== b && (y = RC.eDe(c, d, w, g, t, s, r, s, i),
                    y >= 0 && y <= e))
                        v(),
                        p--,
                        m = !1,
                        b = 4;
                    else if (f < l && 3 !== b && (y = RC.eDe(c, d, w, g, r, s, r, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f++,
                        m = !1,
                        b = 1;
                    else if (f > 0 && 1 !== b && (y = RC.eDe(c, d, w, g, t, s, t, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f--,
                        m = !0,
                        b = 3;
                    else {
                        if (!(p < u && 4 !== b && (y = RC.eDe(c, d, w, g, t, h, r, h, i),
                        y >= 0 && y <= e)))
                            break;
                        v(),
                        p++,
                        m = !0,
                        b = 2
                    }
                }
            }
            return RC.v(RC.Hm, n)
        }
        Wbs(t, i) {
            const e = this.Kmn(t);
            this.qmn(e),
            i._ps(e)
        }
        Kmn(t) {
            const i = []
              , e = t.Aps();
            for (let t = 0, s = e.length; t < s; t += 2) {
                const s = e[t]
                  , n = e[t + 1]
                  , [r,h] = this.Xmn(s, n);
                i.push(r, h)
            }
            return i
        }
        Xmn(t, i) {
            const e = this.ka() - 1
              , s = this.Ga() - 1
              , n = 1 / e
              , r = 1 / s
              , h = RC.Ne(Math.floor(t * e), 0, e - 1)
              , o = RC.Ne(Math.floor(i * s), 0, s - 1)
              , a = h * n
              , l = o * r
              , u = (h + 1) * n
              , c = (o + 1) * r
              , d = this.ja(h, o)
              , f = this.ja(h + 1, o + 1)
              , p = RC.sDe(t, i, a, l, u, l, u, c)
              , m = p ? a + n : a
              , w = p ? l : l + r
              , g = this.ja(h + (p ? 1 : 0), o + (p ? 0 : 1))
              , [y,b,v] = RC.nDe(t, i, a, l, m, w, u, c);
            return RC.rDe(y, b, v, d._a(), d.Da(), d.aK(), g._a(), g.Da(), g.aK(), f._a(), f.Da(), f.aK())
        }
        qmn(t) {
            const i = []
              , e = 1e-7;
            let s = t[0]
              , n = t[1]
              , r = s - t.at(-2)
              , h = n - t.at(-1);
            for (let o = 0, a = t.length; o < a; o += 2) {
                const l = (o + 2) % a
                  , u = t[l]
                  , c = t[l + 1]
                  , d = u - s
                  , f = c - n
                  , p = Math.abs(d) < e && Math.abs(r) < e && Math.sign(f) === Math.sign(h)
                  , m = Math.abs(f) < e && Math.abs(h) < e && Math.sign(d) === Math.sign(r);
                (!p && !m && Math.abs(d / r - f / h) > .001 || 0 == d && 0 === f) && i.push(s, n),
                s = u,
                n = c,
                r = d,
                h = f
            }
            i.length >= 6 && i.length < t.length && RC.lw(t, i)
        }
        wO() {
            return {
                cols: this.ka(),
                rows: this.Ga(),
                points: this.Gmn.map(t => t.map(t => t.wO()))
            }
        }
        xfs(t) {
            const i = this.ka()
              , e = this.Ga();
            if (t.cols !== i || t.rows !== e)
                throw new Error("mesh data wrong size");
            const s = t.points;
            for (let t = 0; t < e; ++t) {
                const e = s[t];
                for (let s = 0; s < i; ++s) {
                    this.ja(s, t).xfs(e[s])
                }
            }
        }
    }
}
{
    const FC = self.t
      , LC = self.sG
      , BC = LC.hG
      , UC = LC.dys
      , NC = LC.eG
      , jC = NC.create()
      , $C = BC.rMe(0, 0, 0)
      , zC = BC.rMe(0, 0, 0)
      , VC = BC.rMe(0, 0, 0)
      , WC = BC.rMe(0, 1, 0)
      , HC = (UC.rMe(0, 0, 0, 0),
    new FC.Nn)
      , KC = new FC.Rect
      , qC = new FC.Nn(0,0,1,0,1,1,0,1)
      , XC = {
        Ymn: 1,
        Jmn: 1e4
    }
      , YC = NC.rMe(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1);
    FC.ra.RC = class {
        constructor(t) {
            t = Object.assign({}, XC, t),
            this.ZC = 0,
            this.tv = 0,
            this.Zmn = FC.ct(45),
            this.Qmn = Math.tan(this.Zmn / 2),
            this.twn = NC.create(),
            this.iwn = NC.create(),
            this.ewn = !1,
            this.swn = t.Ymn,
            this.nwn = t.Jmn,
            this.rwn = [],
            this.hwn = new Map,
            this.own = null,
            this.awn = null,
            this.lwn = null,
            this.uwn = null,
            this.cwn = null,
            this.dwn = null,
            this.fwn = null,
            this.pwn = null,
            this.mwn = null,
            this.wwn = null,
            this.gwn = null,
            this.ywn = null,
            this.bwn = new Map,
            this.vwn = null,
            this.Swn = [],
            this.xwn = new Map,
            this.Mwn = 0,
            this.Ewn = 0,
            this.Z6 = 1,
            this.Cwn = [this.Z6],
            this._wn = 1,
            this.Twn = [this._wn],
            this.Iwn = .5,
            this.Pwn = [this.Iwn],
            this.Gwn = 0,
            this.Awn = !0,
            this.Rwn = !1
        }
        BMt() {
            this.Mwn = 0,
            this.Ewn = 0,
            this.own = null,
            this.awn = null,
            this.lwn = null,
            this.uwn = null,
            this.cwn = null,
            this.dwn = null,
            this.fwn = null,
            this.pwn = null,
            this.mwn = null,
            this.wwn = null,
            this.gwn = null,
            this.ywn = null,
            this.kwn()
        }
        w0() {
            this.BMt(),
            this.vwn = null
        }
        Own() {
            for (const t of this.rwn)
                t.he();
            this.BMt()
        }
        ns() {
            return this.ZC
        }
        Kn() {
            return this.tv
        }
        xa(t) {
            return this.Dwn() ? 100 : t / (2 * this.Fwn())
        }
        wa(t) {
            if (this.Dwn()) {
                return t / (2 * this.Fwn()) / this.xa(t)
            }
            return 1
        }
        TV(t) {
            FC.Ge(t),
            this.swn = t
        }
        bZ() {
            return this.swn
        }
        kV(t) {
            FC.Ge(t),
            this.nwn = t
        }
        IZ() {
            return this.nwn
        }
        IV(t) {
            FC.Ge(t),
            this.Zmn = t,
            this.Qmn = Math.tan(this.Zmn / 2)
        }
        Lwn() {
            return this.Zmn
        }
        Fwn() {
            return this.Qmn
        }
        bV() {
            this.ewn = !1
        }
        MV() {
            this.ewn = !0
        }
        Dwn() {
            return !this.ewn
        }
        Bwn() {
            return this.ewn
        }
        EV(t, i, e=.5, s=.5) {
            const n = this.bZ()
              , r = this.IZ()
              , h = this.Lwn();
            if (.5 === e && .5 === s)
                this.Zd() ? NC.jMe(t, h, i, n, r) : NC.perspective(t, h, i, n, r);
            else {
                const h = 2 * (e = 1 - e) - 2
                  , o = 2 * e
                  , a = 2 * s - 2
                  , l = 2 * s
                  , u = this.Fwn() * n
                  , c = u * i;
                NC.UMe(t, h * c, o * c, a * u, l * u, n, r),
                this.Zd() && NC.mul(t, YC, t)
            }
        }
        bzs(t, i, e, s=1) {
            const n = self.devicePixelRatio
              , r = 2 * this.xa(e) * n * this.Fwn() / e
              , h = i * r / (2 * n * s)
              , o = e * r / (2 * n * s)
              , a = -h
              , l = h
              , u = -o
              , c = o;
            this.Zd() ? NC.WMe(t, a, l, u, c, this.bZ(), this.IZ()) : NC.VMe(t, a, l, u, c, this.bZ(), this.IZ())
        }
        Gzs(t, i, e, s, n, r=1) {
            let h = 1;
            this.Dwn() && (h = 200 * this.Fwn() / n);
            const o = VC;
            BC.set(o, h, -h, 1);
            const a = $C
              , l = zC;
            BC.multiply(a, i, o),
            BC.multiply(l, e, o),
            NC.HMe(t, a, l, s || WC),
            o[2] = r,
            NC.scale(t, t, o)
        }
        mV(t, i, e, s, n, r, h, o) {
            return BC.set($C, t, i, e),
            BC.set(zC, s, n, r),
            this.Gzs(jC, $C, zC, WC, h, o),
            jC
        }
        Uwn(t) {
            this.rwn.push(t),
            this.hwn.set(t.Fa(), t)
        }
        Nwn(t) {
            const i = this.rwn.indexOf(t);
            -1 !== i && this.rwn.splice(i, 1),
            this.hwn.delete(t.Fa())
        }
        kwn() {
            FC.sc(this.rwn),
            this.hwn.clear()
        }
        xmn(t) {
            return this.hwn.get(t) || null
        }
        jwn() {
            return this.own
        }
        Yr() {
            this.Yw(this.own)
        }
        $wn() {
            return this.awn
        }
        zwn() {
            this.Yw(this.awn)
        }
        VT() {
            this.Yw(this.lwn)
        }
        IM() {
            this.Yw(this.uwn)
        }
        er() {
            this.Yw(this.cwn)
        }
        Vwn() {
            this.Yw(this.dwn)
        }
        Kg() {
            this.Yw(this.fwn)
        }
        Wwn() {
            this.Yw(this.pwn)
        }
        Hwn() {
            this.Yw(this.mwn)
        }
        Kwn() {
            this.Yw(this.wwn)
        }
        qwn() {
            this.Yw(this.gwn)
        }
        Wc() {
            this.Yw(this.ywn)
        }
        wmn(t) {
            this.vwn = t
        }
        Xwn() {
            return this.vwn
        }
        Ywn(t, i, e, s, n, r) {
            const h = FC.ra.cmn.ymn(t, i, e, s, n, r);
            let o = this.bwn.get(h);
            return o || (o = FC.v(FC.ra.cmn, this, t, i, e, s, n, r),
            this.bwn.set(h, o)),
            o.bmn(),
            o
        }
        Jwn(t) {
            t.vmn(),
            0 === t.Smn() && (this.vwn === t && (this.vwn = null),
            this.bwn.delete(t.gmn()),
            t.he())
        }
        Zwn(t) {
            FC.sc(this.Swn),
            this.xwn.clear();
            let i = 0;
            for (const e of t) {
                const t = e[0]
                  , s = e[1]
                  , n = e[2];
                this.Swn.push([s, n]),
                this.xwn.set(t, {
                    number: i,
                    Qwn: s,
                    tgn: n
                }),
                i++
            }
        }
        ign(t) {
            return this.Swn[t]
        }
        egn(t) {
            return this.ign(t)[0]
        }
        sgn(t) {
            return this.ign(t)[1]
        }
        ngn(t) {
            const i = this.xwn.get(t);
            if (void 0 === i)
                throw new Error("invalid blend name");
            return i
        }
        Fzs(t) {
            const i = this.xwn.get(t);
            if (void 0 === i)
                throw new Error("invalid blend name");
            return i.number
        }
        oK(t) {
            this.Mwn = t
        }
        rgn() {
            return this.Mwn
        }
        lK(t) {
            this.Ewn = t,
            this.vwn = null
        }
        hgn() {
            return this.Ewn
        }
        Ra(t, i, e, s) {
            const n = FC.fi(t, i, e, s)
              , r = Math.sin(n)
              , h = Math.cos(n)
              , o = .5 * this.Z6
              , a = r * o
              , l = h * o
              , u = this._wn;
            2 === u ? this.ogn(t, i, 0, e, s, 0, a, l) : 1 === u ? this.agn(t, i, 0, e, s, 0, a, l) : this.lgn(t, i, 0, e, s, 0, a, l)
        }
        Wo(t, i, e, s, n, r) {
            const h = FC.fi(t, i, s, n)
              , o = Math.sin(h)
              , a = Math.cos(h)
              , l = .5 * this.Z6
              , u = o * l
              , c = a * l
              , d = this._wn;
            2 === d ? this.ogn(t, i, e, s, n, r, u, c) : 1 === d ? this.agn(t, i, e, s, n, r, u, c) : this.lgn(t, i, e, s, n, r, u, c)
        }
        ogn(t, i, e, s, n, r, h, o) {
            const a = this.Iwn
              , l = t + a - o
              , u = i + a - h
              , c = s + a + o
              , d = n + a + h
              , f = 2 * o
              , p = 2 * h
              , m = l + h
              , w = u - o
              , g = l - h + f
              , y = u + o + p
              , b = c + h
              , v = d - o
              , S = c - h - f
              , x = d + o - p;
            this.ob(m, w, e, b, v, r, S, x, r, g, y, e, qC)
        }
        agn(t, i, e, s, n, r, h, o) {
            const a = this.Iwn
              , l = t + a - o
              , u = i + a - h
              , c = s + a + o
              , d = n + a + h
              , f = l + h
              , p = u - o
              , m = l - h
              , w = u + o
              , g = c + h
              , y = d - o
              , b = c - h
              , v = d + o;
            this.ob(f, p, e, g, y, r, b, v, r, m, w, e, qC)
        }
        lgn(t, i, e, s, n, r, h, o) {
            const a = this.Iwn
              , l = t + a
              , u = i + a
              , c = s + a
              , d = n + a
              , f = l + h
              , p = u - o
              , m = l - h
              , w = u + o
              , g = c + h
              , y = d - o
              , b = c - h
              , v = d + o;
            this.ob(f, p, e, g, y, r, b, v, r, m, w, e, qC)
        }
        YJs(t, i, e, s, n, r) {
            const h = FC.fi(t, i, e, s)
              , o = Math.sin(h)
              , a = Math.cos(h)
              , l = .5 * this.Z6
              , u = o * l
              , c = a * l
              , d = this._wn;
            2 === d ? this.ugn(t, i, e, s, u, c, n, r) : 1 === d ? this.cgn(t, i, e, s, u, c, n, r) : this.dgn(t, i, e, s, u, c, n, r)
        }
        ugn(t, i, e, s, n, r, h, o) {
            const a = this.Iwn
              , l = t + a - r
              , u = i + a - n
              , c = e + a + r
              , d = s + a + n
              , f = 2 * r
              , p = 2 * n
              , m = l + n
              , w = u - r
              , g = l - n + f
              , y = u + r + p
              , b = c + n
              , v = d - r
              , S = c - n - f
              , x = d + r - p;
            HC.set(m, w, b, v, S, x, g, y),
            KC.set(h, 0, o, 0),
            this.gr(HC, KC)
        }
        cgn(t, i, e, s, n, r, h, o) {
            const a = this.Iwn
              , l = t + a - r
              , u = i + a - n
              , c = e + a + r
              , d = s + a + n
              , f = l + n
              , p = u - r
              , m = l - n
              , w = u + r
              , g = c + n
              , y = d - r
              , b = c - n
              , v = d + r;
            HC.set(f, p, g, y, b, v, m, w),
            KC.set(h, 0, o, 0),
            this.gr(HC, KC)
        }
        dgn(t, i, e, s, n, r, h, o) {
            const a = this.Iwn
              , l = t + a
              , u = i + a
              , c = e + a
              , d = s + a
              , f = l + n
              , p = u - r
              , m = l - n
              , w = u + r
              , g = c + n
              , y = d - r
              , b = c - n
              , v = d + r;
            HC.set(f, p, g, y, b, v, m, w),
            KC.set(h, 0, o, 0),
            this.gr(HC, KC)
        }
        D9(t, i, e, s) {
            const n = .5 * this.Z6
              , r = this._wn;
            2 === r ? this.fgn(t, i, e, s, n) : 1 === r ? this.pgn(t, i, e, s, n) : this.mgn(t, i, e, s, n)
        }
        fgn(t, i, e, s, n) {
            this.ogn(t, i, 0, e, i, 0, 0, n),
            this.ogn(e, i, 0, e, s, 0, n, 0),
            this.ogn(e, s, 0, t, s, 0, 0, -n),
            this.ogn(t, s, 0, t, i, 0, -n, 0)
        }
        pgn(t, i, e, s, n) {
            this.agn(t, i, 0, e, i, 0, 0, n),
            this.agn(e, i, 0, e, s, 0, n, 0),
            this.agn(e, s, 0, t, s, 0, 0, -n),
            this.agn(t, s, 0, t, i, 0, -n, 0)
        }
        mgn(t, i, e, s, n) {
            this.lgn(t, i, 0, e, i, 0, 0, n),
            this.lgn(e, i, 0, e, s, 0, n, 0),
            this.lgn(e, s, 0, t, s, 0, 0, -n),
            this.lgn(t, s, 0, t, i, 0, -n, 0)
        }
        ta(t) {
            this.D9(t.Kr(), t.Zr(), t.gl(), t.wl())
        }
        $r(t) {
            const i = FC.fi(t.Jn(), t.Qn(), t.Hw(), t.rl())
              , e = Math.sin(i)
              , s = Math.cos(i)
              , n = .5 * this.Z6
              , r = e * n
              , h = s * n
              , o = this._wn;
            2 === o ? this.wgn(t, r, h) : 1 === o ? this.ggn(t, r, h) : this.ygn(t, r, h)
        }
        wgn(t, i, e) {
            this.ogn(t.Jn(), t.Qn(), 0, t.Hw(), t.rl(), 0, i, e),
            this.ogn(t.Hw(), t.rl(), 0, t.al(), t.ll(), 0, e, -i),
            this.ogn(t.al(), t.ll(), 0, t.zc(), t.Ec(), 0, -i, -e),
            this.ogn(t.zc(), t.Ec(), 0, t.Jn(), t.Qn(), 0, -e, i)
        }
        ggn(t, i, e) {
            this.agn(t.Jn(), t.Qn(), 0, t.Hw(), t.rl(), 0, i, e),
            this.agn(t.Hw(), t.rl(), 0, t.al(), t.ll(), 0, e, -i),
            this.agn(t.al(), t.ll(), 0, t.zc(), t.Ec(), 0, -i, -e),
            this.agn(t.zc(), t.Ec(), 0, t.Jn(), t.Qn(), 0, -e, i)
        }
        ygn(t, i, e) {
            this.lgn(t.Jn(), t.Qn(), 0, t.Hw(), t.rl(), 0, i, e),
            this.lgn(t.Hw(), t.rl(), 0, t.al(), t.ll(), 0, e, -i),
            this.lgn(t.al(), t.ll(), 0, t.zc(), t.Ec(), 0, -i, -e),
            this.lgn(t.zc(), t.Ec(), 0, t.Jn(), t.Qn(), 0, -e, i)
        }
        LV(t) {
            this.Z6 = t,
            this.Cwn[this.Cwn.length - 1] = t
        }
        SDi() {
            return this.Z6
        }
        Bc(t) {
            if (this.Cwn.length >= 100)
                throw new Error("pushed too many line widths - check push/pop pairs");
            this.Cwn.push(t),
            this.Z6 = t
        }
        Xc() {
            if (this.Cwn.length <= 1)
                throw new Error("cannot pop last line width - check push/pop pairs");
            this.Cwn.pop(),
            this.Z6 = this.Cwn.at(-1)
        }
        bgn() {
            this._wn = 0,
            this.Twn[this.Twn.length - 1] = 0
        }
        vgn() {
            this._wn = 1,
            this.Twn[this.Twn.length - 1] = 0
        }
        Sgn() {
            this._wn = 2,
            this.Twn[this.Twn.length - 1] = 0
        }
        xgn(t) {
            if (FC.zt(t),
            "butt" === t)
                this.Mgn();
            else if ("square" === t)
                this.Hc();
            else {
                if ("zag" !== t)
                    throw new Error("invalid line cap");
                this.o3()
            }
        }
        Mgn() {
            if (this.Twn.length >= 100)
                throw new Error("pushed too many line caps - check push/pop pairs");
            this.Twn.push(0),
            this._wn = 0
        }
        Hc() {
            if (this.Twn.length >= 100)
                throw new Error("pushed too many line caps - check push/pop pairs");
            this.Twn.push(1),
            this._wn = 1
        }
        o3() {
            if (this.Twn.length >= 100)
                throw new Error("pushed too many line caps - check push/pop pairs");
            this.Twn.push(2),
            this._wn = 2
        }
        Yc() {
            if (this.Twn.length <= 1)
                throw new Error("cannot pop last line cap - check push/pop pairs");
            this.Twn.pop(),
            this._wn = this.Twn.at(-1)
        }
        WV(t) {
            this.Iwn = t,
            this.Pwn[this.Pwn.length - 1] = t
        }
        Egn() {
            return this.Iwn
        }
        Uc(t) {
            if (this.Pwn.length >= 100)
                throw new Error("pushed too many line offsets - check push/pop pairs");
            this.Pwn.push(t),
            this.Iwn = t
        }
        $c() {
            if (this.Pwn.length <= 1)
                throw new Error("cannot pop last line offset - check push/pop pairs");
            this.Pwn.pop(),
            this.Iwn = this.Pwn.at(-1)
        }
        Wn() {
            this.Ww(0),
            this.Xw(0)
        }
        Qg(t) {
            const i = t.length / 2;
            if (i < 3)
                throw new Error("need at least 3 points");
            const e = i - 2
              , s = e - 1
              , n = t[0]
              , r = t[1];
            for (let i = 0; i < e; i += 2) {
                const e = 2 * i
                  , h = t[e + 2]
                  , o = t[e + 3]
                  , a = t[e + 4]
                  , l = t[e + 5];
                if (i === s)
                    this.Cgn(n, r, h, o, a, l, a, l);
                else {
                    const i = t[e + 6]
                      , s = t[e + 7];
                    this.Cgn(n, r, h, o, a, l, i, s)
                }
            }
        }
        qV() {
            this._gn(!0),
            this.Gwn++
        }
        Tgn() {
            return this.Gwn
        }
        Ign() {
            this.Gwn++
        }
        Pgn(t) {
            this.Awn = !!t
        }
        Ggn() {
            return this.Awn
        }
        S0(t) {
            this.Rwn = !!t
        }
        Agn() {
            return this.Rwn
        }
        Rgn() {
            return !1
        }
        Zd() {
            return !1
        }
        kgn() {
            FC.E4()
        }
        Ogn() {
            FC.E4()
        }
        Dgn() {
            FC.E4()
        }
        Fgn() {
            return this.kgn() + this.Ogn() + this.Dgn()
        }
        Lgn() {
            return FC.v(FC.ra.na, this)
        }
    }
}
{
    const JC = self.t;
    JC.ra.Bgn = class {
        constructor(t, i) {
            JC.U(t, JC.ra.RC),
            JC.zt(i.name),
            this.rVt = i.name,
            this.an = t,
            this.Ugn = i.Ngn || 0,
            this.jgn = i.$gn || 0,
            this.zgn = !!i.Vgn,
            this.Wgn = !!i.Hgn,
            this.Kgn = !!i.qgn,
            this.Xgn = !!i.Ygn,
            this.Jgn = !!i.animated,
            this.Zgn = !!i.wni,
            this.Qgn = !!i.bni,
            this.tyn = !1,
            this.iyn = this.zgn || this.Zgn || 0 !== this.Ugn || 0 !== this.jgn
        }
        he() {
            this.an = null
        }
        Mn() {
            return this.an
        }
        Fa() {
            return this.rVt
        }
        eyn() {
            return 0 !== this.Ugn || 0 !== this.jgn
        }
        syn() {
            return this.Ugn
        }
        nyn() {
            return this.jgn
        }
        yni() {
            return this.zgn
        }
        no() {
            return this.Wgn
        }
        ryn() {
            return this.Kgn
        }
        hyn() {
            return this.Xgn
        }
        oyn() {
            return this.Jgn
        }
        ils() {
            return this.Zgn
        }
        Sni() {
            return this.Qgn
        }
        ayn() {
            return this.tyn
        }
        lyn() {
            return this.iyn
        }
        uyn() {
            return !1
        }
    }
}
{
    const ZC = self.t
      , QC = 4096
      , t_ = 4
      , i_ = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"])
      , e_ = {
        timeout: 60
    }
      , s_ = new ZC.Ha(0,0,0,1)
      , n_ = new Set(["left", "center", "right"])
      , r_ = new Set(["top", "center", "bottom"])
      , h_ = new Set(["word", "cjk", "character"])
      , o_ = new Set(["ltr", "rtl"])
      , a_ = 1e3
      , l_ = 10
      , u_ = 2
      , c_ = new Set;
    function d_(t, i, e, s, n, r) {
        i ? t.strokeRect(e, s, n, r) : t.fillRect(e, s, n, r)
    }
    function f_(t, i) {
        t = t.trim();
        const e = parseFloat(t);
        return isFinite(e) ? t.endsWith("%") ? i * e / 100 : e : 0
    }
    ZC.PW && ZC.PW.addEventListener("fontload", t => {
        const i = t.font.Fa();
        for (const t of c_)
            (t.BC() || ZC._x(t.cyn(), i)) && t.cC()
    }
    );
    let p_ = !1
      , m_ = !1;
    ZC.ra.na = class {
        constructor(t, i) {
            ZC.U(t, ZC.ra.RC),
            ZC.Wat(i),
            i = Object.assign({}, e_, i),
            this.an = t,
            this.dyn = "Arial",
            this.D7s = 16,
            this.fyn = 1,
            this.$S = 0,
            this.pyn = !1,
            this.myn = !1,
            this.wyn = "black",
            this.DS = !1,
            this.BUe = null,
            this.gyn = !0,
            this.nM = null,
            this.yyn = new Set,
            this.BS = "left",
            this.US = "top",
            this._S = "",
            this.LS = null,
            this.NS = ZC.v(ZC.AS),
            this.FS = "word",
            this.byn = "ltr",
            this.zS = !1,
            this.ES = !1,
            this.vyn = !1,
            this.Syn = !1,
            this.YS = -1,
            this.qS = 0,
            this.jS = 0,
            this.RS = 0,
            this.ZC = 0,
            this.tv = 0,
            this.xyn = 1,
            this.Myn = null,
            this.Eyn = null,
            this.Cyn = null,
            this._yn = null,
            this.S_i = -1,
            this.v_i = -1,
            this.Tyn = "",
            this.Iyn = "",
            this.Pyn = "",
            this.Gyn = 1,
            this.Ayn = 1,
            this.JS = t => this.QS(t),
            this.Ryn = new Map,
            this.kyn = new ZC.oG( () => this.Oyn(!0),u_),
            this.Qs = null,
            this.Dyn = !0,
            this.Fyn = new ZC.Rect,
            this.Lyn = 1,
            this.prs = new ZC.oG( () => {
                this.mrs(),
                this.Byn(8, 8),
                this.Uyn()
            }
            ,i.timeout),
            this.aa = null,
            this.cn = !1,
            c_.add(this)
        }
        he() {
            this.nM = null,
            this.yyn.clear(),
            this.BUe = null,
            this.LS = null,
            this.Myn = null,
            this.Eyn = null,
            this.Cyn = null,
            this._yn = null,
            this.JS = null,
            this.Oyn(),
            this.kyn.he(),
            this.prs.he(),
            this.aa = null,
            this.mrs(),
            this.NS.tC(),
            this.NS = null,
            this.an = null,
            this.cn = !0,
            c_.delete(this)
        }
        Uyn() {
            this.vyn = !0
        }
        oC() {
            this.Uyn(),
            this.ES = !0
        }
        cC() {
            this.oC(),
            this.zS = !0
        }
        $a(t) {
            if (t = !!t,
            this.DS === t)
                return;
            this.DS = t;
            const i = this.DS ? "alphabetic" : "top";
            this.Eyn && (this.Eyn.textBaseline = i),
            this.Cyn && (this.Cyn.textBaseline = i),
            this.Oyn(),
            this.cC()
        }
        BC() {
            return this.DS
        }
        lM(t) {
            ZC.Mw(t, ZC.$Ue),
            this.BUe !== t && (this.BUe = t,
            this.NS.lM(t),
            this.BUe && this.BUe.kx() && this.BUe.Iri().then( () => this.Uyn()),
            this.cC())
        }
        oM(t) {
            t = !!t,
            this.gyn !== t && (this.gyn = t,
            this.Uyn())
        }
        cl(t) {
            ZC.zt(t),
            t || (t = "serif"),
            this.dyn !== t && (this.dyn = t,
            this.Oyn(),
            this.cC())
        }
        cyn() {
            return this.dyn
        }
        la(t) {
            ZC.Ge(t),
            t < .1 && (t = .1),
            this.D7s !== t && (this.D7s = t,
            this.Oyn(),
            this.cC())
        }
        Ilt() {
            return this.D7s
        }
        Nyn(t) {
            ZC.Ge(t),
            this.fyn !== t && (this.fyn = t,
            this.Oyn(),
            this.cC())
        }
        xS(t) {
            ZC.Ge(t),
            this.$S !== t && (this.$S = t,
            this.oC())
        }
        XC() {
            return this.$S
        }
        cM(t) {
            t = !!t,
            this.pyn !== t && (this.pyn = t,
            this.Oyn(),
            this.cC())
        }
        jyn() {
            return this.pyn
        }
        Xa(t) {
            t = !!t,
            this.myn !== t && (this.myn = t,
            this.Oyn(),
            this.cC())
        }
        $yn() {
            return this.myn
        }
        uC(t) {
            ZC.Ge(t),
            t = Math.floor(t),
            this.YS !== t && (this.YS = t,
            this.Uyn())
        }
        pC() {
            return this.YS
        }
        zyn(t, i) {
            let e = [];
            (this.pyn || i.NC("b")) && e.push("bold"),
            (this.myn || i.NC("i")) && e.push("italic");
            const s = i.sC("size")
              , n = (s ? parseFloat(s.nC) : this.D7s) * this.fyn;
            t ? e.push(n + "pt") : e.push(n * this.Vyn() + "pt");
            let r = this.dyn;
            const h = i.sC("font");
            return h && h.nC && (r = h.nC,
            this.nM && !this.yyn.has(r) && (this.nM(r),
            this.yyn.add(r))),
            r && (i_.has(r) ? e.push(r) : e.push('"' + r + '"')),
            e.join(" ")
        }
        Xn(t) {
            t instanceof ZC.Ha && (t = t.MDe()),
            ZC.zt(t),
            this.wyn !== t && (this.wyn = t,
            this.Uyn())
        }
        da(t, i, e) {
            ZC.Ge(t),
            ZC.Ge(i),
            ZC.Ge(e),
            s_.Eo(t, i, e),
            this.Xn(s_)
        }
        ca(t) {
            if (ZC.zt(t),
            !n_.has(t))
                throw new Error("invalid horizontal alignment");
            this.BS !== t && (this.BS = t,
            this.oC())
        }
        Wyn() {
            return this.BS
        }
        ua(t) {
            if (ZC.zt(t),
            !r_.has(t))
                throw new Error("invalid vertical alignment");
            this.US !== t && (this.US = t,
            this.oC())
        }
        Hyn() {
            return this.US
        }
        mS(t) {
            if (!h_.has(t))
                throw new Error("invalid word wrap mode");
            this.FS !== t && (this.FS = t,
            this.Oyn(),
            this.cC())
        }
        Kyn() {
            return this.FS
        }
        uM(t) {
            if (ZC.zt(t),
            !o_.has(t))
                throw new Error("invalid text direction");
            this.byn !== t && (this.byn = t,
            this.Eyn && (this.Eyn.direction = this.byn),
            this.Cyn && (this.Cyn.direction = this.byn),
            this.Oyn(),
            this.cC())
        }
        qyn() {
            return this.byn
        }
        pa(t) {
            ZC.zt(t),
            this._S !== t && (this._S = t,
            this.Oyn(),
            this.cC())
        }
        VB() {
            return this._S
        }
        Vyn() {
            return this.Lyn * this.xyn * self.devicePixelRatio
        }
        aM(t) {
            t = !!t,
            this.Dyn !== t && (this.Dyn = t,
            this.Syn = !0)
        }
        Xyn() {
            return this.Dyn
        }
        Hr(t, i, e) {
            if (ZC.Ge(t),
            ZC.Ge(i),
            ZC.cO(e),
            void 0 === e && (e = 1),
            t <= 0 || t <= 0)
                return;
            if (this.jS === t && this.RS === i && this.xyn === e)
                return;
            const s = this.jS;
            this.jS = t,
            this.RS = i,
            this.xyn = e;
            const n = self.devicePixelRatio;
            this.ZC = this.jS * this.xyn * n,
            this.tv = this.RS * this.xyn * n;
            const r = Math.max(this.ZC, this.tv)
              , h = Math.min(this.an.Yyn(), QC);
            let o = 1;
            r > h && (o = h / r,
            this.ZC = Math.min(this.ZC * o, h),
            this.tv = Math.min(this.tv * o, h)),
            this.Lyn = o,
            this.jS !== s ? this.cC() : this.oC()
        }
        ns() {
            return this.ZC
        }
        Kn() {
            return this.tv
        }
        rM() {
            return this.xyn
        }
        $C() {
            return this.fC(),
            this.NS.YC()
        }
        qC() {
            return this.fC(),
            this.NS.wNe() + this.NS.JC() * (this.$S + t_) - this.$S
        }
        Jyn() {
            this.fC();
            let t = 0;
            for (const i of this.NS.mC())
                for (const e of i.wC())
                    t += e.zUe();
            return t
        }
        Gn() {
            return this.prs.Bg(),
            this.Zyn(),
            this.Qs
        }
        dC(t, i) {
            this.fC();
            const e = this.Vyn()
              , s = this.NS.mC();
            for (const n of s) {
                const s = n.sNe() * e;
                if (i >= n.gC() - n.Kn() * e + s && i < n.gC() + s)
                    for (const i of n.wC())
                        if (t >= i.bC() && t < i.bC() + i.ns() * e)
                            return i
            }
            return null
        }
        *yC(t) {
            this.fC();
            const i = this.NS.mC();
            for (const e of i)
                for (const i of e.wC()) {
                    const e = i.sC("tag");
                    e && ZC._x(e.nC, t) && (yield i)
                }
        }
        xC(t, i) {
            for (const e of this.yC(t)) {
                if (0 === i)
                    return e;
                --i
            }
            return null
        }
        SC(t) {
            let i = 0;
            for (const e of this.yC(t))
                ++i;
            return i
        }
        Zyn() {
            (!this.Qs || this.vyn || this.ES || this.zS || this.Syn) && (this.cn || this.ZC <= 0 || this.tv <= 0 || this.Qyn())
        }
        Qyn() {
            this.cn || (this.fC(),
            this.Byn(Math.max(ZC.ha(Math.ceil(this.ZC)), 128), Math.max(ZC.ha(Math.ceil(this.tv)), 64)),
            this.tbn(),
            this.ibn(),
            this.prs.Bg())
        }
        Byn(t, i) {
            this.Myn || (this.Myn = ZC.GS(16, 16));
            let e = !1;
            this.S_i === t && this.v_i === i || (this.S_i = t,
            this.v_i = i,
            this.Myn.width = t,
            this.Myn.height = i,
            e = !0),
            this.Eyn || (this.Eyn = this.Myn.getContext("2d"),
            e = !0),
            e ? (this.Eyn.textBaseline = this.DS ? "alphabetic" : "top",
            this.Eyn.direction = this.byn,
            this.Eyn.font = this.Tyn,
            this.Eyn.fillStyle = this.Pyn,
            this.Eyn.strokeStyle = this.Pyn,
            this.Eyn.globalAlpha = this.Gyn,
            this.Eyn.lineWidth = this.Ayn) : this.Eyn.clearRect(0, 0, t, i)
        }
        ebn() {
            this.Cyn || (this.Cyn = ZC.GS(16, 16).getContext("2d"),
            this._yn = ZC.GS(16, 16).getContext("2d"),
            this.Cyn.textBaseline = this.DS ? "alphabetic" : "top",
            this._yn.textBaseline = "top",
            this.Cyn.direction = this.byn,
            this._yn.direction = this.byn)
        }
        sbn(t) {
            this.Iyn !== t && (this.Iyn = t,
            this.Cyn.font = t,
            this._yn.font = t)
        }
        nbn() {
            if (!p_) {
                p_ = !0,
                this.ebn();
                const t = this.Cyn.measureText("test");
                m_ = "number" == typeof t.fontBoundingBoxAscent && "number" == typeof t.fontBoundingBoxDescent
            }
            return m_
        }
        fC() {
            this.CC(),
            this.vC()
        }
        CC() {
            this.zS && (this.ebn(),
            !this.DS || this.LS && this.LS.toString() === this._S || (this.LS = new ZC.MC(this._S,{
                IC: !0
            })),
            this.kyn.Bg(),
            this.NS.AS(this.DS ? this.LS.TC() : this._S, this.JS, this.jS, this.FS, 0),
            this.zS = !1)
        }
        vC() {
            this.ES && (this.OC(),
            this.ES = !1)
        }
        Oyn(t) {
            this.Ryn.clear(),
            t || this.kyn.cu()
        }
        rbn(t, i) {
            const e = this.Ryn;
            if (e.set(t, i),
            e.size > a_) {
                let t = 0;
                for (const i of e.keys())
                    if (e.delete(i),
                    t++,
                    t >= l_)
                        break
            }
        }
        QS(t) {
            const i = t.OUe() ? t.iC().join("") : " "
              , e = this.zyn(!0, t)
              , s = e + "|" + i
              , n = this.Ryn;
            let r = n.get(s);
            if (r)
                return n.delete(s),
                n.set(s, r),
                r;
            this.sbn(e);
            const h = this.Cyn.measureText(i);
            let o = 0;
            if (this.DS && this.nbn()) {
                const t = this._yn.measureText(i);
                o = h.fontBoundingBoxAscent - t.fontBoundingBoxAscent
            }
            const a = t.sC("size")
              , l = (a ? parseFloat(a.nC) : this.D7s) * this.fyn;
            var u;
            return r = {
                width: h.width,
                height: (u = l,
                u * (4 / 3)),
                fontBoundingBoxAscent: h.fontBoundingBoxAscent || 0,
                fontBoundingBoxDescent: h.fontBoundingBoxDescent || 0,
                IUe: o
            },
            this.rbn(s, r),
            r
        }
        hbn(t) {
            this.Tyn !== t && (this.Tyn = t,
            this.Eyn.font = t)
        }
        obn(t) {
            this.Pyn !== t && (this.Pyn = t,
            this.Eyn.fillStyle = t,
            this.Eyn.strokeStyle = t)
        }
        abn(t) {
            this.Gyn !== t && (this.Gyn = t,
            this.Eyn.globalAlpha = t)
        }
        lbn(t) {
            this.Ayn !== t && (this.Ayn = t,
            this.Eyn.lineWidth = t)
        }
        OC() {
            const t = this.Vyn()
              , i = (t_ + this.$S) * t;
            let e = 0;
            const s = this.NS.mC();
            if (0 === s.length)
                return;
            for (const t of s) {
                t.VC(NaN),
                t.kC(NaN);
                for (const i of t.wC())
                    i.VC(NaN),
                    i.kC(NaN)
            }
            const n = this.DS && this.nbn();
            let r = s[0].Kn() * t;
            if ("center" === this.US) {
                const h = s.reduce( (e, s) => e + s.Kn() * t + i, 0) - i;
                e = Math.max(this.tv / 2 - h / 2, 0),
                n && (r = s[0].nNe() * t)
            } else if ("bottom" === this.US) {
                const r = s.reduce( (e, s) => e + s.Kn() * t + i, 0) - this.$S * t
                  , h = n ? s.at(-1).sNe() * t : 0;
                e = this.tv - r - h - 2
            }
            for (let n = 0, h = s.length; n < h; ++n) {
                const h = s[n]
                  , o = h.Kn() * t
                  , a = e;
                if (this.DS) {
                    if (e += 0 === n ? r : o,
                    n > 0 && e > this.tv - t_ * t)
                        break
                } else if (n > 0 && e >= this.tv - o)
                    break;
                a >= 0 && this.GC(h, e, t),
                this.DS || (e += o),
                e += i
            }
        }
        GC(t, i, e) {
            let s = 0;
            "center" === this.BS ? s = Math.floor((this.ZC - t.ns() * e) / 2) : "right" === this.BS && (s = this.ZC - t.ns() * e),
            t.VC(s),
            t.kC(i);
            for (const n of "ltr" === this.byn ? t.wC() : t.xNe())
                this.ubn(n, s, i, e),
                s += n.ns() * e
        }
        ubn(t, i, e, s) {
            const n = t.sC("offsetx");
            i += n ? f_(n.nC, t.Kn()) * s : 0;
            const r = t.sC("offsety");
            if (e += r ? f_(r.nC, t.Kn()) * s : 0,
            t.eC()) {
                const i = t.sC("iconoffsety");
                e += i ? f_(i.nC, t.Kn()) * s : .2 * t.Kn() * s
            }
            t.VC(i),
            t.kC(e)
        }
        tbn() {
            if (!this.vyn)
                return;
            this.Eyn.imageSmoothingEnabled = this.gyn,
            this.Eyn.imageSmoothingQuality = "high",
            this.qS = 0;
            const t = this.Vyn()
              , i = this.NS.mC();
            for (const e of i)
                this.cbn(e, t);
            this.vyn = !1
        }
        cbn(t, i) {
            const e = t.bC()
              , s = t.gC();
            if (Number.isFinite(e) && Number.isFinite(s))
                for (const e of "ltr" === this.byn ? t.wC() : t.xNe())
                    this.DC(e, i, t.Kn())
        }
        DC(t, i, e) {
            const s = this.Eyn
              , n = t.bC()
              , r = t.gC();
            if (!Number.isFinite(n) || !Number.isFinite(r))
                return;
            const h = e / 16;
            let o = t.ns() * i;
            const a = t.Kn() * i
              , l = t.Kn() / 16
              , u = (t_ + this.$S) * i;
            let c = t.OUe() ? t.iC() : null;
            if (-1 !== this.YS) {
                if (this.qS >= this.YS)
                    return;
                t.OUe() && this.qS + c.length > this.YS && (c = c.slice(0, this.YS - this.qS),
                o = this.QS(t).width * i),
                this.qS += t.zUe()
            }
            const d = t.sC("background")
              , f = t.NC("u")
              , p = t.NC("s");
            if (t.OUe() && ZC.LC(c) && !d && !f && !p || t.NC("hide"))
                return;
            const m = t.sC("color")
              , w = t.sC("opacity");
            this.abn(w ? parseFloat(w.nC) / 100 : 1),
            d && (this.obn(d.nC),
            s.fillRect(n, r - a, o, a + u));
            const g = t.sC("linethickness")
              , y = g ? parseFloat(g.nC) : 1
              , b = t.NC("stroke");
            if (b && this.lbn(.5 * l * y * this.Vyn()),
            t.OUe()) {
                const i = c.join("");
                if (this.hbn(this.zyn(!1, t)),
                !b) {
                    this.lbn(.5 * l * y * this.Vyn());
                    const e = t.sC("outlineback");
                    e && (this.obn(e.nC),
                    this.dbn(!0, i, n, r, o))
                }
                if (this.obn(m ? m.nC : this.wyn),
                this.dbn(b, i, n, r, o),
                !b) {
                    this.lbn(.5 * l * y * this.Vyn());
                    const e = t.sC("outline");
                    e && (this.obn(e.nC),
                    this.dbn(!0, i, n, r, o))
                }
            } else if (t.eC() && t.ns() > 0) {
                const i = t.gn(this.BUe);
                i && s.drawImage(i, n, r - a, o, a)
            }
            if (this.obn(m ? m.nC : this.wyn),
            f && d_(s, b, n, r + i * h, o, i * h * y),
            p) {
                const t = i * l
                  , e = r - a / 4 + t / 2;
                s.fillRect(n, e - t * y / 2, o, t * y)
            }
        }
        dbn(t, i, e, s, n) {
            "rtl" === this.byn && (e += n),
            t ? "Gecko" === ZC.kt.NRe ? this.Eyn.strokeText(i, e, s, n) : this.Eyn.strokeText(i, e, s) : "Gecko" === ZC.kt.NRe ? this.Eyn.fillText(i, e, s, n) : this.Eyn.fillText(i, e, s)
        }
        ibn() {
            this.an.un() || (this.Qs && !this.Syn || (this.mrs(),
            this.Qs = this.an.sK(this.Myn.width, this.Myn.height, {
                wc: this.Dyn,
                bc: "high"
            }),
            this.Syn = !1),
            this.an.eK(this.Myn, this.Qs),
            this.Fyn.set(0, 0, this.ZC / this.Qs.ns(), this.tv / this.Qs.Kn()),
            this.aa && this.aa())
        }
        Jr() {
            return this.Fyn
        }
        mrs() {
            this.Qs && (this.an.un() || this.an.pn(this.Qs),
            this.Qs = null)
        }
        static Vs() {
            for (const t of c_)
                t.mrs()
        }
        static fbn() {
            return c_.values()
        }
    }
}
{
    const w_ = globalThis.t
      , g_ = globalThis.assert
      , y_ = 65535;
    function b_(t, i, e) {
        const s = e.Jn()
          , n = e.Qn()
          , r = e.Hw() - s
          , h = e.rl() - n;
        return [s + r * t + (e.zc() - s) * i, n + h * t + (e.Ec() - n) * i]
    }
    w_.ra.KZ = class {
        constructor(t, i, e) {
            this.Mmn = t,
            this.Emn = i,
            this.lcn = e,
            this.kd = NaN,
            this.Gd = NaN,
            this.mys = NaN,
            this._u = NaN,
            this._v = NaN,
            this.kd = 0,
            this.Gd = 0,
            this.mys = 0,
            this._u = 0,
            this._v = 0
        }
        cxs(t, i, e, s) {
            this.kd = t,
            this.Gd = i,
            this._u = e,
            this._v = s
        }
        _a() {
            return this.kd
        }
        kp(t) {
            this.kd !== t && (this.kd = t,
            this.Mmn.Cmn())
        }
        Da() {
            return this.Gd
        }
        Gp(t) {
            this.Gd !== t && (this.Gd = t,
            this.Mmn.Cmn())
        }
        aK() {
            return this.mys
        }
        Qne(t) {
            this.mys !== t && (this.mys = Math.max(t, 0),
            this.Mmn.Cmn())
        }
        B3() {
            return this._u
        }
        t8(t) {
            this._u = t
        }
        Y3() {
            return this._v
        }
        i8(t) {
            this._v = t
        }
        _mn(t, i, e) {
            [this.kd,this.Gd] = b_(t.kd, t.Gd, i),
            this.mys = t.mys,
            this._u = w_.mi(e.Kr(), e.gl(), t._u),
            this._v = w_.mi(e.Zr(), e.wl(), t._v)
        }
        Tmn(t, i, e) {
            [this.kd,this.Gd] = b_(t.kd, t.Gd, i),
            this.mys = t.mys,
            [this._u,this._v] = b_(t._u, t._v, e)
        }
        wO() {
            return {
                x: this._a(),
                y: this.Da(),
                z: this.aK(),
                u: this.B3(),
                v: this.Y3()
            }
        }
        xfs(t) {
            this.kp(t.x),
            this.Gp(t.y),
            t.hasOwnProperty("z") && this.Qne(t.z),
            this.t8(t.u),
            this.i8(t.v)
        }
        So() {
            return this.Mmn
        }
        lle() {
            return this.Emn
        }
        cle() {
            return this.lcn
        }
    }
    ,
    w_.ra.OCs = class {
        constructor(t, i, e) {
            if (t < 2 || i < 2)
                throw new Error("invalid mesh size");
            this.Imn = t,
            this.Pmn = i,
            this.HIs = e || null,
            this.Gmn = [],
            this.Amn = 0,
            this.Rmn = 0,
            this.kmn = 1,
            this.Omn = 1,
            this.Dmn = 0,
            this.Fmn = !1,
            this.Lmn = [],
            this.Bmn = 0,
            this.Umn = !0;
            const s = t - 1
              , n = i - 1;
            for (let e = 0; e < i; ++e) {
                const i = [];
                for (let r = 0; r < t; ++r) {
                    const t = w_.v(w_.ra.KZ, this, r, e)
                      , h = r / s
                      , o = e / n;
                    t.cxs(h, o, h, o),
                    i.push(t)
                }
                this.Gmn.push(i)
            }
        }
        he() {
            w_.sc(this.Gmn),
            w_.sc(this.Lmn)
        }
        ka() {
            return this.Imn
        }
        Ga() {
            return this.Pmn
        }
        mte() {
            return this.HIs
        }
        UCs() {
            return this.Gmn
        }
        Cmn() {
            this.Fmn = !0,
            this.Umn = !0
        }
        Nmn() {
            if (!this.Fmn)
                return;
            let t = 1 / 0
              , i = 1 / 0
              , e = -1 / 0
              , s = -1 / 0
              , n = 0;
            for (const r of this.Gmn)
                for (const h of r) {
                    const r = h._a()
                      , o = h.Da();
                    t = Math.min(t, r),
                    i = Math.min(i, o),
                    e = Math.max(e, r),
                    s = Math.max(s, o),
                    n = Math.max(n, h.aK())
                }
            this.Amn = t,
            this.Rmn = i,
            this.kmn = e,
            this.Omn = s,
            this.Dmn = n,
            this.Fmn = !1
        }
        Gtt() {
            return this.Nmn(),
            this.Amn
        }
        Ott() {
            return this.Nmn(),
            this.Rmn
        }
        Ctt() {
            return this.Nmn(),
            this.kmn
        }
        Rtt() {
            return this.Nmn(),
            this.Omn
        }
        jmn() {
            return this.Nmn(),
            this.Dmn
        }
        Gni() {
            return this.jmn() > 0
        }
        ja(t, i) {
            return t = Math.floor(t),
            i = Math.floor(i),
            t < 0 || t >= this.Imn || i < 0 || i >= this.Pmn ? null : this.Gmn[i][t]
        }
        RCs(t, i, e) {
            w_.U(t, w_.ra.OCs),
            w_.U(i, w_.Nn),
            w_.cT(e, w_.Rect, w_.Nn);
            const s = e instanceof w_.Rect;
            if (t.ka() !== this.ka() || t.Ga() !== this.Ga())
                throw new Error("source mesh wrong size");
            const n = t.Gmn
              , r = this.Gmn;
            for (let t = 0, h = r.length; t < h; ++t) {
                const h = n[t]
                  , o = r[t];
                for (let t = 0, n = o.length; t < n; ++t) {
                    const n = h[t]
                      , r = o[t];
                    s ? r._mn(n, i, e) : r.Tmn(n, i, e)
                }
            }
            this.Umn = !0
        }
        $mn(t) {
            if (!this.Umn && this.Bmn === t)
                return;
            const i = this.Imn
              , e = this.Pmn
              , s = this.Lmn
              , n = Math.floor(y_ / i) - 1;
            if (n <= 0)
                throw new Error("mesh too large");
            const r = Math.ceil((e - 1) / n);
            r < s.length && (s.length = r);
            let h = 0;
            for (let o = 0; o < r; ++o) {
                const r = Math.min(n, e - h - 1);
                g_(r > 0, "invalid mesh chunk");
                const a = (r + 1) * i
                  , l = 3 * a
                  , u = 2 * a
                  , c = (i - 1) * r * 6;
                if (o === s.length)
                    s.push({
                        zmn: new Float32Array(l),
                        Vmn: new Float32Array(u),
                        Wmn: new Uint16Array(c)
                    });
                else {
                    const t = s[o];
                    t.zmn.length !== l && (t.zmn = new Float32Array(l)),
                    t.Vmn.length !== u && (t.Vmn = new Float32Array(u)),
                    t.Wmn.length !== c && (t.Wmn = new Uint16Array(c))
                }
                const {zmn: d, Vmn: f, Wmn: p} = s[o];
                this.Hmn(h, r, t, d, f, p),
                h += n
            }
            this.Bmn = t,
            this.Umn = !1
        }
        Hmn(t, i, e, s, n, r) {
            const h = this.Gmn
              , o = this.Imn;
            let a = 0
              , l = 0
              , u = 0;
            for (let c = t, d = t + i + 1; c < d; ++c) {
                const i = h[c]
                  , f = c + 1
                  , p = c - t
                  , m = p * o
                  , w = (p + 1) * o;
                for (let t = 0, h = i.length; t < h; ++t) {
                    const o = i[t]
                      , c = t + 1;
                    if (s[a++] = o._a(),
                    s[a++] = o.Da(),
                    s[a++] = o.aK() + e,
                    n[l++] = o.B3(),
                    n[l++] = o.Y3(),
                    c < h && f < d) {
                        const i = t + m
                          , e = c + m
                          , s = c + w
                          , n = t + w;
                        r[u++] = i,
                        r[u++] = e,
                        r[u++] = s,
                        r[u++] = i,
                        r[u++] = s,
                        r[u++] = n
                    }
                }
            }
        }
        Un(t, i) {
            this.$mn(i);
            for (const {zmn: i, Vmn: e, Wmn: s} of this.Lmn)
                t.jo(i, e, s)
        }
        LGs(t, i) {
            i || (i = (t, i, e) => [t, i, e]);
            const e = this.Gmn;
            let s = e[0];
            for (let n = 1, r = e.length; n < r; ++n) {
                const h = e[n];
                let o = s[0]
                  , a = h[0];
                for (let e = 1, l = h.length; e < l; ++e) {
                    const u = s[e]
                      , c = h[e]
                      , [d,f,p] = i(o._a(), o.Da(), o.aK())
                      , [m,w,g] = i(u._a(), u.Da(), u.aK())
                      , [y,b,v] = i(c._a(), c.Da(), c.aK())
                      , [S,x,M] = i(a._a(), a.Da(), a.aK());
                    t.Wo(d, f, p, m, w, g),
                    t.Wo(d, f, p, y, b, v),
                    t.Wo(d, f, p, S, x, M),
                    e === l - 1 && t.Wo(m, w, g, y, b, v),
                    n === r - 1 && t.Wo(S, x, M, y, b, v),
                    o = u,
                    a = c
                }
                s = h
            }
        }
        zbs(t) {
            const i = .001
              , e = .99999999
              , s = t.Aps()
              , n = []
              , r = this.ka() - 1
              , h = this.Ga() - 1
              , o = 1 / r
              , a = 1 / h
              , l = r - 1
              , u = h - 1;
            let c = s[0]
              , d = s[1]
              , f = w_.Ne(Math.floor(c * r), 0, l)
              , p = w_.Ne(Math.floor(d * h), 0, u)
              , m = !0
              , w = 0
              , g = 0
              , y = 0;
            let b = -1;
            const v = () => {
                c = w_.Ne(w_.mi(c, w, y), 0, 1),
                d = w_.Ne(w_.mi(d, g, y), 0, 1),
                n.push(c, d)
            }
            ;
            for (let t = 0, S = s.length; t < S; t += 2) {
                c = s[t],
                d = s[t + 1],
                n.push(c, d),
                f = w_.Ne(Math.floor(c * r), 0, l),
                p = w_.Ne(Math.floor(d * h), 0, u);
                const x = (t + 2) % S;
                for (w = s[x],
                g = s[x + 1],
                b = -1; ; ) {
                    if (n.length > 1e6)
                        throw new Error("Too many mesh poly points");
                    const t = f * o
                      , s = p * a
                      , r = (f + 1) * o
                      , h = (p + 1) * a;
                    if (m = w_.sDe(c, d, t, s, r, s, r, h),
                    0 !== b && (y = w_.eDe(c, d, w, g, t, s, r, h, -.001),
                    y >= 0 && y <= e))
                        v(),
                        m = !m,
                        b = 0;
                    else if (p > 0 && 2 !== b && (y = w_.eDe(c, d, w, g, t, s, r, s, i),
                    y >= 0 && y <= e))
                        v(),
                        p--,
                        m = !1,
                        b = 4;
                    else if (f < l && 3 !== b && (y = w_.eDe(c, d, w, g, r, s, r, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f++,
                        m = !1,
                        b = 1;
                    else if (f > 0 && 1 !== b && (y = w_.eDe(c, d, w, g, t, s, t, h, i),
                    y >= 0 && y <= e))
                        v(),
                        f--,
                        m = !0,
                        b = 3;
                    else {
                        if (!(p < u && 4 !== b && (y = w_.eDe(c, d, w, g, t, h, r, h, i),
                        y >= 0 && y <= e)))
                            break;
                        v(),
                        p++,
                        m = !0,
                        b = 2
                    }
                }
            }
            return w_.v(w_.Hm, n)
        }
        Wbs(t, i) {
            const e = this.Kmn(t);
            this.qmn(e),
            i._ps(e)
        }
        Kmn(t) {
            const i = []
              , e = t.Aps();
            for (let t = 0, s = e.length; t < s; t += 2) {
                const s = e[t]
                  , n = e[t + 1]
                  , [r,h] = this.Xmn(s, n);
                i.push(r, h)
            }
            return i
        }
        Xmn(t, i) {
            const e = this.ka() - 1
              , s = this.Ga() - 1
              , n = 1 / e
              , r = 1 / s
              , h = w_.Ne(Math.floor(t * e), 0, e - 1)
              , o = w_.Ne(Math.floor(i * s), 0, s - 1)
              , a = h * n
              , l = o * r
              , u = (h + 1) * n
              , c = (o + 1) * r
              , d = this.ja(h, o)
              , f = this.ja(h + 1, o + 1)
              , p = w_.sDe(t, i, a, l, u, l, u, c)
              , m = p ? a + n : a
              , w = p ? l : l + r
              , g = this.ja(h + (p ? 1 : 0), o + (p ? 0 : 1))
              , [y,b,v] = w_.nDe(t, i, a, l, m, w, u, c);
            return w_.rDe(y, b, v, d._a(), d.Da(), d.aK(), g._a(), g.Da(), g.aK(), f._a(), f.Da(), f.aK())
        }
        qmn(t) {
            const i = []
              , e = 1e-7;
            let s = t[0]
              , n = t[1]
              , r = s - t.at(-2)
              , h = n - t.at(-1);
            for (let o = 0, a = t.length; o < a; o += 2) {
                const l = (o + 2) % a
                  , u = t[l]
                  , c = t[l + 1]
                  , d = u - s
                  , f = c - n
                  , p = Math.abs(d) < e && Math.abs(r) < e && Math.sign(f) === Math.sign(h)
                  , m = Math.abs(f) < e && Math.abs(h) < e && Math.sign(d) === Math.sign(r);
                (!p && !m && Math.abs(d / r - f / h) > .001 || 0 == d && 0 === f) && i.push(s, n),
                s = u,
                n = c,
                r = d,
                h = f
            }
            i.length >= 6 && i.length < t.length && w_.lw(t, i)
        }
        wO() {
            return {
                cols: this.ka(),
                rows: this.Ga(),
                points: this.Gmn.map(t => t.map(t => t.wO()))
            }
        }
        xfs(t) {
            const i = this.ka()
              , e = this.Ga();
            if (t.cols !== i || t.rows !== e)
                throw new Error("mesh data wrong size");
            const s = t.points;
            for (let t = 0; t < e; ++t) {
                const e = s[t];
                for (let s = 0; s < i; ++s) {
                    this.ja(s, t).xfs(e[s])
                }
            }
        }
    }
}
{
    const v_ = self.t
      , S_ = self.sG.eG
      , x_ = new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
    v_.ra.pbn = class {
        constructor(t, i, e) {
            if (!x_.has(e))
                throw new Error("invalid uniform type");
            this.HIs = t,
            this.mbn = this.HIs.wbn(),
            this.rVt = i,
            this.lVt = e,
            this.gbn = "color" === this.lVt,
            this.ybn = this.mbn.getUniformLocation(this.HIs.Als(), i),
            this.bbn = !!this.ybn;
            const s = x_.get(e);
            this.O8e = new Float32Array(s),
            this.vbn = new Float32Array(s)
        }
        he() {
            this.HIs = null,
            this.mbn = null,
            this.ybn = null
        }
        Sbn() {
            return this.bbn
        }
        Vdt() {
            return this.lVt
        }
        xbn() {
            return this.gbn
        }
        Mbn(t) {
            this.Sbn() && (this.O8e[0] = t,
            this.vbn.set(this.O8e),
            this.mbn.uniform1f(this.ybn, t))
        }
        Ebn(t) {
            this.Sbn() && (this.O8e[0] = t,
            this.vbn.set(this.O8e),
            this.mbn.uniform1i(this.ybn, t))
        }
        Cbn(t, i) {
            this.Sbn() && (this.O8e[0] = t,
            this.O8e[1] = i,
            this.vbn.set(this.O8e),
            this.mbn.uniform2f(this.ybn, t, i))
        }
        _bn(t, i, e) {
            this.Sbn() && (this.O8e[0] = t,
            this.O8e[1] = i,
            this.O8e[2] = e,
            this.vbn.set(this.O8e),
            this.mbn.uniform3f(this.ybn, t, i, e))
        }
        Tbn(t, i, e, s) {
            this.Sbn() && (this.O8e[0] = t,
            this.O8e[1] = i,
            this.O8e[2] = e,
            this.O8e[3] = s,
            this.vbn.set(this.O8e),
            this.mbn.uniform4f(this.ybn, t, i, e, s))
        }
        Ibn(t) {
            t = Math.fround(t);
            const i = this.O8e;
            i[0] !== t && (i[0] = t,
            this.mbn.uniform1f(this.ybn, t))
        }
        Pbn(t) {
            const i = this.O8e;
            i[0] !== t && (i[0] = t,
            this.mbn.uniform1i(this.ybn, t))
        }
        Gbn(t, i) {
            t = Math.fround(t),
            i = Math.fround(i);
            const e = this.O8e;
            e[0] === t && e[1] === i || (e[0] = t,
            e[1] = i,
            this.mbn.uniform2f(this.ybn, t, i))
        }
        Abn(t, i, e) {
            t = Math.fround(t),
            i = Math.fround(i),
            e = Math.fround(e);
            const s = this.O8e;
            s[0] === t && s[1] === i && s[2] === e || (s[0] = t,
            s[1] = i,
            s[2] = e,
            this.mbn.uniform3f(this.ybn, t, i, e))
        }
        Rbn(t, i, e, s) {
            t = Math.fround(t),
            i = Math.fround(i),
            e = Math.fround(e),
            s = Math.fround(s);
            const n = this.O8e;
            n[0] === t && n[1] === i && n[2] === e && n[3] === s || (n[0] = t,
            n[1] = i,
            n[2] = e,
            n[3] = s,
            this.mbn.uniform4f(this.ybn, t, i, e, s))
        }
        kbn(t) {
            const i = this.O8e;
            S_.wMe(i, t) || (v_.Lke(i, t, 0),
            this.mbn.uniformMatrix4fv(this.ybn, !1, t))
        }
        Obn(t) {
            const i = this.vbn;
            return this.xbn() ? i[0] === Math.fround(t.getR()) && i[1] === Math.fround(t.getG()) && i[2] === Math.fround(t.getB()) : i[0] === Math.fround(t)
        }
        Dbn(t) {
            const i = this.vbn;
            this.xbn() ? (i[0] = t.getR(),
            i[1] = t.getG(),
            i[2] = t.getB()) : i[0] = t
        }
        Fbn(t) {
            return this.vbn[0] === Math.fround(t)
        }
        Lbn(t, i) {
            const e = this.vbn;
            return e[0] === Math.fround(t) && e[1] === Math.fround(i)
        }
        Bbn(t) {
            this.vbn[0] = t
        }
        Ubn(t, i) {
            const e = this.vbn;
            e[0] = t,
            e[1] = i
        }
    }
}
{
    const M_ = self.t
      , E_ = self.sG
      , C_ = (E_.hG,
    E_.eG,
    new Set(["aPos", "aTex", "aColor", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar"]));
    M_.ra.Nbn = class extends M_.ra.Bgn {
        static async jbn(t, i) {
            const e = t.dMt()
              , s = i.src
              , n = i.$bn
              , r = i.name
              , h = e.createShader(e.FRAGMENT_SHADER);
            e.shaderSource(h, s),
            e.compileShader(h);
            const o = e.createShader(e.VERTEX_SHADER);
            e.shaderSource(o, n),
            e.compileShader(o);
            const a = e.createProgram();
            e.attachShader(a, h),
            e.attachShader(a, o),
            e.bindAttribLocation(a, 0, "aPos"),
            e.bindAttribLocation(a, 1, "aTex"),
            e.bindAttribLocation(a, 2, "aColor"),
            e.bindAttribLocation(a, 3, "aPoints"),
            e.linkProgram(a);
            const l = t.zbn();
            if (l ? await t.Vbn( () => e.getProgramParameter(a, l.COMPLETION_STATUS_KHR)) : await M_.KTi(5),
            !e.getShaderParameter(h, e.COMPILE_STATUS)) {
                const t = e.getShaderInfoLog(h);
                throw e.deleteShader(h),
                e.deleteShader(o),
                e.deleteProgram(a),
                new Error("Error compiling fragment shader: " + t)
            }
            if (!e.getShaderParameter(o, e.COMPILE_STATUS)) {
                const t = e.getShaderInfoLog(o);
                throw e.deleteShader(h),
                e.deleteShader(o),
                e.deleteProgram(a),
                new Error("Error compiling vertex shader: " + t)
            }
            if (!e.getProgramParameter(a, e.LINK_STATUS)) {
                const t = e.getProgramInfoLog(a);
                throw e.deleteShader(h),
                e.deleteShader(o),
                e.deleteProgram(a),
                new Error("Error linking shader program: " + t)
            }
            const u = M_.pBe(e.getProgramInfoLog(a) || "").trim();
            return u && !M_.dBe(u) && console.info(`[WebGL] Shader program '${r}' compilation log: `, u),
            e.deleteShader(h),
            e.deleteShader(o),
            a
        }
        static async y_(t, i) {
            const e = await M_.ra.Nbn.jbn(t, i);
            return new M_.ra.Nbn(t,e,i)
        }
        constructor(t, i, e) {
            super(t, e);
            const s = t.dMt()
              , n = t.Wbn();
            t._gn(),
            s.useProgram(i),
            this.mbn = s,
            this.dmn = i,
            this.Hbn = "<default-device-transform>" === e.name;
            const r = s.getAttribLocation(i, "aPos")
              , h = s.getAttribLocation(i, "aTex")
              , o = s.getAttribLocation(i, "aColor");
            this.Kbn = s.getAttribLocation(i, "aPoints"),
            -1 !== r && (s.bindBuffer(s.ARRAY_BUFFER, t.qbn),
            s.vertexAttribPointer(r, 3, s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(r)),
            -1 !== h && (s.bindBuffer(s.ARRAY_BUFFER, t.Xbn),
            s.vertexAttribPointer(h, 2, s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(h)),
            -1 !== o && (s.bindBuffer(s.ARRAY_BUFFER, t.Ybn),
            s.vertexAttribPointer(o, 4, t.Jbn() ? s.HALF_FLOAT : s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(o)),
            -1 !== this.Kbn && (s.bindBuffer(s.ARRAY_BUFFER, t.Zbn),
            s.vertexAttribPointer(this.Kbn, 4, s.FLOAT, !1, 0, 0),
            s.enableVertexAttribArray(this.Kbn)),
            s.bindBuffer(s.ARRAY_BUFFER, null),
            this.Qbn = new M_.ra.pbn(this,"matP","mat4"),
            this.tvn = new M_.ra.pbn(this,"matMV","mat4"),
            this.ivn = new M_.ra.pbn(this,"color","vec4"),
            this.evn = new M_.ra.pbn(this,"samplerFront","sampler"),
            this.svn = new M_.ra.pbn(this,"pointTexStart","vec2"),
            this.nvn = new M_.ra.pbn(this,"pointTexEnd","vec2"),
            this.rvn = new M_.ra.pbn(this,"zElevation","float"),
            this.hvn = new M_.ra.pbn(this,"tileSize","vec2"),
            this.ovn = new M_.ra.pbn(this,"tileSpacing","vec2"),
            this.avn = new M_.ra.pbn(this,"color2_","vec4"),
            this.lvn = new M_.ra.pbn(this,"outlineThickness","float"),
            this.uvn = new M_.ra.pbn(this,"samplerBack","sampler"),
            this.cvn = new M_.ra.pbn(this,"samplerDepth","sampler"),
            this.dvn = new M_.ra.pbn(this,"destStart","vec2"),
            this.fvn = new M_.ra.pbn(this,"destEnd","vec2"),
            this.pvn = new M_.ra.pbn(this,"srcStart","vec2"),
            this.mvn = new M_.ra.pbn(this,"srcEnd","vec2"),
            this.wvn = new M_.ra.pbn(this,"srcOriginStart","vec2"),
            this.gvn = new M_.ra.pbn(this,"srcOriginEnd","vec2"),
            this.yvn = new M_.ra.pbn(this,"pixelSize","vec2"),
            this.bvn = new M_.ra.pbn(this,"seconds","float"),
            this.vvn = new M_.ra.pbn(this,"devicePixelRatio","float"),
            this.Svn = new M_.ra.pbn(this,"layerScale","float"),
            this.xvn = new M_.ra.pbn(this,"layerAngle","float"),
            this.Mvn = new M_.ra.pbn(this,"layoutStart","vec2"),
            this.Evn = new M_.ra.pbn(this,"layoutEnd","vec2"),
            this.Cvn = new M_.ra.pbn(this,"zNear","float"),
            this._vn = new M_.ra.pbn(this,"zFar","float"),
            this.Tvn = !!(this.yvn.Sbn() || this.bvn.Sbn() || this.uvn.Sbn() || this.dvn.Sbn() || this.fvn.Sbn() || this.pvn.Sbn() || this.mvn.Sbn() || this.wvn.Sbn() || this.gvn.Sbn() || this.vvn.Sbn() || this.Svn.Sbn() || this.xvn.Sbn() || this.Mvn.Sbn() || this.Evn.Sbn());
            const a = e.parameters || [];
            this.Ivn = [],
            this.tyn = this.yvn.Sbn() || this.pvn.Sbn() || this.mvn.Sbn() || this.wvn.Sbn() || this.gvn.Sbn(),
            this.Pvn = !1,
            this.Gvn = !1,
            this.ivn.Tbn(1, 1, 1, 1),
            this.avn.Tbn(1, 1, 1, 1),
            this.evn.Ebn(0),
            this.uvn.Ebn(1),
            this.cvn.Ebn(2),
            this.svn.Cbn(0, 0),
            this.nvn.Cbn(1, 1),
            this.rvn.Mbn(0),
            this.hvn.Cbn(0, 0),
            this.ovn.Cbn(0, 0),
            this.dvn.Cbn(0, 0),
            this.fvn.Cbn(1, 1),
            this.pvn.Cbn(0, 0),
            this.mvn.Cbn(0, 0),
            this.wvn.Cbn(0, 0),
            this.gvn.Cbn(0, 0),
            this.yvn.Cbn(0, 0),
            this.vvn.Mbn(1),
            this.Cvn.Mbn(t.bZ()),
            this._vn.Mbn(t.IZ()),
            this.Svn.Mbn(1),
            this.xvn.Mbn(0),
            this.bvn.Mbn(0),
            this.Mvn.Cbn(0, 0),
            this.Evn.Cbn(0, 0),
            this.lvn.Mbn(1);
            for (const t of a) {
                const i = t[0]
                  , e = t[2]
                  , s = new M_.ra.pbn(this,i,e);
                "color" === e ? s._bn(0, 0, 0) : s.Mbn(0),
                this.Ivn.push(s)
            }
            this.Hbn ? this.Avn(n.Rvn) : (this.kvn(n.Rvn, !0),
            this.Ovn(n.Dvn, !0));
            const l = n.Fvn;
            s.useProgram(l ? l.dmn : null)
        }
        he() {
            this.mbn.deleteProgram(this.dmn),
            this.dmn = null,
            this.an.Nwn(this),
            this.mbn = null,
            super.he()
        }
        wbn() {
            return this.mbn
        }
        Als() {
            return this.dmn
        }
        IKt() {
            return this.Ivn.length
        }
        Lvn(t) {
            return t < 0 || t >= this.Ivn.length ? null : this.Ivn[t].Vdt()
        }
        Bvn(t) {
            for (let i = 0, e = t.length; i < e; ++i)
                if (!this.Ivn[i].Obn(t[i]))
                    return !1;
            return !0
        }
        Uvn(t) {
            for (let i = 0, e = t.length; i < e; ++i)
                this.Ivn[i].Dbn(t[i])
        }
        Nvn(t, i, e, s, n, r, h, o, a, l) {
            return !this.uvn.Sbn() && (!(this.yvn.Sbn() && !this.yvn.Lbn(n, r)) && (!(this.dvn.Sbn() && !this.dvn.Lbn(t.Kr(), t.Zr())) && (!(this.fvn.Sbn() && !this.fvn.Lbn(t.gl(), t.wl())) && (!(this.vvn.Sbn() && !this.vvn.Fbn(h)) && (!(this.Svn.Sbn() && !this.Svn.Fbn(o)) && (!(this.xvn.Sbn() && !this.xvn.Fbn(a)) && (!(this.pvn.Sbn() && !this.pvn.Lbn(i.Kr(), i.Zr())) && (!(this.mvn.Sbn() && !this.mvn.Lbn(i.gl(), i.wl())) && (!(this.wvn.Sbn() && !this.wvn.Lbn(e.Kr(), e.Zr())) && (!(this.gvn.Sbn() && !this.gvn.Lbn(e.gl(), e.wl())) && (!(this.Mvn.Sbn() && !this.Mvn.Lbn(s.Kr(), s.Zr())) && (!(this.Evn.Sbn() && !this.Evn.Lbn(s.Zr(), s.wl())) && !(this.bvn.Sbn() && !this.bvn.Fbn(l))))))))))))))
        }
        jvn(t, i, e, s, n, r, h, o, a, l) {
            this.uvn.Sbn() || (this.yvn.Sbn() && this.yvn.Ubn(n, r),
            this.dvn.Sbn() && this.dvn.Ubn(t.Kr(), t.Zr()),
            this.fvn.Sbn() && this.fvn.Ubn(t.gl(), t.wl()),
            this.vvn.Sbn() && this.vvn.Bbn(h),
            this.Svn.Sbn() && this.Svn.Bbn(o),
            this.xvn.Sbn() && this.xvn.Bbn(a),
            this.pvn.Sbn() && this.pvn.Ubn(i.Kr(), i.Zr()),
            this.mvn.Sbn() && this.mvn.Ubn(i.gl(), i.wl()),
            this.wvn.Sbn() && this.wvn.Ubn(e.Kr(), e.Zr()),
            this.gvn.Sbn() && this.gvn.Ubn(e.gl(), e.wl()),
            this.Mvn.Sbn() && this.Mvn.Ubn(s.Kr(), s.Zr()),
            this.Evn.Sbn() && this.Evn.Ubn(s.Zr(), s.wl()),
            this.bvn.Sbn() && this.bvn.Bbn(l))
        }
        kvn(t, i) {
            this.Pvn && !i || this.Hbn || (this.Qbn.Sbn() && this.Qbn.kbn(t),
            this.Pvn = !0)
        }
        $vn() {
            this.Pvn = !1
        }
        Ovn(t, i) {
            this.Gvn && !i || this.Hbn || (this.tvn.Sbn() && this.tvn.kbn(t),
            this.Gvn = !0)
        }
        zvn() {
            this.Gvn = !1
        }
        Avn(t) {
            if (!this.Hbn)
                throw new Error("not device transform shader");
            this.Qbn.kbn(t);
            const i = this.an
              , e = i.ns() / 2
              , s = i.Kn() / 2
              , n = i.mV(e, s, i.xa(i.Kn()), e, s, 0, i.Kn());
            this.tvn.kbn(n)
        }
        jSi(t) {
            this.ivn.Sbn() && this.ivn.Rbn(t[0], t[1], t[2], t[3])
        }
        static Vvn() {
            return C_
        }
        static Wvn(t) {
            return t ? "\n#extension GL_EXT_conservative_depth : enable\nlayout (depth_greater) out highp float gl_FragDepth;\n\t" : ""
        }
        static Hvn(t) {
            const i = t ? "highp" : "mediump";
            return ["attribute highp vec3 aPos;", `attribute ${i} vec2 aTex;`, `varying ${i} vec2 vTex;`, "attribute lowp vec4 aColor;", "varying lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPos, 1.0);", "\tvTex = aTex;", "\tvColor = aColor;", "}"].join("\n")
        }
        static Kvn(t) {
            const i = t ? "highp" : "mediump";
            return ["#version 300 es", "in highp vec3 aPos;", `in ${i} vec2 aTex;`, `out ${i} vec2 vTex;`, "in lowp vec4 aColor;", "out lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPos, 1.0);", "\tvTex = aTex;", "\tvColor = aColor;", "}"].join("\n")
        }
        static qvn() {
            return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * vColor;", "}"].join("\n")
        }
        static Xvn() {
            return ["#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * vColor;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static Yvn(t) {
            return ["#version 300 es", M_.ra.Nbn.Wvn(t), "in mediump vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\toutColor = texture(samplerFront, vTex) * vColor;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static Jvn() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "}"].join("\n")
        }
        static Zvn() {
            return ["#extension GL_EXT_frag_depth : enable", "varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static Qvn(t) {
            return ["#version 300 es", M_.ra.Nbn.Wvn(t), "in highp vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static tSn(t, i, e, s) {
            let n = "";
            return t >= 2 ? n = "#version 300 es\n" + M_.ra.Nbn.Wvn(s) : (i && (n = "#extension GL_EXT_frag_depth : enable\n"),
            e && (n += "#extension GL_EXT_shader_texture_lod : enable\n",
            n += "#extension GL_OES_standard_derivatives : enable\n")),
            n + `\nprecision highp float;\n${t >= 2 ? "in" : "varying"} vec2 vTex;\n${t >= 2 ? "out lowp vec4 outColor;" : ""}\n${t >= 2 ? "in" : "varying"} lowp vec4 vColor;\nuniform lowp sampler2D samplerFront;\nuniform vec2 pixelSize;\n\nuniform vec2 tileSize;\nuniform vec2 tileSpacing;\nuniform float outlineThickness;\n\nconst float PI = 3.1415926;\n\nlowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)\n{\n\treturn (a + b + (a - b) * cos(x * PI)) / 2.0;\n}\n\nvec3 randVec3(vec2 seed)\n{\n\treturn vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));\n}\n\nlowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)\n{\n\tvec2 posRandom = tileSize;\n\tfloat angleRandom = outlineThickness;\n\t\n\tvec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;\n\t\n\tfloat angle = angleRandom * rand.z * PI;\n\tfloat sin_a = sin(angle);\n\tfloat cos_a = cos(angle);\n\tfloat aspect = pixelSize.x / pixelSize.y;\n\n\tvec2 mid = tile + vec2(0.5, 0.5);\n\tvec2 dp = uv - mid;\n\tdp.x /= aspect;\n\tvec2 r = vec2(dp.x * cos_a - dp.y * sin_a,\n\t\t\t\t  dp.y * cos_a + dp.x * sin_a);\n\tr.x *= aspect;\n\n\tvec2 p = mid + r + (posRandom * rand.xy / 2.0);\n\t\n\t${t >= 2 ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}\n\t${t < 2 && e ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}\n\t${t < 2 && !e ? "return texture2D(samplerFront, p);" : ""}\n}\n\nvoid main(void) {\n\t\n\t${t < 2 ? "lowp vec4 outColor;" : ""}\n\t\n\tfloat blendMarginX = tileSpacing.x;\n\tfloat blendMarginY = tileSpacing.y;\n\t\n\tvec2 tile = floor(vTex);\n\tvec2 tex = fract(vTex);\n\tvec2 ddx = ${t >= 2 || e ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};\n\tvec2 ddy = ${t >= 2 || e ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};\n\t\n\tvec4 curTile = sampleTile(tile, vTex, ddx, ddy);\n\t\n\tbool inLeftMargin = (tex.x < blendMarginX);\n\tbool inRightMargin = (tex.x > 1.0 - blendMarginX);\n\tbool inTopMargin = (tex.y < blendMarginY);\n\tbool inBottomMargin = (tex.y > 1.0 - blendMarginY);\n\t\n\tif (inLeftMargin)\n\t{\n\t\tlowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;\n\t\tlowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = leftMixedTile;\n\t\t}\n\t}\n\telse if (inRightMargin)\n\t{\n\t\tlowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);\n\t\tlowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = rightMixedTile;\n\t\t}\n\t}\n\telse if (inTopMargin)\n\t{\n\t\tlowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t}\n\telse if (inBottomMargin)\n\t{\n\t\tlowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t}\n\telse\n\t{\n\t\toutColor = curTile;\n\t}\n\t\n\toutColor *= vColor;\n\t${t < 2 ? "gl_FragColor = outColor;" : ""}\n\t${t >= 2 ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}\n\t${t < 2 && i ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}\n}\n`
        }
        static iSn() {
            return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}"].join("\n")
        }
        static eSn() {
            return ["#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}"].join("\n")
        }
        static sSn() {
            return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}"].join("\n")
        }
        static nSn() {
            return ["#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static rSn(t) {
            return ["#version 300 es", M_.ra.Nbn.Wvn(t), "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n")
        }
        static hSn() {
            return ["varying lowp vec4 vColor;", "void main(void) {", "\tgl_FragColor = vColor;", "}"].join("\n")
        }
        static oSn() {
            return ["precision lowp float;", "varying mediump vec2 vTex;", "varying vec4 vColor;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "\tvec3 lower = linearRGB * vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "\tvec3 lower = sRGB/vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "\tvec3 linearGrad = mix(toLinear(vColor.rgb), toLinear(color2_.rgb), vTex.x);", "\tfloat a = mix(vColor.a, color2_.a, vTex.x);", "\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join("\n")
        }
        static aSn() {
            return ["precision lowp float;", "varying highp vec2 vTex;", "varying vec4 vColor;", "void main(void) {", "\thighp float grad = vTex.x / (1.0 - vTex.y);", "\tgl_FragColor = vColor * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);", "}"].join("\n")
        }
        static lSn() {
            return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "\tgl_FragColor = vColor * f;", "}"].join("\n")
        }
        static uSn() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp float f = step(diffSq.x + diffSq.y, 0.25);", "\tgl_FragColor = vColor * f;", "}"].join("\n")
        }
        static cSn() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp float distSq = diffSq.x + diffSq.y;", "\thighp vec2 norm = normalize(diff);", "\thighp vec2 halfNorm = norm * 0.5;", "\thighp float innerF = step(distSq, 0.25);", "\thighp vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "\thighp vec2 innerEdgeSq = innerEdge * innerEdge;", "\thighp float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "\tgl_FragColor = vColor * innerF * outerF;", "}"].join("\n")
        }
        static dSn() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp vec2 norm = normalize(diff);", "\thighp vec2 halfNorm = norm * 0.5;", "\thighp vec2 halfNormSq = halfNorm * halfNorm;", "\thighp vec2 innerEdge = halfNorm - pixelSize * norm;", "\thighp vec2 innerEdgeSq = innerEdge * innerEdge;", "\thighp float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "\tgl_FragColor = vColor * f;", "}"].join("\n")
        }
        static fSn() {
            return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "\thighp vec2 diff = vTex - vec2(0.5, 0.5);", "\thighp vec2 diffSq = diff * diff;", "\thighp float distSq = diffSq.x + diffSq.y;", "\thighp vec2 norm = normalize(diff);", "\thighp vec2 halfNorm = norm * 0.5;", "\thighp vec2 halfNormSq = halfNorm * halfNorm;", "\thighp vec2 pxNorm = pixelSize * norm;", "\thighp vec2 innerEdge1 = halfNorm - pxNorm;", "\thighp vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "\thighp float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "\thighp vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "\thighp vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "\thighp vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "\thighp vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "\thighp float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "\tgl_FragColor = vColor * innerF * outerF;", "}"].join("\n")
        }
    }
}
{
    const __ = self.t
      , T_ = self.sG
      , I_ = (T_.dys,
    T_.eG)
      , P_ = 1
      , G_ = 2
      , A_ = 3
      , R_ = 4
      , k_ = 5
      , O_ = 6
      , D_ = 7
      , F_ = 8
      , L_ = 9
      , B_ = 10
      , U_ = 11
      , N_ = 12
      , j_ = 13
      , $_ = 14
      , z_ = 15
      , V_ = 16
      , W_ = 17
      , H_ = 18
      , K_ = 19
      , q_ = 20
      , X_ = 21
      , Y_ = 22
      , J_ = 23
      , Z_ = 24
      , Q_ = 25
      , tT = 26
      , iT = 27
      , eT = 28
      , sT = 29
      , nT = 30;
    __.ra.pSn = class {
        constructor(t) {
            this.II = t,
            this.Dvn = I_.create(),
            this.Rvn = I_.create(),
            this.mSn = null,
            this.wSn = null,
            this.gSn = !1,
            this.Fvn = null,
            this.ySn = new __.Rect,
            this.clearColor = __.v(__.Ha, 0, 0, 0, 0)
        }
    }
    ,
    __.ra.bSn = class {
        constructor(t) {
            const i = new ArrayBuffer(96);
            this.lVt = 0,
            this.vSn = t,
            this.mbn = t.II.dMt(),
            this.SSn = 0,
            this.xSn = 0,
            this.MSn = null,
            this.ESn = new Float32Array(i,0,16),
            this.CSn = new Float32Array(i,64,4),
            this._Sn = new Float32Array(i,80,4),
            this.TSn = []
        }
        ISn(t, i) {
            this.lVt = P_,
            this.SSn = t,
            this.xSn = i
        }
        PSn() {
            const t = this.mbn;
            t.drawElements(t.TRIANGLES, this.xSn, t.UNSIGNED_SHORT, this.SSn)
        }
        GSn(t) {
            this.lVt = G_,
            this.MSn = t
        }
        ASn() {
            const t = this.mbn
              , i = this.MSn;
            t.bindTexture(t.TEXTURE_2D, i ? i.RSn() : null)
        }
        kSn(t) {
            this.lVt = q_,
            t.uDe(this.CSn, 0)
        }
        OSn() {
            const t = this.CSn
              , i = this.vSn.Fvn;
            i.avn.Sbn() && i.avn.Rbn(t[0], t[1], t[2], t[3])
        }
        DSn(t, i) {
            this.lVt = A_,
            this.SSn = t,
            this.xSn = i
        }
        FSn() {
            this.mbn.blendFunc(this.SSn, this.xSn)
        }
        LSn(t, i, e, s) {
            this.lVt = R_;
            const n = this.CSn;
            n[0] = t,
            n[1] = i,
            n[2] = e,
            n[3] = s
        }
        BSn() {
            const t = this.CSn;
            this.mbn.viewport(t[0], t[1], t[2], t[3])
        }
        USn(t) {
            this.lVt = k_,
            I_.ia(this.ESn, t)
        }
        NSn() {
            const t = this.vSn
              , i = t.II.rwn
              , e = t.Fvn
              , s = this.ESn;
            for (let t = 0, n = i.length; t < n; ++t) {
                const n = i[t];
                n === e ? n.kvn(s, !0) : n.$vn()
            }
            I_.ia(t.Rvn, s)
        }
        jSn(t) {
            this.lVt = O_,
            I_.ia(this.ESn, t)
        }
        $Sn() {
            const t = this.vSn
              , i = t.II.rwn
              , e = t.Fvn
              , s = this.ESn;
            for (let t = 0, n = i.length; t < n; ++t) {
                const n = i[t];
                n === e ? n.Ovn(s, !0) : n.zvn()
            }
            I_.ia(t.Dvn, s)
        }
        zSn(t) {
            this.lVt = D_,
            this.MSn = t
        }
        VSn() {
            const t = this.mbn
              , i = this.MSn
              , e = this.vSn;
            i ? (e.mSn = i.WSn(),
            e.wSn = i.HSn(),
            e.gSn && e.wSn ? t.bindFramebuffer(t.FRAMEBUFFER, e.wSn) : t.bindFramebuffer(t.FRAMEBUFFER, e.mSn)) : (e.mSn = null,
            e.wSn = null,
            t.bindFramebuffer(t.FRAMEBUFFER, null))
        }
        KSn(t) {
            this.lVt = F_,
            t.uDe(this.ESn, 0)
        }
        qSn(t, i, e, s) {
            this.lVt = F_;
            const n = this.ESn;
            n[0] = t,
            n[1] = i,
            n[2] = e,
            n[3] = s
        }
        XSn() {
            const t = this.mbn
              , i = this.ESn
              , e = this.vSn.clearColor
              , s = i[0]
              , n = i[1]
              , r = i[2]
              , h = i[3];
            e.RGs(s, n, r, h) || (t.clearColor(s, n, r, h),
            e.CIs(s, n, r, h)),
            t.clear(t.COLOR_BUFFER_BIT)
        }
        YSn(t) {
            this.lVt = $_,
            t.uDe(this.ESn, 0)
        }
        JSn() {
            const t = this.ESn;
            this.vSn.ySn.set(t[0], t[1], t[2], t[3])
        }
        ZSn(t, i, e) {
            this.lVt = L_,
            this.SSn = t,
            this.xSn = 1,
            this.ESn[0] = i,
            e.uDe(this.CSn, 0)
        }
        QSn() {
            const t = this.mbn
              , i = this.vSn
              , e = i.II.awn;
            t.useProgram(e.dmn),
            e.kvn(i.Rvn, !1),
            e.Ovn(i.Dvn, !1);
            const s = i.ySn;
            e.svn.Sbn() && e.svn.Gbn(s.Kr(), s.Zr()),
            e.nvn.Sbn() && e.nvn.Gbn(s.gl(), s.wl());
            const n = this.ESn[0];
            if (e.rvn.Sbn() && e.rvn.Ibn(n),
            e.ivn.Sbn()) {
                const t = this.CSn;
                e.ivn.Rbn(t[0], t[1], t[2], t[3])
            }
            t.drawArrays(t.POINTS, this.SSn / 4, this.xSn),
            t.useProgram(i.Fvn.dmn)
        }
        txn(t) {
            this.lVt = B_,
            this.MSn = t
        }
        ixn() {
            const t = this.mbn
              , i = this.vSn
              , e = this.MSn;
            i.Fvn = e,
            t.useProgram(e.dmn),
            e.kvn(i.Rvn, !1),
            e.Ovn(i.Dvn, !1)
        }
        exn() {
            this.lVt = U_
        }
        sxn() {
            const t = this.vSn.Fvn
              , i = this.mbn
              , e = this.ESn
              , s = this.CSn
              , n = this._Sn;
            if (t.uvn.Sbn()) {
                const t = this.vSn.II
                  , e = this.MSn;
                t.nxn !== e && (i.activeTexture(i.TEXTURE1),
                i.bindTexture(i.TEXTURE_2D, e ? e.RSn() : null),
                t.nxn = e,
                i.activeTexture(i.TEXTURE0))
            }
            t.yvn.Sbn() && t.yvn.Gbn(e[0], e[1]),
            t.dvn.Sbn() && t.dvn.Gbn(e[2], e[3]),
            t.fvn.Sbn() && t.fvn.Gbn(e[4], e[5]),
            t.vvn.Sbn() && t.vvn.Ibn(this.xSn),
            t.Svn.Sbn() && t.Svn.Ibn(e[6]),
            t.xvn.Sbn() && t.xvn.Ibn(e[7]),
            t.pvn.Sbn() && t.pvn.Gbn(e[12], e[13]),
            t.mvn.Sbn() && t.mvn.Gbn(e[14], e[15]),
            t.wvn.Sbn() && t.wvn.Gbn(n[0], n[1]),
            t.gvn.Sbn() && t.gvn.Gbn(n[2], n[3]),
            t.Mvn.Sbn() && t.Mvn.Gbn(s[0], s[1]),
            t.Evn.Sbn() && t.Evn.Gbn(s[2], s[3]),
            t.bvn.Sbn() && t.bvn.Ibn(this.SSn)
        }
        rxn() {
            this.lVt = N_
        }
        hxn() {
            const t = this.vSn.Fvn.Ivn
              , i = this.TSn;
            for (let e = 0, s = t.length; e < s; ++e) {
                const s = t[e]
                  , n = i[e];
                s.xbn() ? s.Abn(n.getR(), n.getG(), n.getB()) : s.Ibn(n)
            }
        }
        oxn(t) {
            this.lVt = j_,
            this.MSn = t
        }
        axn() {
            const t = this.mbn
              , i = this.MSn
              , e = this.vSn.mSn;
            i !== e && t.bindFramebuffer(t.FRAMEBUFFER, i),
            t.invalidateFramebuffer(t.FRAMEBUFFER, [t.COLOR_ATTACHMENT0]),
            i !== e && t.bindFramebuffer(t.FRAMEBUFFER, e)
        }
        lxn(t, i, e) {
            this.lVt = V_;
            const s = this.ESn
              , n = this.vSn.II;
            s[0] = t.ns(),
            s[1] = t.Kn(),
            s[2] = i ? i.ns() : n.ns(),
            s[3] = i ? i.Kn() : n.Kn(),
            s[4] = t.T0() ? 1 : 0,
            s[5] = "stretch" === e;
            const r = this.TSn;
            __.sc(r),
            r.push(t.WSn()),
            r.push(i ? i.WSn() : null)
        }
        uxn() {
            const t = this.ESn
              , i = this.TSn
              , e = this.mbn
              , s = t[0]
              , n = t[1]
              , r = t[2]
              , h = t[3]
              , o = 0 !== t[4]
              , a = 0 !== t[5]
              , l = i[0]
              , u = i[1];
            if (e.bindFramebuffer(e.READ_FRAMEBUFFER, l),
            e.bindFramebuffer(e.DRAW_FRAMEBUFFER, u),
            a)
                e.blitFramebuffer(0, 0, s, n, 0, 0, r, h, e.COLOR_BUFFER_BIT, o ? e.LINEAR : e.NEAREST);
            else {
                const t = Math.min(s, r)
                  , i = Math.min(n, h)
                  , o = Math.max(n - h, 0)
                  , a = Math.max(h - n, 0);
                e.blitFramebuffer(0, o, t, i + o, 0, a, t, i + a, e.COLOR_BUFFER_BIT, e.NEAREST)
            }
        }
        cxn(t) {
            this.lVt = W_,
            this.MSn = t
        }
        dxn() {
            this.MSn.fxn(),
            this.MSn = null
        }
        pxn(t) {
            this.lVt = H_,
            this.MSn = t
        }
        mxn() {
            this.MSn.wxn(),
            this.MSn = null
        }
        gxn(t, i, e) {
            this.lVt = K_;
            const s = this.ESn;
            s[0] = t,
            s[1] = i,
            s[2] = e
        }
        yxn() {
            const t = this.vSn.Fvn
              , i = this.ESn;
            t.yvn.Sbn() && t.yvn.Gbn(i[0], i[1]),
            t.lvn.Sbn() && t.lvn.Ibn(i[2])
        }
        bxn(t, i, e, s, n, r, h) {
            this.lVt = z_;
            const o = this.ESn;
            t.uDe(o, 0),
            o[4] = 1 / i,
            o[5] = 1 / e,
            o[6] = s / i,
            o[7] = n / e,
            o[8] = r / i,
            o[9] = h / e
        }
        vxn() {
            const t = this.vSn.Fvn
              , i = this.ESn;
            t.pvn.Sbn() && t.pvn.Gbn(i[0], i[1]),
            t.yvn.Sbn() && t.yvn.Gbn(i[4], i[5]),
            t.hvn.Sbn() && t.hvn.Gbn(i[6], i[7]),
            t.ovn.Sbn() && t.ovn.Gbn(i[8], i[9])
        }
        Sxn(t, i, e, s, n, r, h) {
            this.lVt = eT;
            const o = this.ESn;
            o[0] = 1 / t,
            o[1] = 1 / i,
            o[2] = e,
            o[3] = s,
            o[4] = n,
            o[5] = r,
            o[6] = h
        }
        xxn() {
            const t = this.vSn.Fvn
              , i = this.ESn;
            t.yvn.Sbn() && t.yvn.Gbn(i[0], i[1]),
            t.hvn.Sbn() && t.hvn.Gbn(i[2], i[3]),
            t.lvn.Sbn() && t.lvn.Ibn(i[4]),
            t.ovn.Sbn() && t.ovn.Gbn(i[5], i[6])
        }
        Mxn(t) {
            this.lVt = X_,
            this.SSn = t ? 1 : 0
        }
        Exn() {
            const t = this.mbn
              , i = 0 !== this.SSn;
            i || t.depthMask(!0),
            t.clear(t.DEPTH_BUFFER_BIT),
            i || t.depthMask(!1)
        }
        Cxn(t) {
            this.lVt = Y_,
            this.SSn = t ? 1 : 0
        }
        _xn() {
            const t = this.mbn;
            0 === this.SSn ? (t.disable(t.DEPTH_TEST),
            t.depthMask(!1)) : (t.enable(t.DEPTH_TEST),
            t.depthMask(!0))
        }
        Txn(t) {
            this.lVt = J_,
            this.SSn = t ? 1 : 0
        }
        Ixn() {
            const t = this.mbn
              , i = this.vSn
              , e = i.II
              , s = 0 !== this.SSn;
            i.gSn = s,
            t.activeTexture(t.TEXTURE2),
            s ? (i.wSn && t.bindFramebuffer(t.FRAMEBUFFER, i.wSn),
            t.bindTexture(t.TEXTURE_2D, e.Pxn())) : (t.bindTexture(t.TEXTURE_2D, null),
            i.wSn && t.bindFramebuffer(t.FRAMEBUFFER, i.mSn)),
            t.activeTexture(t.TEXTURE0)
        }
        Gxn() {
            this.lVt = Z_
        }
        Axn() {
            const t = this.mbn;
            t.clear(t.STENCIL_BUFFER_BIT),
            t.enable(t.STENCIL_TEST),
            t.stencilFunc(t.ALWAYS, 1, 1),
            t.stencilOp(t.KEEP, t.KEEP, t.REPLACE),
            t.colorMask(!1, !1, !1, !1)
        }
        Rxn() {
            this.lVt = Q_
        }
        kxn() {
            const t = this.mbn;
            t.enable(t.STENCIL_TEST),
            t.colorMask(!0, !0, !0, !0),
            t.stencilFunc(t.EQUAL, 1, 1),
            t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
        }
        Oxn() {
            this.lVt = tT
        }
        Dxn() {
            const t = this.mbn;
            t.disable(t.STENCIL_TEST)
        }
        Fxn(t, i, e, s, n) {
            this.lVt = iT,
            this.SSn = t ? 1 : 0;
            const r = this.ESn;
            r[0] = i,
            r[1] = e,
            r[2] = s,
            r[3] = n
        }
        Lxn() {
            const t = this.mbn
              , i = this.ESn;
            1 === this.SSn ? (t.enable(t.SCISSOR_TEST),
            t.scissor(i[0], i[1], i[2], i[3])) : t.disable(t.SCISSOR_TEST)
        }
        Bxn(t) {
            this.lVt = sT,
            this.SSn = t
        }
        Uxn() {
            const t = this.mbn
              , i = this.SSn;
            0 === i ? t.disable(t.CULL_FACE) : (t.enable(t.CULL_FACE),
            1 === i ? t.cullFace(t.BACK) : t.cullFace(t.FRONT))
        }
        Nxn(t) {
            this.lVt = nT,
            this.SSn = t
        }
        jxn() {
            const t = this.mbn;
            t.frontFace(0 === this.SSn ? t.CW : t.CCW)
        }
        UPe() {
            switch (this.lVt) {
            case 1:
                return void this.PSn();
            case 2:
                return void this.ASn();
            case 3:
                return void this.FSn();
            case 4:
                return void this.BSn();
            case 5:
                return void this.NSn();
            case 6:
                return void this.$Sn();
            case 7:
                return void this.VSn();
            case 8:
                return void this.XSn();
            case 9:
                return void this.QSn();
            case 10:
                return void this.ixn();
            case 11:
                return void this.sxn();
            case 12:
                return void this.hxn();
            case 13:
                return void this.axn();
            case 14:
                return void this.JSn();
            case 15:
                return void this.vxn();
            case 16:
                return void this.uxn();
            case 17:
                return void this.dxn();
            case 18:
                return void this.mxn();
            case 19:
                return void this.yxn();
            case 20:
                return void this.OSn();
            case 21:
                return void this.Exn();
            case 22:
                return void this._xn();
            case 23:
                return void this.Ixn();
            case 24:
                return void this.Axn();
            case 25:
                return void this.kxn();
            case 26:
                return void this.Dxn();
            case 27:
                return void this.Lxn();
            case 28:
                return void this.xxn();
            case 29:
                return void this.Uxn();
            case 30:
                return void this.jxn()
            }
        }
    }
}
{
    const rT = self.t
      , hT = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"])
      , oT = new Set(["nearest", "bilinear", "trilinear"])
      , aT = new Set(["default", "low", "high"])
      , lT = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
    function uT(t, i) {
        let e, s, n, r;
        switch (t) {
        case "rgba8":
            e = i.RGBA8,
            s = i.RGBA,
            n = i.RGBA,
            r = i.UNSIGNED_BYTE;
            break;
        case "rgb8":
            e = i.RGB8,
            s = i.RGB,
            n = i.RGB,
            r = i.UNSIGNED_BYTE;
            break;
        case "rgba4":
            e = i.RGBA4,
            s = i.RGBA,
            n = i.RGBA,
            r = i.UNSIGNED_SHORT_4_4_4_4;
            break;
        case "rgb5_a1":
            e = i.RGB5_A1,
            s = i.RGBA,
            n = i.RGBA,
            r = i.UNSIGNED_SHORT_5_5_5_1;
            break;
        case "rgb565":
            e = i.RGB565,
            s = i.RGB,
            n = i.RGB,
            r = i.UNSIGNED_SHORT_5_6_5;
            break;
        default:
            throw new Error("invalid pixel format")
        }
        return {
            $xn: e,
            zxn: s,
            format: n,
            type: r
        }
    }
    const cT = {
        On: "clamp-to-edge",
        Pn: "clamp-to-edge",
        Cn: "trilinear",
        vn: 0,
        Vxn: "rgba8",
        wc: !0,
        bc: "default",
        Wxn: !0,
        og: !1,
        width: -1,
        height: -1
    }
      , dT = {
        Wxn: !0,
        flipY: !1
    }
      , fT = new Set;
    rT.ra.Hxn = class {
        constructor(t) {
            rT.U(t, rT.ra.p0),
            this.an = t,
            this.Qs = null,
            this.ZC = 0,
            this.tv = 0,
            this.YKs = !0,
            this.wM = "clamp-to-edge",
            this.bM = "clamp-to-edge",
            this.Kxn = "trilinear",
            this.qxn = 0,
            this.Xxn = "rgba8",
            this.Yxn = !1,
            this.Jxn = "default",
            this.dKe = 0
        }
        Zxn(t, i) {
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData || t instanceof ArrayBuffer))
                throw new Error("invalid texture source");
            if (rT.Wat(i),
            i = Object.assign({}, cT, i),
            this.Qs)
                throw new Error("already created texture");
            if (rT.zt(i.On),
            rT.zt(i.Pn),
            rT.zt(i.Vxn),
            rT.zt(this.Kxn),
            rT.Ge(i.vn),
            this.wM = i.On,
            this.bM = i.Pn,
            this.Kxn = i.Cn,
            this.qxn = i.vn,
            this.Xxn = i.Vxn,
            this.Yxn = !!i.wc && this.an.Ggn(),
            this.Jxn = i.bc,
            !lT.has(this.wM) || !lT.has(this.bM))
                throw new Error("invalid wrap mode");
            if (!oT.has(this.Kxn))
                throw new Error("invalid sampling");
            if (!hT.has(this.Xxn))
                throw new Error("invalid pixel format");
            if (!aT.has(this.Jxn))
                throw new Error("invalid mipmap quality");
            if (this.YKs = !0,
            t instanceof ArrayBuffer || null === t || i.og) {
                if (rT.Ge(i.width),
                rT.Ge(i.height),
                this.ZC = i.width,
                this.tv = i.height,
                t instanceof ArrayBuffer && t.byteLength !== this.ZC * this.tv * 4)
                    throw new Error("ArrayBuffer wrong size")
            } else
                this.ZC = t.width,
                this.tv = t.height;
            if (this.ZC <= 0 || this.tv <= 0)
                throw new Error("invalid texture data size");
            if (i.og) {
                const i = rT.GS(this.ZC, this.tv);
                i.getContext("2d").drawImage(t, 0, 0, this.ZC, this.tv),
                t = i
            }
            const e = rT.zOe(this.ZC) && rT.zOe(this.tv)
              , s = this.an.Yyn();
            if (this.ZC > s || this.tv > s)
                throw new Error("texture data exceeds maximum texture size");
            const n = this.an.dMt()
              , r = this.an.Qxn();
            this.Qs = n.createTexture(),
            n.bindTexture(n.TEXTURE_2D, this.Qs),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.Wxn),
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1);
            const h = uT(this.Xxn, n);
            if (this.an.kv() || e || !this.tMn())
                if (r >= 2) {
                    let i;
                    i = this.Yxn ? Math.floor(Math.log2(Math.max(this.ZC, this.tv)) + 1) : 1,
                    n.texStorage2D(n.TEXTURE_2D, i, h.$xn, this.ZC, this.tv),
                    t instanceof ArrayBuffer ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, this.ZC, this.tv, h.format, h.type, new Uint8Array(t)) : null !== t && n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, h.format, h.type, t)
                } else
                    t instanceof ArrayBuffer ? n.texImage2D(n.TEXTURE_2D, 0, h.zxn, this.ZC, this.tv, 0, h.format, h.type, new Uint8Array(t)) : null === t ? n.texImage2D(n.TEXTURE_2D, 0, h.zxn, this.ZC, this.tv, 0, h.format, h.type, null) : n.texImage2D(n.TEXTURE_2D, 0, h.zxn, h.format, h.type, t);
            else {
                if (null === t)
                    throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                if (t instanceof ArrayBuffer && (t = new ImageData(new Uint8ClampedArray(t),this.ZC,this.tv)),
                t instanceof ImageData) {
                    const i = rT.GS(this.ZC, this.tv);
                    i.getContext("2d").putImageData(t, 0, 0),
                    t = i
                }
                const i = rT.GS(rT.ha(this.ZC), rT.ha(this.tv))
                  , e = i.getContext("2d");
                e.imageSmoothingEnabled = "nearest" !== this.Kxn,
                e.drawImage(t, 0, 0, this.ZC, this.tv, 0, 0, i.width, i.height),
                n.texImage2D(n.TEXTURE_2D, 0, h.zxn, h.format, h.type, i)
            }
            null !== t && this.iMn(n),
            n.bindTexture(n.TEXTURE_2D, null),
            this.an.eMn(),
            this.dKe = 1,
            fT.add(this)
        }
        sMn(t, i, e) {
            if (rT.Ge(t),
            rT.Ge(i),
            rT.Wat(e),
            e = Object.assign({}, cT, e),
            this.Qs)
                throw new Error("already created texture");
            if (rT.zt(e.On),
            rT.zt(e.Pn),
            rT.zt(e.Vxn),
            rT.zt(this.Kxn),
            this.wM = e.On,
            this.bM = e.Pn,
            this.Kxn = e.Cn,
            this.Xxn = e.Vxn,
            this.Yxn = !!e.wc && this.an.Ggn(),
            this.Jxn = e.bc,
            !lT.has(this.wM) || !lT.has(this.bM))
                throw new Error("invalid wrap mode");
            if (!oT.has(this.Kxn))
                throw new Error("invalid sampling");
            if (!hT.has(this.Xxn))
                throw new Error("invalid pixel format");
            if (!aT.has(this.Jxn))
                throw new Error("invalid mipmap quality");
            this.YKs = !1,
            this.ZC = Math.floor(t),
            this.tv = Math.floor(i);
            const s = rT.zOe(this.ZC) && rT.zOe(this.tv)
              , n = this.an.Yyn();
            if (this.ZC <= 0 || this.tv <= 0)
                throw new Error("invalid texture size");
            if (this.ZC > n || this.tv > n)
                throw new Error("texture exceeds maximum texture size");
            if (!this.an.kv() && this.tMn() && !s)
                throw new Error("non-power-of-two tiled textures not supported");
            const r = this.an.dMt()
              , h = this.an.Qxn();
            this.Qs = r.createTexture(),
            r.bindTexture(r.TEXTURE_2D, this.Qs),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.Wxn),
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1);
            const o = uT(this.Xxn, r)
              , a = h >= 2 ? o.$xn : o.zxn;
            r.texImage2D(r.TEXTURE_2D, 0, a, this.ZC, this.tv, 0, o.format, o.type, null),
            this.iMn(r),
            r.bindTexture(r.TEXTURE_2D, null),
            this.an.eMn(),
            this.dKe = 1,
            fT.add(this)
        }
        nMn(t) {
            if ("default" === this.Jxn)
                return this.YKs ? t.NICEST : t.FASTEST;
            if ("low" === this.Jxn)
                return t.FASTEST;
            if ("high" === this.Jxn)
                return t.NICEST;
            throw new Error("invalid mipmap quality")
        }
        tMn() {
            return "clamp-to-edge" !== this.wM || "clamp-to-edge" !== this.bM
        }
        rMn(t, i) {
            if (rT.zt(i),
            "clamp-to-edge" === i)
                return t.CLAMP_TO_EDGE;
            if ("repeat" === i)
                return t.REPEAT;
            if ("mirror-repeat" === i)
                return t.MIRRORED_REPEAT;
            throw new Error("invalid wrap mode")
        }
        iMn(t) {
            const i = rT.zOe(this.ZC) && rT.zOe(this.tv);
            if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, this.rMn(t, this.wM)),
            t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, this.rMn(t, this.bM)),
            "nearest" === this.Kxn)
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST),
                this.Yxn = !1;
            else if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR),
            (i || this.an.kv()) && this.Yxn) {
                t.hint(t.GENERATE_MIPMAP_HINT, this.nMn(t)),
                t.generateMipmap(t.TEXTURE_2D);
                const i = "trilinear" === this.Kxn && !this.an.Agn();
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, i ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR_MIPMAP_NEAREST)
            } else
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR),
                this.Yxn = !1;
            const e = this.an.hMn();
            e && this.qxn > 0 && "nearest" !== this.Kxn && t.texParameterf(t.TEXTURE_2D, e.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this.qxn, this.an.oMn()))
        }
        $Wt(t, i) {
            if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData))
                throw new Error("invalid texture source");
            if (!this.Qs || this.dKe <= 0)
                throw new Error("texture not created");
            if (this.YKs)
                throw new Error("cannot update static texture");
            rT.Wat(i),
            i = Object.assign({}, dT, i);
            const e = t.width || t.videoWidth
              , s = t.height || t.videoHeight
              , n = this.an.Qxn()
              , r = this.an.dMt();
            r.bindTexture(r.TEXTURE_2D, this.Qs),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.Wxn),
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !!i.flipY);
            const h = uT(this.Xxn, r)
              , o = n >= 2 ? h.$xn : h.zxn;
            try {
                if (this.ZC === e && this.tv === s) {
                    const i = rT.zOe(this.ZC) && rT.zOe(this.tv);
                    r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, h.format, h.type, t),
                    (i || this.an.kv()) && this.Yxn && (r.hint(r.GENERATE_MIPMAP_HINT, this.nMn(r)),
                    r.generateMipmap(r.TEXTURE_2D))
                } else {
                    this.ZC = e,
                    this.tv = s;
                    const i = rT.zOe(this.ZC) && rT.zOe(this.tv);
                    if (!this.an.kv() && this.tMn() && !i)
                        throw new Error("non-power-of-two tiled textures not supported");
                    r.texImage2D(r.TEXTURE_2D, 0, o, h.format, h.type, t),
                    (i || this.an.kv()) && this.Yxn && (r.hint(r.GENERATE_MIPMAP_HINT, this.nMn(r)),
                    r.generateMipmap(r.TEXTURE_2D))
                }
            } catch (t) {
                console.error("Error updating WebGL texture: ", t)
            }
            r.bindTexture(r.TEXTURE_2D, null),
            this.an.eMn()
        }
        Hwt() {
            if (this.dKe > 0)
                throw new Error("texture still has references");
            if (!this.Qs)
                throw new Error("already deleted texture");
            fT.delete(this);
            this.an.dMt().deleteTexture(this.Qs),
            this.Qs = null
        }
        Ert() {
            return !!this.Qs
        }
        RSn() {
            return this.Qs
        }
        Mn() {
            return this.an
        }
        aMn() {
            this.dKe++
        }
        lMn() {
            if (this.dKe <= 0)
                throw new Error("no more references");
            this.dKe--
        }
        uMn() {
            return this.dKe
        }
        ns() {
            return this.ZC
        }
        Kn() {
            return this.tv
        }
        tXs() {
            return this.YKs
        }
        YZ() {
            let t = this.ZC * this.tv;
            switch (this.Xxn) {
            case "rgba8":
                t *= 4;
                break;
            case "rgb8":
                t *= 3;
                break;
            case "rgba4":
            case "rgb5_a1":
            case "rgb565":
                t *= 2
            }
            return this.Yxn && (t += Math.floor(t / 3)),
            t
        }
        static Vs() {
            fT.clear()
        }
        static cMn() {
            return fT.values()
        }
    }
}
{
    const pT = self.t
      , mT = self.assert
      , wT = self.sG
      , gT = (wT.hG,
    wT.eG)
      , yT = new Set(["nearest", "bilinear", "trilinear"])
      , bT = {
        Cn: "trilinear",
        alpha: !0,
        l0: !1,
        dMn: !0,
        fMn: !0,
        pMn: 0
    }
      , vT = new Set;
    pT.ra.mMn = class {
        constructor(t) {
            pT.U(t, pT.ra.p0),
            this.an = t,
            this.wMn = null,
            this.gMn = null,
            this.Qs = null,
            this.yMn = null,
            this.ZC = 0,
            this.tv = 0,
            this.bMn = !0,
            this.Kxn = "trilinear",
            this.vMn = !0,
            this.wys = !1,
            this.SMn = !0,
            this.xMn = 0,
            this.MMn = gT.create(),
            this.NG = 0,
            this.VG = 0,
            this.KG = 0
        }
        _k(t, i, e) {
            pT.Ge(t),
            pT.Ge(i),
            pT.Wat(e),
            e = Object.assign({}, bT, e);
            const s = this.an.Qxn();
            if (this.Qs || this.yMn)
                throw new Error("already created render target");
            if (this.Kxn = e.Cn,
            this.vMn = !!e.alpha,
            this.wys = !!e.l0,
            this.SMn = !!e.dMn,
            this.bMn = !!e.fMn,
            this.xMn = e.pMn,
            pT.zt(this.Kxn),
            !yT.has(this.Kxn))
                throw new Error("invalid sampling");
            if (this.xMn > 0 && (s < 2 || this.SMn))
                throw new Error("invalid use of multisampling");
            if (s < 2 && (this.SMn = !0),
            this.ZC = t,
            this.tv = i,
            this.ZC <= 0 || this.tv <= 0)
                throw new Error("invalid render target size");
            this.EMn();
            const n = this.an.dMt();
            if (this.wMn = n.createFramebuffer(),
            this.wys && (this.gMn = n.createFramebuffer()),
            this.SMn) {
                this.Qs = this.an.sK(this.ZC, this.tv, {
                    Cn: this.Kxn,
                    Vxn: this.vMn ? "rgba8" : "rgb8",
                    wc: !1
                });
                const t = this.Qs.RSn();
                n.bindFramebuffer(n.FRAMEBUFFER, this.wMn),
                n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0),
                this.wys && (n.bindFramebuffer(n.FRAMEBUFFER, this.gMn),
                n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0))
            } else {
                this.yMn = n.createRenderbuffer(),
                n.bindRenderbuffer(n.RENDERBUFFER, this.yMn);
                const t = this.vMn ? n.RGBA8 : n.RGB8;
                if (this.xMn > 0) {
                    const i = n.getInternalformatParameter(n.RENDERBUFFER, t, n.SAMPLES);
                    if (i && i[0]) {
                        const t = i[0];
                        this.xMn > t && (this.xMn = t)
                    } else
                        this.xMn = 0
                }
                0 === this.xMn ? n.renderbufferStorage(n.RENDERBUFFER, t, this.ZC, this.tv) : n.renderbufferStorageMultisample(n.RENDERBUFFER, this.xMn, t, this.ZC, this.tv),
                n.bindFramebuffer(n.FRAMEBUFFER, this.wMn),
                n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, this.yMn),
                this.wys && (n.bindFramebuffer(n.FRAMEBUFFER, this.gMn),
                n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, this.yMn)),
                n.bindRenderbuffer(n.RENDERBUFFER, null)
            }
            const r = this.an.Pxn();
            this.wys && r && (n.bindFramebuffer(n.FRAMEBUFFER, this.wMn),
            this.an.CMn() ? n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, r, 0) : n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r)),
            mT(n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE, "WebGLRenderTarget framebuffer is incomplete"),
            n.bindFramebuffer(n.FRAMEBUFFER, null),
            vT.add(this)
        }
        _Mn(t, i) {
            if (this.ZC === t && this.tv === i)
                return;
            this.ZC = t,
            this.tv = i,
            this.EMn();
            const e = this.an.dMt();
            e.bindFramebuffer(e.FRAMEBUFFER, this.wMn),
            this.Qs ? this.Qs.$Wt(new ImageData(this.ZC,this.tv)) : (e.bindRenderbuffer(e.RENDERBUFFER, this.yMn),
            e.renderbufferStorage(e.RENDERBUFFER, this.vMn ? e.RGBA8 : e.RGB8, this.ZC, this.tv),
            e.bindRenderbuffer(e.RENDERBUFFER, null));
            const s = this.an.Pxn();
            this.wys && s && (this.an.CMn() ? e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0) : e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, s)),
            mT(e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE, "WebGLRenderTarget framebuffer is incomplete"),
            e.bindFramebuffer(e.FRAMEBUFFER, null)
        }
        Hwt() {
            if (!this.Qs && !this.yMn)
                throw new Error("already deleted render target");
            vT.delete(this);
            const t = this.an.dMt();
            this.Qs ? (t.bindFramebuffer(t.FRAMEBUFFER, this.wMn),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0),
            this.wys && (t.bindFramebuffer(t.FRAMEBUFFER, this.gMn),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)),
            this.an.pn(this.Qs),
            this.Qs = null) : this.yMn && (t.bindFramebuffer(t.FRAMEBUFFER, this.wMn),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null),
            this.wys && (t.bindFramebuffer(t.FRAMEBUFFER, this.gMn),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null)),
            t.deleteRenderbuffer(this.yMn),
            this.yMn = null),
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            this.an.Qxn() >= 2 && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null)),
            t.deleteFramebuffer(this.wMn),
            this.wys && t.deleteFramebuffer(this.gMn);
            const i = this.an.Wbn();
            i.mSn = null,
            i.wSn = null,
            this.wMn = null
        }
        EMn() {
            this.an.EV(this.MMn, this.ZC / this.tv),
            this.NG = this.an.Lwn(),
            this.VG = this.an.bZ(),
            this.KG = this.an.IZ()
        }
        WSn() {
            return this.wMn
        }
        HSn() {
            return this.gMn
        }
        Mn() {
            return this.an
        }
        Gn() {
            return this.Qs
        }
        TMn() {
            return this.an.Lwn() === this.NG && this.an.bZ() === this.VG && this.an.IZ() === this.KG || this.EMn(),
            this.MMn
        }
        T0() {
            return "nearest" !== this.Kxn
        }
        IMn() {
            return this.vMn
        }
        PMn() {
            return this.SMn
        }
        GMn() {
            return this.wys
        }
        ns() {
            return this.ZC
        }
        Kn() {
            return this.tv
        }
        AMn() {
            return this.bMn
        }
        RMn() {
            return this.xMn
        }
        YIt() {
            const t = {
                Cn: this.Kxn,
                alpha: this.vMn,
                dMn: this.SMn
            };
            return this.bMn || (t.width = this.ZC,
            t.height = this.tv),
            t
        }
        kMn(t) {
            return "nearest" !== (t = Object.assign({}, bT, t)).Cn === this.T0() && (!!t.alpha === this.IMn() && (!!t.l0 === this.GMn() && (!(this.an.Qxn() >= 2 && !!t.dMn !== this.PMn()) && ("number" == typeof t.width || "number" == typeof t.height ? !this.AMn() && this.ns() === Math.floor(t.width) && this.Kn() === Math.floor(t.height) : this.AMn()))))
        }
        OMn() {
            return this.Qs ? this.Qs.RSn() : null
        }
        YZ() {
            return this.Qs ? this.Qs.YZ() : this.ZC * this.tv * (this.vMn ? 4 : 3)
        }
        static async DMn(t, i) {
            const e = await t.FMn(i, !0);
            return await pT.mms(e)
        }
        static Vs() {
            vT.clear()
        }
        static LMn() {
            return vT.values()
        }
        static BMn(t, i) {
            for (const e of vT)
                e.AMn() && e._Mn(t, i)
        }
    }
}
{
    const ST = self.t;
    class xT {
        constructor(t) {
            this.mbn = t.dMt(),
            this.i3t = t.Qxn(),
            this.UMn = t.NMn(),
            this.jMn = null,
            this.Vd = !1,
            this.$Mn = !1,
            this.Z2s = 0,
            1 === this.i3t ? this.jMn = this.UMn.createQueryEXT() : this.jMn = this.mbn.createQuery()
        }
        he() {
            this.zMn(),
            this.mbn = null,
            this.UMn = null,
            this.$Mn = !1
        }
        zMn() {
            this.jMn && (1 === this.i3t ? this.UMn.deleteQueryEXT(this.jMn) : this.mbn.deleteQuery(this.jMn),
            this.jMn = null)
        }
        fxn() {
            if (this.Vd)
                throw new Error("query already active");
            1 === this.i3t ? this.UMn.beginQueryEXT(this.UMn.TIME_ELAPSED_EXT, this.jMn) : this.mbn.beginQuery(this.UMn.TIME_ELAPSED_EXT, this.jMn),
            this.Vd = !0
        }
        wxn() {
            if (!this.Vd)
                throw new Error("query not active");
            1 === this.i3t ? this.UMn.endQueryEXT(this.UMn.TIME_ELAPSED_EXT) : this.mbn.endQuery(this.UMn.TIME_ELAPSED_EXT),
            this.Vd = !1
        }
        VMn() {
            if (!this.jMn || this.$Mn || this.Vd)
                return;
            let t = !1;
            t = 1 === this.i3t ? this.UMn.getQueryObjectEXT(this.jMn, this.UMn.QUERY_RESULT_AVAILABLE_EXT) : this.mbn.getQueryParameter(this.jMn, this.mbn.QUERY_RESULT_AVAILABLE);
            const i = this.mbn.getParameter(this.UMn.GPU_DISJOINT_EXT);
            t && !i && (1 === this.i3t ? this.Z2s = this.UMn.getQueryObjectEXT(this.jMn, this.UMn.QUERY_RESULT_EXT) : this.Z2s = this.mbn.getQueryParameter(this.jMn, this.mbn.QUERY_RESULT),
            this.Z2s /= 1e9,
            this.$Mn = !0),
            (t || i) && this.zMn()
        }
        WMn() {
            return this.$Mn
        }
        $8s() {
            if (!this.$Mn)
                throw new Error("no result available");
            return this.Z2s
        }
    }
    ST.ra.HMn = class {
        constructor(t) {
            this.an = t,
            this.Gwn = t.Tgn(),
            this.Vd = !1,
            this.KMn = null,
            this.qMn = !1,
            this.XMn = null,
            this.YMn = []
        }
        he() {
            for (const t of this.YMn)
                t instanceof xT && t.he();
            ST.sc(this.YMn),
            this.KMn = null,
            this.XMn = null,
            this.an = null
        }
        fxn() {
            if (this.Vd)
                throw new Error("query already active");
            const t = this.an.JMn();
            t.length > 0 ? (this.qMn = !0,
            this.KMn = t.at(-1),
            this.KMn.ZMn(),
            this.KMn.YMn.push(this)) : (this.qMn = !1,
            this.KMn = null),
            this.Vd = !0,
            t.push(this),
            this.QMn()
        }
        wxn() {
            if (!this.Vd)
                throw new Error("query not active");
            if (this.an.JMn().pop() !== this)
                throw new Error("can only end most nested query");
            this.Vd = !1,
            this.ZMn(),
            this.KMn && (this.KMn.QMn(),
            this.KMn = null)
        }
        QMn() {
            this.XMn = ST.v(xT, this.an),
            this.YMn.push(this.XMn),
            this.XMn.fxn()
        }
        ZMn() {
            this.XMn.wxn(),
            this.XMn = null
        }
        VMn() {
            for (const t of this.YMn)
                t.VMn()
        }
        lFs() {
            return this.qMn
        }
        WMn() {
            return this.YMn.every(t => t.WMn())
        }
        $8s() {
            return this.YMn.reduce( (t, i) => t + i.$8s(), 0)
        }
        Tgn() {
            return this.Gwn
        }
    }
}
{
    const MT = self.t;
    MT.ra.tEn = class {
        constructor(t, i=1e3) {
            this.an = t,
            this.iEn = i,
            this._He = [],
            this.an.eEn(this)
        }
        he() {
            this.tC(),
            this.an.sEn(this),
            this.an = null
        }
        tC() {
            for (const t of this._He)
                t.he();
            MT.sc(this._He)
        }
        nEn() {
            const t = new MT.ra.HMn(this.an);
            if (this._He.push(t),
            this._He.length > this.iEn) {
                this._He.shift().he()
            }
            return t
        }
        rEn(t) {
            for (const i of this._He) {
                if (i.Tgn() >= t)
                    return;
                if (i.lFs())
                    return;
                i.VMn()
            }
        }
        hEn(t, i) {
            if (i <= t)
                return NaN;
            let e = 0;
            for (const s of this._He) {
                if (s.Tgn() >= i)
                    break;
                if (!(s.Tgn() < t)) {
                    if (!s.WMn())
                        return NaN;
                    e += s.$8s()
                }
            }
            return e
        }
        oEn(t) {
            for (let i = 0, e = this._He.length; i < e; ++i) {
                const e = this._He[i];
                if (!(e.Tgn() < t))
                    return void (i > 0 && this._He.splice(0, i));
                e.he()
            }
        }
    }
}
{
    const ET = self.t
      , CT = self.assert
      , _T = self.sG
      , TT = (_T.hG,
    _T.dys)
      , IT = _T.eG
      , PT = {
        powerPreference: "default",
        c0: !0,
        alpha: !1,
        l0: !1,
        a0: !1,
        f0: 2,
        o0: !1
    }
      , GT = new Set(["default", "low-power", "high-performance"])
      , AT = 65535
      , RT = 6 * AT
      , kT = 8e3
      , OT = kT - 4
      , DT = new ET.Nn(0,0,1,0,1,1,0,1)
      , FT = IT.create()
      , LT = IT.create()
      , BT = new ET.Nn
      , UT = new ET.Rect;
    let NT = null;
    ET.Vl && (self.aEn = function() {
        NT ? NT.lEn() : (() => {})("WEBGL_lose_context not supported")
    }
    ,
    self.uEn = function() {
        NT ? NT.cEn() : (() => {})("WEBGL_lose_context not supported")
    }
    );
    const jT = new Set;
    let $T = -1;
    function zT() {
        $T = -1;
        for (const t of jT)
            t.dEn() && (t.resolve(),
            jT.delete(t));
        jT.size > 0 && ($T = self.requestAnimationFrame(zT))
    }
    ET.ra.p0 = class extends ET.ra.RC {
        constructor(t, i) {
            if (super(i),
            i = Object.assign({}, PT, i),
            ET.zt(i.powerPreference),
            !GT.has(i.powerPreference))
                throw new Error("invalid power preference");
            const e = {
                alpha: !!i.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: i.powerPreference,
                failIfMajorPerformanceCaveat: !!i.o0
            };
            let s = null
              , n = 0;
            if (i.f0 >= 2 && (s = t.getContext("webgl2", e),
            n = 2),
            s || (s = t.getContext("webgl", e),
            n = 1),
            !s)
                throw new Error("renderer-unavailable (could not get WebGL context)");
            this.mbn = s,
            this.fEn = s.getContextAttributes(),
            this.pEn = s.getParameter(s.VERSION),
            this.i3t = n,
            this.xHs = TT.create(),
            this.mEn = !1,
            this.wEn = IT.create(),
            this.gEn = !!i.l0,
            this.yEn = !(!i.l0 || !i.a0),
            this.bEn = this.gEn,
            this.vEn = !1,
            this.SEn = null,
            this.xEn = !0,
            this.MEn = 0,
            this.EEn = 0,
            this.qbn = null,
            this.Xbn = null,
            this.Ybn = null,
            this.CEn = null,
            this.Zbn = null,
            this._En = this.i3t >= 2 && void 0 !== globalThis.Float16Array,
            this.TEn = new Float32Array(3 * AT),
            this.IEn = new Uint16Array(RT),
            this.PEn = new Float32Array(2 * AT),
            this.GEn = this._En ? new globalThis.Float16Array(4 * AT) : new Float32Array(4 * AT),
            this.oci = new Float32Array(4 * kT),
            this.AEn = 0,
            this.REn = 0,
            this.kEn = 0,
            this.OEn = null,
            this.DEn = null,
            this.FEn = [],
            this.LEn = 0,
            this.BEn = 0,
            this.UEn = null,
            this.NEn = 0,
            this.vSn = ET.v(ET.ra.pSn, this),
            this.jEn = ET.v(ET.Ha, 1, 1, 1, 1),
            this.$En = null,
            this.nxn = null,
            this.zEn = 0,
            this.VEn = 0,
            this.WEn = new ET.Rect,
            this.HEn = ET.v(ET.Rect, 0, 0, -1, -1),
            this.KEn = 0,
            this.qEn = 0,
            this.XEn = 0,
            this.YEn = -1,
            this.JEn = 0,
            this.ZEn = 0,
            this.QEn = "(unavailable)",
            this.tCn = "(unavailable)",
            this.iCn = [],
            this.eCn = !1,
            this.sCn = null,
            this.nCn = null,
            this.rCn = null,
            this.hCn = null,
            this.oCn = null,
            this.aCn = null,
            this.lCn = null,
            this.uCn = 0,
            this.cCn = !!i.c0,
            this.UMn = null,
            this.dCn = new Set,
            this.fCn = []
        }
        Rgn() {
            return !0
        }
        async w0() {
            super.w0();
            const t = this.mbn;
            this.jEn.CIs(1, 1, 1, 1),
            this.$En = null,
            this.nxn = null,
            this.AEn = 0,
            this.REn = 0,
            this.kEn = 0,
            ET.sc(this.FEn),
            this.LEn = 0,
            this.BEn = 0,
            this.OEn = null,
            this.UEn = null,
            this.WEn.set(0, 0, 1, 1),
            this.NEn = 0;
            const i = this.vSn;
            i.Fvn = null,
            i.mSn = null,
            i.wSn = null,
            i.clearColor.CIs(0, 0, 0, 0),
            i.ySn.set(0, 0, 1, 1),
            t.clearColor(0, 0, 0, 0),
            t.clear(t.COLOR_BUFFER_BIT),
            t.enable(t.BLEND),
            t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA),
            this.zEn = t.ONE,
            this.VEn = t.ONE_MINUS_SRC_ALPHA,
            this.pCn(t),
            t.cullFace(t.BACK),
            t.disable(t.CULL_FACE),
            this.qEn = 0,
            t.frontFace(t.CW),
            this.XEn = 0,
            t.disable(t.STENCIL_TEST),
            t.disable(t.DITHER),
            this.gEn ? (t.enable(t.DEPTH_TEST),
            t.depthMask(!0),
            t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST),
            t.depthMask(!1)),
            this.bEn = this.gEn,
            this.vEn = !1,
            this.Zbn = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this.Zbn),
            t.bufferData(t.ARRAY_BUFFER, this.oci.byteLength, t.DYNAMIC_DRAW),
            this.qbn = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this.qbn),
            t.bufferData(t.ARRAY_BUFFER, this.TEn.byteLength, t.DYNAMIC_DRAW),
            this.Xbn = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this.Xbn),
            t.bufferData(t.ARRAY_BUFFER, this.PEn.byteLength, t.DYNAMIC_DRAW),
            this.Ybn = t.createBuffer(),
            t.bindBuffer(t.ARRAY_BUFFER, this.Ybn),
            t.bufferData(t.ARRAY_BUFFER, this.GEn.byteLength, t.DYNAMIC_DRAW),
            this.CEn = t.createBuffer(),
            t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.CEn),
            t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.IEn.byteLength, t.DYNAMIC_DRAW),
            t.activeTexture(t.TEXTURE0),
            t.bindTexture(t.TEXTURE_2D, null),
            this.YEn = t.getParameter(t.MAX_TEXTURE_SIZE);
            const e = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);
            this.JEn = e[0],
            this.ZEn = e[1],
            this.ZEn > 2048 && (this.ZEn = 2048),
            this.iCn = t.getSupportedExtensions();
            const s = t.getExtension("WEBGL_debug_renderer_info");
            if (s && (this.QEn = t.getParameter(s.UNMASKED_VENDOR_WEBGL),
            this.tCn = t.getParameter(s.UNMASKED_RENDERER_WEBGL)),
            this.sCn = t.getExtension("KHR_parallel_shader_compile"),
            this.i3t >= 2 && ("Chromium" !== ET.kt.NRe || ET.kt.URe >= 135) && (this.rCn = t.getExtension("EXT_conservative_depth")),
            ET.Vl && (NT = t.getExtension("WEBGL_lose_context")),
            this.cCn && (1 === this.Qxn() ? this.UMn = t.getExtension("EXT_disjoint_timer_query") : this.UMn = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")),
            this.nCn = t.getExtension("EXT_texture_filter_anisotropic"),
            this.nCn ? this.uCn = t.getParameter(this.nCn.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : this.uCn = 0,
            this.Qxn() < 2 && this.gEn && this.yEn && (this.hCn = t.getExtension("WEBGL_depth_texture"),
            !this.hCn))
                throw new Error("no depth texture support");
            this.Qxn() < 2 && (this.oCn = t.getExtension("EXT_frag_depth"),
            this.aCn = t.getExtension("OES_standard_derivatives"),
            this.lCn = t.getExtension("EXT_shader_texture_lod"));
            const n = ET.ra.Nbn
              , r = n.Hvn(!1);
            let h = n.qvn()
              , o = r
              , a = n.sSn()
              , l = n.iSn()
              , u = n.Jvn()
              , c = n.Hvn(!0)
              , d = !1;
            this.gEn && (this.Qxn() < 2 ? this.oCn && (h = n.Xvn(),
            a = n.nSn(),
            u = n.Zvn(),
            d = !0) : (o = n.Kvn(),
            h = n.Yvn(this.mCn()),
            a = n.rSn(this.mCn()),
            l = n.eSn(),
            u = n.Qvn(this.mCn()),
            c = n.Kvn(!0)));
            const f = n.tSn(this.Qxn(), d, this.aCn && this.lCn, this.mCn())
              , p = this.Qxn() >= 2 ? n.Kvn() : r
              , m = [[h, o, "<default>"], [h, o, "<default-device-transform>"], [a, l, "<point>"], [n.hSn(), r, "<fill>"], [n.oSn(), r, "<lineargradient>"], [n.aSn(), r, "<penumbra>"], [n.uSn(), r, "<hardellipse>"], [n.cSn(), r, "<hardellipseoutline>"], [n.dSn(), r, "<smoothellipse>"], [n.fSn(), r, "<smoothellipseoutline>"], [n.lSn(), r, "<smoothline>"], [u, c, "<tilemap>"], [f, p, "<tilerandomization>"]]
              , w = await Promise.all(m.map(t => this.wCn({
                src: t[0],
                $bn: t[1],
                name: t[2]
            })));
            this.own = w[0],
            this.DEn = w[1],
            this.awn = w[2],
            this.cwn = w[3],
            this.dwn = w[4],
            this.fwn = w[5],
            this.pwn = w[6],
            this.mwn = w[7],
            this.wwn = w[8],
            this.gwn = w[9],
            this.ywn = w[10],
            this.lwn = w[11],
            this.uwn = w[12],
            this.Yr()
        }
        async wCn(t) {
            const i = await ET.ra.Nbn.y_(this, t);
            return this.Uwn(i),
            i
        }
        gCn() {
            this.OEn = null
        }
        Hr(t, i, e) {
            if (this.ZC === t && this.tv === i && !e)
                return;
            this._gn();
            const s = this.mbn
              , n = this.vSn;
            this.ZC = t,
            this.tv = i,
            this.yCn(0, 0, t, i),
            this.EV(this.wEn, t / i),
            this.pV(this.wEn),
            this.DEn && (s.useProgram(this.DEn.Als()),
            this.DEn.Avn(this.twn),
            this.OEn = this.DEn,
            this.vSn.Fvn = this.DEn),
            s.bindTexture(s.TEXTURE_2D, null),
            s.activeTexture(s.TEXTURE1),
            s.bindTexture(s.TEXTURE_2D, null),
            s.activeTexture(s.TEXTURE0),
            this.$En = null,
            this.nxn = null,
            this.gEn && this.xEn && this.bCn(this.ZC, this.tv),
            this.UEn && this.UEn._Mn(this.ZC, this.tv),
            s.bindFramebuffer(s.FRAMEBUFFER, null),
            this.UEn = null,
            n.mSn = null,
            n.wSn = null
        }
        bCn(t, i) {
            const e = this.mbn;
            this.SEn && this.MEn === t && this.EEn === i || (this.yEn ? (this.SEn && e.deleteTexture(this.SEn),
            this.SEn = e.createTexture(),
            e.bindTexture(e.TEXTURE_2D, this.SEn),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            this.Qxn() >= 2 ? e.texImage2D(e.TEXTURE_2D, 0, e.DEPTH24_STENCIL8, t, i, 0, e.DEPTH_STENCIL, e.UNSIGNED_INT_24_8, null) : this.hCn ? e.texImage2D(e.TEXTURE_2D, 0, e.DEPTH_STENCIL, t, i, 0, e.DEPTH_STENCIL, this.hCn.UNSIGNED_INT_24_8_WEBGL, null) : CT(!1, "no depth texture support"),
            e.bindTexture(e.TEXTURE_2D, null)) : (this.SEn && e.deleteRenderbuffer(this.SEn),
            this.SEn = e.createRenderbuffer(),
            e.bindRenderbuffer(e.RENDERBUFFER, this.SEn),
            e.renderbufferStorage(e.RENDERBUFFER, this.i3t >= 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL, t, i),
            e.bindRenderbuffer(e.RENDERBUFFER, null)),
            this.MEn = t,
            this.EEn = i)
        }
        vCn(t, i) {
            this.gEn && (this.xEn = !1,
            this.bCn(t, i))
        }
        SCn() {
            this.gEn && (this.xEn = !0,
            this.bCn(this.ZC, this.tv))
        }
        yCn(t, i, e, s) {
            const n = this.xHs;
            if (n[0] === t && n[1] === i && n[2] === e && n[3] === s)
                return;
            this.xCn().LSn(t, i, e, s),
            TT.set(n, t, i, e, s),
            this.BEn = 0
        }
        IV(t) {
            super.IV(t),
            this.EV(this.wEn, this.ZC / this.tv)
        }
        TV(t) {
            super.TV(t),
            this.EV(this.wEn, this.ZC / this.tv)
        }
        kV(t) {
            super.kV(t),
            this.EV(this.wEn, this.ZC / this.tv)
        }
        pV(t) {
            if (IT.wMe(this.twn, t))
                return;
            this.xCn().USn(t),
            IT.ia(this.twn, t),
            this.BEn = 0,
            this.mEn = !0
        }
        MCn() {
            let t, i, e;
            const s = this.UEn;
            null === s ? (t = this.wEn,
            i = this.ns(),
            e = this.Kn()) : (t = s.TMn(),
            i = s.ns(),
            e = s.Kn()),
            this.pV(t),
            this.yCn(0, 0, i, e)
        }
        yV(t) {
            if (IT.wMe(this.iwn, t))
                return;
            this.xCn().jSn(t),
            IT.ia(this.iwn, t),
            this.BEn = 0,
            this.mEn = !0
        }
        ECn() {
            this.mEn = !1
        }
        Mzs() {
            return this.mEn
        }
        Wbn() {
            return this.vSn
        }
        xCn() {
            const t = this.FEn;
            return this.LEn === t.length && t.push(new ET.ra.bSn(this.vSn)),
            t[this.LEn++]
        }
        _gn() {
            0 !== this.LEn && (this.un() || (this.CCn(),
            this._Cn(),
            this.LEn = 0,
            this.AEn = 0,
            this.REn = 0,
            this.kEn = 0,
            this.BEn = 0))
        }
        CCn() {
            const t = this.mbn;
            this.AEn > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this.qbn),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.TEn.subarray(0, 3 * this.AEn)),
            t.bindBuffer(t.ARRAY_BUFFER, this.Xbn),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.PEn.subarray(0, 2 * this.AEn)),
            t.bindBuffer(t.ARRAY_BUFFER, this.Ybn),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.GEn.subarray(0, 4 * this.AEn))),
            this.REn > 0 && (t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.CEn),
            t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, this.IEn.subarray(0, this.REn))),
            this.kEn > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this.Zbn),
            t.bufferSubData(t.ARRAY_BUFFER, 0, this.oci.subarray(0, this.kEn)))
        }
        _Cn() {
            const t = this.FEn;
            for (let i = 0, e = this.LEn; i < e; ++i)
                t[i].UPe()
        }
        du() {
            return this.jEn.getA()
        }
        ir(t, i, e, s) {
            const n = this.jEn;
            n.RGs(t, i, e, s) || (n.CIs(t, i, e, s),
            this.vwn = null,
            2 === this.BEn && (this.BEn = 0))
        }
        Rp(t) {
            const i = this.jEn;
            i.getA() !== t && (i.FC(t),
            this.vwn = null,
            2 === this.BEn && (this.BEn = 0))
        }
        Xn(t) {
            const i = this.jEn;
            i.equals(t) || (i.set(t),
            this.vwn = null,
            2 === this.BEn && (this.BEn = 0))
        }
        qr() {
            this.ir(1, 1, 1, 1)
        }
        $n() {
            return this.jEn
        }
        dr(t) {
            if (t === this.$En)
                return;
            CT(!t || !this.UEn || t !== this.UEn.Gn(), "setting texture to current render texture");
            this.xCn().GSn(t),
            this.$En = t,
            this.BEn = 0
        }
        eMn() {
            this.$En = null
        }
        ac(t) {
            const i = this.ign(t);
            this.TCn(i[0], i[1])
        }
        rc(t) {
            const i = this.ngn(t);
            this.TCn(i.Qwn, i.tgn)
        }
        TCn(t, i) {
            if (t === this.zEn && i === this.VEn)
                return;
            this.xCn().DSn(t, i),
            this.zEn = t,
            this.VEn = i,
            this.BEn = 0,
            this.vwn = null
        }
        ICn() {
            return this.zEn === this.mbn.ONE && this.VEn === this.mbn.ONE_MINUS_SRC_ALPHA
        }
        tr() {
            this.TCn(this.mbn.ONE, this.mbn.ONE_MINUS_SRC_ALPHA)
        }
        PCn() {
            this.TCn(this.mbn.SRC_ALPHA, this.mbn.ONE_MINUS_SRC_ALPHA)
        }
        Ww(t) {
            if (this.qEn === t)
                return;
            this.xCn().Bxn(t),
            this.qEn = t,
            this.BEn = 0,
            this.vwn = null
        }
        GCn() {
            return this.qEn
        }
        Xw(t) {
            if (this.XEn === t)
                return;
            this.xCn().Nxn(t),
            this.XEn = t,
            this.BEn = 0,
            this.vwn = null
        }
        ACn() {
            return this.XEn
        }
        RCn() {
            this.TCn(this.mbn.ONE, this.mbn.ZERO)
        }
        Rect(t) {
            this.E9(t.Kr(), t.Zr(), t.gl(), t.wl())
        }
        E9(t, i, e, s) {
            this.Cgn(t, i, e, i, e, s, t, s)
        }
        kCn(t, i) {
            if ((this.AEn + t > AT || this.REn + i > RT) && this._gn(),
            1 === this.BEn)
                this.FEn[this.LEn - 1].xSn += i;
            else {
                this.xCn().ISn(2 * this.REn, i),
                this.BEn = 1
            }
        }
        OCn() {
            const t = this.AEn;
            let i = this.REn;
            this.REn += 6;
            const e = this.IEn;
            e[i++] = t,
            e[i++] = t + 1,
            e[i++] = t + 2,
            e[i++] = t,
            e[i++] = t + 2,
            e[i] = t + 3
        }
        Nn(t) {
            this.Ac(t, DT)
        }
        Cgn(t, i, e, s, n, r, h, o) {
            this.kCn(4, 6),
            this.OCn();
            const a = this.TEn
              , l = this.AEn;
            this.AEn += 4;
            let u = 3 * l;
            const c = this.Mwn + this.Ewn;
            a[u++] = t,
            a[u++] = i,
            a[u++] = c,
            a[u++] = e,
            a[u++] = s,
            a[u++] = c,
            a[u++] = n,
            a[u++] = r,
            a[u++] = c,
            a[u++] = h,
            a[u++] = o,
            a[u] = c,
            DT.uDe(this.PEn, 2 * l),
            this.jEn.yDe(this.GEn, 4 * l)
        }
        gr(t, i) {
            this.kCn(4, 6),
            this.OCn();
            const e = this.AEn;
            this.AEn += 4,
            t.gFe(this.TEn, 3 * e, this.Mwn + this.Ewn),
            i.VDe(this.PEn, 2 * e),
            this.jEn.yDe(this.GEn, 4 * e)
        }
        Ac(t, i) {
            this.kCn(4, 6),
            this.OCn();
            const e = this.AEn;
            this.AEn += 4,
            t.gFe(this.TEn, 3 * e, this.Mwn + this.Ewn),
            i.uDe(this.PEn, 2 * e),
            this.jEn.yDe(this.GEn, 4 * e)
        }
        DCn(t, i, e) {
            this.kCn(4, 6),
            this.OCn();
            const s = this.AEn;
            this.AEn += 4,
            t.gFe(this.TEn, 3 * s, this.Mwn + this.Ewn),
            i.uDe(this.PEn, 2 * s),
            this.GEn.set(e, 4 * s)
        }
        eb(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.kCn(4, 6),
            this.OCn();
            const f = this.TEn
              , p = this.AEn;
            this.AEn += 4;
            let m = 3 * p;
            const w = this.Mwn + this.Ewn;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.VDe(this.PEn, 2 * p),
            this.jEn.yDe(this.GEn, 4 * p)
        }
        ob(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.kCn(4, 6),
            this.OCn();
            const f = this.TEn
              , p = this.AEn;
            this.AEn += 4;
            let m = 3 * p;
            const w = this.Mwn + this.Ewn;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.uDe(this.PEn, 2 * p),
            this.jEn.yDe(this.GEn, 4 * p)
        }
        FCn(t, i, e, s, n, r, h, o, a, l, u, c, d, f) {
            this.kCn(4, 6),
            this.OCn();
            const p = this.TEn
              , m = this.AEn;
            this.AEn += 4;
            let w = 3 * m;
            const g = this.Mwn + this.Ewn;
            p[w++] = t,
            p[w++] = i,
            p[w++] = g + e,
            p[w++] = s,
            p[w++] = n,
            p[w++] = g + r,
            p[w++] = h,
            p[w++] = o,
            p[w++] = g + a,
            p[w++] = l,
            p[w++] = u,
            p[w] = g + c,
            d.uDe(this.PEn, 2 * m),
            this.GEn.set(f, 4 * m)
        }
        jo(t, i, e, s) {
            if (t.length % 3 != 0)
                throw new Error("vertex buffer length not multiple of 3");
            if (t.length > 3 * AT)
                throw new Error(`too many vertices (${t.length / 3}, limit ${AT})`);
            if (e.length % 3 != 0)
                throw new Error("index buffer length not multiple of 3");
            if (e.length > RT)
                throw new Error(`too many indices (${e.length}, limit ${RT})`);
            this.kCn(t.length, e.length);
            const n = this.AEn;
            this.TEn.set(t, 3 * n),
            this.PEn.set(i, 2 * n);
            const r = this.IEn;
            if (0 === n)
                r.set(e, this.REn);
            else {
                let t = this.REn;
                for (let i = 0, s = e.length; i < s; ++i)
                    r[t++] = e[i] + n
            }
            const h = this.GEn;
            if (null != s)
                h.set(s, 4 * n);
            else {
                const i = this.jEn
                  , e = i.getR()
                  , s = i.getG()
                  , r = i.getB()
                  , o = i.getA();
                let a = 4 * n;
                for (let i = 0, n = t.length; i < n; ++i)
                    h[a++] = e,
                    h[a++] = s,
                    h[a++] = r,
                    h[a++] = o
            }
            this.AEn += t.length / 3,
            this.REn += e.length
        }
        LCn(t, i) {
            this.lK(0),
            IT.ia(FT, this.twn),
            IT.ia(LT, this.iwn),
            this.MCn();
            const [e,s] = this.BCn(this.UEn)
              , n = this.mV(0, 0, this.xa(s), 0, 0, 0, s);
            if (this.yV(n),
            "crop" === t && this.UEn && i) {
                const t = this.ZC / 2
                  , e = this.tv / 2
                  , s = i.ns()
                  , n = i.Kn()
                  , r = this.UEn.ns()
                  , h = this.UEn.Kn()
                  , o = Math.min(r, s)
                  , a = Math.min(h, n)
                  , l = Math.max(n - h, 0)
                  , u = Math.max(h - n, 0);
                UT.set(-t, e - u, -t + o, e - a - u),
                BT.sa(UT),
                UT.set(0, l, o, a + l),
                UT.tb(s, n),
                this.gr(BT, UT)
            } else {
                const t = e / 2
                  , i = s / 2;
                this.E9(-t, i, t, -i)
            }
            this.pV(FT),
            this.yV(LT)
        }
        $p(t) {
            if (this.WEn.equals(t))
                return;
            this.WEn.ia(t);
            this.xCn().YSn(t),
            this.BEn = 0
        }
        qp() {}
        tf(t, i, e, s) {
            this.kEn >= OT && this._gn();
            let n = this.kEn;
            const r = this.Mwn + this.Ewn;
            if (2 === this.BEn && this.NEn === r)
                this.FEn[this.LEn - 1].xSn++;
            else {
                this.xCn().ZSn(n, r, this.jEn),
                this.BEn = 2,
                this.NEn = r
            }
            const h = this.oci;
            h[n++] = t,
            h[n++] = i,
            h[n++] = e,
            h[n++] = s,
            this.kEn = n
        }
        Yw(t) {
            if (this.OEn === t)
                return;
            this.xCn().txn(t),
            this.OEn = t,
            this.BEn = 0,
            this.vwn = null
        }
        $w() {
            return this.OEn
        }
        UCn() {
            this.Yw(this.DEn)
        }
        NCn(t) {
            this.xCn().kSn(t),
            this.BEn = 0
        }
        jCn(t, i, e=1) {
            this.xCn().gxn(t, i, e),
            this.BEn = 0
        }
        kT(t, i, e, s, n, r, h) {
            if (this.OEn !== this.lwn)
                throw new Error("must set tilemap fill mode first");
            this.xCn().bxn(t, i, e, s, n, r, h),
            this.BEn = 0
        }
        TM(t, i, e, s, n, r, h) {
            if (this.OEn !== this.uwn)
                throw new Error("must set tile randomization mode first");
            this.xCn().Sxn(t, i, e, s, n, r, h),
            this.BEn = 0
        }
        $Cn(t, i, e, s, n, r, h, o, a, l, u) {
            const c = this.OEn;
            if (u %= 10800,
            !c.Tvn || c.Nvn(i, e, s, n, r, h, o, a, l, u))
                return;
            const d = this.xCn();
            d.exn(),
            c.jvn(i, e, s, n, r, h, o, a, l, u);
            const f = d.ESn;
            f[0] = r,
            f[1] = h,
            i.uDe(f, 2),
            f[6] = a,
            f[7] = l,
            e.uDe(f, 12);
            const p = d.CSn;
            n.uDe(p, 0);
            const m = p[1];
            p[1] = p[3],
            p[3] = m,
            s.uDe(d._Sn, 0),
            d.SSn = u,
            d.xSn = o,
            c.uvn.Sbn() ? (CT(!t || !this.UEn || t !== this.UEn, "Warning: setting texture1 to current render texture"),
            d.MSn = t ? t.Gn() : null) : d.MSn = null,
            this.BEn = 0
        }
        zCn(t) {
            const i = this.OEn;
            if (0 === t.length || i.Bvn(t))
                return;
            const e = this.xCn();
            e.rxn(),
            i.Uvn(t),
            ET.lw(e.TSn, t),
            this.BEn = 0
        }
        Pzs(t, i, e, s) {
            this.xCn().qSn(t, i, e, s),
            this.BEn = 0
        }
        tC(t) {
            this.xCn().KSn(t),
            this.BEn = 0
        }
        ke() {}
        qV() {
            super.qV(),
            this.mbn.flush()
        }
        LJs() {
            if (!this.gEn || !this.UEn || !this.UEn.GMn())
                return;
            this.xCn().Mxn(this.bEn),
            this.BEn = 0
        }
        VV(t) {
            if (t = !!t,
            this.bEn === t)
                return;
            if (!this.gEn)
                return;
            this.bEn = t;
            this.xCn().Cxn(t),
            this.BEn = 0
        }
        VCn() {
            return this.bEn
        }
        Pxn() {
            return this.SEn
        }
        CMn() {
            return this.yEn
        }
        WCn(t) {
            if (t = !!t,
            !this.yEn)
                return;
            if (this.vEn === t)
                return;
            if (t && this.VCn())
                throw new Error("depth still enabled");
            this.vEn = t;
            this.xCn().Txn(t),
            this.BEn = 0
        }
        HCn(t, i, e, s, n=0) {
            if (t = Math.floor(t),
            i = Math.floor(i),
            e = Math.floor(e),
            s = Math.floor(s),
            this.HEn.jDe(t, i, e, s))
                return;
            this.HEn.ff(t, i, e, s);
            i = (n || this.BCn(this.tJs())[1]) - i - s;
            this.xCn().Fxn(!0, t, i, e, s),
            this.BEn = 0
        }
        KCn() {
            if (-1 === this.HEn.gl())
                return;
            this.HEn.set(0, 0, -1, -1);
            this.xCn().Fxn(!1, 0, 0, 0, 0),
            this.BEn = 0
        }
        qCn() {
            for (const t of this.dCn)
                t.rEn(this.Gwn)
        }
        un() {
            return !this.mbn || this.mbn.isContextLost() || this.eCn
        }
        Vs() {
            super.Own(),
            ET.ra.Hxn.Vs(),
            ET.ra.mMn.Vs(),
            ET.ra.na.Vs();
            for (const t of this.dCn)
                t.tC();
            this.iCn = [],
            this.UMn = null,
            this.sCn = null,
            this.rCn = null,
            this.nCn = null,
            this.hCn = null,
            this.oCn = null,
            this.aCn = null,
            this.lCn = null,
            this.uCn = 0,
            this.QEn = "(unavailable)",
            this.tCn = "(unavailable)",
            this.OEn = null,
            this.DEn = null,
            this.SEn = null;
            for (const t of this.bwn.values())
                t.Vs()
        }
        async Lv() {
            this.eCn = !0,
            await this.w0(),
            this.eCn = !1;
            for (const t of this.bwn.values())
                t.Lv(this);
            this.Hr(this.ZC, this.tv, !0)
        }
        In(t, i) {
            if (this.un())
                throw new Error("context lost");
            this._gn();
            const e = ET.v(ET.ra.Hxn, this);
            return e.Zxn(t, i),
            e
        }
        async Sn(t, i) {
            if (this.un())
                throw new Error("context lost");
            if (i = Object.assign({}, i),
            ET.zk.Qhs) {
                let e = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply"
                });
                const s = i.On && "clamp-to-edge" !== i.On || i.Pn && "clamp-to-edge" !== i.Pn
                  , n = ET.zOe(e.width) && ET.zOe(e.height);
                return this.kv() || n || !s ? i.Wxn = !1 : ET.zk.KRe ? (e = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply",
                    resizeWidth: ET.ha(e.width),
                    resizeHeight: ET.ha(e.height)
                }),
                i.Wxn = !1) : e = await createImageBitmap(t, {
                    premultiplyAlpha: "none"
                }),
                await ET._Ct( () => this.In(e, i))
            }
            if (t instanceof Blob) {
                if ("undefined" == typeof Image)
                    throw new Error("texture upload variant not supported in worker");
                const i = await ET.jv(t);
                t = i
            }
            return await ET._Ct( () => this.In(t, i))
        }
        sK(t, i, e) {
            this._gn();
            const s = ET.v(ET.ra.Hxn, this);
            return s.sMn(t, i, e),
            s
        }
        eK(t, i, e) {
            this._gn(),
            i.$Wt(t, e)
        }
        pn(t) {
            t && (t.lMn(),
            t.uMn() > 0 || (this._gn(),
            t === this.$En && (this.mbn.bindTexture(this.mbn.TEXTURE_2D, null),
            this.$En = null),
            t === this.nxn && (this.mbn.activeTexture(this.mbn.TEXTURE1),
            this.mbn.bindTexture(this.mbn.TEXTURE_2D, null),
            this.mbn.activeTexture(this.mbn.TEXTURE0),
            this.nxn = null),
            t.Hwt()))
        }
        R0(t) {
            ET.Wat(t);
            let i = this.ZC
              , e = this.tv
              , s = !0;
            if (t && ("number" == typeof t.width && (i = Math.floor(t.width),
            s = !1),
            "number" == typeof t.height && (e = Math.floor(t.height),
            s = !1)),
            i <= 0 || e <= 0)
                throw new Error("invalid size");
            this._gn();
            const n = ET.v(ET.ra.mMn, this);
            return n._k(i, e, Object.assign({
                fMn: s
            }, t)),
            this.UEn = null,
            this.vSn.mSn = null,
            this.vSn.wSn = null,
            n
        }
        UV(t, i=!0) {
            if (t === this.UEn)
                return;
            t && t.AMn() && t._Mn(this.ZC, this.tv);
            this.xCn().zSn(t),
            this.UEn = t,
            this.BEn = 0,
            i && this.MCn()
        }
        tJs() {
            return this.UEn
        }
        BCn(t) {
            return t ? [t.ns(), t.Kn()] : [this.ZC, this.tv]
        }
        XCn(t, i="stretch") {
            if (CT(t !== this.UEn, "copying render target to itself"),
            this.i3t < 2 || this.UEn && this.UEn.RMn() > 0)
                this.RCn(),
                this.qr(),
                this.sJs(t, i);
            else {
                this.xCn().lxn(t, this.UEn, i),
                this.BEn = 0
            }
        }
        sJs(t, i="stretch") {
            CT(t !== this.UEn, "drawing render target to itself");
            const e = t.Gn();
            if (!e)
                throw new Error("not a texture-backed render target");
            this.dr(e),
            this.LCn(i, e)
        }
        iJs(t) {
            if (this.i3t < 2)
                return;
            this.xCn().oxn(t.WSn()),
            this.BEn = 0
        }
        YCn(t) {
            this.UV(null),
            this._gn();
            const i = t.Gn();
            i === this.$En && (this.mbn.bindTexture(this.mbn.TEXTURE_2D, null),
            this.$En = null),
            i === this.nxn && (this.mbn.activeTexture(this.mbn.TEXTURE1),
            this.mbn.bindTexture(this.mbn.TEXTURE_2D, null),
            this.mbn.activeTexture(this.mbn.TEXTURE0),
            this.nxn = null),
            t.Hwt()
        }
        async FMn(t, i, e) {
            this._gn();
            const s = this.UEn;
            let n, r, h;
            t ? (n = t.ns(),
            r = t.Kn(),
            h = t.WSn()) : (n = this.ns(),
            r = this.Kn(),
            h = null);
            let o = 0
              , a = 0
              , l = n
              , u = r;
            if (e) {
                o = ET.Ne(Math.floor(e.Kr()), 0, n - 1),
                a = ET.Ne(Math.floor(e.Zr()), 0, r - 1);
                let t = e.width();
                t = 0 === t ? n - o : ET.Ne(Math.floor(t), 0, n - o);
                let i = e.height();
                i = 0 === i ? r - a : ET.Ne(Math.floor(i), 0, r - a),
                l = t,
                u = i,
                a = r - (a + u)
            }
            const c = this.mbn;
            c.bindFramebuffer(c.FRAMEBUFFER, h);
            const d = () => {
                c.bindFramebuffer(c.FRAMEBUFFER, null),
                this.UEn = null,
                this.vSn.mSn = null,
                this.vSn.wSn = null,
                this.UV(s)
            }
            ;
            let f;
            if (!i && this.Qxn() >= 2) {
                c.bindFramebuffer(c.READ_FRAMEBUFFER, h);
                const t = c.createBuffer()
                  , i = l * u * 4
                  , e = c.PIXEL_PACK_BUFFER;
                c.bindBuffer(e, t),
                c.bufferData(e, i, c.STREAM_READ),
                c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, 0),
                c.bindFramebuffer(c.READ_FRAMEBUFFER, null),
                c.bindBuffer(e, null),
                d();
                const s = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this.Vbn( () => c.getSyncParameter(s, c.SYNC_STATUS) === c.SIGNALED),
                c.deleteSync(s),
                f = new ImageData(l,u),
                c.bindBuffer(e, t),
                c.getBufferSubData(e, 0, new Uint8Array(f.data.buffer), 0, i),
                c.bindBuffer(e, null),
                c.deleteBuffer(t)
            } else
                f = new ImageData(l,u),
                c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, new Uint8Array(f.data.buffer)),
                d();
            return f
        }
        JCn() {
            this.VV(!0);
            this.xCn().Gxn(),
            this.BEn = 0,
            this.KEn = 1
        }
        ZCn(t=!1) {
            this.VV(t);
            this.xCn().Rxn(),
            this.BEn = 0,
            this.KEn = 2
        }
        QCn() {
            return 2 === this.KEn
        }
        t_n(t=!0) {
            this.VV(t);
            this.xCn().Oxn(),
            this.BEn = 0,
            this.KEn = 0
        }
        i_n(t) {
            if (!this.e_n())
                return;
            this.xCn().cxn(t),
            this.BEn = 0
        }
        s_n(t) {
            if (!this.e_n())
                return;
            this.xCn().pxn(t),
            this.BEn = 0
        }
        Vbn(t) {
            const i = new Promise(i => jT.add({
                resolve: i,
                dEn: t
            }));
            return -1 === $T && ($T = self.requestAnimationFrame(zT)),
            i
        }
        kgn() {
            return this.ZC * this.tv * (this.fEn.alpha ? 4 : 3)
        }
        Ogn() {
            let t = 0;
            for (const i of ET.ra.mMn.LMn())
                i.Gn() || (t += i.YZ());
            return t
        }
        Dgn() {
            let t = 0;
            for (const i of ET.ra.Hxn.cMn())
                t += i.YZ();
            return t
        }
        n_n() {
            return this.pEn
        }
        Qxn() {
            return this.i3t
        }
        Jbn() {
            return this._En
        }
        MEt() {
            return "webgl" + this.Qxn()
        }
        kv() {
            return this.Qxn() >= 2
        }
        Yyn() {
            return this.YEn
        }
        if() {
            return this.JEn
        }
        ef() {
            return this.ZEn
        }
        r_n() {
            return this.QEn
        }
        h_n() {
            return this.tCn
        }
        o_n() {
            if (this.Qxn() >= 2)
                return "webgl2";
            {
                const t = [];
                return this.oCn && t.push("EXT_frag_depth"),
                this.aCn && t.push("OES_standard_derivatives"),
                this.lCn && t.push("EXT_shader_texture_lod"),
                t.length > 0 ? "webgl1:" + t.join(",") : "webgl1:none"
            }
        }
        a_n() {
            return this.iCn
        }
        e_n() {
            return !!this.UMn
        }
        NMn() {
            return this.UMn
        }
        zbn() {
            return this.sCn
        }
        mCn() {
            return !!this.rCn
        }
        hMn() {
            return this.nCn
        }
        oMn() {
            return this.uCn
        }
        eEn(t) {
            this.dCn.add(t)
        }
        sEn(t) {
            this.dCn.delete(t)
        }
        JMn() {
            return this.fCn
        }
        dMt() {
            return this.mbn
        }
        pCn(t) {
            this.Zwn([["normal", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["additive", t.ONE, t.ONE], ["xor", t.ONE, t.ONE_MINUS_SRC_ALPHA], ["copy", t.ONE, t.ZERO], ["destination-over", t.ONE_MINUS_DST_ALPHA, t.ONE], ["source-in", t.DST_ALPHA, t.ZERO], ["destination-in", t.ZERO, t.SRC_ALPHA], ["source-out", t.ONE_MINUS_DST_ALPHA, t.ZERO], ["destination-out", t.ZERO, t.ONE_MINUS_SRC_ALPHA], ["source-atop", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], ["destination-atop", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]])
        }
        l_n() {
            return this.Lgn()
        }
    }
}
{
    const VT = self.t
      , WT = self.sG
      , HT = (WT.hG,
    WT.eG)
      , KT = self.assert
      , qT = self.GPUBufferUsage
      , XT = self.GPUShaderStage
      , YT = (self.GPUMapMode,
    self.GPUTextureUsage)
      , JT = {
        powerPreference: "default",
        l0: !1,
        o0: !1,
        u_n: !1,
        c_n: "bilinear",
        d_n: !1,
        a0: !1,
        f_n: !0
    }
      , ZT = 65535
      , QT = 6 * ZT
      , tI = Math.floor(ZT / 4)
      , iI = ZT
      , eI = 4 * tI - 16
      , sI = 1
      , nI = 2
      , rI = 4
      , hI = 8
      , oI = 16
      , aI = 32
      , lI = 64
      , uI = 128
      , cI = 256
      , dI = 512
      , fI = 1024
      , pI = 2048
      , mI = 4096
      , wI = 8192
      , gI = 16384
      , yI = 32768
      , bI = 65536
      , vI = 1 << 17
      , SI = 1 << 18
      , xI = 1 << 19
      , MI = 1 << 20
      , EI = 1 << 21
      , CI = 1 << 22
      , _I = 1 << 23
      , TI = 1 << 24
      , II = 1 << 25
      , PI = 1 << 26
      , GI = 1 << 27
      , AI = 1 << 28
      , RI = 1 << 29
      , kI = 1 << 30
      , OI = 1
      , DI = oI | aI | wI | lI | uI | cI
      , FI = DI | hI | sI
      , LI = DI | gI
      , BI = dI | fI | pI | mI
      , UI = 2
      , NI = 4
      , jI = 2
      , $I = 4
      , zI = new VT.Nn(0,0,1,0,1,1,0,1)
      , VI = VT.v(VT.m3)
      , WI = VT.v(VT.Rect)
      , HI = (VT.v(VT.Rect),
    VT.v(VT.Nn));
    VT.ra.u0 = class extends VT.ra.RC {
        constructor(t) {
            super(t),
            this.p_n = null,
            this.wfi = null,
            this.m_n = null,
            this.w_n = null,
            this.xG = null,
            this.g_n = null,
            this.y_n = "",
            this.b_n = null,
            this.v_n = null,
            this.Lti = 0,
            this.Bti = 0,
            this.S_n = HT.create(),
            this.SEn = null,
            this.x_n = null,
            this.M_n = null,
            this.E_n = null,
            this.C_n = null,
            this.__n = null,
            this.MEn = 0,
            this.EEn = 0,
            this.T_n = null,
            this.I_n = null,
            this.P_n = null,
            this.G_n = null,
            this.qbn = null,
            this.Xbn = null,
            this.A_n = null,
            this.Ybn = null,
            this.CEn = null,
            this.R_n = null,
            this.Zbn = null,
            this.k_n = VT.ra.D_n.O_n(),
            this.F_n = VT.ra.D_n.L_n(),
            this.B_n = null,
            this.U_n = null,
            this.N_n = VT.ra.D_n.j_n(),
            this.$_n = VT.ra.D_n.z_n(),
            this.V_n = null,
            this.W_n = null,
            this.H_n = VT.ra.D_n.K_n(),
            this.q_n = VT.ra.D_n.X_n(),
            this.Y_n = null,
            this.J_n = null,
            this.Z_n = null,
            this.TEn = new Float32Array(3 * ZT),
            this.PEn = new Float32Array(2 * ZT),
            this.Q_n = new Uint32Array(ZT),
            this.GEn = null,
            this.IEn = new Uint16Array(QT),
            this.oci = new Float32Array(4 * tI),
            this.AEn = 0,
            this.REn = 0,
            this.tTn = 0,
            this.iTn = VT.v(VT.Ha, 1, 1, 1, 1),
            this.kEn = 0,
            this.eTn = VT.v(VT.ra.sTn, this),
            this.nTn = yI,
            this.rTn = 0,
            this.hTn = 0,
            this.oTn = 0,
            this.aTn = 0,
            this.lTn = 0,
            this.uTn = 0,
            this.cTn = 0,
            this.dTn = 0,
            this.fTn = 0,
            this.pTn = VT.v(VT.Rect, 0, 0, 0, 0),
            this.mTn = VT.v(VT.Ha, 1, 1, 1, 1),
            this.wTn = VT.v(VT.Ha, 1, 1, 1, 1),
            this.gTn = VT.v(VT.Rect, 0, 0, 0, 0),
            this.yTn = 0,
            this.bTn = "",
            this.vTn = null,
            this.STn = null,
            this.xTn = null,
            this.MTn = null,
            this.ETn = null,
            this.CTn = null,
            this._Tn = null,
            this.TTn = null,
            this.ITn = null,
            this.PTn = null,
            this.GTn = null,
            this.ATn = null,
            this.RTn = null,
            this.kTn = new Set,
            this.OTn = new Set,
            this.YEn = 8192,
            this.DTn = null,
            this.FTn = null,
            this.LTn = null,
            this.BTn = null,
            this.UTn = 0,
            this.NTn = 0,
            this.jTn = 0,
            this.$Tn = 0,
            this.zTn = null,
            this.VTn = null,
            this.WTn = new Map,
            this.HTn = null,
            this.KTn = null,
            this.qTn = [],
            this.XTn = null,
            this.UEn = null,
            this.YTn = !1,
            this.JTn = "bilinear",
            this.ZTn = !1,
            this.yEn = !1,
            this.QTn = null,
            this.tIn = !1,
            this.iIn = -1,
            this.eIn = -1,
            this.sIn = new Set,
            this.y0 = null,
            this.g0 = null,
            this.pCn()
        }
        Zd() {
            return !0
        }
        nIn(t, i) {
            i ? this.nTn |= t : this.nTn &= ~t
        }
        rIn(t) {
            return 0 !== (this.nTn & t)
        }
        hIn(t, i) {
            i ? this.rTn |= t : this.rTn &= ~t
        }
        oIn(t) {
            return 0 !== (this.rTn & t)
        }
        async y_(t, i) {
            if (i = Object.assign({}, JT, i),
            !navigator.gpu)
                throw new Error("renderer-unavailable (WebGPU not supported)");
            i.l0 && (this.nTn |= xI),
            i.f_n && (this.nTn |= bI),
            this.YTn = !!i.u_n,
            this.JTn = i.c_n,
            this.ZTn = !!i.d_n,
            this.p_n = {},
            this.yEn = !(!i.l0 || !i.a0),
            "default" !== i.powerPreference && (this.p_n.powerPreference = i.powerPreference),
            this.xG = t,
            await this.aIn(i.o0)
        }
        async aIn(t) {
            for (this.w_n = null,
            await this.lIn(t); !this.w_n; )
                this.wfi = null,
                await this.lIn(t);
            await this.w0()
        }
        async lIn(t) {
            if (!this.wfi) {
                if (this.wfi = await navigator.gpu.requestAdapter(this.p_n),
                !this.wfi)
                    throw new Error("renderer-unavailable (no WebGPU adapter available)");
                if (t && (this.wfi.isFallbackAdapter || this.wfi.info.isFallbackAdapter))
                    throw new Error("renderer-unavailable (WebGPU provided fallback adapter)");
                if ("adreno-7xx" === this.wfi.info.architecture)
                    throw new Error("WebGPU disabled on adreno-7xx devices - see https://issues.chromium.org/issues/329702056")
            }
            const i = [];
            if (this.wfi.features.has("timestamp-query") && i.push("timestamp-query"),
            this.wfi.features.has("shader-f16") && i.push("shader-f16"),
            this.w_n = await this.wfi.requestDevice({
                requiredFeatures: i,
                requiredLimits: {
                    maxTextureDimension2D: this.wfi.limits.maxTextureDimension2D
                }
            }),
            !this.w_n)
                return null;
            this.YEn = this.w_n.limits.maxTextureDimension2D,
            this.nIn(GI, this.w_n.features.has("timestamp-query")),
            this.nIn(AI, this.w_n.features.has("shader-f16")),
            this.nIn(RI, this.rIn(AI) && void 0 !== globalThis.Float16Array),
            this.w_n.lost.then(t => this.uIn(t)),
            this.nIn(yI, !1)
        }
        async uIn(t) {
            console.log("[WebGPU] Device lost: ", t),
            super.Own(),
            this.eTn.Vs(),
            VT.ra.cIn.Vs(),
            VT.ra.dIn.Vs(),
            VT.ra.na.Vs(),
            this.y_n = "",
            this.b_n = null,
            this.v_n = null,
            this.SEn = null,
            this.M_n = null,
            this.x_n = null,
            this.E_n = null,
            this.C_n = null,
            this.__n = null,
            this.qbn = null,
            this.Xbn = null,
            this.A_n = null,
            this.Ybn = null,
            this.CEn = null,
            this.R_n = null,
            this.Zbn = null,
            this.T_n = null,
            this.I_n = null,
            this.P_n = null,
            this.G_n = null,
            this.STn = null,
            this.vTn = null,
            this.ATn = null,
            this.xTn = null,
            this.MTn = null,
            this.ETn = null,
            this.DTn = null,
            this.BTn = null,
            this.CTn = null,
            this._Tn = null,
            this.TTn = null,
            this.ITn = null,
            this.PTn = null,
            this.GTn = null,
            this.FTn = null,
            this.LTn = null,
            this.XTn = null,
            this.UEn = null,
            this.RTn = null,
            this.QTn = null,
            this.zTn = null,
            this.VTn = null,
            this.kTn.clear(),
            this.OTn.clear(),
            this.WTn.clear();
            for (const t of this.bwn.values())
                t.Vs();
            this.w_n = null,
            this.wfi = null,
            this.m_n = null,
            this.nTn |= yI,
            this.y0 && this.y0(),
            await this.aIn();
            for (const t of this.bwn.values())
                t.Lv(this);
            this.Hr(this.ZC, this.tv, !0),
            this.g0 && this.g0()
        }
        async w0() {
            super.w0();
            const t = this.w_n;
            this.y_n = navigator.gpu.getPreferredCanvasFormat(),
            this.b_n = null,
            this.v_n = null;
            let i = YT.RENDER_ATTACHMENT;
            this.YTn && (i |= YT.TEXTURE_BINDING),
            this.ZTn && (i |= YT.COPY_SRC),
            this.y_n.startsWith("rgba8") || this.y_n.startsWith("bgra8") ? this.bTn = this.y_n : this.bTn = "rgba8unorm",
            this.nTn &= xI | GI | AI | RI | bI,
            this.nTn |= BI,
            this.rTn = 0,
            this.rIn(xI) && (this.nTn |= MI | EI | PI),
            this.AEn = 0,
            this.REn = 0,
            this.UTn = 0,
            this.jTn = 0,
            this.$Tn = 0,
            this.NTn = 0,
            this.iTn.CIs(1, 1, 1, 1),
            this.mTn.CIs(1, 1, 1, 1),
            this.wTn.CIs(1, 1, 1, 1),
            this.GEn = this.Jbn() ? new globalThis.Float16Array(4 * iI) : new Float32Array(4 * iI),
            this.B_n = new ArrayBuffer(this.F_n),
            this.U_n = new Float32Array(this.B_n),
            this.V_n = new ArrayBuffer(this.$_n),
            this.W_n = new Float32Array(this.V_n),
            this.Y_n = new ArrayBuffer(this.q_n),
            this.J_n = new Float32Array(this.Y_n),
            this.Z_n = new Uint32Array(this.Y_n),
            this.qbn = t.createBuffer({
                label: "vertexbuffer",
                size: this.TEn.byteLength,
                usage: qT.VERTEX | qT.COPY_DST
            }),
            this.Xbn = t.createBuffer({
                label: "texcoordbuffer",
                size: this.PEn.byteLength,
                usage: qT.VERTEX | qT.COPY_DST
            }),
            this.A_n = t.createBuffer({
                label: "texindexbuffer",
                size: this.Q_n.byteLength,
                usage: qT.VERTEX | qT.COPY_DST
            }),
            this.Ybn = t.createBuffer({
                label: "colorbuffer",
                size: this.GEn.byteLength,
                usage: qT.VERTEX | qT.COPY_DST
            }),
            this.CEn = t.createBuffer({
                label: "indexbuffer",
                size: this.IEn.byteLength,
                usage: qT.INDEX | qT.COPY_DST
            }),
            this.R_n = t.createBuffer({
                label: "pointsindexbuffer",
                size: 6 * tI * 2,
                usage: qT.INDEX,
                mappedAtCreation: !0
            });
            const e = this.R_n.getMappedRange();
            this.fIn(e),
            this.R_n.unmap(),
            this.Zbn = t.createBuffer({
                label: "pointbuffer",
                size: this.oci.byteLength,
                usage: qT.VERTEX | qT.STORAGE | qT.COPY_DST
            }),
            this.vTn = t.createBindGroupLayout({
                label: "bufferbindgrouplayout",
                entries: [{
                    binding: 0,
                    visibility: XT.VERTEX,
                    buffer: {
                        type: "uniform",
                        minBindingSize: this.F_n
                    }
                }, {
                    binding: 1,
                    visibility: XT.FRAGMENT,
                    buffer: {
                        type: "uniform",
                        minBindingSize: this.$_n
                    }
                }, {
                    binding: 3,
                    visibility: XT.VERTEX,
                    buffer: {
                        type: "read-only-storage",
                        minBindingSize: this.oci.byteLength
                    }
                }, {
                    binding: 4,
                    visibility: XT.FRAGMENT,
                    buffer: {
                        type: "uniform",
                        minBindingSize: this.q_n
                    }
                }, {
                    binding: 5,
                    visibility: XT.FRAGMENT,
                    buffer: {
                        type: "uniform"
                    }
                }]
            });
            const s = []
              , n = VT.ra.mIn.pIn();
            for (let t = 0; t < n; ++t)
                s.push({
                    binding: 2 * t,
                    visibility: XT.FRAGMENT,
                    sampler: {
                        type: "filtering"
                    }
                }, {
                    binding: 2 * t + 1,
                    visibility: XT.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d"
                    }
                });
            this.xTn = t.createBindGroupLayout({
                label: "texturebindgrouplayout",
                entries: s
            }),
            this.MTn = t.createBindGroupLayout({
                label: "backtexturebindgrouplayout",
                entries: [{
                    binding: 0,
                    visibility: XT.FRAGMENT,
                    sampler: {
                        type: "nearest" === this.JTn ? "non-filtering" : "filtering"
                    }
                }, {
                    binding: 1,
                    visibility: XT.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d"
                    }
                }]
            }),
            this.ETn = t.createBindGroupLayout({
                label: "depthtexturebindgrouplayout",
                entries: [{
                    binding: 0,
                    visibility: XT.FRAGMENT,
                    sampler: {
                        type: "non-filtering"
                    }
                }, {
                    binding: 1,
                    visibility: XT.FRAGMENT,
                    texture: {
                        sampleType: "depth",
                        viewDimension: "2d"
                    }
                }]
            }),
            this.DTn = t.createPipelineLayout({
                bindGroupLayouts: [this.vTn, this.xTn, this.MTn, this.ETn]
            });
            const r = VT.ra.D_n
              , h = this.wIn()
              , o = this.Jbn();
            this.FTn = t.createShaderModule({
                label: "<default vertex module>",
                code: r.gIn(r.Hvn(o), h)
            }),
            this.FTn.getCompilationInfo().then(t => r.yIn("<default>", "vertex", t)),
            this.LTn = t.createShaderModule({
                label: "<normalized vertex module>",
                code: r.gIn(r.bIn(o), h)
            }),
            this.LTn.getCompilationInfo().then(t => r.yIn("<normalized>", "vertex", t));
            const a = await Promise.all([r.y_(this, {
                name: "<default>",
                src: r.vIn(!1, o),
                SIn: r.vIn(!0, o),
                $bn: r.xIn(o),
                MIn: r.EIn(o)
            }), r.y_(this, {
                name: "<single-texture-fill>",
                src: r.CIn(!1, o),
                SIn: r.CIn(!0, o),
                $bn: r.xIn(o),
                MIn: r.EIn(o)
            }), r.y_(this, {
                name: "<generate-mipmap>",
                src: r._In(),
                $bn: r.TIn()
            }), r.y_(this, {
                name: "<point>",
                src: r.IIn(!1),
                SIn: r.IIn(!0),
                $bn: r.PIn()
            }), r.y_(this, {
                name: "<tilemap>",
                src: r.GIn(!1),
                SIn: r.GIn(!0)
            }), r.y_(this, {
                name: "<fill>",
                src: r.AIn()
            }), r.y_(this, {
                name: "<lineargradient>",
                src: r.RIn()
            }), r.y_(this, {
                name: "<penumbra>",
                src: r.kIn()
            }), r.y_(this, {
                name: "<hardellipse>",
                src: r.OIn()
            }), r.y_(this, {
                name: "<hardellipseoutline>",
                src: r.DIn()
            }), r.y_(this, {
                name: "<smoothellipse>",
                src: r.FIn()
            }), r.y_(this, {
                name: "<smoothellipseoutline>",
                src: r.LIn()
            }), r.y_(this, {
                name: "<tilerandomization>",
                src: r.tSn(!1),
                SIn: r.tSn(!0)
            }), r.y_(this, {
                name: "<smoothline>",
                src: r.BIn()
            })]);
            this.own = a[0],
            this.VTn = a[1],
            this.zTn = a[2],
            this.awn = a[3],
            this.lwn = a[4],
            this.cwn = a[5],
            this.dwn = a[6],
            this.fwn = a[7],
            this.pwn = a[8],
            this.mwn = a[9],
            this.wwn = a[10],
            this.gwn = a[11],
            this.uwn = a[12],
            this.ywn = a[13];
            for (const t of a)
                this.Uwn(t);
            0 !== (this.nTn & bI) ? (this.nTn |= vI | SI,
            this.BTn = this.own) : this.BTn = this.VTn,
            this.RTn = this.zTn.UIn(),
            this.T_n = t.createBuffer({
                label: "vertexuniformbuffer",
                size: this.F_n,
                usage: qT.UNIFORM | qT.COPY_DST
            }),
            this.I_n = t.createBuffer({
                label: "fragmentuniformbuffer",
                size: this.$_n,
                usage: qT.UNIFORM | qT.COPY_DST
            }),
            this.P_n = t.createBuffer({
                label: "fragmentc3paramsuniformbuffer",
                size: this.q_n,
                usage: qT.UNIFORM | qT.COPY_DST
            }),
            this.G_n = t.createBuffer({
                label: "fragmentdefaultcustomparamsbuffer",
                size: 16,
                usage: qT.UNIFORM | qT.COPY_DST
            }),
            this.aTn = 0,
            this.lTn = this.F_n,
            this.NIn(),
            this.jIn(),
            this.$In(),
            this.uTn = 0,
            this.cTn = this.$_n,
            this.zIn(),
            this.VIn(),
            this.STn = this.WIn(this.G_n),
            this.ATn = this.STn;
            const l = VT.GS(32, 32);
            l.getContext("2d"),
            this.CTn = await this.Sn(l),
            this._Tn = null,
            this.TTn = this.CTn.HIn(),
            this.tTn = 0,
            this.ITn = null,
            this.PTn = this.CTn.KIn(),
            this.CTn.qIn(),
            this.x_n = this.w_n.createTexture({
                label: "nulldepthbuffer",
                size: [8, 8, 1],
                format: this.XIn(),
                usage: YT.TEXTURE_BINDING
            }),
            this.E_n = this.x_n.createView({
                label: "nulldepthbufferview",
                aspect: "depth-only"
            }),
            this.__n = this.w_n.createBindGroup({
                label: "nulldepthbufferbindgroup",
                layout: this.ETn,
                entries: [{
                    binding: 0,
                    resource: this.YIn({
                        Cn: "nearest"
                    })
                }, {
                    binding: 1,
                    resource: this.E_n
                }]
            }),
            this.GTn = this.__n,
            this.XTn = VT.v(VT.ra.dIn, this, !0),
            this.XTn.Gn().JIn(i, this.y_n),
            this.UEn = this.XTn,
            this.ZIn(),
            this.m_n = this.wfi.info,
            this.g_n || (this.g_n = this.xG.getContext("webgpu")),
            this.g_n.configure({
                device: t,
                format: this.y_n,
                usage: i,
                alphaMode: "premultiplied"
            })
        }
        WIn(t) {
            return this.w_n.createBindGroup({
                layout: this.vTn,
                entries: [{
                    binding: 0,
                    resource: {
                        buffer: this.T_n
                    }
                }, {
                    binding: 1,
                    resource: {
                        buffer: this.I_n
                    }
                }, {
                    binding: 3,
                    resource: {
                        buffer: this.Zbn
                    }
                }, {
                    binding: 4,
                    resource: {
                        buffer: this.P_n
                    }
                }, {
                    binding: 5,
                    resource: {
                        buffer: t
                    }
                }]
            })
        }
        fIn(t) {
            KT(t.byteLength % 12 == 0, "wrong size index buffer");
            const i = new Uint16Array(t);
            let e = 0
              , s = i.length
              , n = 0;
            for (; e < s; )
                i[e++] = n,
                i[e++] = n + 1,
                i[e++] = n + 2,
                i[e++] = n,
                i[e++] = n + 2,
                i[e++] = n + 3,
                n += 4
        }
        QIn() {
            return this.w_n
        }
        tPn() {
            return this.FTn
        }
        iPn() {
            return this.LTn
        }
        async wCn(t) {
            const i = await VT.ra.D_n.y_(this, t);
            return this.Uwn(i),
            i
        }
        MEt() {
            return "webgpu"
        }
        ePn() {
            return this.y_n
        }
        XIn() {
            return "depth24plus-stencil8"
        }
        sPn() {
            return this.b_n
        }
        nPn() {
            return this.v_n
        }
        rPn() {
            return this.YTn
        }
        hPn() {
            return this.ZTn
        }
        oPn() {
            return this.DTn
        }
        aPn() {
            return this.xTn
        }
        lPn() {
            return this.MTn
        }
        uPn() {
            return this.JTn
        }
        cPn() {
            return this.bTn
        }
        Yyn() {
            return this.YEn
        }
        un() {
            return this.rIn(yI)
        }
        e_n() {
            return this.rIn(GI)
        }
        wIn() {
            return this.rIn(AI)
        }
        Jbn() {
            return this.rIn(RI)
        }
        kgn() {
            const t = this.ns() * this.Kn();
            let i = t * VT.ra.cIn.dPn(this.y_n);
            return this.fPn() && (i += t * VT.ra.cIn.dPn(this.XIn())),
            i
        }
        Ogn() {
            let t = 0;
            for (const i of VT.ra.dIn.LMn())
                i.pPn() || (t += i.Gn().YZ());
            return t
        }
        Dgn() {
            let t = 0;
            for (const i of VT.ra.cIn.cMn())
                i.mPn() || (t += i.YZ());
            return t
        }
        kv() {
            return !0
        }
        wPn() {
            return this.eTn
        }
        Hr(t, i, e) {
            (this.ZC !== t || this.tv !== i || e) && (this._gn(),
            this.ZC = t,
            this.tv = i,
            this.Lti = t,
            this.Bti = i,
            this.XTn.EMn(),
            this.pV(this.XTn.TMn()),
            this.UEn && this.UEn._Mn(this.ZC, this.tv),
            this.rIn(xI) && this.rIn(PI) && this.bCn(t, i))
        }
        bCn(t, i) {
            if (this.SEn) {
                if (this.MEn === t && this.EEn === i)
                    return;
                this.SEn.destroy()
            }
            let e = YT.RENDER_ATTACHMENT;
            this.yEn && (e |= YT.TEXTURE_BINDING),
            this.SEn = this.w_n.createTexture({
                label: "depthbuffer",
                size: [t, i, 1],
                format: this.XIn(),
                usage: e
            }),
            this.M_n = this.SEn.createView({
                label: "depthbufferview"
            }),
            this.yEn && (this.C_n = this.w_n.createBindGroup({
                label: "depthbufferbindgroup",
                layout: this.ETn,
                entries: [{
                    binding: 0,
                    resource: this.YIn({
                        Cn: "nearest"
                    })
                }, {
                    binding: 1,
                    resource: this.SEn.createView({
                        label: "depthbufferview",
                        aspect: "depth-only"
                    })
                }]
            })),
            this.MEn = t,
            this.EEn = i
        }
        vCn(t, i) {
            this.fPn() && (this.nIn(PI, !1),
            this.bCn(t, i))
        }
        SCn() {
            this.fPn() && (this.nIn(PI, !0),
            this.bCn(this.ZC, this.tv))
        }
        pV(t) {
            HT.wMe(this.twn, t) || (HT.ia(this.twn, t),
            this.NIn())
        }
        MCn() {
            this.pV(this.UEn.TMn())
        }
        yV(t) {
            HT.wMe(this.iwn, t) || (HT.ia(this.iwn, t),
            this.NIn())
        }
        ECn() {
            this.hIn(OI, !1)
        }
        Mzs() {
            return this.oIn(OI)
        }
        In(t, i) {
            if (VT.BM(t),
            t && !VT.ra.cIn.gPn(t)) {
                const i = t.width || t.videoWidth
                  , e = t.height || t.videoHeight
                  , s = VT.GS(i, e);
                s.getContext("2d").drawImage(t, 0, 0, i, e),
                t = s
            }
            this._gn();
            const e = VT.v(VT.ra.cIn, this);
            return e._k(t, i),
            e
        }
        async Sn(t, i) {
            if (VT.ra.cIn.gPn(t))
                return this.In(t, i);
            {
                if (!VT.zk.Qhs)
                    throw new Error("no support for ImageBitmapOptions");
                const e = await createImageBitmap(t, {
                    premultiplyAlpha: "premultiply"
                });
                return this.In(e, i)
            }
        }
        YIn(t) {
            const i = t.On || "clamp-to-edge"
              , e = t.Pn || "clamp-to-edge"
              , s = t.Cn;
            let n = t.vn || 0;
            "trilinear" !== s && (n = 0);
            const r = `${i},${e},${s},${n}`;
            let h = this.WTn.get(r);
            if (h)
                return h;
            const o = {
                addressModeU: i,
                addressModeV: e,
                magFilter: "nearest",
                minFilter: "nearest",
                mipmapFilter: "nearest"
            };
            return "bilinear" !== s && "trilinear" !== s || (o.magFilter = "linear",
            o.minFilter = "linear"),
            "trilinear" === s && (o.mipmapFilter = "linear",
            n > 1 && (o.maxAnisotropy = n)),
            h = this.w_n.createSampler(o),
            this.WTn.set(r, h),
            h
        }
        UIn() {
            return this.RTn
        }
        sK(t, i, e) {
            this._gn();
            const s = VT.v(VT.ra.cIn, this);
            return s.sMn(t, i, e),
            s
        }
        eK(t, i, e) {
            return i.$Wt(t, e)
        }
        pn(t) {
            t && (t.lMn(),
            t.uMn() > 0 || (this.un() || (this._gn(),
            this._Tn === t && this.dr(null),
            this.ITn === t && this.yPn(null)),
            t.Hwt()))
        }
        bPn(t, i) {
            this.un() || (i ? this.kTn.add(t) : this.kTn.delete(t))
        }
        vPn(t, i) {
            i ? this.OTn.add(t) : this.OTn.delete(t)
        }
        SPn(t) {
            const i = [t]
              , e = VT.ra.mIn.pIn();
            for (const t of this.OTn)
                t.he();
            for (const s of this.kTn) {
                if (i.length >= e)
                    break;
                s !== t && i.push(s)
            }
            i.length < 2 || VT.v(VT.ra.mIn, this, i)
        }
        ke() {
            this.xPn()
        }
        MPn() {
            this.xPn()
        }
        xPn() {
            this.b_n = this.g_n.getCurrentTexture(),
            this.v_n = this.b_n.createView({
                label: "swapchaintextureview"
            }),
            this.XTn.Gn().EPn()
        }
        qV() {
            null === this.KTn && this.XTn.CPn() && this._Pn(),
            super.qV(),
            this.eTn.TPn(this.Gwn),
            this.XTn.Gn().IPn(),
            this.b_n = null,
            this.v_n = null
        }
        ZIn() {
            this.HTn = this.w_n.createCommandEncoder(),
            this.nTn &= ~gI
        }
        PPn(t) {
            if (!this.e_n())
                throw new Error("GPU profiling not supported");
            if (this.QTn)
                throw new Error("already started frame timing");
            return this.tIn = !1,
            this.sIn.clear(),
            this.QTn = VT.v(VT.ra.GPn, this, t),
            this.QTn
        }
        APn(t, i) {
            if (this.e_n()) {
                if (!this.QTn)
                    throw new Error("not started frame timing");
                if (t < 0 || i < 0 || t === i)
                    throw new Error("invalid timestamp index");
                this.RPn(),
                this.tIn = !0,
                this.iIn = t,
                this.eIn = i
            }
        }
        kPn() {
            this.tIn && (this.RPn(),
            this.tIn = !1)
        }
        kCn(t, i) {
            if (this.AEn + t > ZT || this.REn + i > QT)
                this._gn();
            else if (0 !== (this.nTn & sI))
                return void (this.oTn += i);
            null === this.KTn && this._Pn(),
            this.nTn |= sI,
            this.hTn = this.REn,
            this.oTn = i
        }
        OCn() {
            const t = this.AEn;
            let i = this.REn;
            this.REn += 6;
            const e = this.IEn;
            e[i++] = t,
            e[i++] = t + 1,
            e[i++] = t + 2,
            e[i++] = t,
            e[i++] = t + 2,
            e[i] = t + 3
        }
        OPn() {
            const t = this.nTn;
            if (0 === (t & sI))
                return;
            const i = this.KTn;
            if (0 !== (t & oI)) {
                const e = this.UEn;
                i.setViewport(0, 0, e.ns(), e.Kn(), 0, 1),
                0 !== (t & nI) ? i.setIndexBuffer(this.R_n, "uint16") : i.setIndexBuffer(this.CEn, "uint16"),
                i.setVertexBuffer(0, this.qbn),
                i.setVertexBuffer(1, this.Xbn),
                i.setVertexBuffer(2, this.Ybn),
                i.setVertexBuffer(3, this.A_n),
                0 !== (t & (_I | TI)) && i.setStencilReference(1),
                0 !== (t & rI) && this.DPn(i, this.pTn, e)
            }
            if (0 !== (t & aI)) {
                let e = 0;
                0 !== (t & kI) ? e = 4 : 0 !== (t & _I) ? e = 2 : 0 !== (t & TI) ? e = 3 : (t & (MI | EI)) === (MI | EI) && (e = 1),
                i.setPipeline(this.BTn.FPn(this.UTn, e, this.jTn, this.$Tn, this.NTn))
            }
            if (0 !== (t & wI) && i.setBindGroup(0, this.ATn),
            0 !== (t & lI) && i.setBindGroup(1, this.TTn),
            0 !== (t & uI) && i.setBindGroup(2, this.PTn),
            0 !== (t & cI) && i.setBindGroup(3, this.GTn),
            0 !== (t & hI)) {
                const e = this.UEn;
                0 !== (t & rI) ? this.DPn(i, this.pTn, e) : i.setScissorRect(0, 0, e.ns(), e.Kn())
            }
            i.drawIndexed(this.oTn, 1, this.hTn, 0, 0),
            this.nTn &= ~FI
        }
        DPn(t, i, e) {
            const s = e.ns()
              , n = e.Kn();
            let r = VT.Ne(i.Kr(), 0, s)
              , h = VT.Ne(i.Zr(), 0, n)
              , o = VT.Ne(i.gl(), r, s)
              , a = VT.Ne(i.wl(), h, n);
            Number.isNaN(r) && (r = 0),
            Number.isNaN(h) && (h = 0),
            Number.isNaN(o) && (o = s),
            Number.isNaN(a) && (a = n),
            t.setScissorRect(r, h, o - r, a - h)
        }
        _Pn() {
            KT(!this.KTn, "expected no render pass");
            const t = this.nTn;
            0 !== (t & BI) && this.LPn();
            let i = null;
            i = 0 !== (t & _I) ? this.BPn() : 0 !== (t & TI) ? this.UPn() : this.NPn(),
            this.KTn = this.HTn.beginRenderPass(i),
            this.nTn |= LI
        }
        NPn() {
            const t = this.nTn
              , i = this.UEn
              , e = {
                colorAttachments: [{
                    view: i.jPn(),
                    loadOp: i.CPn() ? "clear" : "load",
                    clearValue: i.$Pn().toJSON(),
                    storeOp: "store"
                }]
            };
            return this.zPn(e),
            i.VPn(!1),
            (t & (EI | MI)) === (EI | MI) && (e.depthStencilAttachment = {
                view: this.M_n,
                depthLoadOp: 0 !== (t & CI) ? "clear" : "load",
                depthClearValue: 1,
                depthStoreOp: "store",
                stencilLoadOp: "clear",
                stencilClearValue: 0,
                stencilStoreOp: "discard"
            },
            this.nTn &= ~CI),
            e
        }
        BPn() {
            const t = this.nTn
              , i = {
                colorAttachments: [],
                depthStencilAttachment: {
                    view: this.M_n,
                    depthLoadOp: 0 !== (t & CI) ? "clear" : "load",
                    depthClearValue: 1,
                    depthStoreOp: "store",
                    stencilLoadOp: 0 !== (t & II) ? "clear" : "load",
                    stencilClearValue: 0,
                    stencilStoreOp: "store"
                }
            };
            return this.zPn(i),
            this.nTn &= ~(CI | II),
            i
        }
        UPn() {
            const t = this.UEn
              , i = {
                colorAttachments: [{
                    view: t.jPn(),
                    loadOp: t.CPn() ? "clear" : "load",
                    clearValue: t.$Pn().toJSON(),
                    storeOp: "store"
                }],
                depthStencilAttachment: {
                    view: this.M_n,
                    depthReadOnly: !0,
                    stencilReadOnly: !0
                }
            };
            return this.zPn(i),
            t.VPn(!1),
            i
        }
        zPn(t) {
            if (!this.tIn)
                return;
            const i = {
                querySet: this.QTn.WPn(),
                endOfPassWriteIndex: this.eIn
            };
            this.sIn.has(this.iIn) || (i.beginningOfPassWriteIndex = this.iIn,
            this.sIn.add(this.iIn)),
            t.timestampWrites = i
        }
        HPn(t) {
            if (!t.CPn())
                return;
            this.RPn();
            this.HTn.beginRenderPass({
                colorAttachments: [{
                    view: t.jPn(),
                    loadOp: "clear",
                    clearValue: t.$Pn().toJSON(),
                    storeOp: "store"
                }]
            }).end(),
            this.nTn |= gI,
            t.VPn(!1)
        }
        RPn() {
            null !== this.KTn && (this.OPn(),
            this.KTn.end(),
            this.KTn = null)
        }
        _gn(t=!1) {
            this.RPn(),
            this.QTn && t && (this.QTn.i8s(this.HTn),
            this.nTn |= gI),
            0 !== (this.nTn & gI) && (this.qTn.push(this.HTn.finish()),
            this.ZIn()),
            0 !== this.qTn.length && (this.CCn(),
            this.w_n.queue.submit(this.qTn),
            VT.sc(this.qTn),
            this.eTn.KPn(),
            this.QTn && t && (this.QTn.qPn(),
            this.QTn = null))
        }
        CCn() {
            const t = this.w_n.queue;
            if (this.AEn > 0) {
                const i = this.AEn;
                t.writeBuffer(this.qbn, 0, this.TEn.buffer, 0, 3 * i * $I),
                t.writeBuffer(this.Xbn, 0, this.PEn.buffer, 0, 2 * i * $I),
                0 !== (this.nTn & bI) && t.writeBuffer(this.A_n, 0, this.Q_n.buffer, 0, i * NI);
                const e = this.Jbn() ? jI : $I;
                t.writeBuffer(this.Ybn, 0, this.GEn.buffer, 0, 4 * i * e),
                this.AEn = 0
            }
            this.REn > 0 && (this.REn % 2 != 0 && (this.IEn[this.REn++] = 0),
            t.writeBuffer(this.CEn, 0, this.IEn.buffer, 0, this.REn * UI),
            this.REn = 0),
            this.kEn > 0 && (t.writeBuffer(this.Zbn, 0, this.oci.buffer, 0, this.kEn * $I),
            this.kEn = 0)
        }
        NIn() {
            this.nTn |= dI,
            this.rTn |= OI,
            this.XPn(this.k_n.transform)
        }
        jIn() {
            const t = this.k_n.YPn;
            this.gTn.uDe(this.U_n, t.offset / 4),
            this.XPn(t)
        }
        $In() {
            const t = this.k_n.CHs;
            this.U_n[t.offset / 4] = this.yTn,
            this.XPn(t)
        }
        XPn(t) {
            const i = t.offset
              , e = t.end;
            0 !== (this.nTn & fI) ? (this.aTn = Math.min(this.aTn, i),
            this.lTn = Math.max(this.lTn, e)) : (this.nTn |= fI,
            this.aTn = i,
            this.lTn = e,
            this.RPn())
        }
        zIn() {
            this.JPn(this.mTn, this.N_n.ZPn)
        }
        VIn() {
            this.JPn(this.wTn, this.N_n.QPn)
        }
        JPn(t, i) {
            t.uDe(this.W_n, i.offset / 4),
            this.tGn(i)
        }
        iGn(t, i) {
            t.uDe(this.W_n, i.offset / 4),
            this.tGn(i)
        }
        tGn(t) {
            const i = t.offset
              , e = t.end;
            0 !== (this.nTn & pI) ? (this.uTn = Math.min(this.uTn, i),
            this.cTn = Math.max(this.cTn, e)) : (this.nTn |= pI,
            this.uTn = i,
            this.cTn = e,
            this.RPn())
        }
        eGn(t, i) {
            this.J_n[i.offset / 4] !== Math.fround(t) && (this.J_n[i.offset / 4] = t,
            this.sGn(i))
        }
        nGn(t, i) {
            this.Z_n[i.offset / 4] !== t && (this.Z_n[i.offset / 4] = t,
            this.sGn(i))
        }
        rGn(t, i) {
            t.oDe(this.J_n, i.offset / 4) || (t.uDe(this.J_n, i.offset / 4),
            this.sGn(i))
        }
        sGn(t) {
            const i = t.offset
              , e = t.end;
            0 !== (this.nTn & mI) ? (this.dTn = Math.min(this.dTn, i),
            this.fTn = Math.max(this.fTn, e)) : (this.nTn |= mI,
            this.dTn = i,
            this.fTn = e,
            this.RPn())
        }
        LPn() {
            const t = this.nTn;
            0 !== (t & dI) && (HT.multiply(this.S_n, this.twn, this.iwn),
            this.U_n.set(this.S_n, this.k_n.transform.offset / 4)),
            0 !== (t & fI) && this.eTn.hGn(this.HTn, this.T_n, this.B_n, this.aTn, this.lTn - this.aTn),
            0 !== (t & pI) && this.eTn.hGn(this.HTn, this.I_n, this.V_n, this.uTn, this.cTn - this.uTn),
            0 !== (t & mI) && this.eTn.hGn(this.HTn, this.P_n, this.Y_n, this.dTn, this.fTn - this.dTn),
            this.nTn = t & ~BI | gI
        }
        R0(t) {
            VT.Wat(t);
            let i = this.ZC
              , e = this.tv
              , s = !0;
            if (t && ("number" == typeof t.width && (i = Math.floor(t.width),
            s = !1),
            "number" == typeof t.height && (e = Math.floor(t.height),
            s = !1)),
            i <= 0 || e <= 0)
                throw new Error("invalid size");
            this._gn();
            const n = VT.v(VT.ra.dIn, this);
            return n._k(i, e, Object.assign({
                fMn: s
            }, t)),
            n
        }
        UV(t, i=!0) {
            null === t && (t = this.XTn),
            this.UEn !== t && (this.RPn(),
            this.UEn = t,
            this.nIn(EI, t.GMn()),
            t.AMn() && !t.pPn() && t._Mn(this.ZC, this.tv),
            i && this.MCn())
        }
        iJs(t) {}
        tJs() {
            return this.UEn === this.XTn ? null : this.UEn
        }
        BCn(t) {
            return null === t ? [this.ZC, this.tv] : [t.ns(), t.Kn()]
        }
        oGn() {
            return this.XTn
        }
        YCn(t) {
            this._gn(),
            this.UEn === t && this.UV(null);
            const i = t.Gn();
            this._Tn === i && this.dr(null),
            this.ITn === i && this.yPn(null),
            t.Hwt()
        }
        async FMn(t, i, e) {
            this.HPn(t),
            this._gn(),
            null === t && (t = this.XTn);
            const s = this.w_n
              , n = t.ns()
              , r = t.Kn();
            let h = 0
              , o = 0
              , a = n
              , l = r;
            if (e) {
                h = VT.Ne(Math.floor(e.Kr()), 0, n - 1),
                o = VT.Ne(Math.floor(e.Zr()), 0, r - 1);
                let t = e.width();
                t = 0 === t ? n - h : VT.Ne(Math.floor(t), 0, n - h);
                let i = e.height();
                i = 0 === i ? r - o : VT.Ne(Math.floor(i), 0, r - o),
                a = t,
                l = i
            }
            const u = s.createCommandEncoder()
              , c = t.Gn();
            let d = c.RSn()
              , f = null;
            "rgba8unorm" === c.aGn() ? c.lGn() || VT.Gks() : (f = this.uGn(c, "rgba8unorm", u),
            d = f);
            const p = 4 * a
              , m = 256 * Math.ceil(p / 256)
              , w = s.createBuffer({
                size: m * l,
                usage: qT.MAP_READ | qT.COPY_DST
            });
            u.copyTextureToBuffer({
                texture: d,
                origin: [h, o, 0]
            }, {
                buffer: w,
                bytesPerRow: m
            }, [a, l, 1]);
            const g = u.finish();
            s.queue.submit([g]),
            f && f.destroy(),
            await w.mapAsync(self.GPUMapMode.READ);
            const y = w.getMappedRange().slice(0);
            let b;
            if (m === p)
                b = new ImageData(new Uint8ClampedArray(y),a,l);
            else {
                const t = new ArrayBuffer(p * l)
                  , i = new Uint8Array(t);
                for (let t = 0; t < l; ++t) {
                    const e = t * m
                      , s = t * p;
                    i.set(new Uint8Array(y,e,p), s)
                }
                b = new ImageData(new Uint8ClampedArray(t),a,l)
            }
            return w.destroy(),
            b
        }
        uGn(t, i, e) {
            const s = this.w_n
              , n = t.ns()
              , r = t.Kn();
            if (t.aGn() === i)
                throw new Error("no conversion necessary");
            t.PMn() || VT.Gks();
            const h = s.createTexture({
                size: [n, r, 1],
                format: i,
                usage: YT.COPY_SRC | YT.RENDER_ATTACHMENT
            })
              , o = this.zTn.UIn(i)
              , a = o.getBindGroupLayout(0)
              , l = this.YIn({
                Cn: "nearest"
            })
              , u = t.RSn().createView({
                baseMipLevel: 0,
                mipLevelCount: 1
            })
              , c = h.createView({
                baseMipLevel: 0,
                mipLevelCount: 1
            })
              , d = e.beginRenderPass({
                colorAttachments: [{
                    view: c,
                    loadOp: "clear",
                    clearValue: [0, 0, 0, 0],
                    storeOp: "store"
                }]
            })
              , f = s.createBindGroup({
                layout: a,
                entries: [{
                    binding: 0,
                    resource: l
                }, {
                    binding: 1,
                    resource: u
                }]
            });
            return d.setPipeline(o),
            d.setBindGroup(0, f),
            d.draw(4),
            d.end(),
            h
        }
        VV(t) {
            0 !== (this.nTn & xI) && (t = !!t,
            0 !== (this.nTn & MI) !== t && (0 !== (this.nTn & EI) && this.RPn(),
            this.nIn(MI, t)))
        }
        VCn() {
            return this.rIn(MI)
        }
        fPn() {
            return this.rIn(xI)
        }
        WCn(t) {
            if (!this.yEn)
                return;
            if (t && this.VCn())
                throw new Error("depth still enabled");
            const i = t ? this.C_n : this.__n;
            this.GTn !== i && (this.OPn(),
            this.GTn = i,
            this.nTn |= cI)
        }
        tC(t) {
            this.RPn(),
            this.UEn.VPn(!0),
            this.UEn.$Pn().set(t)
        }
        Pzs(t, i, e, s) {
            this.RPn(),
            this.UEn.VPn(!0),
            this.UEn.$Pn().CIs(t, i, e, s)
        }
        LJs() {
            (this.nTn & (xI | EI)) === (xI | EI) && (this.RPn(),
            this.nTn |= CI)
        }
        HCn(t, i, e, s) {
            t = Math.floor(t),
            i = Math.floor(i),
            e = Math.floor(e),
            s = Math.floor(s),
            0 !== (this.nTn & rI) && this.pTn.jDe(t, i, e, s) || (this.OPn(),
            this.nTn |= rI | hI,
            this.pTn.ff(t, i, e, s))
        }
        KCn() {
            0 !== (this.nTn & rI) && (this.OPn(),
            this.nTn &= ~rI,
            this.nTn |= hI)
        }
        jwn() {
            return 0 !== (this.nTn & bI) ? this.own : this.VTn
        }
        Yr() {
            this.Yw(this.jwn())
        }
        Yw(t) {
            if (this.BTn !== t) {
                if (t === this.own && 0 === (this.nTn & bI))
                    throw new Error("cannot set multitexture fill program when multitexturing not allowed");
                this.OPn(),
                this.BTn = t,
                this.vwn = null,
                this.nTn |= aI,
                this.cGn(t === this.own)
            }
        }
        $w() {
            return this.BTn
        }
        cGn(t) {
            if (t = !!t,
            0 !== (this.nTn & vI) === t)
                return;
            this.nIn(vI, t);
            const i = null === this._Tn ? this.CTn : this._Tn;
            this.dGn(i)
        }
        fGn(t) {
            t = !!t,
            0 !== (this.nTn & SI) !== t && (this.OPn(),
            this.nIn(SI, t),
            this.nIn(aI, !0))
        }
        pGn(t) {
            t = !!t,
            0 !== (this.nTn & kI) !== t && (this.OPn(),
            this.nIn(kI, t),
            this.nTn |= aI)
        }
        mGn() {
            return this.rIn(kI)
        }
        dr(t) {
            t !== this._Tn && (this._Tn = t,
            null === t && (t = this.CTn),
            this.dGn(t))
        }
        dGn(t) {
            if (0 !== (this.nTn & vI)) {
                const i = t.wGn();
                if (null !== i)
                    return this.gGn(i),
                    this.tTn = t.yGn(),
                    void this.fGn(!0)
            }
            this.gGn(t.HIn()),
            this.tTn = 0,
            this.fGn(!1)
        }
        gGn(t) {
            t !== this.TTn && (this.OPn(),
            this.TTn = t,
            this.nTn |= lI)
        }
        bGn(t) {
            this._Tn === t && (this.OPn(),
            this.TTn = t.HIn(),
            this.nTn |= lI)
        }
        vGn(t) {
            if (this.TTn !== t)
                return;
            this.OPn();
            const i = null === this._Tn ? this.CTn : this._Tn;
            this.TTn = i.HIn(),
            this.tTn = 0,
            this.nTn |= lI
        }
        yPn(t) {
            t !== this.ITn && (this.ITn = t,
            null === t && (t = this.CTn),
            this.OPn(),
            this.PTn = t.KIn(),
            this.nTn |= uI)
        }
        SGn(t, i, e, s, n, r) {
            const h = t.xGn()
              , o = i.xGn();
            if (0 === (h & YT.COPY_SRC))
                throw new Error("source texture missing COPY_SRC usage");
            if (0 === (o & YT.COPY_DST))
                throw new Error("destination texture missing COPY_DST usage");
            if (t === i)
                throw new Error("invalid destination");
            const a = Math.min(t.ns(), i.ns())
              , l = Math.min(t.Kn(), i.Kn());
            n = Math.min(n, a - e),
            r = Math.min(r, l - s),
            n <= 0 || r <= 0 || (this.RPn(),
            this.HTn.copyTextureToTexture({
                texture: t.RSn(),
                origin: [e, s]
            }, {
                texture: i.RSn(),
                origin: [e, s]
            }, [n, r]),
            this.nTn |= gI)
        }
        MGn(t) {
            return t >= 2 ? 4 : 1
        }
        EGn(t) {
            t = this.MGn(t),
            this.NTn !== t && (this.OPn(),
            this.NTn = t,
            this.nTn |= aI)
        }
        ac(t) {
            t !== this.UTn && (this.OPn(),
            this.UTn = t,
            this.vwn = null,
            this.nTn |= aI)
        }
        rc(t) {
            this.ac(this.Fzs(t))
        }
        tr() {
            this.ac(0)
        }
        RCn() {
            this.ac(3)
        }
        ir(t, i, e, s) {
            const n = this.iTn;
            n.RGs(t, i, e, s) || (n.CIs(t, i, e, s),
            this.vwn = null)
        }
        Rp(t) {
            const i = this.iTn;
            i.getA() !== t && (i.FC(t),
            this.vwn = null)
        }
        du() {
            return this.iTn.getA()
        }
        Xn(t) {
            const i = this.iTn;
            i.equals(t) || (i.set(t),
            this.vwn = null)
        }
        qr() {
            this.ir(1, 1, 1, 1)
        }
        $n() {
            return this.iTn
        }
        Ww(t) {
            t !== this.jTn && (this.OPn(),
            this.jTn = t,
            this.vwn = null,
            this.nTn |= aI)
        }
        GCn() {
            return this.jTn
        }
        Xw(t) {
            t !== this.$Tn && (this.OPn(),
            this.$Tn = t,
            this.vwn = null,
            this.nTn |= aI)
        }
        ACn() {
            return this.$Tn
        }
        Rect(t) {
            this.E9(t.Kr(), t.Zr(), t.gl(), t.wl())
        }
        E9(t, i, e, s) {
            this.Cgn(t, i, e, i, e, s, t, s)
        }
        CGn(t) {
            const i = this.Q_n
              , e = this.tTn;
            i[t++] = e,
            i[t++] = e,
            i[t++] = e,
            i[t] = e
        }
        Nn(t) {
            this.Ac(t, zI)
        }
        Cgn(t, i, e, s, n, r, h, o) {
            this.kCn(4, 6),
            this.OCn();
            const a = this.TEn
              , l = this.AEn;
            this.AEn += 4;
            let u = 3 * l;
            const c = this.Mwn + this.Ewn;
            a[u++] = t,
            a[u++] = i,
            a[u++] = c,
            a[u++] = e,
            a[u++] = s,
            a[u++] = c,
            a[u++] = n,
            a[u++] = r,
            a[u++] = c,
            a[u++] = h,
            a[u++] = o,
            a[u] = c,
            zI.uDe(this.PEn, 2 * l),
            0 !== (this.nTn & SI) && this.CGn(l),
            this.iTn.yDe(this.GEn, 4 * l)
        }
        gr(t, i) {
            this.kCn(4, 6),
            this.OCn();
            const e = this.AEn;
            this.AEn += 4,
            t.gFe(this.TEn, 3 * e, this.Mwn + this.Ewn),
            i.VDe(this.PEn, 2 * e),
            0 !== (this.nTn & SI) && this.CGn(e),
            this.iTn.yDe(this.GEn, 4 * e)
        }
        Ac(t, i) {
            this.kCn(4, 6),
            this.OCn();
            const e = this.AEn;
            this.AEn += 4,
            t.gFe(this.TEn, 3 * e, this.Mwn + this.Ewn),
            i.uDe(this.PEn, 2 * e),
            0 !== (this.nTn & SI) && this.CGn(e),
            this.iTn.yDe(this.GEn, 4 * e)
        }
        DCn(t, i, e) {
            this.kCn(4, 6),
            this.OCn();
            const s = this.AEn;
            this.AEn += 4,
            t.gFe(this.TEn, 3 * s, this.Mwn + this.Ewn),
            i.uDe(this.PEn, 2 * s),
            0 !== (this.nTn & SI) && this.CGn(s),
            this.GEn.set(e, 4 * s)
        }
        eb(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.kCn(4, 6),
            this.OCn();
            const f = this.TEn
              , p = this.AEn;
            this.AEn += 4;
            let m = 3 * p;
            const w = this.Mwn + this.Ewn;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.VDe(this.PEn, 2 * p),
            0 !== (this.nTn & SI) && this.CGn(p),
            this.iTn.yDe(this.GEn, 4 * p)
        }
        ob(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            this.kCn(4, 6),
            this.OCn();
            const f = this.TEn
              , p = this.AEn;
            this.AEn += 4;
            let m = 3 * p;
            const w = this.Mwn + this.Ewn;
            f[m++] = t,
            f[m++] = i,
            f[m++] = w + e,
            f[m++] = s,
            f[m++] = n,
            f[m++] = w + r,
            f[m++] = h,
            f[m++] = o,
            f[m++] = w + a,
            f[m++] = l,
            f[m++] = u,
            f[m] = w + c,
            d.uDe(this.PEn, 2 * p),
            0 !== (this.nTn & SI) && this.CGn(p),
            this.iTn.yDe(this.GEn, 4 * p)
        }
        FCn(t, i, e, s, n, r, h, o, a, l, u, c, d, f) {
            this.kCn(4, 6),
            this.OCn();
            const p = this.TEn
              , m = this.AEn;
            this.AEn += 4;
            let w = 3 * m;
            const g = this.Mwn + this.Ewn;
            p[w++] = t,
            p[w++] = i,
            p[w++] = g + e,
            p[w++] = s,
            p[w++] = n,
            p[w++] = g + r,
            p[w++] = h,
            p[w++] = o,
            p[w++] = g + a,
            p[w++] = l,
            p[w++] = u,
            p[w] = g + c,
            d.uDe(this.PEn, 2 * m),
            0 !== (this.nTn & SI) && this.CGn(m),
            this.GEn.set(f, 4 * m)
        }
        jo(t, i, e, s) {
            if (t.length % 3 != 0)
                throw new Error("vertex buffer length not multiple of 3");
            if (t.length > 3 * ZT)
                throw new Error(`too many vertices (${t.length / 3}, limit ${ZT})`);
            if (e.length % 3 != 0)
                throw new Error("index buffer length not multiple of 3");
            if (e.length > QT)
                throw new Error(`too many indices (${e.length}, limit ${QT})`);
            this.kCn(t.length, e.length);
            const n = this.AEn;
            this.TEn.set(t, 3 * n),
            this.PEn.set(i, 2 * n),
            0 !== (this.nTn & SI) && this.Q_n.fill(this.tTn, n, n + t.length);
            const r = this.IEn;
            if (0 === n)
                r.set(e, this.REn);
            else {
                let t = this.REn;
                for (let i = 0, s = e.length; i < s; ++i)
                    r[t++] = e[i] + n
            }
            const h = this.GEn;
            if (null != s)
                h.set(s, 4 * n);
            else {
                const i = this.iTn
                  , e = i.getR()
                  , s = i.getG()
                  , r = i.getB()
                  , o = i.getA();
                let a = 4 * n;
                for (let i = 0, n = t.length; i < n; ++i)
                    h[a++] = e,
                    h[a++] = s,
                    h[a++] = r,
                    h[a++] = o
            }
            this.AEn += t.length / 3,
            this.REn += e.length
        }
        $p(t) {
            this.gTn.equals(t) || (this.gTn.ia(t),
            this.jIn());
            const i = this.Mwn + this.Ewn;
            this.yTn !== i && (this.yTn = i,
            this.$In()),
            this.wTn.equals(this.iTn) || (this.wTn.ia(this.iTn),
            this.VIn()),
            this.Yw(this.$wn()),
            this.oTn = 0,
            this.nTn |= nI | oI
        }
        qp() {
            this.oTn > 0 && this.OPn(),
            this.nTn &= ~nI,
            this.nTn |= oI
        }
        tf(t, i, e, s) {
            let n = this.kEn;
            n > eI && (this._gn(),
            n = 0),
            0 !== (this.nTn & sI) ? this.oTn += 6 : (null === this.KTn && this._Pn(),
            this.nTn |= sI,
            this.hTn = n / 4 * 6,
            this.oTn = 6);
            const r = this.oci;
            r[n++] = t,
            r[n++] = i,
            r[n++] = e,
            r[n++] = s,
            this.kEn = n
        }
        NCn(t) {
            this.mTn.equals(t) || (this.mTn.ia(t),
            this.zIn())
        }
        jCn(t, i, e=1) {
            const s = this.N_n
              , n = this.W_n;
            VI.set(t, i),
            VI.oDe(n, s._Gn.offset / 4) || this.iGn(VI, s._Gn),
            n[s.TGn.offset / 4] !== Math.fround(e) && (n[s.TGn.offset / 4] = e,
            this.tGn(s.TGn))
        }
        kT(t, i, e, s, n, r, h) {
            const o = this.N_n
              , a = this.W_n;
            t.oDe(a, o.IGn.offset / 4) || (t.uDe(a, o.IGn.offset / 4),
            this.tGn(o.IGn)),
            VI.set(s / i, n / e),
            VI.oDe(a, o.PGn.offset / 4) || this.iGn(VI, o.PGn),
            VI.set(r / i, h / e),
            VI.oDe(a, o.GGn.offset / 4) || this.iGn(VI, o.GGn)
        }
        TM(t, i, e, s, n, r, h) {
            const o = this.N_n
              , a = this.W_n;
            VI.set(e, s),
            VI.oDe(a, o.PGn.offset / 4) || this.iGn(VI, o.PGn),
            a[o.TGn.offset / 4] !== Math.fround(n) && (a[o.TGn.offset / 4] = n,
            this.tGn(o.TGn)),
            VI.set(r, h),
            VI.oDe(a, o.GGn.offset / 4) || this.iGn(VI, o.GGn)
        }
        $Cn(t, i, e, s, n, r, h, o, a, l, u) {
            const c = this.H_n
              , d = this.BTn;
            u %= 10800,
            d.ils() && (KT(null === t || this.UEn.Gn() !== t, "setting back texture to current render target"),
            this.yPn(t)),
            d.AGn() && (this.rGn(i, c.RGn),
            this.rGn(e, c.IGn),
            this.rGn(s, c.kGn),
            this.rGn(n, c.WJs)),
            this.eGn(o, c.devicePixelRatio),
            this.eGn(a, c.zJs),
            this.eGn(l, c.OGn),
            this.eGn(u, c.IBe),
            this.eGn(this.bZ(), c.yti),
            this.eGn(this.IZ(), c.bti)
        }
        zCn(t) {
            VT.Mw(t, VT.ra.kls),
            t && (t.MN() && (this.RPn(),
            t.DGn(this.HTn)),
            this.FGn(t.LGn()))
        }
        BGn(t) {
            this.nGn(t ? 1 : 0, this.H_n.UGn)
        }
        FGn(t) {
            t !== this.ATn && (this.OPn(),
            this.ATn = t,
            this.nTn |= wI)
        }
        NGn(t) {
            this.ATn === t && this.FGn(this.STn)
        }
        XCn(t) {
            if (KT(t !== this.UEn, "copying render target to itself"),
            t.CPn())
                return this.UEn.VPn(!0),
                void this.UEn.$Pn().set(t.$Pn());
            t.RMn() >= 2 && this.UEn.RMn() < 2 ? this.jGn(t) : (this.Pzs(0, 0, 0, 0),
            this.RCn(),
            this.qr(),
            this.sJs(t))
        }
        sJs(t) {
            KT(t !== this.UEn, "drawing render target to itself"),
            this.HPn(t);
            const i = t.Gn();
            this.dr(i),
            this.LCn()
        }
        LCn() {
            const t = this.mGn();
            t || this.pGn(!0),
            this.lK(0);
            const i = HI
              , e = WI;
            i.set(0, -1, 0, -1, 2, 1, 0, 1),
            e.set(0, -1, 2, 1),
            this.gr(i, e),
            t || this.pGn(!1)
        }
        jGn(t) {
            this.HPn(t),
            this.RPn();
            this.HTn.beginRenderPass({
                colorAttachments: [{
                    view: t.Gn().jPn(),
                    resolveTarget: this.UEn.Gn().jPn(),
                    loadOp: "load",
                    storeOp: "store"
                }]
            }).end(),
            this.nTn |= gI
        }
        JCn() {
            this.RPn(),
            this.VV(!0),
            this.nTn |= _I | II
        }
        ZCn(t=!1) {
            this.RPn(),
            this.VV(t),
            this.nTn &= ~_I,
            this.nTn |= TI
        }
        QCn() {
            return this.rIn(TI)
        }
        t_n(t=!0) {
            this.RPn(),
            this.VV(t),
            this.nTn &= ~TI
        }
        pCn() {
            this.Zwn([["normal", "one", "one-minus-src-alpha"], ["additive", "one", "one"], ["xor", "one", "one-minus-src-alpha"], ["copy", "one", "zero"], ["destination-over", "one-minus-dst-alpha", "one"], ["source-in", "dst-alpha", "zero"], ["destination-in", "zero", "src-alpha"], ["source-out", "one-minus-dst-alpha", "zero"], ["destination-out", "zero", "one-minus-src-alpha"], ["source-atop", "dst-alpha", "one-minus-src-alpha"], ["destination-atop", "one-minus-dst-alpha", "src-alpha"]])
        }
        $Gn() {
            return this.wfi ? [...this.wfi.features] : []
        }
        zGn() {
            return this.m_n
        }
        VGn() {
            const t = this.m_n;
            if (!t)
                return "unknown/unknown";
            const i = t.vendor || "unknown"
              , e = t.architecture || "unknown"
              , s = [];
            t.device && s.push(t.device),
            t.description && s.push(t.description),
            t.type && s.push(t.type),
            t.backend && s.push(t.backend);
            return i + "/" + e + (s.length > 0 ? ` (${s.join(", ")})` : "")
        }
    }
}
{
    const KI = self.t
      , qI = !0;
    KI.ra.sTn = class {
        constructor(t) {
            KI.U(t, KI.ra.u0),
            this.an = t,
            this.WGn = new Map,
            this.HGn = [],
            this.KGn = [],
            this.qGn = [],
            this.XGn = 0,
            this.YGn = 0,
            this.JGn = 0,
            this.ZGn = 0,
            this.QGn = 0,
            this.tAn = 0
        }
        Mn() {
            return this.an
        }
        Vs() {
            this.WGn.clear(),
            KI.sc(this.HGn),
            KI.sc(this.KGn),
            KI.sc(this.qGn)
        }
        iAn(t) {
            return Math.max(KI.ha(t), 16)
        }
        eAn(t) {
            this.QGn++;
            const i = this.iAn(t);
            if (qI) {
                const t = this.WGn.get(i);
                if (void 0 !== t && t.length > 0) {
                    const e = t.pop();
                    return e.sAn(),
                    0 === t.length && this.WGn.delete(i),
                    e
                }
            }
            return this.XGn++,
            this.YGn += i,
            this.JGn++,
            KI.v(KI.ra.nAn, this, i)
        }
        rAn(t) {
            this.tAn++;
            const i = t.jp()
              , e = this.WGn.get(i);
            void 0 === e ? this.WGn.set(i, [t]) : e.push(t)
        }
        hAn(t) {
            this.qGn.push(t)
        }
        KPn() {
            for (const t of this.HGn)
                t.oAn();
            KI.sc(this.HGn);
            for (const t of this.KGn)
                this.XGn--,
                this.YGn -= t.jp(),
                t.he();
            KI.sc(this.KGn);
            for (const t of this.qGn)
                t.destroy();
            KI.sc(this.qGn)
        }
        TPn(t) {
            t % 30 == 0 && this.aAn(t)
        }
        aAn(t) {
            for (const [i,e] of this.WGn.entries()) {
                let s = 0;
                for (let i = 0, n = e.length; i < n; ++i) {
                    const n = e[i];
                    n.lAn(t) ? (this.XGn--,
                    this.YGn -= n.jp(),
                    n.he(),
                    this.ZGn++) : (e[s] = n,
                    ++s)
                }
                0 === s ? this.WGn.delete(i) : KI.yp(e, s)
            }
            this.uAn()
        }
        hGn(t, i, e, s, n) {
            const r = this.eAn(n)
              , h = r.UVe()
              , o = h.getMappedRange(0, n);
            new Uint8Array(o).set(new Uint8Array(e,s,n)),
            h.unmap(),
            t.copyBufferToBuffer(h, 0, i, s, n),
            qI ? this.HGn.push(r) : (r.cAn(),
            this.KGn.push(r))
        }
        uAn() {
            this.JGn = 0,
            this.ZGn = 0,
            this.QGn = 0,
            this.tAn = 0
        }
    }
}
{
    const XI = self.t
      , YI = self.GPUBufferUsage
      , JI = self.GPUMapMode
      , ZI = self.assert
      , QI = 0
      , tP = 1
      , iP = 2;
    XI.ra.nAn = class {
        constructor(t, i) {
            XI.U(t, XI.ra.sTn),
            this.eTn = t,
            this.Uli = tP,
            this.Nd = i,
            this._He = this.Mn().QIn().createBuffer({
                mappedAtCreation: !0,
                size: i,
                usage: YI.COPY_SRC | YI.MAP_WRITE
            }),
            this.dAn = 0
        }
        Mn() {
            return this.eTn.Mn()
        }
        n9s() {
            return this.Uli
        }
        jp() {
            return this.Nd
        }
        UVe() {
            return this._He
        }
        sAn() {
            ZI(this.Uli === QI, "expected buffer available"),
            this.Uli = tP
        }
        async oAn() {
            ZI(this.Uli === tP, "expected buffer in use"),
            this.Uli = iP;
            try {
                await this._He.mapAsync(JI.WRITE)
            } catch (t) {
                return void (() => {})("[WebGPU] Error recycling buffer, assuming device was lost: ", t)
            }
            this.Mn().un() || (this.Uli = QI,
            this.dAn = this.Mn().Tgn(),
            this.eTn.rAn(this))
        }
        cAn() {
            this.Uli = QI
        }
        lAn(t) {
            return this.dAn <= t - 25
        }
        he() {
            ZI(this.Uli === QI, "cannot destroy buffer"),
            this._He.destroy(),
            this._He = null,
            this.eTn = null
        }
    }
}
{
    const eP = self.t
      , sP = self.assert
      , nP = self.GPUBufferUsage;
    eP.ra.kls = class {
        constructor(t) {
            eP.U(t, eP.ra.D_n),
            sP(t.Pls() > 0, "no custom params");
            const i = t.Mn();
            this.dmn = t,
            this.fAn = t.Pls(),
            this.pAn = new ArrayBuffer(this.fAn),
            this.mAn = new Float32Array(this.pAn),
            this.Fns = !1,
            this._He = i.QIn().createBuffer({
                size: this.fAn,
                usage: nP.UNIFORM | nP.COPY_DST
            }),
            this.wAn = i.WIn(this._He)
        }
        he() {
            this.Mn().NGn(this.wAn),
            this.Mn().wPn().hAn(this._He),
            this._He = null,
            this.dmn = null,
            this.pAn = null,
            this.mAn = null,
            this.wAn = null
        }
        Mn() {
            return this.dmn.Mn()
        }
        Als() {
            return this.dmn
        }
        LGn() {
            return this.wAn
        }
        bne(t, i) {
            const e = this.dmn.gAn(t)
              , s = e.type
              , n = e.offset / 4
              , r = this.mAn;
            if ("color" === s) {
                if (i.vDe(r, n))
                    return;
                i.bDe(r, n),
                this.Fns = !0
            } else {
                if ("float" !== s && "percent" !== s)
                    throw new Error(`unexpected shader param type '${s}'`);
                if (r[n] === Math.fround(i))
                    return;
                r[n] = i,
                this.Fns = !0
            }
        }
        MN() {
            return this.Fns
        }
        DGn(t) {
            this.Mn().wPn().hGn(t, this._He, this.pAn, 0, this.fAn),
            this.Fns = !1
        }
    }
}
{
    const rP = self.t
      , hP = 4
      , oP = 2
      , aP = 4
      , lP = 2 * hP
      , uP = 4 * hP;
    function cP(t) {
        for (const i of Object.values(t))
            i.end = i.offset + i.size
    }
    const dP = "\nstruct Uniforms {\n\ttransform\t\t: mat4x4<f32>,\n\tpointTexStart\t: vec2<f32>,\n\tpointTexEnd\t\t: vec2<f32>,\n\tzElevation\t\t: f32\n};\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n"
      , fP = {
        transform: {
            offset: 0,
            size: 16 * hP,
            end: 0
        },
        YPn: {
            offset: 64,
            size: uP,
            end: 0
        },
        yAn: {
            offset: 64,
            size: lP,
            end: 0
        },
        bAn: {
            offset: 72,
            size: lP,
            end: 0
        },
        CHs: {
            offset: 80,
            size: hP,
            end: 0
        }
    };
    cP(fP);
    const pP = fP.CHs.end
      , mP = "\nstruct Uniforms {\n\tcolor2\t\t\t\t: vec4<f32>,\n\tpointColor \t\t\t: vec4<f32>,\n\ttileSize\t\t\t: vec2<f32>,\n\ttileSpacing\t\t\t: vec2<f32>,\n\tsrcRectStart\t\t: vec2<f32>,\n\tsrcRectEnd\t\t\t: vec2<f32>,\n\tpixelSize\t\t\t: vec2<f32>,\n\toutlineThickness\t: f32\n};\n@binding(1) @group(0) var<uniform> uniforms : Uniforms;\n"
      , wP = {
        ZPn: {
            offset: 0,
            size: uP,
            end: 0
        },
        QPn: {
            offset: 16,
            size: uP,
            end: 0
        },
        PGn: {
            offset: 32,
            size: lP,
            end: 0
        },
        GGn: {
            offset: 40,
            size: lP,
            end: 0
        },
        IGn: {
            offset: 48,
            size: uP,
            end: 0
        },
        vAn: {
            offset: 48,
            size: lP,
            end: 0
        },
        SAn: {
            offset: 56,
            size: lP,
            end: 0
        },
        _Gn: {
            offset: 64,
            size: lP,
            end: 0
        },
        TGn: {
            offset: 72,
            size: hP,
            end: 0
        }
    };
    cP(wP);
    const gP = wP.TGn.end
      , yP = "\nstruct C3Params {\n\tsrcStart\t\t\t: vec2<f32>,\n\tsrcEnd\t\t\t\t: vec2<f32>,\n\tsrcOriginStart\t\t: vec2<f32>,\n\tsrcOriginEnd\t\t: vec2<f32>,\n\tlayoutStart\t\t\t: vec2<f32>,\n\tlayoutEnd\t\t\t: vec2<f32>,\n\tdestStart\t\t\t: vec2<f32>,\n\tdestEnd\t\t\t\t: vec2<f32>,\n\tdevicePixelRatio\t: f32,\n\tlayerScale\t\t\t: f32,\n\tlayerAngle\t\t\t: f32,\n\tseconds\t\t\t\t: f32,\n\tzNear\t\t\t\t: f32,\n\tzFar\t\t\t\t: f32,\n\tisSrcTexRotated\t\t: u32\n};\n@binding(4) @group(0) var<uniform> c3Params : C3Params;\n\nfn c3_srcToNorm(p : vec2<f32>) -> vec2<f32>\n{\n\treturn (p - c3Params.srcStart) / (c3Params.srcEnd - c3Params.srcStart);\n}\n\nfn c3_normToSrc(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p, c3Params.srcEnd - c3Params.srcStart, c3Params.srcStart);\n}\n\nfn c3_clampToSrc(p : vec2<f32>) -> vec2<f32>\n{\n\treturn clamp(p, min(c3Params.srcStart, c3Params.srcEnd), max(c3Params.srcStart, c3Params.srcEnd));\n}\n\nfn c3_srcOriginToNorm(p : vec2<f32>) -> vec2<f32>\n{\n\treturn (p - c3Params.srcOriginStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart);\n}\n\nfn c3_normToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p, c3Params.srcOriginEnd - c3Params.srcOriginStart, c3Params.srcOriginStart);\n}\n\nfn c3_clampToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n\treturn clamp(p, min(c3Params.srcOriginStart, c3Params.srcOriginEnd), max(c3Params.srcOriginStart, c3Params.srcOriginEnd));\n}\n\nfn c3_getLayoutPos(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p - c3Params.srcOriginStart, (c3Params.layoutEnd - c3Params.layoutStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart), c3Params.layoutStart);\n}\n\nfn c3_srcToDest(p : vec2<f32>) -> vec2<f32>\n{\n\treturn fma(p - c3Params.srcStart, (c3Params.destEnd - c3Params.destStart) / (c3Params.srcEnd - c3Params.srcStart), c3Params.destStart);\n}\n\nfn c3_clampToDest(p : vec2<f32>) -> vec2<f32>\n{\n\treturn clamp(p, min(c3Params.destStart, c3Params.destEnd), max(c3Params.destStart, c3Params.destEnd));\n}\n\nfn c3_linearizeDepth(depthSample : f32) -> f32\n{\n\treturn c3Params.zNear * c3Params.zFar / (c3Params.zFar + depthSample * (c3Params.zNear - c3Params.zFar));\n}\n"
      , bP = ["srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "c3_srcToNorm", "c3_normToSrc", "c3_clampToSrc", "c3_srcOriginToNorm", "c3_normToSrcOrigin", "c3_clampToSrcOrigin", "c3_getLayoutPos", "c3_srcToDest"]
      , vP = ["layoutStart", "layoutEnd", "destStart", "destEnd", "c3_clampToDest"]
      , SP = {
        IGn: {
            offset: 0,
            size: uP,
            end: 0
        },
        xAn: {
            offset: 0,
            size: lP,
            end: 0
        },
        MAn: {
            offset: 8,
            size: lP,
            end: 0
        },
        kGn: {
            offset: 16,
            size: uP,
            end: 0
        },
        EAn: {
            offset: 16,
            size: lP,
            end: 0
        },
        CAn: {
            offset: 24,
            size: lP,
            end: 0
        },
        WJs: {
            offset: 32,
            size: uP,
            end: 0
        },
        _An: {
            offset: 32,
            size: lP,
            end: 0
        },
        TAn: {
            offset: 40,
            size: lP,
            end: 0
        },
        RGn: {
            offset: 48,
            size: uP,
            end: 0
        },
        IAn: {
            offset: 48,
            size: lP,
            end: 0
        },
        PAn: {
            offset: 56,
            size: lP,
            end: 0
        },
        devicePixelRatio: {
            offset: 64,
            size: hP,
            end: 0
        },
        zJs: {
            offset: 68,
            size: hP,
            end: 0
        },
        OGn: {
            offset: 72,
            size: hP,
            end: 0
        },
        IBe: {
            offset: 76,
            size: hP,
            end: 0
        },
        yti: {
            offset: 80,
            size: hP,
            end: 0
        },
        bti: {
            offset: 84,
            size: hP,
            end: 0
        },
        UGn: {
            offset: 88,
            size: aP,
            end: 0
        }
    };
    cP(SP);
    const xP = SP.UGn.end;
    function MP(t) {
        return `\nstruct FragmentInput {\n\t@location(1) fragUV : vec2<f32>,\n\t@location(2) fragColor : vec4<${t ? "f16" : "f32"}>,\n\t@builtin(position) fragPos : vec4<f32>\n};\n\nfn c3_getBackUV(fragPos : vec2<f32>, texBack : texture_2d<f32>) -> vec2<f32>\n{\n\treturn fragPos / vec2<f32>(textureDimensions(texBack));\n}\n\nfn c3_getDepthUV(fragPos : vec2<f32>, texDepth : texture_depth_2d) -> vec2<f32>\n{\n\treturn fragPos / vec2<f32>(textureDimensions(texDepth));\n}\n`
    }
    const EP = "\nstruct FragmentOutput {\n\t@location(0) color : vec4<f32>\n};\n"
      , CP = new Map([["float", 4], ["percent", 4], ["color", 12]])
      , _P = new Map([["float", 4], ["percent", 4], ["color", 16]])
      , TP = "\nfn c3_premultiply(c : vec4<f32>) -> vec4<f32>\n{\n\treturn vec4<f32>(c.rgb * c.a, c.a);\n}\n\nfn c3_unpremultiply(c : vec4<f32>) -> vec4<f32>\n{\n\tif (c.a == 0.0)\n\t{\n\t\treturn vec4<f32>(0.0);\n\t}\n\t\n\treturn vec4<f32>(c.rgb / c.a, c.a);\n}\n\nfn c3_grayscale(rgb : vec3<f32>) -> f32\n{\n\treturn dot(rgb, vec3<f32>(0.299, 0.587, 0.114));\n}\n\nfn c3_getPixelSize(t : texture_2d<f32>) -> vec2<f32>\n{\n\treturn vec2<f32>(1.0) / vec2<f32>(textureDimensions(t));\n}\n\nfn c3_clamp2(v : vec2<f32>, l : f32, u : f32) -> vec2<f32>\n{\n\treturn clamp(v, vec2<f32>(l), vec2<f32>(u));\n}\n\nfn c3_mod(x : f32, y : f32) -> f32\n{\n\treturn x - y * floor(x / y);\n}\n\nfn c3_mod2(x : vec2<f32>, y : vec2<f32>) -> vec2<f32>\n{\n\treturn x - y * floor(x / y);\n}\n\nfn c3_RGBtoHSL(color : vec3<f32>) -> vec3<f32>\n{\n\tvar hsl : vec3<f32> = vec3<f32>(0.0);\n\t\n\tvar fmin : f32 = min(min(color.r, color.g), color.b);\n\tvar fmax : f32 = max(max(color.r, color.g), color.b);\n\tvar delta : f32 = fmax - fmin;\n\n\thsl.z = (fmax + fmin) / 2.0;\n\n\tif (delta == 0.0)\n\t{\n\t\thsl.x = 0.0;\n\t\thsl.y = 0.0;\n\t}\n\telse \n\t{\n\t\tif (hsl.z < 0.5)\n\t\t{\n\t\t\thsl.y = delta / (fmax + fmin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\n\t\t}\n\t\t\n\t\tvar dR : f32 = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n\t\tvar dG : f32 = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n\t\tvar dB : f32 = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n\t\tif (color.r == fmax)\n\t\t{\n\t\t\thsl.x = dB - dG;\n\t\t}\n\t\telse if (color.g == fmax)\n\t\t{\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\n\t\t}\n\t\telse if (color.b == fmax)\n\t\t{\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\n\t\t}\n\n\t\tif (hsl.x < 0.0)\n\t\t{\n\t\t\thsl.x = hsl.x + 1.0;\n\t\t}\n\t\telse if (hsl.x > 1.0)\n\t\t{\n\t\t\thsl.x = hsl.x - 1.0;\n\t\t}\n\t}\n\n\treturn hsl;\n}\n\nfn c3_hueToRGB(f1 : f32, f2 : f32, hue_ : f32) -> f32\n{\n\tvar hue : f32 = hue_;\n\tif (hue < 0.0)\n\t{\n\t\thue = hue + 1.0;\n\t}\n\telse if (hue > 1.0)\n\t{\n\t\thue = hue - 1.0;\n\t}\n\t\t\n\tvar ret : f32;\n\t\n\tif ((6.0 * hue) < 1.0)\n\t{\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\n\t}\n\telse if ((2.0 * hue) < 1.0)\n\t{\n\t\tret = f2;\n\t}\n\telse if ((3.0 * hue) < 2.0)\n\t{\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n\t}\n\telse\n\t{\n\t\tret = f1;\n\t}\n\t\n\treturn ret;\n}\n\nfn c3_HSLtoRGB(hsl : vec3<f32>) -> vec3<f32>\n{\n\tvar rgb : vec3<f32> = vec3<f32>(hsl.z);\n\t\n\tif (hsl.y != 0.0)\n\t{\n\t\tvar f2 : f32;\n\t\t\n\t\tif (hsl.z < 0.5)\n\t\t{\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\t\t}\n\t\t\t\n\t\tvar f1 : f32 = 2.0 * hsl.z - f2;\n\t\t\n\t\trgb.r = c3_hueToRGB(f1, f2, hsl.x + (1.0 / 3.0));\n\t\trgb.g = c3_hueToRGB(f1, f2, hsl.x);\n\t\trgb.b = c3_hueToRGB(f1, f2, hsl.x - (1.0 / 3.0));\n\t}\n\t\n\treturn rgb;\n}\n";
    function IP(t, i, e, s, n) {
        return t << 10 | i << 7 | e << 5 | s << 4 | n
    }
    rP.ra.D_n = class extends rP.ra.Bgn {
        constructor(t, i) {
            if (super(t, i),
            this.GAn = i.AAn,
            this.RAn = i.kAn,
            this.OAn = i.DAn,
            this.LTn = i.FAn,
            this.LAn = new Map,
            this.BAn = new Map,
            this.UAn = !1,
            this.NAn = !1,
            this.tqs = [],
            this.jAn = 0,
            i.parameters) {
                let t = 0;
                for (const e of i.parameters) {
                    const i = e[2];
                    if (!CP.has(i))
                        throw new Error(`unrecognized effect param type '${i}'`);
                    const s = CP.get(i)
                      , n = _P.get(i)
                      , r = t % n;
                    0 !== r && (t += n - r),
                    this.tqs.push({
                        type: i,
                        offset: t,
                        size: s,
                        end: t + s
                    }),
                    t += s
                }
                this.jAn = 16 * Math.ceil(t / 16)
            }
        }
        static async y_(t, i) {
            const e = t.QIn()
              , s = i.name
              , n = t.wIn()
              , r = t.Jbn()
              , h = i.src
              , o = rP.ra.D_n.$An(h, n, r)
              , a = e.createShaderModule({
                label: s,
                code: o
            });
            let l, u = null;
            if (i.SIn) {
                const t = rP.ra.D_n.$An(i.SIn, n, r);
                u = e.createShaderModule({
                    label: s,
                    code: t
                })
            }
            a.getCompilationInfo().then(t => rP.ra.D_n.yIn(s, "fragment", t));
            const c = rP.ra.D_n.gIn(i.$bn, n);
            let d;
            c ? (l = e.createShaderModule({
                label: s,
                code: c
            }),
            l.getCompilationInfo().then(t => rP.ra.D_n.yIn(s, "vertex", t))) : l = t.tPn();
            const f = rP.ra.D_n.gIn(i.MIn, n);
            f ? (d = e.createShaderModule({
                label: s,
                code: f
            }),
            d.getCompilationInfo().then(t => rP.ra.D_n.yIn(s, "vertex (norm)", t))) : d = t.iPn();
            const p = rP.v(rP.ra.D_n, t, Object.assign({
                AAn: a,
                kAn: u,
                DAn: l,
                FAn: d
            }, i));
            if (p.tyn = h.includes("%%C3PARAMS_STRUCT%%") && bP.some(t => h.includes(t)),
            p.UAn = p.tyn || h.includes("%%C3PARAMS_STRUCT%%") && vP.some(t => h.includes(t)),
            p.NAn = h.includes("%%C3PARAMS_STRUCT%%") && h.includes("isSrcTexRotated"),
            "<generate-mipmap>" !== s) {
                const i = p.zAn(0, 0, 0, 0, 0);
                let e = null;
                t.fPn() && (e = p.zAn(0, 1, 0, 0, 0));
                const [s,n] = await Promise.all([i, e]);
                p.LAn.set(IP(0, 0, 0, 0, 0), s),
                n && p.LAn.set(IP(0, 1, 0, 0, 0), n)
            }
            return p
        }
        static VAn(t, i) {
            if (!t)
                return t;
            let e = "";
            return e = i ? "enable f16;\nalias f16or32 = f16;\n" : "alias f16or32 = f32;\n",
            e + t
        }
        static $An(t, i, e) {
            return t = rP.ra.D_n.VAn(t, i),
            rP.gxe(t, {
                "%%SAMPLERFRONT_BINDING%%": "@binding(0) @group(1)",
                "%%TEXTUREFRONT_BINDING%%": "@binding(1) @group(1)",
                "%%SAMPLERBACK_BINDING%%": "@binding(0) @group(2)",
                "%%TEXTUREBACK_BINDING%%": "@binding(1) @group(2)",
                "%%SAMPLERDEPTH_BINDING%%": "@binding(0) @group(3)",
                "%%TEXTUREDEPTH_BINDING%%": "@binding(1) @group(3)",
                "%%SHADERPARAMS_BINDING%%": "@binding(5) @group(0)",
                "%%FRAGMENTINPUT_STRUCT%%": MP(e),
                "%%FRAGMENTOUTPUT_STRUCT%%": EP,
                "%%C3PARAMS_STRUCT%%": yP,
                "%%C3_UTILITY_FUNCTIONS%%": TP
            })
        }
        static gIn(t, i) {
            return rP.ra.D_n.VAn(t, i)
        }
        static yIn(t, i, e) {
            for (const s of e.messages) {
                const e = `[WebGPU] Message (${s.type}) compiling ${i} shader '${t}': ${s.message} (line ${s.lineNum}, pos ${s.linePos})`;
                "error" === s.type ? console.error(e) : "warning" === s.type ? (() => {})(e) : console.log(e)
            }
        }
        he() {
            this.GAn = null,
            this.RAn = null,
            this.OAn = null,
            this.LTn = null,
            this.LAn.clear(),
            this.BAn.clear(),
            super.he()
        }
        QIn() {
            return this.an.QIn()
        }
        oPn() {
            return this.an.oPn()
        }
        Mn() {
            return this.an
        }
        AGn() {
            return this.UAn
        }
        uyn() {
            return this.NAn
        }
        IKt() {
            return this.tqs.length
        }
        Lvn(t) {
            return t < 0 || t >= this.tqs.length ? null : this.tqs[t].type
        }
        Pls() {
            return this.jAn
        }
        gAn(t) {
            return this.tqs[t]
        }
        WAn(t, i, e, s, n) {
            const r = this.an
              , h = r.Jbn()
              , [o,a] = r.ign(t);
            let l = "none";
            switch (e) {
            case 1:
                l = "back";
                break;
            case 2:
                l = "front"
            }
            const u = {
                label: `${this.Fa()} blendMode ${t} variant ${i} multisampleCount ${n}`,
                layout: this.oPn(),
                primitive: {
                    cullMode: l,
                    frontFace: 0 === s ? "cw" : "ccw"
                },
                vertex: {
                    module: 4 === i ? this.LTn : this.OAn,
                    entryPoint: "main",
                    buffers: [{
                        arrayStride: 3 * hP,
                        attributes: [{
                            shaderLocation: 0,
                            offset: 0,
                            format: "float32x3"
                        }]
                    }, {
                        arrayStride: 2 * hP,
                        attributes: [{
                            shaderLocation: 1,
                            offset: 0,
                            format: "float32x2"
                        }]
                    }, {
                        arrayStride: 4 * (h ? oP : hP),
                        attributes: [{
                            shaderLocation: 2,
                            offset: 0,
                            format: h ? "float16x4" : "float32x4"
                        }]
                    }, {
                        arrayStride: aP,
                        attributes: [{
                            shaderLocation: 3,
                            offset: 0,
                            format: "uint32"
                        }]
                    }]
                },
                fragment: {
                    module: this.GAn,
                    entryPoint: "main",
                    targets: [{
                        format: r.ePn(),
                        blend: {
                            color: {
                                srcFactor: o,
                                dstFactor: a
                            },
                            alpha: {
                                srcFactor: o,
                                dstFactor: a
                            }
                        }
                    }]
                }
            };
            if (n >= 2 && (u.multisample = {
                count: n
            }),
            1 === i)
                u.fragment.module = this.RAn || this.GAn,
                u.depthStencil = {
                    format: r.XIn(),
                    depthWriteEnabled: !0,
                    depthCompare: "less-equal"
                };
            else if (2 === i) {
                u.fragment.module = this.RAn || this.GAn,
                u.fragment.targets = [];
                const t = {
                    compare: "always",
                    failOp: "keep",
                    depthFailOp: "keep",
                    passOp: "replace"
                };
                u.depthStencil = {
                    format: r.XIn(),
                    depthWriteEnabled: !0,
                    depthCompare: "less-equal",
                    stencilFront: t,
                    stencilBack: t,
                    stencilReadMask: 1,
                    stencilWriteMask: 1
                }
            } else if (3 === i) {
                u.fragment.module = this.RAn || this.GAn;
                const t = {
                    compare: "equal",
                    failOp: "keep",
                    depthFailOp: "keep",
                    passOp: "keep"
                };
                u.depthStencil = {
                    format: r.XIn(),
                    depthWriteEnabled: !1,
                    depthCompare: "always",
                    stencilFront: t,
                    stencilBack: t,
                    stencilReadMask: 1,
                    stencilWriteMask: 0
                }
            }
            return u
        }
        HAn(t, i, e, s, n) {
            return this.QIn().createRenderPipeline(this.WAn(t, i, e, s, n))
        }
        zAn(t, i, e, s, n) {
            return this.QIn().createRenderPipelineAsync(this.WAn(t, i, e, s, n))
        }
        FPn(t, i, e, s, n) {
            const r = IP(t, i, e, s, n);
            let h = this.LAn.get(r);
            return h || (h = this.HAn(t, i, e, s, n),
            this.LAn.set(r, h),
            h)
        }
        static O_n() {
            return fP
        }
        static L_n() {
            return 16 * Math.ceil(pP / 16)
        }
        static j_n() {
            return wP
        }
        static z_n() {
            return 16 * Math.ceil(gP / 16)
        }
        static K_n() {
            return SP
        }
        static X_n() {
            return 16 * Math.ceil(xP / 16)
        }
        static Hvn(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\t${dP}\n\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\toutput.Position = uniforms.transform * vec4<f32>(input.position, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.fragColor = input.color;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\treturn output;\n\t\t}`
        }
        static bIn(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p = input.position;\n\t\t\tp.y = 1.0 - p.y;\n\t\t\toutput.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\toutput.fragColor = input.color;\n\t\t\treturn output;\n\t\t}`
        }
        static xIn(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\t${dP}\n\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\toutput.Position = uniforms.transform * vec4<f32>(input.position, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.fragColor = input.color;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\treturn output;\n\t\t}`
        }
        static EIn(t) {
            const i = t ? "f16" : "f32";
            return `\n\t\tstruct VertexInput {\n\t\t\t@location(0) position : vec3<f32>,\n\t\t\t@location(1) uv : vec2<f32>,\n\t\t\t@location(2) color : vec4<${i}>,\n\t\t\t@location(3) texIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p = input.position;\n\t\t\tp.y = 1.0 - p.y;\n\t\t\toutput.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);\n\t\t\toutput.fragUV = input.uv;\n\t\t\toutput.fragColor = input.color;\n\t\t\toutput.texIndex = input.texIndex;\n\t\t\treturn output;\n\t\t}`
        }
        static vIn(t, i) {
            return `\n\t\t@binding(0) @group(1) var sampler0 : sampler;\n\t\t@binding(1) @group(1) var texture0 : texture_2d<f32>;\n\t\t@binding(2) @group(1) var sampler1 : sampler;\n\t\t@binding(3) @group(1) var texture1 : texture_2d<f32>;\n\t\t@binding(4) @group(1) var sampler2 : sampler;\n\t\t@binding(5) @group(1) var texture2 : texture_2d<f32>;\n\t\t@binding(6) @group(1) var sampler3 : sampler;\n\t\t@binding(7) @group(1) var texture3 : texture_2d<f32>;\n\t\t@binding(8) @group(1) var sampler4 : sampler;\n\t\t@binding(9) @group(1) var texture4 : texture_2d<f32>;\n\t\t@binding(10) @group(1) var sampler5 : sampler;\n\t\t@binding(11) @group(1) var texture5 : texture_2d<f32>;\n\t\t@binding(12) @group(1) var sampler6 : sampler;\n\t\t@binding(13) @group(1) var texture6 : texture_2d<f32>;\n\t\t@binding(14) @group(1) var sampler7 : sampler;\n\t\t@binding(15) @group(1) var texture7 : texture_2d<f32>;\n\t\t@binding(16) @group(1) var sampler8 : sampler;\n\t\t@binding(17) @group(1) var texture8 : texture_2d<f32>;\n\t\t@binding(18) @group(1) var sampler9 : sampler;\n\t\t@binding(19) @group(1) var texture9 : texture_2d<f32>;\n\t\t@binding(20) @group(1) var sampler10 : sampler;\n\t\t@binding(21) @group(1) var texture10 : texture_2d<f32>;\n\t\t@binding(22) @group(1) var sampler11 : sampler;\n\t\t@binding(23) @group(1) var texture11 : texture_2d<f32>;\n\t\t@binding(24) @group(1) var sampler12 : sampler;\n\t\t@binding(25) @group(1) var texture12 : texture_2d<f32>;\n\t\t@binding(26) @group(1) var sampler13 : sampler;\n\t\t@binding(27) @group(1) var texture13 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i ? "f16" : "f32"}>,\n\t\t\t@location(3) @interpolate(flat, either) texIndex : u32,\n\t\t\t${t ? "@builtin(position) fragPos: vec4<f32>" : ""}\n\t\t};\n\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar texXy : vec2<f32> = input.fragUV.xy;\n\t\t\tvar texIndex : u32 = input.texIndex;\n\t\t\tvar c : vec4<f32>;\n\n\t\t\tlet dx = dpdx(texXy);\n\t\t\tlet dy = dpdy(texXy);\n\t\t\t\n\t\t\tif (texIndex <= 6)\n\t\t\t{\n\t\t\t\tif (texIndex <= 2)\n\t\t\t\t{\n\t\t\t\t\tif (texIndex == 0)\t\t\t{\tc = textureSampleGrad(texture0, sampler0, texXy, dx, dy);\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 1)\t\t{\tc = textureSampleGrad(texture1, sampler1, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture2, sampler2, texXy, dx, dy);\t}\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (texIndex <= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 3)\t\t{\tc = textureSampleGrad(texture3, sampler3, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture4, sampler4, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex <= 5)\t\t{\tc = textureSampleGrad(texture5, sampler5, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture6, sampler6, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (texIndex <= 9)\n\t\t\t\t{\n\t\t\t\t\tif (texIndex == 7)\t\t\t{\tc = textureSampleGrad(texture7, sampler7, texXy, dx, dy);\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 8)\t\t{\tc = textureSampleGrad(texture8, sampler8, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture9, sampler9, texXy, dx, dy);\t}\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (texIndex <= 11)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 10)\t\t{\tc = textureSampleGrad(texture10, sampler10, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture11, sampler11, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (texIndex == 12)\t\t{\tc = textureSampleGrad(texture12, sampler12, texXy, dx, dy);\t}\n\t\t\t\t\t\telse\t\t\t\t\t{\tc = textureSampleGrad(texture13, sampler13, texXy, dx, dy);\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutput.color = c * vec4<f32>(input.fragColor);\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static CIn(t, i) {
            return `\n\t\t@binding(0) @group(1) var sampler0 : sampler;\n\t\t@binding(1) @group(1) var texture0 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(1) fragUV : vec2<f32>,\n\t\t\t@location(2) fragColor : vec4<${i ? "f16" : "f32"}>,\n\t\t\t${t ? "@builtin(position) fragPos: vec4<f32>" : ""}\n\t\t};\n\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = textureSample(texture0, sampler0, input.fragUV) * vec4<f32>(input.fragColor);\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static TIn() {
            return "\n\t\tstruct VertexInput {\n\t\t\t@builtin(vertex_index) VertexIndex : u32\n\t\t};\n\t\t\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(0) fragUV : vec2<f32>\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\n\t\t\tvar pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n\t\t\t\tvec2<f32>(-1.0, 1.0),\n\t\t\t\tvec2<f32>(1.0, 1.0),\n\t\t\t\tvec2<f32>(-1.0, -1.0),\n\t\t\t\tvec2<f32>(1.0, -1.0));\n\t\t\t\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p : vec2<f32> = pos[input.VertexIndex];\n\t\t\toutput.Position = vec4<f32>(p, 0.0, 1.0);\n\t\t\toutput.fragUV = p / 2.0 + 0.5;\n\t\t\treturn output;\n\t\t}"
        }
        static _In() {
            return "\n\t\t@binding(0) @group(0) var sampler0 : sampler;\n\t\t@binding(1) @group(0) var texture0 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(0) fragUV : vec2<f32>\n\t\t};\n\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>\n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = textureSample(texture0, sampler0, vec2<f32>(input.fragUV.x, 1.0 - input.fragUV.y));\n\t\t\treturn output;\n\t\t}"
        }
        UIn(t) {
            t || (t = this.an.cPn());
            let i = this.BAn.get(t);
            return i || (i = this.QIn().createRenderPipeline({
                label: "<mipmap generator>",
                layout: "auto",
                vertex: {
                    module: this.OAn,
                    entryPoint: "main"
                },
                primitive: {
                    topology: "triangle-strip",
                    stripIndexFormat: "uint16"
                },
                fragment: {
                    module: this.GAn,
                    entryPoint: "main",
                    targets: [{
                        format: t,
                        blend: {
                            color: {
                                srcFactor: "one",
                                dstFactor: "zero"
                            },
                            alpha: {
                                srcFactor: "one",
                                dstFactor: "zero"
                            }
                        }
                    }]
                }
            }),
            this.BAn.set(t, i)),
            i
        }
        static PIn() {
            return `\n\t\t${dP}\n\n\t\tstruct PointData {\n\t\t\tdata : array<vec4<f32>>\n\t\t};\n\t\t@binding(3) @group(0) var<storage> pointBuffer : PointData;\n\n\t\tstruct VertexInput {\n\t\t\t@builtin(vertex_index) VertexIndex : u32\n\t\t};\n\n\t\tstruct VertexOutput {\n\t\t\t@builtin(position) Position : vec4<f32>,\n\t\t\t@location(0) fragUV : vec2<f32>,\n\t\t\t@location(1) pointOpacity : f32\n\t\t};\n\n\t\t@vertex\n\t\tfn main(input : VertexInput) -> VertexOutput {\n\n\t\t\tvar normPos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n\t\t\t\tvec2<f32>(-0.5, -0.5),\n\t\t\t\tvec2<f32>(0.5, -0.5),\n\t\t\t\tvec2<f32>(0.5, 0.5),\n\t\t\t\tvec2<f32>(-0.5, 0.5));\n\t\t\t\n\t\t\tvar output : VertexOutput;\n\t\t\tvar p : vec2<f32> = normPos[input.VertexIndex % u32(4)];\n\t\t\tvar pointData : vec4<f32> = pointBuffer.data[input.VertexIndex / u32(4)];\n\n\t\t\tvar size : f32 = pointData.z;\n\t\t\toutput.Position = uniforms.transform * vec4<f32>(p * size + pointData.xy, uniforms.zElevation, 1.0);\n\t\t\toutput.pointOpacity = pointData.w;\n\n\t\t\tvar pointTexMin : vec2<f32> = min(uniforms.pointTexStart, uniforms.pointTexEnd);\n\t\t\tvar pointTexMax : vec2<f32> = max(uniforms.pointTexStart, uniforms.pointTexEnd);\n\t\t\tvar pn : vec2<f32> = p + vec2<f32>(0.5, 0.5);\n\t\t\tvar pointCoord : vec2<f32> = select(vec2<f32>(1.0 - pn.y, pn.x), pn, uniforms.pointTexEnd.x > uniforms.pointTexStart.x);\n\n\t\t\toutput.fragUV = mix(pointTexMin, pointTexMax, pointCoord);\n\t\t\treturn output;\n\t\t}`
        }
        static IIn(t) {
            return `\n\t\t${mP}\n\n\t\t%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;\n\t\t%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;\n\n\t\tstruct FragmentInput {\n\t\t\t@location(0) fragUV : vec2<f32>,\n\t\t\t@location(1) pointOpacity : f32,\n\t\t\t@builtin(position) fragPos : vec4<f32>\n\t\t};\n\t\t\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = textureSample(texture0, sampler0, input.fragUV) * uniforms.pointColor * input.pointOpacity;\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static GIn(t) {
            return `\n\t\t${mP}\n\n\t\t%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;\n\t\t%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t\n\t\tstruct FragmentOutput {\n\t\t\t@location(0) color : vec4<f32>,\n\t\t\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n\t\t};\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar halfPixelSize : vec2<f32> = vec2<f32>(0.5, 0.5) / vec2<f32>(textureDimensions(texture0));\n\n\t\t\tvar tile : vec2<f32> = floor(input.fragUV);\n\t\t\tvar tex : vec2<f32> = fract(input.fragUV);\n\t\t\tvar tileOrigin : vec2<f32> = uniforms.srcRectStart + tile * (uniforms.tileSize + uniforms.tileSpacing);\n\t\t\tvar lowerBound : vec2<f32> = tileOrigin + halfPixelSize;\n\t\t\tvar upperBound : vec2<f32> = tileOrigin + uniforms.tileSize - halfPixelSize;\n\n\t\t\toutput.color = textureSampleLevel(texture0, sampler0, clamp(tex, lowerBound, upperBound), 0.0) * vec4<f32>(input.fragColor);\n\t\t\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\t\t\treturn output;\n\t\t}`
        }
        static tSn(t) {
            return `\n${mP}\n\n%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;\n%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;\n\n%%FRAGMENTINPUT_STRUCT%%\n\nstruct FragmentOutput {\n\t@location(0) color : vec4<f32>,\n\t${t ? "@builtin(frag_depth) fragDepth: f32" : ""} \n};\n\n%%C3_UTILITY_FUNCTIONS%%\n\nconst PI : f32 = 3.1415926;\n\nfn cospVec4(a : vec4<f32>, b : vec4<f32>, x : f32) -> vec4<f32>\n{\n\treturn (a + b + (a - b) * cos(x * PI)) / 2.0;\n}\n\nfn randVec3(seed : vec2<f32>) -> vec3<f32>\n{\n\treturn vec3<f32>(\n\t\tfract(sin(dot(seed.xy, vec2<f32>(12.9898,78.233))) * 43758.5453),\n\t\tfract(sin(dot(seed.yx, vec2<f32>(12.9898,-78.233))) * 43758.5453),\n\t\tfract(sin(dot(seed.xy, vec2<f32>(-12.9898,-78.233))) * 43758.5453));\n}\n\nfn sampleTile(tile : vec2<f32>, uv : vec2<f32>, ddx : vec2<f32>, ddy : vec2<f32>) -> vec4<f32>\n{\n\tvar posRandom = uniforms.tileSize;\n\tvar angleRandom = uniforms.outlineThickness;\n\tvar pixelSize = c3_getPixelSize(texture0);\n\t\n\tvar rand = (randVec3(round(tile)) - 0.5) * 2.0;\n\t\n\tvar angle = angleRandom * rand.z * PI;\n\tvar sin_a = sin(angle);\n\tvar cos_a = cos(angle);\n\tvar aspect = pixelSize.x / pixelSize.y;\n\n\tvar mid = tile + vec2<f32>(0.5, 0.5);\n\tvar dp = uv - mid;\n\tdp.x /= aspect;\n\tvar r = vec2<f32>(dp.x * cos_a - dp.y * sin_a,\n\t\t\t\t\t  dp.y * cos_a + dp.x * sin_a);\n\tr.x *= aspect;\n\n\tvar p = mid + r + (posRandom * rand.xy / 2.0);\n\t\n\treturn textureSampleGrad(texture0, sampler0, p, ddx, ddy);\n}\n\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\n\tvar output : FragmentOutput;\n\t\n\tvar blendMarginX = uniforms.tileSpacing.x;\n\tvar blendMarginY = uniforms.tileSpacing.y;\n\t\n\tvar tile = floor(input.fragUV);\n\tvar tex = fract(input.fragUV);\n\tvar ddx = dpdx(input.fragUV);\n\tvar ddy = dpdy(input.fragUV);\n\t\n\tvar curTile = sampleTile(tile, input.fragUV, ddx, ddy);\n\t\n\tvar inLeftMargin = (tex.x < blendMarginX);\n\tvar inRightMargin = (tex.x > 1.0 - blendMarginX);\n\tvar inTopMargin = (tex.y < blendMarginY);\n\tvar inBottomMargin = (tex.y > 1.0 - blendMarginY);\n\t\n\tif (inLeftMargin)\n\t{\n\t\tvar leftTile = sampleTile(tile + vec2<f32>(-1.0, 0.0), input.fragUV, ddx, ddy);\n\t\tvar leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;\n\t\tvar leftMixedTile = cospVec4(leftTile, curTile, leftMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tvar topTile =     sampleTile(tile + vec2<f32>(0.0,  -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topLeftTile = sampleTile(tile + vec2<f32>(-1.0, -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tvar bottomTile =     sampleTile(tile + vec2<f32>(0.0,  1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomLeftTile = sampleTile(tile + vec2<f32>(-1.0, 1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutput.color = leftMixedTile;\n\t\t}\n\t}\n\telse if (inRightMargin)\n\t{\n\t\tvar rightTile = sampleTile(tile + vec2(1.0, 0.0), input.fragUV, ddx, ddy);\n\t\tvar rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);\n\t\tvar rightMixedTile = cospVec4(curTile, rightTile, rightMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tvar topTile =      sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topRightTile = sampleTile(tile + vec2<f32>(1.0, -1.0), input.fragUV, ddx, ddy);\n\t\t\tvar topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tvar bottomTile =      sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomRightTile = sampleTile(tile + vec2<f32>(1.0, 1.0), input.fragUV, ddx, ddy);\n\t\t\tvar bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);\n\t\t\t\n\t\t\toutput.color = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutput.color = rightMixedTile;\n\t\t}\n\t}\n\telse if (inTopMargin)\n\t{\n\t\tvar topTile = sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);\n\t\toutput.color = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t}\n\telse if (inBottomMargin)\n\t{\n\t\tvar bottomTile = sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);\n\t\toutput.color = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t}\n\telse\n\t{\n\t\toutput.color = curTile;\n\t}\n\t\n\toutput.color *= vec4<f32>(input.fragColor);\n\t${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}\n\treturn output;\n}\n`
        }
        static AIn() {
            return "\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\toutput.color = vec4<f32>(input.fragColor);\n\t\t\treturn output;\n\t\t}"
        }
        static RIn() {
            return `\n\t\t${mP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\tfn fromLinear(linearRGB : vec3<f32>) -> vec3<f32>\n\t\t{\n\t\t\tvar cutoff : vec3<bool> = (linearRGB < vec3<f32>(0.0031308));\n\t\t\tvar higher : vec3<f32> = vec3<f32>(1.055) * pow(abs(linearRGB), vec3<f32>(1.0/2.4)) - 0.055;\n\t\t\tvar lower : vec3<f32> = linearRGB * 12.92;\n\t\t\treturn select(higher, lower, cutoff);\n\t\t}\n\n\t\tfn toLinear(sRGB : vec3<f32>) -> vec3<f32>\n\t\t{\n\t\t\tvar cutoff : vec3<bool> = (sRGB < vec3<f32>(0.04045));\n\t\t\tvar higher : vec3<f32> = pow(abs((sRGB + 0.055) / 1.055), vec3<f32>(2.4));\n\t\t\tvar lower : vec3<f32> = sRGB / 12.92;\n\t\t\treturn select(higher, lower, cutoff);\n\t\t}\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar linearGrad : vec3<f32> = mix(toLinear(vec3<f32>(input.fragColor.rgb)), toLinear(uniforms.color2.rgb), vec3<f32>(input.fragUV.x));\n\n\t\t\tvar a : f32 = mix(f32(input.fragColor.a), uniforms.color2.a, input.fragUV.x);\n\t\t\toutput.color = vec4<f32>(fromLinear(linearGrad) * a, a);\n\t\t\treturn output;\n\t\t}\n\t\t`
        }
        static kIn() {
            return `\n\t\t${mP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar grad : f32 = input.fragUV.x / (1.0 - input.fragUV.y);\n\t\t\toutput.color = vec4<f32>(input.fragColor) * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);\n\t\t\treturn output;\n\t\t}\n\t\t`
        }
        static OIn() {
            return "\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\n\t\t\tvar f : f32 = step(diffSq.x + diffSq.y, 0.25);\n\n\t\t\toutput.color = vec4<f32>(input.fragColor) * f;\n\t\t\treturn output;\n\t\t}"
        }
        static DIn() {
            return `\n\t\t${mP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\t\t\tvar distSq : f32 = diffSq.x + diffSq.y;\n\t\t\tvar norm : vec2<f32> = normalize(diff);\n\t\t\tvar halfNorm : vec2<f32> = norm * 0.5;\n\n\t\t\tvar innerF : f32 = step(distSq, 0.25);\n\n\t\t\tvar innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm * uniforms.outlineThickness;\n\t\t\tvar innerEdgeSq : vec2<f32> = innerEdge * innerEdge;\n\t\t\tvar outerF : f32 = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\t\t\t\n\t\t\toutput.color = vec4<f32>(input.fragColor) * innerF * outerF;\n\t\t\treturn output;\n\t\t}`
        }
        static FIn() {
            return `\n\t\t${mP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\t\t\tvar norm : vec2<f32> = normalize(diff);\n\t\t\tvar halfNorm : vec2<f32> = norm * 0.5;\n\t\t\tvar halfNormSq : vec2<f32> = halfNorm * halfNorm;\n\n\t\t\tvar innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm;\n\t\t\tvar innerEdgeSq : vec2<f32> = innerEdge * innerEdge;\n\n\t\t\tvar f : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\n\t\t\toutput.color = vec4<f32>(input.fragColor) * f;\n\t\t\treturn output;\n\t\t}`
        }
        static LIn() {
            return `\n\t\t${mP}\n\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar diff : vec2<f32> = input.fragUV - 0.5;\n\t\t\tvar diffSq : vec2<f32> = diff * diff;\n\t\t\tvar distSq : f32 = diffSq.x + diffSq.y;\n\t\t\tvar norm : vec2<f32> = normalize(diff);\n\t\t\tvar halfNorm : vec2<f32> = norm * 0.5;\n\t\t\tvar halfNormSq : vec2<f32> = halfNorm * halfNorm;\n\n\t\t\tvar pxNorm : vec2<f32> = uniforms.pixelSize * norm;\n\t\t\tvar innerEdge1 : vec2<f32> = halfNorm - pxNorm;\n\t\t\tvar innerEdge1Sq : vec2<f32> = innerEdge1 * innerEdge1;\n\n\t\t\tvar innerF : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\n\t\t\tvar innerEdge2 : vec2<f32> = halfNorm - pxNorm * uniforms.outlineThickness;\n\t\t\tvar innerEdge2Sq : vec2<f32> = innerEdge2 * innerEdge2;\n\t\t\tvar innerEdge3 : vec2<f32> = halfNorm - pxNorm * (uniforms.outlineThickness + 1.0);\n\t\t\tvar innerEdge3Sq : vec2<f32> = innerEdge3 * innerEdge3;\n\n\t\t\tvar outerF : f32 = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\t\t\t\n\t\t\toutput.color = vec4<f32>(input.fragColor) * innerF * outerF;\n\t\t\treturn output;\n\t\t}`
        }
        static BIn() {
            return "\n\t\t%%FRAGMENTINPUT_STRUCT%%\n\t\t%%FRAGMENTOUTPUT_STRUCT%%\n\n\t\t@fragment\n\t\tfn main(input : FragmentInput) -> FragmentOutput {\n\t\t\tvar output : FragmentOutput;\n\t\t\tvar f : f32 = 1.0 - abs(input.fragUV.y - 0.5) * 2.0;\n\t\t\toutput.color = vec4<f32>(input.fragColor) * f;\n\t\t\treturn output;\n\t\t}"
        }
    }
}
{
    const PP = self.t
      , GP = new Set(["nearest", "bilinear", "trilinear"])
      , AP = new Set(["clamp-to-edge", "repeat", "mirror-repeat"])
      , RP = self.GPUTextureUsage
      , kP = {
        On: "clamp-to-edge",
        Pn: "clamp-to-edge",
        Cn: "trilinear",
        vn: 0,
        wc: !0,
        KAn: !1,
        dMn: !1,
        A0: !1,
        qAn: !1,
        pMn: 0,
        width: -1,
        height: -1
    }
      , OP = [[1, ["r8unorm", "r8snorm", "r8uint", "r8sint", "stencil8"]], [2, ["r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "depth16unorm"]], [3, ["depth24plus"]], [4, ["r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2uint", "rgb10a2unorm", "rg11b10ufloat", "depth24plus-stencil8", "depth32float"]], [8, ["rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float"]], [16, ["rgba32uint", "rgba32sint", "rgba32float"]], [5, ["depth32float-stencil8"]]]
      , DP = new Map;
    for (const [BP,UP] of OP)
        for (const NP of UP)
            DP.set(NP, BP);
    const FP = new Set
      , LP = {
        Wxn: !0,
        flipY: !1
    };
    PP.ra.cIn = class {
        constructor(t, i) {
            this.an = t,
            this.Qs = null,
            this.Nan = "",
            this.XAn = null,
            this.YAn = null,
            this.JAn = null,
            this.ZAn = null,
            this.ZC = 0,
            this.tv = 0,
            this.YKs = !0,
            this.wM = "clamp-to-edge",
            this.bM = "clamp-to-edge",
            this.Kxn = "trilinear",
            this.qxn = 0,
            this.Yxn = !1,
            this.dKe = 0,
            this.QAn = !1,
            this.SMn = !1,
            this.tRn = !1,
            this.iRn = !1,
            this.xMn = 0,
            this.eRn = 0,
            this.sRn = !0,
            this.nRn = null,
            this.rRn = 0,
            this.hRn = !!i,
            this.hRn && (this.Nan = this.an.ePn(),
            this.QAn = !0,
            this.SMn = this.an.rPn(),
            this.Kxn = this.an.uPn(),
            this.YAn = this.an.YIn({
                Cn: this.Kxn
            }))
        }
        oRn(t) {
            if (PP.zt(t.On),
            PP.zt(t.Pn),
            PP.Ge(t.vn),
            this.wM = t.On,
            this.bM = t.Pn,
            this.Kxn = t.Cn,
            this.qxn = t.vn,
            this.Yxn = !!t.wc && this.an.Ggn() && "nearest" !== t.Cn,
            this.QAn = !!t.KAn,
            this.SMn = !!t.dMn,
            this.tRn = !!t.A0,
            this.iRn = !!t.qAn,
            this.xMn = this.an.MGn(t.pMn),
            !GP.has(this.Kxn))
                throw new Error("invalid sampling");
            if (!AP.has(this.wM) || !AP.has(this.bM))
                throw new Error("invalid wrap mode");
            if (this.xMn >= 2 && this.SMn)
                throw new Error("invalid use of multisampling");
            "nearest" === this.Kxn && (this.qxn = 0),
            this.YAn = this.an.YIn({
                On: this.wM,
                Pn: this.bM,
                Cn: this.Kxn,
                vn: this.qxn
            }),
            this.aRn(),
            this.dKe = 1
        }
        aRn() {
            const t = this.an
              , i = t.QIn();
            this.eRn = 0,
            this.QAn ? (this.eRn = RP.RENDER_ATTACHMENT,
            this.SMn && (this.eRn |= RP.TEXTURE_BINDING),
            this.iRn && (this.eRn |= RP.COPY_DST),
            this.Nan = this.an.ePn()) : (this.eRn = RP.COPY_DST | RP.TEXTURE_BINDING,
            this.Nan = this.an.cPn()),
            this.tRn && (this.eRn |= RP.COPY_SRC),
            this.Qs = i.createTexture({
                size: [this.ZC, this.tv, 1],
                mipLevelCount: this.lRn(),
                format: this.Nan,
                usage: this.eRn,
                sampleCount: this.xMn >= 2 ? this.xMn : 1
            }),
            this.XAn = this.Qs.createView();
            const e = []
              , s = PP.ra.mIn.pIn();
            for (let t = 0; t < s; ++t)
                e.push({
                    binding: 2 * t,
                    resource: this.YAn
                }, {
                    binding: 2 * t + 1,
                    resource: this.XAn
                });
            this.QAn && !this.SMn || (this.JAn = i.createBindGroup({
                layout: t.aPn(),
                entries: e
            }),
            this.ZAn = i.createBindGroup({
                layout: t.lPn(),
                entries: [{
                    binding: 0,
                    resource: this.an.YIn({
                        Cn: this.an.uPn()
                    })
                }, {
                    binding: 1,
                    resource: this.XAn
                }]
            })),
            this.uRn() && this.bPn(!0),
            FP.add(this)
        }
        cRn() {
            FP.delete(this),
            this.nRn && this.nRn.he(),
            this.bPn(!1),
            this.Qs.destroy(),
            this.Qs = null,
            this.XAn = null,
            this.JAn = null,
            this.ZAn = null
        }
        static gPn(t) {
            return t instanceof ImageBitmap || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas
        }
        static dRn(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || t instanceof ImageData
        }
        fRn(t) {
            return [t.width || t.videoWidth, t.height || t.videoHeight]
        }
        _k(t, i) {
            if (t && !PP.ra.cIn.gPn(t))
                throw new TypeError("invalid texture source");
            if (PP.Wat(i),
            i = Object.assign({}, kP, i),
            this.Qs)
                throw new Error("already created texture");
            if (this.YKs = !0,
            t) {
                const [i,e] = this.fRn(t);
                this.ZC = i,
                this.tv = e
            } else if (PP.Ge(i.width),
            PP.Ge(i.height),
            this.ZC = i.width,
            this.tv = i.height,
            this.ZC <= 0 || this.tv <= 0)
                throw new Error("invalid texture size");
            if (this.oRn(i),
            this.QAn || this.SMn)
                throw new Error("static texture cannot be render target");
            t && this.pRn(t)
        }
        pRn(t, i=!0) {
            if (this.Yxn)
                this.mRn(t, this.lRn(), i);
            else {
                const e = this.an.QIn()
                  , s = e.createCommandEncoder()
                  , n = e.createTexture({
                    size: [this.ZC, this.tv, 1],
                    mipLevelCount: 1,
                    format: this.Nan,
                    usage: RP.COPY_SRC | RP.COPY_DST | RP.RENDER_ATTACHMENT
                });
                this.wRn(n, t, 0, i),
                s.copyTextureToTexture({
                    texture: n,
                    mipLevel: 0
                }, {
                    texture: this.Qs,
                    mipLevel: 0
                }, [this.ZC, this.tv, 1]),
                e.queue.submit([s.finish()]),
                n.destroy()
            }
        }
        wRn(t, i, e, s=!0) {
            const [n,r] = this.fRn(i);
            this.an.QIn().queue.copyExternalImageToTexture({
                source: i
            }, {
                texture: t,
                mipLevel: e,
                premultipliedAlpha: !!s
            }, [n, r, 1])
        }
        lRn() {
            return this.Yxn ? Math.floor(Math.log2(Math.max(this.ZC, this.tv)) + 1) : 1
        }
        mRn(t, i, e=!0) {
            const s = this.an.QIn()
              , n = s.createTexture({
                size: [this.ZC, this.tv, 1],
                mipLevelCount: this.lRn(),
                format: this.Nan,
                usage: RP.COPY_DST | RP.COPY_SRC | RP.TEXTURE_BINDING | RP.RENDER_ATTACHMENT
            })
              , r = this.an.UIn()
              , h = r.getBindGroupLayout(0)
              , o = this.an.YIn({
                Cn: "bilinear"
            })
              , a = s.createCommandEncoder();
            this.wRn(n, t, 0, e),
            a.copyTextureToTexture({
                texture: n,
                mipLevel: 0
            }, {
                texture: this.Qs,
                mipLevel: 0
            }, [this.ZC, this.tv, 1]);
            const l = [];
            for (let t = 0; t < i; ++t)
                l.push(n.createView({
                    baseMipLevel: t,
                    mipLevelCount: 1
                }));
            let u = this.ZC
              , c = this.tv;
            for (let t = 1; t < i; ++t) {
                u /= 2,
                c /= 2;
                const i = Math.max(Math.floor(u), 1)
                  , e = Math.max(Math.floor(c), 1)
                  , d = a.beginRenderPass({
                    colorAttachments: [{
                        view: l[t],
                        loadOp: "clear",
                        clearValue: [0, 0, 0, 0],
                        storeOp: "store"
                    }]
                })
                  , f = s.createBindGroup({
                    layout: h,
                    entries: [{
                        binding: 0,
                        resource: o
                    }, {
                        binding: 1,
                        resource: l[t - 1]
                    }]
                });
                d.setPipeline(r),
                d.setBindGroup(0, f),
                d.draw(4),
                d.end(),
                a.copyTextureToTexture({
                    texture: n,
                    mipLevel: t
                }, {
                    texture: this.Qs,
                    mipLevel: t
                }, [i, e, 1])
            }
            s.queue.submit([a.finish()]),
            n.destroy()
        }
        sMn(t, i, e) {
            if (PP.Ge(t),
            PP.Ge(i),
            PP.Wat(e),
            e = Object.assign({}, kP, e),
            this.Qs)
                throw new Error("already created texture");
            this.YKs = !1,
            this.ZC = t,
            this.tv = i,
            this.oRn(e)
        }
        async $Wt(t, i) {
            if (!PP.ra.cIn.gPn(t) && !PP.ra.cIn.dRn(t))
                throw new Error("invalid texture source");
            if (!this.Qs || this.dKe <= 0)
                throw new Error("texture not created");
            if (this.YKs)
                throw new Error("cannot update static texture");
            if (PP.Wat(i),
            i = Object.assign({}, LP, i),
            (PP.ra.cIn.dRn(t) || i.flipY || !i.Wxn) && (t = await createImageBitmap(t, {
                premultiplyAlpha: i.Wxn ? "premultiply" : "none",
                imageOrientation: i.flipY ? "flipY" : "none"
            }),
            !this.Qs))
                return;
            this.an._gn();
            const [e,s] = this.fRn(t);
            this.ZC === e && this.tv === s || (this.cRn(),
            this.ZC = e,
            this.tv = s,
            this.aRn(),
            this.an.bGn(this)),
            this.pRn(t, i.Wxn)
        }
        Hwt() {
            if (this.dKe > 0)
                throw new Error("texture still has references");
            if (!this.Qs)
                throw new Error("already deleted texture");
            this.cRn()
        }
        qIn() {
            this.sRn = !1,
            this.bPn(!1)
        }
        uRn() {
            return this.YKs && this.sRn && !this.QAn
        }
        bPn(t) {
            this.an.bPn(this, t)
        }
        gRn(t, i) {
            if (this.nRn)
                throw new Error("already in a group");
            this.nRn = t,
            this.rRn = i,
            this.bPn(!1)
        }
        yRn() {
            this.nRn = null,
            this.rRn = 0,
            this.uRn() && this.bPn(!0)
        }
        HIn() {
            return this.JAn
        }
        KIn() {
            return this.ZAn
        }
        wGn() {
            return null !== this.nRn ? this.nRn.bRn() : this.uRn() ? (this.an.SPn(this),
            null !== this.nRn ? this.nRn.bRn() : null) : null
        }
        yGn() {
            return this.rRn
        }
        ns() {
            return this.hRn ? this.an.ns() : this.ZC
        }
        Kn() {
            return this.hRn ? this.an.Kn() : this.tv
        }
        Mn() {
            return this.an
        }
        RSn() {
            return this.Qs
        }
        jPn() {
            return this.XAn
        }
        aGn() {
            return this.Nan
        }
        YIn() {
            return this.YAn
        }
        bn() {
            return this.Kxn
        }
        T0() {
            return "nearest" !== this.Kxn
        }
        mPn() {
            return this.QAn
        }
        PMn() {
            return this.SMn
        }
        lGn() {
            return this.tRn
        }
        aMn() {
            this.dKe++
        }
        lMn() {
            if (this.dKe <= 0)
                throw new Error("no more references");
            this.dKe--
        }
        uMn() {
            return this.dKe
        }
        xGn() {
            return this.eRn
        }
        JIn(t, i) {
            this.eRn = t,
            this.Nan = i
        }
        EPn() {
            const t = this.an
              , i = t.QIn();
            this.Qs = t.sPn(),
            this.XAn = t.nPn(),
            t.rPn() && (this.ZAn = i.createBindGroup({
                layout: t.lPn(),
                entries: [{
                    binding: 0,
                    resource: this.YAn
                }, {
                    binding: 1,
                    resource: this.XAn
                }]
            }))
        }
        IPn() {
            this.Qs = null,
            this.XAn = null,
            this.ZAn = null
        }
        YZ() {
            let t = this.ns() * this.Kn() * PP.ra.cIn.dPn(this.aGn());
            return this.Yxn && (t += Math.floor(t / 3)),
            t
        }
        static Vs() {}
        static cMn() {
            return FP.values()
        }
        static dPn(t) {
            const i = DP.get(t);
            return "number" == typeof i ? i : NaN
        }
    }
}
{
    const jP = self.t;
    jP.ra.mIn = class {
        constructor(t, i) {
            if (jP._D(i),
            i.length < 2)
                throw new Error("invalid multi-texture group");
            this.an = t,
            this.vRn = i,
            this.SRn = null;
            for (let t = 0, e = i.length; t < e; ++t)
                i[t].gRn(this, t);
            i.length < jP.ra.mIn.pIn() && this.an.vPn(this, !0),
            this.xRn()
        }
        he() {
            this.an.vPn(this, !1);
            for (const t of this.vRn)
                t.yRn();
            this.MRn(),
            jP.sc(this.vRn),
            this.an = null
        }
        xRn() {
            this.MRn();
            const t = this.an.QIn()
              , i = []
              , e = jP.ra.mIn.pIn();
            for (let t = 0; t < e; ++t) {
                const e = this.vRn[Math.min(t, this.vRn.length - 1)];
                i.push({
                    binding: 2 * t,
                    resource: e.YIn()
                }, {
                    binding: 2 * t + 1,
                    resource: e.jPn()
                })
            }
            this.SRn = t.createBindGroup({
                layout: this.an.aPn(),
                entries: i
            })
        }
        MRn() {
            null !== this.SRn && this.an.vGn(this.SRn),
            this.SRn = null
        }
        bRn() {
            return this.SRn
        }
        static pIn() {
            return 14
        }
    }
}
{
    const $P = self.t
      , zP = self.sG
      , VP = (zP.hG,
    zP.eG)
      , WP = {
        Cn: "trilinear",
        alpha: !0,
        l0: !1,
        dMn: !0,
        A0: !1,
        qAn: !1,
        fMn: !0,
        pMn: 0
    }
      , HP = new Set;
    $P.ra.dIn = class {
        constructor(t, i) {
            $P.U(t, $P.ra.u0),
            this.an = t,
            this.ERn = !!i,
            this.wys = !!i && t.fPn(),
            this.CRn = null,
            this.bMn = !0,
            this.xMn = 0,
            this._Rn = !1,
            this.TRn = $P.v($P.Ha),
            this.MMn = VP.create(),
            this.NG = 0,
            this.VG = 0,
            this.KG = 0,
            this.ERn && (this.CRn = $P.v($P.ra.cIn, t, !0))
        }
        _k(t, i, e) {
            if ($P.Ge(t),
            $P.Ge(i),
            $P.Wat(e),
            e = Object.assign({}, WP, e),
            self.assert(!this.ERn, "do not create backbuffer"),
            this.CRn)
                throw new Error("already created render target");
            if (this.wys = !!e.l0,
            this.bMn = !!e.fMn,
            this.xMn = this.an.MGn(e.pMn),
            this.xMn >= 2 && e.dMn)
                throw new Error("invalid use of multisampling");
            this.CRn = this.an.sK(t, i, {
                Cn: e.Cn,
                wc: !1,
                KAn: !0,
                dMn: e.dMn,
                A0: e.A0,
                qAn: e.qAn,
                pMn: this.xMn
            }),
            this.EMn(),
            HP.add(this)
        }
        Hwt() {
            HP.delete(this),
            this.CRn.cRn(),
            this.CRn = null,
            this.an = null
        }
        _Mn(t, i) {
            if (t === this.ns() && i === this.Kn())
                return;
            const e = this.CRn.bn()
              , s = this.CRn.PMn()
              , n = this.CRn.lGn();
            this.CRn.cRn(),
            this.CRn = null,
            this.CRn = this.an.sK(t, i, {
                Cn: e,
                wc: !1,
                KAn: !0,
                dMn: s,
                A0: n
            }),
            this.EMn()
        }
        jPn() {
            return this.ERn ? this.an.nPn() : this.CRn.jPn()
        }
        EMn() {
            this.an.EV(this.MMn, this.ns() / this.Kn()),
            this.NG = this.an.Lwn(),
            this.VG = this.an.bZ(),
            this.KG = this.an.IZ()
        }
        AMn() {
            return this.bMn
        }
        pPn() {
            return this.ERn
        }
        GMn() {
            return this.wys
        }
        ns() {
            return this.ERn ? this.an.ns() : this.CRn.ns()
        }
        Kn() {
            return this.ERn ? this.an.Kn() : this.CRn.Kn()
        }
        Gn() {
            if (this.CRn)
                return this.CRn;
            throw new Error("no texture")
        }
        Mn() {
            return this.an
        }
        RMn() {
            return this.xMn
        }
        TMn() {
            return this.an.Lwn() === this.NG && this.an.bZ() === this.VG && this.an.IZ() === this.KG || this.EMn(),
            this.MMn
        }
        T0() {
            return this.CRn.T0()
        }
        PMn() {
            return this.CRn.PMn()
        }
        lGn() {
            return this.CRn.lGn()
        }
        kMn(t) {
            return "nearest" !== (t = Object.assign({}, WP, t)).Cn === this.T0() && (!!t.dMn === this.PMn() && (!!t.A0 === this.lGn() && (!!t.l0 === this.GMn() && ("number" == typeof t.width || "number" == typeof t.height ? !this.AMn() && this.ns() === Math.floor(t.width) && this.Kn() === Math.floor(t.height) : this.AMn()))))
        }
        VPn(t) {
            this._Rn = !!t
        }
        CPn() {
            return this._Rn
        }
        $Pn() {
            return this.TRn
        }
        static Vs() {}
        static LMn() {
            return HP.values()
        }
    }
}
{
    const KP = self.t;
    KP.ra.GPn = class {
        constructor(t, i) {
            KP.U(t, KP.ra.u0),
            KP.Ge(i),
            this.an = t,
            this.Gwn = this.an.Tgn(),
            this.IRn = i;
            const e = this.an.QIn();
            this.PRn = e.createQuerySet({
                count: this.IRn,
                type: "timestamp"
            });
            const s = self.GPUBufferUsage;
            this.GRn = e.createBuffer({
                size: this.ARn(),
                usage: s.QUERY_RESOLVE | s.COPY_SRC
            }),
            this.RRn = e.createBuffer({
                size: this.ARn(),
                usage: s.COPY_DST | s.MAP_READ
            }),
            this.Z2s = null
        }
        ARn() {
            return 8 * this.IRn
        }
        WPn() {
            return this.PRn
        }
        i8s(t) {
            t.resolveQuerySet(this.PRn, 0, this.IRn, this.GRn, 0),
            t.copyBufferToBuffer(this.GRn, 0, this.RRn, 0, this.ARn())
        }
        async qPn() {
            const t = this.ARn();
            await this.RRn.mapAsync(self.GPUMapMode.READ, 0, t);
            const i = this.RRn.getMappedRange(0, t);
            this.Z2s = new BigUint64Array(i.slice(0)),
            this.RRn.destroy(),
            this.RRn = null,
            this.GRn.destroy(),
            this.GRn = null,
            this.PRn.destroy(),
            this.PRn = null
        }
        WMn() {
            return null !== this.Z2s
        }
        $8s() {
            if (!this.Z2s)
                throw new Error("not yet got result");
            return this.Z2s
        }
        Tgn() {
            return this.Gwn
        }
    }
}
{
    const qP = self.t
      , XP = {
        kRn: null,
        VQ: null,
        XQ: null,
        getTime: null,
        YQ: null
    };
    qP.ra.NQ = class {
        constructor(t) {
            t = Object.assign({}, XP, t),
            qP.X_t(t.kRn),
            qP.qd(t.VQ),
            qP.qd(t.XQ),
            qP.qd(t.getTime),
            qP.qd(t.YQ),
            this.ORn = t.kRn,
            this.DRn = t.VQ,
            this.FRn = t.XQ,
            this.LRn = t.getTime,
            this.BRn = t.YQ,
            this.URn = null,
            this.NRn = new Set
        }
        jRn(t) {
            this.NRn.add(t)
        }
        $Rn(t) {
            this.NRn.delete(t)
        }
        Vs() {
            this.URn = null;
            for (const t of this.NRn)
                t.Vs()
        }
        zRn(t) {
            return this.ORn ? this.ORn(t) : [t.ns(), t.Kn()]
        }
        tJs(t) {
            return this.DRn(t)
        }
        VRn(t, i) {
            this.FRn(t, i)
        }
        Po() {
            return this.LRn()
        }
        bOt(t) {
            this.BRn(t)
        }
        WRn(t, i, e) {
            return i = Math.floor(i),
            e = Math.floor(e),
            !this.URn || this.URn.ns() === i && this.URn.Kn() === e || (t.pn(this.URn),
            this.URn = null),
            null === this.URn && (this.URn = t.In(null, {
                width: i,
                height: e,
                Cn: "nearest",
                wc: !1
            })),
            this.URn
        }
    }
}
{
    const YP = self.t
      , JP = self.assert
      , ZP = self.sG.eG
      , QP = YP.v(YP.Rect)
      , tG = YP.v(YP.Rect)
      , iG = YP.v(YP.Rect)
      , eG = YP.v(YP.Rect)
      , sG = ZP.create()
      , nG = ZP.create()
      , rG = {
        Wys: null,
        Yys: null,
        tbs: null,
        XJs: !1
    }
      , hG = {
        KGs: null,
        XGs: !1,
        HRn: !1,
        YGs: !1,
        qGs: !1,
        ZGs: !1,
        DJs: !1
    };
    YP.ra.zys = class {
        constructor(t, i) {
            YP.U(t, YP.ra.NQ),
            i = Object.assign({}, rG, i),
            YP.qd(i.Wys),
            YP.X_t(i.Yys),
            YP.qd(i.tbs),
            this.VYi = t,
            this.KRn = i.Wys,
            this.qRn = i.Yys,
            this.XRn = i.tbs,
            this.YRn = null,
            this.JRn = [],
            this.ZRn = [],
            this.ahn = [],
            this.QRn = !1,
            this.xys = 0,
            this.tkn = !1,
            this.ikn = !1,
            this.ekn = !1,
            this.skn = !1,
            this.nkn = !1,
            this.rkn = !1,
            this.mEn = !1,
            this.hkn = !1,
            this.okn = !1,
            this.akn = !1,
            this.lkn = !1,
            this.ukn = !1,
            this.ckn = 0,
            this.dkn = [null, null, null],
            this.fkn = !!i.XJs,
            this.pkn = 0,
            this.mkn = 0,
            this.wkn = 0,
            this.gkn = 0,
            this.ykn = null,
            this.bkn = null,
            this.vkn = YP.v(YP.Rect),
            this.Skn = YP.v(YP.Rect),
            this.xkn = YP.v(YP.Rect),
            this.Mkn = YP.v(YP.Rect),
            this.Ekn = YP.v(YP.Rect),
            this.gp = 1,
            this.Ckn = 1,
            this._kn = 0,
            this.Fe = 0,
            this.Tkn = null,
            this.Ikn = null,
            this.Pkn = 0,
            this.Gkn = 0,
            this.Akn = 0,
            this.Rkn = 0,
            this.kkn = !1,
            this.MMn = ZP.create(),
            this.Okn = ZP.create(),
            this.VYi.jRn(this)
        }
        he() {
            this.VYi.$Rn(this),
            YP.sc(this.ahn),
            YP.sc(this.JRn),
            YP.sc(this.ZRn),
            this.ykn = null,
            this.bkn = null,
            this.KRn = null,
            this.qRn = null,
            this.XRn = null
        }
        Vs() {
            this.QRn = !0,
            YP.sc(this.ahn),
            YP.sc(this.JRn),
            YP.sc(this.ZRn)
        }
        zGs() {
            return this.QRn
        }
        WGs(t, i) {
            if (YP._D(t),
            YP.Wat(i),
            i = Object.assign({}, hG, i),
            YP.sc(this.ahn),
            this.pkn = 0,
            this.mkn = 0,
            this.tkn = !1,
            this.ikn = !1,
            this.ekn = !1,
            this.skn = !1,
            this.nkn = !1,
            this.rkn = !1,
            this.ckn = 0,
            this.ukn = !!i.qGs,
            this.lkn = !!i.DJs,
            this.QRn = !1,
            YP.lw(this.JRn, t),
            0 === t.length)
                return;
            if (i.KGs) {
                if (YP._D(i.KGs),
                i.KGs.length !== t.length)
                    throw new Error("incorrect indexMap length");
                YP.lw(this.ZRn, i.KGs)
            } else {
                YP.sc(this.ZRn);
                for (let i = 0, e = t.length; i < e; ++i)
                    this.ZRn.push(i)
            }
            for (const i of t)
                this.pkn += i.syn(),
                this.mkn += i.nyn(),
                i.oyn() && (this.tkn = !0),
                i.Sni() && (this.ikn = !0),
                i.ils() && (this.ekn = !0),
                i.yni() && (this.skn = !0),
                i.uyn() && (this.nkn = !0);
            this.rkn = this.Dkn(t[0].Mn());
            const e = this.Fkn(t[0], i)
              , s = this.Lkn(t.at(-1), i);
            if (1 === t.length && !e && !s)
                return void (this.akn = !0);
            this.akn = !1;
            let n = 0;
            e && (this.ckn = 1,
            this.ahn.push(YP.v(YP.ra.zys.Ukn.Bkn, this, -1, 1)),
            n = 1);
            for (let i = 0, r = t.length; i < r; ++i)
                if (0 !== i || e) {
                    let t = 1 === n ? 2 : 1;
                    i !== r - 1 || s || (t = 0),
                    this.ckn = Math.max(this.ckn, t),
                    this.ahn.push(YP.v(YP.ra.zys.Ukn.Nkn, this, n, t, i)),
                    n = t
                } else
                    this.ckn = 1,
                    this.ahn.push(YP.v(YP.ra.zys.Ukn.jkn, this, -1, 1, i)),
                    n = 1;
            s && this.ahn.push(YP.v(YP.ra.zys.Ukn.$kn, this, n, 0))
        }
        Fkn(t, i) {
            return !!(i.XGs || t.no() || i.YGs && !t.hyn() || t.Sni() && !this.lkn || 0 !== this.pkn || 0 !== this.mkn) || (t.Mn().Rgn() ? t.ils() && (i.ZGs || i.qGs) || t.ayn() && i.qGs : t.ils() && !this.rkn && i.ZGs)
        }
        Lkn(t, i) {
            return !!i.HRn || (t.Mn().Rgn() ? t.ils() || t.yni() : (t.ils() || t.yni()) && this.zkn())
        }
        Dkn(t) {
            return t.Zd() && this.ekn && !this.skn
        }
        BJs(t, i, e) {
            YP.U(t, YP.ra.RC),
            YP.Yq(e),
            t.Zd() && null === i && (i = t.oGn()),
            this.Tkn = i,
            this.ykn = e.$Js || null,
            this.bkn = e.JJs || null,
            this.xys = e.HJs || 0,
            this.gp = e.devicePixelRatio || 1,
            this.Ckn = e.zJs || 1,
            this._kn = e.OGn || 0,
            this.Fe = "number" == typeof e.time ? e.time : this.VYi.Po(),
            this.mEn = !1,
            t.ECn(),
            this.tkn && this.x9i();
            let s = !1;
            if (this.Vkn() && (this.Wkn(t, e),
            s = !0,
            this.Ikn = this.VYi.WRn(t, this.wkn, this.gkn),
            QP.ia(this.Skn),
            QP.ZDe(),
            t.Zd() && t.HPn(this.Tkn),
            t.SGn(this.Tkn.Gn(), this.Ikn, QP.Kr(), QP.Zr(), QP.width(), QP.height())),
            this.akn)
                this.Hkn(t, e);
            else if (JP(this.ahn.length > 0, "expected some steps"),
            s || this.Wkn(t, e),
            0 !== this.xkn.width() || 0 !== this.xkn.height()) {
                t.tr(),
                t.Wn(),
                t.qr(),
                t.oK(0),
                t.lK(0),
                this.YRn = e.Kkn || null,
                this.Pkn = e.qkn || 0,
                this.Gkn = e.Xkn || 0,
                this.Akn = e.Ykn || 0,
                this.Rkn = e.Jkn || 0,
                this.kkn = !!e.Zkn,
                this.Qkn(t),
                this.dkn[0] = i,
                this.dkn[1] = this.ckn >= 1 ? this.tOn() : null,
                this.dkn[2] = 2 === this.ckn ? this.tOn() : null;
                for (const i of this.ahn) {
                    const e = this.iOn(i.eOn())
                      , s = this.iOn(i.sOn());
                    t.Zd() ? i.nOn(t, e, s) : i.rOn(t, e, s)
                }
                t.dr(null),
                this.dkn[1] && this.hOn(this.dkn[1]),
                this.dkn[2] && this.hOn(this.dkn[2]),
                this.dkn.fill(null),
                this.oOn(t),
                this.Tkn = null,
                this.Ikn = null,
                this.ykn = null,
                this.bkn = null,
                this.YRn = null
            }
        }
        Wkn(t, i) {
            const [e,s] = this.VYi.zRn(t);
            this.aOn(t, e, s),
            this.lOn(i)
        }
        aOn(t, i, e) {
            if (i <= 0 || e <= 0)
                throw new Error("invalid draw size");
            this.wkn === i && this.gkn === e || this.uOn(t, i, e, 0, 0, this.MMn, this.Okn),
            this.wkn = i,
            this.gkn = e
        }
        uOn(t, i, e, s, n, r, h) {
            const o = i / 2 + s
              , a = e / 2 + n;
            t.EV(r, i / e);
            const l = t.mV(o, a, t.xa(e), o, a, 0, e);
            ZP.ia(h, l)
        }
        lOn(t) {
            if (this.vkn.ia(t.WJs),
            t.KJs ? this.Skn.ia(t.KJs) : this.Skn.set(0, 0, this.wkn, this.gkn),
            this.akn) {
                const i = t.qkn ?? 0
                  , e = t.Xkn ?? 0;
                this.Skn.offset(-i, -e)
            }
            this.xkn.ia(this.Skn),
            this.xkn.tb(this.wkn, this.gkn);
            const i = this.Ckn * this.gp;
            this.Skn.Xm(this.pkn * i, this.mkn * i),
            this.Ekn.ia(this.Skn),
            this.Ekn.tb(this.wkn, this.gkn),
            this.Skn.QDe(0, 0, this.wkn, this.gkn),
            this.Mkn.ia(this.Skn),
            this.Mkn.tb(this.wkn, this.gkn)
        }
        Qkn(t) {
            if (this.hkn = t.VCn(),
            this.okn = t.QCn(),
            this.lkn)
                t.VV(!1),
                this.ikn && t.WCn(!0);
            else {
                if (QP.ia(this.Skn),
                t.Rgn()) {
                    const t = this.Ckn * this.gp;
                    QP.Xm(Math.max(this.pkn, 1) * t, Math.max(this.mkn, 1) * t),
                    QP.ZDe(),
                    QP.Ne(0, 0, this.wkn, this.gkn)
                } else
                    QP.ZDe();
                t.HCn(QP.Kr(), QP.Zr(), QP.width(), QP.height(), this.gkn)
            }
        }
        cOn(t) {
            t.qr(),
            this.lkn || (this.okn ? t.t_n(!1) : t.VV(!1),
            this.ikn && t.WCn(!0)),
            t.Zd() && t.pGn(!0)
        }
        oOn(t) {
            t.WCn(!1),
            this.okn ? t.ZCn(this.hkn) : t.VV(this.hkn),
            this.lkn || t.KCn(),
            t.Zd() && t.pGn(!1),
            this.mEn = t.Mzs()
        }
        dOn() {
            this.Ekn.Ne(0, 0, 1, 1)
        }
        iOn(t) {
            return t < 0 ? null : this.dkn[t]
        }
        tOn() {
            return this.VYi.tJs(this)
        }
        fOn() {
            return this.Tkn
        }
        hOn(t) {
            this.VYi.VRn(t, this)
        }
        pOn(t) {
            return this.JRn[t]
        }
        mOn(t) {
            this.YRn ? this.YRn(this, t, () => this.KRn(t, this)) : this.KRn(t, this),
            this.akn || this.cOn(t)
        }
        wOn(t) {
            if (this.lkn)
                return !0;
            if (0 !== this.Pkn || 0 !== this.Gkn || 0 !== this.Akn || 0 !== this.Rkn)
                return !1;
            const [i,e] = t.BCn(t.tJs());
            return i === this.wkn && e === this.gkn
        }
        gOn(t, i) {
            let e = this.MMn
              , s = this.Okn;
            if (i && !this.wOn(t)) {
                let i, n;
                e = sG,
                s = nG,
                0 !== this.Akn && 0 !== this.Rkn ? [i,n] = [this.Akn, this.Rkn] : [i,n] = t.BCn(t.tJs()),
                this.uOn(t, i, n, this.Pkn, this.Gkn, e, s),
                this.lkn || t.KCn()
            }
            t.pV(e),
            t.yV(s)
        }
        x9i() {
            this.VYi.bOt(this)
        }
        yOn(t, i) {
            return this.XRn(this.ZRn[t], i)
        }
        bOn(t, i) {
            let e = this.Ekn
              , s = this.Mkn
              , n = this.xkn;
            t.Rgn() && (tG.ia(e),
            tG.KDe(1),
            e = tG,
            iG.ia(s),
            iG.KDe(1),
            s = iG,
            eG.ia(n),
            eG.KDe(1),
            n = eG),
            this.vOn(t, i, s, n, e, 1 / this.wkn, 1 / this.gkn)
        }
        SOn(t, i) {
            let e = this.Mkn
              , s = this.xkn
              , n = 1 / this.wkn
              , r = 1 / this.gkn;
            if (this.qRn) {
                let {qys: t, Zys: i, Qys: h} = this.qRn(this.ykn);
                t || (QP.set(0, 0, 0, 0),
                t = QP),
                i || (i = this.wkn),
                h || (h = this.gkn),
                e = t,
                s = t,
                n = 1 / i,
                r = 1 / h
            } else
                t.Rgn() && (iG.ia(e),
                iG.KDe(1),
                e = iG,
                eG.ia(s),
                eG.KDe(1),
                s = eG);
            let h = this.Ekn;
            t.Rgn() && (h = tG,
            h.ia(this.Ekn),
            h.KDe(1)),
            this.vOn(t, i, e, s, h, n, r),
            t.Zd() && this.nkn && t.BGn(this.ukn)
        }
        xOn(t) {
            return this.ekn ? t.Zd() ? this.Vkn() ? this.Ikn : this.Tkn.Gn() : this.Tkn : null
        }
        vOn(t, i, e, s, n, r, h) {
            t.$Cn(this.xOn(t), n, e, s, this.vkn, r, h, this.gp, this.Ckn, this._kn, this.Fe),
            t.zCn(this.yOn(i, t))
        }
        Hkn(t, i) {
            const e = this.JRn[0]
              , s = t.VCn()
              , n = e.Sni();
            n && (t.VV(!1),
            t.WCn(!0),
            this.Ekn.set(0, 0, 1, 1),
            this.xkn.set(0, 0, 1, 1)),
            t.Yw(e),
            t.ac(this.xys),
            t.UV(this.Tkn),
            t.Wn();
            let r = 0
              , h = 1;
            if (this.xkn.set(0, 0, 1, 1),
            e.ayn() && this.qRn) {
                const {qys: t, Zys: i, Qys: e} = this.qRn(this.ykn);
                t && this.xkn.ia(t),
                r = Number.isFinite(i) ? 1 / i : 0,
                h = Number.isFinite(e) ? 1 / e : 0
            } else {
                const [i,e] = this.VYi.zRn(t);
                r = 1 / i,
                h = 1 / e
            }
            i.WJs ? this.vkn.ia(i.WJs) : this.vkn.set(0, 0, 0, 0),
            t.$Cn(this.xOn(t), this.Ekn, this.xkn, this.xkn, this.vkn, r, h, this.gp, this.Ckn, this._kn, this.Fe),
            t.zCn(this.yOn(0, t)),
            t.Zd() && this.nkn && t.BGn(this.ukn),
            t.oK(0),
            this.mOn(t),
            n && (t.WCn(!1),
            t.VV(s))
        }
        Vkn() {
            return this.rkn
        }
        zkn() {
            return !this.rkn
        }
        MOn() {
            return this.ekn
        }
        Tzs() {
            return !!this.akn && !this.Vkn()
        }
        EOn() {
            return this.lkn
        }
        Kys() {
            return this.ykn
        }
        jQ() {
            return this.bkn
        }
        COn() {
            return this.xys
        }
        _On() {
            return this.kkn
        }
        Mzs() {
            return this.mEn
        }
        TOn() {
            return this.Skn
        }
        IOn() {
            return this.Mkn
        }
        POn() {
            return this.fkn
        }
        async GOn(t, i, e) {}
    }
}
{
    const oG = self.t;
    oG.ra.zys.Ukn = class {
        constructor(t, i, e, s=-1) {
            this.Hys = t,
            this.AOn = i,
            this.ROn = e,
            this.eVt = s
        }
        $Gs() {
            return this.Hys
        }
        eOn() {
            return this.AOn
        }
        sOn() {
            return this.ROn
        }
        hI() {
            return this.eVt
        }
        Als() {
            return this.$Gs().pOn(this.hI())
        }
        rOn(t, i, e) {
            oG.E4()
        }
        nOn(t, i, e) {
            oG.E4()
        }
    }
}
{
    const aG = self.t;
    aG.ra.zys.Ukn.Bkn = class extends aG.ra.zys.Ukn {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        rOn(t, i, e) {
            const s = this.$Gs();
            t.tr(),
            t.Wn(),
            t.Yr(),
            t.UV(e, s._On()),
            t.Pzs(0, 0, 0, 0),
            s.mOn(t),
            s.dOn()
        }
        nOn(t, i, e) {
            const s = this.$Gs();
            t.tr(),
            t.Wn(),
            t.Yr(),
            t.UV(e, !1),
            t.Pzs(0, 0, 0, 0),
            s.mOn(t),
            s.dOn()
        }
    }
}
{
    const lG = self.t
      , uG = lG.v(lG.Rect)
      , cG = lG.v(lG.Nn);
    lG.ra.zys.Ukn.$kn = class extends lG.ra.zys.Ukn {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        rOn(t, i, e) {
            const s = this.$Gs();
            t.Yr(),
            t.UV(e),
            s.gOn(t, !0),
            t.ac(s.COn()),
            t.dr(i.Gn()),
            cG.sa(s.TOn()),
            uG.ia(s.IOn()),
            uG.KDe(1),
            t.gr(cG, uG),
            s.POn() && t.iJs(i)
        }
        nOn(t, i, e) {
            const s = this.$Gs();
            t.Yr(),
            t.UV(e, !1),
            s.wOn(t) ? cG.sa(s.IOn()) : (t.pGn(!1),
            s.gOn(t, !0),
            cG.sa(s.TOn())),
            t.yPn(null),
            t.ac(s.COn()),
            t.dr(i.Gn()),
            s.EOn() ? t.LCn() : t.gr(cG, s.IOn())
        }
    }
}
{
    const dG = self.t;
    dG.ra.zys.Ukn.jkn = class extends dG.ra.zys.Ukn {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        rOn(t, i, e) {
            const s = this.$Gs();
            t.UV(e, s._On()),
            t.Pzs(0, 0, 0, 0),
            t.RCn(),
            t.Yw(this.Als()),
            s.SOn(t, this.hI()),
            s.mOn(t),
            s.dOn()
        }
        nOn(t, i, e) {
            const s = this.$Gs();
            t.UV(e, !1),
            t.Pzs(0, 0, 0, 0),
            t.RCn(),
            t.Yw(this.Als()),
            s.SOn(t, this.hI()),
            s.mOn(t),
            s.dOn()
        }
    }
}
{
    const fG = self.t
      , pG = fG.v(fG.Rect)
      , mG = fG.v(fG.Nn);
    fG.ra.zys.Ukn.Nkn = class extends fG.ra.zys.Ukn {
        constructor(t, i, e, s) {
            super(t, i, e, s)
        }
        rOn(t, i, e) {
            const s = this.$Gs();
            t.UV(e);
            const n = 0 === this.sOn();
            n ? t.ac(s.COn()) : (t.Pzs(0, 0, 0, 0),
            t.RCn()),
            t.Yw(this.Als()),
            s.bOn(t, this.hI()),
            t.dr(i.Gn()),
            s.gOn(t, n),
            mG.sa(s.TOn()),
            pG.ia(s.IOn()),
            pG.KDe(1),
            t.gr(mG, pG),
            s.POn() && t.iJs(i)
        }
        nOn(t, i, e) {
            const s = this.$Gs();
            t.UV(e, !1);
            0 === this.sOn() ? (t.ac(s.COn()),
            t.yPn(null),
            s.wOn(t) ? mG.sa(s.IOn()) : (t.pGn(!1),
            s.gOn(t, !0),
            mG.sa(s.TOn()))) : (t.Pzs(0, 0, 0, 0),
            t.RCn(),
            mG.sa(s.IOn())),
            t.Yw(this.Als()),
            s.bOn(t, this.hI()),
            t.dr(i.Gn()),
            s.EOn() ? t.LCn() : t.gr(mG, s.IOn())
        }
    }
}
{
    const wG = self.t;
    wG.o_ = {},
    wG.o_.Nti = 45800,
    wG.o_.kOn = "stable",
    wG.o_.OOn = !0,
    wG.o_.URL = {
        DOn: "https://www.construct.net/",
        FOn: {
            games: "make-games",
            animation: "animation-software"
        },
        oSe: "",
        LOn: "https://www.construct.net",
        BOn: "https://www.construct.net/about",
        UOn: "https://www.construct.net/register",
        NOn: "https://www.construct.net/privacy-policy",
        i_: "https://www.construct.net/game-assets",
        jOn: {
            games: "https://www.construct.net/make-games/manuals/construct-3",
            animation: "https://www.construct.net/animation-software/manual"
        },
        C6t: "",
        $On: "getting-started/using-an-account",
        zOn: "releases/",
        VOn: "https://www.construct.net/profile/edit",
        WOn: "https://www.construct.net/profile/licenses",
        HOn: "https://www.construct.net/make-games/buy-construct-3",
        KOn: "https://www.construct.net/store/checkout?editor=1",
        Kge: "https://www.construct.net/make-games/features",
        A6t: "https://www.construct.net/tutorials",
        qOn: "https://www.construct.net/tutorials/beginners-guide-to-construct-3-1",
        KU: "https://www.construct.net/make-games/manuals/construct-3/scripting/guides/using-typescript",
        XOn: "https://www.construct.net/community",
        YOn: "https://www.construct.net/forum",
        JOn: "https://www.construct.net/blogs",
        t_: "https://www.construct.net/make-games/addons",
        ZOn: "https://www.construct.net/make-games/showcase",
        QOn: "https://www.construct.net/free-online-games",
        tDn: "https://github.com/Scirra/Construct-bugs",
        iDn: "https://github.com/Scirra/Construct-feature-requests",
        eDn: "https://www.construct.net/forum/construct-3/translations-11/how-to-help-translate-construc-128475"
    },
    wG.o_.sDn = function(t) {
        wG.o_.URL.oSe = wG.o_.URL.DOn + wG.o_.URL.FOn[t] + "/",
        wG.o_.URL.C6t = wG.o_.URL.jOn[t]
    }
    ,
    wG.Vhi = function(t) {
        wG.Ge(t);
        const i = t % 100;
        let e = "r" + Math.floor(t / 100);
        return 0 !== i && (e += "." + i),
        e
    }
    ,
    wG.nDn = function(t) {
        return wG.L5s(wG.Vhi(t), ".", "-")
    }
    ,
    wG.rDn = function(t) {
        wG.zt(t),
        (t = t.toLowerCase().trim()).startsWith("r") && (t = t.substr(1));
        const i = t.split(".");
        let e = -1;
        return 1 === i.length ? e = 100 * parseInt(i[0], 10) : 2 === i.length && (e = 100 * parseInt(i[0], 10) + parseInt(i[1], 10)),
        isFinite(e) || (e = -1),
        e
    }
    ,
    wG.o_.Lhi = wG.Vhi(wG.o_.Nti),
    wG.o_.hDn = wG.nDn(wG.o_.Nti)
}
globalThis.t.qs.fA.oDn = {
    aDn: [{
        id: "main",
        size: "1fr",
        name: "Main area",
        devicePixelRatio: 1,
        popup: !1,
        type: "Pane",
        activeTab: null,
        layout: {
            tabSide: !1,
            size: 1920,
            id: "middle",
            isHorizontal: !0,
            children: [{
                id: "propertiesBar",
                size: "320px",
                fixedSize: !0,
                name: "Properties",
                devicePixelRatio: 1,
                popup: !1,
                type: "CaptionPane",
                activeTab: null,
                caption: "Properties",
                side: "left",
                docked: !0
            }, {
                id: "",
                size: "1fr",
                name: "middle2",
                devicePixelRatio: 1,
                type: "DockingPane",
                activeTab: null,
                side: "",
                docked: !0,
                layout: {
                    tabSide: !1,
                    size: 1024,
                    id: "middle3",
                    isHorizontal: !1,
                    children: [{
                        id: "midPane",
                        size: "1fr",
                        name: "Mid pane",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "",
                        docked: !0,
                        layout: {
                            tabSide: "top",
                            children: []
                        }
                    }, {
                        id: "assetBrowserBar",
                        size: "250px",
                        name: "Asset Browser",
                        devicePixelRatio: 1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Asset Browser",
                        side: "bottom",
                        docked: !0
                    }]
                }
            }, {
                id: "",
                size: "320px",
                fixedSize: !0,
                name: "middle2",
                devicePixelRatio: 1,
                type: "DockingPane",
                activeTab: null,
                side: "right",
                docked: !0,
                layout: {
                    tabSide: !1,
                    size: 1024,
                    id: "middle3",
                    isHorizontal: !1,
                    children: [{
                        id: "projectBar",
                        size: "487px",
                        name: "Project",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Project",
                        side: "top",
                        docked: !0
                    }, {
                        id: "",
                        size: "487px",
                        name: "middle4",
                        devicePixelRatio: 1,
                        type: "TabPane",
                        activeTab: null,
                        side: "bottom",
                        docked: !0,
                        layout: {
                            tabSide: "bottom",
                            children: [{
                                id: "layersBar",
                                size: "487px",
                                name: "Layers",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !0,
                                caption: "Layers",
                                side: "bottom",
                                docked: !0
                            }, {
                                id: "tilemapBar",
                                size: "487px",
                                name: "Tilemap",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !1,
                                caption: "Tilemap",
                                side: "bottom",
                                docked: !0
                            }]
                        }
                    }]
                }
            }]
        }
    }],
    lDn: [{
        id: "main",
        size: "1fr",
        name: "Main area",
        devicePixelRatio: 1,
        popup: !1,
        type: "Pane",
        activeTab: null,
        layout: {
            tabSide: !1,
            size: 1920,
            id: "middle",
            isHorizontal: !0,
            children: [{
                id: "propertiesBar",
                size: "320px",
                fixedSize: !0,
                name: "Properties",
                devicePixelRatio: 1,
                popup: !1,
                type: "CaptionPane",
                activeTab: null,
                caption: "Properties",
                side: "left",
                docked: !0
            }, {
                id: "midPane",
                size: "1fr",
                name: "Mid pane",
                devicePixelRatio: 1,
                popup: !1,
                type: "TabPane",
                activeTab: null,
                side: "",
                docked: !0,
                layout: {
                    tabSide: "top",
                    children: []
                }
            }, {
                size: "300px",
                fixedSize: !0,
                name: "middle2",
                devicePixelRatio: 1,
                popup: !1,
                type: "DockingPane",
                activeTab: null,
                side: "right",
                docked: !0,
                layout: {
                    tabSide: !1,
                    size: 974,
                    id: "middle3",
                    isHorizontal: !1,
                    children: [{
                        id: "projectBar",
                        size: "487px",
                        name: "Project",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Project",
                        side: "top",
                        docked: !0
                    }, {
                        size: "300px",
                        name: "middle4",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "bottom",
                        docked: !0,
                        layout: {
                            tabSide: "bottom",
                            children: [{
                                id: "layersBar",
                                size: "300px",
                                name: "Layers",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !0,
                                caption: "Layers",
                                side: "bottom",
                                docked: !0
                            }, {
                                id: "tilemapBar",
                                size: "300px",
                                name: "Tilemap",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !1,
                                caption: "Tilemap",
                                side: "bottom",
                                docked: !0
                            }]
                        }
                    }]
                }
            }]
        }
    }],
    uDn: [{
        id: "main",
        size: "1fr",
        name: "Main area",
        devicePixelRatio: 1,
        popup: !1,
        type: "Pane",
        activeTab: null,
        layout: {
            tabSide: !1,
            size: 883,
            id: "middle",
            isHorizontal: !1,
            children: [{
                id: "",
                size: "1fr",
                name: "(no name)",
                devicePixelRatio: 1,
                popup: !1,
                type: "Pane",
                activeTab: null,
                layout: {
                    tabSide: !1,
                    size: 1309,
                    id: "middle",
                    isHorizontal: !0,
                    children: [{
                        id: "propertiesBar",
                        size: "320px",
                        fixedSize: !0,
                        name: "Properties",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "CaptionPane",
                        activeTab: null,
                        caption: "Properties",
                        side: "left",
                        docked: !0
                    }, {
                        id: "midPane",
                        size: "1fr",
                        name: "Mid pane",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "",
                        docked: !0,
                        layout: {
                            tabSide: "top",
                            children: []
                        }
                    }, {
                        id: "",
                        size: "300px",
                        fixedSize: !0,
                        name: "middle2",
                        devicePixelRatio: 1,
                        popup: !1,
                        type: "TabPane",
                        activeTab: null,
                        side: "right",
                        docked: !0,
                        layout: {
                            tabSide: "bottom",
                            children: [{
                                id: "projectBar",
                                size: "300px",
                                name: "Project",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !0,
                                caption: "Project",
                                side: "right",
                                docked: !0
                            }, {
                                id: "layersBar",
                                size: "300px",
                                name: "Layers",
                                devicePixelRatio: 1,
                                popup: !1,
                                type: "CaptionPane",
                                activeTab: !1,
                                caption: "Layers",
                                side: "right",
                                docked: !0
                            }]
                        }
                    }]
                }
            }, {
                id: "",
                size: "250px",
                name: "middle2",
                devicePixelRatio: 1,
                type: "TabPane",
                activeTab: null,
                side: "bottom",
                docked: !0,
                layout: {
                    tabSide: "bottom",
                    children: [{
                        id: "timelineBar",
                        size: "250px",
                        name: "Timeline",
                        devicePixelRatio: 1,
                        type: "CaptionPane",
                        activeTab: !0,
                        caption: "Timeline",
                        side: "bottom",
                        docked: !0
                    }, {
                        id: "assetBrowserBar",
                        size: "250px",
                        name: "Asset Browser",
                        devicePixelRatio: 1,
                        type: "CaptionPane",
                        activeTab: !1,
                        caption: "Asset Browser",
                        side: "bottom",
                        docked: !0
                    }]
                }
            }]
        }
    }]
};
{
    const gG = self.t
      , yG = (gG.ek(import.meta.url),
    "workers/")
      , bG = "dispatchWorker.js"
      , vG = "jobWorker.js";
    class SG extends gG.Me {
        constructor() {
            super(),
            this.cDn = gG.M9s.lVs("oneworker") ? 1 : Math.min(gG.hardwareConcurrency, 16),
            this.dDn = null,
            this.fDn = [],
            this.pDn = new Map,
            this.mDn = 0,
            this.wDn = !1,
            this.gDn = !1,
            this.yDn = !1,
            this.g_t = null,
            this.w_t = null
        }
        vp() {
            if (this.wDn)
                throw new Error("already initialised");
            return gG.n0("JobSchedulerInit"),
            this.dDn = new Worker(yG + bG),
            this.dDn.addEventListener("message", t => this.bDn(t)),
            this.vDn(),
            this.wDn = !0,
            this.g_t = new Promise( (t, i) => {
                this.w_t = t
            }
            ),
            this.g_t
        }
        vDn() {
            const t = new Worker(yG + vG);
            t.addEventListener("message", t => this.SDn(t));
            const i = new MessageChannel;
            this.dDn.postMessage({
                type: "_addJobWorker",
                port: i.port1
            }, [i.port1]),
            t.postMessage({
                type: "init",
                number: this.fDn.length,
                port: i.port2
            }, [i.port2]),
            this.gDn = !0,
            this.fDn.push(t)
        }
        Qdt(t, i, e, s, n) {
            if (gG.zt(t),
            gG._U(i),
            gG.zAt(e),
            gG.X_t(s),
            gG.Mw(n, gG.Cye),
            !this.wDn)
                throw new Error("not yet initialised");
            e || (e = []);
            const r = this.mDn++
              , h = {
                type: t,
                jobId: r,
                params: i,
                transferables: e
            }
              , o = new Promise( (t, i) => {
                this.pDn.set(r, {
                    resolve: t,
                    xDn: s,
                    reject: i,
                    MDn: !1
                })
            }
            );
            return n && n.Aze( () => this.EDn(r)),
            this.dDn.postMessage(h, e),
            this.CDn(),
            o
        }
        EDn(t) {
            gG.Ge(t);
            const i = this.pDn.get(t);
            i && (i.MDn = !0,
            i.resolve = null,
            i.xDn = null,
            i.reject = null,
            this.dDn.postMessage({
                type: "_cancel",
                jobId: t
            }))
        }
        bDn(t) {
            const i = t.data
              , e = i.type;
            if ("error" !== e)
                throw new Error(`unknown message from dispatch worker '${e}'`);
            console.error("[Dispatch worker] Error: " + i.error)
        }
        SDn(t) {
            const i = t.data
              , e = i.type
              , s = i.jobId;
            switch (e) {
            case "result":
                this._Dn(s, i.result);
                break;
            case "progress":
                this.TDn(s, i.progress);
                break;
            case "error":
                this.IDn(s, i.error);
                break;
            case "ready":
                this.PDn();
                break;
            default:
                throw new Error(`unknown message from worker '${e}'`)
            }
        }
        _Dn(t, i) {
            const e = this.pDn.get(t);
            if (!e)
                throw new Error("invalid job ID");
            e.MDn || e.resolve(i),
            this.pDn.delete(t)
        }
        TDn(t, i) {
            const e = this.pDn.get(t);
            if (!e)
                throw new Error("invalid job ID");
            !e.MDn && e.xDn && e.xDn(i)
        }
        IDn(t, i) {
            const e = this.pDn.get(t);
            if (!e)
                throw new Error("invalid job ID");
            e.MDn || e.reject(i),
            this.pDn.delete(t)
        }
        PDn() {
            this.gDn = !1,
            this.w_t && (this.w_t(),
            this.w_t = null,
            this.g_t = null,
            gG.I0("JobSchedulerInit")),
            this.CDn()
        }
        CDn() {
            if (!(this.fDn.length >= this.cDn || this.gDn || this.yDn || this.pDn.size <= this.fDn.length))
                try {
                    this.vDn()
                } catch (t) {
                    this.yDn = !0,
                    console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this.fDn.length} so far)`, t)
                }
        }
    }
    gG.twt = gG.v(SG)
}
{
    const xG = self.t;
    globalThis.GDn = class extends xG.Me {
        constructor() {
            super(),
            this.ADn = null
        }
        vR() {
            xG.E4()
        }
        Vdt() {
            xG.E4()
        }
        Fa() {
            xG.E4()
        }
        dj() {
            xG.E4()
        }
        $te() {
            xG.E4()
        }
        YMt() {
            xG.E4()
        }
        DZs() {
            xG.E4()
        }
        Vpt() {
            xG.E4()
        }
    }
}
{
    const MG = self.t;
    MG.ii = class extends MG.Me {
        constructor() {
            super(),
            this.Fxe = new.target,
            this.hi = null,
            this.m = null,
            this.RDn = null
        }
        he() {
            this.Fxe = null,
            this.hi = null,
            this.m = null
        }
        kDn(t) {
            MG.U(t, self.Plugin),
            this.hi = t
        }
        Ja() {
            return this.hi
        }
        ODn(t) {
            MG.qd(t),
            this.Fxe = t
        }
        jxe() {
            return this.Fxe
        }
        DDn(t) {
            MG.U(t, self.si),
            this.m = t
        }
        GetInfo() {
            if (!this.m)
                throw new Error("plugin must set info");
            return this.m
        }
        Ql(t) {
            MG.zt(t),
            this.RDn = t
        }
        FDn() {
            return this.RDn
        }
        lg() {
            return this.hi.lg()
        }
        yn() {
            return this.Ja().yn()
        }
        ZA(t) {
            return MG.U(t, self.aF),
            MG.v(this.jxe().G, this, t)
        }
        ri() {
            const t = self.app;
            let i = [["instance-wait-for-signal", "timer"]];
            for (const [e,s] of i)
                this.hi.JQs(e) && this.hi.ci(e).ai(t.oi(s))
        }
        Pi(t, i) {
            MG.zt(t),
            MG.qd(i),
            this.hi.ki(t).eee(i)
        }
        Rv() {}
        async nh(t) {}
    }
}
{
    const EG = self.t;
    EG.Ni = class extends EG.Me {
        constructor(t, i) {
            EG.U(t, EG.ii),
            EG.U(i, window.aF),
            super(),
            this.LDn = t,
            this.Os = i,
            this.wrs = null,
            this.BDn = null
        }
        he() {
            this.wrs && (self.app.zs().removeEventListener("renderercontextlost", this.wrs),
            this.wrs = null),
            this.BDn && (self.app.zs().removeEventListener("renderercontextrestored", this.BDn),
            this.BDn = null),
            this.LDn = null,
            this.Os = null,
            EG.he(this)
        }
        NM(t) {
            return EG.U(t, window.AM),
            EG.v(this.hg().jxe().Instance, this, t)
        }
        Ds() {
            return this.Os
        }
        hg() {
            return this.LDn
        }
        Ja() {
            return this.LDn.Ja()
        }
        yn() {
            return this.Ds().yn()
        }
        FM() {}
        Ps() {
            this.wrs || (this.wrs = () => this.Vs(),
            this.BDn = () => this.Lv(),
            self.app.zs().addEventListener("renderercontextlost", this.wrs),
            self.app.zs().addEventListener("renderercontextrestored", this.BDn))
        }
        Vs() {}
        Lv() {}
        xM() {
            return null
        }
        SM() {
            return "clamp-to-edge"
        }
        CM() {
            return "clamp-to-edge"
        }
    }
}
{
    const CG = self.t
      , _G = CG.v(CG.Rect, 0, 0, 1, 1)
      , TG = CG.v(CG.Nn);
    TG.sa(_G),
    CG.Ai = class extends CG.Me {
        constructor(t, i) {
            CG.U(t, CG.Ni),
            CG.U(i, window.AM),
            super(),
            this.Js = t,
            this.Ie = i,
            this.Fn = !1,
            this.UDn = !1,
            this.NDn = !1,
            this.jDn = _G,
            this.$Dn = TG,
            this.wrs = null,
            this.BDn = null
        }
        he() {
            this.wrs && (self.app.zs().removeEventListener("renderercontextlost", this.wrs),
            this.wrs = null),
            this.BDn && (self.app.zs().removeEventListener("renderercontextrestored", this.BDn),
            this.BDn = null),
            this.Js = null,
            this.Ie = null,
            CG.he(this)
        }
        WI() {}
        wb() {
            return this.Js
        }
        Ds() {
            return this.Js.Ds()
        }
        hg() {
            return this.Js.hg()
        }
        Ja() {
            return this.Js.Ja()
        }
        Fi() {}
        pS() {}
        Ax(t) {}
        ue(t, i) {}
        ro(t, i, e) {}
        PO(t, i) {}
        N(t, i) {
            return !1
        }
        yn() {
            return this.Ie.yn()
        }
        Gs() {
            return this.Ie
        }
        jr() {}
        ao() {
            return !1
        }
        lo() {
            CG.E4()
        }
        ho() {
            CG.E4()
        }
        oo() {
            return null
        }
        Zv() {
            const t = this.Ie.oCs();
            if (t && t.eos()) {
                const i = t.Vns();
                return [i.ns(), i.Kn()]
            }
            return [100, 100]
        }
        tM() {
            const t = this.Ie.oCs();
            return t && t.eos() ? t.Jr() : null
        }
        aCs() {
            const t = this.Ie.oCs();
            return t && t.eos() ? t.Fc() : null
        }
        pM() {
            const t = this.Ie.oCs();
            return !!t && t.WBt()
        }
        no() {
            return !1
        }
        La() {
            return this.aCs()
        }
        br() {
            return !1
        }
        yr(t) {
            CG.E4()
        }
        Un(t, i) {
            CG.E4()
        }
        co() {
            return null
        }
        Nx(t, i) {
            const e = i.Wr
              , s = this.Ie
              , n = s.sl()
              , r = s.$o()
              , h = s.eg()
              , o = h.pw();
            for (let i = 0; i < o; i++) {
                const [s,o] = n.ag(e, h.tO(i), h.eO(i), r)
                  , [a,l] = n.ag(e, h.tO(i + 1), h.eO(i + 1), r);
                t.Ra(s, o, a, l)
            }
        }
        Gn(t) {
            if (CG.Mw(t, self.Iw),
            !t)
                return null;
            let i = t.Trs();
            return i ? (this.jDn = t.Jr(),
            this.$Dn = t.Fc(),
            i) : (this.Fn || (this.UDn = !0,
            t.Ors().then(t => {
                this.UDn = !1
            }
            ).catch(t => {
                console.error("Error loading texture:", t),
                this.NDn = !0
            }
            )),
            null)
        }
        Jr() {
            return this.jDn
        }
        Fc() {
            return this.$Dn
        }
        Io() {
            return this.NDn
        }
        wr() {}
        Bn(t) {
            CG.zt(t);
            let i = 0
              , e = 0;
            switch (t) {
            case "top-left":
                break;
            case "top":
                i = .5;
                break;
            case "top-right":
                i = 1;
                break;
            case "left":
                e = .5;
                break;
            case "center":
                i = .5,
                e = .5;
                break;
            case "right":
                i = 1,
                e = .5;
                break;
            case "bottom-left":
                e = 1;
                break;
            case "bottom":
                i = .5,
                e = 1;
                break;
            case "bottom-right":
                i = 1,
                e = 1;
                break;
            default:
                throw new Error("invalid origin")
            }
            this.Ie._c(i),
            this.Ie.Dc(e)
        }
        gO() {
            return null
        }
        bO(t) {
            CG.E4()
        }
        SO(t) {}
        Ps() {
            this.wrs || (this.wrs = () => this.Vs(),
            this.BDn = () => this.Lv(),
            self.app.zs().addEventListener("renderercontextlost", this.wrs),
            self.app.zs().addEventListener("renderercontextrestored", this.BDn))
        }
        Vs() {}
        Lv() {}
        async uo() {}
    }
}
{
    const IG = self.t;
    IG.bh = class extends IG.Ai {
        constructor(t, i) {
            super(t, i),
            this.zDn = !1,
            this.VDn = () => this.ce()
        }
        he() {
            this.pe(!1),
            this.VDn = null
        }
        Fi() {
            this.Ie.me("live-preview") && this.pe(!0)
        }
        WDn() {
            self.app.addEventListener("livepreviewstop", this.VDn)
        }
        HDn() {
            self.app.removeEventListener("livepreviewstop", this.VDn)
        }
        pe(t) {
            if (t = !!t,
            this.zDn !== t)
                if (self.app.k_() && t)
                    self.app.j_(this.yn(), 10);
                else if (this.zDn = t,
                this.zDn) {
                    this.WDn(),
                    this.ye();
                    this.Ie.iN().RK(!0)
                } else {
                    this.Pe(),
                    this.HDn();
                    const t = this.Ie.Xb()
                      , i = t ? t.Bx() : null;
                    if (i) {
                        if (!i.fo() && !i.uFs() && !this.Ie.wvs()) {
                            this.Ie.iN().RK(!1)
                        }
                    } else if (!this.Ie.wvs()) {
                        this.Ie.iN().RK(!1)
                    }
                }
        }
        de() {
            return this.zDn
        }
        ye() {}
        Pe() {}
        ce() {
            this.pe(!1),
            this.Ie.A("live-preview", !1)
        }
    }
}
{
    const PG = self.t
      , GG = self.lang
      , AG = new Set(["integer", "float", "percent", "angle", "text", "longtext", "check", "color", "font", "combo", "animation", "dynamiccombo", "link", "group", "info", "object", "projectfile"])
      , RG = new Set(["for-each-instance", "once-for-type", "for-single-instance-or-type"])
      , kG = new WeakMap;
    window.i = class t {
        constructor(t, i, e) {
            if (PG.zt(t),
            PG.zt(i),
            !AG.has(t))
                throw new Error(`invalid property type '${t}'`);
            if (!i)
                throw new Error("property id cannot be empty");
            if (this.gTt = {
                initialValue: null,
                Cb: 1,
                yb: null,
                gs: null,
                bs: "for-each-instance",
                items: null,
                yt: null,
                Gr: null,
                se: !0,
                minValue: null,
                maxValue: null,
                _l: !0,
                Dl: !0,
                Z: "all",
                hidden: !1,
                $: !0,
                D: !1,
                ys: !0,
                Pc: null,
                filter: "",
                Ll: null,
                zl: null,
                kl: "",
                Gl: "",
                jl: "",
                Rl: ""
            },
            PG.$nt(e) ? (this.gTt = Object.assign(this.gTt, e),
            "color" === t && PG.kft(e.initialValue) && (this.gTt.initialValue = new PG.Ha,
            this.gTt.initialValue.Kd(e.initialValue))) : "color" === t && PG.kft(e) ? (this.gTt.initialValue = new PG.Ha,
            this.gTt.initialValue.Kd(e)) : this.gTt.initialValue = e,
            !("text" !== t && "longtext" !== t || void 0 !== this.gTt.initialValue && null !== this.gTt.initialValue)) {
                const t = GG(`.${i}.initial-value`);
                t === PG.p.Fl ? this.gTt.initialValue = "" : this.gTt.initialValue = t
            }
            if (void 0 === this.gTt.initialValue && (this.gTt.initialValue = null),
            this.lVt = t,
            this.phs = i,
            PG.X_t(this.gTt.yt),
            this.rVt = GG(`.${i}.name`),
            this.Eos = GG(`.${i}.desc`),
            this.KDn = "",
            "link" === this.lVt && (this.KDn = GG(`.${i}.link-text`)),
            this.Yqs = [],
            this.qDn = new Map,
            "object" !== this.lVt && "projectfile" !== this.lVt || (this.gTt.initialValue = -1),
            this.XDn = "",
            this.Kqs = "",
            "combo" === this.lVt) {
                PG._D(this.gTt.items);
                for (let t of this.gTt.items)
                    PG.zt(t),
                    this.qDn.set(t, this.Yqs.length),
                    this.Yqs.push({
                        value: t,
                        displayName: GG(`.${i}.items.${t}`)
                    })
            }
            this.YDn()
        }
        YDn() {
            if (PG.Ge(this.gTt.Cb),
            "link" === this.lVt && (PG.qd(this.gTt.gs),
            PG.X_t(this.gTt.yb),
            !RG.has(this.gTt.bs)))
                throw new Error(`invalid link callback type '${this.gTt.bs}'`);
            switch (this.lVt) {
            case "integer":
            case "float":
            case "percent":
            case "angle":
                PG.VY(this.gTt.initialValue);
                break;
            case "text":
            case "longtext":
            case "font":
                PG.zt(this.gTt.initialValue);
                break;
            case "check":
                this.gTt.initialValue = !!this.gTt.initialValue;
                break;
            case "animation":
                if (null !== this.gTt.initialValue)
                    throw new Error("do not specify initial value for 'animation' property");
                this.gTt.initialValue = "";
                break;
            case "color":
                PG.U(this.gTt.initialValue, PG.Ha);
                break;
            case "combo":
                if (PG.zt(this.gTt.initialValue),
                !this.gTt.items.includes(this.gTt.initialValue))
                    throw new Error("combo property initial value not in items list");
                break;
            case "link":
            case "group":
                break;
            case "info":
                PG.qd(this.gTt.Gr);
                break;
            case "dynamiccombo":
                if (PG.qd(this.gTt.Ll),
                PG.qd(this.gTt.zl),
                null !== this.gTt.initialValue)
                    throw new Error("do not specify initial value for 'dynamiccombo' property");
                this.gTt.initialValue = ""
            }
        }
        Vdt() {
            return this.lVt
        }
        vR() {
            return this.phs
        }
        Fa() {
            return this.rVt
        }
        QM() {
            return this.gTt.initialValue
        }
        _oe() {
            return this.gTt.yt
        }
        dj() {
            return this.Eos
        }
        Koe() {
            if ("combo" !== this.lVt)
                throw new Error("not a combo property type");
            return this.Yqs
        }
        dZs(t) {
            if (PG.zt(t),
            "combo" !== this.lVt)
                throw new Error("not a combo property type");
            for (let i of this.Yqs)
                if (i.value === t)
                    return !0;
            return !1
        }
        IO(t) {
            if (PG.zt(t),
            "combo" !== this.lVt)
                throw new Error("not a combo property type");
            for (let i of this.Yqs)
                if (i.value === t)
                    return i.displayName;
            throw new Error("invalid combo item value")
        }
        nys(t) {
            if (PG.zt(t),
            "combo" !== this.lVt)
                throw new Error("not a combo property type");
            let i = this.qDn.get(t);
            if (void 0 === i)
                throw new Error("invalid combo item value");
            return i
        }
        Wre() {
            if ("link" !== this.lVt)
                throw new Error("not a link property type");
            return this.KDn
        }
        Bre() {
            if ("link" !== this.lVt)
                throw new Error("not a link property type");
            return this.gTt.gs
        }
        Dre() {
            if ("link" !== this.lVt)
                throw new Error("not a link property type");
            return this.gTt.bs
        }
        Kre() {
            if ("info" !== this.lVt)
                throw new Error("not an info property type");
            return this.gTt.Gr
        }
        sT() {
            if (!this.$Vs())
                throw new Error("not a numeric property type");
            return null !== this.gTt.minValue
        }
        nT() {
            if (!this.$Vs())
                throw new Error("not a numeric property type");
            return this.gTt.minValue
        }
        Uoe() {
            if (!this.$Vs())
                throw new Error("not a numeric property type");
            return null !== this.gTt.maxValue
        }
        Woe() {
            if (!this.$Vs())
                throw new Error("not a numeric property type");
            return this.gTt.maxValue
        }
        Ere() {
            if (!this.$Vs())
                throw new Error("not a numeric property type");
            return this.gTt._l
        }
        Vre() {
            if (!this.$Vs())
                throw new Error("not a numeric property type");
            return this.gTt.Dl
        }
        $Vs() {
            return "integer" === this.lVt || "float" === this.lVt || "percent" === this.lVt || "angle" === this.lVt
        }
        Moe() {
            const t = this.lVt;
            return !!this.gTt.D && ("integer" === t || "float" === t || "percent" === t || "angle" === t || "text" === t || "longtext" === t || "check" === t || "combo" === t || "animation" === t || "dynamiccombo" === t || "color" === t)
        }
        gxs() {
            return this.gTt.ys
        }
        Toe() {
            return this.gTt.se
        }
        Ooe() {
            return self.app.UZs(this.gTt.Z)
        }
        Vpt() {
            return this.gTt.hidden
        }
        JDn(t) {
            PG.zt(t),
            this.XDn = t
        }
        ZDn() {
            return this.XDn
        }
        Zre() {
            if ("object" !== this.lVt)
                throw new Error("not an object property type");
            return this.gTt.Pc
        }
        tae() {
            if ("projectfile" !== this.lVt)
                throw new Error("not a projectfile property type");
            return this.gTt.filter
        }
        QDn(t) {
            PG.zt(t),
            this.Kqs = t
        }
        tFn() {
            return this.Kqs
        }
        Ure() {
            if ("link" !== this.lVt)
                throw new Error("not a link property type");
            return this.gTt.yb
        }
        wne() {
            return "integer" === this.lVt || "float" === this.lVt || "percent" === this.lVt || "angle" === this.lVt || "text" === this.lVt
        }
        kne() {
            if ("integer" !== this.lVt && "float" !== this.lVt)
                throw new Error("property does not support a drag speed multiplier");
            return this.gTt.Cb
        }
        Lre() {
            if ("dynamiccombo" !== this.lVt)
                throw new Error("property does not support a comboGetter");
            return this.gTt.Ll
        }
        Tre() {
            if ("dynamiccombo" !== this.lVt)
                throw new Error("property does not support a comboValidator");
            return this.gTt.zl
        }
        Gre() {
            return this.gTt.kl
        }
        Pre() {
            return this.gTt.Gl
        }
        jre() {
            return this.gTt.jl
        }
        Ire() {
            return this.gTt.Rl
        }
        Lxt() {
            return !("link" === this.lVt || "group" === this.lVt || "info" === this.lVt)
        }
        Coe() {
            return !!this.gTt.$
        }
        static iFn(i) {
            const e = kG.get(i);
            if (e)
                return e;
            const s = i.Vdt()
              , n = i.vR();
            let r = i.eFn();
            if (PG.$nt(r)) {
                if (r = Object.assign({}, {
                    initialValue: null,
                    dragSpeedMultiplier: 1,
                    items: null,
                    minValue: null,
                    maxValue: null,
                    linkCallback: null,
                    callbackType: "for-each-instance",
                    infoCallback: null,
                    allowedPluginIds: null,
                    interpolatable: !1,
                    templatable: !1,
                    filter: null
                }, r),
                r = {
                    initialValue: r.initialValue,
                    Cb: r.dragSpeedMultiplier,
                    items: r.items,
                    minValue: r.minValue,
                    maxValue: r.maxValue,
                    gs: r.linkCallback,
                    bs: r.callbackType,
                    Gr: r.infoCallback,
                    Pc: r.allowedPluginIds,
                    D: r.interpolatable,
                    ys: r.templatable,
                    filter: r.filter
                },
                "link" === s)
                    if ("for-each-instance" === r.bs) {
                        const t = r.gs;
                        r.gs = i => t(i.sFn())
                    } else {
                        if ("once-for-type" !== r.bs)
                            throw new Error("invalid callbackType");
                        {
                            const t = r.gs;
                            r.gs = i => t(i.nFn())
                        }
                    }
                if ("info" === s) {
                    const t = r.Gr;
                    r.Gr = i => t(i.Nl().sFn())
                }
            }
            const h = new t(s,n,r);
            return kG.set(i, h),
            h
        }
    }
}
{
    const OG = self.t
      , DG = new Set(["3d", "data-and-storage", "html-elements", "general", "input", "media", "monetisation", "platform-specific", "web", "other"])
      , FG = new Set(["object", "world"])
      , LG = new Set(["", "module"]);
    window.si = class extends OG.Me {
        constructor(t) {
            OG.zt(t),
            super(),
            this.phs = t,
            this.rVt = "",
            this.Eos = "",
            this.i3t = "1.0.0.0",
            this.rFn = !1,
            this.CZs = "general",
            this.hFn = "",
            this.qxe = "http://",
            this.oFn = "object",
            this.Zxe = "icon.svg",
            this.Qxe = "image/svg+xml",
            this.aFn = "",
            this.lFn = ["c3runtime/plugin.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"],
            this.uFn = [],
            this.dJe = !1,
            this.cFn = !1,
            this.dFn = !1,
            this.fFn = !1,
            this.pFn = "",
            this.mFn = !1,
            this.mw = null,
            this.wFn = !1,
            this.Ans = !1,
            this.Zze = !1,
            this.gFn = !1,
            this.EZs = !1,
            this.yFn = !1,
            this.bFn = !1,
            this.vFn = !1,
            this.SFn = !1,
            this.xFn = !1,
            this.MFn = !1,
            this.Wgn = !1,
            this.EFn = !0,
            this.CFn = !0,
            this._Fn = "",
            this.TFn = !0,
            this.IFn = !1,
            this.PFn = !1,
            this.GFn = !1,
            this.AFn = !1,
            this.RFn = !1,
            this.kFn = !1,
            this.OFn = !1,
            this.DFn = !1,
            this.FFn = !1,
            this.LFn = !1,
            this.BFn = !1,
            this.UFn = !1,
            this.NFn = {},
            this.pHs = [],
            this.jFn = new Map,
            this.$Fn = [],
            this.zFn = [],
            this.VFn = [],
            this.WFn = [],
            this.HFn = !1,
            this.KFn = "",
            this.qFn = [],
            this.XFn = {
                M: "",
                objectType: "",
                bie: ""
            },
            this.YFn = [],
            this.JFn = new Map
        }
        Njt() {
            return this.phs
        }
        I(t) {
            OG.zt(t),
            this.rVt = t
        }
        Fa() {
            return this.rVt
        }
        k(t) {
            OG.zt(t),
            this.Eos = t
        }
        dj() {
            return this.Eos
        }
        P(t) {
            OG.zt(t),
            this.i3t = t,
            this.rFn = !0
        }
        $te() {
            return this.i3t
        }
        ZFn() {
            return this.rFn
        }
        S(t) {
            OG.zt(t),
            "form-controls" === t && (t = "html-elements"),
            this.CZs = t
        }
        RZs() {
            return this.CZs
        }
        B(t) {
            OG.zt(t),
            this.hFn = t
        }
        Ote() {
            return this.hFn
        }
        L(t) {
            OG.zt(t),
            this.qxe = self.app.Yse(t)
        }
        NA() {
            return this.qxe
        }
        Ei(t) {
            OG.zt(t),
            this.oFn = t
        }
        _F() {
            return this.oFn
        }
        CA(t, i) {
            OG.zt(t),
            OG.zt(i),
            this.Zxe = t,
            this.Qxe = i
        }
        sAe() {
            return this.Zxe
        }
        iAe() {
            return this.Qxe
        }
        Bi(t) {
            this.dJe = !!t
        }
        hit() {
            return this.dJe
        }
        Ui(t) {
            this.cFn = !!t
        }
        Gq() {
            return this.cFn
        }
        $i(t) {
            this.dFn = !!t
        }
        kie() {
            return this.dFn
        }
        Hi(t) {
            this.fFn = !!t
        }
        su() {
            return this.fFn
        }
        Yx(t) {
            OG.zt(t),
            this.pFn = t
        }
        QFn() {
            return this.pFn
        }
        VM(t) {
            OG.zt(t),
            this._Fn = t
        }
        tLn() {
            return this._Fn
        }
        vl(t) {
            this.TFn = !!t
        }
        bei() {
            return this.TFn
        }
        fw(t) {
            this.mFn = !!t
        }
        nu() {
            return this.mFn
        }
        ww(t) {
            if (OG._D(t),
            0 === t.length)
                throw new Error("expected non-empty array");
            this.mw = t
        }
        D0t() {
            return Array.isArray(this.mw)
        }
        jfs() {
            return this.mw
        }
        gM(t) {
            this.Ans = !!t
        }
        Rns() {
            return this.Ans
        }
        Oc(t) {
            this.wFn = !!t
        }
        ygs() {
            return this.wFn
        }
        $x(t) {
            this.Zze = !!t
        }
        UH() {
            return this.Zze
        }
        PM(t) {
            this.gFn = !!t
        }
        Zm() {
            return this.gFn
        }
        kr(t) {
            this.EZs = !!t
        }
        DZs() {
            return this.EZs
        }
        Ol(t) {
            this.yFn = !!t
        }
        iLn() {
            return this.yFn
        }
        Tl(t) {
            this.bFn = !!t
        }
        eLn() {
            return this.bFn
        }
        ni(t) {
            this.vFn = !!t
        }
        DF() {
            return this.vFn
        }
        Wi(t) {
            this.SFn = !!t
        }
        GN() {
            return this.SFn
        }
        ma(t) {
            this.MFn = !!t
        }
        HGs() {
            return this.MFn
        }
        Xi(t) {
            this.xFn = !!t
        }
        foe() {
            return this.xFn
        }
        Yi(t) {
            this.Wgn = !!t
        }
        no() {
            return this.Wgn
        }
        sLn(t) {
            this.EFn = !!t
        }
        uni() {
            return this.EFn
        }
        K(t) {
            this.CFn = !!t
        }
        Coe() {
            return this.CFn
        }
        qi() {
            this.IFn = !0
        }
        jri() {
            return this.IFn
        }
        Ji() {
            this.PFn = !0
        }
        Rri() {
            return this.PFn
        }
        Qi() {
            this.GFn = !0
        }
        nLn() {
            return this.GFn
        }
        Ki() {
            this.AFn = !0
        }
        Nri() {
            return this.AFn
        }
        Zi() {
            this.RFn = !0
        }
        Dri() {
            return this.RFn
        }
        Fr() {
            this.kFn = !0
        }
        Uri() {
            return this.kFn
        }
        zr() {
            this.OFn = !0
        }
        Vri() {
            return this.OFn
        }
        Er() {
            this.DFn = !0
        }
        Lri() {
            return this.DFn
        }
        Br(t) {
            this.NFn = t
        }
        rLn() {
            return this.NFn
        }
        ds() {
            this.FFn = !0
        }
        Bri() {
            return this.FFn
        }
        Ta() {
            this.LFn = !0
        }
        $ri() {
            return this.LFn
        }
        Pl() {
            this.BFn = !0
        }
        Jri() {
            return this.BFn
        }
        fs() {
            this.UFn = !0
        }
        Hri() {
            return this.UFn
        }
        O(t) {
            OG._D(t),
            OG.lw(this.pHs, t),
            this.jFn.clear();
            for (const t of this.pHs)
                this.jFn.set(t.vR(), t)
        }
        Aoe() {
            return this.pHs
        }
        qa(t) {
            return OG.zt(t),
            this.jFn.get(t) ?? null
        }
        oys(t) {
            return OG.zt(t),
            this.jFn.has(t)
        }
        Cr(t) {
            const i = OG.v(self.hLn, t);
            return this.$Fn.push(i),
            i
        }
        fxe() {
            return this.$Fn
        }
        oLn(t) {
            const i = OG.v(self.aLn, t);
            return this.zFn.push(i),
            i
        }
        lLn() {
            return this.zFn
        }
        vt(t) {
            this.VFn.push(OG.v(self.SEe, t))
        }
        Fri() {
            return this.VFn
        }
        pl(t, i="") {
            if (OG.zt(t),
            t.startsWith("http:"))
                throw new Error("cannot use insecure remote script dependency, use HTTPS");
            if (!LG.has(i))
                throw new Error("invalid type");
            this.WFn.push({
                url: t,
                type: i
            })
        }
        Sxe() {
            return this.WFn
        }
        uLn(t) {
            this.HFn = !!t
        }
        cLn() {
            return this.HFn
        }
        dLn(t, i) {
            if (OG.zt(t),
            !t)
                throw new Error("invalid component id");
            OG._D(i),
            this.KFn = t,
            this.qFn = i
        }
        Axe() {
            return {
                _xe: this.KFn,
                xxe: this.qFn
            }
        }
        fLn(t) {
            this.lFn = t.slice(0)
        }
        Ke(t) {
            OG.zt(t),
            this.lFn.push(t)
        }
        pLn() {
            const t = this.lFn.slice(0);
            return this.aFn && !t.includes(this.aFn) && t.push(this.aFn),
            t
        }
        mLn(t) {
            OG.zt(t),
            this.aFn = t
        }
        $_e() {
            return this.aFn
        }
        vr(t) {
            this.uFn = t.slice(0)
        }
        wLn() {
            return this.uFn
        }
        C(t) {
            OG.Yq(t),
            OG.Kq(t.M),
            OG.Kq(t.objectType),
            OG.Kq(t.bie),
            t.M && (this.XFn.M = t.M),
            t.objectType && (this.XFn.objectType = t.objectType),
            t.bie && (this.XFn.bie = t.bie)
        }
        EPs() {
            return this.XFn
        }
        T(t) {
            OG._D(t),
            this.YFn = t
        }
        CPs() {
            return this.YFn
        }
        za(t, i) {
            OG.zt(t),
            OG._D(i),
            this.JFn.set(t, i)
        }
        mIe(t) {
            return this.JFn.get(t)
        }
        I6s() {
            if (!this.phs)
                throw new Error("id can not be empty");
            if (!this.rVt)
                throw new Error("name can not be empty");
            if (this.rVt === OG.p.Fl)
                throw new Error(`failed to load addon name language string for addon '${this.phs}' - check the base key in the language file JSON is the lowercased plugin ID: "${this.phs.toLowerCase()}"`);
            if (!DG.has(this.CZs) && ("system" !== this.CZs || "system" !== this.phs))
                throw new Error(`invalid plugin category '${this.CZs}'`);
            if (!this.hFn)
                throw new Error("must specify author");
            if (!FG.has(this.oFn))
                throw new Error(`invalid plugin type '${this.oFn}'`);
            if (this.qxe && !this.qxe.startsWith("http://") && !this.qxe.startsWith("https://"))
                throw new Error("help URL must begin with http:// or https://");
            if ("world" === this.oFn && this.vFn)
                throw new Error("plugin type 'world' cannot also be single-global");
            if ("object" === this.oFn && this.SFn)
                throw new Error("plugin type 'object' cannot support effects");
            if (this.cFn) {
                if ("object" === this.oFn)
                    throw new Error("plugin type 'object' cannot also be rotatable");
                if (this.vFn)
                    throw new Error("single-global plugins cannot also be rotatable")
            }
            if (this.dJe) {
                if ("object" === this.oFn)
                    throw new Error("plugin type 'object' cannot also be resizable");
                if (this.vFn)
                    throw new Error("single-global plugins cannot also be resizable")
            }
            if (this.fFn) {
                if ("object" === this.oFn)
                    throw new Error("plugin type 'object' cannot have a texture");
                if (this.vFn)
                    throw new Error("single-global plugins cannot have a texture")
            } else if (this.pFn)
                throw new Error("cannot specify default image URL if not using image");
            if (this.mFn) {
                if ("object" === this.oFn)
                    throw new Error("plugin type 'object' cannot have animations");
                if (this.vFn)
                    throw new Error("single-global plugins cannot have animations")
            } else if (this.D0t())
                throw new Error("fixed animations mode requires animations");
            if (this.fFn && this.mFn)
                throw new Error("plugin cannot specify both texture and animations");
            if (this.Ans && !this.fFn && !this.mFn)
                throw new Error("plugin cannot be tiled if it doesn't use texture or animations");
            if ("object" === this.oFn && (this.IFn || this.PFn || this.GFn || this.AFn || this.RFn))
                throw new Error("plugin type 'object' cannot use common ACEs");
            OG.YJ(this.pHs, self.i);
            let t = new Set;
            for (let i of this.pHs) {
                let e = i.vR();
                if (t.has(e))
                    throw new Error(`duplicate plugin property ID '${e}'`);
                t.add(e)
            }
            if (!this.vFn && this.qFn.length > 0)
                throw new Error("wrapper export properties require plugin to be single-global");
            if (!this.qFn.every(i => t.has(i)))
                throw new Error("invalid wrapper export property id")
        }
    }
}
{
    const BG = self.t
      , UG = BG.ek(import.meta.url)
      , NG = BG.tk(UG.URL);
    BG.p.ik(NG + "lang"),
    BG.gLn = function(t, i) {
        BG.U(t, self._Qs),
        BG.U(i, self.si),
        BG.p.u("plugins._common"),
        t.VQs(!0);
        const e = self.app
          , s = e.oi("effect")
          , n = e.oi("instance-variable")
          , r = e.oi("layers")
          , h = e.oi("z-order")
          , o = e.oi("template")
          , a = i.rLn();
        let l;
        i.nLn() && (t.S("angle"),
        t.BQs({
            id: "is-within-angle",
            c2id: -11,
            scriptName: "AngleWithin",
            params: [{
                id: "within",
                type: "number",
                initialValue: .5
            }, {
                id: "angle",
                type: "number"
            }]
        }),
        t.BQs({
            id: "is-clockwise-from",
            c2id: -12,
            scriptName: "IsClockwiseFrom",
            params: [{
                id: "angle",
                type: "number"
            }]
        }),
        t.BQs({
            id: "is-between-angles",
            c2id: -13,
            scriptName: "IsBetweenAngles",
            params: [{
                id: "first-angle",
                type: "number"
            }, {
                id: "second-angle",
                type: "number",
                initialValue: 45
            }]
        }),
        t.$Qs({
            id: "set-angle",
            c2id: -8,
            scriptName: "SetAngle",
            params: [{
                id: "angle",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "rotate-clockwise",
            c2id: -18,
            scriptName: "RotateClockwise",
            params: [{
                id: "degrees",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "rotate-counter-clockwise",
            c2id: -19,
            scriptName: "RotateCounterclockwise",
            params: [{
                id: "degrees",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "rotate-toward-angle",
            c2id: -20,
            scriptName: "RotateTowardAngle",
            params: [{
                id: "degrees",
                type: "number"
            }, {
                id: "angle",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "rotate-toward-position",
            c2id: -21,
            scriptName: "RotateTowardPosition",
            params: [{
                id: "degrees",
                type: "number"
            }, {
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-angle-toward-position",
            c2id: -22,
            scriptName: "SetTowardPosition",
            params: [{
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }]
        }),
        t.HQs({
            id: "angle",
            c2id: -5,
            expressionName: "Angle",
            returnType: "number"
        })),
        i.Nri() && (t.S("appearance"),
        t.BQs({
            id: "is-visible",
            c2id: -9,
            scriptName: "IsVisible"
        }),
        t.BQs({
            id: "compare-opacity",
            c2id: -10,
            scriptName: "CompareOpacity",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "opacity",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-visible",
            c2id: -15,
            scriptName: "SetVisible",
            params: [{
                id: "visibility",
                type: "combo",
                items: ["invisible", "visible", "toggle"],
                initialValue: "visible"
            }]
        }),
        t.$Qs({
            id: "set-opacity",
            c2id: -16,
            scriptName: "SetOpacity",
            params: [{
                id: "opacity",
                type: "number",
                initialValue: 100
            }]
        }),
        i.foe() && (t.$Qs({
            id: "set-default-color",
            scriptName: "SetDefaultColor",
            params: [{
                id: "color",
                type: "number",
                initialValue: "rgbEx(0, 0, 0)"
            }]
        }),
        t.HQs({
            id: "color-value",
            expressionName: "ColorValue",
            returnType: "number"
        })),
        t.HQs({
            id: "opacity",
            c2id: -7,
            expressionName: "Opacity",
            returnType: "number"
        })),
        i.GN() && (t.S("appearance"),
        t.BQs({
            id: "is-effect-enabled",
            scriptName: "IsEffectEnabled",
            hideInSimplifiedMode: !0,
            params: [{
                id: "effect",
                type: "objecteffect"
            }]
        }).ai(s),
        t.$Qs({
            id: "set-effect-enabled",
            c2id: -27,
            scriptName: "SetEffectEnabled",
            hideInSimplifiedMode: !0,
            params: [{
                id: "mode",
                type: "combo",
                items: ["disable", "enable"]
            }, {
                id: "effect",
                type: "objecteffect"
            }]
        }).ai(s),
        t.$Qs({
            id: "set-effect-parameter",
            c2id: -28,
            scriptName: "SetEffectParam",
            hideInSimplifiedMode: !0,
            params: [{
                id: "effect",
                type: "objecteffect"
            }, {
                id: "parameter-index",
                type: "number"
            }, {
                id: "value",
                type: "number"
            }]
        }).ai(s)),
        i.DF() || (t.S("instance-variables"),
        t.BQs({
            id: "compare-instance-variable",
            c2id: -7,
            scriptName: "CompareInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "comparison",
                type: "cmp"
            }, {
                id: "value",
                type: "any"
            }]
        }).ai(n),
        t.BQs({
            id: "is-boolean-instance-variable-set",
            c2id: -8,
            scriptName: "IsBoolInstanceVarSet",
            params: [{
                id: "instance-variable",
                type: "instancevarbool"
            }]
        }).ai(n),
        t.BQs({
            id: "pick-highestlowest",
            c2id: -20,
            scriptName: "PickInstVarHiLow",
            params: [{
                id: "which",
                type: "combo",
                items: ["lowest", "highest"]
            }, {
                id: "instance-variable",
                type: "instancevar"
            }],
            isStatic: !0,
            isInvertible: !1
        }).ai(n),
        t.$Qs({
            id: "set-instvar-value",
            c2id: -10,
            scriptName: "SetInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "value",
                type: "any"
            }]
        }).ai(n),
        t.$Qs({
            id: "add-to-instvar",
            c2id: -11,
            scriptName: "AddInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "value",
                type: "any",
                initialValue: 1
            }]
        }).ai(n),
        t.$Qs({
            id: "subtract-from-instvar",
            c2id: -12,
            scriptName: "SubInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevar"
            }, {
                id: "value",
                type: "any",
                initialValue: 1
            }]
        }).ai(n),
        t.$Qs({
            id: "set-boolean-instvar",
            c2id: -13,
            scriptName: "SetBoolInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevarbool"
            }, {
                id: "value",
                type: "combo",
                items: ["false", "true"],
                initialValue: "true"
            }]
        }).ai(n),
        t.$Qs({
            id: "toggle-boolean-instvar",
            c2id: -14,
            scriptName: "ToggleBoolInstanceVar",
            params: [{
                id: "instance-variable",
                type: "instancevarbool"
            }]
        }).ai(n),
        t.S("misc"),
        t.BQs({
            id: "pick-by-unique-id",
            c2id: -14,
            scriptName: "PickByUID",
            hideInSimplifiedMode: !0,
            params: [{
                id: "unique-id",
                type: "number"
            }],
            isStatic: !0
        }),
        t.BQs({
            id: "has-tags",
            scriptName: "HasTags",
            params: [{
                id: "tags",
                type: "objectinsttags"
            }],
            hideInSimplifiedMode: !0
        }),
        t.BQs({
            id: "on-created",
            c2id: -18,
            scriptName: "OnCreated",
            isTrigger: !0
        }),
        t.BQs({
            id: "on-destroyed",
            c2id: -19,
            scriptName: "OnDestroyed",
            isTrigger: !0
        }),
        t.$Qs({
            id: "destroy",
            c2id: -9,
            scriptName: "Destroy"
        }),
        t.$Qs({
            id: "change-tags",
            params: [{
                id: "action",
                type: "combo",
                items: ["add", "remove"]
            }, {
                id: "tags",
                type: "objectinsttags"
            }],
            scriptName: "ChangeTags",
            hideInSimplifiedMode: !0
        }),
        t.HQs({
            id: "count",
            c2id: -6,
            expressionName: "Count",
            returnType: "number"
        }),
        t.HQs({
            id: "pickedcount",
            c2id: -14,
            expressionName: "PickedCount",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "uid",
            c2id: -9,
            expressionName: "UID",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "iid",
            c2id: -13,
            expressionName: "IID",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        "object" !== i._F() && (t.$Qs({
            id: "set-from-json",
            c2id: -30,
            scriptName: "LoadFromJsonString",
            hideInSimplifiedMode: !0,
            params: [{
                id: "json",
                type: "string"
            }]
        }),
        t.HQs({
            id: "asjson",
            c2id: -19,
            expressionName: "AsJSON",
            hideInSimplifiedMode: !0,
            returnType: "string"
        })),
        t.HQs({
            id: "objecttypename",
            expressionName: "ObjectTypeName",
            hideInSimplifiedMode: !0,
            returnType: "string"
        }),
        t.HQs({
            id: "get-tags",
            expressionName: "Tags",
            returnType: "string",
            hideInSimplifiedMode: !0
        }),
        t.HQs({
            id: "get-tags-count",
            expressionName: "TagsCount",
            returnType: "number",
            hideInSimplifiedMode: !0
        }),
        t.HQs({
            id: "get-tag-at",
            expressionName: "TagAt",
            returnType: "string",
            params: [{
                id: "index",
                type: "number"
            }],
            hideInSimplifiedMode: !0
        }),
        t.BQs({
            id: "on-instance-signal",
            scriptName: "OnInstanceSignal",
            isTrigger: !0,
            canDebug: !1,
            params: [{
                id: "tag",
                type: "string",
                autocompleteId: "instance-signal"
            }]
        }),
        t.$Qs({
            id: "instance-signal",
            scriptName: "InstanceSignal",
            params: [{
                id: "tag",
                type: "string",
                autocompleteId: "instance-signal"
            }]
        }),
        t.$Qs({
            id: "instance-wait-for-signal",
            scriptName: "InstanceWaitForSignal",
            isStatic: !0,
            canBailOut: !0,
            params: [{
                id: "tag",
                type: "string",
                autocompleteId: "instance-signal"
            }]
        })),
        i.jri() && (t.S("size-position"),
        t.BQs({
            id: "compare-x",
            c2id: -1,
            scriptName: "CompareX",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "x-co-ordinate",
                type: "number"
            }]
        }),
        t.BQs({
            id: "compare-y",
            c2id: -2,
            scriptName: "CompareY",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "y-co-ordinate",
                type: "number"
            }]
        }),
        t.BQs({
            id: "is-on-screen",
            c2id: -3,
            scriptName: "IsOnScreen"
        }),
        t.BQs({
            id: "is-outside-layout",
            c2id: -4,
            scriptName: "IsOutsideLayout"
        }),
        t.BQs({
            id: "pick-nearestfurthest",
            c2id: -15,
            scriptName: "PickDistance",
            params: [{
                id: "which",
                type: "combo",
                items: ["nearest", "furthest"]
            }, {
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }],
            isStatic: !0,
            isInvertible: !1
        }),
        t.$Qs({
            id: "set-x",
            c2id: -1,
            scriptName: "SetX",
            params: [{
                id: "x",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-y",
            c2id: -2,
            scriptName: "SetY",
            params: [{
                id: "y",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-position",
            c2id: -3,
            scriptName: "SetPos",
            params: [{
                id: "x",
                type: "number"
            }, {
                id: "y",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-position-to-another-object",
            c2id: -4,
            scriptName: "SetPosToObject",
            params: [{
                id: "object",
                type: "object"
            }, {
                id: "image-point-optional",
                type: "any"
            }]
        }),
        i.nLn() && t.$Qs({
            id: "move-forward",
            c2id: -17,
            scriptName: "MoveForward",
            params: [{
                id: "distance",
                type: "number",
                initialValue: 1
            }]
        }),
        t.$Qs({
            id: "move-at-angle",
            c2id: -23,
            scriptName: "MoveAtAngle",
            params: [{
                id: "angle",
                type: "number"
            }, {
                id: "distance",
                type: "number",
                initialValue: 1
            }]
        }),
        t.HQs({
            id: "x",
            c2id: -1,
            expressionName: "X",
            returnType: "number"
        }),
        t.HQs({
            id: "y",
            c2id: -2,
            expressionName: "Y",
            returnType: "number"
        }),
        t.S("time"),
        t.HQs({
            id: "dt",
            c2id: -8,
            expressionName: "dt",
            returnType: "number"
        })),
        i.Rri() && (t.S("size-position"),
        t.BQs({
            id: "compare-width",
            c2id: -5,
            scriptName: "CompareWidth",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "width",
                type: "number"
            }]
        }),
        t.BQs({
            id: "compare-height",
            c2id: -6,
            scriptName: "CompareHeight",
            params: [{
                id: "comparison",
                type: "cmp"
            }, {
                id: "height",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-width",
            c2id: -5,
            scriptName: "SetWidth",
            params: [{
                id: "width",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-height",
            c2id: -6,
            scriptName: "SetHeight",
            params: [{
                id: "height",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-size",
            c2id: -7,
            scriptName: "SetSize",
            params: [{
                id: "width",
                type: "number"
            }, {
                id: "height",
                type: "number"
            }]
        }),
        t.HQs({
            id: "width",
            c2id: -3,
            expressionName: "Width",
            returnType: "number"
        }),
        t.HQs({
            id: "height",
            c2id: -4,
            expressionName: "Height",
            returnType: "number"
        }),
        t.HQs({
            id: "bboxleft",
            c2id: -15,
            expressionName: "BBoxLeft",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "bboxtop",
            c2id: -16,
            expressionName: "BBoxTop",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "bboxright",
            c2id: -17,
            expressionName: "BBoxRight",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "bboxbottom",
            c2id: -18,
            expressionName: "BBoxBottom",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "bboxmidx",
            expressionName: "BBoxMidX",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "bboxmidy",
            expressionName: "BBoxMidY",
            hideInSimplifiedMode: !0,
            returnType: "number"
        })),
        i.Dri() && (t.S("z-order"),
        t.BQs({
            id: "is-on-layer",
            c2id: -16,
            scriptName: "IsOnLayer",
            params: [{
                id: "layer",
                type: "layer"
            }]
        }).ai(r),
        t.BQs({
            id: "pick-topbottom",
            c2id: -17,
            scriptName: "PickTopBottom",
            params: [{
                id: "which",
                type: "combo",
                items: ["top", "bottom"]
            }],
            isStatic: !0
        }).ai(h),
        t.$Qs({
            id: "move-to-top",
            c2id: -24,
            scriptName: "MoveToTop"
        }).ai(h),
        t.$Qs({
            id: "move-to-bottom",
            c2id: -25,
            scriptName: "MoveToBottom"
        }).ai(h),
        t.$Qs({
            id: "move-to-layer",
            c2id: -26,
            scriptName: "MoveToLayer",
            params: [{
                id: "layer",
                type: "layer"
            }]
        }).ai(r),
        t.$Qs({
            id: "move-to-object",
            c2id: -29,
            scriptName: "ZMoveToObject",
            params: [{
                id: "where",
                type: "combo",
                items: ["in-front", "behind"]
            }, {
                id: "object",
                type: "object"
            }]
        }).ai(h),
        t.HQs({
            id: "layernumber",
            c2id: -10,
            expressionName: "LayerNumber",
            returnType: "number"
        }).ai(r),
        t.HQs({
            id: "layername",
            c2id: -11,
            expressionName: "LayerName",
            returnType: "string"
        }).ai(r),
        t.HQs({
            id: "zindex",
            c2id: -12,
            expressionName: "ZIndex",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }).ai(h),
        i.kie() && (t.BQs({
            id: "compare-z-elevation",
            scriptName: "CompareZElevation",
            hideInSimplifiedMode: !0,
            params: [{
                id: "which",
                type: "combo",
                items: ["z-elevation", "total-z-elevation"]
            }, {
                id: "comparison",
                type: "cmp"
            }, {
                id: "z-elevation",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-z-elevation",
            scriptName: "SetZElevation",
            hideInSimplifiedMode: !0,
            params: [{
                id: "z",
                type: "number"
            }]
        }),
        t.HQs({
            id: "z-elevation",
            expressionName: "ZElevation",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "total-z-elevation",
            expressionName: "TotalZElevation",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }))),
        i.Jri() && (t.S("collisions"),
        t.BQs({
            id: "on-collision-with-another-object",
            c2id: 0,
            scriptName: "OnCollision",
            params: [{
                id: "object",
                type: "object"
            }],
            isFakeTrigger: !0,
            canDebug: !0,
            isStatic: !0,
            highlight: !0
        }),
        t.BQs({
            id: "is-overlapping-another-object",
            c2id: 1,
            scriptName: "IsOverlapping",
            params: [{
                id: "object",
                type: "object"
            }]
        }),
        t.BQs({
            id: "is-overlapping-at-offset",
            c2id: 9,
            scriptName: "IsOverlappingOffset",
            hideInSimplifiedMode: !0,
            params: [{
                id: "object",
                type: "object"
            }, {
                id: "offset-x",
                type: "number"
            }, {
                id: "offset-y",
                type: "number"
            }]
        })),
        i.Bri() && (t.S("hierarchy"),
        t.BQs({
            id: "on-hierarchy-ready",
            scriptName: "OnHierarchyReady",
            isTrigger: !0
        }),
        t.BQs({
            id: "has-parent",
            scriptName: "HasParent",
            hideInSimplifiedMode: !0
        }),
        t.BQs({
            id: "has-children",
            scriptName: "HasChildren",
            hideInSimplifiedMode: !0
        }),
        t.BQs({
            id: "pick-parent",
            scriptName: "PickParent",
            isStatic: !0,
            isInvertible: !1,
            hideInSimplifiedMode: !0,
            params: [{
                id: "parent",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "which",
                type: "combo",
                items: ["own", "all", "top"]
            }]
        }),
        t.BQs({
            id: "pick-children",
            scriptName: "PickChildren",
            isStatic: !0,
            isInvertible: !1,
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "which",
                type: "combo",
                items: ["own", "all", "bottom"]
            }]
        }),
        t.BQs({
            id: "pick-nth-child",
            scriptName: "PickNthChild",
            isStatic: !0,
            isInvertible: !1,
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "index-type",
                type: "combo",
                items: ["all", "filtered"]
            }, {
                id: "instance",
                type: "number"
            }]
        }),
        t.BQs({
            id: "compare-child-count",
            scriptName: "CompareChildCount",
            hideInSimplifiedMode: !0,
            params: [{
                id: "which",
                type: "combo",
                items: ["own", "all"]
            }, {
                id: "comparison",
                type: "cmp"
            }, {
                id: "count",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "add-child",
            scriptName: "AddChild",
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }, {
                id: "transform-x",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-y",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-w",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-h",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-a",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-o",
                type: "boolean",
                initialValue: "false"
            }, {
                id: "transform-z-elevation",
                type: "boolean",
                initialValue: "true"
            }, {
                id: "transform-visibility",
                type: "boolean",
                initialValue: "false"
            }, {
                id: "destroy-with-parent",
                type: "boolean"
            }]
        }),
        t.$Qs({
            id: "remove-child",
            scriptName: "RemoveChild",
            hideInSimplifiedMode: !0,
            params: [{
                id: "child",
                type: "object",
                allowedPluginIds: ["<scene-graph>"]
            }]
        }),
        t.$Qs({
            id: "remove-from-parent",
            scriptName: "RemoveFromParent",
            hideInSimplifiedMode: !0
        }),
        t.HQs({
            id: "parent-uid",
            expressionName: "ParentUID",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "child-count",
            expressionName: "ChildCount",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "all-child-count",
            expressionName: "AllChildCount",
            hideInSimplifiedMode: !0,
            returnType: "number"
        })),
        i.$ri() && (t.S("mesh"),
        t.$Qs({
            id: "set-mesh-size",
            scriptName: "SetMeshSize",
            hideInSimplifiedMode: !0,
            params: [{
                id: "cols",
                type: "number"
            }, {
                id: "rows",
                type: "number"
            }]
        }),
        t.$Qs({
            id: "set-mesh-point",
            scriptName: "SetMeshPoint",
            hideInSimplifiedMode: !0,
            params: [{
                id: "col",
                type: "number"
            }, {
                id: "row",
                type: "number"
            }, {
                id: "mode",
                type: "combo",
                items: ["absolute", "relative"]
            }, {
                id: "posx",
                type: "number"
            }, {
                id: "posy",
                type: "number"
            }, {
                id: "z-elevation",
                type: "number"
            }, {
                id: "texx",
                type: "number",
                initialValue: "-1"
            }, {
                id: "texy",
                type: "number",
                initialValue: "-1"
            }]
        }),
        t.HQs({
            id: "mesh-columns",
            expressionName: "MeshColumns",
            hideInSimplifiedMode: !0,
            returnType: "number"
        }),
        t.HQs({
            id: "mesh-rows",
            expressionName: "MeshRows",
            hideInSimplifiedMode: !0,
            returnType: "number"
        })),
        i.Uri() && (t.S("html-element"),
        t.BQs({
            id: "is-visible",
            scriptName: "IsVisible"
        }),
        l = {
            id: "set-visible",
            scriptName: "SetVisible",
            params: [{
                id: "visibility",
                type: "combo",
                items: ["invisible", "visible", "toggle"]
            }]
        },
        a.hasOwnProperty("set-visible") && (l.c2id = a["set-visible"]),
        t.$Qs(l),
        l = {
            id: "set-css-style",
            scriptName: "SetCSSStyle",
            hideInSimplifiedMode: !0,
            params: [{
                id: "property-name",
                type: "string",
                initialValue: '"border"'
            }, {
                id: "value",
                type: "string",
                initialValue: '"1px solid red"'
            }]
        },
        a.hasOwnProperty("set-css-style") && (l.c2id = a["set-css-style"]),
        t.$Qs(l),
        t.$Qs({
            id: "set-elem-attribute",
            scriptName: "SetElemAttribute",
            hideInSimplifiedMode: !0,
            params: [{
                id: "attribute-name",
                type: "string"
            }, {
                id: "attribute-value",
                type: "any",
                initialValue: '""'
            }]
        }),
        t.$Qs({
            id: "remove-elem-attribute",
            scriptName: "RemoveElemAttribute",
            hideInSimplifiedMode: !0,
            params: [{
                id: "attribute-name",
                type: "string"
            }]
        })),
        i.Vri() && (t.S("html-element"),
        t.BQs({
            id: "is-focused",
            scriptName: "IsFocused"
        }),
        l = {
            id: "set-focused",
            scriptName: "SetFocus",
            hideInSimplifiedMode: !0
        },
        a.hasOwnProperty("set-focused") && (l.c2id = a["set-focused"]),
        t.$Qs(l),
        l = {
            id: "set-unfocused",
            scriptName: "SetBlur",
            hideInSimplifiedMode: !0
        },
        a.hasOwnProperty("set-unfocused") && (l.c2id = a["set-unfocused"]),
        t.$Qs(l)),
        i.Lri() && (t.S("html-element"),
        t.BQs({
            id: "is-enabled",
            scriptName: "IsEnabled"
        }),
        l = {
            id: "set-enabled",
            scriptName: "SetEnabled",
            params: [{
                id: "mode",
                type: "combo",
                items: ["disabled", "enabled"]
            }]
        },
        a.hasOwnProperty("set-enabled") && (l.c2id = a["set-enabled"]),
        t.$Qs(l)),
        i.Hri() && (t.S("template"),
        t.HQs({
            id: "template-name",
            expressionName: "TemplateName",
            returnType: "string"
        }).ai(o)),
        BG.p.j(),
        t.VQs(!1)
    }
}
{
    const jG = self.t
      , $G = self.i
      , zG = self.Uze
      , VG = (new Set(["default", "npm", "pgb"]),
    new Set(["all", "android", "ios", "windows"]))
      , WG = {
        id: "",
        version: "",
        platform: "all"
    };
    class HG {
        constructor(t, i) {
            jG.zt(t),
            jG.zt(i),
            this.rVt = t,
            this.LIs = i
        }
        yLn() {
            return ""
        }
        Dhe() {
            return ""
        }
        Ft(t) {
            return this.LIs
        }
        Fa() {
            return this.rVt
        }
        jnn() {
            return !0
        }
        i8s(t) {
            return jG.U(t, self.gh),
            [this.Fa(), this.Ft(t)]
        }
    }
    class KG extends HG {
        constructor(t, i, e) {
            jG.U(e, $G),
            jG.U(t, jG.ii),
            super(i, ""),
            this.nUs = e,
            this.hi = t,
            this.bLn = !1
        }
        yLn() {
            return this.hi.Ja().Fa()
        }
        Dhe() {
            return this.nUs.Fa()
        }
        vLn() {
            this.bLn = !0
        }
        jnn() {
            return !this.bLn
        }
        Ft(t) {
            return t.Zei(this.hi).Rs(this.nUs.vR())
        }
    }
    class qG extends HG {
        constructor(t, i, e, s) {
            super(e, s),
            this.hi = t,
            this.SLn = i
        }
        yLn() {
            return this.hi.Ja().Fa()
        }
        I_e() {
            return this.SLn.I_e()
        }
        i8s(t) {
            return jG.U(t, self.gh),
            [this.Fa(), this.Ft(t), this.I_e()]
        }
    }
    window.hLn = class extends jG.Me {
        constructor(t) {
            if (super(),
            t = Object.assign({}, WG, t),
            jG.zt(t.id),
            jG.zt(t.version),
            jG.zt(t.platform),
            jG.zAt(t.xLn),
            !t.id)
                throw new Error("id cannot be empty");
            if (!VG.has(t.platform))
                throw new Error("invalid platform");
            let i = t.bie;
            if (i instanceof window.SDK.IPluginBase && (i = t.bie.MLn()),
            jG.Mw(i, jG.ii),
            this.phs = t.id,
            this.i3t = t.version,
            this.ELn = t.platform,
            this.CLn = [],
            this._Ln = [],
            t.xLn)
                for (const e of t.xLn) {
                    jG._D(e);
                    let[t,s] = e;
                    s instanceof window.SDK.PluginProperty && (s = $G.iFn(s)),
                    this.Mr(i, t, s)
                }
        }
        Njt() {
            return this.phs
        }
        $te() {
            return this.i3t
        }
        YMt() {
            return this.SLt
        }
        I_e() {
            return this.ELn
        }
        TLn(t) {
            if (jG.U(t, self.gh),
            this.CLn.length > 0) {
                const i = [];
                for (const e of this.CLn) {
                    const s = e.i8s(t);
                    if (e.jnn()) {
                        const t = s[1].toString();
                        if (!("" !== t.trim() || t && jG.dBe(t)))
                            return zG.Lze(self.tP("ui.export.cordova-variable-required", e.Dhe(), e.yLn()))
                    }
                    i.push(s)
                }
                return zG.Ok(i)
            }
            return zG.Ok(null)
        }
        ILn(t) {
            if (jG.U(t, self.gh),
            this._Ln.length > 0) {
                const i = [];
                for (const e of this._Ln)
                    i.push(e.i8s(t));
                return zG.Ok(i)
            }
            return zG.Ok(null)
        }
        Mr(t, i, e) {
            jG.U(t, jG.ii),
            jG.U(e, $G),
            jG.zt(i);
            const s = jG.v(KG, t, i, e);
            return this.CLn.push(s),
            s
        }
        Ir(t, i, e) {
            jG.U(t, jG.ii),
            jG.zt(i),
            jG.zt(e);
            const s = jG.v(qG, t, this, i, e);
            return this._Ln.push(s),
            s
        }
        PLn(t, i) {
            jG.zt(t),
            jG.zt(i);
            const e = jG.v(HG, t, i);
            return this.CLn.push(e),
            e
        }
        Ja() {
            return this.hi
        }
    }
}
{
    const XG = self.t
      , YG = new Set(["all", "android", "ios"])
      , JG = {
        src: "",
        target: "",
        platform: "all"
    };
    window.aLn = class extends XG.Me {
        constructor(t) {
            if (super(),
            t = Object.assign({}, JG, t),
            XG.zt(t.src),
            XG.zt(t.target),
            XG.zt(t.platform),
            !YG.has(t.platform))
                throw new Error("invalid platform");
            this.GLn = t.src,
            this.bui = t.target,
            this.ELn = t.platform
        }
        ALn() {
            return this.GLn
        }
        RLn() {
            return this.bui
        }
        I_e() {
            return this.ELn
        }
    }
}
{
    const ZG = self.t
      , QG = new Set(["copy-to-output", "external-script", "external-dom-script", "external-runtime-script", "external-css", "wrapper-extension"])
      , tA = new Set(["", "module"])
      , iA = {
        filename: "",
        Vt: "",
        kLn: "",
        type: "copy-to-output",
        platform: "all"
    };
    window.SEe = class extends ZG.Me {
        constructor(t) {
            if (super(),
            t = Object.assign({}, iA, t),
            ZG.zt(t.filename),
            ZG.Kq(t.Vt),
            ZG.Kq(t.kLn),
            ZG.zt(t.type),
            ZG.zt(t.platform),
            !t.filename)
                throw new Error("filename cannot be empty");
            if (!tA.has(t.kLn))
                throw new Error("invalid script type");
            if (!QG.has(t.type))
                throw new Error("invalid dependency type");
            if (!t.platform)
                throw new Error("platform cannot be empty");
            if (this.Oxs = t.filename,
            this.OLn = t.Vt,
            this.DLn = t.kLn,
            this.lVt = t.type,
            this.ELn = t.platform,
            "external-script" === this.lVt && (this.lVt = "external-dom-script"),
            !this.OLn)
                if (this.lVt.endsWith("-script"))
                    this.OLn = "application/javascript";
                else if ("external-css" === this.lVt)
                    this.OLn = "text/css";
                else {
                    if ("wrapper-extension" !== this.lVt)
                        throw new Error(`file dependency '${this.Oxs}' must specify a fileType`);
                    this.OLn = "application/octet-stream"
                }
        }
        dh() {
            return this.Oxs
        }
        FLn() {
            return this.OLn
        }
        j_e() {
            return this.DLn
        }
        Vdt() {
            return this.lVt
        }
        I_e() {
            return this.ELn
        }
    }
}
{
    const eA = self.t
      , sA = "#00768E"
      , nA = new Set(["CORDOVAIAP", "IAP", "Multiplayer", "admob", "advert", "pubcenter", "iad", "XboxLive", "InstantGames"]);
    window.Plugin = class extends globalThis.GDn {
        constructor(t, i) {
            eA.U(t, eA.ii),
            super(),
            this.Gpn = t,
            this.m = this.Gpn.GetInfo(),
            this.LLn = eA.v(self._Qs),
            this.SLt = i.source,
            this.lFn = new Map,
            this.BLn = null,
            this.Xus = null,
            this.Yus = null,
            this.qus = null,
            this.ULn = null,
            this.NLn = null,
            this.jLn = null,
            this.$Ln = null,
            this.m.I6s(),
            this.Gpn.kDn(this),
            i.zLn && (this.BLn = eA.v(eA.qs.pAe, self.app, null, {
                name: "plugin-" + this.vR(),
                color: sA,
                A6e: i.zLn
            }))
        }
        he() {
            this.Gpn.he(),
            this.Gpn = null,
            this.m = null,
            this.LLn.he(),
            this.LLn = null,
            this.lFn.clear()
        }
        VLn(t) {
            eA.Yq(t),
            eA.gLn(this.LLn, this.m),
            eA.p.u("plugins." + this.vR().toLowerCase());
            const i = !!this.m.DZs();
            i && eA.p.Vr(!1);
            for (let[i,e] of Object.entries(t)) {
                if ("$schema" === i)
                    continue;
                this.LLn.S(i);
                let t = e.conditions
                  , s = e.actions
                  , n = e.expressions;
                if (t)
                    for (let i of t)
                        this.LLn.BQs(i);
                if (s)
                    for (let t of s)
                        this.LLn.$Qs(t);
                if (n)
                    for (let t of n)
                        this.LLn.HQs(t)
            }
            i && eA.p.Vr(!0),
            this.LLn.LQs(),
            eA.p.j(),
            this.Gpn.ri(),
            this.WLn()
        }
        WLn() {
            const t = []
              , i = []
              , e = [];
            this.Bri() && (t.push(["has-parent", "scene-graph"], ["has-children", "scene-graph"], ["pick-parent", "scene-graph"], ["pick-children", "scene-graph"], ["pick-nth-child", "scene-graph"], ["compare-child-count", "scene-graph"]),
            i.push(["add-child", "scene-graph"], ["remove-child", "scene-graph"], ["remove-from-parent", "scene-graph"]),
            e.push(["parent-uid", "scene-graph"], ["child-count", "scene-graph"], ["all-child-count", "scene-graph"])),
            this.$ri() && (i.push(["set-mesh-size", "mesh"], ["set-mesh-point", "mesh"]),
            e.push(["mesh-columns", "mesh"], ["mesh-rows", "mesh"]));
            const s = self.app;
            for (const [i,e] of t)
                this.li(i).ai(s.oi(e));
            for (const [t,e] of i)
                this.ci(t).ai(s.oi(e));
            for (const [t,i] of e)
                this.ui(t).ai(s.oi(i))
        }
        vR() {
            return this.m.Njt()
        }
        Vdt() {
            return "plugin"
        }
        Fa() {
            return this.m.Fa()
        }
        dj() {
            return this.m.dj()
        }
        $te() {
            return this.m.$te()
        }
        kPs() {
            return 1
        }
        RZs() {
            return this.m.RZs()
        }
        Ote() {
            return this.m.Ote()
        }
        NA() {
            return this.m.NA()
        }
        YMt() {
            return this.SLt
        }
        _F() {
            return this.m._F()
        }
        Gq() {
            return this.m.Gq()
        }
        hit() {
            return this.m.hit()
        }
        DF() {
            return this.m.DF()
        }
        kie() {
            return this.m.kie()
        }
        bei() {
            return this.m.bei()
        }
        Sbs() {
            return "html-elements" === this.RZs()
        }
        su() {
            return this.m.su()
        }
        Dfs() {
            return null
        }
        Tfs() {
            return Promise.resolve([])
        }
        nu() {
            return this.m.nu()
        }
        D0t() {
            return this.m.D0t()
        }
        jfs() {
            return this.m.jfs()
        }
        Rns() {
            return this.m.Rns()
        }
        ygs() {
            return this.m.ygs()
        }
        UH() {
            return this.m.UH()
        }
        Zm() {
            return this.m.Zm()
        }
        DZs() {
            return this.m.DZs()
        }
        HLn() {
            this.m.kr(!0)
        }
        iLn() {
            return this.m.iLn()
        }
        eLn() {
            return this.m.eLn()
        }
        Vpt() {
            return this.DZs() || this.eLn() && !self.app.KLn()
        }
        GN() {
            return this.m.GN()
        }
        HGs() {
            return this.m.HGs()
        }
        foe() {
            return this.m.foe()
        }
        no() {
            return this.m.no()
        }
        VN() {
            return !this.DF()
        }
        $N() {
            return !this.DF() && "world" === this._F()
        }
        Hds() {
            return "object" === this._F() && !this.DF()
        }
        jri() {
            return this.m.jri()
        }
        Rri() {
            return this.m.Rri()
        }
        nLn() {
            return this.m.nLn()
        }
        Nri() {
            return this.m.Nri()
        }
        Dri() {
            return this.m.Dri()
        }
        Uri() {
            return this.m.Uri()
        }
        Vri() {
            return this.m.Vri()
        }
        Lri() {
            return this.m.Lri()
        }
        Bri() {
            return this.m.Bri()
        }
        _X() {
            return this.Bri()
        }
        $ri() {
            return this.m.$ri()
        }
        YX() {
            return this.$ri()
        }
        Jri() {
            return this.m.Jri()
        }
        Hri() {
            return this.m.Hri()
        }
        Aoe() {
            return this.m.Aoe()
        }
        qa(t) {
            eA.zt(t);
            const i = this.m.qa(t);
            if (!i)
                throw new Error(`plugin property id '${t}' not found`);
            return i
        }
        oys(t) {
            return eA.zt(t),
            this.m.oys(t)
        }
        fxe() {
            return this.m.fxe()
        }
        lLn() {
            return this.m.lLn()
        }
        qLn() {
            return this.m.cLn()
        }
        Axe() {
            return this.m.Axe()
        }
        gk() {
            return this.Gpn
        }
        XLn() {
            return `plugins/${this.vR()}/`
        }
        YLn() {
            return eA.Ars.cPs() + this.XLn()
        }
        B_e() {
            return !!this.$_e()
        }
        $_e() {
            return this.m.$_e()
        }
        async M_e(t, i) {
            eA.E4()
        }
        async R_e(t, i, e) {
            eA.E4()
        }
        Fri() {
            return this.m.Fri()
        }
        Sxe() {
            return this.m.Sxe()
        }
        EPs() {
            return this.m.EPs()
        }
        CPs() {
            return this.m.CPs()
        }
        uni() {
            return this.m.uni() && "dev" !== this.YMt()
        }
        Coe() {
            return this.m.Coe()
        }
        emn() {
            eA.E4()
        }
        iAe() {
            return this.m.iAe()
        }
        JLn() {
            return "image/svg+xml" === this.iAe()
        }
        ZLn() {
            !this.BLn && this.JLn() && (this.BLn = eA.v(eA.qs.pAe, self.app, this.emn(), {
                name: "plugin-" + this.vR(),
                color: sA
            }))
        }
        lg() {
            if (this.ZLn(),
            !this.BLn)
                throw new Error("no svg icon");
            return this.BLn.yAs()
        }
        xA() {
            return this.Xus || (this.ZLn(),
            this.BLn ? this.Xus = this.BLn.xA() : this.Xus = eA.qs.O_.mAe(this.emn(), self.app.T_(), {
                og: this.JLn()
            })),
            this.Xus
        }
        uj() {
            return this.Yus || (this.ZLn(),
            this.BLn ? this.Yus = this.BLn.uj() : this.Yus = eA.qs.O_.mAe(this.emn(), self.app.Gk(), {
                og: this.JLn()
            })),
            this.Yus
        }
        nus() {
            return this.qus || (this.ZLn(),
            this.BLn ? this.qus = this.BLn.nus() : this.qus = eA.qs.O_.mAe(this.emn(), self.app.BJt(), {
                og: this.JLn()
            })),
            this.qus
        }
        Igs(t) {
            switch (eA.zt(t),
            t) {
            case "small":
                return this.xA();
            case "medium":
                return this.uj();
            case "large":
                return this.nus();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        pps() {
            return this.ULn || (this.ULn = eA.qs.O_.y_(null, self.app.T_(), {
                name: this.vR() + "-family"
            }),
            this.ULn.U_(),
            this.ULn.P_([this.xA(), {
                icon: self.app.oi("family-overlay-mask"),
                type: "mask"
            }, self.app.oi("family-overlay")])),
            this.ULn
        }
        mps() {
            return this.NLn || (this.NLn = eA.qs.O_.y_(null, self.app.Gk(), {
                name: this.vR() + "-family"
            }),
            this.NLn.U_(),
            this.NLn.P_([this.uj(), {
                icon: self.app.Tk("family-overlay-mask"),
                type: "mask"
            }, self.app.Tk("family-overlay")])),
            this.NLn
        }
        wps() {
            return this.jLn || (this.jLn = eA.qs.O_.y_(null, self.app.BJt(), {
                name: this.vR() + "-family"
            }),
            this.jLn.U_(),
            this.jLn.P_([this.nus(), {
                icon: self.app.bds("family-overlay-mask"),
                type: "mask"
            }, self.app.bds("family-overlay")])),
            this.jLn
        }
        mIe(t) {
            return this.m.mIe(t)
        }
        li(t) {
            return eA.zt(t),
            this.LLn.li(t)
        }
        Iqs(t) {
            return eA.Ge(t),
            this.LLn.Iqs(t)
        }
        HDt() {
            return this.LLn.HDt()
        }
        OGt() {
            return this.LLn.OGt()
        }
        JQs(t) {
            return this.LLn.JQs(t)
        }
        ci(t) {
            return eA.zt(t),
            this.LLn.ci(t)
        }
        jqs(t) {
            return eA.Ge(t),
            this.LLn.jqs(t)
        }
        actions() {
            return this.LLn.actions()
        }
        Hyt() {
            return this.LLn.Hyt()
        }
        ui(t) {
            return eA.zt(t),
            this.LLn.ui(t)
        }
        zQs(t) {
            return eA.Ge(t),
            this.LLn.zQs(t)
        }
        ki(t) {
            return eA.zt(t),
            this.LLn.ki(t)
        }
        Gos(t) {
            return eA.zt(t),
            !!this.ki(t)
        }
        WQs() {
            return this.LLn.WQs()
        }
        KQs() {
            return this.LLn.KQs()
        }
        VIe(t) {
            if (eA.zt(t),
            "conditions" === t)
                return this.HDt();
            if ("actions" === t)
                return this.actions();
            if ("expressions" === t)
                return this.WQs();
            throw new Error("invalid ace type")
        }
        ZA(t, i) {
            if (eA.U(t, self.gh),
            eA.Kq(i),
            this.DF() && t.pR().has(this))
                throw new Error("single-global plugin already in project");
            if (i) {
                if (i = self.EF.lQ(i, !0),
                t.wR(i))
                    throw new Error(`object type name '${i}' already used`)
            } else
                i = t.YA(this.Fa());
            let e = eA.v(self.aF, t, this, i);
            return e.Js = this.Gpn.ZA(e),
            this.DF() && e.pfs(),
            this.bei() || "worker" !== t.xse() || t.Aii("auto"),
            e
        }
        Ome() {
            return !nA.has(this.vR())
        }
        async nh(t) {
            return await this.Gpn.nh(t)
        }
        static Ame(t, i) {
            const e = (eA.Ots(t) ? t.QLn : t.Fa()).toLowerCase()
              , s = (eA.Ots(i) ? i.QLn : i.Fa()).toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const rA = self.t
      , hA = ["c3runtime/plugin.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"];
    window.tBn = class extends self.Plugin {
        constructor(t, i) {
            if (rA.U(t, rA.ii),
            super(t, i),
            rA.jii()) {
                const t = this.m.pLn();
                rA.spt(t, new Set(hA)),
                t.unshift("c3runtime/runtime.js"),
                this.m.fLn(t)
            }
            this.Kdt = "",
            i.path && (this.Kdt = new URL(i.path,rA.sh()).toString(),
            t.Ql(this.Kdt)),
            this.$Ln = null;
            const e = this.m.QFn();
            if (this.m.su() && e && rA.Kl(e).then(t => this.$Ln = t).catch(t => console.error("Error loading default image: ", t)),
            this.m.D0t())
                for (const t of this.m.jfs())
                    rA.Kl(t.gw).then(i => t.Rfs = i).catch(t => console.error("Error loading default image: ", t));
            this.iBn = null;
            const s = this.m.tLn();
            s && (this.iBn = rA.Z1t(s).catch(t => console.error("Error loading default data: ", t)))
        }
        he() {
            this.$Ln = null,
            this.iBn = null,
            super.he()
        }
        Dfs() {
            return this.$Ln
        }
        Tfs() {
            return this.iBn ? this.iBn : super.Tfs()
        }
        cxe() {
            return this.m.pLn().map(t => this.Kdt + t)
        }
        async F_e(t, i, e, s) {
            return await Promise.all(e.map(async e => {
                if ("preview" === t)
                    return this.Kdt + e;
                {
                    const t = this.YLn() + e
                      , n = this.XLn() + e;
                    i.set(t, null);
                    const r = await this.eBn(e);
                    return i.set(t, r),
                    s ? t : n
                }
            }
            ))
        }
        async M_e(t, i) {
            return await this.F_e(t, i, this.m.wLn(), !0)
        }
        async R_e(t, i, e) {
            return await this.F_e(t, i, this.m.pLn(), !1)
        }
        async eBn(t) {
            rA.zt(t);
            const i = this.lFn.get(t);
            if (i)
                return i;
            const e = await fetch(this.Kdt + t)
              , s = await e.text();
            return this.lFn.set(t, s),
            s
        }
        emn() {
            return this.Kdt + this.m.sAe()
        }
        zrt() {
            return this.Kdt
        }
        sBn(t) {
            return this.Kdt + t
        }
        IPs(t) {
            return this.sBn(t)
        }
        $te() {
            return rA.o_.Lhi
        }
    }
}
{
    const oA = self.t
      , aA = new Set([1, 2]);
    window.ani = class extends self.Plugin {
        constructor(t, i) {
            t instanceof window.SDK.IPluginBase && (t = t.MLn()),
            oA.U(t, oA.ii),
            super(t, i);
            const e = i.nBn;
            if (this.N2t = i.files,
            this.rBn = new Map,
            this.hBn = i.nBn["sdk-version"] ?? 1,
            1 === this.hBn)
                throw new Error(`instantiating SDKv1 addon '${this.vR()}'`);
            if (!aA.has(this.hBn))
                throw new Error(`addon ID '${this.vR()}' specifies invalid SDK version ${this.hBn}`);
            this.m.ZFn() && (() => {})(`[Addon SDK] Addon ID '${this.vR()}' called SetVersion(). This is ignored in the Addon SDK v2 and the version set in addon.json is used instead. Remove the call to SetVersion() to clear this warning.`),
            this.m.P(e.version),
            this.m.vl(e["supports-worker-mode"] ?? !0),
            this.m.$_e() || this.oBn(),
            this.aBn = i.lBn,
            this.$Ln = null;
            const s = this.m.QFn();
            this.m.su() && s && (this.$Ln = this.oxe(s))
        }
        VLn(t) {
            super.VLn(t);
            for (const t of [...this.HDt(), ...this.actions()])
                if (!t.jZs())
                    for (const i of t.parameters())
                        if (!i.lZs())
                            throw new Error(`Addon '${this.vR()}' ACE '${t.vR()}' uses "${i.Vdt()}" parameter which is not supported in the SDK. Refer to the SDK documentation for supported types. Note support for condition/action variadic parameters has been removed - see: https://www.construct.net/forum/construct-3/plugin-sdk-10/variadic-parameters-removed-143189`)
        }
        he() {
            this.N2t = null,
            this.$Ln = null,
            super.he()
        }
        kPs() {
            return this.hBn
        }
        Dfs() {
            return this.$Ln
        }
        oBn() {
            const t = "c3runtime/main.js";
            if (!this.N2t.hasOwnProperty(t)) {
                const i = this.m.pLn().map(t => `import "./${t.startsWith("c3runtime/") ? t.substr(10) : t}";`).join("\n");
                this.N2t[t] = new Blob([i],{
                    type: "application/javascript"
                })
            }
            this.m.mLn(t)
        }
        cxe() {
            return this.m.pLn().map(t => this.sBn(t))
        }
        async M_e(t, i) {
            return await Promise.all(this.m.wLn().map(async t => {
                const e = this.YLn() + t;
                i.set(e, null);
                const s = await this.eBn(t);
                return i.set(e, s),
                e
            }
            ))
        }
        async R_e(t, i, e) {
            return await Promise.all(this.m.pLn().map(async t => {
                const i = await this.eBn(t)
                  , s = this.YLn() + t;
                e.set(s, i)
            }
            )),
            []
        }
        async eBn(t) {
            oA.zt(t);
            const i = this.lFn.get(t);
            if (i)
                return i;
            self.assert(this.N2t.hasOwnProperty(t), `missing addon '${this.vR()}' plugin runtime file`);
            const e = await oA.gle(this.N2t[t]);
            return this.lFn.set(t, e),
            e
        }
        emn() {
            const t = this.m.sAe();
            try {
                return this.sBn(t)
            } catch (i) {
                return console.error(`Error loading addon '${this.vR()}' icon: `, i),
                t
            }
        }
        sBn(t) {
            let i = this.rBn.get(t);
            if (i)
                return i;
            const e = this.N2t[t];
            if (!e)
                throw new Error(`addon '${this.vR()}' missing file '${t}'`);
            return i = URL.createObjectURL(e),
            this.rBn.set(t, i),
            i
        }
        oxe(t) {
            const i = this.N2t[t];
            if (!i)
                throw new Error(`addon '${this.vR()}' missing file '${t}'`);
            return i
        }
        IPs(t) {
            return this.oxe(t)
        }
        yhi() {
            return this.N2t._c3addon
        }
        async XPe() {
            if ("dev" !== this.YMt() || !this.aBn)
                return;
            this.lFn.clear();
            const t = Object.keys(this.aBn)
              , i = new Map;
            try {
                await Promise.all(t.map(async t => {
                    const e = this.aBn[t]
                      , s = await oA.Kl(e);
                    i.set(t, s)
                }
                ))
            } catch (t) {
                return void console.error(`Error reloading developer addon '${this.vR()}' files: `, t)
            }
            for (const [t,e] of i)
                this.N2t[t] = e,
                this.rBn.has(t) && (URL.revokeObjectURL(this.rBn.get(t)),
                this.rBn.delete(t))
        }
    }
}
{
    const lA = self.t
      , uA = lA.ek(import.meta.url);
    lA.tk(uA.URL);
    class cA extends lA.Event.aG {
        constructor() {
            super(),
            this.yAe = null
        }
        W7t(t) {
            return this.yAe = t,
            this.SIt()
        }
        async SIt() {
            const t = new lA.Event("load");
            t.app = this.yAe,
            await this.ize(t);
            const i = new lA.Event("afterload");
            await this.ize(i)
        }
        Li(t, i) {
            lA.zt(t),
            lA.qd(i),
            lA.lj.uBn("plugin", t, i)
        }
        Jm(t, i) {
            return lA.zt(t),
            lA.Mw(i, self.gh),
            lA.lj.Jm("plugin", t, i)
        }
        Eas(t, i) {
            return lA.zt(t),
            lA.Mw(i, self.gh),
            lA.lj.Eas("plugin", t, i)
        }
        Kde(t) {
            return lA.lj.Kde("plugin", t)
        }
        *plugins(t, i) {
            lA.Mw(t, self.gh);
            for (const e of lA.lj.addons("plugin", t, i)) {
                if (!lA.Ots(e)) {
                    if ("system" === e.vR())
                        continue;
                    if (lA.jii() && e.iLn())
                        continue
                }
                yield e
            }
        }
        e8s() {
            return this.Jm("system")
        }
    }
    lA.Di = lA.v(cA),
    lA.ei = {}
}
{
    const dA = self.t;
    dA.h = class extends dA.Me {
        constructor() {
            super(),
            this.Fxe = new.target,
            this.cas = null,
            this.m = null,
            this.RDn = null
        }
        he() {
            this.Fxe = null,
            this.cas = null,
            this.m = null
        }
        cBn(t) {
            dA.U(t, self.las),
            this.cas = t
        }
        sxt() {
            return this.cas
        }
        ODn(t) {
            dA.qd(t),
            this.Fxe = t
        }
        jxe() {
            return this.Fxe
        }
        DDn(t) {
            dA.U(t, self.V),
            this.m = t
        }
        GetInfo() {
            if (!this.m)
                throw new Error("behavior must set info");
            return this.m
        }
        Ql(t) {
            dA.zt(t),
            this.RDn = t
        }
        FDn() {
            return this.RDn
        }
        _as(t) {
            return dA.U(t, self.bte),
            dA.v(this.jxe().G, this, t)
        }
    }
}
{
    const fA = self.t;
    fA.R = class extends fA.Me {
        constructor(t, i) {
            fA.U(t, fA.h),
            fA.U(i, window.bte),
            super(),
            this.dBn = t,
            this.Aas = i
        }
        he() {
            fA.he(this)
        }
        NM(t) {
            return fA.U(t, window.mas),
            fA.v(this.fBn().jxe().Instance, this, t)
        }
        LEt() {
            return this.Aas
        }
        pEt() {
            return this.Aas.pEt()
        }
        fBn() {
            return this.dBn
        }
        sxt() {
            return this.dBn.sxt()
        }
    }
}
{
    const pA = self.t;
    pA.W = class extends pA.Me {
        constructor(t, i) {
            pA.U(t, pA.R),
            pA.U(i, window.mas),
            super(),
            this.Js = t,
            this.q = i,
            this.Ie = this.q.Km()
        }
        he() {
            pA.he(this)
        }
        Fi() {}
        ue(t, i) {}
        N(t, i) {
            return !1
        }
    }
}
{
    const mA = self.t;
    mA.le = class extends mA.W {
        constructor(t, i) {
            mA.U(t, mA.R),
            mA.U(i, window.mas),
            super(t, i),
            this.zDn = !1,
            this.Ce = null,
            this.J0 = null,
            this.V1 = t => this.Se(t.dt),
            this.VDn = () => this.ce()
        }
        he() {
            this.pe(!1),
            this.V1 = null,
            this.VDn = null
        }
        WDn() {
            self.app.addEventListener("livepreviewstop", this.VDn),
            this.J0.addEventListener("beforerender", this.V1)
        }
        HDn() {
            this.J0 && this.J0.removeEventListener("beforerender", this.V1),
            self.app.removeEventListener("livepreviewstop", this.VDn)
        }
        pe(t) {
            t = !!t;
            let i = self.app.zs().TF();
            if (i || (t = !1),
            this.zDn !== t)
                if (self.app.k_() && t)
                    self.app.j_(i.yn(), 10);
                else if (this.zDn = t,
                this.Ie.po(this.zDn),
                this.zDn) {
                    this.Ce = this.Ie.Hb(),
                    this.J0 = i,
                    this.WDn(),
                    this.ye();
                    this.Ie.iN().RK(!0)
                } else {
                    this.Pe(),
                    this.Ie.Qb(this.Ce),
                    this.Ce = null,
                    this.HDn(),
                    this.J0 = null;
                    const t = this.Ie.Xb()
                      , i = t ? t.Bx() : null;
                    if (i) {
                        if (!i.fo() && !i.uFs() && !this.Ie.wvs()) {
                            this.Ie.iN().RK(!1)
                        }
                    } else if (!this.Ie.wvs()) {
                        this.Ie.iN().RK(!1)
                    }
                }
        }
        de() {
            return this.zDn
        }
        ye() {}
        Pe() {}
        ce() {
            this.pe(!1),
            this.q.A("live-preview", !1)
        }
        Se(t) {
            mA.E4()
        }
    }
}
{
    const wA = self.t
      , gA = new Set(["attributes", "general", "movements", "other"])
      , yA = new Set(["", "module"]);
    window.V = class extends wA.Me {
        constructor(t) {
            wA.zt(t),
            super(),
            this.phs = t,
            this.rVt = "",
            this.Eos = "",
            this.i3t = "1.0.0.0",
            this.rFn = !1,
            this.CZs = "general",
            this.hFn = "",
            this.qxe = "http://",
            this.Zxe = "icon.svg",
            this.Qxe = "image/svg+xml",
            this.aFn = "",
            this.lFn = ["c3runtime/behavior.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"],
            this.uFn = [],
            this.pBn = !1,
            this.EZs = !1,
            this.yFn = !1,
            this.bFn = !1,
            this.EFn = !0,
            this.CFn = !0,
            this.TFn = !0,
            this.pHs = [],
            this.jFn = new Map,
            this.VFn = [],
            this.WFn = [],
            this.XFn = {
                M: "",
                akt: "",
                behavior: ""
            },
            this.YFn = []
        }
        Njt() {
            return this.phs
        }
        I(t) {
            wA.zt(t),
            this.rVt = t
        }
        Fa() {
            return this.rVt
        }
        k(t) {
            wA.zt(t),
            this.Eos = t
        }
        dj() {
            return this.Eos
        }
        P(t) {
            wA.zt(t),
            this.i3t = t,
            this.rFn = !0
        }
        $te() {
            return this.i3t
        }
        ZFn() {
            return this.rFn
        }
        S(t) {
            wA.zt(t),
            this.CZs = t
        }
        RZs() {
            return this.CZs
        }
        B(t) {
            wA.zt(t),
            this.hFn = t
        }
        Ote() {
            return this.hFn
        }
        CA(t, i) {
            wA.zt(t),
            wA.zt(i),
            this.Zxe = t,
            this.Qxe = i
        }
        sAe() {
            return this.Zxe
        }
        iAe() {
            return this.Qxe
        }
        L(t) {
            wA.zt(t),
            this.qxe = self.app.Yse(t)
        }
        NA() {
            return this.qxe
        }
        H(t) {
            this.pBn = !!t
        }
        qde() {
            return this.pBn
        }
        kr(t) {
            this.EZs = !!t
        }
        DZs() {
            return this.EZs
        }
        Ol(t) {
            this.yFn = !!t
        }
        iLn() {
            return this.yFn
        }
        Tl(t) {
            this.bFn = !!t
        }
        eLn() {
            return this.bFn
        }
        O(t) {
            wA._D(t),
            wA.lw(this.pHs, t),
            this.jFn.clear();
            for (const t of this.pHs)
                this.jFn.set(t.vR(), t)
        }
        Aoe() {
            return this.pHs
        }
        qa(t) {
            return wA.zt(t),
            this.jFn.get(t) ?? null
        }
        oys(t) {
            return wA.zt(t),
            this.jFn.has(t)
        }
        vt(t) {
            this.VFn.push(wA.v(self.SEe, t))
        }
        Fri() {
            return this.VFn
        }
        pl(t, i="") {
            if (wA.zt(t),
            t.startsWith("http:"))
                throw new Error("cannot use insecure remote script dependency, use HTTPS");
            if (!yA.has(i))
                throw new Error("invalid type");
            this.WFn.push({
                url: t,
                type: i
            })
        }
        Sxe() {
            return this.WFn
        }
        sLn(t) {
            this.EFn = !!t
        }
        uni() {
            return this.EFn
        }
        K(t) {
            this.CFn = !!t
        }
        Coe() {
            return this.CFn
        }
        vl(t) {
            this.TFn = !!t
        }
        bei() {
            return this.TFn
        }
        fLn(t) {
            this.lFn = t.slice(0)
        }
        Ke(t) {
            wA.zt(t),
            this.lFn.push(t)
        }
        pLn() {
            const t = this.lFn.slice(0);
            return this.aFn && !t.includes(this.aFn) && t.push(this.aFn),
            t
        }
        mLn(t) {
            wA.zt(t),
            this.aFn = t
        }
        $_e() {
            return this.aFn
        }
        vr(t) {
            this.uFn = t.slice(0)
        }
        wLn() {
            return this.uFn
        }
        C(t) {
            wA.Yq(t),
            wA.Kq(t.M),
            wA.Kq(t.akt),
            wA.Kq(t.behavior),
            t.M && (this.XFn.M = t.M),
            t.akt && (this.XFn.akt = t.akt),
            t.behavior && (this.XFn.behavior = t.behavior)
        }
        EPs() {
            return this.XFn
        }
        T(t) {
            wA._D(t),
            this.YFn = t
        }
        CPs() {
            return this.YFn
        }
        I6s() {
            if (!this.phs)
                throw new Error("id can not be empty");
            if (!this.rVt)
                throw new Error("name can not be empty");
            if (!gA.has(this.CZs))
                throw new Error(`invalid behavior category '${this.CZs}'`);
            if (!this.hFn)
                throw new Error("must specify author");
            if (this.qxe && !this.qxe.startsWith("http://") && !this.qxe.startsWith("https://"))
                throw new Error("help URL must begin with http:// or https://");
            wA.YJ(this.pHs, self.i);
            let t = new Set;
            for (let i of this.pHs) {
                let e = i.vR();
                if (t.has(e))
                    throw new Error(`duplicate behavior property ID '${e}'`);
                t.add(e)
            }
        }
    }
}
{
    const bA = self.t
      , vA = "#D04100";
    window.las = class extends globalThis.GDn {
        constructor(t, i) {
            bA.U(t, bA.h),
            super(),
            this.Gpn = t,
            this.m = this.Gpn.GetInfo(),
            this.LLn = bA.v(self._Qs),
            this.SLt = i.source,
            this.lFn = new Map,
            this.BLn = null,
            this.Xus = null,
            this.Yus = null,
            this.qus = null,
            this.m.I6s(),
            this.Gpn.cBn(this),
            i.zLn && (this.BLn = bA.v(bA.qs.pAe, self.app, null, {
                name: "behavior-" + this.vR(),
                color: vA,
                A6e: i.zLn
            }))
        }
        he() {
            this.Gpn.he(),
            this.Gpn = null,
            this.m = null,
            this.LLn.he(),
            this.LLn = null,
            this.lFn.clear()
        }
        VLn(t) {
            bA.Yq(t),
            bA.p.u("behaviors." + this.vR().toLowerCase());
            const i = !!this.m.DZs();
            i && bA.p.Vr(!1);
            for (let[i,e] of Object.entries(t)) {
                if ("$schema" === i)
                    continue;
                this.LLn.S(i);
                let t = e.conditions
                  , s = e.actions
                  , n = e.expressions;
                if (t)
                    for (let i of t)
                        this.LLn.BQs(i);
                if (s)
                    for (let t of s)
                        this.LLn.$Qs(t);
                if (n)
                    for (let t of n)
                        this.LLn.HQs(t)
            }
            i && bA.p.Vr(!0),
            this.LLn.LQs(),
            bA.p.j()
        }
        vR() {
            return this.m.Njt()
        }
        Vdt() {
            return "behavior"
        }
        Fa() {
            return this.m.Fa()
        }
        dj() {
            return this.m.dj()
        }
        $te() {
            return this.m.$te()
        }
        kPs() {
            return 1
        }
        RZs() {
            return this.m.RZs()
        }
        Ote() {
            return this.m.Ote()
        }
        NA() {
            return this.m.NA()
        }
        YMt() {
            return this.SLt
        }
        qde() {
            return this.m.qde()
        }
        DZs() {
            return this.m.DZs()
        }
        HLn() {
            this.m.kr(!0)
        }
        iLn() {
            return this.m.iLn()
        }
        eLn() {
            return this.m.eLn()
        }
        Vpt() {
            return this.DZs() || this.eLn() && !self.app.KLn()
        }
        bei() {
            return this.m.bei()
        }
        Aoe() {
            return this.m.Aoe()
        }
        qa(t) {
            bA.zt(t);
            const i = this.m.qa(t);
            if (!i)
                throw new Error(`behavior property id '${t}' not found`);
            return i
        }
        oys(t) {
            return bA.zt(t),
            this.m.oys(t)
        }
        gk() {
            return this.Gpn
        }
        XLn() {
            return `behaviors/${this.vR()}/`
        }
        YLn() {
            return bA.Ars.cPs() + this.XLn()
        }
        B_e() {
            return !!this.$_e()
        }
        $_e() {
            return this.m.$_e()
        }
        async M_e(t, i) {
            bA.E4()
        }
        async R_e(t, i, e) {
            bA.E4()
        }
        Fri() {
            return this.m.Fri()
        }
        Sxe() {
            return this.m.Sxe()
        }
        EPs() {
            return this.m.EPs()
        }
        CPs() {
            return this.m.CPs()
        }
        uni() {
            return this.m.uni() && "dev" !== this.YMt()
        }
        Coe() {
            return this.m.Coe()
        }
        iAe() {
            return this.m.iAe()
        }
        JLn() {
            return "image/svg+xml" === this.iAe()
        }
        ZLn() {
            !this.BLn && this.JLn() && (this.BLn = bA.v(bA.qs.pAe, self.app, this.emn(), {
                name: "behavior-" + this.vR(),
                color: vA
            }))
        }
        xA() {
            return this.Xus || (this.ZLn(),
            this.BLn ? this.Xus = this.BLn.xA() : this.Xus = bA.qs.O_.mAe(this.emn(), self.app.T_(), {
                og: this.JLn()
            })),
            this.Xus
        }
        uj() {
            return this.Yus || (this.ZLn(),
            this.BLn ? this.Yus = this.BLn.uj() : this.Yus = bA.qs.O_.mAe(this.emn(), self.app.Gk(), {
                og: this.JLn()
            })),
            this.Yus
        }
        nus() {
            return this.qus || (this.ZLn(),
            this.BLn ? this.qus = this.BLn.nus() : this.qus = bA.qs.O_.mAe(this.emn(), self.app.BJt(), {
                og: this.JLn()
            })),
            this.qus
        }
        Igs(t) {
            switch (bA.zt(t),
            t) {
            case "small":
                return this.xA();
            case "medium":
                return this.uj();
            case "large":
                return this.nus();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        li(t) {
            return bA.zt(t),
            this.LLn.li(t)
        }
        Iqs(t) {
            return bA.Ge(t),
            this.LLn.Iqs(t)
        }
        HDt() {
            return this.LLn.HDt()
        }
        OGt() {
            return this.LLn.OGt()
        }
        ci(t) {
            return bA.zt(t),
            this.LLn.ci(t)
        }
        jqs(t) {
            return bA.Ge(t),
            this.LLn.jqs(t)
        }
        actions() {
            return this.LLn.actions()
        }
        Hyt() {
            return this.LLn.Hyt()
        }
        ui(t) {
            return bA.zt(t),
            this.LLn.ui(t)
        }
        zQs(t) {
            return bA.Ge(t),
            this.LLn.zQs(t)
        }
        ki(t) {
            return bA.zt(t),
            this.LLn.ki(t)
        }
        WQs() {
            return this.LLn.WQs()
        }
        KQs() {
            return this.LLn.KQs()
        }
        VIe(t) {
            if (bA.zt(t),
            "conditions" === t)
                return this.HDt();
            if ("actions" === t)
                return this.actions();
            if ("expressions" === t)
                return this.WQs();
            throw new Error("invalid ace type")
        }
        _as(t, i) {
            if (bA.U(t, self.EF),
            bA.zt(i),
            i = self.EF.lQ(i, !0),
            t.Ja().Gos(i)) {
                const e = new Error("expression name collision");
                throw e.type = "expression-name-collision",
                e.Cos = "behavior",
                e.El = t,
                e.name = i,
                e
            }
            if (t.Ios(i))
                throw new Error(`behavior type name '${i}' already in namespace`);
            let e = bA.v(self.bte, t, this, i);
            e.Js = this.Gpn._as(e);
            const s = t.yn();
            return this.bei() || "worker" !== s.xse() || s.Aii("auto"),
            e
        }
        static Qde(t, i) {
            const e = (bA.Ots(t) ? t.QLn : t.Fa()).toLowerCase()
              , s = (bA.Ots(i) ? i.QLn : i.Fa()).toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const SA = self.t
      , xA = ["c3runtime/behavior.js", "c3runtime/type.js", "c3runtime/instance.js", "c3runtime/conditions.js", "c3runtime/actions.js", "c3runtime/expressions.js"];
    window.mBn = class extends self.las {
        constructor(t, i) {
            if (SA.U(t, SA.h),
            super(t, i),
            SA.jii()) {
                const t = this.m.pLn();
                SA.spt(t, new Set(xA)),
                t.unshift("c3runtime/runtime.js"),
                this.m.fLn(t)
            }
            this.Kdt = "",
            i.path && (this.Kdt = new URL(i.path,SA.sh()).toString(),
            t.Ql(this.Kdt))
        }
        he() {
            super.he()
        }
        cxe() {
            return this.m.pLn().map(t => this.Kdt + t)
        }
        async F_e(t, i, e, s) {
            return await Promise.all(e.map(async e => {
                if ("preview" === t)
                    return this.Kdt + e;
                {
                    const t = this.YLn() + e
                      , n = this.XLn() + e;
                    i.set(t, null);
                    const r = await this.eBn(e);
                    return i.set(t, r),
                    s ? t : n
                }
            }
            ))
        }
        async M_e(t, i) {
            return await this.F_e(t, i, this.m.wLn(), !0)
        }
        async R_e(t, i, e) {
            return await this.F_e(t, i, this.m.pLn(), !1)
        }
        async eBn(t) {
            SA.zt(t);
            const i = this.lFn.get(t);
            if (i)
                return i;
            const e = await fetch(this.Kdt + t)
              , s = await e.text();
            return this.lFn.set(t, s),
            s
        }
        emn() {
            return this.Kdt + this.m.sAe()
        }
        zrt() {
            return this.Kdt
        }
        sBn(t) {
            return this.Kdt + t
        }
        IPs(t) {
            return this.sBn(t)
        }
        $te() {
            return SA.o_.Lhi
        }
    }
}
{
    const MA = self.t
      , EA = new Set([1, 2]);
    window.lni = class extends self.las {
        constructor(t, i) {
            t instanceof window.SDK.IBehaviorBase && (t = t.wBn()),
            MA.U(t, MA.h),
            super(t, i);
            const e = i.nBn;
            if (this.N2t = i.files,
            this.rBn = new Map,
            this.hBn = i.nBn["sdk-version"] ?? 1,
            1 === this.hBn)
                throw new Error(`instantiating SDKv1 addon '${this.vR()}'`);
            if (!EA.has(this.hBn))
                throw new Error(`addon ID '${this.vR()}' specifies invalid SDK version ${this.hBn}`);
            this.m.ZFn() && (() => {})(`[Addon SDK] Addon ID '${this.vR()}' called SetVersion(). This is ignored in the Addon SDK v2 and the version set in addon.json is used instead. Remove the call to SetVersion() to clear this warning.`),
            this.m.P(e.version),
            this.m.vl(e["supports-worker-mode"] ?? !0),
            this.m.$_e() || this.oBn(),
            this.aBn = i.lBn
        }
        VLn(t) {
            super.VLn(t);
            for (const t of [...this.HDt(), ...this.actions()])
                if (!t.jZs())
                    for (const i of t.parameters())
                        if (!i.lZs())
                            throw new Error(`Addon '${this.vR()}' ACE '${t.vR()}' uses "${i.Vdt()}" parameter which is not supported in the SDK. Refer to the SDK documentation for supported types. Note support for condition/action variadic parameters has been removed - see: https://www.construct.net/forum/construct-3/plugin-sdk-10/variadic-parameters-removed-143189`)
        }
        he() {
            this.N2t = null,
            super.he()
        }
        kPs() {
            return this.hBn
        }
        oBn() {
            const t = "c3runtime/main.js";
            if (!this.N2t.hasOwnProperty(t)) {
                const i = this.m.pLn().map(t => `import "./${t.startsWith("c3runtime/") ? t.substr(10) : t}";`).join("\n");
                this.N2t[t] = new Blob([i],{
                    type: "application/javascript"
                })
            }
            this.m.mLn(t)
        }
        cxe() {
            return this.m.pLn().map(t => this.sBn(t))
        }
        async M_e(t, i) {
            return await Promise.all(this.m.wLn().map(async t => {
                const e = this.YLn() + t;
                i.set(e, null);
                const s = await this.eBn(t);
                return i.set(e, s),
                e
            }
            ))
        }
        async R_e(t, i, e) {
            return await Promise.all(this.m.pLn().map(async t => {
                const i = await this.eBn(t)
                  , s = this.YLn() + t;
                e.set(s, i)
            }
            )),
            []
        }
        async eBn(t) {
            MA.zt(t);
            const i = this.lFn.get(t);
            if (i)
                return i;
            self.assert(this.N2t.hasOwnProperty(t), `missing addon '${this.vR()}' plugin runtime file`);
            const e = await MA.gle(this.N2t[t]);
            return this.lFn.set(t, e),
            e
        }
        emn() {
            return this.sBn(this.m.sAe())
        }
        sBn(t) {
            let i = this.rBn.get(t);
            if (i)
                return i;
            const e = this.N2t[t];
            if (!e)
                throw new Error(`addon '${this.vR()}' missing file '${t}'`);
            return i = URL.createObjectURL(e),
            this.rBn.set(t, i),
            i
        }
        oxe(t) {
            const i = this.N2t[t];
            if (!i)
                throw new Error(`addon '${this.vR()}' missing file '${t}'`);
            return i
        }
        IPs(t) {
            return this.oxe(t)
        }
        yhi() {
            return this.N2t._c3addon
        }
        async XPe() {
            if ("dev" !== this.YMt() || !this.aBn)
                return;
            this.lFn.clear();
            const t = Object.keys(this.aBn)
              , i = new Map;
            try {
                await Promise.all(t.map(async t => {
                    const e = this.aBn[t]
                      , s = await MA.Kl(e);
                    i.set(t, s)
                }
                ))
            } catch (t) {
                return void console.error(`Error reloading developer addon '${this.vR()}' files: `, t)
            }
            for (const [t,e] of i)
                this.N2t[t] = e,
                this.rBn.has(t) && (URL.revokeObjectURL(this.rBn.get(t)),
                this.rBn.delete(t))
        }
    }
}
{
    const CA = self.t
      , _A = CA.ek(import.meta.url);
    CA.tk(_A.URL);
    class TA extends CA.Event.aG {
        constructor() {
            super(),
            this.yAe = null
        }
        W7t(t) {
            return this.yAe = t,
            this.SIt()
        }
        async SIt() {
            const t = new CA.Event("load");
            t.app = this.yAe,
            await this.ize(t);
            const i = new CA.Event("afterload");
            await this.ize(i)
        }
        _(t, i) {
            CA.zt(t),
            CA.qd(i),
            CA.lj.uBn("behavior", t, i)
        }
        Jm(t, i) {
            return CA.zt(t),
            CA.Mw(i, self.gh),
            CA.lj.Jm("behavior", t, i)
        }
        Eas(t, i) {
            return CA.zt(t),
            CA.Mw(i, self.gh),
            CA.lj.Eas("behavior", t, i)
        }
        Kde(t) {
            return CA.lj.Kde("behavior", t)
        }
        *Yde(t, i) {
            CA.Mw(t, self.gh);
            for (const e of CA.lj.addons("behavior", t, i))
                !CA.Ots(e) && CA.jii() && e.iLn() || (yield e)
        }
    }
    CA.F = CA.v(TA),
    CA.o = {}
}
{
    const IA = self.t
      , PA = self.lang
      , GA = self.assert
      , AA = new Set(["3d", "blend", "color", "distortion", "mask", "normal-mapping", "other", "tiling"])
      , RA = new Set;
    window.MQ = class t extends globalThis.GDn {
        constructor(t, i, e, s, n, r) {
            if (super(),
            IA.zt(t),
            IA.Yq(i),
            IA.Kq(e),
            IA.Kq(s),
            IA.Kq(n),
            IA.Wat(r),
            IA.zt(i.id),
            IA.zt(i.category),
            IA.zt(i.author),
            IA.Kq(i.version),
            IA.zAt(i["supported-renderers"]),
            IA.Wat(i["extend-box"]),
            i["extend-box"] && (IA.Ge(i["extend-box"].horizontal),
            IA.Ge(i["extend-box"].vertical)),
            IA._D(i.parameters),
            !AA.has(i.category))
                throw new Error("invalid category");
            this.Kdt = t,
            this.SLt = "built-in",
            this.phs = i.id,
            this.CZs = i.category,
            this.hFn = i.author,
            this.i3t = i.version || "1.0.0.0",
            this.Wgn = !!i["must-predraw"],
            this.Zgn = !!i["blends-background"],
            this.Qgn = !!i["uses-depth"],
            this.zgn = !!i["cross-sampling"],
            this.Kgn = !!i["preserves-opaqueness"],
            this.Xgn = !!i["supports-3d-direct-rendering"],
            this.Jgn = !!i.animated,
            this.Ugn = 0,
            this.jgn = 0,
            this.EZs = !!i["is-deprecated"],
            this.N2t = null,
            this.aBn = null;
            const h = i["supported-renderers"];
            if (this.gBn = !h || h.includes("webgl"),
            this.yBn = h && h.includes("webgl2"),
            this.bBn = h && h.includes("webgpu"),
            i["extend-box"] && (this.Ugn = i["extend-box"].horizontal,
            this.jgn = i["extend-box"].vertical),
            this.vBn = e,
            this.SBn = s,
            this.xBn = n,
            this.gBn && !this.vBn)
                throw new Error(`effect ${this.phs} supports WebGL but has empty GLSL content`);
            if (this.yBn && !this.SBn)
                throw new Error(`effect ${this.phs} supports WebGL2 but has empty GLSL content`);
            if (this.bBn && !this.xBn)
                throw new Error(`effect ${this.phs} supports WebGPU but has empty WGSL content`);
            if (this.Zgn && this.Qgn)
                throw new Error(`effect ${this.phs} cannot specify both background blending and depth`);
            this.dmn = null,
            this.MBn = null,
            this.EBn = i.parameters,
            this.tqs = [],
            this.rVt = "",
            this.Eos = "",
            this.C2t = !1,
            r && (this.SLt = r.source,
            this.N2t = r.files,
            this.aBn = r.lBn)
        }
        he() {
            this.vBn = "",
            this.SBn = "",
            this.xBn = "",
            this.dmn && (this.dmn.he(),
            this.dmn = null),
            this.N2t = null
        }
        static async mAe(i, e) {
            IA.zt(i),
            IA.zt(e),
            IA.p.ik(`${i}${e}\\lang`);
            const s = await IA.Z1t(`${i}${e}\\${e}.json`)
              , n = s["supported-renderers"]
              , r = !n || n.includes("webgl")
              , h = n && n.includes("webgl2")
              , o = n && n.includes("webgpu");
            let a = ""
              , l = ""
              , u = "";
            return r && (a = await IA.Nxe(`${i}${e}\\${e}.fx`)),
            h && (l = await IA.Nxe(`${i}${e}\\${e}.webgl2.fx`)),
            o && (u = await IA.Nxe(`${i}${e}\\${e}.wgsl`)),
            IA.v(t, i, s, a, l, u)
        }
        W7t() {
            if (this.C2t)
                throw new Error("effect already ready");
            IA.p.u("effects." + this.phs.toLowerCase()),
            this.rVt = PA(".name"),
            this.Eos = PA(".description"),
            IA.p.u(".parameters");
            for (const t of this.EBn) {
                const i = new self.i(t.type,t.id,{
                    initialValue: t["initial-value"],
                    D: t.interpolatable
                })
                  , e = t.uniform;
                if (IA.ra.Nbn.Vvn().has(e))
                    throw new Error(`[Effects] Effect '${this.phs}' parameter '${t.id}' specifices a uniform '${e}', but this name is reserved for internal use by Construct. Please use a different uniform name.`);
                i.JDn(e),
                t.hasOwnProperty("c2id") && i.QDn(t.c2id),
                this.tqs.push(i)
            }
            IA.sc(this.EBn),
            IA.p.j(),
            IA.p.j(),
            this.C2t = !0
        }
        Vdt() {
            return "effect"
        }
        vR() {
            return this.phs
        }
        Fa() {
            return this.rVt
        }
        dj() {
            return this.Eos
        }
        RZs() {
            return this.CZs
        }
        Ote() {
            return this.hFn
        }
        $te() {
            return "built-in" === this.YMt() ? IA.o_.Lhi : this.i3t
        }
        CBn() {
            return this.gBn
        }
        _Bn() {
            return this.yBn
        }
        Pse() {
            return this.bBn
        }
        YMt() {
            return this.SLt
        }
        DZs() {
            return this.EZs
        }
        Vpt() {
            return this.DZs()
        }
        no() {
            return this.Wgn
        }
        ils() {
            return this.Zgn
        }
        Sni() {
            return this.Qgn
        }
        yni() {
            return this.zgn
        }
        ryn() {
            return this.Kgn
        }
        hyn() {
            return this.Xgn
        }
        oyn() {
            return this.Jgn
        }
        syn() {
            return this.Ugn
        }
        nyn() {
            return this.jgn
        }
        eyn() {
            return 0 !== this.Ugn || 0 !== this.jgn
        }
        Coe() {
            return !0
        }
        pne() {
            return this.tqs
        }
        voi(t) {
            IA.zt(t);
            for (let i of this.tqs)
                if (i.vR() === t)
                    return i;
            return null
        }
        Goi(t) {
            IA.zt(t);
            for (let i of this.tqs)
                if ("color" === i.Vdt()) {
                    let e = i.tFn().split(",").indexOf(t);
                    if (e >= 0)
                        return {
                            nC: i,
                            component: e
                        }
                } else if (i.tFn() === t)
                    return {
                        nC: i
                    };
            return null
        }
        Gae(t) {
            IA.zt(t);
            let i = this.voi(t);
            if (!i)
                throw new Error(`effect parameter id '${t}' not found`);
            return i
        }
        TBn() {
            return GA(this.gBn, "shader does not support WebGL"),
            this.vBn
        }
        IBn() {
            return GA(this.yBn, "shader does not support WebGL 2"),
            this.SBn
        }
        PBn() {
            return GA(this.bBn, "shader does not support WebGPU"),
            this.xBn
        }
        zrt() {
            return this.Kdt
        }
        GBn() {
            if (this.dmn)
                return Promise.resolve(this.dmn);
            if (this.MBn)
                return this.MBn;
            const t = this.tqs.map(t => [t.ZDn(), 0, t.Vdt()]);
            return this.MBn = (async () => {
                try {
                    const i = await self.app.Pv();
                    let e = ""
                      , s = "";
                    if (i.Zd()) {
                        if (!this.Pse())
                            throw new Error(`shader '${this.vR()}' does not support WebGPU`);
                        e = this.PBn()
                    } else if (this._Bn() && i.Qxn() >= 2)
                        e = this.IBn(),
                        s = IA.ra.Nbn.Kvn();
                    else {
                        if (!this.CBn())
                            throw new Error(`shader '${this.vR()}' does not support WebGL 1`);
                        e = this.TBn(),
                        s = IA.ra.Nbn.Hvn()
                    }
                    const n = await i.wCn({
                        src: e,
                        $bn: s,
                        name: this.vR(),
                        wni: this.ils(),
                        bni: this.Sni(),
                        Ngn: this.syn(),
                        $gn: this.nyn(),
                        Vgn: this.yni(),
                        Hgn: this.no(),
                        qgn: this.ryn(),
                        Ygn: this.hyn(),
                        animated: this.oyn(),
                        parameters: t
                    });
                    return RA.add(this),
                    this.dmn = n,
                    this.MBn = null,
                    this.dmn
                } catch (t) {
                    console.error(`Failed to compile '${this.vR()}' shader program: `, t),
                    this.dmn = null
                }
            }
            )(),
            this.MBn
        }
        Als() {
            return this.dmn
        }
        static L0() {
            for (const t of RA)
                t.dmn = null
        }
        static async F0() {
            await Promise.all([...RA].map(t => t.GBn()))
        }
        async mls(t, i) {
            IA.U(t, self.qas),
            IA.zt(i);
            const e = t instanceof self.EF ? t : null;
            if (e) {
                if (e.Ja().Gos(i)) {
                    const t = new Error("expression name collision");
                    throw t.type = "expression-name-collision",
                    t.Cos = "effect",
                    t.El = e,
                    t.name = i,
                    t
                }
                if (e.Ios(i))
                    throw new Error(`effect type name '${i}' already in namespace`)
            }
            return await this.GBn(),
            IA.v(self.gte, t, this, i)
        }
        static Zls(t, i) {
            const e = (IA.Ots(t) ? t.QLn : t.Fa()).toLowerCase()
              , s = (IA.Ots(i) ? i.QLn : i.Fa()).toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
        yhi() {
            return this.N2t._c3addon
        }
        ABn(t) {
            const i = t.split("\n").map(t => t.trim())
              , e = [];
            for (const t of i)
                t && "//" !== t.substr(0, 2) && e.push(t);
            return e.join("\n")
        }
        RBn() {
            return this.CBn() ? this.ABn(this.TBn()) : ""
        }
        kBn() {
            return this._Bn() ? this.ABn(this.IBn()) : ""
        }
        OBn() {
            return this.Pse() ? this.ABn(this.PBn()) : ""
        }
        DBn() {
            const t = [];
            for (const i of this.tqs)
                t.push([i.ZDn(), 0, i.Vdt()]);
            return t
        }
        nh(t) {
            return {
                glsl: this.RBn(),
                glslWebGL2: this.kBn(),
                wgsl: this.OBn(),
                blendsBackground: this.ils(),
                usesDepth: this.Sni(),
                extendBoxHorizontal: this.syn(),
                extendBoxVertical: this.nyn(),
                crossSampling: this.yni(),
                mustPreDraw: this.no(),
                preservesOpaqueness: this.ryn(),
                supports3dDirectRendering: this.hyn(),
                animated: this.oyn(),
                parameters: this.DBn()
            }
        }
        async XPe() {
            if ("dev" !== this.YMt() || !this.aBn)
                return;
            const t = ["effect.fx", "effect.webgl2.fx", "effect.wgsl"]
              , i = new Map;
            try {
                await Promise.all(t.map(async t => {
                    const e = this.aBn[t];
                    if (!e)
                        return;
                    const s = await IA.Nxe(e);
                    i.set(t, s)
                }
                ))
            } catch (t) {
                return void console.error(`Error reloading developer addon '${this.vR()}' files: `, t)
            }
            for (const [t,e] of i)
                this.N2t[t] = new Blob([e]),
                "effect.fx" === t ? this.vBn = e : "effect.webgl2.fx" === t ? this.SBn = e : "effect.wgsl" === t && (this.xBn = e)
        }
    }
}
{
    const kA = self.t
      , OA = self.MQ
      , DA = "effects/";
    class FA extends kA.Event.aG {
        constructor() {
            super(),
            this.yAe = null,
            this.FBn = !1,
            this.LBn = 0,
            this.BBn = 0
        }
        Jm(t, i) {
            return kA.zt(t),
            kA.Mw(i, self.gh),
            kA.lj.Jm("effect", t, i)
        }
        Eas(t, i) {
            return kA.zt(t),
            kA.Mw(i, self.gh),
            kA.lj.Eas("effect", t, i)
        }
        async SIt() {
            kA.jii() ? await this.UBn() : await this.NBn()
        }
        NBn() {
            if (this.FBn)
                throw new Error("already loaded effects");
            this.FBn = !0;
            let t = DA;
            return kA.Z1t(t + "defaultEffectList.json").then(i => {
                let e = i.defaultEffects;
                this.BBn = e.length;
                let s = [];
                for (let i of e)
                    s.push(OA.mAe(t, i));
                return kA.RPe(s, (t, i) => this.jBn(t, i))
            }
            ).then(t => {
                for (let i of t)
                    kA.lj.$Bn(i.vR(), i)
            }
            )
        }
        UBn() {
            if (this.FBn)
                throw new Error("already loaded effects");
            this.FBn = !0,
            this.BBn = 1;
            const t = DA;
            return kA.Z1t(t + "allEffects.json").then(t => {
                this.LBn = 1;
                for (const i of t.all) {
                    const t = kA.v(OA, "", i.json, i.glsl, i.glslWebGL2, i.wgsl);
                    kA.lj.$Bn(t.vR(), t)
                }
            }
            )
        }
        jBn(t, i) {
            this.LBn = t
        }
        zBn() {
            return this.LBn
        }
        VBn() {
            return this.BBn
        }
        W7t(t) {
            this.yAe = t,
            kA.lj.WBn()
        }
        effects(t, i) {
            return kA.Mw(t, self.gh),
            kA.lj.addons("effect", t, i)
        }
    }
    kA.pls = kA.v(FA)
}
window.SDK = {},
window.SDK.Plugins = {},
window.SDK.Behaviors = {},
window.SDK.Gfx = {},
window.SDK.UI = {};
{
    const LA = self.t;
    class BA {
        constructor() {}
        PushContext(t) {
            LA.p.u(t)
        }
        PopContext() {
            LA.p.j()
        }
        Get(t) {
            return LA.p.$s(t)
        }
    }
    window.SDK.Lang = new BA
}
{
    const UA = self.t;
    window.SDK.Rect = class {
        constructor(t, i, e, s) {
            this.hrt = null,
            t instanceof UA.Rect ? this.hrt = t : this.hrt = UA.v(UA.Rect, t, i, e, s)
        }
        set(t, i, e, s) {
            this.hrt.set(t, i, e, s)
        }
        copy(t) {
            UA.U(t, window.SDK.Rect),
            this.hrt.ia(t.hrt)
        }
        clone() {
            const t = new window.SDK.Rect;
            return t.copy(this),
            t
        }
        setLeft(t) {
            this.hrt.u9(t)
        }
        getLeft() {
            return this.hrt.Kr()
        }
        setTop(t) {
            this.hrt.d9(t)
        }
        getTop() {
            return this.hrt.Zr()
        }
        setRight(t) {
            this.hrt.zC(t)
        }
        getRight() {
            return this.hrt.gl()
        }
        setBottom(t) {
            this.hrt.p9(t)
        }
        getBottom() {
            return this.hrt.wl()
        }
        width() {
            return this.hrt.width()
        }
        height() {
            return this.hrt.height()
        }
        midX() {
            return this.hrt.bl()
        }
        midY() {
            return this.hrt.yl()
        }
        offset(t, i) {
            this.hrt.offset(t, i)
        }
        inflate(t, i) {
            this.hrt.Xm(t, i)
        }
        deflate(t, i) {
            this.hrt.ea(t, i)
        }
        multiply(t, i) {
            this.hrt.multiply(t, i)
        }
        divide(t, i) {
            this.hrt.tb(t, i)
        }
        clamp(t, i, e, s) {
            this.hrt.Ne(t, i, e, s)
        }
        normalize() {
            this.hrt.normalize()
        }
        intersectsRect(t) {
            return UA.U(t, window.SDK.Rect),
            this.hrt.Yp(t.hrt)
        }
        containsPoint(t, i) {
            return this.hrt.a8(t, i)
        }
    }
}
{
    const NA = self.t;
    window.SDK.Quad = class {
        constructor(t, i, e, s, n, r, h, o) {
            this.yys = null,
            t instanceof NA.Nn ? this.yys = t : this.yys = NA.v(NA.Nn, t, i, e, s, n, r, h, o)
        }
        set(t, i, e, s, n, r, h, o) {
            this.yys.set(t, i, e, s, n, r, h, o)
        }
        setRect(t, i, e, s) {
            this.yys.Nc(t, i, e, s)
        }
        copy(t) {
            NA.U(t, window.SDK.Quad),
            this.yys.ia(t.yys)
        }
        setTlx(t) {
            this.yys.ab(t)
        }
        getTlx() {
            return this.yys.Jn()
        }
        setTly(t) {
            this.yys.lb(t)
        }
        getTly() {
            return this.yys.Qn()
        }
        setTrx(t) {
            this.yys.lFe(t)
        }
        getTrx() {
            return this.yys.Hw()
        }
        setTry(t) {
            this.yys.uFe(t)
        }
        getTry() {
            return this.yys.rl()
        }
        setBrx(t) {
            this.yys.cFe(t)
        }
        getBrx() {
            return this.yys.al()
        }
        setBry(t) {
            this.yys.dFe(t)
        }
        getBry() {
            return this.yys.ll()
        }
        setBlx(t) {
            this.yys.fFe(t)
        }
        getBlx() {
            return this.yys.zc()
        }
        setBly(t) {
            this.yys.pFe(t)
        }
        getBly() {
            return this.yys.Ec()
        }
        offset(t, i) {
            this.yys.offset(t, i)
        }
        setFromRect(t) {
            NA.U(t, window.SDK.Rect),
            this.yys.sa(t.hrt)
        }
        setFromRotatedRect(t, i) {
            NA.U(t, window.SDK.Rect),
            this.yys.mr(t.hrt, i)
        }
        getBoundingBox(t) {
            NA.U(t, window.SDK.Rect),
            this.yys.Lbs(t.hrt)
        }
        containsPoint(t, i) {
            return this.yys.a8(t, i)
        }
        midX() {
            return this.yys.bl()
        }
        midY() {
            return this.yys.yl()
        }
        intersectsSegment(t, i, e, s) {
            return this.yys.yFe(t, i, e, s)
        }
        intersectsQuad(t) {
            return NA.U(t, window.SDK.Quad),
            this.yys.bFe(t.yys)
        }
    }
}
{
    const jA = self.t;
    window.SDK.Color = class {
        constructor(t, i, e, s) {
            this.mp = null,
            t instanceof jA.Ha ? this.mp = t : this.mp = jA.v(jA.Ha, t, i, e, s)
        }
        setRgb(t, i, e) {
            this.mp.Eo(t, i, e)
        }
        setRgba(t, i, e, s) {
            this.mp.CIs(t, i, e, s)
        }
        copy(t) {
            jA.U(t, window.SDK.Color),
            this.mp.set(t.mp)
        }
        copyRgb(t) {
            jA.U(t, window.SDK.Color),
            this.mp.Wa(t.mp)
        }
        setR(t) {
            this.mp.mDe(t)
        }
        getR(t) {
            return this.mp.getR()
        }
        setG(t) {
            this.mp.wDe(t)
        }
        getG(t) {
            return this.mp.getG()
        }
        setB(t) {
            this.mp.gDe(t)
        }
        getB(t) {
            return this.mp.getB()
        }
        setA(t) {
            this.mp.FC(t)
        }
        getA(t) {
            return this.mp.getA()
        }
        clone() {
            const t = new window.SDK.Color;
            return t.copy(this),
            t
        }
        equals(t) {
            return jA.U(t, window.SDK.Color),
            this.mp.equals(t.mp)
        }
        equalsIgnoringAlpha(t) {
            return jA.U(t, window.SDK.Color),
            this.mp.Oae(t.mp)
        }
        equalsRgb(t, i, e) {
            return this.mp.PLs(t, i, e)
        }
        equalsRgba(t, i, e, s) {
            return this.mp.RGs(t, i, e, s)
        }
        premultiply() {
            this.mp.Vc()
        }
        unpremultiply() {
            this.mp.SDe()
        }
    }
}
{
    const $A = self.t
      , zA = new WeakMap;
    window.SDK.IZipFile = class {
        constructor(t) {
            $A.U(t, $A.FRt),
            zA.set(this, t)
        }
        PathExists(t) {
            return zA.get(this).hes(t)
        }
        GetFileList() {
            return [...zA.get(this).FKe()]
        }
        GetFirstEntryWithExtension(t) {
            const i = zA.get(this).$Rt(t);
            return i ? new window.SDK.IZipFileEntry(i) : null
        }
        GetEntry(t) {
            const i = zA.get(this).XRt(t);
            return i ? new window.SDK.IZipFileEntry(i) : null
        }
        ReadText(t) {
            return zA.get(this).ies(window.SDK.IZipFileEntry.Oze(t))
        }
        ReadJson(t) {
            return zA.get(this).ees(window.SDK.IZipFileEntry.Oze(t))
        }
        ReadBlob(t) {
            return zA.get(this).JRt(window.SDK.IZipFileEntry.Oze(t))
        }
    }
}
{
    const VA = self.t
      , WA = new WeakMap;
    window.SDK.IZipFileEntry = class {
        constructor(t) {
            WA.set(this, t)
        }
        static Oze(t) {
            return VA.U(t, window.SDK.IZipFileEntry),
            WA.get(t)
        }
    }
}
{
    const HA = self.t;
    HA.HBn = class extends HA.ii {
        constructor(t) {
            super(),
            HA.U(t, window.SDK.IPluginBase),
            this.KBn = t
        }
        he() {
            this.KBn.Release(),
            this.KBn = null,
            super.he()
        }
        ZA(t) {
            HA.U(t, self.aF);
            let i = this.jxe().Type;
            !i && this.Ja().kPs() >= 2 && (i = globalThis.SDK.ITypeBase);
            return HA.v(i, this.KBn, t.Bds()).qBn(this, t)
        }
    }
}
{
    const KA = self.t;
    KA.XBn = class extends KA.Ni {
        constructor(t, i, e) {
            super(t, i),
            KA.U(e, window.SDK.ITypeBase),
            this.YBn = e
        }
        NM(t) {
            KA.U(t, window.AM);
            const i = "world" === this.Os.Ja()._F() ? window.SDK.IWorldInstance : window.SDK.IObjectInstance;
            let e = this.hg().jxe().Instance;
            !e && this.Ja().kPs() >= 2 && (e = globalThis.SDK.IInstanceBase);
            return KA.v(e, this.YBn, new i(t)).JBn(this, t)
        }
        nFn() {
            return this.YBn
        }
    }
}
{
    const qA = self.t;
    qA.ZBn = class extends qA.Ai {
        constructor(t, i, e) {
            qA.U(e, window.SDK.IInstanceBase),
            super(t, i),
            this.QBn = e,
            this.tUn = null,
            qA.$l(this.Ie, self.Vb) && (this.tUn = t => this.Dh(t),
            self.app.addEventListener("timelineeditablechange", this.tUn))
        }
        sFn() {
            return this.QBn
        }
        he() {
            this.tUn && self.app.removeEventListener("timelineeditablechange", this.tUn),
            this.tUn = null,
            this.QBn.Release(),
            super.he()
        }
        Fi() {
            this.QBn.OnCreate()
        }
        pS() {
            this.QBn.OnAfterCreate()
        }
        ue(t, i) {
            i && i instanceof qA.Ha && (i = new window.SDK.Color(i.getR(),i.getG(),i.getB(),i.getA())),
            this.QBn.OnPropertyChanged(t, i)
        }
        ro(t, i, e) {
            let s;
            i && i instanceof qA.Ha && (i = new window.SDK.Color(i.getR(),i.getG(),i.getB(),i.getA())),
            !0 === e.zx ? s = "relative" : !0 === e.absolute && (s = "absolute"),
            this.QBn.OnTimelinePropertyChanged(t, i, {
                resultMode: s
            })
        }
        Dh(t) {
            const i = t.timeline
              , e = i.yn();
            this.yn() === e && (e.kx() || e.do() === i && i.mo(this.Ie) && (i.fo() || this.QBn.OnExitTimelineEditMode()))
        }
        N(t, i) {
            return this.QBn.LoadC2Property(t, i)
        }
    }
}
{
    const XA = self.t;
    XA.iUn = class extends XA.ZBn {
        constructor(t, i, e) {
            XA.U(e, window.SDK.IWorldInstanceBase),
            super(t, i, e)
        }
        Un(t, i) {
            this.QBn.Draw(self.app.zs().G0(), i.nz)
        }
        jr() {
            this.QBn.OnPlacedInLayout()
        }
        ao() {
            return this.QBn.IsOriginalSizeKnown()
        }
        lo() {
            return this.QBn.GetOriginalWidth()
        }
        ho() {
            return this.QBn.GetOriginalHeight()
        }
        br() {
            return this.QBn.HasDoubleTapHandler()
        }
        yr() {
            this.QBn.OnDoubleTap()
        }
    }
}
{
    const YA = globalThis.t;
    YA.eUn = class extends YA.h {
        constructor(t) {
            super(),
            YA.U(t, globalThis.SDK.IBehaviorBase),
            this.sUn = t
        }
        he() {
            this.sUn.Release(),
            this.sUn = null,
            super.he()
        }
        _as(t) {
            YA.U(t, globalThis.bte);
            let i = this.jxe().Type;
            !i && this.sxt().kPs() >= 2 && (i = globalThis.SDK.IBehaviorTypeBase);
            return YA.v(i, this.sUn, new globalThis.SDK.IBehaviorType(t)).nUn(this, t)
        }
    }
}
{
    const JA = self.t;
    JA.rUn = class extends JA.R {
        constructor(t, i, e) {
            super(t, i),
            JA.U(e, window.SDK.IBehaviorTypeBase),
            this.hUn = e
        }
        NM(t) {
            JA.U(t, window.mas);
            let i = this.fBn().jxe().Instance;
            !i && this.sxt().kPs() >= 2 && (i = globalThis.SDK.IBehaviorInstanceBase);
            return JA.v(i, this.hUn, new window.SDK.IBehaviorInstance(t)).oUn(this, t)
        }
    }
}
{
    const ZA = self.t;
    ZA.aUn = class extends ZA.W {
        constructor(t, i, e) {
            super(t, i),
            ZA.U(e, window.SDK.IBehaviorInstanceBase),
            this.lUn = e
        }
        uUn() {
            return this.lUn
        }
        he() {
            this.lUn.Release(),
            super.he()
        }
        Fi() {
            this.lUn.OnCreate()
        }
        ue(t, i) {
            i && i instanceof ZA.Ha && (i = new window.SDK.Color(i.getR(),i.getG(),i.getB(),i.getA())),
            this.lUn.OnPropertyChanged(t, i)
        }
    }
}
{
    const QA = self.t
      , tR = new WeakMap;
    window.SDK.IPluginBase = class {
        constructor(t) {
            QA.zt(t),
            this._class = new.target;
            const i = QA.v(self.si, t);
            this._info = new window.SDK.IPluginInfo(i);
            const e = QA.v(QA.HBn, this);
            e.ODn(this._class),
            e.DDn(i),
            tR.set(this, e)
        }
        Release() {
            this._class = null,
            this._info = null
        }
        MLn() {
            return tR.get(this)
        }
        static Register(t, i) {
            QA.zt(t),
            QA.qd(i),
            QA.Di.addEventListener("load", e => {
                QA.Di.Li(t, i)
            }
            )
        }
    }
}
{
    const iR = self.t
      , eR = new WeakMap;
    window.SDK.IPluginInfo = class {
        constructor(t) {
            iR.U(t, self.si),
            eR.set(this, t)
        }
        SetName(t) {
            eR.get(this).I(t)
        }
        SetDescription(t) {
            eR.get(this).k(t)
        }
        SetVersion(t) {
            eR.get(this).P(t)
        }
        SetCategory(t) {
            eR.get(this).S(t)
        }
        SetAuthor(t) {
            eR.get(this).B(t)
        }
        SetHelpUrl(t) {
            eR.get(this).L(t)
        }
        SetPluginType(t) {
            eR.get(this).Ei(t)
        }
        SetIcon(t, i) {
            eR.get(this).CA(t, i)
        }
        SetIsResizable(t) {
            eR.get(this).Bi(t)
        }
        SetIsRotatable(t) {
            eR.get(this).Ui(t)
        }
        SetSupportsZElevation(t) {
            eR.get(this).$i(t)
        }
        SetHasImage(t) {
            eR.get(this).Hi(t)
        }
        SetDefaultImageURL(t) {
            eR.get(this).Yx(t)
        }
        SetHasAnimations(t) {
            eR.get(this).fw(t)
        }
        SetIsTiled(t) {
            eR.get(this).gM(t)
        }
        SetIsFont(t) {
            eR.get(this).$x(t)
        }
        SetHasTilemap(t) {
            eR.get(this).PM(t)
        }
        SetIsDeprecated(t) {
            eR.get(this).kr(t)
        }
        SetIsSingleGlobal(t) {
            eR.get(this).ni(t)
        }
        SetSupportsEffects(t) {
            eR.get(this).Wi(t)
        }
        SetMustPreDraw(t) {
            eR.get(this).Yi(t)
        }
        SetIs3D(t) {
            eR.get(this).ma(t)
        }
        SetSupportsColor(t) {
            eR.get(this).Xi(t)
        }
        SetCanBeBundled(t) {
            eR.get(this).sLn(t)
        }
        SetUsesJquery(t) {
            (() => {})("[SDK] SetUsesJquery() is deprecated and no longer has any effect")
        }
        AddCommonPositionACEs() {
            eR.get(this).qi()
        }
        AddCommonSizeACEs() {
            eR.get(this).Ji()
        }
        AddCommonAngleACEs() {
            eR.get(this).Qi()
        }
        AddCommonAppearanceACEs() {
            eR.get(this).Ki()
        }
        AddCommonZOrderACEs() {
            eR.get(this).Zi()
        }
        AddCommonSceneGraphACEs() {
            eR.get(this).ds()
        }
        SetProperties(t) {
            eR.get(this).O(t.map(t => self.i.iFn(t)))
        }
        AddCordovaPluginReference(t) {
            eR.get(this).Cr({
                id: t.id,
                version: t.version || "",
                source: t.source || "default",
                platform: t.platform || "all",
                bie: t.plugin,
                xLn: t.variables
            })
        }
        AddCordovaResourceFile(t) {
            eR.get(this).oLn({
                src: t.src,
                target: t.target || "",
                platform: t.platform || "all"
            })
        }
        AddFileDependency(t) {
            eR.get(this).vt({
                filename: t.filename,
                Vt: t.fileType || "",
                kLn: t.scriptType || "",
                type: t.type,
                platform: t.platform || "all"
            })
        }
        AddRemoteScriptDependency(t, i="") {
            eR.get(this).pl(t, i)
        }
        SetSupportedRuntimes() {
            (() => {})("[SDK] SetSupportedRuntimes() is deprecated and no longer has any effect")
        }
        SetRuntimeModuleMainScript(t) {
            eR.get(this).mLn(t)
        }
        AddC3RuntimeScript(t) {
            eR.get(this).Ke(t)
        }
        SetC3RuntimeScripts(t) {
            eR.get(this).fLn(t)
        }
        SetDOMSideScripts(t) {
            eR.get(this).vr(t)
        }
        SetAndroidXEnabled(t) {
            (() => {})("[SDK] SetAndroidXEnabled() is deprecated and no longer has any effect")
        }
        SetGooglePlayServicesEnabled(t) {
            eR.get(this).uLn(t)
        }
        SetWrapperExportProperties(t, i) {
            eR.get(this).dLn(t, i)
        }
        SetScriptInterfaceNames(t) {
            eR.get(this).C({
                M: t.instance,
                objectType: t.objectType,
                bie: t.plugin
            })
        }
        SetTypeScriptDefinitionFiles(t) {
            eR.get(this).T(t)
        }
    }
}
window.SDK.PluginProperty = class {
    constructor(t, i, e) {
        this.lVt = t,
        this.phs = i,
        this.gTt = e
    }
    Vdt() {
        return this.lVt
    }
    vR() {
        return this.phs
    }
    eFn() {
        return this.gTt
    }
}
;
{
    const sR = self.t
      , nR = new WeakMap;
    window.SDK.ITypeBase = class {
        constructor(t, i) {
            this._sdkPlugin = t,
            this._objectType = i
        }
        qBn(t, i) {
            const e = sR.v(sR.XBn, t, i, this);
            return nR.set(this, e),
            e
        }
        GetObjectType() {
            return this._objectType
        }
    }
}
{
    const rR = self.t
      , hR = new WeakMap;
    window.SDK.IInstanceBase = class {
        constructor(t, i) {
            this._sdkType = t,
            this._inst = i
        }
        JBn(t, i) {
            const e = rR.v(rR.ZBn, t, i, this);
            return this.CYe(e),
            e
        }
        CYe(t) {
            hR.set(this, t)
        }
        Release() {}
        OnCreate() {}
        OnAfterCreate() {}
        OnPropertyChanged(t, i) {}
        OnTimelinePropertyChanged(t, i, e) {}
        OnExitTimelineEditMode() {}
        LoadC2Property(t, i) {
            return !1
        }
        GetObjectType() {
            return this._sdkType.GetObjectType()
        }
        GetProject() {
            return this._inst.GetProject()
        }
        GetInstance() {
            return this._inst
        }
    }
}
{
    const oR = self.t
      , aR = (new WeakMap,
    new window.SDK.Rect(0,0,1,1));
    window.SDK.IWorldInstanceBase = class extends window.SDK.IInstanceBase {
        constructor(t, i) {
            super(t, i),
            this._isLoadingTexture = !1,
            this._isWebGLTextureLoading = !1,
            this._hadWebGLTextureError = !1,
            this._webGLTexRect = aR,
            this._onWebGLContextLost = null
        }
        JBn(t, i) {
            const e = oR.v(oR.iUn, t, i, this);
            return this.CYe(e),
            e
        }
        Draw(t, i) {
            oR.E4()
        }
        OnPlacedInLayout() {}
        GetTexture(t) {
            if (oR.Mw(t, window.SDK.IAnimationFrame),
            !t)
                return null;
            const i = t.GetCachedWebGLTexture();
            return i ? (this._webGLTexRect = t.GetTexRect(),
            i) : (this._isLoadingTexture || (this._isWebGLTextureLoading = !0,
            t.LoadWebGLTexture().then(t => {
                this._isWebGLTextureLoading = !1
            }
            ).catch(t => {
                console.error("Error loading texture:", t),
                this._hadWebGLTextureError = !0
            }
            )),
            null)
        }
        GetTexRect() {
            return this._webGLTexRect
        }
        HadTextureError() {
            return this._hadWebGLTextureError
        }
        IsOriginalSizeKnown() {
            return !1
        }
        GetOriginalWidth() {
            oR.E4()
        }
        GetOriginalHeight() {
            oR.E4()
        }
        HasDoubleTapHandler() {
            return !1
        }
        OnDoubleTap() {
            oR.E4()
        }
    }
}
{
    const lR = self.t
      , uR = new WeakMap;
    window.SDK.IBehaviorBase = class {
        constructor(t) {
            lR.zt(t),
            this._class = new.target;
            const i = lR.v(self.V, t);
            this._info = new window.SDK.IBehaviorInfo(i);
            const e = lR.v(lR.eUn, this);
            e.ODn(this._class),
            e.DDn(i),
            uR.set(this, e)
        }
        Release() {
            this._class = null,
            this._info = null
        }
        wBn() {
            return uR.get(this)
        }
        static Register(t, i) {
            lR.zt(t),
            lR.qd(i),
            lR.F.addEventListener("load", e => {
                lR.F._(t, i)
            }
            )
        }
    }
}
{
    const cR = self.t
      , dR = new WeakMap;
    window.SDK.IBehaviorInfo = class {
        constructor(t) {
            cR.U(t, self.V),
            dR.set(this, t)
        }
        SetName(t) {
            dR.get(this).I(t)
        }
        SetDescription(t) {
            dR.get(this).k(t)
        }
        SetVersion(t) {
            dR.get(this).P(t)
        }
        SetCategory(t) {
            dR.get(this).S(t)
        }
        SetAuthor(t) {
            dR.get(this).B(t)
        }
        SetHelpUrl(t) {
            dR.get(this).L(t)
        }
        SetIcon(t, i) {
            dR.get(this).CA(t, i)
        }
        SetIsOnlyOneAllowed(t) {
            dR.get(this).H(t)
        }
        SetIsDeprecated(t) {
            dR.get(this).kr(t)
        }
        SetCanBeBundled(t) {
            dR.get(this).sLn(t)
        }
        SetProperties(t) {
            dR.get(this).O(t.map(t => self.i.iFn(t)))
        }
        AddCordovaPluginReference(t) {
            dR.get(this).Cr({
                id: t.id,
                version: t.version || "",
                source: t.source || "default",
                platform: t.platform || "all"
            })
        }
        AddFileDependency(t) {
            dR.get(this).vt({
                filename: t.filename,
                Vt: t.fileType || "",
                kLn: t.scriptType || "",
                type: t.type,
                platform: t.platform || "all"
            })
        }
        AddRemoteScriptDependency(t, i="") {
            dR.get(this).pl(t, i)
        }
        SetRuntimeModuleMainScript(t) {
            dR.get(this).mLn(t)
        }
        AddC3RuntimeScript(t) {
            dR.get(this).Ke(t)
        }
        SetC3RuntimeScripts(t) {
            dR.get(this).fLn(t)
        }
        SetSupportedRuntimes() {
            (() => {})("[SDK] SetSupportedRuntimes() is deprecated and no longer has any effect")
        }
        SetScriptInterfaceNames(t) {
            dR.get(this).C({
                M: t.instance,
                akt: t.behaviorType,
                behavior: t.behavior
            })
        }
        SetTypeScriptDefinitionFiles(t) {
            dR.get(this).T(t)
        }
    }
}
{
    const fR = self.t
      , pR = new WeakMap;
    window.SDK.IBehaviorTypeBase = class {
        constructor(t, i) {
            this._sdkBehavior = t,
            this._behaviorType = i
        }
        nUn(t, i) {
            const e = fR.v(fR.rUn, t, i, this);
            return pR.set(this, e),
            e
        }
    }
}
{
    const mR = self.t
      , wR = new WeakMap;
    window.SDK.IBehaviorInstanceBase = class {
        constructor(t, i) {
            this._sdkBehaviorType = t,
            this._behaviorInstance = i
        }
        oUn(t, i) {
            const e = mR.v(mR.aUn, t, i, this);
            return wR.set(this, e),
            e
        }
        Release() {}
        OnCreate() {}
        OnPropertyChanged(t, i) {}
        GetBehaviorInstance() {
            return this._behaviorInstance
        }
        GetSdkBehaviorType() {
            return this._sdkBehaviorType
        }
    }
}
{
    const gR = self.t
      , yR = new WeakMap;
    window.SDK.IObjectClass = class {
        constructor(t) {
            gR.U(t, window.EF),
            yR.set(this, t)
        }
        static Oze(t) {
            return gR.U(t, window.SDK.IObjectClass),
            yR.get(t)
        }
        GetProject() {
            return yR.get(this).yn().moi()
        }
        GetName() {
            return yR.get(this).Fa()
        }
        Delete() {
            yR.get(this).lD()
        }
    }
}
{
    const bR = self.t
      , vR = new WeakMap;
    window.SDK.IObjectType = class extends window.SDK.IObjectClass {
        constructor(t) {
            bR.U(t, window.aF),
            super(t),
            vR.set(this, t)
        }
        static Oze(t) {
            return bR.U(t, window.SDK.IObjectType),
            vR.get(t)
        }
        GetImage() {
            return vR.get(this).mn().Egs()
        }
        EditImage() {
            bR.qs.Ys.$s("AnimationsEditor").Xs(vR.get(this))
        }
        GetAnimations() {
            return [...vR.get(this).Bl()].map(t => t.Zms())
        }
        EditAnimations() {
            this.EditImage()
        }
        async AddAnimation(t, i, e, s) {
            bR.Kq(t);
            const n = vR.get(this)
              , r = bR.v(self.gy, n, t || "Animation 1")
              , h = r.Zms();
            return await h.AddFrame(i, e, s),
            n.eR().cR(r),
            h
        }
        CreateWorldInstance(t) {
            const i = vR.get(this).KY(window.SDK.ILayer.Oze(t));
            return i.Fi(),
            i.jr(),
            new window.SDK.IWorldInstance(i)
        }
        GetAllInstances() {
            return [...vR.get(this)._s()].map(t => new window.SDK.IWorldInstance(t))
        }
        IsInContainer() {
            return vR.get(this).z8()
        }
        GetContainer() {
            const t = vR.get(this).K8();
            return t ? t.dcs() : null
        }
        CreateContainer(t) {
            return vR.get(this).cre(t.map(t => vR.get(t))).dcs()
        }
    }
}
{
    const SR = self.t
      , xR = new WeakMap;
    window.SDK.IFamily = class extends window.SDK.IObjectClass {
        constructor(t) {
            SR.U(t, window.tu),
            super(t),
            xR.set(this, t)
        }
        GetMembers() {
            return [...xR.get(this).iu()].map(t => t.Bds())
        }
        SetMembers(t) {
            const i = xR.get(this)
              , e = [];
            for (const s of t) {
                const t = window.SDK.IObjectClass.Oze(s);
                if (!i.XH(t, !1))
                    throw new Error(`object type '${t.Fa()}' incompatible with family '${i.Fa()}`);
                e.push(t)
            }
            i.YN(e)
        }
    }
}
{
    const MR = self.t
      , ER = new WeakMap;
    window.SDK.IObjectInstance = class {
        constructor(t) {
            MR.U(t, window.AM),
            ER.set(this, t)
        }
        static Oze(t) {
            return MR.U(t, window.SDK.IObjectInstance),
            ER.get(t)
        }
        GetProject() {
            return ER.get(this).yn().moi()
        }
        GetObjectType() {
            return ER.get(this).Ds().Bds()
        }
        GetExternalSdkInstance() {
            const t = ER.get(this).Nl();
            return t instanceof MR.ZBn ? t.sFn() : null
        }
        GetUID() {
            return ER.get(this).Qd()
        }
        GetPropertyValue(t) {
            let i = ER.get(this).Rs(t);
            return i && i instanceof MR.Ha && (i = new window.SDK.Color(i.getR(),i.getG(),i.getB(),i.getA())),
            i
        }
        GetTimelinePropertyValue(t) {
            let i = ER.get(this).me(t);
            return i && i instanceof MR.Ha && (i = new window.SDK.Color(i.getR(),i.getG(),i.getB(),i.getA())),
            i
        }
        SetPropertyValue(t, i) {
            i && i instanceof window.SDK.Color && (i = new MR.Ha(i.getR(),i.getG(),i.getB(),i.getA())),
            ER.get(this).A(t, i)
        }
    }
}
{
    const CR = self.t
      , _R = new WeakMap;
    window.SDK.IWorldInstance = class extends window.SDK.IObjectInstance {
        constructor(t) {
            CR.U(t, window.Vb),
            super(t),
            _R.set(this, t)
        }
        GetBoundingBox() {
            return _R.get(this).VCs()
        }
        GetQuad() {
            return _R.get(this).LCs()
        }
        GetColor() {
            return _R.get(this).$Cs()
        }
        GetOpacity() {
            return _R.get(this).du()
        }
        SetOpacity(t) {
            _R.get(this).Rp(t)
        }
        SetX(t) {
            _R.get(this).kp(t)
        }
        GetX() {
            return _R.get(this)._a()
        }
        SetY(t) {
            _R.get(this).Gp(t)
        }
        GetY() {
            return _R.get(this).Da()
        }
        SetXY(t, i) {
            const e = _R.get(this);
            e.kp(t),
            e.Gp(i)
        }
        SetZElevation(t) {
            _R.get(this).Qne(t)
        }
        GetZElevation() {
            return _R.get(this).aK()
        }
        GetTotalZElevation() {
            return _R.get(this).$o()
        }
        SetWidth(t) {
            _R.get(this).Qx(t)
        }
        GetWidth() {
            return _R.get(this).ns()
        }
        SetHeight(t) {
            _R.get(this).Kx(t)
        }
        GetHeight() {
            return _R.get(this).Kn()
        }
        SetSize(t, i) {
            _R.get(this).Hr(t, i)
        }
        SetOriginX(t) {
            _R.get(this)._c(t)
        }
        GetOriginX() {
            return _R.get(this).Pw()
        }
        SetOriginY(t) {
            _R.get(this).Dc(t)
        }
        GetOriginY() {
            return _R.get(this).Vw()
        }
        SetOrigin(t, i) {
            _R.get(this).Ow(t, i)
        }
        GetAngle() {
            return _R.get(this).es()
        }
        SetAngle(t) {
            _R.get(this)._p(t)
        }
        GetLayer() {
            return _R.get(this).sl().jzs()
        }
        GetLayout() {
            return _R.get(this).qm().QJs()
        }
        ApplyBlendMode(t) {
            _R.get(this).Hn(window.SDK.Gfx.IWebGLRenderer.Oze(t))
        }
    }
}
{
    const TR = self.t
      , IR = new WeakMap;
    window.SDK.IAnimation = class {
        constructor(t) {
            TR.U(t, window.gy),
            IR.set(this, t)
        }
        GetName() {
            return IR.get(this).Fa()
        }
        GetObjectType() {
            return IR.get(this).Ds().Bds()
        }
        GetFrames() {
            return [...IR.get(this).frames()].map(t => t.Egs())
        }
        async AddFrame(t, i, e) {
            TR.Mw(t, Blob),
            TR.cO(i),
            TR.cO(e);
            const s = IR.get(this)
              , n = TR.v(self.Iw, s.Ds(), s);
            return s.uQ(n),
            t ? "number" == typeof i && "number" == typeof e ? n.fQ(t, i, e) : await n.Nfs(t) : await n.Mfs(i, e),
            n.Egs()
        }
        SetSpeed(t) {
            IR.get(this).xms(t)
        }
        GetSpeed() {
            return IR.get(this).Zb()
        }
        SetLooping(t) {
            IR.get(this).Ems(!!t)
        }
        IsLooping() {
            return IR.get(this).ey()
        }
        SetPingPong(t) {
            IR.get(this).Zce(!!t)
        }
        IsPingPong() {
            return IR.get(this).ty()
        }
        SetRepeatCount(t) {
            IR.get(this).Qce(t)
        }
        GetRepeatCount() {
            return IR.get(this).sy()
        }
        SetRepeatTo(t) {
            IR.get(this)._ms(t)
        }
        GetRepeatTo() {
            return IR.get(this).iy()
        }
        Delete() {
            const t = IR.get(this);
            if (t.Ds().Rds() < 2)
                throw new Error("cannot delete last animation");
            t.lD()
        }
    }
}
{
    const PR = self.t
      , GR = new WeakMap;
    window.SDK.IAnimationFrame = class {
        constructor(t) {
            PR.U(t, window.Iw),
            GR.set(this, t)
        }
        GetObjectType() {
            return GR.get(this).Ds().Bds()
        }
        GetWidth() {
            return GR.get(this).ns()
        }
        GetHeight() {
            return GR.get(this).Kn()
        }
        GetCachedWebGLTexture() {
            return window.SDK.Gfx.IWebGLTexture.cUn(GR.get(this).Trs())
        }
        GetTexRect() {
            return GR.get(this).nos()
        }
        async LoadWebGLTexture() {
            const t = await GR.get(this).Ors();
            return window.SDK.Gfx.IWebGLTexture.cUn(t)
        }
        GetBlob() {
            return GR.get(this).xc()
        }
        ReplaceBlobAndDecode(t) {
            return GR.get(this).NRt(t)
        }
        SetDuration(t) {
            GR.get(this).Mws(t)
        }
        GetDuration() {
            return GR.get(this).Kb()
        }
        GetOriginX() {
            return GR.get(this).Pw()
        }
        SetOriginX(t) {
            GR.get(this)._c(t)
        }
        GetOriginY() {
            return GR.get(this).Vw()
        }
        SetOriginY(t) {
            GR.get(this).Dc(t)
        }
        AddImagePoint(t, i, e) {
            return GR.get(this).Bws(t, i, e).ems()
        }
        GetImagePoints() {
            return [...GR.get(this).ims()].map(t => t.ems())
        }
        GetCollisionPoly() {
            return GR.get(this).Hps()
        }
        Delete() {
            const t = GR.get(this);
            if (t.mx().Ib() < 2)
                throw new Error("cannot delete last animation frame");
            t.lD()
        }
    }
}
{
    const AR = self.t
      , RR = new WeakMap;
    window.SDK.IImagePoint = class {
        constructor(t) {
            AR.U(t, window.Kps),
            RR.set(this, t)
        }
        GetAnimationFrame() {
            return RR.get(this).Rx().Egs()
        }
        GetName() {
            return RR.get(this).Fa()
        }
        SetName(t) {
            RR.get(this).I(t)
        }
        GetX() {
            return RR.get(this)._a()
        }
        SetX(t) {
            RR.get(this).kp(t)
        }
        GetY() {
            return RR.get(this).Da()
        }
        SetY(t) {
            return RR.get(this).Gp(t)
        }
    }
}
{
    const kR = self.t
      , OR = new WeakMap;
    window.SDK.ICollisionPoly = class {
        constructor(t) {
            kR.U(t, window.Hm),
            OR.set(this, t)
        }
        Reset() {
            OR.get(this).Bg()
        }
        IsDefault() {
            return OR.get(this).uI()
        }
        GetPoints() {
            return OR.get(this).xps()
        }
        SetPoints(t) {
            if (kR._D(t),
            t.length < 6 || t.length % 2 != 0)
                throw new Error("invalid points array");
            OR.get(this).Eps(t)
        }
    }
}
{
    const DR = self.t
      , FR = new WeakMap;
    window.SDK.IContainer = class {
        constructor(t) {
            DR.U(t, window.Yls),
            FR.set(this, t)
        }
        IsActive() {
            return FR.get(this).Wp()
        }
        GetMembers() {
            return [...FR.get(this).iu()].map(t => t.Bds())
        }
        SetSelectMode(t) {
            FR.get(this).ire(t)
        }
        GetSelectMode() {
            return FR.get(this).vq()
        }
        RemoveObjectType(t) {
            const i = FR.get(this)
              , e = window.SDK.IObjectClass.Oze(t);
            i.ZN(e)
        }
    }
}
{
    const LR = self.t
      , BR = new WeakMap;
    window.SDK.IBehaviorType = class {
        constructor(t) {
            LR.U(t, window.bte),
            BR.set(this, t)
        }
        GetProject() {
            return BR.get(this).yn().moi()
        }
        GetName() {
            return BR.get(this).Fa()
        }
    }
}
{
    const UR = self.t
      , NR = new WeakMap;
    window.SDK.IBehaviorInstance = class {
        constructor(t) {
            UR.U(t, window.mas),
            NR.set(this, t)
        }
        GetProject() {
            return NR.get(this).yn().moi()
        }
        GetPropertyValue(t) {
            let i = NR.get(this).Rs(t);
            return i && i instanceof UR.Ha && (i = new window.SDK.Color(i.getR(),i.getG(),i.getB(),i.getA())),
            i
        }
        SetPropertyValue(t, i) {
            i && i instanceof window.SDK.Color && (i = new UR.Ha(i.getR(),i.getG(),i.getB(),i.getA())),
            NR.get(this).A(t, i)
        }
        GetObjectInstance() {
            const t = NR.get(this).Km();
            return t instanceof self.Vb ? new window.SDK.IWorldInstance(t) : new window.SDK.IObjectInstance(t)
        }
        GetExternalSdkInstance() {
            const t = NR.get(this).Nl();
            return t instanceof UR.aUn ? t.uUn() : null
        }
    }
}
{
    const jR = self.t
      , $R = new WeakMap;
    window.SDK.IProject = class {
        constructor(t) {
            jR.U(t, window.gh),
            $R.set(this, t)
        }
        GetName() {
            return $R.get(this).Fa()
        }
        GetRuntime() {
            return (() => {})("[SDK] IProject.GetRuntime() is deprecated and always returns 'c3'"),
            "c3"
        }
        GetSystemType() {
            return $R.get(this).gkt().Bds()
        }
        GetSingleGlobalObjectType(t) {
            jR.zt(t);
            const i = $R.get(this).Ejs(t);
            return i ? i.Bds() : null
        }
        async CreateObjectType(t, i) {
            const e = $R.get(this)
              , s = jR.Di.Jm(t, e).ZA(e, e.YA(i));
            return await s.Mfs(),
            e.zH().cR(s),
            s.Bds()
        }
        CreateFamily(t, i) {
            if (jR.Kq(t),
            jR.YJ(i, window.SDK.IObjectType),
            !i.length)
                throw new Error("no family members provided");
            const e = $R.get(this);
            t = (t = self.EF.lQ(t || "", !0)) ? e.YA(t) : e.KN();
            const s = window.SDK.IObjectType.Oze(i[0]).Ja()
              , n = jR.v(self.tu, e, s, t);
            return n.YN(i.map(t => window.SDK.IObjectType.Oze(t))),
            e.WN(n),
            n.bps()
        }
        GetObjectTypeByName(t) {
            jR.zt(t);
            const i = $R.get(this).gR(t);
            return i ? i.Bds() : null
        }
        GetFamilyByName(t) {
            jR.zt(t);
            const i = $R.get(this).jR(t);
            return i ? i.bps() : null
        }
        GetObjectClassByName(t) {
            jR.zt(t);
            const i = $R.get(this).JYs(t);
            return i instanceof self.aF ? i.Bds() : i instanceof self.tu ? i.bps() : null
        }
        GetObjectClassBySID(t) {
            jR.Ge(t);
            const i = $R.get(this).Zc(t);
            return i instanceof self.aF ? i.Bds() : i instanceof self.tu ? i.bps() : null
        }
        GetInstanceByUID(t) {
            jR.Ge(t);
            const i = $R.get(this).Xgs(t);
            return i ? i instanceof self.Vb ? new window.SDK.IWorldInstance(i) : new window.SDK.IObjectInstance(i) : null
        }
        AddOrReplaceProjectFile(t, i, e="general") {
            $R.get(this).Rni(e).wQ(t, i)
        }
        GetProjectFileBySID(t) {
            jR.Ge(t);
            const i = $R.get(this).io(t);
            return i ? i.vAs() : null
        }
        GetProjectFileByName(t) {
            jR.zt(t);
            const i = $R.get(this).U5t(t);
            return i ? i.vAs() : null
        }
        GetProjectFileByExportPath(t) {
            jR.zt(t);
            const i = $R.get(this).Lni(t);
            return i ? i.vAs() : null
        }
        ShowImportAudioDialog(t) {
            const i = $R.get(this);
            jR.qs.Ys.$s("ImportAudio").o2t(t, i, document.body)
        }
        EnsureFontLoaded(t) {
            return $R.get(this).eM(t)
        }
        UndoPointChangeObjectInstancesProperty(t, i) {
            t = Array.isArray(t) ? t.map(t => window.SDK.IObjectInstance.Oze(t)) : [window.SDK.IObjectInstance.Oze(t)],
            $R.get(this).Ka(new self.tl.Za(t,i))
        }
    }
}
{
    const zR = self.t
      , VR = new WeakMap;
    window.SDK.ILayout = class {
        constructor(t) {
            zR.U(t, window.fA),
            VR.set(this, t)
        }
        GetName() {
            return VR.get(this).Fa()
        }
        GetProject() {
            return VR.get(this).yn().moi()
        }
        GetEventSheet() {
            const t = VR.get(this).$R();
            return t ? t.GWs() : null
        }
        GetAllLayers() {
            return [...VR.get(this).UR()].map(t => t.jzs())
        }
    }
}
{
    const WR = self.t
      , HR = new WeakMap;
    window.SDK.ILayer = class {
        constructor(t) {
            WR.U(t, window.TR),
            HR.set(this, t)
        }
        static Oze(t) {
            return WR.U(t, window.SDK.ILayer),
            HR.get(t)
        }
        GetName() {
            return HR.get(this).Fa()
        }
        GetLayout() {
            return HR.get(this).qm().QJs()
        }
    }
}
{
    const KR = self.t
      , qR = new WeakMap;
    window.SDK.IProjectFile = class {
        constructor(t) {
            KR.U(t, window.fh),
            qR.set(this, t)
        }
        GetName() {
            return qR.get(this).Fa()
        }
        GetProject() {
            return qR.get(this).yn().moi()
        }
        GetBlob() {
            return qR.get(this).xc()
        }
    }
}
{
    const XR = self.t
      , YR = new WeakMap;
    window.SDK.IEventSheet = class {
        constructor(t) {
            XR.U(t, window.lF),
            YR.set(this, t)
        }
        GetName() {
            return YR.get(this).Fa()
        }
        GetProject() {
            return YR.get(this).yn().moi()
        }
        GetRoot() {
            return YR.get(this).iN().xKs()
        }
    }
}
{
    const JR = self.t
      , ZR = new WeakMap;
    window.SDK.IEventParentRow = class {
        constructor(t) {
            JR.U(t, window.Tmt),
            ZR.set(this, t)
        }
        async AddEventBlock() {
            const t = ZR.get(this)
              , i = JR.v(self.lyt, t);
            return await t.hN(i),
            i.xKs()
        }
    }
}
{
    const QR = self.t
      , tk = new WeakMap;
    function ik(t, i) {
        if ("string" == typeof i)
            return i;
        if ("number" == typeof i)
            return i.toString();
        if (i && i instanceof window.SDK.IObjectClass)
            return window.SDK.IObjectClass.Oze(i);
        if (t instanceof globalThis.ESt)
            return !!i;
        throw TypeError("unsupported event parameter")
    }
    window.SDK.IEventBlock = class extends window.SDK.IEventParentRow {
        constructor(t) {
            QR.U(t, window.lyt),
            super(t),
            tk.set(this, t)
        }
        AddCondition(t, i, e, s) {
            if (QR.U(t, window.SDK.IObjectClass),
            QR.zt(e),
            QR.zAt(s),
            !QR.fO(i))
                throw new Error("value passed for reserved parameter");
            const n = tk.get(this)
              , r = window.SDK.IObjectClass.Oze(t)
              , h = r.Ja().li(e)
              , o = QR.v(self.fyt, n, r, null, h);
            for (const t of o.parameters()) {
                const i = t.hI();
                if (i >= s.length)
                    throw new RangeError("not enough parameters passed");
                t.Set(ik(t, s[i]))
            }
            n.Jyt(o)
        }
        AddAction(t, i, e, s) {
            if (QR.U(t, window.SDK.IObjectClass),
            QR.zt(e),
            QR.zAt(s),
            !QR.fO(i))
                throw new Error("value passed for reserved parameter");
            const n = tk.get(this)
              , r = window.SDK.IObjectClass.Oze(t)
              , h = r.Ja().ci(e)
              , o = QR.v(self.ukt, n, r, null, h);
            for (const t of o.parameters()) {
                const i = t.hI();
                if (i >= s.length)
                    throw new RangeError("not enough parameters passed");
                t.Set(ik(t, s[i]))
            }
            n.Ayt(o)
        }
    }
}
{
    const ek = self.t
      , sk = new WeakMap;
    window.SDK.Gfx.IWebGLRenderer = class {
        constructor(t) {
            sk.set(this, t)
        }
        static Oze(t) {
            return sk.get(t)
        }
        SetAlphaBlend() {
            sk.get(this).tr()
        }
        SetColorFillMode() {
            sk.get(this).er()
        }
        SetTextureFillMode() {
            sk.get(this).Yr()
        }
        SetSmoothLineFillMode() {
            sk.get(this).Wc()
        }
        SetColorRgba(t, i, e, s) {
            sk.get(this).ir(t, i, e, s)
        }
        SetColor(t) {
            ek.U(t, window.SDK.Color),
            sk.get(this).Xn(t.mp)
        }
        SetOpacity(t) {
            sk.get(this).Rp(t)
        }
        ResetColor() {
            sk.get(this).qr()
        }
        SetCurrentZ(t) {
            sk.get(this).lK(t)
        }
        GetCurrentZ() {
            return sk.get(this).hgn()
        }
        Rect(t) {
            ek.U(t, window.SDK.Rect),
            sk.get(this).Rect(t.hrt)
        }
        Rect2(t, i, e, s) {
            sk.get(this).E9(t, i, e, s)
        }
        Quad(t) {
            ek.U(t, window.SDK.Quad),
            sk.get(this).Nn(t.yys)
        }
        Quad2(t, i, e, s, n, r, h, o) {
            sk.get(this).Cgn(t, i, e, s, n, r, h, o)
        }
        Quad3(t, i) {
            ek.U(t, window.SDK.Quad),
            ek.U(i, window.SDK.Rect),
            sk.get(this).gr(t.yys, i.hrt)
        }
        Quad4(t, i) {
            ek.U(t, window.SDK.Quad),
            ek.U(i, window.SDK.Quad),
            sk.get(this).Ac(t.yys, i.yys)
        }
        Quad3D(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            ek.U(d, window.SDK.Rect),
            sk.get(this).eb(t, i, e, s, n, r, h, o, a, l, u, c, d.hrt)
        }
        Quad3D2(t, i, e, s, n, r, h, o, a, l, u, c, d) {
            ek.U(d, window.SDK.Quad),
            sk.get(this).ob(t, i, e, s, n, r, h, o, a, l, u, c, d.yys)
        }
        ConvexPoly(t) {
            ek._D(t),
            sk.get(this).Qg(t)
        }
        Line(t, i, e, s) {
            sk.get(this).Ra(t, i, e, s)
        }
        TexturedLine(t, i, e, s, n, r) {
            sk.get(this).YJs(t, i, e, s, n, r)
        }
        LineRect(t, i, e, s) {
            sk.get(this).D9(t, i, e, s)
        }
        LineRect2(t) {
            ek.U(t, window.SDK.Rect),
            sk.get(this).ta(t.hrt)
        }
        LineQuad(t) {
            ek.U(t, window.SDK.Quad),
            sk.get(this).$r(t.yys)
        }
        PushLineWidth(t) {
            sk.get(this).Bc(t)
        }
        PopLineWidth() {
            sk.get(this).Xc()
        }
        PushLineCap(t) {
            sk.get(this).xgn(t)
        }
        PopLineCap() {
            sk.get(this).Yc()
        }
        SetTexture(t) {
            const i = window.SDK.Gfx.IWebGLTexture;
            ek.Mw(t, i),
            sk.get(this).dr(t ? i.Oze(t) : null)
        }
        CreateWebGLText() {
            const t = sk.get(this).Lgn();
            return new window.SDK.Gfx.IWebGLText(t)
        }
        CreateRendererText() {
            const t = sk.get(this).Lgn();
            return new window.SDK.Gfx.IWebGLText(t)
        }
        CreateDynamicTexture(t, i, e) {
            const s = {
                On: (e = e || {}).wrapX || "clamp-to-edge",
                Pn: e.wrapY || "clamp-to-edge",
                Cn: e.sampling || "trilinear",
                Vxn: e.pixelFormat || "rgba8",
                wc: !e.hasOwnProperty("mipMap") || !!e.mipMap,
                bc: e.mipMapQuality || "default"
            };
            e.isTiled && ("repeat-x" !== e.tileType && "repeat" !== e.tileType && e.tileType || (s.On = "repeat"),
            "repeat-y" !== e.tileType && "repeat" !== e.tileType && e.tileType || (s.Pn = "repeat"));
            const n = sk.get(this).sK(t, i, s);
            return window.SDK.Gfx.IWebGLTexture.cUn(n)
        }
        UpdateTexture(t, i, e) {
            e = e || {};
            const s = window.SDK.Gfx.IWebGLTexture;
            ek.Mw(i, s);
            const n = s.Oze(i);
            sk.get(this).eK(t, n, {
                Wxn: !!e.premultiplyAlpha
            })
        }
        DeleteTexture(t) {
            const i = window.SDK.Gfx.IWebGLTexture;
            ek.Mw(t, i);
            const e = i.Oze(t);
            sk.get(this).pn(e)
        }
        DrawMesh(t, i, e, s) {
            sk.get(this).jo(t, i, e, s)
        }
    }
}
{
    const nk = new WeakMap;
    window.SDK.Gfx.IDrawParams = class {
        constructor(t) {
            nk.set(this, t)
        }
        GetDt() {
            return nk.get(this).dt
        }
        GetLayoutView() {
            return nk.get(this).Wr.IQ()
        }
    }
}
{
    const rk = self.t
      , hk = new WeakMap
      , ok = new WeakMap;
    window.SDK.Gfx.IWebGLTexture = class {
        constructor(t) {
            rk.cT(t, rk.ra.Hxn, rk.ra.cIn),
            hk.set(this, t),
            ok.set(t, this)
        }
        static cUn(t) {
            if (!t)
                return null;
            const i = ok.get(t);
            return i || new window.SDK.Gfx.IWebGLTexture(t)
        }
        static Oze(t) {
            return rk.U(t, window.SDK.Gfx.IWebGLTexture),
            hk.get(t)
        }
        GetWidth() {
            return hk.get(this).ns()
        }
        GetHeight() {
            return hk.get(this).Kn()
        }
    }
}
{
    const ak = self.t
      , lk = new WeakMap;
    window.SDK.Gfx.IWebGLText = class {
        constructor(t) {
            ak.U(t, ak.ra.na),
            lk.set(this, t)
        }
        Release() {
            lk.get(this).he()
        }
        SetFontName(t) {
            lk.get(this).cl(t)
        }
        SetFontSize(t) {
            lk.get(this).la(t)
        }
        SetLineHeight(t) {
            lk.get(this).xS(t)
        }
        SetBold(t) {
            lk.get(this).cM(t)
        }
        SetItalic(t) {
            lk.get(this).Xa(t)
        }
        SetColor(t) {
            ak.U(t, window.SDK.Color),
            lk.get(this).Xn(t.mp)
        }
        SetColorRgb(t, i, e) {
            lk.get(this).da(t, i, e)
        }
        SetHorizontalAlignment(t) {
            lk.get(this).ca(t)
        }
        SetVerticalAlignment(t) {
            lk.get(this).ua(t)
        }
        SetWordWrapMode(t) {
            lk.get(this).mS(t)
        }
        SetText(t) {
            lk.get(this).pa(t)
        }
        SetSize(t, i, e) {
            lk.get(this).Hr(t, i, e)
        }
        GetTexture() {
            const t = lk.get(this).Gn();
            return t ? window.SDK.Gfx.IWebGLTexture.cUn(t) : null
        }
        GetTexRect() {
            return new window.SDK.Rect(lk.get(this).Jr())
        }
        SetTextureUpdateCallback(t) {
            lk.get(this).aa = t
        }
        ReleaseTexture() {
            lk.get(this).mrs()
        }
        GetTextWidth() {
            return lk.get(this).$C()
        }
        GetTextHeight() {
            return lk.get(this).qC()
        }
    }
}
{
    const uk = self.t
      , ck = new WeakMap;
    window.SDK.UI.ILayoutView = class {
        constructor(t) {
            uk.U(t, window.lG),
            ck.set(this, t)
        }
        GetProject() {
            return ck.get(this).yn().moi()
        }
        GetZoomFactor() {
            return ck.get(this).oa()
        }
        LayoutToClientDeviceX(t) {
            return ck.get(this).zZ(t)
        }
        LayoutToClientDeviceY(t) {
            return ck.get(this).LZ(t)
        }
        SetDeviceTransform(t) {
            return ck.get(this).hl(window.SDK.Gfx.IWebGLRenderer.Oze(t))
        }
        SetDefaultTransform(t) {
            return ck.get(this).ol(window.SDK.Gfx.IWebGLRenderer.Oze(t))
        }
        Refresh() {
            ck.get(this).uz()
        }
        GetLayout() {
            return ck.get(this).qm().QJs()
        }
        GetActiveLayer() {
            return ck.get(this).MR().jzs()
        }
    }
}
{
    const dk = self.t;
    new WeakMap;
    window.SDK.UI.Util = class {
        static ShowLongTextPropertyDialog(t, i) {
            const e = dk.qs.Ys.$s("LongTextPropertyDialog");
            return e.Ya(i),
            e.Qa(t)
        }
        static AddDragDropFileImportHandler(t, i) {
            self.app.dUn(t, i)
        }
    }
}
{
    const fk = self.t
      , pk = self.lang;
    window.fUn = class extends globalThis.GDn {
        constructor(t, i) {
            super(),
            this.phs = t.id,
            this.rVt = t.name,
            this.i3t = t.version,
            this.hFn = t.author,
            this.Qxe = t["icon-type"] || "image/svg+xml",
            this.Zxe = "",
            this.pUn = t.website,
            this.qxe = self.app.Yse(t.documentation),
            this.Eos = t.description,
            this.mUn = t.stylesheets,
            this.SLt = i.source,
            this.N2t = i.files,
            this.wUn = [],
            this.gUn = [],
            this.BLn = null,
            this.Xus = null,
            this.Yus = null,
            this.qus = null,
            "built-in" === this.SLt && fk.jii() && (this.rVt = pk(`themes.${this.phs}.name`),
            this.Eos = pk(`themes.${this.phs}.description`))
        }
        he() {
            this.N2t = null,
            this.Zxe && (URL.revokeObjectURL(this.Zxe),
            this.Zxe = "");
            for (const t of this.wUn)
                URL.revokeObjectURL(t);
            fk.sc(this.wUn),
            super.he()
        }
        yUn() {
            if (!this.wUn.length)
                for (const t of this.mUn)
                    this.wUn.push(URL.createObjectURL(this.N2t[t]))
        }
        bUn(t) {
            return new Promise( (i, e) => {
                const s = document.createElement("link");
                s.rel = "stylesheet",
                s.onload = () => i(s),
                s.onerror = e,
                s.href = t,
                s.setAttribute("data-theme", this.vR()),
                document.head.appendChild(s)
            }
            )
        }
        async iXe() {
            const t = [];
            this.yUn();
            for (const i of this.wUn)
                t.push(this.bUn(i).then(t => this.gUn.push(t)));
            await Promise.all(t),
            fk.qs.oX.wXe()
        }
        async vUn() {
            const t = [];
            for (let i = 0, e = this.wUn.length; i < e; ++i) {
                const e = this.wUn[i]
                  , s = this.gUn[i];
                t.push(this.SUn(e, s))
            }
            await Promise.all(t),
            fk.qs.oX.wXe()
        }
        async SUn(t, i) {
            const e = await this.bUn(t);
            fk.qs.BW(i);
            const s = this.gUn.indexOf(i);
            self.assert(s >= 0, "cannot find stylesheet element"),
            this.gUn[s] = e
        }
        yYe() {
            return this.yUn(),
            this.wUn.slice(0)
        }
        vR() {
            return this.phs
        }
        Vdt() {
            return "theme"
        }
        Fa() {
            return this.rVt
        }
        dj() {
            return this.Eos
        }
        $te() {
            return this.i3t
        }
        Ote() {
            return this.hFn
        }
        NA() {
            return this.qxe
        }
        YMt() {
            return this.SLt
        }
        DZs() {
            return !1
        }
        Vpt() {
            return this.DZs()
        }
        Coe() {
            return !0
        }
        xUn() {
            return "image/svg+xml" === this.iAe() ? "icon.svg" : "icon.png"
        }
        emn() {
            return this.Zxe || (this.Zxe = URL.createObjectURL(this.N2t[this.xUn()])),
            this.Zxe
        }
        iAe() {
            return this.Qxe
        }
        JLn() {
            return "image/svg+xml" === this.iAe()
        }
        ZLn() {
            !this.BLn && this.JLn() && (this.BLn = fk.v(fk.qs.pAe, self.app, this.emn(), {
                name: "theme-" + this.vR()
            }))
        }
        xA() {
            return this.Xus || (this.ZLn(),
            this.BLn ? this.Xus = this.BLn.xA() : this.Xus = fk.qs.O_.mAe(this.emn(), self.app.T_(), {
                og: this.JLn()
            })),
            this.Xus
        }
        uj() {
            return this.Yus || (this.ZLn(),
            this.BLn ? this.Yus = this.BLn.uj() : this.Yus = fk.qs.O_.mAe(this.emn(), self.app.Gk(), {
                og: this.JLn()
            })),
            this.Yus
        }
        nus() {
            return this.qus || (this.ZLn(),
            this.BLn ? this.qus = this.BLn.nus() : this.qus = fk.qs.O_.mAe(this.emn(), self.app.BJt(), {
                og: this.JLn()
            })),
            this.qus
        }
        Igs(t) {
            switch (fk.zt(t),
            t) {
            case "small":
                return this.xA();
            case "medium":
                return this.uj();
            case "large":
                return this.nus();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        yhi() {
            return this.N2t._c3addon
        }
        static Zls(t, i) {
            let e = t.Fa().toLowerCase()
              , s = i.Fa().toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const mk = self.t
      , wk = self.lang
      , gk = mk.ek(import.meta.url)
      , yk = mk.tk(gk.URL);
    mk.p.ik(yk + "lang");
    const bk = new Set(["start-page-only", "project-file"]);
    window.MUn = class extends globalThis.GDn {
        constructor(t, i) {
            if (super(),
            this.phs = t.id,
            this.rVt = "",
            this.Eos = "",
            this.i3t = t.version,
            this.hFn = t.author,
            this.Qxe = t["icon-type"] || "image/svg+xml",
            this.Zxe = "",
            this.pUn = t.website,
            this.EUn = t["default-ui-layout"] || "games",
            this.CUn = t["example-browser-tags"] || [],
            this._Un = t["starting-point"],
            !bk.has(this._Un))
                throw new Error(`addon '${this.phs}' specifies invalid starting point '${this._Un}'`);
            this.TUn = t["starting-project-file"],
            this.Kdt = i.path,
            this.SLt = i.source,
            this.N2t = i.files;
            const e = t["tour-file-list"];
            if (!Array.isArray(e))
                throw new Error(`addon '${this.phs}' missing "tour-file-list" array`);
            for (const t of e) {
                if (this.N2t.hasOwnProperty(t))
                    throw new Error(`addon '${this.phs}' "tour-file-list" specifies duplicate filename '${t}'`);
                this.N2t[t] = null
            }
            this.BLn = null,
            this.Xus = null,
            this.Yus = null,
            this.qus = null,
            this.C2t = !1,
            this.i0e = !1,
            this.IUn = null,
            this.PUn = 1
        }
        he() {
            this.N2t = null,
            this.Zxe && (URL.revokeObjectURL(this.Zxe),
            this.Zxe = ""),
            super.he()
        }
        W7t() {
            if (this.C2t)
                throw new Error("tour already ready");
            mk.p.u(this.GUn()),
            this.rVt = wk(".name"),
            this.Eos = wk(".description"),
            mk.p.j(),
            this.C2t = !0
        }
        async SIt() {
            if (this.i0e)
                return;
            if (await Promise.all(Object.keys(this.N2t).map(async t => {
                if (this.N2t[t])
                    return;
                if (mk.jii() && t.endsWith("/en-US.json"))
                    return;
                const i = await mk.Kl(this.Kdt + t);
                this.N2t[t] = i
            }
            )),
            mk.jii() || (mk.lj.AUn(this.phs, this.N2t, "tourLang/"),
            await mk.p.SIt()),
            !this.N2t.hasOwnProperty("tour.json"))
                throw new Error(`tour addon '${this.phs}' missing tour.json file`);
            const t = (await mk.pes(this.N2t["tour.json"])).sections;
            if (!Array.isArray(t))
                throw new Error('missing "sections" array in tour addon');
            if (this.IUn = t.map(t => mk.v(self.RUn, this, t)),
            0 === this.IUn.length)
                throw new Error("tour sections array is empty");
            this.i0e = !0
        }
        vR() {
            return this.phs
        }
        Vdt() {
            return "tour"
        }
        GUn() {
            return `tours.${this.phs.toLowerCase()}`
        }
        Fa() {
            return this.rVt
        }
        dj() {
            return this.Eos
        }
        $te() {
            return this.i3t
        }
        Ote() {
            return this.hFn
        }
        kUn() {
            return this.pUn
        }
        OUn() {
            return this.CUn
        }
        DUn() {
            return this.Kdt + "thumbnail.webp"
        }
        FUn() {
            return this._Un
        }
        LUn() {
            if ("project-file" !== this.FUn())
                throw new Error("invalid starting point");
            const t = this.N2t[this.TUn];
            if (!t)
                throw new Error("missing starting project file");
            return t
        }
        YMt() {
            return this.SLt
        }
        BUn() {
            return this.EUn
        }
        DZs() {
            return !1
        }
        Vpt() {
            return this.DZs()
        }
        UUn() {
            return this.PUn++
        }
        NUn() {
            return this.PUn - 1
        }
        jUn() {
            return this.IUn.values()
        }
        *$Un() {
            for (const t of this.jUn())
                yield*t.crn()
        }
        Coe() {
            return !0
        }
        xUn() {
            return "image/svg+xml" === this.iAe() ? "icon.svg" : "icon.png"
        }
        emn() {
            return this.Zxe || (this.Zxe = URL.createObjectURL(this.N2t[this.xUn()])),
            this.Zxe
        }
        iAe() {
            return this.Qxe
        }
        JLn() {
            return "image/svg+xml" === this.iAe()
        }
        ZLn() {
            !this.BLn && this.JLn() && (this.BLn = mk.v(mk.qs.pAe, self.app, this.emn(), {
                name: "tour-" + this.vR()
            }))
        }
        xA() {
            return this.Xus || (this.ZLn(),
            this.BLn ? this.Xus = this.BLn.xA() : this.Xus = mk.qs.O_.mAe(this.emn(), self.app.T_(), {
                og: this.JLn()
            })),
            this.Xus
        }
        uj() {
            return this.Yus || (this.ZLn(),
            this.BLn ? this.Yus = this.BLn.uj() : this.Yus = mk.qs.O_.mAe(this.emn(), self.app.Gk(), {
                og: this.JLn()
            })),
            this.Yus
        }
        nus() {
            return this.qus || (this.ZLn(),
            this.BLn ? this.qus = this.BLn.nus() : this.qus = mk.qs.O_.mAe(this.emn(), self.app.BJt(), {
                og: this.JLn()
            })),
            this.qus
        }
        Igs(t) {
            switch (mk.zt(t),
            t) {
            case "small":
                return this.xA();
            case "medium":
                return this.uj();
            case "large":
                return this.nus();
            default:
                throw new Error("invalid icon size specifier")
            }
        }
        yhi() {
            return this.N2t._c3addon
        }
        zUn(t) {
            return mk.zt(t),
            this.N2t[t] || null
        }
        static Zls(t, i) {
            let e = t.Fa().toLowerCase()
              , s = i.Fa().toLowerCase();
            return e > s ? 1 : e < s ? -1 : 0
        }
    }
}
{
    const vk = self.t;
    window.RUn = class extends vk.Me {
        constructor(t, i) {
            if (vk.U(t, self.MUn),
            vk.Yq(i),
            super(),
            !Array.isArray(i.steps))
                throw new Error('missing "steps" array in section');
            if (this.VUn = t,
            this.phs = i.id,
            this.pXs = self.lang(this.GUn() + ".title"),
            this.ahn = i.steps.map(t => self.WUn.y_(this, t)).flat(),
            0 === this.ahn.length)
                throw new Error("tour section steps array is empty")
        }
        GUn() {
            return `${this.VUn.GUn()}.sections.${this.phs}`
        }
        HUn() {
            return this.VUn
        }
        vR() {
            return this.phs
        }
        crn() {
            return this.ahn.values()
        }
    }
}
{
    const Sk = self.t
      , xk = self.lang;
    window.KUn = class extends Sk.Me {
        constructor(t, i) {
            if (super(),
            this.qUn = t,
            this.phs = i.id,
            this.XUn = i["analytics-milestone"] || "",
            "string" != typeof this.phs)
                throw new Error("tour step missing 'id' property")
        }
        YUn() {
            throw new Error(`invalid tour step '${this.vR()}' in section '${this.JUn().vR()}'`)
        }
        JUn() {
            return this.qUn
        }
        HUn() {
            return this.JUn().HUn()
        }
        GUn() {
            return `${this.HUn().GUn()}.steps.${this.phs}`
        }
        ZUn(t) {
            return xk(this.GUn() + t)
        }
        QUn(t) {
            const i = this.ZUn(t);
            return i === Sk.p.Fl ? null : i
        }
        tNn(t) {
            const i = this.ZUn(t);
            return i === Sk.p.Fl ? xk(t) : i
        }
        vR() {
            return this.phs
        }
        iNn() {
            return this.XUn
        }
    }
}
{
    const Mk = self.t;
    let Ek = null;
    function Ck() {
        if (!Ek) {
            const t = self.eNn
              , i = self.WUn;
            Ek = new Map([["show-message", i.sNn], ["click-button", i.nNn], ["select-menu-item", i.rNn], ["create-object-type", i.ZA], ["rename-object-type", i.hNn], ["wait-for-place-object", i.oNn], ["import-image", i.aNn], ["modify-image", i.lNn], ["get-to-dialog", i.uNn], ["pick-create-object-type", i.cNn], ["pick-timeline-instance", i.dNn], ["pick-add-behavior", i.fNn], ["pick-event-object", i.pNn], ["pick-event-ac", i.mNn], ["enter-parameter", i.wNn], ["enter-script", i.gNn], ["edit-layout-view", i.yNn], ["wait", i.KTi], ["select-project-bar-item", i.bNn], ["change-property", i.fD], ["create-default-new-project", t.vNn], ["create-singleglobal-object", t.SNn], ["create-object-with-image", t.xNn], ["add-behaviors", t.MNn], ["add-event", t.Gmt], ["add-action", t.Ayt]])
        }
        return Ek
    }
    window.WUn = class extends self.KUn {
        constructor(t, i, e={}) {
            if (super(t, i),
            this.ENn = this.HUn().UUn(),
            this.CNn = e.message || this.ZUn(".text"),
            this._Nn = i.links || [],
            this.TNn = [],
            this.CNn.includes("[tip")) {
                const t = t => () => this.ZUn(`.text-tip${t + 1}`);
                for (let i = 0; i < 9; ++i)
                    this.TNn.push(t(i))
            }
        }
        static y_(t, i) {
            Mk.U(t, self.RUn),
            Mk.Yq(i);
            const e = i["step-type"]
              , s = Ck().get(e);
            if (!s)
                throw new Error(`invalid step-type '${e}'`);
            const n = Mk.v(s, t, i);
            return n instanceof self.eNn ? n.INn() : n
        }
        PNn() {
            Mk.E4()
        }
        GNn() {
            return this.ENn
        }
        ANn() {
            return 1 === this.GNn()
        }
        RNn() {
            return this.GNn() === this.HUn().NUn()
        }
        kNn() {
            return Mk.v(Mk.MC, this.CNn, {
                O0: !0,
                links: this._Nn.map(t => self.app.hEe(t, "GuidedTour-" + this.HUn().vR(), this.vR())),
                UBe: this.TNn
            })
        }
        ONn() {
            return "string" == typeof this.CNn && this.CNn !== Mk.p.Fl
        }
        DNn() {
            return !1
        }
    }
}
window.WUn.sNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.ONn() || this.YUn()
    }
    PNn() {
        return self.FNn.sNn
    }
    DNn() {
        return !0
    }
}
,
window.WUn.nNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.nJi = i.button,
        this.LNn = !!i["can-skip"],
        this.BNn = i["event-tag"],
        this.UNn = i.menu,
        this._es = i.items,
        this.NNn = i["created-event-tag"],
        this.ONn() && "string" == typeof this.nJi || this.YUn()
    }
    jNn() {
        return this.nJi
    }
    $Nn() {
        return this.LNn
    }
    zNn() {
        return this.BNn
    }
    VNn() {
        return this.UNn
    }
    UFt() {
        return this._es
    }
    WNn() {
        return this.NNn
    }
    PNn() {
        return self.FNn.nNn
    }
}
;
{
    const _k = new Set(["layout-view-context-menu", "animations-editor-imagepoints"]);
    window.WUn.rNn = class extends self.WUn {
        constructor(t, i, e={}) {
            super(t, i, e),
            this.UNn = i.menu,
            this._es = i.items,
            this.ONn() && "string" == typeof this.UNn && _k.has(this.UNn) && Array.isArray(this._es) || this.YUn()
        }
        VNn() {
            return this.UNn
        }
        UFt() {
            return this._es
        }
        PNn() {
            return self.FNn.rNn
        }
    }
}
window.WUn.ZA = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.ONn() || this.YUn()
    }
    PNn() {
        return self.FNn.ZA
    }
}
;
{
    const Tk = self.t;
    window.WUn.hNn = class extends self.WUn {
        constructor(t, i, e={}) {
            super(t, i, e),
            this.HNn = i["object-type-tag"],
            this.KNn = e.qNn || this.ZUn(".desired-name"),
            this.ONn() && "string" == typeof this.HNn && this.KNn && this.KNn !== Tk.p.Fl || this.YUn()
        }
        XNn() {
            return this.HNn
        }
        YNn() {
            return this.KNn
        }
        PNn() {
            return self.FNn.hNn
        }
    }
}
window.WUn.oNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.JNn = i["instance-tag"],
        this.itt = 0,
        this.stt = 0;
        const s = i["initial-size"];
        Array.isArray(s) && (2 !== s.length && this.YUn(),
        this.itt = s[0],
        this.stt = s[1]),
        this.ONn() || this.YUn()
    }
    PNn() {
        return self.FNn.oNn
    }
    ZNn() {
        return this.JNn
    }
    QNn() {
        return 0 !== this.itt || 0 !== this.stt
    }
    pji() {
        return this.itt
    }
    mji() {
        return this.stt
    }
}
;
{
    const Ik = self.t;
    window.WUn.aNn = class extends self.WUn {
        constructor(t, i, e={}) {
            if (super(t, i, e),
            this.An = i.image,
            this.hws = i["collision-poly"] || "",
            this.ONn() && "string" == typeof this.An || this.YUn(),
            this.bhs = this.HUn().zUn(this.An),
            !this.bhs)
                throw new Error(`import image step file '${this.An}' missing`)
        }
        tjn() {
            return Ik.des(this.An)
        }
        xc() {
            return this.bhs
        }
        ET() {
            return this.hws
        }
        PNn() {
            return self.FNn.aNn
        }
    }
}
window.WUn.lNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.ONn() || this.YUn()
    }
    PNn() {
        return self.FNn.lNn
    }
}
;
{
    const Pk = self.t
      , Gk = new Set(["behaviors"]);
    window.WUn.uNn = class extends self.WUn {
        constructor(t, i, e={}) {
            super(t, i, e),
            Pk.p.u("tours._common.go-to-dialog.behaviors"),
            this.CNn = e.message || this.tNn(".text"),
            Pk.p.j(),
            this.bWt = i.dialog,
            this.HNn = i["object-type-tag"],
            this.ONn() && "string" == typeof this.bWt && Gk.has(this.bWt) || this.YUn()
        }
        SWt() {
            return this.bWt
        }
        XNn() {
            return this.HNn
        }
        PNn() {
            return self.FNn.uNn
        }
    }
}
window.WUn.cNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.hi = i.plugin,
        this.HNn = i["object-type-tag"],
        this.ijn = e.ejn || this.QUn(".assign-name"),
        this.ONn() && "string" == typeof this.hi || this.YUn()
    }
    Ja() {
        return this.hi
    }
    PNn() {
        return self.FNn.cNn
    }
    XNn() {
        return this.HNn
    }
    sjn() {
        return this.ijn
    }
}
,
window.WUn.dNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.JNn = i["instance-tag"],
        this.ONn() && "string" == typeof this.JNn || this.YUn()
    }
    ZNn() {
        return this.JNn
    }
    PNn() {
        return self.FNn.dNn
    }
}
,
window.WUn.fNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.cas = i.behavior,
        this.njn = i["behavior-type-tag"],
        this.ONn() && "string" == typeof this.cas || this.YUn()
    }
    PNn() {
        return self.FNn.fNn
    }
    sxt() {
        return this.cas
    }
    rjn() {
        return this.njn
    }
}
,
window.WUn.pNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.HNn = i["object-type-tag"],
        this.BNn = i["event-tag"],
        this.ONn() && "string" == typeof this.HNn || this.YUn()
    }
    XNn() {
        return this.HNn
    }
    zNn() {
        return this.BNn
    }
    PNn() {
        return self.FNn.pNn
    }
}
,
window.WUn.mNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.hjn = i["ac-id"],
        this.ONn() && "string" == typeof this.hjn || this.YUn()
    }
    ojn() {
        return this.hjn
    }
    PNn() {
        return self.FNn.mNn
    }
}
;
{
    const Ak = self.t;
    window.WUn.wNn = class extends self.WUn {
        constructor(t, i, e={}) {
            super(t, i, e),
            this.ajn = i["param-id"],
            this.ljn = e.ujn || i["param-value"] || this.ZUn(".param-value"),
            this.CNn = e.message || this.QUn(".text") || self.tP("tours._common.enter-parameter.text", this.ljn),
            this.cjn = e.djn || this.QUn(".text2") || self.lang("tours._common.enter-parameter.pick-object"),
            this.ONn() && "string" == typeof this.ajn && this.ljn && this.ljn !== Ak.p.Fl || this.YUn()
        }
        fjn() {
            return this.ajn
        }
        Pae() {
            return this.ljn
        }
        PNn() {
            return self.FNn.wNn
        }
        pjn() {
            return Ak.v(Ak.MC, this.cjn, {
                O0: !0
            })
        }
    }
}
self.t;
window.WUn.gNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.BNn = i["event-tag"],
        this.mjn = null,
        new RegExp(i["script-regex"]),
        i["script-regex"] ? this.mjn = new RegExp(i["script-regex"]) : i["space-separated-script-regexes"] && (this.mjn = new RegExp(i["space-separated-script-regexes"].join("\\s*"))),
        this.CNn = e.message || this.ZUn(".text"),
        this.ONn() && "string" == typeof this.BNn && this.mjn || this.YUn()
    }
    zNn() {
        return this.BNn
    }
    wjn() {
        return this.mjn
    }
    PNn() {
        return self.FNn.gNn
    }
    DNn() {
        return !0
    }
}
;
window.WUn.yNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.gjn = i["allow-context-menu-items"] || [],
        this.yjn = i["message-position"] || "",
        this.ONn() || this.YUn()
    }
    bjn() {
        return this.gjn
    }
    vjn() {
        return this.yjn
    }
    PNn() {
        return self.FNn.yNn
    }
}
,
window.WUn.KTi = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.Fe = i.time
    }
    Po() {
        return this.Fe
    }
    PNn() {
        return self.FNn.KTi
    }
}
,
window.WUn.bNn = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.Sjn = i["item-tag"],
        this.ONn() && "string" == typeof this.Sjn || this.YUn()
    }
    xjn() {
        return this.Sjn
    }
    PNn() {
        return self.FNn.bNn
    }
}
,
window.WUn.fD = class extends self.WUn {
    constructor(t, i, e={}) {
        super(t, i, e),
        this.Mjn = i["show-properties-tag"],
        this.Ejn = i["property-id"],
        this.Cjn = i["set-value-tag"],
        this.ONn() && "string" == typeof this.Ejn || this.YUn()
    }
    _jn() {
        return this.Mjn
    }
    Tjn() {
        return this.Ejn
    }
    Ijn() {
        return this.Cjn
    }
    PNn() {
        return self.FNn.fD
    }
}
;
{
    const Rk = self.t;
    window.eNn = class extends self.KUn {
        constructor(t, i) {
            super(t, i),
            this.ahn = [],
            this.Pjn = !0
        }
        INn() {
            return this.ahn
        }
        Gjn(t, i, e, s) {
            return this.Pjn && (this.Pjn = !1,
            e || (e = {}),
            e["analytics-milestone"] = this.iNn()),
            Rk.v(t, this.JUn(), Object.assign({
                id: this.vR() + i
            }, e), s)
        }
    }
}
{
    const kk = self.t
      , Ok = self.WUn;
    window.eNn.vNn = class extends self.eNn {
        constructor(t, i) {
            super(t, i),
            kk.p.u("tours._common.create-default-new-project");
            const e = this.tNn(".start-page-message")
              , s = this.tNn(".create-button-message");
            kk.p.j(),
            this.ahn = [this.Gjn(Ok.nNn, "-sp", {
                button: "start-page-new-project"
            }, {
                message: e
            }), this.Gjn(Ok.nNn, "-create", {
                button: "new-project-dialog-create"
            }, {
                message: s
            })]
        }
    }
}
{
    const Dk = self.t
      , Fk = self.WUn;
    window.eNn.SNn = class extends self.eNn {
        constructor(t, i) {
            super(t, i);
            const e = i.plugin;
            "string" != typeof e && this.YUn();
            const s = i["object-type-tag"];
            Dk.p.u("tours._common.create-object-with-image");
            const n = this.tNn(".create-message")
              , r = this.tNn(".pick-message");
            Dk.p.j();
            const h = this.QUn(".assign-name")
              , o = this.QUn(".desired-name");
            this.ahn = [this.Gjn(Fk.ZA, "-create", null, {
                message: n
            }), this.Gjn(Fk.cNn, "-pick", {
                plugin: e,
                "object-type-tag": s
            }, {
                message: r,
                ejn: h
            })],
            o && this.ahn.push(this.Gjn(Fk.hNn, "-rename", {
                "object-type-tag": s
            }, {
                message: this.ZUn(".rename-message"),
                qNn: o
            }))
        }
    }
}
{
    const Lk = self.t
      , Bk = self.WUn;
    window.eNn.xNn = class extends self.eNn {
        constructor(t, i) {
            super(t, i);
            const e = i.plugin
              , s = i.image;
            "string" == typeof e && "string" == typeof s || this.YUn();
            const n = i["object-type-tag"]
              , r = i["instance-tag"]
              , h = i["initial-size"];
            Lk.p.u("tours._common.create-object-with-image");
            const o = this.tNn(".create-message")
              , a = this.tNn(".pick-message")
              , l = this.tNn(".place-message")
              , u = this.tNn(".import-image-message")
              , c = this.tNn(".close-message");
            Lk.p.j();
            const d = this.QUn(".assign-name")
              , f = this.QUn(".desired-name");
            this.ahn = [this.Gjn(Bk.ZA, "-create", null, {
                message: o
            }), this.Gjn(Bk.cNn, "-pick", {
                plugin: e,
                "object-type-tag": n
            }, {
                message: a,
                ejn: d
            }), this.Gjn(Bk.oNn, "-place", {
                "instance-tag": r,
                "initial-size": h
            }, {
                message: l
            }), this.Gjn(Bk.aNn, "-import-image", {
                image: s
            }, {
                message: u
            }), this.Gjn(Bk.nNn, "-close", {
                button: "animations-editor-close"
            }, {
                message: c
            })],
            f && this.ahn.push(this.Gjn(Bk.hNn, "-rename", {
                "object-type-tag": n
            }, {
                message: this.ZUn(".rename-message"),
                qNn: f
            }))
        }
    }
}
{
    const Uk = self.t
      , Nk = self.WUn;
    window.eNn.MNn = class extends self.eNn {
        constructor(t, i) {
            super(t, i);
            const e = i["object-type-tag"]
              , s = i.behaviors;
            "string" == typeof e && Array.isArray(s) || this.YUn(),
            Uk.p.u("tours._common.add-behaviors");
            const n = this.tNn(".add-edit-behaviors")
              , r = this.tNn(".add-button-first")
              , h = this.tNn(".add-button-next")
              , o = this.tNn(".close-behaviors-dialog");
            Uk.p.j(),
            this.ahn = [this.Gjn(Nk.uNn, "-getto", {
                dialog: "behaviors",
                "object-type-tag": e
            }, {
                message: n
            })];
            let a = 0;
            for (const t of s) {
                const i = t.behavior
                  , e = t["behavior-type-tag"];
                "string" != typeof i && this.YUn(),
                this.ahn.push(this.Gjn(Nk.nNn, "-add", {
                    button: "behaviors-dialog-add"
                }, {
                    message: 0 === a ? r : h
                })),
                this.ahn.push(this.Gjn(Nk.fNn, "-pick", {
                    behavior: i,
                    "behavior-type-tag": e
                }, {
                    message: this.ZUn(`.pick-behavior-${a}`)
                })),
                ++a
            }
            this.ahn.push(this.Gjn(Nk.nNn, "-close", {
                button: "behaviors-dialog-close"
            }, {
                message: o
            }))
        }
    }
}
{
    const jk = self.t
      , $k = self.WUn;
    window.eNn.Gmt = class extends self.eNn {
        constructor(t, i) {
            super(t, i);
            const e = i["event-tag"]
              , s = i["object-type-tag"]
              , n = i["ac-id"]
              , r = i.params;
            "string" == typeof s && "string" == typeof n || this.YUn(),
            jk.p.u("tours._common.add-event");
            const h = this.tNn(".click-add-link")
              , o = this.tNn(".pick-object")
              , a = this.tNn(".pick-condition")
              , l = this.tNn(".params-done");
            if (jk.p.j(),
            this.ahn = [this.Gjn($k.nNn, "-add", {
                button: "event-sheet-add-event-link"
            }, {
                message: h
            }), this.Gjn($k.pNn, "-object", {
                "object-type-tag": s,
                "event-tag": e
            }, {
                message: o
            }), this.Gjn($k.mNn, "-condition", {
                "ac-id": n
            }, {
                message: a
            })],
            Array.isArray(r) && r.length > 0)
                for (const t of r) {
                    const i = t.id;
                    "string" != typeof i && this.YUn(),
                    this.ahn.push(this.Gjn($k.wNn, "-param-" + i, {
                        "param-id": i
                    }, {
                        ujn: t.value || this.ZUn(`.${i}-value`),
                        message: this.QUn(`.${i}-text`),
                        djn: this.QUn(`.${i}-text2`)
                    }))
                }
            this.ahn.push(this.Gjn($k.nNn, "-done", {
                button: "parameters-dialog-done",
                "can-skip": !0
            }, {
                message: l
            }))
        }
    }
}
{
    const zk = self.t
      , Vk = self.WUn;
    window.eNn.Ayt = class extends self.eNn {
        constructor(t, i) {
            super(t, i);
            const e = i["event-tag"]
              , s = i["object-type-tag"]
              , n = i["ac-id"]
              , r = i.params;
            "string" == typeof e && "string" == typeof s && "string" == typeof n || this.YUn(),
            zk.p.u("tours._common.add-action");
            const h = this.tNn(".click-add-link")
              , o = this.tNn(".pick-object")
              , a = this.tNn(".pick-action")
              , l = this.tNn(".params-done");
            if (zk.p.j(),
            this.ahn = [this.Gjn(Vk.nNn, "-add", {
                button: "add-action-link",
                "event-tag": e
            }, {
                message: h
            }), this.Gjn(Vk.pNn, "-object", {
                "object-type-tag": s
            }, {
                message: o
            }), this.Gjn(Vk.mNn, "-action", {
                "ac-id": n
            }, {
                message: a
            })],
            Array.isArray(r) && r.length > 0)
                for (const t of r) {
                    const i = t.id;
                    "string" != typeof i && this.YUn(),
                    this.ahn.push(this.Gjn(Vk.wNn, "-param-" + i, {
                        "param-id": i
                    }, {
                        ujn: t.value || this.ZUn(`.${i}-value`),
                        message: this.QUn(`.${i}-text`),
                        djn: this.QUn(`.${i}-text2`)
                    }))
                }
            this.ahn.push(this.Gjn(Vk.nNn, "-done", {
                button: "parameters-dialog-done",
                "can-skip": !0
            }, {
                message: l
            }))
        }
    }
}
{
    const Wk = self.t
      , Hk = self.lang
      , Kk = self.tBn
      , qk = self.ani
      , Xk = self.mBn
      , Yk = self.lni
      , Jk = self.MQ
      , Zk = "c3-addon-files"
      , Qk = "c3-addon-list"
      , tO = "c3-dev-addon-list"
      , iO = "c3-remembered-addons"
      , eO = new Set(["plugin", "behavior", "effect", "theme", "tour"])
      , sO = new Set(["plugin", "behavior"])
      , nO = new Set(["conditions", "actions", "expressions"])
      , rO = {
        plugin: "plugins/",
        behavior: "behaviors/"
    }
      , hO = {
        plugin: ["plugin.js", "type.js", "instance.js"],
        behavior: ["behavior.js", "type.js", "instance.js"]
    }
      , oO = {
        plugin: {
            "built-in": Kk,
            addon: qk,
            project: qk,
            dev: qk
        },
        behavior: {
            "built-in": Xk,
            addon: Yk,
            project: Yk,
            dev: Yk
        },
        effect: {
            "built-in": Jk,
            addon: Jk,
            project: Jk,
            dev: Jk
        }
    };
    class aO extends Wk.Event.aG {
        constructor() {
            super(),
            this.yAe = null,
            this.Ajn = !1,
            this.Rjn = null,
            this.kjn = null,
            this.Ojn = null,
            this.Djn = null,
            this.Fjn = null,
            this.Ljn = {
                plugin: new Map,
                behavior: new Map,
                effect: new Map,
                theme: new Map,
                tour: new Map
            },
            this.Bjn = new Map,
            this.Ujn = null,
            this.Njn = 0,
            this.jjn = 0
        }
        $jn() {
            return this.Ajn
        }
        zjn(t, i) {
            return !("plugin" !== t && "behavior" !== t || "addon" !== i.source && "dev" !== i.source && "project" !== i.source || 1 !== (i.nBn["sdk-version"] ?? 1))
        }
        $Bn(t, i) {
            const e = {
                _Ye: null,
                source: "built-in",
                path: null,
                M: i,
                Vjn: null,
                zLn: null,
                files: null
            };
            this.Ljn.effect.set(t, e)
        }
        async Wjn(t) {
            this.yAe = t,
            this.Ajn = "animation" !== t.QPe() && Wk.M9s.lVs("safe-mode"),
            await Promise.all([this.Hjn(), this.Kjn("theme")]),
            await Wk.p.SIt()
        }
        async qjn() {
            await Promise.all([this.Xjn(), this.Kjn("tour")])
        }
        Yjn() {
            for (const t of this.Ljn.tour.values())
                t.M && t.M.W7t()
        }
        async SIt() {
            let t;
            t = Wk.jii() ? this.Jjn() : this.Zjn(),
            await Promise.all([t, this.Qjn()]),
            this.t$n()
        }
        Zjn() {
            return Promise.all([this.i$n("plugin"), this.i$n("behavior")])
        }
        async i$n(t) {
            const i = (await Wk.Z1t(rO[t] + t + "List.json"))[t + "List"]
              , e = [];
            for (const [s,n] of Object.entries(i)) {
                const i = n.productTypes || "all";
                self.app.UZs(i) && e.push(this.e$n(t, n, s, "dev"))
            }
            return Promise.all(e)
        }
        Jjn() {
            return Promise.all([this.s$n("plugin"), this.s$n("behavior")])
        }
        async s$n(t) {
            const i = rO[t]
              , e = Wk.Z1t(i + "allAces.json")
              , s = Wk.Z1t(i + "allSvgIcons.json")
              , n = Wk.Z1t(i + t + "List.json")
              , r = i + "allEditor" + ("plugin" === t ? "Plugins" : "Behaviors") + ".js";
            await Wk.ih(r);
            const h = (await n)[t + "List"]
              , o = [];
            for (const [i,e] of Object.entries(h)) {
                const s = e.productTypes || "all";
                self.app.UZs(s) && o.push(this.e$n(t, e, i, "release"))
            }
            await Promise.all(o);
            const a = await e;
            for (const [i,e] of Object.entries(a))
                this.Ljn[t].get(i).Vjn = e;
            const l = await s;
            for (const [i,e] of Object.entries(l))
                this.Ljn[t].get(i).zLn = e
        }
        async e$n(t, i, e, s) {
            const n = rO[t] + i.path + "/";
            Wk.p.ik(n + "lang");
            let r = {
                _Ye: null,
                source: "built-in",
                path: n,
                M: null,
                Vjn: null,
                zLn: null,
                files: null
            };
            if (this.Ljn[t].set(e, r),
            "dev" === s) {
                const e = [];
                e.push(Wk.Z1t(n + "aces.json").then(t => r.Vjn = t));
                const s = i.editorScripts || hO[t];
                for (const t of s)
                    e.push(Wk.ih(n + t));
                await Promise.all(e)
            }
            this.jjn++
        }
        async Qjn() {
            self.app.Rj() && (await Promise.all([this.Kjn("plugin"), this.Kjn("behavior"), this.Kjn("effect")]),
            await Wk.p.SIt())
        }
        Kjn(t) {
            const i = this.n$n(t).then(i => Promise.all(i.map(i => this.r$n(t, i))))
              , e = this.h$n(t).then(i => Promise.all(Object.entries(i).map(i => this.o$n(t, i[0], i[1]))));
            return Promise.all([i, e])
        }
        async Hjn() {
            const t = await fetch(Wk.sh() + "theme/defaultThemeList.json");
            if (!t.ok)
                throw new Error("unable to load theme list");
            const i = (await t.json()).themes;
            return Promise.all(i.map(t => this.a$n(t)))
        }
        a$n(t) {
            return Wk.zt(t),
            this.o$n("theme", t, Wk.sh() + "theme/" + t + "/addon.json", !0)
        }
        async Xjn() {
            const t = await fetch(Wk.sh() + "tours/defaultToursList.json");
            if (!t.ok)
                throw new Error("unable to load tours list");
            const i = (await t.json()).tours
              , e = [];
            for (const [t,s] of Object.entries(i)) {
                const i = s.productTypes || "all";
                self.app.UZs(i) && e.push(this.l$n(t))
            }
            await Promise.all(e)
        }
        l$n(t) {
            return Wk.zt(t),
            this.o$n("tour", t, Wk.sh() + "tours/" + t + "/addon.json", !0)
        }
        async r$n(t, i, e, s) {
            Wk.zt(t),
            Wk.zt(i);
            let n = null;
            if (e ? (n = this.Bjn.get(e),
            n || (n = {
                plugin: new Map,
                behavior: new Map,
                effect: new Map
            },
            this.Bjn.set(e, n))) : n = this.Ljn,
            n[t].has(i))
                throw new Error(`duplicate addon id '${i}'`);
            const r = e ? Promise.resolve(s) : Wk.lj.u$n(t, i)
              , h = await r;
            if (!h)
                return void console.error(`[Addons] Missing addon file for ${t} '${i}' - addon not loaded. Try reinstalling the addon.`);
            const o = await Wk.pes(h["addon.json"]);
            if (o.hasOwnProperty("min-construct-version")) {
                const t = Wk.rDn(o["min-construct-version"]);
                if (t > Wk.o_.Nti)
                    return void console.error(`[Addons] Addon '${i}' cannot be loaded in this version of Construct. The addon specifies a minimum Construct version of ${Wk.Vhi(t)}, and you are currently using ${Wk.o_.Lhi}.`)
            }
            const a = {
                _Ye: null,
                source: e ? "project" : "addon",
                path: null,
                M: null,
                nBn: o,
                Vjn: null,
                zLn: null,
                files: h,
                sx: e || null
            };
            n[t].set(i, a),
            this.Njn++,
            await this.c$n(t, a, this.Ajn),
            this.jjn++
        }
        async o$n(t, i, e, s) {
            Wk.zt(t),
            Wk.zt(i),
            Wk.zt(e);
            const n = Wk.tk(e)
              , r = this.Ljn;
            if (r[t].has(i))
                throw new Error(`duplicate addon id '${i}'`);
            const h = await Wk.Z1t(e);
            if (h.hasOwnProperty("min-construct-version")) {
                const t = Wk.rDn(h["min-construct-version"]);
                if (t > Wk.o_.Nti)
                    return void console.error(`[Addons] Addon '${i}' cannot be loaded in this version of Construct. The addon specifies a minimum Construct version of ${Wk.Vhi(t)}, and you are currently using ${Wk.o_.Lhi}.`)
            }
            const o = {
                _Ye: null,
                source: s ? "built-in" : "dev",
                path: n,
                M: null,
                nBn: h,
                Vjn: null,
                zLn: null,
                files: {},
                lBn: {},
                sx: null
            };
            if (r[t].set(i, o),
            this.Njn++,
            h.id !== i)
                throw new Error(`addon.json specifies id '${h.id}' but expected id '${i}'; uninstall addons before changing the id`);
            if (!h.hasOwnProperty("file-list"))
                throw new Error(`developer addon '${i}' is missing 'file-list' in addon.json - check the SDK documentation`);
            await Promise.all(h["file-list"].map(async i => {
                if ("tour" === t && Wk.jii() && i.endsWith("/en-US.json"))
                    return;
                const e = await Wk.Kl(n + i);
                o.files[i] = e,
                o.lBn[i] = n + i
            }
            )),
            await this.c$n(t, o, s && Wk.p.VNe() || this.Ajn),
            s || console.log(`[Addons] Loaded developer ${t} '${i}' from ${e}`),
            this.jjn++
        }
        c$n(t, i, e) {
            const s = []
              , n = i.nBn
              , r = n.id;
            if ("theme" === t)
                i.M = Wk.v(self.fUn, n, i);
            else if ("tour" === t)
                try {
                    i.M = Wk.v(self.MUn, n, i)
                } catch (t) {
                    console.error(`Error loading guided tour addon '${r}': `, t),
                    i.M = null
                }
            else if ("effect" === t) {
                if (!this.Ajn) {
                    if (!i.files["addon.json"])
                        throw new Error("effect addon missing file: addon.json");
                    s.push((async () => {
                        const t = await Wk.pes(i.files["addon.json"])
                          , e = t["supported-renderers"]
                          , s = !e || e.includes("webgl")
                          , n = e && e.includes("webgl2")
                          , r = e && e.includes("webgpu");
                        if (s && !i.files["effect.fx"])
                            throw new Error("effect addon missing file: effect.fx");
                        if (n && !i.files["effect.webgl2.fx"])
                            throw new Error("effect addon missing file: effect.webgl2.fx");
                        if (r && !i.files["effect.wgsl"])
                            throw new Error("effect addon missing file: effect.wgsl");
                        let h = ""
                          , o = ""
                          , a = "";
                        s && (h = await Wk.gle(i.files["effect.fx"])),
                        n && (o = await Wk.gle(i.files["effect.webgl2.fx"])),
                        r && (a = await Wk.gle(i.files["effect.wgsl"])),
                        i.M = Wk.v(self.MQ, "", t, h, o, a, i)
                    }
                    )())
                }
            } else if (!this.Ajn && !this.zjn(t, i)) {
                const e = n["editor-scripts"];
                for (const n of e) {
                    if (!i.files.hasOwnProperty(n))
                        throw new Error(`cannot find addon '${r}' "editor-scripts" file '${n}'`);
                    const e = URL.createObjectURL(i.files[n]);
                    s.push(Wk.ih(e).then(i => i.setAttribute("data-comment", t + "-" + r)))
                }
                if (!i.files["aces.json"])
                    throw new Error("addon missing file: aces.json");
                s.push(Wk.pes(i.files["aces.json"]).then(t => i.Vjn = t))
            }
            return e || this.AUn(r, i.files, "lang/"),
            Promise.all(s)
        }
        AUn(t, i, e) {
            const s = `${e}en-US.json`;
            if (!i.hasOwnProperty(s))
                throw new Error(`cannot find required en-US.json language file in addon '${t}'`);
            const n = URL.createObjectURL(i[s]);
            Wk.p.XNe(n);
            const r = self.app.iwt();
            if ("en-US" !== r) {
                const t = `${e}${r}.json`;
                if (i.hasOwnProperty(t)) {
                    const e = URL.createObjectURL(i[t]);
                    Wk.p.YNe(e)
                }
            }
        }
        Hhi(t) {
            Wk.Mw(t, self.gh),
            this.Ujn = t
        }
        uBn(t, i, e) {
            let s;
            if (Wk.zt(i),
            Wk.qd(e),
            s = this.Ujn ? this.Bjn.get(this.Ujn)[t].get(i) : this.Ljn[t].get(i),
            !s)
                throw new Error(`Failed to register addon ID '${i}' because no addon with that ID is loaded. It may have previously been installed with a different ID, or the ID in plugin.js may not match the one specified in addon.json. Uninstall addons before changing their ID. Loaded addon IDs are: ${[...this.Ljn[t].keys()].join(", ")}`);
            if (s._Ye)
                throw new Error(`already registered addon id '${i}'`);
            if (s._Ye = e,
            !this.Ajn && !s.Vjn)
                throw new Error(`addon '${i}' missing aces.json`)
        }
        d$n() {
            const t = new Set;
            for (const i of sO)
                for (const [e,s] of this.Ljn[i])
                    s._Ye || (t.add(e),
                    this.Ljn[i].delete(e));
            if (t.size) {
                const i = [...t];
                let e;
                e = i.length > 10 ? i.slice(0, 10).join(", ") + "... (" + (i.length - 10) + " more)" : i.join(", "),
                self.app.Lii("AddonsFailedLoad", e);
                Wk.qs.Ys.$s("OK").Qa(new Wk.MC(self.tP("ui.errors.failed-to-load-addons", e),{
                    O0: !0
                }))
            }
        }
        zBn() {
            return this.jjn
        }
        VBn() {
            return this.Njn
        }
        f$n(t, i, e) {
            let s;
            if (Wk.zt(t),
            Wk.zt(i),
            e) {
                const n = this.Bjn.get(e);
                n && (s = n[t].get(i))
            }
            if (s || (s = this.Ljn[t].get(i)),
            !s)
                return null;
            if ("effect" !== t && !s.M && (!this.Ajn || "addon" !== s.source && "dev" !== s.source) && !this.zjn(t, s)) {
                const e = Wk.v(oO[t][s.source], Wk.v(s._Ye), s);
                try {
                    e.VLn(s.Vjn)
                } catch (e) {
                    console.error(`[Construct] Error loading addon '${i}': `, e),
                    this.Ljn[t].delete(i)
                }
                s.M = e
            }
            return s
        }
        Jm(t, i, e) {
            const s = this.f$n(t, i, e);
            if (!s)
                throw new Error(`cannot find ${t} with id '${i}'`);
            return s.M
        }
        Eas(t, i, e, s) {
            const n = this.f$n(t, i, e);
            return !(!s && n && (this.Ajn && ("addon" === n.source || "dev" === n.source) || this.zjn(t, n))) && !!n
        }
        Kde(t, i) {
            Wk.zt(t);
            let e = [];
            if (i) {
                if (this.Bjn.get(i))
                    for (const s of this.Ljn[t].keys())
                        e.push(Wk._Ct( () => this.f$n(t, s, i)))
            }
            for (const i of this.Ljn[t].keys())
                e.push(Wk._Ct( () => this.f$n(t, i, null)));
            return Promise.all(e)
        }
        *addons(t, i, e) {
            Wk.zt(t);
            const s = new Set;
            if (i) {
                const e = this.Bjn.get(i);
                if (e)
                    for (const i of e[t].values()) {
                        const t = i.M;
                        if (!t)
                            throw new Error("must load all addons before iterating");
                        t.Vpt() || (s.add(t.vR()),
                        yield t)
                    }
            }
            for (const [i,n] of this.Ljn[t].entries()) {
                const r = n.M;
                if (!r) {
                    if (this.Ajn || this.zjn(t, n)) {
                        e && (yield{
                            p$n: t,
                            QLn: i,
                            Q7s: n.nBn.author,
                            version: n.nBn.version,
                            m$n: n.nBn["sdk-version"] ?? 1,
                            source: n.source
                        });
                        continue
                    }
                    if ("tour" === t)
                        continue;
                    throw new Error("must load all addons before iterating")
                }
                !e && r.Vpt() || s.has(r.vR()) || self.app.PE() && !r.Coe() || (yield r)
            }
        }
        *w$n(t) {
            Wk.zt(t);
            for (const [i,e] of this.Ljn[t].entries())
                "addon" === e.source && (yield i)
        }
        WBn() {
            for (const t of this.Ljn.effect.values())
                t.M && t.M.W7t()
        }
        g$n() {
            return this.Rjn ? Promise.resolve(this.Rjn) : (this.Ojn || (this.Ojn = Promise.all([localforage.getItem(Qk), localforage.getItem(tO)]).then(t => (this.Rjn = t[0],
            this.kjn = t[1],
            this.Ojn = null,
            this.Rjn))),
            this.Ojn)
        }
        async n$n(t) {
            Wk.zt(t);
            const i = await this.g$n();
            return i && i[t] ? i[t] : []
        }
        async h$n(t) {
            return Wk.zt(t),
            await this.g$n(),
            this.kjn && this.kjn[t] ? this.kjn[t] : {}
        }
        y$n() {
            return this.Djn || (this.Djn = localforage.sBe({
                name: Zk
            })),
            this.Djn
        }
        u$n(t, i) {
            return this.y$n().getItem(t + "-" + i)
        }
        b$n(t) {
            if (!0 !== t["is-c3-addon"])
                throw new Error("not a C3 addon");
            if (!eO.has(t.type))
                throw new Error("invalid addon type");
            if (!(t.name && t.id && t.version && t.author && t.website && t.documentation && t.description))
                throw new Error("invalid addon json")
        }
        async $hi(t, i, e, s=!1) {
            Wk.U(t, Blob),
            Wk.Mw(i, self.gh),
            Wk.Hdt(e);
            const n = !!i
              , r = new Wk.FRt;
            try {
                await r.HRt(t);
                const h = r.XRt("addon.json");
                if (!h)
                    throw new Error("missing addon.json");
                const o = await r.ees(h);
                this.b$n(o);
                const a = o.id
                  , l = o.type
                  , u = o["sdk-version"] ?? 1;
                if (("plugin" === l || "behavior" === l) && 1 === u) {
                    const t = new Error("sdkv1-addon");
                    throw t.QLn = a,
                    t.v$n = o.author,
                    t
                }
                if (o.hasOwnProperty("min-construct-version")) {
                    const t = Wk.rDn(o["min-construct-version"]);
                    if (t > Wk.o_.Nti) {
                        const i = new Error("min-version");
                        throw i.S$n = t,
                        i
                    }
                }
                if (!n && this.Eas(l, a, null, !0)) {
                    if (!s) {
                        const t = Wk.qs.Ys.$s("Confirm")
                          , i = this.Ljn[l].get(a).M
                          , e = i ? i.$te() : "(unknown)"
                          , s = o.version;
                        Wk.p.u("ui.update-addon-prompt");
                        const n = t.Qa({
                            caption: Hk(".caption"),
                            message: self.tG(".message", e, s),
                            jD: Hk(".update"),
                            vD: Hk("common.cancel")
                        });
                        Wk.p.j();
                        if (null === await n)
                            return
                    }
                    await this.x$n(l, a, "addon")
                }
                let c = !1;
                n && (c = await this.M$n(t));
                let d = null;
                if (c || s)
                    d = "allowed";
                else {
                    const t = Wk.qs.Ys.$s("AddonConfirmInstall");
                    d = await t.Qa(o, n, e)
                }
                if (null === d) {
                    if (n)
                        throw new Error("addon install failed");
                    return !1
                }
                if ("remember" === d)
                    try {
                        await this.E$n(t)
                    } catch (t) {
                        console.error("Error remembering addon: ", t)
                    }
                let f = t;
                n && Wk.g2t(t) && (f = await Wk.wes(t));
                const p = {
                    _c3addon: f
                }
                  , m = [];
                for (const t of r.DKe())
                    m.push(r.JRt(t).then(i => p[t.filename] = i));
                if (await Promise.all(m),
                n)
                    return await this.r$n(l, a, i, p),
                    !0;
                {
                    const t = this.y$n();
                    try {
                        await t.setItem(l + "-" + a, p);
                        let i = await localforage.getItem(Qk);
                        return i ? (i.theme || (i.theme = []),
                        i.tour || (i.tour = [])) : i = {
                            plugin: [],
                            behavior: [],
                            effect: [],
                            theme: [],
                            tour: []
                        },
                        i[l].includes(a) ? !1 : (i[l].push(a),
                        await localforage.setItem(Qk, i),
                        !0)
                    } catch (t) {
                        return self.app.OA(t),
                        !1
                    }
                }
            } finally {
                r.YRt()
            }
        }
        async C$n(t, i, e) {
            if (Wk.zt(t),
            Wk.Yq(i),
            Wk.Hdt(e),
            !self.app.Xj())
                throw new Error("developer mode not enabled");
            const s = i.id
              , n = i.type
              , r = i["sdk-version"] ?? 1;
            if (("plugin" === n || "behavior" === n) && 1 === r) {
                const t = new Error("sdkv1-addon");
                throw t.QLn = s,
                t.v$n = i.author,
                t
            }
            if (this.Eas(n, s, null, !0))
                throw new Error(`addon id '${s}' already installed`);
            if (i.hasOwnProperty("min-construct-version")) {
                const t = Wk.rDn(i["min-construct-version"]);
                if (t > Wk.o_.Nti) {
                    console.error(`[Construct] Cannot install dev mode addon: the minimum Construct version required is ${Wk.Vhi(t)}, and you are currently using ${Wk.o_.Lhi}.`);
                    const i = new Error("min-version");
                    throw i.S$n = t,
                    i
                }
            }
            let h = await localforage.getItem(tO);
            if (h || (h = {}),
            h[n] || (h[n] = {}),
            h[n].hasOwnProperty(s))
                throw new Error(`dev addon '${s}' already installed; uninstall it first to reinstall`);
            h[n][s] = t;
            try {
                await localforage.setItem(tO, h)
            } catch (t) {
                self.app.OA(t)
            }
        }
        x$n(t, i, e) {
            return "dev" === e ? this._$n(t, i) : this.T$n(t, i)
        }
        async T$n(t, i) {
            const e = this.y$n();
            try {
                await e.removeItem(t + "-" + i)
            } catch (t) {
                (() => {})("Error removing addon files: ", t)
            }
            const s = await localforage.getItem(Qk);
            if (s) {
                Wk.sni(s[t], i);
                try {
                    await localforage.setItem(Qk, s)
                } catch (t) {
                    self.app.OA(t)
                }
            }
        }
        async _$n(t, i) {
            const e = await localforage.getItem(tO);
            if (!e || !e[t])
                return;
            delete e[t][i];
            try {
                await localforage.setItem(tO, e)
            } catch (t) {
                self.app.OA(t)
            }
        }
        I$n(t) {
            const i = this.Bjn.get(t);
            i && (this.P$n(i.plugin),
            this.P$n(i.behavior),
            this.P$n(i.effect),
            this.Bjn.delete(t))
        }
        P$n(t) {
            for (const i of t.values())
                i.M && i.M.he();
            t.clear()
        }
        async E$n(t) {
            const i = await Wk.fAs(t)
              , e = await Wk.Crypto.dAs(i);
            let s = await localforage.getItem(iO);
            s || (s = []),
            s.includes(e) || (s.push(e),
            await localforage.setItem(iO, s))
        }
        async M$n(t) {
            const i = await Wk.fAs(t)
              , e = await Wk.Crypto.dAs(i);
            let s = await localforage.getItem(iO);
            return !!s && s.includes(e)
        }
        Jhi(t) {
            Wk.U(t, self.gh);
            const i = this.Bjn.get(t);
            if (i)
                for (const t of i.effect.values())
                    t.M.W7t()
        }
        async G$n() {
            Wk.n0("PreParseACDisplayTexts"),
            await Promise.all([this.A$n("plugin"), this.A$n("behavior")]),
            Wk.I0("PreParseACDisplayTexts")
        }
        A$n(t) {
            Wk.zt(t);
            const i = [];
            for (const e of this.Ljn[t].values())
                (!this.Ajn && !this.zjn(t, e) || e.M) && (self.assert(e.M, "expected addon instance to be created by now"),
                i.push(Wk._Ct( () => this.R$n(e.M))));
            return Promise.all(i)
        }
        R$n(t) {
            return Promise.all([...t.HDt(), ...t.actions()].map(t => Wk._Ct( () => t.KZs())))
        }
        async k$n() {
            const t = self.app.r0().theme;
            t && this.Eas("theme", t) && (this.Fjn = this.Jm("theme", t),
            await this.Fjn.iXe())
        }
        async O$n() {
            const t = self.app.r0().theme;
            t && this.Eas("theme", t) && (this.Fjn = this.Jm("theme", t),
            await this.Fjn.vUn(),
            await self.app.imn())
        }
        gYe() {
            return this.Fjn
        }
        D$n(t) {
            return eO.has(t)
        }
        t$n() {
            self.C3SDK_ListAddonIDs = t => {
                this.F$n(t)
            }
            ,
            self.C3SDK_ListACEIDs = (t, i, e) => {
                this.L$n(t, i, e)
            }
        }
        async F$n(t) {
            if (eO.has(t)) {
                await this.Kde(t),
                console.log(`[SDK] Listing all installed ${t} IDs:`);
                for (const i of this.addons(t))
                    console.log(`"${i.vR()}" (${i.Fa()})`)
            } else
                (() => {})(`Invalid addon type: passed '${t}', must be one of: ${[...eO].join(",")}`)
        }
        async L$n(t, i, e) {
            if (!sO.has(t))
                return void (() => {})(`Invalid addon type: passed '${t}', must be one of: ${[...sO].join(",")}`);
            if ("string" != typeof i)
                return void (() => {})(`Invalid addon ID: expected string, got '${typeof i}'`);
            if (!this.Eas(t, i))
                return void (() => {})(`No '${t}' with ID '${i}' found`);
            if (!nO.has(e))
                return void (() => {})(`Invalid ACE type: passed '${e}', must be one of: ${[...nO].join(",")}`);
            const s = this.Jm(t, i);
            for (const t of s.VIe(e)) {
                let i;
                i = t instanceof self.ZYs ? t.qZs() : t.AYs();
                let e = `"${t.vR()}" (${i})`;
                if (t.NZs()) {
                    e += " - params: ";
                    const i = [];
                    for (let e = 0, s = t.IKt(); e < s; ++e) {
                        const s = t.txt(e);
                        i.push(`${s.vR()} (${s.Vdt()})`)
                    }
                    console.log(e, i)
                } else
                    console.log(e)
            }
        }
    }
    Wk.lj = Wk.v(aO)
}
{
    const lO = self.t
      , uO = self.lang
      , cO = self.tP
      , dO = lO.ek(import.meta.url)
      , fO = dO.getElementById("aboutDialog")
      , pO = lO.tk(dO.URL);
    lO.p.ik(pO + "lang");
    const mO = "About"
      , wO = lO.qs.Jj.B$n = class extends lO.qs.Ys {
        constructor() {
            super(fO),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.U$n = this.dwt("localStorageQuota"),
            this.N$n = this.dwt("localStoragePersistent"),
            this.j$n = this.dwt("requestPersistentStorage"),
            this.j$n.onclick = () => this.$$n(),
            this.dwt("viewReleaseNotes").onclick = () => self.app.e_(lO.o_.URL.oSe + lO.o_.URL.zOn + lO.o_.hDn, "ReleaseNotes"),
            this.dwt("viewAccountInfo").onclick = function() {
                lO.qs.Ys.$s("AccountInfo").Qa(self.app.zj("useraccount"))
            }
            ,
            this.dwt("aboutShowPlatformInfo").onclick = function() {
                lO.qs.Ys.$s("PlatformInfo").Qa()
            }
            ,
            this.dwt("aboutShowLegalInfo").onclick = function() {
                lO.qs.Ys.$s("LegalInfo").Qa()
            }
            ,
            this.dwt("aboutShowLicenseAgreement").onclick = function() {
                lO.qs.Ys.$s("EULA").Qa()
            }
            ,
            this.dwt("aboutShowBundledGameLicense").onclick = function() {
                lO.qs.Ys.$s("BundledContentLicense").Qa()
            }
            ,
            this.dwt("privacyPolicy").onclick = function() {
                lO.qs.Ys.$s("PrivacyPolicy").Qa()
            }
            ;
            const t = lO.qs.oX.qKe()
              , i = this.dwt("aboutDialogC3logo");
            let e = "";
            "animation" === self.app.QPe() ? (i.classList.add("animation"),
            e = t ? "loader/calogo-darkbg.svg" : "loader/calogo-lightbg.svg") : (i.classList.add("games"),
            e = t ? "loader/c3logo-darkbg.svg" : "loader/c3logo-lightbg.svg"),
            i.src = e,
            i.alt = uO("ui.start-page.construct-logo")
        }
        Swt() {
            const t = self.app;
            lO.p.u("ui.dialogs.about"),
            this.lKi.textContent = uO("common.ok"),
            this.Ya(uO(".caption")),
            this.dwt("c3versioninfo").textContent = cO(".release-number-" + t.tke(), lO.o_.Lhi),
            this.dwt("viewReleaseNotes").textContent = cO(".view-release-notes", lO.o_.Lhi),
            this.dwt("aboutShowPlatformInfo").textContent = uO(".platform-information"),
            this.dwt("accountHeader").textContent = uO(".account-header"),
            this.dwt("viewAccountInfo").textContent = uO(".view-account-information"),
            this.dwt("localStorageHeader").textContent = uO(".local-storage-header"),
            this.j$n.textContent = uO(".request-persistent-storage"),
            this.dwt("aboutConstructHeader").textContent = uO(".about-construct-header"),
            this.dwt("officialWebsite").textContent = uO(".official-website"),
            this.dwt("editorCredit").textContent = uO(".editor-credit"),
            this.dwt("websiteCredit").textContent = uO(".website-credit"),
            this.dwt("designCredit").textContent = uO(".design-credit"),
            this.dwt("thanksCredit").textContent = uO(".thanks-credit"),
            this.dwt("aboutShowLicenseAgreement").textContent = uO(".eula"),
            this.dwt("aboutShowBundledGameLicense").textContent = uO(".bundled-project-license"),
            this.dwt("privacyPolicy").textContent = uO(".privacy-policy"),
            this.dwt("aboutShowLegalInfo").textContent = uO(".legal-information"),
            this.dwt("timeSpentInEditorLabel").textContent = uO(".time-spent-in-editor"),
            this.dwt("thanksNote").textContent = uO(".thanks-note"),
            lO.odt(this.dwt("quote"), self.idt(".quote")),
            this.dwt("mainWebsiteLink").onclick = () => t.e_(lO.o_.URL.LOn, "AboutDialog", "OfficialWebsite");
            const i = this.dwt("storageCleanup");
            i.textContent = uO(".storage-cleanup"),
            i.onclick = () => {
                lO.qs.Ys.$s("StorageCleanup").Qa()
            }
            ;
            const e = this.dwt("aboutUsLink");
            e.textContent = uO(".about-us"),
            e.onclick = () => t.e_(lO.o_.URL.BOn, "AboutDialog", "AboutUs");
            const s = this.dwt("helpLink");
            s.textContent = uO(".help"),
            s.onclick = () => t.e_(lO.o_.URL.C6t, "AboutDialog", "Help");
            const n = this.dwt("forumsLink");
            n.textContent = uO(".forums"),
            n.onclick = () => t.e_(lO.o_.URL.YOn, "AboutDialog", "Forum");
            const r = this.dwt("tutorialsLink");
            r.textContent = uO(".tutorials"),
            r.onclick = () => t.e_(lO.o_.URL.A6t, "AboutDialog", "Tutorials");
            const h = this.dwt("addonExchangeLink");
            h.textContent = uO(".get-addons"),
            h.onclick = () => t.e_(lO.o_.URL.t_, "AboutDialog", "Addons");
            const o = this.dwt("contributeTranslationsLink");
            o.textContent = uO(".contribute-translations"),
            o.onclick = () => t.e_(lO.o_.URL.eDn, "AboutDialog", "ContributeTranslations");
            const a = this.dwt("suggestFeaturesLink");
            a.textContent = uO(".suggest-features"),
            a.onclick = () => t.e_(lO.o_.URL.iDn);
            const l = this.dwt("reportIssuesLink");
            l.textContent = uO(".report-issues"),
            l.onclick = () => t.e_(lO.o_.URL.tDn),
            lO.p.j()
        }
        Qa(t) {
            return this.z$n(),
            this.V$n(),
            super.Qa(t)
        }
        z$n() {
            lO.zk.QRe ? (this.U$n.textContent = uO("common.ellipsis"),
            navigator.storage.estimate().then(t => {
                const i = t.quota
                  , e = t.usage
                  , s = Math.round(1e3 * e / i) / 10;
                this.U$n.textContent = cO("ui.dialogs.about.storage-usage", lO.Iye(e), lO.Iye(i), s)
            }
            ).catch(t => {
                (() => {})("Error estimating storage usage: ", t),
                this.U$n.textContent = uO("ui.dialogs.about.storage-usage-unavailable")
            }
            )) : this.U$n.textContent = uO("ui.dialogs.about.storage-usage-unavailable"),
            lO.zk.ZRe ? (this.N$n.textContent = "",
            this.N$n.classList.remove("storagePersisted"),
            this.N$n.classList.remove("storageNotPersisted"),
            this.j$n.setAttribute("hidden", ""),
            navigator.storage.persisted().then(t => {
                t ? (this.N$n.classList.add("storagePersisted"),
                this.N$n.textContent = uO("ui.dialogs.about.storage-persisted")) : (this.N$n.classList.add("storageNotPersisted"),
                this.N$n.textContent = uO("ui.dialogs.about.storage-not-persisted-prefix"),
                this.j$n.removeAttribute("hidden"))
            }
            )) : this.N$n.textContent = uO("ui.dialogs.about.storage-status-unavailable")
        }
        V$n() {
            localforage.getItem("c3-time-spent-in-editor").then(t => {
                "number" != typeof t && (t = 0);
                const i = this.dwt("timeSpentInEditor");
                i.textContent = t >= 31536e5 ? "Very clever." : lO.PBe(t, {
                    IBe: !1
                })
            }
            )
        }
        $$n() {
            navigator.storage.persist().then(t => {
                if (this.z$n(),
                !t) {
                    lO.qs.Ys.$s("OK").Qa(uO("ui.dialogs.about.persistent-storage-denied"))
                }
            }
            )
        }
        VW() {}
    }
    ;
    lO.qs.HY.ipt.addEventListener("load", () => {
        lO.qs.Ys.opt(mO, wO)
    }
    )
}
{
    const gO = self.t
      , yO = self.lang
      , bO = gO.ek(import.meta.url)
      , vO = bO.getElementById("addonConfirmInstallDialog")
      , SO = gO.tk(bO.URL);
    gO.p.ik(SO + "lang");
    const xO = "AddonConfirmInstall"
      , MO = gO.qs.Jj.W$n = class extends gO.qs.Ys {
        constructor() {
            super(vO),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.H$n = this.dwt("dontAskAgain"),
            this.K$n = !1,
            gO.v(gO.qs.kmt, self.app.Tk("warning"), this.dwt("iconWrap"))
        }
        Swt() {
            gO.p.u("ui.dialogs.addonConfirmInstall"),
            this.Ya(yO(".caption")),
            gO.odt(this.dwt("headerText"), gO.v(gO.MC, yO(".header-text"), {
                O0: !0
            })),
            this.dwt("addonNameLabel").textContent = yO(".name"),
            this.dwt("addonVersionLabel").textContent = yO(".version"),
            this.dwt("addonTypeLabel").textContent = yO(".type"),
            this.dwt("addonAuthorLabel").textContent = yO(".author"),
            this.dwt("addonWebsiteLabel").textContent = yO(".website"),
            this.dwt("addonDocumentationLabel").textContent = yO(".documentation"),
            this.dwt("addonDescriptionLabel").textContent = yO(".description"),
            this.dwt("dontAskAgainLabel").textContent = yO(".dont-ask-again"),
            this.lKi.textContent = yO(".install"),
            this.lhs.textContent = yO("common.cancel"),
            gO.p.j()
        }
        Qa(t, i, e) {
            gO.Yq(t),
            gO.p.u("ui.dialogs.addonConfirmInstall"),
            this.dwt("addonName").textContent = t.name,
            this.dwt("addonVersion").textContent = t.version,
            this.dwt("addonType").textContent = yO(".type-" + t.type),
            this.dwt("addonAuthor").textContent = t.author;
            const s = this.dwt("addonWebsite");
            s.textContent = t.website,
            s.href = t.website;
            const n = this.dwt("addonDocumentation");
            return n.textContent = t.documentation,
            n.href = t.documentation,
            this.dwt("addonDescription").textContent = t.description,
            this.H$n.checked = !1,
            this.K$n = i,
            this.dwt("dontAskAgainWrap").style.display = i ? "" : "none",
            gO.p.j(),
            super.Qa(e)
        }
        gwt() {
            this.PR(!this.K$n || this.H$n.checked ? "remember" : "forget")
        }
        VW() {}
    }
    ;
    gO.qs.HY.ipt.addEventListener("load", () => {
        gO.qs.Ys.opt(xO, MO)
    }
    )
}
{
    const EO = self.t
      , CO = self.lang
      , _O = EO.ek(import.meta.url)
      , TO = _O.getElementById("addonUpdateReviewDialog")
      , IO = EO.tk(_O.URL);
    EO.p.ik(IO + "lang");
    const PO = "AddonUpdateReview"
      , GO = EO.qs.Jj.q$n = class extends EO.qs.Ys {
        constructor() {
            super(TO),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.Aet = this.dwt("updateReviewContent")
        }
        Swt() {
            const t = EO.p.Ok("ui.dialogs.addonUpdateReview");
            this.lKi.textContent = t(".update"),
            this.lhs.textContent = CO("common.cancel")
        }
        Qa(t, i) {
            EO._D(t);
            const e = EO.p.Ok("ui.dialogs.addonUpdateReview");
            return EO.odt(this.dwt("headerWrap"), EO.v(EO.MC, e.yD(".header.review-details", null, t.length) + "\n" + e(".header.bundled-addons-note"), {
                O0: !0
            })),
            this.X$n(t),
            super.Qa(i)
        }
        X$n(t) {
            for (const i of t) {
                const t = document.createElement("div");
                t.classList.add("addonUpdateWrap"),
                EO.odt(t, this.Y$n(i)),
                this.Aet.appendChild(t)
            }
        }
        Y$n(t) {
            const i = EO.p.Ok("ui.dialogs.addonUpdateReview")
              , {version: e, J$n: s, Z$n: n, Q$n: r} = t.tzn;
            let h = `[h2]${t.izn}[/h2]\n`;
            h += i.oj(".current-version", t.ezn) + "\n",
            h += i.oj(".update-version", e) + "\n",
            h += i.oj(".published-date", s.toLocaleString(self.app.iwt(), {
                day: "numeric",
                month: "long",
                year: "numeric"
            })),
            r && (h += `\n[a1]${i(".visit-addon-page")}[/a1]`);
            for (let t = n.length - 1; t >= 0; --t) {
                const e = n[t];
                h += `\n\n[h3]${i.oj(".changes", e.version)}[/h3]\n`,
                h += e.szn
            }
            return EO.v(EO.MC, h, {
                O0: !0,
                links: r ? [r] : []
            })
        }
        VW() {
            EO.qs.BYt(this.Aet)
        }
    }
    ;
    EO.qs.HY.ipt.addEventListener("load", () => {
        EO.qs.Ys.opt(PO, GO)
    }
    )
}
{
    const AO = self.t
      , RO = AO.ek(import.meta.url)
      , kO = RO.getElementById("bundledContentLicenseDialog")
      , OO = (AO.tk(RO.URL),
    "BundledContentLicense")
      , DO = AO.qs.Jj.nzn = class extends AO.qs.Ys {
        constructor() {
            super(kO),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt()
        }
        Swt() {
            this.lKi.textContent = self.lang("common.close-dialog")
        }
        Qa(t) {
            return super.Qa(t)
        }
        VW() {}
    }
    ;
    AO.qs.HY.ipt.addEventListener("load", () => {
        AO.qs.Ys.opt(OO, DO)
    }
    )
}
{
    const FO = self.t
      , LO = FO.ek(import.meta.url)
      , BO = LO.getElementById("eulaDialog")
      , UO = (FO.tk(LO.URL),
    "EULA")
      , NO = FO.qs.Jj.rzn = class extends FO.qs.Ys {
        constructor() {
            super(BO),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt()
        }
        Swt() {
            this.lKi.textContent = self.lang("common.close-dialog")
        }
        Qa(t) {
            return super.Qa(t)
        }
        VW() {}
    }
    ;
    FO.qs.HY.ipt.addEventListener("load", () => {
        FO.qs.Ys.opt(UO, NO)
    }
    )
}
{
    const jO = self.t
      , $O = self.lang
      , zO = jO.ek(import.meta.url)
      , VO = zO.getElementById("exportSelectPlatformDialog")
      , WO = jO.tk(zO.URL);
    jO.p.ik(WO + "lang");
    const HO = "ExportSelectPlatform"
      , KO = new Map([["animation", 0], ["web", 1], ["apps", 2], ["mobile", 3], ["desktop", 4], ["mobile-and-desktop", 5], ["console", 6], ["other", 7], ["deprecated", 8]]);
    function qO(t, i) {
        return KO.get(t[0]) - KO.get(i[0])
    }
    const XO = jO.qs.Jj.hzn = class extends jO.qs.Ys {
        constructor() {
            super(VO),
            this.rhs = this.dwt("nextButton"),
            this.rhs.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt();
            let t = this.dwt("exportPlatformIconView");
            this.IJt = jO.v(jO.qs.Jj.PJt, t),
            this.IJt.addEventListener("itemselect", t => this._zi(t.item)),
            this.IJt.addEventListener("itemdoubletap", t => this.mE(t.item)),
            this.zde = this.dwt("exportPlatformDescription"),
            this.pwt = null
        }
        Swt() {
            jO.p.u("ui.dialogs.exportSelectPlatform"),
            this.Ya($O(".caption")),
            this.rhs.textContent = $O("common.next"),
            this.lhs.textContent = $O("common.cancel");
            const t = this.dwt("helpLink");
            t.textContent = $O("common.help"),
            t.onclick = () => self.app.s_("overview/publishing-projects", "ExportSelectPlatformDialog"),
            jO.p.j()
        }
        Qa(t, i) {
            jO.U(t, self.gh),
            this.pwt = t;
            let e = super.Qa(i);
            return jO.Ars.SIt().then( () => this.ozn()).catch(t => {
                console.error("Error loading exporters: ", t);
                jO.qs.Ys.$s("OK").Qa($O("ui.dialogs.exportSelectPlatform.error-loading-exporters"))
            }
            ),
            e
        }
        ozn() {
            const t = jO.Ars
              , i = new Map;
            for (const e of t.DAe()) {
                let t = {
                    fPe: e,
                    azn: -1
                }
                  , s = e.RZs();
                i.has(s) ? i.get(s).push(t) : i.set(s, [t]);
                const n = e.nAe();
                for (let r = 0, h = n.length; r < h; ++r)
                    t = {
                        fPe: e,
                        azn: r
                    },
                    s = n[r].RZs(),
                    i.has(s) ? i.get(s).push(t) : i.set(s, [t])
            }
            const e = [...i];
            e.sort(qO);
            for (const [t,i] of e) {
                const e = $O("model.exporter-category." + t);
                i.sort( (t, i) => self.vEe.gAe(t.fPe, i.fPe));
                const s = this.IJt.ayt(e);
                for (const t of i) {
                    const i = t.fPe
                      , e = t.azn;
                    if (-1 === e)
                        s.Pk(i.nus(i.Yg()), i.Fa(), {
                            fPe: i,
                            tag: i.Yg(),
                            description: i.dj()
                        });
                    else {
                        const t = i.nAe()[e];
                        s.Pk(i.nus(t.Yg()), t.Fa(), {
                            fPe: i,
                            tag: t.Yg(),
                            description: i.Vxe(t.Yg(), t.dj())
                        })
                    }
                }
            }
        }
        gwt() {
            const t = this.IJt.yF();
            if (!t)
                return;
            const i = t.Pp();
            this.PR(i)
        }
        VW() {
            this.IJt.tC(),
            this.pwt = null
        }
        _zi(t) {
            t ? (this.rhs.removeAttribute("disabled"),
            jO.odt(this.zde, t.Pp().description)) : this.rhs.setAttribute("disabled", "")
        }
        mE(t) {
            this.gwt()
        }
    }
    ;
    jO.qs.HY.ipt.addEventListener("load", () => {
        jO.qs.Ys.opt(HO, XO)
    }
    )
}
{
    const YO = self.t
      , JO = self.lang
      , ZO = YO.ek(import.meta.url)
      , QO = ZO.getElementById("exportStandardOptionsDialog")
      , tD = YO.tk(ZO.URL);
    YO.p.ik(tD + "lang");
    const iD = "ExportStandardOptions"
      , eD = YO.qs.Jj.lzn = class extends YO.qs.Ys {
        constructor() {
            super(QO),
            this.rhs = this.dwt("nextButton"),
            this.rhs.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.uzn = this.y$t("exportDeduplicateImages"),
            this.czn = this.y$t("exportLosslessImageFormat"),
            this.dzn = this.y$t("exportLossyImageFormat"),
            this.fzn = this.y$t("exportOptimizeImages"),
            this.pzn = this.y$t("exportMinifyMode"),
            this.mzn = this.dwt("offlineSupportWrap"),
            this.wzn = this.y$t("exportOfflineSupport"),
            this.pwt = null,
            this.czn.value = "webp",
            this.dzn.value = "avif"
        }
        Swt() {
            YO.p.u("ui.dialogs.exportStandardOptions"),
            this.Ya(JO(".caption")),
            this.rhs.textContent = JO("common.next"),
            this.lhs.textContent = JO("common.cancel");
            const t = this.dwt("helpLink");
            t.textContent = JO("common.help"),
            t.onclick = () => self.app.s_("overview/publishing-projects", "ExportStandardOptionsDialog"),
            this.dwt("imageHeader").textContent = JO(".image-options"),
            this.dwt("exportDeduplicateImagesLabel").textContent = JO(".deduplicate-images"),
            this.dwt("exportLosslessImageFormatLabel").textContent = JO(".lossless-format"),
            this.dwt("exportLossyImageFormatLabel").textContent = JO(".lossy-format"),
            this.dwt("exportOptimizeImagesLabel").textContent = JO(".optimize-images"),
            this.dwt("scriptHeader").textContent = JO(".script-options"),
            YO.p.u(".minify-script"),
            this.dwt("exportMinifyScriptDescription").textContent = JO(".description"),
            this.dwt("exportMinifyModeLabel").textContent = JO(".mode.label");
            for (let t = 0, i = this.pzn.options.length; t < i; ++t) {
                const i = this.pzn.options[t];
                i.textContent = JO(".mode." + i.value)
            }
            YO.p.j(),
            this.dwt("otherHeader").textContent = JO(".other-options"),
            this.dwt("exportOfflineSupportLabel").textContent = JO(".offline-support.label"),
            YO.odt(this.dwt("offlineSupportDescription"), YO.v(YO.MC, JO(".offline-support.description"), {
                links: [ () => self.app.e_("https://www.construct.net/tutorials/offline-games-construct-8", "ExportOfflineSupportLearnMore")]
            })),
            YO.p.j()
        }
        Qa(t, i) {
            this.pwt = t.sx;
            const e = t.dPe
              , s = super.Qa(i);
            YO.p.u("ui.dialogs.exportStandardOptions.minify-script");
            let n = JO(".description");
            const r = [];
            return this.pwt.VU() && (n += " " + JO(".advanced-note"),
            r.push( () => self.app.s_("scripting/guides/advanced-minification", "ExportMinifyAdvancedLearnMore"))),
            YO.odt(this.dwt("exportMinifyScriptDescription"), YO.v(YO.MC, n, {
                links: r
            })),
            YO.p.j(),
            this.mzn.style.display = e.t_e() ? "" : "none",
            this.wzn.checked = !0,
            localforage.getItem("export-std-options").then(t => {
                t && (this.uzn.checked = t.deduplicateImages,
                this.czn.value = t.losslessFormat,
                this.dzn.value = t.lossyFormat,
                this.fzn.checked = t.optimizeImages || t.recompressImages,
                this.pzn.value = t.minifyMode2 ?? "none",
                this.wzn.checked = "boolean" != typeof t.offlineSupport || t.offlineSupport)
            }
            ).catch(YO.Gv),
            s
        }
        async gwt() {
            const t = self.app;
            "none" !== this.pzn.value && await t.JN() ? t.j_(this.pwt, 28) : (localforage.setItem("export-std-options", {
                deduplicateImages: this.uzn.checked,
                losslessFormat: this.czn.value,
                lossyFormat: this.dzn.value,
                optimizeImages: this.fzn.checked,
                minifyMode2: this.pzn.value,
                offlineSupport: this.wzn.checked
            }).catch(YO.Gv),
            this.PR({
                mPe: this.uzn.checked,
                c_e: this.czn.value,
                u_e: this.dzn.value,
                n_e: this.fzn.checked,
                yPe: this.pzn.value,
                s_e: this.wzn.checked
            }))
        }
        VW() {
            this.pwt = null
        }
    }
    ;
    YO.qs.HY.ipt.addEventListener("load", () => {
        YO.qs.Ys.opt(iD, eD)
    }
    )
}
{
    const sD = self.t
      , nD = self.lang
      , rD = self.tP
      , hD = self.tG
      , oD = sD.ek(import.meta.url)
      , aD = oD.getElementById("exportStatsDialog")
      , lD = sD.tk(oD.URL);
    sD.p.ik(lD + "lang");
    const uD = "ExportStats"
      , cD = sD.qs.Jj.gzn = class extends sD.qs.Ys {
        constructor() {
            super(aD),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.IEe = null
        }
        Swt() {
            this.lKi.textContent = nD("common.done")
        }
        Qa(t, i) {
            sD.Yq(t),
            sD.U(t.yzn, self.Gas);
            const e = t.yzn
              , s = e.yn()
              , n = e.YIt();
            this.IEe = n,
            sD.p.u("ui.dialogs.exportStats"),
            this.Ya(nD(".caption")),
            sD.odt(this.dwt("exportDurationMessage"), hD(".duration-message", sD.PBe(Math.round(n.kPe / 1e3)))),
            sD.odt(this.dwt("scriptSizeInfo"), this.bzn(n)),
            sD.odt(this.dwt("dataSizeInfo"), this.vzn(n)),
            sD.odt(this.dwt("imageSizeInfo"), this.Szn(n)),
            sD.odt(this.dwt("deduplicationInfo"), this.xzn(n)),
            sD.odt(this.dwt("audioSizeInfo"), this.Mzn(s));
            let r = (n.FPe || n.LPe || n.bPe) + (n.TPe || n.EPe) + n.gPe + s.dhi() + s.fhi() + (t.Ezn || 0)
              , h = s.fhi();
            t.Czn ? h = NaN : s.sse() || (h += s.dhi()),
            sD.odt(this.dwt("overallSizeInfo"), this._zn(r, h)),
            sD.odt(this.dwt("overallSizeSummary"), hD(".overall-size-summary", sD.Iye(r))),
            sD.p.j();
            const o = this.dwt("customSizeInfo");
            return t.Tzn ? (sD.odt(o, t.Tzn),
            o.style.display = "") : o.style.display = "none",
            super.Qa(i)
        }
        bzn(t) {
            let i = ""
              , e = t.bPe
              , s = t.FPe;
            if ("none" === t.yPe)
                i = hD(".script-size-no-minify", sD.Iye(e), s ? sD.Iye(s) : nD(".not-applicable"));
            else {
                let n = t.LPe;
                i = hD(".script-size-minified", sD.Iye(e), sD.Iye(n), s ? sD.Iye(s) : nD(".not-applicable"))
            }
            return i
        }
        vzn(t) {
            let i = t.EPe
              , e = t.TPe;
            return hD(".data-file-size", sD.Iye(i), e ? sD.Iye(e) : nD(".not-applicable"))
        }
        Szn(t) {
            return hD(t.n_e ? ".optimized-image-size-message" : ".unoptimized-image-size-message", sD.Iye(t.gPe))
        }
        xzn(t) {
            let i = "";
            return i = t.mPe ? hD(".deduplication-message", t.NPe, sD.Iye(t.DPe)) : hD(".no-deduplication-message"),
            i
        }
        Mzn(t) {
            return hD(".audio-size", sD.Iye(t.dhi()), sD.Iye(t.fhi()))
        }
        _zn(t, i) {
            return new sD.MC(rD(".overall-size", sD.Iye(t), isNaN(i) ? nD(".not-applicable") : sD.Iye(t - i)),{
                links: [ () => self.app.s_("tips-and-guides/download-size", "ExportStatsDialog")]
            })
        }
        VW() {
            this.IEe = null
        }
    }
    ;
    sD.qs.HY.ipt.addEventListener("load", () => {
        sD.qs.Ys.opt(uD, cD)
    }
    )
}
{
    const dD = self.t
      , fD = self.Uze
      , pD = self.lang
      , mD = self.tP
      , wD = dD.ek(import.meta.url)
      , gD = wD.getElementById("fileListDialog")
      , yD = "FileList"
      , bD = dD.tk(wD.URL)
      , vD = ["DROPBOX", "ONE DRIVE", "GOOGLE DRIVE", "LOCAL STORAGE"]
      , SD = new Set
      , xD = ["NAME_ASC", "NAME_DEC", "DATE_ASC", "DATE_DEC", "SIZE_ASC", "SIZE_DEC"];
    let MD = !1;
    function ED(t, i) {
        return dD.zt(t),
        dD.zt(i),
        dD.qs.Ys.$s("Confirm").Qa({
            caption: t,
            message: i
        }, gD)
    }
    function CD(t) {
        return dD.zt(t),
        dD.qs.Ys.$s("OK").Qa(t, gD)
    }
    dD.p.ik(bD + "lang");
    const _D = dD.qs.Jj.Izn = class extends dD.qs.Ys {
        constructor() {
            super(gD),
            dD.p.u("ui.dialogs.fileList");
            const t = dD.qs.rA
              , i = t => self.app.oi(t);
            this.yTt = dD.v(t, this.y5t(), this);
            const e = t.uA(28);
            this._Tt = this.yTt.wA("horizontalToolbar", e, [t.pA("refresh", i("reload"), pD(".refresh"), () => this.Vwt(!0)), t.pA("add folder", i("add-folder"), pD(".add-folder"), () => this.rHi()), t.pA("upload", i("cloud-upload"), pD(".upload"), () => this.Pzn()), t.pA("up", i("up-arrow"), pD(".up"), () => this.Gzn()), t.Nk(!1, "dividerA", !1), t.lJt("service", [{
                value: "",
                label: pD(".selectService"),
                selected: !0,
                disabled: !0
            }, {
                value: "DROPBOX",
                label: "Dropbox"
            }, {
                value: "ONE DRIVE",
                label: "OneDrive"
            }, {
                value: "GOOGLE DRIVE",
                label: "Google Drive"
            }], pD(".service"), t => this.Azn(t), !1, !0), t.pA("logout", i("account-logout"), pD(".logout"), () => this.Rzn()), t.Nk(!1, "dividerB", !1), t.fZt("filter", "", pD(".search"), t => this.jue(t), !1, !0)]),
            this.kzn = xD[0],
            this.yTt.fA();
            let s = this.yTt.YBt()
              , n = dD.v(dD.qs.Cgt)
              , r = document.createElement("input")
              , h = document.createElement("button")
              , o = dD.v(dD.qs.Jj.Table, s, {
                pEi: !1
            })
              , a = document.createElement("div")
              , l = document.createElement("span");
            this.lui = {
                service: this._Tt.bA("service"),
                search: this._Tt.bA("filter"),
                upload: this._Tt.bA("upload"),
                refresh: this._Tt.bA("refresh"),
                add: this._Tt.bA("add folder"),
                up: this._Tt.bA("up"),
                Ozn: this._Tt.bA("dividerA"),
                Dzn: this._Tt.bA("dividerB"),
                Fzn: this._Tt.bA("logout"),
                Lzn: s,
                table: o,
                Bzn: n,
                filename: r,
                Uzn: h
            },
            this.Nzn = ["root"],
            this.lui.table.Got().kot("icon", 20, "").kot("name", 160, pD(".name")).kot("date", 120, pD(".dateModified")).Mot("size", pD(".size")),
            this.hk().setAttribute("loading", ""),
            l.textContent = pD(".filename"),
            a.className = "tray",
            s.appendChild(n.element),
            a.appendChild(l),
            a.appendChild(r),
            a.appendChild(h),
            this.mZe().appendChild(a),
            this.Hye = dD.v(dD.kh, dD.jh.Gh(self.app, "settingschange", () => this.yP()), dD.jh.Gh(dD.fk, "afterload", () => this.yP()), dD.jh.Gh(o, "rowcontextmenu", t => this.Zot(t)), dD.jh.Gh(o, "rowselected", t => this.jzn(t.ght)), dD.jh.Gh(o, "rowdoubletapped", t => this.lme(t)), dD.jh.Gh(h, "pointerdown", t => this.$zn(t)), dD.jh.Gh(r, "input", () => this.zzn(r.value))),
            this.TNt = null,
            this.Vzn = null,
            this.Wzn = null,
            this.Hzn = !1,
            this.fui = new Map,
            this.Kzn = !1,
            this.qzn = null,
            this.Xzn = null,
            this.Yzn = null,
            this.Jzn = null,
            this.Zzn = null,
            this.lui.table.x_(!1),
            this.lui.Bzn.E7t(),
            dD.p.j("ui.dialogs.fileList"),
            this.yP()
        }
        yP() {
            const t = self.app.r0();
            this.Kzn = t.cloudCache || !1
        }
        Qzn() {
            this.jye({
                service: "LOCAL STORAGE" === this.Vzn ? this.Wzn : this.Vzn,
                table: this.lui.table.QL(),
                sort: this.kzn
            })
        }
        tVn(t, i) {
            self.assert(xD.includes(t), "invalid sort mode"),
            this.kzn !== t && (this.kzn = t,
            i || (this.Vwt(),
            this.Qzn()))
        }
        iVn() {
            const t = this.Oye()
              , i = t && t.service
              , e = t && t.table
              , s = t && t.sort;
            i && !this.Vzn && this.Azn(i, !0),
            s && this.tVn(s, !0),
            e && this.lui.table.tU(e)
        }
        jue(t) {
            dD.zt(t),
            t = t.trim().toLowerCase();
            for (let i of this.fui.entries())
                i[0].name.toLowerCase().includes(t) ? i[1].x_(!0) : (i[1] === this.qzn && this.eVn(),
                i[1].x_(!1))
        }
        Azn(t, i) {
            if (!t)
                return this.lui.service.iZt(0),
                void (this.Vzn = null);
            dD.zt(t),
            this.Vzn !== t && vD.includes(t) && (this.Nzn.length = 1,
            this.lui.service.ORe(t),
            this.Vzn = t,
            SD.has(t) || (SD.add(t),
            self.app.Lii("CloudSave", this.Vzn)),
            i || (this.Vwt(),
            this.Qzn()))
        }
        zzn(t) {
            dD.zt(t);
            const i = this.sVn(t.toLowerCase());
            if (i.Rze()) {
                const e = i.Oze();
                for (const i of this.fui.entries())
                    if (i[0].name.toLowerCase() === e)
                        return this.jzn(i[1], t),
                        i
            }
            this.qzn ? (this.qzn.xD(),
            "OPEN" === this.TNt && this.nVn(!1),
            this.qzn = null,
            this.Xzn = null) : "SAVE" === this.TNt && this.nVn(0 !== t.length)
        }
        Gzn() {
            this.Nzn.length > 1 && (this.Nzn.pop(),
            this.Vwt())
        }
        async rHi() {
            const t = this.rVn()
              , i = dD.qs.Ys.$s("Input");
            dD.p.u("ui.dialogs.fileList.add-folder-dialog");
            const e = {
                caption: pD(".caption"),
                message: pD(".message"),
                label: pD(".label"),
                c0e: "New folder"
            };
            dD.p.j();
            const s = await i.Qa(e);
            if (null === s || 0 === s)
                return;
            const n = this.sVn(s, !0);
            if (!n.Rze())
                return CD(n.Dze());
            {
                this.hVn(pD("ui.dialogs.fileList.creatingFolder"));
                const i = n.Oze();
                try {
                    await self.jk.oVn(i, t, this.Vzn),
                    this.Vwt()
                } catch (t) {
                    return CD(pD("ui.dialogs.fileList.failedCreatingFolder"))
                }
                this.aVn()
            }
        }
        async Pzn() {
            const t = await dD.qs.Qyi.tbi(".c3p", null, !1, !1);
            if (null === t)
                return;
            const i = this.rVn()
              , e = this.sVn(t.name);
            if (e.kze())
                return void CD(e.Dze());
            const s = e.Oze();
            this.hVn(pD("ui.dialogs.fileList.uploading"));
            try {
                let e = null
                  , n = null;
                for (const t of this.fui.keys())
                    if (t.name.toLowerCase() === s) {
                        e = t;
                        break
                    }
                if (e) {
                    if (!await ED(pD("ui.dialogs.fileList.overwriteFile"), mD("ui.dialogs.fileList.confirmOverwrite", e.name)))
                        return;
                    n = e.id
                }
                try {
                    await self.jk.lVn(t, n, s, i, this.Vzn),
                    this.Vwt()
                } catch (t) {
                    throw t.message
                }
            } catch (t) {
                this.aVn(),
                CD(t)
            }
        }
        uVn(t) {
            t && "folder" == t.type && (this.Nzn.push(t.id),
            this.Vwt())
        }
        cVn(t, i) {
            const e = t.shift();
            for (const s of i)
                if (s.id == e)
                    return t.length > 0 ? this.cVn(t, s.children) : s.children;
            throw new Error("Invalid location")
        }
        async dVn(t) {
            const i = this.rVn()
              , e = this.Vzn;
            for (const s of t) {
                if (i != this.rVn())
                    return;
                if (e != this.Vzn)
                    return;
                if (!this._Wt)
                    return;
                if ("folder" === s.type)
                    try {
                        await self.jk.Xfs(e, !1, s.id)
                    } catch (t) {
                        return void console.error(`Failed to preload child entries of "${i}": `, t)
                    }
            }
        }
        async Vwt(t) {
            if (this.Vzn) {
                let i = this.lui.filename.value;
                this.hVn(mD("ui.dialogs.fileList.getFiles", dD.iPs(this.Vzn)));
                try {
                    const e = this.rVn()
                      , s = await self.jk.Xfs(this.Vzn, t, e);
                    this.Kzn && this.dVn(s),
                    this.fVn();
                    const n = new Set([".c3p", ".capx"]);
                    for (const t of this.pVn(s)) {
                        if ("folder" !== t.type && !n.has(t.ext))
                            continue;
                        const i = this.xsn(t);
                        this.fui.set(t, i)
                    }
                    this.zzn(i),
                    this.aVn()
                } catch (t) {
                    console.error(t),
                    this.mVn(t)
                }
            }
        }
        wVn(t, i) {
            if (t.type === i.type) {
                const e = t.name.toLowerCase()
                  , s = i.name.toLowerCase();
                return e > s ? 1 : s > e ? -1 : 0
            }
            return "file" === t.type ? 1 : -1
        }
        gVn(t, i) {
            if (t.type === i.type) {
                const e = new Date(t.date || 0).getTime() - new Date(i.date || 0).getTime();
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }
            return "file" === t.type ? 1 : -1
        }
        yVn(t, i) {
            if (t.type === i.type) {
                const e = t.size - i.size;
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }
            return "file" === t.type ? 1 : -1
        }
        pVn(t) {
            switch (this.kzn) {
            case "NAME_ASC":
                return t.sort( (t, i) => this.wVn(t, i));
            case "NAME_DEC":
                return t.sort( (t, i) => this.wVn(i, t));
            case "DATE_ASC":
                return t.sort( (t, i) => this.gVn(t, i));
            case "DATE_DEC":
                return t.sort( (t, i) => this.gVn(i, t));
            case "SIZE_ASC":
                return t.sort( (t, i) => this.yVn(t, i));
            case "SIZE_DEC":
                return t.sort( (t, i) => this.yVn(i, t))
            }
        }
        async Rzn() {
            if (this.Vzn) {
                this.hVn(mD("ui.dialogs.fileList.logging-out", dD.iPs(this.Vzn))),
                this.fVn();
                try {
                    await self.jk.bVn(this.Vzn),
                    this.hVn(null, !0)
                } catch (t) {
                    this.mVn(t)
                }
                this.Azn("")
            }
        }
        mVn(t) {
            let i;
            i = "string" == typeof t ? t : pD("ui.dialogs.fileList.failedToRefresh"),
            this.lui.refresh.bet(!0),
            this.lui.upload.bet(!0),
            this.lui.up.bet(!1),
            this.lui.add.bet(!1),
            this.lui.service.bet(!0),
            this.lui.table.x_(!1),
            this.lui.search.bet(!1),
            this.lui.Bzn.x_(!0),
            this.vVn(i),
            this.hk().setAttribute("loading", ""),
            this.lui.Bzn.E7t()
        }
        hVn(t, i) {
            i ? t = pD("ui.dialogs.fileList.pleaseSelectService") : dD.zt(t),
            this.lui.Fzn.bet(!1),
            this.lui.upload.bet(!1),
            this.lui.refresh.bet(!1),
            this.lui.up.bet(!1),
            this.lui.add.bet(!1),
            this.lui.service.bet(i),
            this.lui.table.x_(!1),
            this.lui.search.bet(!1),
            this.lui.Bzn.x_(!0),
            this.vVn(t),
            this.hk().setAttribute("loading", ""),
            i ? this.lui.Bzn.E7t() : this.lui.Bzn.Ppn()
        }
        aVn() {
            this.lui.table.x_(!0),
            this.lui.up.bet(this.Nzn.length > 1),
            this.lui.add.bet(!0),
            this.lui.refresh.bet(!0),
            this.lui.upload.bet(!0),
            this.lui.service.bet(!0),
            this.lui.search.bet(!0),
            this.lui.Bzn.x_(!1),
            this.lui.Fzn.bet(!0),
            this.hk().removeAttribute("loading")
        }
        eVn() {
            this.qzn && (this.qzn.xD(),
            this.nVn(!1),
            this.qzn = null,
            this.Xzn = null)
        }
        jzn(t, i) {
            if (this.qzn === t)
                return;
            this.eVn();
            const e = t.Pp();
            e && "file" == e.type && (this.nVn(!0),
            this.lui.filename.value = i || e.name,
            this.qzn = t,
            this.Xzn = e,
            t.YB())
        }
        lme(t) {
            this.$zn(t)
        }
        Zot(t) {
            const i = t.ght
              , e = dD.v(dD.qs.Ek, this.lui.Lzn)
              , s = i.Pp();
            s && ("file" == s.type ? e.Pk(null, pD("ui.dialogs.fileList.downloadFile"), () => this.SVn(i)) : e.Pk(null, pD("ui.dialogs.fileList.open"), () => this.uVn(s))),
            "name" === t.fnt && (e.Pk(null, pD("ui.dialogs.fileList.sortNameAscending"), () => this.tVn("NAME_ASC")),
            e.Pk(null, pD("ui.dialogs.fileList.sortNameDescending"), () => this.tVn("NAME_DEC"))),
            "date" === t.fnt && (e.Pk(null, pD("ui.dialogs.fileList.sortDateAscending"), () => this.tVn("DATE_ASC")),
            e.Pk(null, pD("ui.dialogs.fileList.sortDateDescending"), () => this.tVn("DATE_DEC"))),
            "size" === t.fnt && (e.Pk(null, pD("ui.dialogs.fileList.sortSizeAscending"), () => this.tVn("SIZE_ASC")),
            e.Pk(null, pD("ui.dialogs.fileList.sortSizeDescending"), () => this.tVn("SIZE_DEC"))),
            e.Pk(null, pD("ui.dialogs.fileList.deleteFile"), () => this.xVn(i)),
            e.Pk(null, pD("ui.dialogs.fileList.renameFile"), () => this.MVn(i)),
            e.nF(t.clientX, t.clientY)
        }
        async xVn(t) {
            const i = t.Pp();
            if (!i)
                return;
            if (!await ED(pD("ui.dialogs.fileList.deleteFile"), mD("ui.dialogs.fileList.confirmDelete", i.name)))
                return;
            this.hVn(pD("ui.dialogs.fileList.deletingFile"));
            const e = this.rVn(i);
            try {
                await self.jk.lD(i.id, e, this.Vzn);
                let s = this.lui.filename.value;
                this.Xzn === i && (this.Xzn = null,
                t.xD(),
                this.qzn = null),
                this.fui.delete(i),
                this.lui.table.J7t(t),
                this.zzn(s),
                !this.Xzn && s && (this.lui.filename.value = s,
                this.nVn(!0))
            } catch (t) {
                (() => {})("failed to delete file", t),
                CD(mD("ui.dialogs.fileList.failedDelete", i.name))
            } finally {
                this.aVn()
            }
        }
        nVn(t) {
            this.lui.Uzn.disabled = !t
        }
        rVn() {
            const t = this.Nzn.length;
            return this.Nzn[t - 1]
        }
        SVn(t) {
            let i = t.Pp();
            self.jk.qU(i.name, i.id, this.Vzn)
        }
        EVn(t, i) {
            const e = t.Pp()
              , s = "file" == e.type;
            e.id = i.id,
            e.name = i.name,
            e.date = i.date;
            const n = i.name
              , r = new Date(i.date).toLocaleString(self.app.iwt(), {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "numeric",
                minute: "numeric"
            })
              , h = s ? isNaN(e.size) ? pD("ui.dialogs.fileList.unknown") : dD.Iye(e.size) : e.children.length.toString();
            t.Xot("name").pa(n),
            t.Xot("date").pa(r),
            t.Xot("size").pa(h)
        }
        async MVn(t) {
            const i = t.Pp();
            if (!i)
                return;
            const e = t.Xot("name")
              , s = e.VB()
              , n = "folder" == i.type
              , r = this.rVn(i);
            let h = await e.$B();
            if (null == h || h === s)
                return;
            const o = this.sVn(h, n);
            if (o.kze())
                return CD(o.Dze());
            const a = o.Oze();
            try {
                if (!await ED(pD("ui.dialogs.fileList.renameFile"), mD("ui.dialogs.fileList.confirmRename", i.name, a)))
                    return;
                this.hVn(pD("ui.dialogs.fileList.renamingFile"));
                const e = await self.jk.GB(i.id, r, this.Vzn, a);
                this.EVn(t, e),
                this.Xzn === i && (this.Xzn = null,
                t.xD(),
                this.qzn = null);
                const s = this.lui.filename.value;
                this.zzn(s),
                !this.Xzn && s && (this.lui.filename.value = s,
                this.nVn(!1))
            } catch (t) {
                (() => {})("Failed to rename file", t),
                CD(mD("ui.dialogs.fileList.failedRename", i.name, a))
            } finally {
                this.aVn()
            }
        }
        AZe(...t) {
            return this.Qzn(),
            this.Jzn && (this.Jzn(null),
            this.Jzn = null),
            super.AZe(...t)
        }
        gwt() {
            dD.qs.Ek.X1() || this.$zn()
        }
        tWt() {
            this.cu()
        }
        $zn(t) {
            if (t) {
                const i = t.ght
                  , e = i && i.Pp();
                if (e && "folder" == e.type)
                    return void this.uVn(e)
            }
            "SAVE" === this.TNt ? this.CVn() : this._Vn()
        }
        _Vn() {
            this.Xzn && "file" == this.Xzn.type && (this.Jzn && this.Jzn([this.Vzn, this.Xzn]),
            this.cu())
        }
        CVn() {
            if (this.Xzn && "file" == this.Xzn.type) {
                if (".capx" === this.Xzn.ext)
                    return void CD(pD("ui.dialogs.fileList.cannotSaveCAPX"));
                ED(pD("ui.dialogs.fileList.overwriteFile"), mD("ui.dialogs.fileList.confirmOverwrite", this.Xzn.name)).then(t => {
                    t && (this.Jzn && this.Jzn([this.Vzn, this.Xzn.name, this.Xzn.id, this.Xzn.parent]),
                    this.cu())
                }
                )
            } else {
                const t = this.rVn()
                  , i = this.sVn(this.lui.filename.value);
                if (i.kze())
                    return CD(i.Dze());
                this.Jzn && this.Jzn([this.Vzn, i.Oze(), null, t]),
                this.cu()
            }
        }
        TVn(t) {
            dD.qs.Ys.$s("OK").Qa(t, this.lui.Lzn)
        }
        sVn(t, i) {
            let e, s = t.trim(), n = /\.([^.]*)$/;
            if (0 === s.length)
                return fD.Lze(pD("ui.dialogs.fileList.filenameNone"));
            if (e = /([\\/:\*\?"<>\|])/i.exec(s))
                return fD.Lze(mD("ui.dialogs.fileList.filenameIllegalCharacter", e[1]));
            if (e = /^(nul|prn|con|lpt[0-9]|com[0-9])(\.|$)/i.exec(s))
                return fD.Lze(mD("ui.dialogs.fileList.filenameReservedName", e[1]));
            if (e = /^\./.exec(s))
                return fD.Lze(pD("ui.dialogs.fileList.filenamePrivate"));
            if (!i) {
                if (e = n.exec(s),
                e && "c3p" !== e[1])
                    return fD.Lze(mD("ui.dialogs.fileList.filenameExtension", e[1]));
                e || (s += ".c3p")
            }
            return fD.Ok(s)
        }
        cu() {
            this.fVn(),
            this.vwt()
        }
        fVn() {
            this.eVn(),
            this.lui.table.tC(),
            this.fui.clear(),
            this.lui.search.ets("")
        }
        xsn(t) {
            const i = "file" == t.type;
            let e;
            e = i ? "file" : t.isShared ? "shared-folder" : "open-folder";
            const s = self.app.oi(e);
            let n = ""
              , r = "";
            return i && (n = isNaN(t.size) ? pD("ui.dialogs.fileList.unknown") : dD.Iye(t.size)),
            t.date && (r = new Date(t.date).toLocaleString(self.app.iwt(), {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "numeric",
                minute: "numeric"
            })),
            this.lui.table.Eot(t).Lot("icon", s).Tot("name", t.name).Aot("date", r).Aot("size", n)
        }
        INt(t) {
            if (dD.zt(t),
            "SAVE" == t)
                this.lui.Uzn.textContent = pD("ui.dialogs.fileList.save"),
                this.Ya(pD("ui.dialogs.fileList.saveProject"));
            else {
                if ("OPEN" != t)
                    throw new Error("Invalid file list mode selected");
                this.lui.Uzn.textContent = pD("ui.dialogs.fileList.open"),
                this.Ya(pD("ui.dialogs.fileList.openProject")),
                this.lui.filename.value = ""
            }
            this.TNt = t
        }
        vVn(t) {
            dD.zt(t),
            this.lui.Bzn.Sgt = t
        }
        IVn(t) {
            t ? this.Hzn ? this.Vwt() : (this.Hzn = !0,
            this.Wzn = this.Vzn,
            this.Azn("LOCAL STORAGE"),
            this.lui.refresh.x_(!1),
            this.lui.Ozn.x_(!1),
            this.lui.Dzn.x_(!1),
            this.lui.service.x_(!1),
            this.lui.Fzn.x_(!1)) : (this.Hzn && (this.Hzn = !1,
            this.Azn(null),
            this.lui.refresh.x_(!0),
            this.lui.Ozn.x_(!0),
            this.lui.Dzn.x_(!0),
            this.lui.service.x_(!0),
            this.lui.Fzn.x_(!0)),
            this.Vzn ? this.Vwt() : this.Wzn ? (this.Azn(this.Wzn),
            this.Wzn = null) : this.hVn(null, !0))
        }
        PVn(t, i) {
            return this.Zzn = null,
            new Promise(i => {
                this.iVn(),
                this.IVn(t),
                this.Jzn = i,
                this.INt("OPEN"),
                t ? this.GVn().then( () => this.Qa()) : this.Qa()
            }
            )
        }
        AVn(t, i, e) {
            dD.Kq(t);
            const s = self.app.dT()
              , n = s.kB()
              , r = s.xB();
            return this.Zzn = "cloud" === n ? r : null,
            new Promise(e => {
                this.lui.filename.value = t,
                this.iVn(),
                this.IVn(i),
                this.Jzn = e,
                this.INt("SAVE"),
                i ? this.GVn().then( () => this.Qa()) : this.Qa()
            }
            )
        }
        HLt() {
            this.iVn()
        }
        GVn() {
            return MD ? Promise.resolve() : dD.zk.ZRe ? navigator.storage.persisted().then(t => {
                if (MD = !!t,
                !MD)
                    return this.$$n()
            }
            ) : Promise.resolve()
        }
        $$n() {
            return new Promise(t => {
                let i = dD.qs.Ys.$s("Confirm");
                i.Qa({
                    message: self.idt("ui.dialogs.fileList.request-persistence")
                }).then(i => {
                    i || t()
                }
                ),
                i.sOe = () => {
                    const i = navigator.storage.persist().then(t => {
                        if (MD = !!t,
                        !1 === t)
                            return dD.qs.Ys.$s("OK").Qa(pD("ui.dialogs.fileList.declined-persistence"))
                    }
                    );
                    t(i)
                }
            }
            )
        }
    }
    ;
    dD.qs.HY.ipt.addEventListener("load", () => {
        dD.qs.Ys.opt(yD, _D)
    }
    )
}
{
    const TD = self.t
      , ID = TD.ek(import.meta.url)
      , PD = ID.getElementById("iframeDialog")
      , GD = TD.tk(ID.URL);
    TD.p.ik(GD + "lang");
    const AD = "iframe"
      , RD = TD.qs.Jj.RVn = class extends TD.qs.Ys {
        constructor() {
            super(PD),
            this.kVn = null,
            this.pwt = null
        }
        Swt() {}
        Ej(t, i) {
            TD.Kq(t);
            const e = super.Ej(i);
            return this.kVn = this.PH().createElement("iframe"),
            this.kVn.className = "dialogiframe",
            this.kVn.setAttribute("allowfullscreen", "true"),
            this.kVn.setAttribute("scrolling", "no"),
            this.kVn.setAttribute("noresize", "noresize"),
            t && (this.kVn.src = t),
            this.kVn.style.pointerEvents = "",
            this.y5t().appendChild(this.kVn),
            e
        }
        OVn(t) {
            TD.U(t, self.gh),
            this.pwt = t
        }
        QYe() {
            this.DVn()
        }
        rJe() {
            this.FVn()
        }
        JYe() {
            this.DVn()
        }
        nJe() {
            this.FVn()
        }
        DVn() {
            this.kVn.style.pointerEvents = "none"
        }
        FVn() {
            this.kVn.style.pointerEvents = ""
        }
        LVn() {
            return this.kVn
        }
        gwt() {
            this.tWt()
        }
        tWt() {
            TD.Ars.eei() && TD.Ars.hei().rei().BVn(this.pwt)
        }
        VW() {
            this.kVn && (this.kVn.src = "",
            TD.qs.BW(this.kVn),
            this.kVn = null),
            this.pwt = null
        }
    }
    ;
    TD.qs.HY.ipt.addEventListener("load", () => {
        TD.qs.Ys.opt(AD, RD)
    }
    )
}
{
    const kD = self.t
      , OD = self.lang
      , DD = self.tP
      , FD = kD.ek(import.meta.url)
      , LD = FD.getElementById("loginDialog")
      , BD = kD.tk(FD.URL);
    kD.p.ik(BD + "lang");
    const UD = "Login"
      , ND = "https://account.construct.net"
      , jD = "https://accountbeta.construct.net";
    let $D = null
      , zD = !1
      , VD = null
      , WD = null
      , HD = null;
    function KD(t) {
        const i = t.type
          , e = kD.qs.Ys.$s("Login")
          , s = self.app.zj("useraccount");
        if ("cancel" === i)
            e.vwt();
        else if ("init" === i)
            zD = !0,
            kD.qs.BW(e.UVn),
            kD.p.u("ui.dialogs.login"),
            $D({
                type: "lang",
                username: OD(".username"),
                password: OD(".password"),
                "keep-me-logged-in": OD(".keep-me-logged-in"),
                cancel: OD("common.cancel"),
                "log-in": OD(".log-in")
            }),
            kD.p.j(),
            $D({
                type: "auto-login"
            });
        else if ("login-error" === i)
            e.NVn("ManualLoginFailed"),
            e.jVn();
        else if ("login-ok" === i)
            e.NVn("ManualLoginOK"),
            VD(t),
            e.Wp() && e.PR(!0);
        else if ("auto-login-ok" === i)
            VD(t);
        else if ("profile-picture" === i)
            s.$Vn(t);
        else if ("auto-login-skipped" === i)
            s.zVn(t);
        else if ("auto-login-error" === i) {
            const i = t.reason;
            console.info("[Account] Auto-login failed: " + i),
            e.NVn(i ? "AutoLoginFailed-" + i : "AutoLoginFailed"),
            s.VVn(i || "fetch-error")
        } else if ("access-code-ok" === i)
            s.WVn(t);
        else if ("access-code-error" === i) {
            const i = t.reason;
            console.info("[Account] Access code failed: " + i),
            self.app.HVn() || e.NVn("AccessCodeFailed-" + i),
            s.KVn(i)
        } else
            "get-token-result" === i ? (WD && WD(t.data),
            WD = null,
            HD = null) : "get-token-error" === i ? (HD && HD(),
            WD = null,
            HD = null) : (() => {})("[Account] Invalid message from iframe")
    }
    const qD = kD.qs.Jj.qVn = class extends kD.qs.Ys {
        constructor() {
            super(LD),
            this.Get.setAttribute("always-active", ""),
            this.UVn = this.dwt("loginOverlayContent"),
            this.XVn = this.dwt("overlayHeader"),
            this.YVn = this.dwt("overlayMessage"),
            this.JVn = this.dwt("overlayProgress"),
            this.XVn.textContent = OD("ui.dialogs.login.please-wait")
        }
        async ZVn(t) {
            if (VD)
                throw new Error("security exception");
            kD.qd(t),
            VD = t;
            const i = self.app
              , e = i.QVn() ? jD : ND
              , s = new URL(e + "/login")
              , n = new URLSearchParams(s.search);
            n.append("theme", i.r0().theme || "default"),
            n.append("lang", i.iwt()),
            n.append("productType", i.QPe()),
            s.search = n.toString(),
            kD.odt(this.YVn, kD.v(kD.MC, DD("ui.dialogs.login.login-unavailable-message", e), {
                links: [e + "/test"]
            })),
            window.setTimeout( () => {
                zD || (i.zj("useraccount").tWn(),
                this.YVn.removeAttribute("hidden"),
                this.XVn.textContent = OD("ui.dialogs.login.login-unavailable-header"),
                kD.qs.BW(this.JVn))
            }
            , 5e3);
            try {
                const t = await kD.hOe({
                    src: s.toString(),
                    oOe: e,
                    sandbox: "allow-scripts allow-forms allow-same-origin allow-popups allow-storage-access-by-user-activation",
                    parent: this.y5t(),
                    aOe: t => KD(t.data)
                });
                t.il.setAttribute("scrolling", "no"),
                t.il.style.display = "",
                t.il.style.border = "0",
                $D = t.lOe
            } catch (t) {
                console.error("Failed to load account iframe: ", t)
            }
        }
        Swt() {
            kD.p.u("ui.dialogs.login"),
            this.Ya(OD(".caption")),
            kD.p.j()
        }
        Qa(t) {
            return super.Qa(t)
        }
        gwt() {}
        async jVn() {
            this.vwt(),
            await kD.qs.HY.NYe(),
            kD.p.u("ui.dialogs.login.failed-prompt");
            const t = kD.qs.Ys.$s("Confirm");
            t.sOe = () => {
                kD.qs.Ys.$s("Login").Qa()
            }
            ,
            t.Qa({
                caption: OD(".caption"),
                message: OD(".message"),
                jD: OD(".try-again")
            }),
            kD.p.j()
        }
        iWn() {
            this.NVn("ManualLogout"),
            $D && $D({
                type: "logout"
            })
        }
        eWn() {
            return zD
        }
        sWn(t, i) {
            if (kD.zt(t),
            kD.Kq(i),
            !zD)
                throw new Error("login service unavailable");
            $D({
                type: "access-code",
                code: t,
                privateKey: i
            })
        }
        static nWn() {
            return zD ? new Promise( (t, i) => {
                WD = t,
                HD = i,
                $D({
                    type: "get-token"
                })
            }
            ) : Promise.reject("login service unavailable")
        }
        QYe() {
            this.DVn()
        }
        rJe() {
            this.FVn()
        }
        JYe() {
            this.DVn()
        }
        nJe() {
            this.FVn()
        }
        DVn() {
            const t = this.y5t().querySelector("iframe");
            t && (t.style.pointerEvents = "none")
        }
        FVn() {
            const t = this.y5t().querySelector("iframe");
            t && (t.style.pointerEvents = "")
        }
        NVn(t) {
            self.app.Lii("Account", t)
        }
        VW() {
            $D && $D({
                type: "clear"
            })
        }
    }
    ;
    kD.qs.HY.ipt.addEventListener("load", () => {
        kD.qs.Ys.opt(UD, qD);
        kD.qs.Ys.$s("Login").zZe()
    }
    )
}
{
    const XD = self.t
      , YD = self.lang
      , JD = XD.ek(import.meta.url)
      , ZD = JD.getElementById("newProjectDialog")
      , QD = XD.tk(JD.URL);
    XD.p.ik(QD + "lang");
    const tF = "NewProject"
      , iF = XD.qs.Jj.rWn = class extends XD.qs.Ys {
        constructor() {
            super(ZD),
            this.hWn = JD.getElementById("npProjectNameInput"),
            this.oWn = JD.getElementById("npPresetSelect"),
            this.aWn = JD.getElementById("npViewportWidthInput"),
            this.lWn = JD.getElementById("npViewportHeightInput"),
            this.uWn = this.dwt("viewportAspectRatio"),
            this.cWn = JD.getElementById("npOrientationSelect"),
            this.dWn = JD.getElementById("npStartWithSelect"),
            this.fWn = JD.getElementById("npPixelArtCheck"),
            this.pWn = () => this.mWn(),
            this.oWn.onchange = () => this.wWn(),
            this.aWn.onchange = this.pWn,
            this.lWn.onchange = this.pWn,
            this.gWn = null,
            this.yWn = null,
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt()
        }
        Swt() {
            XD.p.u("ui.dialogs.newProject"),
            this.Ya(YD(".caption")),
            this.hWn.placeholder = YD(".new-project-name"),
            this.dwt("projectNameLabel").textContent = YD(".project-name-label"),
            this.dwt("presetLabel").textContent = YD(".preset-label"),
            this.dwt("viewportSizeLabel").textContent = YD(".viewport-size-label"),
            this.dwt("viewportSizeSeparator").textContent = YD(".viewport-size-separator"),
            this.dwt("orientationLabel").textContent = YD(".orientations-label"),
            this.dwt("startWithLabel").textContent = YD(".start-with-label"),
            this.dwt("pixelArtLabel").textContent = YD(".pixel-art-label"),
            this.lKi.textContent = YD(".create"),
            this.lhs.textContent = YD("common.cancel");
            const t = this.dwt("helpLink");
            t.textContent = YD("common.help"),
            t.onclick = () => self.app.s_("interface/dialogs/new-project", "NewProjectDialog"),
            XD.p.u(".presets");
            for (let t = 0, i = this.oWn.options.length; t < i; ++t) {
                const i = this.oWn.options[t];
                i.textContent = YD("." + i.value)
            }
            XD.p.j(),
            XD.p.u(".orientations");
            for (let t = 0, i = this.cWn.options.length; t < i; ++t) {
                const i = this.cWn.options[t];
                i.textContent = YD("." + i.value)
            }
            XD.p.j(),
            XD.p.u(".start-with");
            for (let t = 0, i = this.dWn.options.length; t < i; ++t) {
                const i = this.dWn.options[t];
                i.textContent = YD("." + i.value)
            }
            XD.p.j(),
            XD.p.j()
        }
        Qa(t) {
            const i = super.Qa(t)
              , e = self.app;
            return e.Lii("NewProject", "NewProjectDialogOpened"),
            this.bWn(),
            this.gWn = XD.$Ci(this.aWn, this.pWn),
            this.yWn = XD.$Ci(this.lWn, this.pWn),
            this.dwt("startWithRow").style.display = e.PE() ? "none" : "",
            e.ULt() && localforage.getItem("new-project-options").then(t => {
                if (t) {
                    if (this.oWn.value = t.preset,
                    this.aWn.value = t.viewportWidth,
                    this.lWn.value = t.viewportHeight,
                    this.mWn(),
                    this.cWn.value = t.orientations,
                    !e.PE()) {
                        let i = t.startWith;
                        "script" === i && (i = "javascript"),
                        this.dWn.value = i
                    }
                    this.fWn.checked = t.pixelArtMode
                }
            }
            ).catch(XD.Gv),
            i
        }
        bWn() {
            this.hWn.value = "",
            this.oWn.value = "sd-landscape-16-9",
            this.wWn(),
            this.dWn.value = "event-sheet",
            this.fWn.checked = !1
        }
        gwt() {
            if (this.Pme())
                return;
            const t = self.app
              , i = XD.Fms(this.hWn.value) || YD("ui.dialogs.newProject.new-project-name")
              , e = parseInt(this.aWn.value, 10)
              , s = parseInt(this.lWn.value, 10);
            if (e < 2 || e > 32768 || !isFinite(e))
                return XD.p.u("ui.dialogs.newProject.errors"),
                XD.qs.Jj.QY.nF(this.aWn, "warning", YD(".invalid-width"), YD(".invalid-width-desc")),
                void XD.p.j();
            if (s < 2 || s > 32768 || !isFinite(s))
                return XD.p.u("ui.dialogs.newProject.errors"),
                XD.qs.Jj.QY.nF(this.lWn, "warning", YD(".invalid-height"), YD(".invalid-height-desc")),
                void XD.p.j();
            const n = this.PR(!0)
              , r = t.PE() ? "event-sheet" : this.dWn.value;
            return t.Lii("NewProject", "NewProjectDialogOK-" + r),
            t.vWn(t => {
                t.I(i),
                t.ase(e),
                t.lse(s),
                t.bse(this.cWn.value),
                this.fWn.checked && (t.kse(!0),
                t.use("letterbox-integer-scale"),
                t.wse("low"),
                t.gse("nearest"));
                const n = t.vds();
                n.Qx(2 * t.NW()),
                n.Kx(2 * t.ya())
            }
            , r),
            t.ULt() && localforage.setItem("new-project-options", {
                preset: this.oWn.value,
                viewportWidth: e,
                viewportHeight: s,
                orientations: this.cWn.value,
                startWith: r,
                pixelArtMode: this.fWn.checked
            }).catch(XD.Gv),
            n
        }
        tWt() {
            return self.app.Lii("NewProject", "NewProjectDialogCancel"),
            this.vwt()
        }
        VW() {
            this.gWn.Vh(),
            this.gWn = null,
            this.yWn.Vh(),
            this.yWn = null
        }
        wWn() {
            const t = this.oWn.value;
            if (this.fWn.checked = "retro-style" === t,
            "retro-style" === t)
                this.aWn.value = 320,
                this.lWn.value = 180,
                this.cWn.value = "any";
            else if ("sd-landscape-4-3" === t)
                this.aWn.value = 640,
                this.lWn.value = 480,
                this.cWn.value = "landscape";
            else if ("sd-portrait-4-3" === t)
                this.aWn.value = 480,
                this.lWn.value = 640,
                this.cWn.value = "portrait";
            else if ("sd-landscape-16-9" === t)
                this.aWn.value = 854,
                this.lWn.value = 480,
                this.cWn.value = "landscape";
            else if ("sd-portrait-16-9" === t)
                this.aWn.value = 480,
                this.lWn.value = 854,
                this.cWn.value = "portrait";
            else if ("720p-landscape" === t)
                this.aWn.value = 1280,
                this.lWn.value = 720,
                this.cWn.value = "landscape";
            else if ("720p-portrait" === t)
                this.aWn.value = 720,
                this.lWn.value = 1280,
                this.cWn.value = "portrait";
            else if ("1080p-landscape" === t)
                this.aWn.value = 1920,
                this.lWn.value = 1080,
                this.cWn.value = "landscape";
            else if ("1080p-portrait" === t)
                this.aWn.value = 1080,
                this.lWn.value = 1920,
                this.cWn.value = "portrait";
            else if ("4k-landscape" === t)
                this.aWn.value = 3840,
                this.lWn.value = 2160,
                this.cWn.value = "landscape";
            else {
                if ("4k-portrait" !== t)
                    throw new Error("unknown preset");
                this.aWn.value = 2160,
                this.lWn.value = 3840,
                this.cWn.value = "portrait"
            }
            this.mWn()
        }
        mWn() {
            const t = parseInt(this.aWn.value, 10)
              , i = parseInt(this.lWn.value, 10);
            t < 2 || i < 2 || t > 32768 || i > 32768 || !isFinite(t) || !isFinite(i) || (this.uWn.textContent = self.tP("common.aspect-ratio", ...XD.fse(t, i)))
        }
    }
    ;
    XD.qs.HY.ipt.addEventListener("load", () => {
        XD.qs.Ys.opt(tF, iF)
    }
    )
}
{
    const eF = self.t
      , sF = self.lang
      , nF = eF.ek(import.meta.url)
      , rF = nF.getElementById("welcomeTourDialog")
      , hF = eF.tk(nF.URL);
    eF.p.ik(hF + "lang");
    const oF = "WelcomeTour"
      , aF = eF.qs.Jj.SWn = class extends eF.qs.Ys {
        constructor() {
            super(rF),
            this.xWn = this.dwt("tourButton"),
            this.xWn.onclick = () => this.gwt(),
            this.MWn = this.dwt("noThanksLink"),
            this.MWn.onclick = () => this.tWt(),
            this.fJe = !1,
            this.EWn = !1
        }
        Swt() {
            eF.p.u("ui.dialogs.welcomeTour"),
            this.MWn.textContent = sF(".no-thanks"),
            this.Ya(sF(".caption")),
            this.dwt("welcomeMessage").textContent = sF(".welcome-title"),
            eF.odt(this.dwt("welcomeText"), self.idt("animation" === self.app.QPe() ? ".animate-welcome-text" : ".welcome-text")),
            this.xWn.textContent = sF(".tour-button-text") + " " + eF.Gvt.SUe,
            eF.p.j()
        }
        Qa(t) {
            return this.NVn("Show"),
            this.xWn.disabled = !1,
            super.Qa(t)
        }
        NVn(t) {
            self.app.Lii("WelcomeTourDialog", t)
        }
        async gwt() {
            if (this.EWn)
                return;
            this.EWn = !0,
            this.xWn.disabled = !0,
            this.NVn("OK-StartTour"),
            await self.app.Lj(!0);
            const t = eF.lj.Jm("tour", "animation" === self.app.QPe() ? "startWithTimelines" : "makeAPlatformGame");
            await self.app.hj().pj(t),
            this.PR()
        }
        tWt() {
            this.EWn || (this.EWn = !0,
            this.NVn("Cancel"),
            this.vwt())
        }
    }
    ;
    eF.qs.HY.ipt.addEventListener("load", () => {
        eF.qs.Ys.opt(oF, aF)
    }
    )
}
{
    const lF = self.t
      , uF = self.lang
      , cF = self.tG
      , dF = lF.ek(import.meta.url)
      , fF = dF.getElementById("accountInfoDialog")
      , pF = lF.tk(dF.URL);
    lF.p.ik(pF + "lang");
    const mF = "AccountInfo"
      , wF = new Set(["personal", "gamejam", "access-code", "educational", "startupbusiness", "business"])
      , gF = lF.qs.Jj.CWn = class extends lF.qs.Ys {
        constructor() {
            super(fF),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this._Wn = 256,
            this.TWn = this.dwt("profilePictureWrap"),
            this.TWn.style.width = this._Wn + "px",
            this.TWn.style.height = this._Wn + "px",
            this.IWn = "",
            this.PWn = null,
            this.dwt("registerAccount").onclick = () => this.GWn(),
            this.dwt("loginLink").onclick = () => this.AWn(),
            this.dwt("editProfile").onclick = () => this.RWn()
        }
        Swt() {
            lF.p.u("ui.dialogs.accountInfo"),
            this.lKi.textContent = uF("common.close-dialog"),
            this.Ya(uF(".caption")),
            this.dwt("registerAccount").textContent = uF(".register-account"),
            this.dwt("loginLink").textContent = uF(".log-in"),
            this.dwt("editProfile").textContent = uF(".edit-profile"),
            this.dwt("freeLimitHeader").textContent = uF(".free-section-header"),
            this.dwt("maxEventsLabel").textContent = uF(".max-events-label"),
            this.dwt("maxLayersLabel").textContent = uF(".max-layers-label"),
            this.dwt("maxEffectsLabel").textContent = uF(".max-effects-label"),
            this.dwt("maxWebFontsLabel").textContent = uF(".max-webfonts-label"),
            this.dwt("freeLimitUseAccount").textContent = uF(".free-limit-register-account"),
            this.dwt("licenseThankyou").textContent = uF(".license-thankyou");
            const t = self.app
              , i = this.dwt("guestHelpLink");
            i.textContent = uF("common.help"),
            i.onclick = () => t.s_(lF.o_.URL.$On, "AccountInfoDialog", "GuestHelp");
            const e = this.dwt("accountHelpLink");
            e.textContent = uF("common.help"),
            e.onclick = () => t.s_(lF.o_.URL.$On, "AccountInfoDialog", "AccountHelp");
            const s = this.dwt("yourLicenses");
            s.textContent = uF(".your-licenses"),
            s.onclick = () => t.e_(lF.o_.URL.WOn, "AccountInfoDialog", "YourLicenses"),
            lF.p.j()
        }
        Qa(t, i) {
            this.PWn = t;
            const e = super.Qa(i);
            return this.kWn(),
            e
        }
        kWn() {
            lF.p.u("ui.dialogs.accountInfo");
            const t = self.app;
            if (this.dwt("usernameTitle").textContent = this.PWn.OWn(),
            this.dwt("guestSection").style.display = this.PWn.$j() ? "none" : "",
            this.dwt("accountSection").style.display = this.PWn.$j() ? "" : "none",
            this.dwt("freeLimitsSection").style.display = t.k_() ? "" : "none",
            this.dwt("freeLimitUseAccount").style.display = this.PWn.$j() ? "none" : "",
            this.dwt("accessCodeSection").style.display = t.HVn() ? "" : "none",
            this.PWn.$j() && this.PWn.DWn()) {
                this.dwt("offlineSection").style.display = "";
                const i = new Date(1e3 * t.FWn())
                  , e = i - Date.now();
                lF.odt(this.dwt("offlineText"), cF(".offline-mode", i.toLocaleDateString(t.iwt(), {
                    weekday: "long",
                    day: "numeric",
                    month: "long",
                    year: "numeric"
                }), e > 0 ? lF.PBe(e / 1e3, {
                    IBe: !1
                }) : uF("common.time.a-short-while")))
            } else
                this.dwt("offlineSection").style.display = "none";
            lF.qs.BYt(this.TWn);
            const i = this.dwt("licenseBadge");
            i.classList.remove("licenseBadgeFree"),
            i.classList.remove("licenseBadgeLicensed");
            const e = this.dwt("licenseThankyou")
              , s = this.dwt("gameJamSection");
            if (t.k_())
                i.classList.add("licenseBadgeFree"),
                i.textContent = uF(".license-type.free-edition"),
                e.style.display = "none",
                s.style.display = "none",
                this.dwt("maxEventsCount").textContent = t.eAt(),
                this.dwt("maxLayersCount").textContent = t.UVt(),
                this.dwt("maxEffectsCount").textContent = t.iri(),
                this.dwt("maxWebFontsCount").textContent = t.sL();
            else {
                const n = t.LWn();
                i.classList.add("licenseBadgeLicensed"),
                e.style.display = "gamejam" === n ? "none" : "",
                s.style.display = "gamejam" === n ? "" : "none";
                const r = wF.has(n) ? n : "other";
                if (i.textContent = uF(".license-type." + r),
                "gamejam" === n) {
                    const i = new Date(1e3 * t.FWn())
                      , e = i - Date.now();
                    lF.odt(this.dwt("gameJamText"), cF(".gamejam-info", i.toLocaleDateString(t.iwt(), {
                        weekday: "long",
                        day: "numeric",
                        month: "long",
                        year: "numeric"
                    }), e > 0 ? lF.PBe(e / 1e3, {
                        IBe: !1
                    }) : uF("common.time.a-short-while")))
                } else if ("access-code" === n) {
                    const i = new Date(1e3 * t.FWn())
                      , e = i - Date.now();
                    lF.odt(this.dwt("accessCodeText"), cF(".access-code-info", i.toLocaleDateString(t.iwt(), {
                        weekday: "long",
                        day: "numeric",
                        month: "long",
                        year: "numeric"
                    }), e > 0 ? lF.PBe(e / 1e3, {
                        IBe: !1
                    }) : uF("common.time.a-short-while")))
                }
            }
            this.PWn.BWn().then(t => {
                this.IWn = URL.createObjectURL(t);
                const i = new Image;
                i.src = this.IWn,
                i.style.width = this._Wn + "px",
                i.style.height = this._Wn + "px",
                i.alt = uF("user-account.user-avatar"),
                this.TWn.appendChild(i)
            }
            ).catch(t => {
                console.error("Error decoding profile picture: ", t)
            }
            ),
            lF.p.j()
        }
        GWn() {
            this.PWn.hAt(),
            this.tWt()
        }
        AWn() {
            this.PWn.oAt(),
            this.tWt()
        }
        RWn() {
            self.app.e_(lF.o_.URL.VOn, "EditProfile"),
            this.tWt()
        }
        VW() {
            this.PWn = null,
            this.IWn && (URL.revokeObjectURL(this.IWn),
            this.IWn = ""),
            lF.qs.BYt(this.TWn)
        }
    }
    ;
    lF.qs.HY.ipt.addEventListener("load", () => {
        lF.qs.Ys.opt(mF, gF)
    }
    )
}
{
    const yF = self.t
      , bF = self.lang
      , vF = self.tP
      , SF = yF.ek(import.meta.url)
      , xF = SF.getElementById("cordovaBuildReportDialog")
      , MF = yF.tk(SF.URL);
    yF.p.ik(MF + "lang");
    const EF = "CordovaBuildReport"
      , CF = yF.qs.Jj.UWn = class extends yF.qs.Ys {
        constructor() {
            super(xF),
            this.lui = {
                ok: this.dwt("okButton"),
                download: this.dwt("downloadBuiltProject"),
                archive: this.dwt("viewArchive"),
                message: this.dwt("buildFinishedMessage")
            },
            this.lui.ok.onclick = t => this.gwt(),
            this.lui.download.onclick = t => this.F0t(),
            this.lui.archive.onclick = t => this.NWn(),
            this.jWn = "",
            this.Oxs = "",
            this.bhs = null
        }
        VW() {
            this.jWn = "",
            this.Oxs = "",
            this.bhs = null
        }
        Swt() {
            yF.p.u("ui.dialogs.cordovaBuildReport");
            const t = this.lui;
            t.ok.textContent = bF("common.ok"),
            t.message.textContent = bF(".build-finished"),
            t.download.textContent = vF(".download-link", this.Oxs),
            t.archive.textContent = bF(".view-archive-manager"),
            this.Ya(vF(".caption", this.jWn)),
            yF.odt(this.dwt("tutorialLink"), new yF.MC(bF(".tutorial-link"),{
                links: [self.app.hEe("https://www.construct.net/tutorials/how-to-publish-mobile-apps-26")]
            })),
            yF.p.j()
        }
        Qa(t, i, e, s) {
            return yF.zt(t),
            yF.zt(i),
            yF.U(e, Blob),
            this.jWn = t,
            this.Oxs = i,
            this.bhs = e,
            this.Swt(),
            super.Qa(s)
        }
        NWn() {
            yF.qs.Ys.$s("ArchiveManager").Qa()
        }
        F0t() {
            yF._Lt(this.Oxs, this.bhs)
        }
    }
    ;
    yF.qs.HY.ipt.addEventListener("load", () => {
        yF.qs.Ys.opt(EF, CF)
    }
    )
}
{
    const _F = self.t
      , TF = self.lang
      , IF = self.tP
      , PF = _F.ek(import.meta.url)
      , GF = PF.getElementById("cordovaOptionsDialog")
      , AF = _F.tk(PF.URL);
    _F.p.ik(AF + "lang");
    const RF = "CordovaOptions"
      , kF = !1
      , OF = _F.qs.Jj.$Wn = class extends _F.qs.Ys {
        constructor() {
            super(GF),
            this.zWn = {
                VWn: this.WWn(),
                properties: this.HWn(),
                KWn: this.qWn()
            },
            this.uvi = this.XWn(),
            this.ELn = null
        }
        WWn() {
            const t = this.dwt("generalSection")
              , i = this.dwt("generalHeading");
            let e, s, n, r, h;
            {
                const t = this.dwt("androidVersion")
                  , i = t.children[0]
                  , s = t.children[1];
                _F.zlt(i),
                _F.zlt(s),
                e = {
                    element: t,
                    label: i,
                    input: s
                }
            }
            {
                const t = this.dwt("androidTargetVersion")
                  , i = t.children[0]
                  , e = t.children[1];
                _F.zlt(i),
                _F.zlt(e),
                s = {
                    element: t,
                    label: i,
                    YWn: e
                }
            }
            {
                const t = this.dwt("iosVersion")
                  , i = t.children[0]
                  , e = t.children[1];
                _F.zlt(i),
                _F.zlt(e),
                n = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            {
                const t = this.dwt("androidTarget")
                  , i = t.children[0]
                  , e = t.children[1];
                _F.zlt(i),
                _F.zlt(e),
                e.addEventListener("change", t => {
                    const i = e.value
                      , s = this.JWn(i);
                    this.ZWn(s)
                }
                ),
                r = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            {
                const t = this.dwt("iosTarget")
                  , i = t.children[0]
                  , e = t.children[1];
                _F.zlt(i),
                _F.zlt(e),
                h = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            return {
                container: t,
                title: i,
                QWn: e,
                tHn: s,
                iHn: r,
                eHn: n,
                sHn: h
            }
        }
        HWn() {
            const t = this.dwt("propertiesSection")
              , i = this.dwt("propertiesHeading")
              , e = {
                element: this.dwt("whitelist"),
                label: null,
                input: null
            };
            e.label = e.element.children[0],
            e.input = e.element.children[1],
            _F.zlt(e.label, "span"),
            _F.zlt(e.input, "input");
            const s = {
                element: this.dwt("versionCode"),
                label: null,
                input: null
            };
            s.label = s.element.children[0],
            s.input = s.element.children[1],
            _F.zlt(s.label, "span"),
            _F.zlt(s.input, "input");
            const n = {
                element: this.dwt("appLicenseKey"),
                label: null,
                input: null
            };
            n.label = n.element.children[0],
            n.input = n.element.children[1],
            _F.zlt(n.label, "span"),
            _F.zlt(n.input, "input");
            const r = {
                element: this.dwt("hideStatusBar"),
                label: null,
                input: null
            };
            r.input = r.element.children[1],
            r.label = r.element.children[2],
            _F.zlt(r.label, "span"),
            _F.zlt(r.input, "input");
            const h = {
                element: this.dwt("vibratePermission"),
                label: null,
                input: null
            };
            h.input = h.element.children[1],
            h.label = h.element.children[2],
            _F.zlt(h.label, "span"),
            _F.zlt(h.input, "input");
            const o = {
                element: this.dwt("cameraPermission"),
                label: null,
                input: null
            };
            o.input = o.element.children[1],
            o.label = o.element.children[2],
            _F.zlt(o.label, "span"),
            _F.zlt(o.input, "input");
            const a = {
                element: this.dwt("microphonePermission"),
                label: null,
                input: null
            };
            a.input = a.element.children[1],
            a.label = a.element.children[2],
            _F.zlt(a.label, "span"),
            _F.zlt(a.input, "input");
            const l = {
                element: this.dwt("useAssetPack"),
                label: null,
                input: null
            };
            return l.input = l.element.children[1],
            l.label = l.element.children[2],
            _F.zlt(l.label, "span"),
            _F.zlt(l.input, "input"),
            {
                container: t,
                title: i,
                nHn: e,
                rHn: s,
                hHn: n,
                oHn: r,
                aHn: h,
                lHn: o,
                uHn: a,
                cHn: l
            }
        }
        qWn() {
            const t = this.dwt("signingSection")
              , i = this.dwt("propertyHeading");
            let e, s, n, r, h;
            {
                const t = this.dwt("keystore")
                  , i = t.children[0];
                let s;
                _F.zlt(i);
                {
                    const e = t.children[1];
                    _F.zlt(i);
                    const n = e.children[0]
                      , r = e.children[1];
                    _F.zlt(n),
                    _F.zlt(r),
                    s = {
                        element: e,
                        input: n,
                        label: r
                    }
                }
                const n = t.children[2]
                  , r = t.children[4]
                  , h = t.children[5];
                _F.zlt(n),
                _F.zlt(r),
                _F.zlt(h),
                r.addEventListener("click", t => _F.qs.Ys.$s("CreateKeystoreDialog").Qa()),
                h.addEventListener("click", i => {
                    s.input.value = null,
                    t.removeAttribute("keystore-selected")
                }
                ),
                s.input.addEventListener("change", i => {
                    const e = s.input.files;
                    e[0] ? (t.setAttribute("keystore-selected", ""),
                    n.textContent = e[0].name) : (t.removeAttribute("keystore-selected"),
                    n.textContent = "")
                }
                ),
                e = {
                    element: t,
                    title: i,
                    select: s,
                    name: n,
                    create: r,
                    clear: h
                }
            }
            {
                const t = this.dwt("keyalias")
                  , i = t.children[0]
                  , e = t.children[1];
                _F.zlt(i),
                _F.zlt(e),
                s = {
                    element: t,
                    label: i,
                    input: e
                }
            }
            {
                const t = this.dwt("passwordVisible")
                  , i = t.children[1]
                  , e = t.children[2];
                _F.zlt(e),
                _F.zlt(i),
                n = {
                    element: t,
                    input: i,
                    label: e
                }
            }
            {
                const t = this.dwt("keystorePassword")
                  , i = t.children[0]
                  , e = t.children[1];
                _F.zlt(i),
                _F.zlt(e),
                r = {
                    element: t,
                    input: e,
                    label: i
                }
            }
            {
                const t = this.dwt("keyPassword")
                  , i = t.children[0]
                  , e = t.children[1];
                _F.zlt(i),
                _F.zlt(e),
                h = {
                    element: t,
                    input: e,
                    label: i
                }
            }
            return n.input.addEventListener("change", t => {
                const i = n.input.checked ? "text" : "password";
                r.input.type = i,
                h.input.type = i
            }
            ),
            {
                container: t,
                title: i,
                dHn: e,
                fHn: s,
                pHn: n,
                mHn: r,
                wHn: h
            }
        }
        XWn() {
            const t = this.dwt("helpLink")
              , i = this.dwt("nextButton")
              , e = this.dwt("cancelButton");
            return t.addEventListener("click", t => self.app.s_("interface/dialogs/cordova-options", "CordovaOptionsDialog")),
            i.addEventListener("click", t => this.gwt()),
            e.addEventListener("click", t => this.tWt()),
            {
                gHn: t,
                yHn: i,
                PD: e
            }
        }
        Swt() {
            this.bHn(),
            this.vHn(),
            this.SHn(),
            this.xHn()
        }
        JWn(t) {
            return 0 === t.indexOf("signed")
        }
        MHn(t) {
            const i = t.indexOf("-");
            return i > -1 ? t.slice(i + 1) : t
        }
        bHn() {
            const t = (t, i) => t.textContent = TF(i)
              , i = this.zWn.VWn;
            _F.p.u("ui.dialogs.cordovaOptions"),
            t(i.title, ".general"),
            t(i.QWn.label, ".min-version"),
            t(i.tHn.label, ".target-version"),
            t(i.iHn.label, ".android-build"),
            t(i.eHn.label, ".min-version"),
            t(i.sHn.label, ".ios-build"),
            _F.p.u(".builds");
            const e = i.iHn.input;
            t(e.item(0), ".cordova-project"),
            t(e.item(1), ".android-studio-project"),
            t(e.item(2), ".debug-apk"),
            t(e.item(3), ".unsigned-release-apk"),
            t(e.item(4), ".unsigned-app-bundle"),
            t(e.item(5), ".signed-debug-apk"),
            t(e.item(6), ".signed-release-apk"),
            t(e.item(7), ".signed-app-bundle");
            const s = i.sHn.input;
            t(s.item(0), ".cordova-project"),
            t(s.item(1), ".xcode-project"),
            _F.p.j(),
            _F.p.j()
        }
        vHn() {
            const t = (t, i) => t.textContent = TF(i)
              , i = this.zWn.properties;
            _F.p.u("ui.dialogs.cordovaOptions"),
            t(i.title, ".properties"),
            t(i.nHn.label, ".url-whitelist"),
            t(i.oHn.label, ".hide-status-bar"),
            t(i.rHn.label, ".android-version-code"),
            t(i.aHn.label, ".permissions.vibrate"),
            t(i.lHn.label, ".permissions.camera"),
            t(i.uHn.label, ".permissions.microphone"),
            _F.p.j()
        }
        SHn() {
            const t = (t, i) => t.textContent = TF(i)
              , i = this.zWn.KWn;
            _F.p.u("ui.dialogs.cordovaOptions"),
            t(i.title, ".signing"),
            t(i.dHn.select.label, ".choose"),
            t(i.dHn.create, ".create"),
            t(i.dHn.clear, ".clear"),
            t(i.dHn, ".keystore"),
            t(i.fHn.label, ".key-alias"),
            t(i.pHn.label, ".show-passwords"),
            t(i.mHn.label, ".keystore-password"),
            t(i.wHn.label, ".key-password"),
            _F.p.j()
        }
        xHn() {
            _F.p.u("ui.dialogs.cordovaOptions"),
            this.Ya(TF(".caption"));
            const t = (t, i) => t.textContent = TF(i)
              , i = this.uvi;
            t(i.gHn, "common.help"),
            t(i.yHn, "common.next"),
            t(i.PD, "common.cancel"),
            _F.p.j()
        }
        EHn(t) {
            var i, e;
            i = this.zWn.properties.container,
            e = t,
            i.style.display = e ? "" : "none"
        }
        ZWn(t) {
            const i = this.zWn.KWn;
            var e, s;
            e = i.container,
            s = t,
            e.style.display = s ? "" : "none",
            t || (i.wHn.input.value = "",
            i.mHn.input.value = "",
            i.fHn.input.value = "",
            i.dHn.select.input.value = null,
            i.dHn.name.textContent = "",
            i.dHn.element.removeAttribute("keystore-selected"))
        }
        CHn() {
            const t = this.zWn.VWn.iHn
              , i = t.input.value
              , e = "" === t.element.style.display
              , s = this.JWn(i);
            this.ZWn(e && s)
        }
        async _Hn(t, i, e) {
            _F.zt(t),
            _F.zt(i),
            _F.Hdt(e);
            const s = "android" !== t
              , n = "ios" !== t
              , r = await this.THn(i);
            return this.IHn(r),
            this.ELn = t,
            this.PHn(n, s, !1, !1),
            this.EHn(!1),
            this.CHn(),
            super.Qa(e)
        }
        async Qa(t, i) {
            _F.Yq(t);
            const e = t.platform
              , s = t.version
              , n = !!t.GHn;
            _F.zt(e),
            _F.zt(s),
            _F.Hdt(i);
            const r = "android" === e
              , h = "ios" === e
              , o = await this.THn(s);
            if (this.IHn(o),
            this.ELn = e,
            this.PHn(r, h, !0, !0),
            this.EHn(!0),
            this.CHn(),
            h) {
                const t = this.zWn.VWn.eHn.input;
                n ? (_F.qs.CD(t.options[0], "disabled", n),
                "1500" === t.value && (t.value = "1600")) : _F.qs.CD(t.options[0], "disabled", !1)
            }
            return super.Qa(i)
        }
        async THn(t) {
            _F.zt(t);
            const i = await localforage.getItem("cordova-export-options") || {}
              , e = this.AHn(t);
            return {
                androidVersion: Math.max(parseInt(i.androidVersion) || 700, 700),
                androidTarget: "cordova",
                iosVersion: Math.max(i.iosVersion || 1500, 1500),
                iosTarget: "cordova",
                hideStatusBar: i.hideStatusBar || !1,
                permissionVibrate: i.permissionVibrate || !1,
                permissionCamera: i.permissionCamera || !1,
                permissionMicrophone: i.permissionMicrophone || !1,
                whitelist: "http://*/* https://*/*",
                versionCode: e,
                useAssetPack: i.useAssetPack || !1,
                generateAssetManifest: i.generateAssetManifest || !1,
                assetPackLocation: ""
            }
        }
        AHn(t) {
            _F.zt(t);
            const i = /^(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?$/.exec(t);
            if (!i)
                throw new Error("Invalid version number");
            return 100 * (100 * (100 * +i[1] + (+i[2] || 0)) + (+i[3] || 0)) + (+i[4] || 0)
        }
        RHn(t) {
            if ("number" !== t.type)
                throw new Error("Invalid type on input");
            const i = t.min ? parseFloat(t.min) : -1 / 0
              , e = t.max ? parseFloat(t.max) : 1 / 0;
            if (i > e)
                throw new Error("Invalid min/max on input");
            const s = parseFloat(t.value);
            return isNaN(s) || s < i || s > e
        }
        kHn() {
            const t = this.zWn.properties
              , i = this.zWn.VWn;
            return {
                androidVersion: i.QWn.input.value,
                androidTarget: i.iHn.input.value,
                iosVersion: i.eHn.input.value,
                iosTarget: i.sHn.input.value,
                hideStatusBar: t.oHn.input.checked,
                permissionVibrate: t.aHn.input.checked,
                permissionCamera: t.lHn.input.checked,
                permissionMicrophone: t.uHn.input.checked,
                whitelist: t.nHn.input.value,
                versionCode: t.rHn.input.value,
                useAssetPack: t.cHn.input.checked,
                licenseKey: t.hHn.input.value,
                keystore: null,
                alias: null,
                ksPassword: null,
                kPassword: null
            }
        }
        OHn(t) {
            const i = this.zWn.KWn;
            return t.keystore = i.dHn.select.input.files[0],
            t.alias = i.fHn.input.value,
            t.ksPassword = i.mHn.input.value,
            t.kPassword = i.wHn.input.value || i.mHn.input.value,
            t
        }
        DHn(t) {
            if (!t.keystore)
                throw new Error("Please specify the keystore.");
            if (!t.alias)
                throw new Error("Please specify the alias.");
            if (!t.ksPassword)
                throw new Error("Please specify the keystore password.")
        }
        IHn(t) {
            const {VWn: i, properties: e} = this.zWn;
            i.QWn.input.value = t.androidVersion;
            const s = _F.qPe.LHn.FHn();
            i.tHn.YWn.textContent = IF("ui.dialogs.cordovaOptions.android-target-version-info", s.QWn, s.BHn),
            i.eHn.input.value = t.iosVersion,
            e.rHn.input.value = t.versionCode,
            e.oHn.input.checked = t.hideStatusBar,
            e.lHn.input.checked = t.permissionCamera,
            e.aHn.input.checked = t.permissionVibrate,
            e.uHn.input.checked = t.permissionMicrophone,
            e.nHn.input.value = t.whitelist
        }
        PHn(t, i, e, s) {
            const n = (t, i) => t.style.display = i ? "" : "none"
              , r = this.zWn.VWn;
            n(r.iHn.element, t),
            n(r.tHn.element, t),
            n(r.QWn.element, s && t),
            n(r.sHn.element, i),
            n(r.eHn.element, s && i);
            const h = this.zWn.properties;
            n(h.cHn.element, kF && t),
            n(h.hHn.element, kF && t),
            n(h.rHn.element, t);
            const o = r.iHn.input.options
              , a = r.sHn.input.options;
            e ? (o[0].removeAttribute("hidden"),
            a[0].removeAttribute("hidden")) : (o[0].setAttribute("hidden", ""),
            0 == o.selectedIndex && (o.selectedIndex = 1),
            a[0].setAttribute("hidden", ""),
            0 == a.selectedIndex && (a.selectedIndex = 1))
        }
        gwt() {
            if (this.RHn(this.zWn.properties.rHn.input)) {
                return void _F.qs.Ys.$s("OK").Qa(self.idt("ui.dialogs.cordovaOptions.invalid-version-code"))
            }
            const t = this.kHn()
              , i = "ios" !== this.ELn
              , e = t.androidTarget
              , s = this.JWn(e)
              , n = i && s;
            if (localforage.setItem("cordova-export-options", t).catch(t => self.app.OA(t)),
            n) {
                const i = this.OHn(t);
                try {
                    this.DHn(i)
                } catch (t) {
                    return void (() => {})(t)
                }
            }
            this.PR(t)
        }
        VW() {}
    }
    ;
    _F.qs.HY.ipt.addEventListener("load", () => {
        _F.qs.Ys.opt(RF, OF)
    }
    )
}
{
    const DF = self.t
      , FF = self.lang
      , LF = DF.ek(import.meta.url)
      , BF = LF.getElementById("archiveManagerDialog")
      , UF = DF.tk(LF.URL)
      , NF = "C3_Archive_Manager"
      , jF = 10;
    DF.p.ik(UF + "lang");
    const $F = "ArchiveManager"
      , zF = DF.qs.Ys.UHn = class extends DF.qs.Ys {
        constructor() {
            super(BF),
            this.yTt = DF.v(DF.qs.rA, BF, this),
            DF.p.u("ui.dialogs.archive-manager");
            const t = DF.qs.rA.uA(28)
              , i = self.app;
            this.Ya(FF(".caption")),
            this._Tt = this.yTt.wA("horizontalToolbar", t, [DF.qs.rA.pA("upload", i.oi("add"), FF(".toolbar.upload"), () => this.Pzn(), !1), DF.qs.rA.pA("download", i.oi("download"), FF(".toolbar.download"), () => this.F0t(), !0), DF.qs.rA.Nk(), DF.qs.rA.pA("delete", i.oi("delete"), FF(".toolbar.delete"), () => this.Hwt(), !0), DF.qs.rA.Nk(), DF.qs.rA.pA("build", i.oi("build"), FF(".toolbar.build"), () => this.NHn(), !0)]),
            this.FBn = !1,
            this.jHn = !1,
            this.yTt.fA();
            const e = this.yTt.YBt()
              , s = DF.v(DF.qs.Jj.Table, e, {
                pEi: !1
            });
            this.u8t = null,
            this.TKe = new Map,
            this.lui = {
                upload: this._Tt.bA("upload"),
                download: this._Tt.bA("download"),
                delete: this._Tt.bA("delete"),
                $Hn: this._Tt.bA("build"),
                Lzn: e,
                table: s
            },
            s.Got().kot("project", 150, FF(".columns.project")).kot("version", 50, FF(".columns.version")).kot("exporter", 80, FF(".columns.exporter")).kot("created", 130, FF(".columns.created")).kot("type", 150, FF(".columns.type")).Mot("size", FF(".columns.size")),
            s.iKt(),
            s.addEventListener("rowcontextmenu", t => this.OW(t)),
            s.addEventListener("rowselected", t => this.zHn(t.ght)),
            s.addEventListener("rowunselected", t => this.VHn(t.ght)),
            DF.p.j()
        }
        async Pzn() {
            if (await self.app.JN())
                return void self.app.j_(null, 21);
            const t = new DF.qs.Qyi;
            let i = await t.Qa(".zip");
            if (null === i)
                return;
            const e = new DF.FRt;
            let s;
            try {
                await e.HRt(i);
                const t = e.XRt("config.json");
                s = await e.ees(t)
            } catch (t) {
                console.error("Error processing zip file: ", t),
                e.YRt();
                return void DF.qs.Ys.$s("OK").Qa(FF("ui.dialogs.archive-manager.error.invalid-file"))
            }
            const n = s.android
              , r = s.ios;
            let h = null;
            if (n && r)
                h = "c2";
            else if (n)
                h = "android";
            else {
                if (!r) {
                    return void DF.qs.Ys.$s("OK").Qa(FF("ui.dialogs.archive-manager.error.invalid-file"))
                }
                h = "ios"
            }
            if ("c2" == h)
                try {
                    i = await this.WHn(i, e, JSON.stringify(s))
                } catch (t) {
                    console.error("Error processing zip file: ", t);
                    return void DF.qs.Ys.$s("OK").Qa(FF("ui.dialogs.archive-manager.error.invalid-file"))
                }
            return e.YRt(),
            this.HHn(i, s.name, h, "cordova", Date.now(), i.name, s.version)
        }
        async WHn(t, i, e) {
            const s = DF.qs.Ys.$s("Progress");
            s.Qa("");
            try {
                const s = DF.qPe.LHn.o_.KHn(e);
                if (s.lei()) {
                    const t = new Map;
                    for (const e of i.DKe()) {
                        const s = await i.JRt(e);
                        t.set(e.filename, s)
                    }
                    s.qHn(!1),
                    s.XHn("cordova-plugin-statusbar", null),
                    s.XHn("cordova-plugin-fullscreen", null),
                    t.set("config.json", s.YHn());
                    const e = t.get("www/c2runtime.js");
                    if (!e)
                        throw new Error("Unable to find runtime");
                    return t.set("www/c2runtime.js", new Blob([e, this.JHn()]), {
                        type: e.type
                    }),
                    await i.yLt(t)
                }
                return t
            } finally {
                s.PR()
            }
        }
        JHn() {
            return ';\n(function () {\nvar previousWidth = -1;\nvar previousHeight = -1;\n\nfunction tick ()\n{\n\trequestAnimationFrame(tick);\n\n\tvar isPortrait = window.innerWidth < window.innerHeight;\n\n\tvar height = isPortrait ? window["screen"]["height"] : window["screen"]["width"];\n\tvar width = isPortrait ? window["screen"]["width"] : window["screen"]["height"];\n\n\tif (previousHeight == height && previousWidth == width)\n\t\treturn;\n\n\tpreviousHeight = height;\n\tpreviousWidth = width;\n\n\tvar docStyle = document["documentElement"].style;\n\tvar bodyStyle = document["body"].style;\n\n\tif (height && width)\n\t{\n\t\tbodyStyle["height"] = docStyle["height"] = height + "px";\n\t\tbodyStyle["width"] = docStyle["width"] = width + "px";\n\t}\n}\n\nfunction enterFullscreen ()\n{\n\t// ios - hide statusbar\n\tif (typeof window["StatusBar"] === "object")\n\t\twindow["StatusBar"]["hide"]();\n\n\t// android - hide status and nav bar\n\tif (typeof window["AndroidFullScreen"] === "object")\n\t\twindow["AndroidFullScreen"]["immersiveMode"]();\n}\n\ndocument.addEventListener("deviceready", function () {\n\tvar ua = navigator.userAgent;\n\tvar isMicrosoftEdge = /edge\\//i.test(ua);\n\tvar isIE = (/msie/i.test(ua) || /trident/i.test(ua) || /iemobile/i.test(ua)) && !isMicrosoftEdge;\n\tvar isiPhone = (/iphone/i.test(ua) || /ipod/i.test(ua)) && !isIE && !isMicrosoftEdge;\t// treat ipod as an iphone; IE mobile masquerades as iPhone\n\n\tenterFullscreen();\n\tif (isiPhone && window["screen"])\n\t\ttick();\n});\n})();'
        }
        F0t() {
            if (!this.u8t)
                throw new Error("No entry selected");
            DF._Lt(this.u8t.filename, this.u8t.blob)
        }
        Hwt() {
            if (!this.u8t)
                throw new Error("No entry selected");
            const t = this.u8t;
            this.u8t = null,
            this.ZHn().then( () => {
                this.TKe.delete(t.uid),
                this.QHn(),
                this.tKn()
            }
            )
        }
        async NHn() {
            if (await self.app.JN())
                return void self.app.j_(null, 21);
            const t = this.u8t;
            if (!t)
                throw new Error("No entry selected");
            const i = t.blob
              , e = t.project
              , s = t.exporter
              , n = t.version
              , r = DF.qs.Ys.$s("CordovaOptions");
            let h;
            if (h = "ios" === s ? {
                iosTarget: "project"
            } : await r._Hn(s, n),
            !h)
                return;
            const o = {};
            return "c2" != s && "android" != s || (o.android = h.androidTarget),
            "c2" != s && "ios" != s || (o.ios = h.iosTarget),
            o.android && 0 === o.android.indexOf("signed") && (o.sign = await this.iKn(h)),
            this.vwt(),
            this.eKn(i, e, s, o, n)
        }
        OW() {}
        zHn(t) {
            this.u8t = t.Pp();
            const i = "cordova" === this.u8t.type;
            this.lui.$Hn.bet(i && !this.jHn),
            this.lui.download.bet(!0),
            this.lui.delete.bet(!0)
        }
        VHn() {
            this.u8t = null,
            this.lui.$Hn.bet(!1),
            this.lui.download.bet(!1),
            this.lui.delete.bet(!1)
        }
        Swt() {}
        sKn(t, i) {
            if ("cordova" === i)
                return "Cordova Project";
            if ("android" === t) {
                const t = i.indexOf("-")
                  , e = 0 === i.indexOf("signed");
                switch (t > -1 ? i.slice(t + 1) : i) {
                case "signed":
                    return "Signed Release APK";
                case "project":
                    return "Android Studio Project";
                case "debug":
                    return e ? "Signed Debug APK" : "Debug APK";
                case "release":
                    return e ? "Signed Release APK" : "Unsigned Release APK";
                case "bundle":
                    return e ? "Signed App Bundle" : "Unsigned App Bundle"
                }
            }
            return "ios" === t && "project" === i ? "Xcode Project" : DF.iPs(i)
        }
        nKn() {
            return localforage.getItem(NF).catch( () => {}
            ).then(t => {
                this.FBn = !0,
                t = t || [];
                for (const i of t) {
                    let t = this.TKe.get(i.uid);
                    t || (this.TKe.set(i.uid, i),
                    t = i),
                    i.saved = !0
                }
            }
            )
        }
        async ZHn() {
            await DF.Ars.SIt(),
            this.FBn || await this.nKn()
        }
        async QHn() {
            if (!this.FBn)
                throw new Error("Local entries not loaded");
            const t = Array.from(this.TKe.values());
            try {
                await localforage.setItem(NF, t);
                for (const t of this.TKe.values())
                    t.saved = !0
            } catch (t) {}
        }
        rKn(t) {
            self.app.OA(t, FF("ui.dialogs.archive-manager.error.storage-fail"))
        }
        tKn() {
            const t = this.lui.table;
            t.tC();
            const i = Array.from(this.TKe.values()).sort( (t, i) => i.created - t.created);
            for (const e of i) {
                const i = e.project
                  , s = "ios" == e.exporter ? "iOS" : DF.iPs(e.exporter)
                  , n = new Date(e.created).toLocaleString(self.app.iwt(), {
                    day: "numeric",
                    month: "short",
                    year: "numeric",
                    hour: "numeric",
                    minute: "numeric"
                })
                  , r = this.sKn(e.exporter, e.type)
                  , h = DF.Iye(e.size)
                  , o = e.version;
                t.Eot(e).Aot("project", i).Aot("version", o).Aot("exporter", s).Aot("created", n).Aot("type", r).Aot("size", h)
            }
        }
        async iKn(t) {
            DF.U(t.keystore, Blob),
            DF.zt(t.alias),
            DF.zt(t.ksPassword),
            DF.zt(t.kPassword);
            const i = await DF.fAs(t.keystore)
              , e = new Uint8Array(i);
            return {
                keystore: DF.TOe(e),
                ksPassword: t.ksPassword,
                kPassword: t.kPassword,
                alias: t.alias
            }
        }
        async HHn(t, i, e, s, n, r, h) {
            DF.U(t, Blob),
            DF.zt(i),
            DF.zt(e),
            DF.zt(s),
            DF.Ge(n),
            DF.zt(h);
            const o = {
                project: i,
                exporter: e,
                created: n,
                type: s,
                size: t.size,
                saved: !1,
                filename: r,
                blob: t,
                version: h,
                uid: DF.lTi()
            };
            if (this.TKe.set(o.uid, o),
            await this.ZHn(),
            this.TKe.size > jF) {
                const t = Array.from(this.TKe.values()).sort( (t, i) => i.created - t.created);
                for (; t.length > jF; ) {
                    const i = t.pop();
                    this.TKe.delete(i.uid)
                }
            }
            return await this.QHn(),
            this.Wp() && this.tKn(),
            o
        }
        async eKn(t, i, e, s, n) {
            let r, h;
            DF.U(t, Blob),
            DF.zt(i),
            DF.zt(e),
            DF.Hut(s),
            DF.zt(n),
            this.hKn(),
            "c2" == e ? (r = "multiple",
            h = `${i}.multiple`) : (r = s[e],
            h = `${i}.${e}.${r}`),
            s.android && 0 === s.android.indexOf("signed") && (s.android = s.android.slice(7));
            const o = DF.v(DF.qs.Ys.UHn.oKn, t, h, s);
            try {
                const t = await o.aKn();
                this.lKn(),
                this.uKn(t, i, e, r, n);
                DF.qs.Ys.$s("CordovaBuildReport").Qa(i, t.name, t)
            } catch (t) {
                this.lKn(t)
            }
        }
        async cKn(t, i, e, s, n, r) {
            DF.U(t, Blob),
            DF.zt(i),
            DF.zt(e),
            DF.zt(s),
            DF.zt(n),
            DF._U(r),
            this.hKn();
            const h = {
                [e]: s,
                sign: r
            }
              , o = `${i}.${e}.${s}`;
            h.android && 0 === h.android.indexOf("signed") && (h.android = h.android.slice(7));
            const a = DF.v(DF.qs.Ys.UHn.oKn, t, o, h);
            try {
                const t = await a.aKn();
                this.lKn(),
                this.uKn(t, i, e, s, n);
                DF.qs.Ys.$s("CordovaBuildReport").Qa(i, t.name, t)
            } catch (t) {
                this.lKn(t)
            }
        }
        Xxe(t) {
            DF.U(t, self.Gas);
            const i = t.yn()
              , e = t.YIt()
              , s = e.MPe
              , n = e.tag
              , r = i.Fa()
              , h = Date.now()
              , o = i.$te();
            return s ? this.HHn(s, r, n, "zip", h, `${r}.${n}.zip`, o) : Promise.resolve()
        }
        dKn(t) {
            DF.U(t, self.Gas);
            const i = t.yn()
              , e = t.YIt()
              , s = e.MPe
              , n = e.tag
              , r = i.Fa()
              , h = Date.now()
              , o = i.$te();
            return this.HHn(s, r, n, "cordova", h, `${r}.${n}.cordova.zip`, o)
        }
        uKn(t, i, e, s, n) {
            DF.e0t(t),
            DF.zt(i),
            DF.zt(e),
            DF.zt(s),
            DF.zt(n);
            const r = Date.now();
            return this.HHn(t, i, e, s, r, t.name, n)
        }
        async fKn(t) {
            DF.U(t, self.Gas);
            const i = t.yn()
              , e = t.YIt()
              , s = e.MPe
              , n = e.tag
              , r = e.pPe.cordova
              , h = i.Fa()
              , o = i.$te();
            let a;
            if ("android" === n && (a = r.androidTarget),
            "ios" === n && (a = r.iosTarget),
            "cordova" === a) {
                this.dKn(t);
                DF.qs.Ys.$s("CordovaExportReport").Qa(t)
            } else {
                let t = null;
                0 === a.indexOf("signed") && (t = await this.iKn(r)),
                await this.cKn(s, h, n, a, o, t)
            }
        }
        fUs() {
            return this.jHn
        }
        hKn() {
            if (this.jHn)
                throw new Error("Already building");
            this.lui.$Hn.bet(!1),
            this.jHn = !0
        }
        lKn(t=null) {
            if (this.jHn = !1,
            null !== t) {
                DF.p.u("ui.dialogs.archive-manager.error");
                const i = FF(".build-fail")
                  , e = FF(".build-failure-message");
                if (DF.p.j(),
                t instanceof Error) {
                    return DF.qs.Ys.$s("ShellOutput").Qa(i, e, t.message)
                }
                if ("string" == typeof t) {
                    return DF.qs.Ys.$s("ShellOutput").Qa(i, e, t)
                }
                return DF.qs.Ys.$s("OK").Qa(i)
            }
        }
        async Qa(t) {
            return await this.ZHn(),
            this.tKn(),
            super.Qa(t)
        }
        AZe() {
            super.AZe()
        }
        gwt() {}
        tWt() {
            super.tWt()
        }
        static pKn() {
            return NF
        }
    }
    ;
    DF.qs.HY.ipt.addEventListener("load", function() {
        DF.qs.Ys.opt($F, zF)
    })
}
{
    const VF = self.t
      , WF = VF.p.Ok("ui.build-service-status")
      , HF = new Map([["Waiting to build", "waiting-to-build"], ["Preparing project", "preparing-project"], ["Building Android", "building-android"], ["Building iOS", "building-ios"], ["Compressing builds", "compressing-builds"], ["Project uploaded successfully", "upload-complete"], ["Connection restored", "connection-restored"], ["Build complete, beginning transfer", "build-complete"]]);
    function KF(t) {
        const i = HF.get(t);
        return i ? WF("." + i) : t
    }
    const qF = "wss://build.construct.net/"
      , XF = 5
      , YF = 5e3
      , JF = Symbol("init")
      , ZF = Symbol("uploading")
      , QF = Symbol("downloading");
    VF.qs.Ys.UHn.oKn = class {
        constructor(t, i, e) {
            const s = !!e.ios
              , n = !!e.android;
            this.gHe = null,
            this.mKn = null,
            this.wKn = null,
            this.gKn = t,
            this.yKn = 0,
            this.bKn = 1,
            this.Uli = JF,
            this.vKn = null,
            this.SKn = i,
            this.xKn = null,
            this.MKn = null,
            this.EKn = null,
            this.CKn = !1,
            this._Kn = e,
            this.ELn = null,
            this.op = null,
            this.TKn = -1,
            n && s ? this.ELn = "c2" : n ? this.ELn = "android" : s && (this.ELn = "ios"),
            this.lVt = e[this.ELn] || null,
            this.IKn = XF,
            this.PKn = WF(".prefix");
            let r = VF.qs.Jj
              , h = VF.v(r.Pan);
            this.Uan = h,
            this.GKn = VF.v(r.jan, h, this.PKn + WF(".transfer-progress")),
            this.AKn = VF.v(r.Van, h, "")
        }
        he() {
            -1 !== this.TKn && (clearTimeout(this.TKn),
            this.TKn = -1),
            this.MKn && this.MKn.Vh(),
            this.EKn && this.EKn.Vh(),
            this.MKn = null,
            this.EKn = null,
            this.gHe && (this.gHe.g_(),
            this.gHe = null),
            this.mKn = null,
            this.wKn = null,
            this.gKn = null,
            this.GKn.qV(),
            this.Uan.he(),
            this.Uan = null,
            this.GKn = null,
            this.AKn = null
        }
        RKn() {
            return `${this.ELn}${this.lVt ? "-" + this.lVt : ""}`
        }
        Lii(t) {
            self.app.Lii("BuildService", t + "-" + this.RKn())
        }
        async ke() {
            this.Lii("StartedBuild"),
            await this.kKn(this.gKn),
            await Promise.all([this.OKn(), this.DKn().then(t => this.FKn())])
        }
        async aKn() {
            try {
                await this.ke(),
                this.Lii("BuildCompleted");
                const t = this.SKn + this.xKn;
                return VF.CU(this.wKn, t)
            } catch (t) {
                throw this.Lii("BuildFailed"),
                t
            } finally {
                this.he()
            }
        }
        LKn() {
            this.IKn--,
            this.CKn = !1,
            this.MKn && (this.MKn.Vh(),
            this.MKn = null),
            this.IKn > 0 ? (this.BKn(WF(".lost-connection")),
            -1 !== this.TKn && clearTimeout(this.TKn),
            this.TKn = setTimeout( () => this.UKn(), YF)) : this.op()
        }
        NKn() {
            this.BKn(WF(".connected-to-server")),
            this.CKn = !0,
            this.MKn = VF.jh.Gh(this.gHe, "close", () => this.LKn())
        }
        async UKn() {
            try {
                await this.gHe.GHe(),
                await this.jKn()
            } catch (t) {
                return void (() => {})(t)
            }
        }
        EQe() {
            this.GKn.zan(this.yKn / this.bKn)
        }
        BKn(t) {
            t = KF(t),
            console.log(`${this.PKn} ${t}`),
            this.AKn && this.AKn.pa(`${this.PKn} ${t}`)
        }
        async FKn() {
            const t = this.mKn;
            for (this.Uli = ZF; t.length > 0; ) {
                const i = t.shift();
                try {
                    const e = 0 === t.length;
                    await this.gHe.zHe(e ? "END" : "CNK", i),
                    this.yKn += i.length,
                    this.EQe()
                } catch (e) {
                    throw t.unshift(i),
                    e
                }
            }
            this.GKn.qV()
        }
        async kKn() {
            this.bKn = this.gKn.size;
            const t = await VF.fAs(this.gKn);
            this.mKn = await VF._Oe(t, Uint8Array, 65536)
        }
        OKn() {
            return this.gHe = VF.v(VF.WebSocket, qF),
            this.EKn = VF.jh.Gh(this.gHe, "open", () => this.NKn()),
            this.gHe.AHe("STS", t => this.BKn(t)),
            this.$Kn()
        }
        $Kn() {
            return this.gHe.LHe("SRT", t => {
                this.Uli = QF,
                this.wKn = [],
                this.bKn = t.size,
                this.xKn = t.ext || ".zip"
            }
            ),
            this.gHe.DHe("RES", t => {
                this.wKn.push(t),
                this.yKn += t.length,
                this.EQe()
            }
            ),
            new Promise( (t, i) => {
                this.op = () => i("Cannot connect to build server"),
                this.gHe.AHe("ERR", i),
                this.gHe.AHe("DON", t)
            }
            )
        }
        async DKn(t) {
            this.BKn(WF(".connecting"));
            try {
                return await this.zKn(t)
            } catch (t) {
                if (!(t instanceof VF.Event && "close" === t.type))
                    throw t;
                (() => {})("no connection")
            }
            let i = 1;
            for (; i < XF; ) {
                await VF.KTi(YF);
                try {
                    return await this.gHe.GHe(),
                    void await this.zKn(t)
                } catch (t) {
                    if (!(t instanceof VF.Event && "close" === t.type))
                        throw t;
                    i++
                }
            }
            this.op()
        }
        async zKn(t) {
            const i = Object.assign({}, this._Kn);
            t && (i.uuid = t);
            const e = self.app;
            i.pt = e.QPe(),
            i.rc = e.tke(),
            i.lh = e.ske();
            const s = this.gHe
              , [n,r] = await Promise.all([s.NHe("RDY"), s.qHe("CRT", i)]);
            this.vKn = n
        }
        async jKn() {
            let t = this.vKn;
            await this.DKn(this.vKn),
            t !== this.vKn ? (await this.kKn(),
            await this.FKn()) : this.Uli === ZF && await this.FKn()
        }
        static async VKn(t) {
            const i = await VF.WebSocket.YHe(qF);
            try {
                await i.qHe("KEY", t);
                const e = await Promise.race([Promise.all([i.$He("RES"), i.NHe("INF")]), i.NHe("ERR")]);
                if ("string" == typeof e)
                    throw new Error(e);
                const s = /Certificate fingerprints\:[\s\S]+SHA1: ([^\n]+)/m.exec(e[1]);
                return [new Blob([e[0]]), s ? s[1] : "FAIL SIGNATURE"]
            } finally {
                i.g_()
            }
        }
    }
}
{
    const tL = self.t
      , iL = self.lang
      , eL = tL.ek(import.meta.url)
      , sL = eL.getElementById("audioPreviewDialog")
      , nL = tL.tk(eL.URL);
    tL.p.ik(nL + "lang");
    const rL = "AudioPreview"
      , hL = tL.qs.Jj.WKn = class extends tL.qs.Ys {
        constructor() {
            super(sL),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.PGe = null,
            this.frs = ""
        }
        Swt() {
            this.lKi.textContent = iL("common.close-dialog"),
            this.Ya(iL("ui.dialogs.audioPreview.caption"))
        }
        async Qa(t, i) {
            const e = this.y5t()
              , s = document.createElement("h3");
            s.textContent = self.tP("ui.dialogs.audioPreview.audio-title", this.HKn(t), this.KKn(t), this.qKn(t));
            const n = document.createElement("audio");
            return n.src = await this.XKn(t),
            n.controls = !0,
            n.autoplay = !0,
            this.PGe = n,
            e.appendChild(s),
            e.appendChild(n),
            super.Qa(i)
        }
        KKn(t) {
            return tL.$l(t, globalThis.fh) ? t.dL().aAs() : tL.MimeType.NAs(t).aAs()
        }
        HKn(t) {
            return tL.$l(t, globalThis.fh) ? t.dh() : t.name
        }
        qKn(t) {
            return tL.$l(t, globalThis.fh) ? tL.Iye(t.xc().size) : tL.Iye(t.size)
        }
        async XKn(t) {
            return tL.$l(t, globalThis.fh) ? t.zU() : (this.frs = URL.createObjectURL(t),
            this.frs)
        }
        VW() {
            tL.qs.BYt(this.y5t()),
            this.PGe.pause(),
            this.PGe = null,
            this.frs && URL.revokeObjectURL(this.frs),
            this.frs = ""
        }
    }
    ;
    tL.qs.HY.ipt.addEventListener("load", () => {
        tL.qs.Ys.opt(rL, hL)
    }
    )
}
{
    const oL = self.t
      , aL = self.lang
      , lL = oL.ek(import.meta.url)
      , uL = lL.getElementById("chooseKeyDialog")
      , cL = oL.tk(lL.URL);
    oL.p.ik(cL + "lang");
    const dL = "ChooseKey"
      , fL = oL.qs.Jj.YKn = class extends oL.qs.Ys {
        constructor() {
            super(uL),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.JKn = this.dwt("chooseKeyDisplay"),
            this.ZKn = this.dwt("chooseKeyDropdown"),
            this.ZKn.addEventListener("change", () => this.QKn()),
            this.Rz = t => this.FP(t),
            this.O5s = -1
        }
        Swt() {
            oL.p.u("ui.dialogs.chooseKey"),
            this.lKi.textContent = aL("common.ok"),
            this.lhs.textContent = aL("common.cancel"),
            this.Ya(aL(".caption")),
            this.dwt("chooseKeyNumLockNote").textContent = aL(".num-lock-note"),
            this.dwt("chooseKeyOrUseDropdownNote").textContent = aL(".or-use-dropdown-note"),
            this.ZKn.item(0).textContent = aL(".dropdown-none"),
            this.ZKn.item(1).textContent = oL.kE.WGe(13),
            this.ZKn.item(2).textContent = oL.kE.WGe(27),
            oL.p.j()
        }
        Qa(t, i) {
            oL.cO(t),
            this.O5s = -1,
            this.JKn.textContent = aL("ui.dialogs.chooseKey.no-key-placeholder"),
            this.lKi.setAttribute("disabled", ""),
            this.ZKn.selectedIndex = 0,
            t >= 0 && this.tqn(t);
            let e = super.Qa(i);
            return this.iqn(),
            e
        }
        iqn() {
            this.PH().addEventListener("keydown", this.Rz, !0)
        }
        eqn() {
            this.PH().removeEventListener("keydown", this.Rz, !0)
        }
        FP(t) {
            t.preventDefault(),
            t.stopPropagation();
            let i = t.which;
            13 !== i ? 27 !== i ? this.tqn(i) : this.tWt() : this.gwt()
        }
        tqn(t) {
            this.O5s = t,
            this.lKi.removeAttribute("disabled"),
            this.JKn.textContent = oL.kE.WGe(t)
        }
        QKn() {
            let t = parseInt(this.ZKn.value, 10);
            t >= 0 && this.tqn(t)
        }
        gwt() {
            this.eqn(),
            this.O5s >= 0 && this.PR(this.O5s)
        }
        tWt() {
            return this.eqn(),
            super.tWt()
        }
        sqn() {
            return this.lKi
        }
        nqn() {
            return this.JKn
        }
        VW() {}
    }
    ;
    oL.qs.HY.ipt.addEventListener("load", () => {
        oL.qs.Ys.opt(dL, fL)
    }
    )
}
{
    const pL = self.t
      , mL = pL.ek(import.meta.url)
      , wL = mL.getElementById("crashReportDialog")
      , gL = (pL.tk(mL.URL),
    "CrashReport");
    let yL = !1
      , bL = !1;
    function vL(t) {
        const i = t.reason;
        if (i) {
            if ("string" == typeof i)
                return i;
            if (void 0 !== self.lU && i instanceof self.lU)
                return i.cU() + ": " + i.aU();
            if ("string" == typeof i.message && (i.message || i.stack || i.error && i.error.stack)) {
                const t = i.stack || (i.error ? i.error.stack : null);
                return "Error: " + i.message + (t ? " @ " + t : "")
            }
            if (i instanceof Event)
                return `Event '${i.type}'` + (i.name ? ` (${i.name})` : "") + ": " + i.toString();
            {
                let e = i.toString();
                if (e.startsWith("[object ")) {
                    let s = {}
                      , n = 0;
                    for (const [t,e] of Object.entries(i)) {
                        if (n >= 3)
                            break;
                        s[t] = e,
                        ++n
                    }
                    let r = e;
                    try {
                        r = JSON.stringify(s)
                    } catch (t) {}
                    r.length > 250 && (r = r.substr(0, 250)),
                    e = r
                }
                return e
            }
        }
        return "" + i
    }
    function SL(t) {
        if (!t)
            return !1;
        if ("string" == typeof t.filename) {
            const i = t.filename.toLowerCase();
            if (i.includes("safari-extension://") || i.includes("chrome-extension://"))
                return !0
        }
        if (t.error && "string" == typeof t.error.stack) {
            const i = t.error.stack.toLowerCase();
            if (i.includes("safari-extension://") || i.includes("chrome-extension://"))
                return !0
        }
        if ("string" == typeof t.message) {
            if (t.message.toLowerCase().startsWith("script error") && !t.filename && 0 === t.lineno)
                return !0;
            if (t.message.toLowerCase().includes("webkit.messagehandlers"))
                return !0;
            if (t.message.includes("ResizeObserver"))
                return !0;
            if (t.message.includes("3rdparty/monaco/") && t.message.includes("importScripts"))
                return !0
        }
        return !1
    }
    function xL(t) {
        if (!t)
            return !1;
        if (t.reason && "string" == typeof t.reason.stack) {
            if (t.reason.stack.toLowerCase().includes("3rdparty/monaco/"))
                return !0
        }
        return !1
    }
    const ML = pL.qs.Jj.rqn = class extends pL.qs.Ys {
        constructor() {
            super(wL),
            this.iSe = this.dwt("copyButton"),
            this.iSe.onclick = () => this.hqn(),
            this.oqn = this.dwt("saveButton"),
            this.oqn.onclick = () => this.aqn(),
            this.lqn = this.dwt("reloadButton"),
            this.lqn.onclick = () => location.reload(!0),
            this.uqn = this.dwt("reportContent"),
            this.wat = pL.v(pL.qs.kmt, self.app.bds("error"), this.dwt("iconWrap"))
        }
        Swt() {}
        Qa(t, i, e) {
            const s = self.app;
            let n = `<h3>Error report information</h3>\n\t\t<p>\n\t\t<strong>Type:</strong> ${t}<br/>`;
            if ("unhandled exception" === t) {
                const t = i.error ? i.error.stack : null;
                s.Lii("Crash", "UnhandledException"),
                s.cqn("Unhandled exception: " + t),
                n += `\n\t\t\t<strong>File:</strong> ${i.filename}, line ${i.lineno}, col ${i.colno}<br/>\n\t\t\t<strong>Message:</strong> ${i.message}<br/>\n\t\t\t<strong>Stack:</strong> ${t}<br/>\n\t\t\t`
            } else if ("unhandled rejection" === t) {
                const t = vL(i);
                let e = t;
                s.Lii("Crash", "UnhandledRejection"),
                n += `<strong>Reason:</strong> ${t}<br/>`,
                i.reason && i.reason.stack && (n += `<strong>Stack:</strong> ${i.reason.stack}<br/>`,
                e += "\n" + i.reason.stack),
                s.cqn("Unhandled rejection: " + e)
            } else
                s.Lii("Crash", "AssertFail"),
                s.cqn("Assert fail: " + i.message + "\n" + i.stack),
                n += `\n\t\t\t<strong>Message:</strong> ${i.message}<br/>\n\t\t\t<strong>Stack:</strong> ${i.stack}<br/>\n\t\t\t`;
            n += `<strong>Construct version:</strong> ${pL.o_.Lhi}<br/>\n\t\t<strong>URL:</strong> ${location.href}<br/>\n\t\t<strong>Date:</strong> ${(new Date).toString()}<br/>\n\t\t<strong>Uptime:</strong> ${Math.round(performance.now() / 100) / 10} s\n\t\t</p>`;
            try {
                pL.qs.Ys.$s("PlatformInfo").dqn(!0).then(t => {
                    n += t,
                    this.uqn.innerHTML = n,
                    this.uqn.scrollTop = 0
                }
                ).catch(t => {
                    n += "Unable to collect further diagnostic information because a promise rejection occurred while trying to collect it.",
                    this.uqn.innerHTML = n,
                    this.uqn.scrollTop = 0
                }
                )
            } catch (t) {
                n += "Unable to collect further diagnostic information because an exception was thrown while trying to collect it.",
                this.uqn.innerHTML = n,
                this.uqn.scrollTop = 0
            }
            0 === s.a7t() && this.oqn.setAttribute("disabled", "");
            let r = super.Qa(e);
            return pL.qs.cqe.j6e(),
            r
        }
        gwt() {}
        tWt() {}
        VW() {
            pL.qs.BYt(this.Aet)
        }
        jJe(t) {
            t.preventDefault()
        }
        hqn() {
            let t = document.createRange();
            t.selectNodeContents(this.uqn);
            let i = window.getSelection();
            i.removeAllRanges(),
            i.addRange(t),
            document.execCommand("copy")
        }
        aqn() {
            self.app.fqn()
        }
        static pqn() {
            return yL
        }
        static mqn() {
            window.addEventListener("error", t => {
                if (SL(t))
                    return void (() => {})("Ignored external unhandled exception: ", t);
                if (yL || bL)
                    return;
                yL = !0;
                pL.qs.Ys.$s("CrashReport").Qa("unhandled exception", t, document.body)
            }
            ),
            window.addEventListener("unhandledrejection", t => {
                if (xL(t))
                    return void (() => {})("Ignored external unhandled rejection: ", t);
                if (yL || bL)
                    return;
                yL = !0;
                pL.qs.Ys.$s("CrashReport").Qa("unhandled rejection", t, document.body)
            }
            ),
            window.addEventListener("beforeunload", () => bL = !0, !0),
            window.addEventListener("unload", () => bL = !0, !0)
        }
    }
    ;
    pL.qs.HY.ipt.addEventListener("load", () => {
        pL.qs.Ys.opt(gL, ML)
    }
    )
}
{
    const EL = self.t
      , CL = self.lang
      , _L = EL.ek(import.meta.url)
      , TL = _L.getElementById("createKeystoreDialog")
      , IL = EL.tk(_L.URL);
    EL.p.ik(IL + "lang");
    const PL = "CreateKeystoreDialog"
      , GL = EL.qs.Jj.wqn = class extends EL.qs.Ys {
        constructor() {
            super(TL),
            this.lui = {
                name: this.gqn("name"),
                unit: this.gqn("unit"),
                yqn: this.gqn("organisation"),
                city: this.gqn("city"),
                state: this.gqn("state"),
                country: this.gqn("country"),
                bqn: this.gqn("alias"),
                validity: this.gqn("validity"),
                password: this.gqn("password"),
                vqn: this.gqn("passwordConfirm"),
                Sqn: this.gqn("passwordVisible")
            },
            this.lui.Sqn.addEventListener("change", () => {
                const t = !this.lui.Sqn.value ? "password" : "text";
                this.lui.password.type = t,
                this.lui.vqn.type = t
            }
            ),
            this.Jde = this.dwt("helpLink"),
            this.Jde.onclick = () => self.app.s_("interface/dialogs/cordova-options", "CreateKeystoreDialog"),
            this.rhs = this.dwt("nextButton"),
            this.rhs.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt()
        }
        gqn(t) {
            const i = this.dwt(t)
              , e = this.dwt(t + "Label");
            let s = !1;
            return {
                get value() {
                    return "checkbox" == i.type ? i.checked : i.value
                },
                set value(t) {
                    "checkbox" == i.type ? i.checked = !!t : i.value = t
                },
                set label(t) {
                    e.textContent = t
                },
                get hidden() {
                    return s
                },
                set hidden(t) {
                    s = !!t;
                    const n = s ? "none" : "";
                    i.style.display = n,
                    e.style.display = n
                },
                set type(t) {
                    i.type = t
                },
                set placeholder(t) {
                    i.placeholder = t
                },
                addEventListener: (t, e, s) => EL.jh.Gh(i, t, e, s)
            }
        }
        Qa(t) {
            return this.lui.name.value = "",
            this.lui.unit.value = "",
            this.lui.yqn.value = "",
            this.lui.city.value = "",
            this.lui.state.value = "",
            this.lui.country.value = "",
            this.lui.bqn.value = "",
            this.lui.validity.value = 25,
            this.lui.password.value = "",
            this.lui.vqn.value = "",
            super.Qa(t)
        }
        kHn() {
            return {
                name: this.lui.name.value.trim(),
                unit: this.lui.unit.value.trim(),
                organisation: this.lui.yqn.value.trim(),
                city: this.lui.city.value.trim(),
                state: this.lui.state.value.trim(),
                country: this.lui.country.value.trim(),
                alias: this.lui.bqn.value.trim(),
                validity: +this.lui.validity.value,
                password: this.lui.password.value,
                passwordConfirm: this.lui.vqn.value,
                keyPassword: this.lui.password.value,
                keyPasswordConfirm: this.lui.vqn.value
            }
        }
        YDn() {
            const t = this.kHn()
              , i = "ui.dialogs.createKeystoreDialog.validation";
            if (!t.name)
                throw CL(i + ".name");
            if (!t.unit)
                throw CL(i + ".unit");
            if (!t.organisation)
                throw CL(i + ".organisation");
            if (!t.city)
                throw CL(i + ".city");
            if (!t.state)
                throw CL(i + ".state");
            if (2 !== t.country.length)
                throw CL(i + ".country");
            if (!t.alias)
                throw CL(i + ".alias");
            if (isNaN(t.validity) || t.validity < 1 || t.validity > 100)
                throw CL(i + ".validity");
            if (!t.password || t.password.length < 6)
                throw CL(i + ".password");
            if (!t.passwordConfirm)
                throw CL(i + ".password-confirm");
            if (t.password !== t.passwordConfirm)
                throw CL(i + ".password-match");
            return t
        }
        Swt() {
            EL.p.u("ui.dialogs.createKeystoreDialog"),
            this.Ya(CL(".caption")),
            this.rhs.textContent = CL(".create"),
            this.lhs.textContent = CL("common.cancel"),
            this.Jde.textContent = CL("common.help"),
            this.lui.name.placeholder = CL(".placeholder.name"),
            this.lui.name.label = CL(".label.name"),
            this.lui.unit.placeholder = CL(".placeholder.unit"),
            this.lui.unit.label = CL(".label.unit"),
            this.lui.yqn.placeholder = CL(".placeholder.organisation"),
            this.lui.yqn.label = CL(".label.organisation"),
            this.lui.city.placeholder = CL(".placeholder.city"),
            this.lui.city.label = CL(".label.city"),
            this.lui.state.placeholder = CL(".placeholder.state"),
            this.lui.state.label = CL(".label.state"),
            this.lui.country.placeholder = CL(".placeholder.country"),
            this.lui.country.label = CL(".label.country"),
            this.lui.bqn.placeholder = CL(".placeholder.alias"),
            this.lui.bqn.label = CL(".label.alias"),
            this.lui.password.placeholder = CL(".placeholder.password"),
            this.lui.password.label = CL(".label.password"),
            this.lui.vqn.placeholder = CL(".placeholder.password-confirm"),
            this.lui.vqn.label = CL(".label.password-confirm"),
            this.lui.validity.label = CL(".label.validity"),
            this.lui.Sqn.label = CL(".label.show-passwords"),
            EL.p.j()
        }
        async gwt() {
            const t = EL.qs.Ys.$s("Progress");
            try {
                const i = this.YDn();
                i.validity *= 365,
                await super.gwt(),
                t.Qa(CL("ui.dialogs.createKeystoreDialog.creating-keystore"));
                const [e,s] = await EL.qs.Ys.UHn.oKn.VKn(i);
                t.PR(),
                await EL.qs.Ys.$s("CreateKeystoreReportDialog").Qa(e, s)
            } catch (i) {
                t.PR();
                const e = EL.qs.Ys.$s("ShellOutput");
                EL.p.u("ui.dialogs.createKeystoreDialog.failure");
                const s = CL(".caption")
                  , n = CL(".message");
                return EL.p.j(),
                i instanceof Error ? e.Qa(s, n, i.message) : e.Qa(s, n, i.toString())
            }
        }
    }
    ;
    EL.qs.HY.ipt.addEventListener("load", () => {
        EL.qs.Ys.opt(PL, GL)
    }
    )
}
{
    const AL = self.t
      , RL = self.idt
      , kL = "CreateKeystoreReportDialog"
      , OL = AL.ek(import.meta.url)
      , DL = OL.getElementById(kL)
      , FL = AL.tk(OL.URL);
    AL.p.ik(FL + "lang");
    const LL = AL.qs.Jj.xqn = class extends AL.qs.Ys {
        constructor() {
            super(DL),
            this.Mqn = null,
            this.Eqn = null,
            this.Cqn = this.dwt("downloadKeystore"),
            this.LJe = this.dwt("okButton"),
            this.LJe.onclick = () => this.PR()
        }
        Qa(t, i, e) {
            AL.U(t, Blob),
            AL.zt(i),
            AL.Hdt(e),
            this.Mqn = t,
            this.Eqn = URL.createObjectURL(t),
            this.Cqn.href = this.Eqn,
            AL.p.u("ui.dialogs.create-keystore-report-dialog");
            return this.y5t().querySelectorAll("p")[5].innerHTML = self.tG(".signature", i).ibt(),
            AL.p.j(),
            super.Qa(e)
        }
        Swt() {
            AL.p.u("ui.dialogs.create-keystore-report-dialog");
            const t = this.y5t().querySelectorAll("p");
            t[0].innerHTML = RL(".keep-it-safe").ibt(),
            t[1].innerHTML = RL(".we-dont-store-it").ibt(),
            t[2].innerHTML = RL(".google-play-app-signing").ibt(),
            t[3].innerHTML = RL(".more-information").ibt(),
            this.Cqn.textContent = RL(".download-keystore").ibt(),
            this.Ya(self.lang(".caption")),
            AL.p.j()
        }
        PR() {
            URL.revokeObjectURL(this.Eqn),
            this.Mqn = null,
            this.Eqn = null,
            super.PR()
        }
    }
    ;
    AL.qs.HY.ipt.addEventListener("load", () => {
        AL.qs.Ys.opt(kL, LL)
    }
    )
}
{
    const BL = self.t
      , UL = self.lang
      , NL = BL.ek(import.meta.url)
      , jL = NL.getElementById("fullscreenPromptDialog")
      , $L = BL.tk(NL.URL);
    BL.p.ik($L + "lang");
    const zL = "FullscreenPrompt"
      , VL = BL.qs.Jj._qn = class extends BL.qs.Ys {
        constructor() {
            super(jL),
            this.lKi = this.dwt("goFullscreen"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.Tqn = this.dwt("fullscreenMessage")
        }
        Swt() {
            BL.p.u("ui.dialogs.fullscreen-prompt"),
            this.Ya(UL(".caption")),
            this.Tqn.textContent = UL(".message"),
            this.lKi.textContent = UL(".go-fullscreen"),
            this.lhs.textContent = UL(".continue"),
            BL.p.j()
        }
        gwt() {
            super.gwt(),
            self.app.Lii("MobileFullscreenPrompt", "Accepted"),
            BL.Dj(document.documentElement)
        }
        tWt() {
            super.tWt(),
            self.app.Lii("MobileFullscreenPrompt", "Declined")
        }
    }
    ;
    BL.qs.HY.ipt.addEventListener("load", () => {
        BL.qs.Ys.opt(zL, VL)
    }
    )
}
{
    const WL = self.t
      , HL = WL.ek(import.meta.url)
      , KL = HL.getElementById("legalInfoDialog")
      , qL = (WL.tk(HL.URL),
    "LegalInfo")
      , XL = WL.qs.Jj.Iqn = class extends WL.qs.Ys {
        constructor() {
            super(KL),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt()
        }
        Swt() {
            this.lKi.textContent = self.lang("common.close-dialog")
        }
        Qa(t) {
            return super.Qa(t)
        }
        VW() {}
    }
    ;
    WL.qs.HY.ipt.addEventListener("load", () => {
        WL.qs.Ys.opt(qL, XL)
    }
    )
}
{
    const YL = self.t
      , JL = YL.ek(import.meta.url)
      , ZL = JL.getElementById("memoryInfoDialog")
      , QL = (YL.tk(JL.URL),
    "MemoryInfo")
      , tB = 2e3;
    function iB(t) {
        let i = t / 1048576;
        return YL.oY(i, 100)
    }
    const eB = YL.qs.Jj.Pqn = class extends YL.qs.Ys {
        constructor() {
            super(ZL),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.Aet = this.dwt("memoryInfoContent"),
            this.Gqn = -1,
            this.Aqn = () => this.kan()
        }
        Swt() {}
        Qa(t) {
            return this.kan(),
            this.Gqn = window.setInterval(this.Aqn, tB),
            super.Qa(t)
        }
        async kan() {
            let t = await self.app.Pv()
              , i = 0
              , e = 0;
            for (let t of YL.ra.Hxn.cMn()) {
                let s = t.YZ();
                i += s,
                t.tXs() && (e += s)
            }
            let s = t.kgn();
            for (let t of YL.ra.mMn.LMn())
                s += t.YZ();
            let n = t.kgn() + t.Ogn()
              , r = t.Fgn()
              , h = self.app.zs().YZ()
              , o = 0
              , a = 0;
            performance.memory && (o = performance.memory.Rqn || 0,
            a = performance.memory.kqn || 0);
            let l = 0
              , u = 0;
            for (let t of self.Dns.all())
                l += t.fos(),
                u += t.dos();
            let c = 0;
            for (let t of YL.qs.X4e.all())
                c += t.YZ();
            let d = YL.$ke()
              , f = r + h + o + l + u + c + d
              , p = `<p>This view automatically refreshes. Note Construct is not able to determine memory usage of everything in the browser process. These values should be treated as estimated minimums.</p>\n\t\t\n\t\t<h3>Totals</h3>\n\t\t<p>\n\t\t<strong>WebGL memory:</strong> ${iB(r)} MB<br/>\n\t\t<strong>Layout view tabs:</strong> ${iB(h)} MB<br/>\n\t\t<strong>JS memory:</strong> ${iB(o)} MB<br/>\n\t\t<strong>Images:</strong> ${iB(l + u)} MB<br/>\n\t\t<strong>Icons:</strong> ${iB(c)} MB<br/>\n\t\t<strong>Library:</strong> ${iB(d)} MB<br/>\n\t\t<strong>Grand total: ${iB(f)} MB</strong>\n\t\t</p>\n\t\t\n\t\t<h3>WebGL memory</h3>\n\t\t<p>\n\t\t<strong>Texture memory usage:</strong> ${iB(i)} MB<br/>\n\t\tOf which static textures: ${iB(e)} MB (${0 === i ? 0 : Math.round(100 * e / i)}%)<br/>\n\t\t<strong>Render targets</strong> (including textures): ${iB(s)} MB<br/>\n\t\tExluding textures: ${iB(n)} MB<br/>\n\t\t</p>\n\t\t\n\t\t<h3>Javascript memory</h3>\n\t\t<p><strong>Used JS heap size:</strong> `;
            p += -1 === o ? "<em>unavailable</em>" : iB(o) + " MB",
            p += "<br/>\n\t\tTotal JS heap size: ",
            p += -1 === a ? "<em>unavailable</em>" : iB(a) + " MB",
            p += `</p>\n\t\t<h3>Images</h3>\n\t\t<p>\n\t\t<strong>Compressed images:</strong> ${iB(l)} MB<br/>\n\t\t<strong>Decompressed images:</strong> ${iB(u)} MB<br/>\n\t\t<strong>Icons:</strong> ${iB(c)} MB\n\t\t</p>`,
            this.Aet.innerHTML = p
        }
        VW() {
            YL.qs.BYt(this.Aet),
            window.clearInterval(this.Gqn),
            this.Gqn = -1
        }
    }
    ;
    YL.qs.HY.ipt.addEventListener("load", () => {
        YL.qs.Ys.opt(QL, eB)
    }
    )
}
{
    const sB = self.t
      , nB = self.lang
      , rB = sB.ek(import.meta.url)
      , hB = rB.getElementById("platformInfoDialog")
      , oB = (sB.tk(rB.URL),
    "PlatformInfo");
    let aB = !1
      , lB = 0
      , uB = 0
      , cB = "";
    function dB() {
        if (aB)
            return;
        const t = self.app.eLs();
        lB = t.sampleRate,
        uB = t.destination.maxChannelCount,
        cB = t.destination.channelInterpretation || "(unavailable)",
        aB = !0,
        t.close && t.close()
    }
    const fB = sB.qs.Jj.Oqn = class extends sB.qs.Ys {
        constructor() {
            super(hB),
            this.lKi = this.dwt("okButton"),
            this.lKi.textContent = nB("common.ok"),
            this.lKi.onclick = () => this.gwt(),
            this.iSe = this.dwt("copy"),
            this.iSe.textContent = nB("common.copy"),
            this.iSe.onclick = () => this.eSe(),
            this.Aet = this.dwt("platformInfoContent")
        }
        Swt() {}
        async dqn(t) {
            const i = {
                Dqn: !1,
                persisted: !1,
                Fqn: !1,
                usage: 0,
                Lqn: 0
            }
              , e = [];
            return sB.zk.ZRe && e.push(navigator.storage.persisted().then(t => {
                i.Dqn = !0,
                i.persisted = t
            }
            ).catch(t => {
                (() => {})("Error requesting persistent storage: ", t),
                i.Dqn = !1
            }
            )),
            sB.zk.QRe && e.push(navigator.storage.estimate().then(t => {
                i.Fqn = !0,
                i.usage = t.usage,
                i.Lqn = t.quota
            }
            ).catch(t => {
                (() => {})("Error estimating storage usage: ", t),
                i.Fqn = !1
            }
            )),
            await Promise.all(e),
            await this.Bqn(i, t)
        }
        async Bqn(t, i) {
            const e = self.app;
            let s = "(unavailable, defaulting to 2)";
            "number" == typeof navigator.hardwareConcurrency && navigator.hardwareConcurrency > 0 && (s = navigator.hardwareConcurrency);
            let n = "(unavailable)";
            "number" == typeof navigator.deviceMemory && navigator.deviceMemory > 0 && (n = navigator.deviceMemory + " GB"),
            await sB.kt.$Re();
            let r = `<h3>Platform information</h3>\n\t\t<p>\n\t\t<strong>Product:</strong> Construct ${"animation" === e.QPe() ? "Animate" : "3"} ${sB.o_.Lhi} (${e.tke(!0)})<br/>\n\t\t<strong>Browser:</strong> ${sB.kt.Nr} ${sB.kt.BRe}<br/>\n\t\t<strong>Browser engine:</strong> ${sB.kt.NRe}<br/>\n\t\t<strong>Context:</strong> ${sB.kt.Tj}<br/>\n\t\t<strong>Operating system:</strong> ${sB.kt.OS} ${sB.kt.LRe}<br/>\n\t\t<strong>Device type:</strong> ${sB.kt.lA ? "desktop" : "mobile"}<br/>\n\t\t<strong>Device pixel ratio:</strong> ${self.devicePixelRatio}<br/>\n\t\t<strong><abbr title="Number of hardware threads supported by the device, which can be different to the number of physical cores.">Logical CPU cores</abbr>:</strong> ${s}<br/>\n\t\t<strong>Approx. device memory:</strong> ${n}<br/>\n\t\t<strong>User agent:</strong> ${navigator.userAgent}<br/>\n\t\t<strong>Language setting:</strong> ${e.iwt()}\n\t\t</p>`
              , h = null;
            try {
                h = await e.Pv()
            } catch (t) {}
            if (!i) {
                if (r += "<h3>Local storage</h3>\n\t\t\t<p>",
                t.Fqn) {
                    const i = Math.round(1e3 * t.usage / t.Lqn) / 10;
                    r += `\n\t\t\t\t<strong>Storage quota (approx):</strong> ${sB.Iye(t.Lqn)}<br/>\n\t\t\t\t<strong>Storage usage (approx):</strong> ${sB.Iye(t.usage)} (${i}%)<br/>\n\t\t\t\t`
                } else
                    r += "\n\t\t\t\t<strong>Storage quota (approx):</strong> (status unavailable)<br/>\n\t\t\t\t<strong>Storage usage (approx):</strong> (status unavailable)<br/>\n\t\t\t\t";
                t.Dqn ? r += `\n\t\t\t\t<strong>Persistent storage:</strong> ${t.persisted ? "Yes" : "No"}\n\t\t\t\t` : r += "\n\t\t\t\t<strong>Persistent storage:</strong> (status unavailable)\n\t\t\t\t",
                r += "</p>",
                r += "<h3>Browser support notes</h3>\n\t\t\t<p>This list contains missing features that are not required, but could improve performance or user experience if supported.</p>\n\t\t\t<ul>";
                let i = "";
                "Firefox" === sB.kt.Nr && (i += '<li>Rendering multiple on-screen Layout Views is slow in Firefox due to <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1163426">bug 1163426</a></li>'),
                CSS.supports("contain", "content") || (i += "<li>CSS containment is not supported. Editor performance may be significantly degraded.</li>"),
                sB.zk.R$i || (i += "<li>The &lt;dialog&gt; element is not supported. A polyfill is in use.</li>"),
                sB.zk.qRe || (i += "<li>The Clipboard API is not supported. Some clipboard features may be unavailable."),
                sB.zk.WRe || (i += "<li>Web Animations are not supported. Animations are disabled.</li>"),
                void 0 === Intl.PluralRules && (i += "<li>This browser does not support pluralisation rules. Plural forms may not be correct.</li>"),
                e.J1() || (i += "<li>UI effects are disabled in settings.</li>"),
                h && h.Rgn() && h.Qxn() < 2 && (i += "<li>WebGL 2+ is not supported. Rendering quality and features may be affected.</li>"),
                h && h.Agn() && (i += `<li>${h.Rgn() ? "WebGL" : "WebGPU"} indicates a major performance caveat. It is probably using software rendering.</li>`),
                h || (i += "<li><strong>Failed to create WebGL renderer. Layout views cannot be opened.</strong></li>"),
                sB.zk.ImageBitmap || (i += "<li>ImageBitmap is not supported. Texture loading performance may be degraded.</li>"),
                sB.zk.ImageBitmap && !sB.zk.Qhs && (i += "<li>ImageBitmapOptions is not supported. Texture loading performance may be degraded.</li>"),
                sB.zk.HRe || (i += "<li>Idle callbacks are not supported. Background loading performance may be degraded.</li>"),
                "undefined" == typeof InputDeviceCapabilities && (i += "<li>Determining input device capabilities is not supported.</li>"),
                sB.zk.ZRe || (i += "<li>Persistent storage is not available. Local storage could be deleted by the browser.</li>"),
                sB.zk.QRe || (i += "<li>Storage quota estimate is unavailable.</li>"),
                CSS.supports("cursor", "-webkit-image-set(url(cursor.png) 1x), crosshair") || CSS.supports("cursor", "image-set(url(cursor.png) 1x), crosshair") || (i += "<li>image-set() is not supported. Mouse cursors may appear with reduced quality."),
                i || (i = "<li>Nothing is missing. Everything is OK!</li>"),
                r += i,
                r += "</ul>"
            }
            if (h)
                if (h.Rgn()) {
                    const t = new Set(h.a_n());
                    if (r += `<h3>WebGL information</h3>\n\t\t\t\t<p>\n\t\t\t\t<strong>Version string:</strong> ${h.n_n()}<br/>\n\t\t\t\t<strong>Numeric version:</strong> ${h.Qxn()}<br/>\n\t\t\t\t<strong>Supports <abbr title="non-power-of-two">NPOT</abbr> textures:</strong> ${h.kv() ? "yes" : "partial"}<br/>\n\t\t\t\t<strong>Supports GPU profiling:</strong> ${h.e_n() ? "yes" : "no"}<br/>\n\t\t\t\t<strong>Vendor:</strong> ${h.r_n()}<br/>\n\t\t\t\t<strong>Renderer:</strong> ${h.h_n()}<br/>\n\t\t\t\t<strong><abbr title="Indicates a performance problem such as use of a software renderer instead of graphics hardware.">Major performance caveat:</strong> ${h.Agn() ? "yes" : "no"}<br/>\n\t\t\t\t<strong>Maximum texture size:</strong> ${h.Yyn()}<br/>\n\t\t\t\t<strong>Point size range:</strong> ${h.if()} to ${h.ef()}<br/>\n\t\t\t\t<strong>Extensions:</strong>`,
                    i)
                        r += " " + [...t].join(", ") + "</p>";
                    else {
                        r += "</p><ul>";
                        for (const i of t)
                            r += `<li>${i}</li>`;
                        r += "</ul>"
                    }
                } else {
                    const t = h.$Gn();
                    t.sort();
                    const e = h.zGn();
                    if (r += `<h3>WebGPU information</h3>\n\t\t\t\t<p>\n\t\t\t\t<strong>Renderer:</strong> WebGPU<br/>\n\t\t\t\t<strong>Supports GPU profiling:</strong> ${h.e_n() ? "yes" : "no"}<br/>\n\t\t\t\t<strong><abbr title="Indicates a performance problem such as use of a software renderer instead of graphics hardware.">Major performance caveat:</strong> ${h.Agn() ? "yes" : "no"}<br/>\n\t\t\t\t<strong>Maximum texture size:</strong> ${h.Yyn()}<br/>\n\t\t\t\t<strong>Adapter vendor:</strong> \t\t${e && e.vendor || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter architecture:</strong>\t${e && e.architecture || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter device:</strong>\t\t${e && e.device || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter description:</strong>\t${e && e.description || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter type:</strong>\t\t\t${e && e.type || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter backend:</strong>\t\t${e && e.backend || "(unavailable)"}<br/>\n\t\t\t\t<strong>Adapter features:</strong>`,
                    i)
                        r += " " + t.join(", ") + "</p>";
                    else {
                        r += "</p><ul>";
                        for (const i of t)
                            r += `<li>${i}</li>`;
                        r += "</ul>"
                    }
                }
            else
                r += "<h3>WebGL information</h3>\n\t\t\t<p><strong>Failed to create WebGL renderer. Try installing any available software updates.</strong></p>";
            if (!i) {
                dB(),
                r += `<h3>Audio information</h3>\n\t\t\t<p>\n\t\t\t<strong>System sample rate:</strong> ${lB} Hz<br/>\n\t\t\t<strong>Output channels:</strong> ${uB}</br>\n\t\t\t<strong>Output interpretation:</strong> ${cB}<br/>\n\t\t\t<strong>Supported decode formats:</strong></p><ul>`;
                const t = new Audio
                  , i = [["webm", "WebM"], ["mp4", "MPEG-4"]]
                  , e = [["opus", "Opus"], ["vorbis", "Vorbis"], ["mp4a.40.2", "AAC"]];
                for (const [s,n] of i)
                    for (const [i,h] of e) {
                        const e = `audio/${s};codecs=${i}`;
                        t.canPlayType(e) && (r += `<li>${n} ${h} (${e})</li>`)
                    }
                if (t.canPlayType("audio/mpeg") && (r += "<li>MP3 (audio/mpeg)</li>"),
                t.canPlayType("audio/flac") && (r += "<li>FLAC (audio/flac)</li>"),
                t.canPlayType("audio/wav;codecs=1") && (r += "<li>PCM WAV (audio/wav;codecs=1)</li>"),
                r += "</ul>\n\t\t\t<p>\n\t\t\t<strong>Supported encode formats:</strong> ",
                "undefined" == typeof MediaRecorder || void 0 === MediaRecorder.isTypeSupported)
                    r += "<em>(encoding not supported)</em></p>";
                else {
                    r += "</p><ul>";
                    for (const [t,s] of i)
                        for (const [i,n] of e) {
                            const e = `audio/${t};codecs=${i}`;
                            MediaRecorder.isTypeSupported(e) && (r += `<li>${s} ${n} (${e})</li>`)
                        }
                    MediaRecorder.isTypeSupported("audio/mpeg") && (r += "<li>MP3 (audio/mpeg)</li>"),
                    MediaRecorder.isTypeSupported("audio/flac") && (r += "<li>FLAC (audio/flac)</li>"),
                    MediaRecorder.isTypeSupported("audio/wav;codecs=1") && (r += "<li>PCM WAV (audio/wav;codecs=1)</li>"),
                    r += "</ul>"
                }
                r += "<h3>Video information</h3>\n\t\t\t<p>\n\t\t\t<strong>Supported decode formats:</strong></p><ul>";
                const s = document.createElement("video")
                  , n = [["av01.0.00M.08", "AV1"], ["vp9", "VP9"], ["vp8", "VP8"], ["hev1.1.2.L93.B0", "H.265"], ["avc1.420034", "H.264"]];
                for (const [t,e] of i)
                    for (const [i,h] of n) {
                        const n = `video/${t};codecs=${i}`;
                        s.canPlayType(n) && (r += `<li>${e} ${h} (${n})</li>`)
                    }
                if (r += "</ul>\n\t\t\t<p>\n\t\t\t<strong>Supported encode formats:</strong> ",
                "undefined" == typeof MediaRecorder || void 0 === MediaRecorder.isTypeSupported)
                    r += "<em>(encoding not supported)</em></p>";
                else {
                    r += "</p><ul>";
                    for (const [t,e] of i)
                        for (const [i,s] of n) {
                            const n = `video/${t};codecs=${i}`;
                            MediaRecorder.isTypeSupported(n) && (r += `<li>${e} ${s} (${n})</li>`)
                        }
                    r += "</ul>"
                }
            }
            return r
        }
        Qa(t) {
            return this.dqn().then(t => this.Aet.innerHTML = t),
            super.Qa(t)
        }
        eSe() {
            const t = document.createRange();
            t.selectNodeContents(this.Aet);
            const i = window.getSelection();
            i.removeAllRanges(),
            i.addRange(t),
            document.execCommand("copy")
        }
        VW() {
            sB.qs.BYt(this.Aet)
        }
    }
    ;
    sB.qs.HY.ipt.addEventListener("load", () => {
        sB.qs.Ys.opt(oB, fB)
    }
    )
}
{
    const pB = self.t
      , mB = pB.ek(import.meta.url)
      , wB = mB.getElementById("privacyPolicyDialog")
      , gB = (pB.tk(mB.URL),
    "PrivacyPolicy")
      , yB = pB.qs.Jj.Uqn = class extends pB.qs.Ys {
        constructor() {
            super(wB),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.dwt("eula").onclick = function() {
                pB.qs.Ys.$s("EULA").Qa()
            }
        }
        Swt() {
            this.lKi.textContent = self.lang("common.close-dialog")
        }
        Qa(t) {
            return super.Qa(t)
        }
        VW() {}
    }
    ;
    pB.qs.HY.ipt.addEventListener("load", () => {
        pB.qs.Ys.opt(gB, yB)
    }
    )
}
{
    const bB = self.t
      , vB = bB.ek(import.meta.url)
      , SB = vB.getElementById("shellOutputDialog")
      , xB = bB.tk(vB.URL);
    bB.p.ik(xB + "lang");
    const MB = "ShellOutput"
      , EB = ["rgb(0, 0, 0)", "rgb(194, 54, 33)", "rgb(37, 188, 36)", "rgb(173, 173, 39)", "rgb(73, 46, 225)", "rgb(211, 56, 211)", "rgb(51, 187, 200)", "rgb(203, 204, 205)"]
      , CB = bB.qs.Jj.Nqn = class extends bB.qs.Ys {
        constructor() {
            super(SB),
            this.jqn = this.dwt("shell-block"),
            this.$qn = this.dwt("shell-message"),
            this.zqn = this.dwt("shell-summary")
        }
        Swt() {
            this.zqn.textContent = self.lang("ui.dialogs.shell-output.build-log")
        }
        Qa(t, i, e, s) {
            bB.zt(t),
            bB.zt(i),
            bB.zt(e),
            bB.Hdt(s),
            this.$qn.textContent = i;
            const n = this.jqn;
            let r = 0
              , h = null;
            bB.qs.BYt(n),
            this.Ya(t),
            e.replace(/\[(\d+)m/g, (t, i, e, s) => {
                const o = s.slice(r, e)
                  , a = document.createElement("span");
                h && (a.style.color = h),
                a.textContent = o,
                n.appendChild(a),
                0 == i && h && (h = null),
                i > 29 && i < 38 && (h = EB[i - 30]),
                r = e + t.length
            }
            );
            const o = e.slice(r)
              , a = document.createElement("span");
            h && (a.style.color = h),
            a.textContent = o,
            n.appendChild(a),
            super.Qa(s)
        }
    }
    ;
    bB.qs.HY.ipt.addEventListener("load", () => {
        bB.qs.Ys.opt(MB, CB)
    }
    )
}
{
    const _B = self.t
      , TB = self.lang
      , IB = self.idt
      , PB = self.iG
      , GB = _B.ek(import.meta.url)
      , AB = GB.getElementById("storageCleanupDialog")
      , RB = _B.tk(GB.URL);
    _B.p.ik(RB + "lang");
    const kB = "StorageCleanup"
      , OB = _B.qs.Jj.Vqn = class extends _B.qs.Ys {
        constructor() {
            super(AB),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.lhs = this.dwt("cancelButton"),
            this.lhs.onclick = () => this.tWt(),
            this.Wqn = this.dwt("scanningWrap"),
            this.Hqn = this.dwt("readyWrap"),
            this.Kqn = this.dwt("storageUsageHeader"),
            this.qqn = this.dwt("clearExportManagerStorage"),
            this.Xqn = this.dwt("clearExportManagerStorageLabel"),
            this.Yqn = this.dwt("clearExampleProjectsStorage"),
            this.Jqn = this.dwt("clearExampleProjectsStorageLabel"),
            this.Zqn = this.dwt("clearLinuxCefStorage"),
            this.Qqn = this.dwt("clearLinuxCefStorageLabel"),
            this.tXn = this.dwt("clearC3Storage"),
            this.iXn = this.dwt("clearC3StorageLabel"),
            this.eXn = this.dwt("localBrowserSavesInfo"),
            this.sXn = this.dwt("clearBrowserCacheInfo"),
            this.nXn = this.dwt("privateBrowsingInfo"),
            this.rXn = this.dwt("systemCleanupInfo"),
            "animation" === self.app.QPe() && (this.dwt("linuxcefwrap").style.display = "none"),
            this.hXn = new Map
        }
        Swt() {
            _B.p.u("ui.dialogs.storageCleanup"),
            this.Ya(TB(".caption")),
            this.lKi.textContent = TB(".clear-storage"),
            this.lhs.textContent = TB("common.cancel");
            const t = this.dwt("helpLink");
            t.textContent = TB("common.help"),
            t.onclick = () => self.app.s_("interface/dialogs/storage-cleanup", "StorageCleanupHelp"),
            this.Wqn.textContent = TB(".scanning-storage"),
            _B.odt(this.dwt("clearExportManagerStorageTip"), IB(".export-manager.tip")),
            _B.odt(this.dwt("clearExampleProjectsStorageTip"), IB(".example-projects.tip")),
            _B.odt(this.dwt("clearLinuxCefStorageTip"), IB(".linux-cef.tip")),
            _B.odt(this.dwt("clearC3StorageTip"), IB(".c3-offline.tip")),
            _B.p.u(".more-options"),
            _B.odt(this.dwt("moreOptionsHeader"), IB(".header")),
            _B.odt(this.dwt("moreOptionsText"), IB(".description")),
            _B.odt(this.eXn, IB(".local-browser-saves")),
            _B.odt(this.sXn, IB(".clear-browser-cache")),
            _B.odt(this.nXn, IB(".private-browsing")),
            _B.odt(this.rXn, IB(".system-storage-cleanup")),
            _B.p.j(),
            _B.p.j()
        }
        Qa(t) {
            "browser" !== _B.kt.Tj && (this.sXn.style.display = "none",
            this.nXn.style.display = "none"),
            self.jk.oXn().then(t => {
                t && (this.eXn.style.display = "none")
            }
            ).catch(t => console.error("[Storage cleanup] Error checking local browser storage: ", t));
            const i = super.Qa(t);
            return self.app.Lii("StorageCleanupDialog", "Shown"),
            this.lKi.setAttribute("disabled", ""),
            this.Wqn.style.display = "",
            this.Hqn.style.display = "none",
            this.aXn(),
            i
        }
        async aXn() {
            await Promise.all([this.lXn(), this.uXn(), this.cXn(), this.dXn(), this.fXn()]),
            this.pXn()
        }
        async lXn() {
            if (_B.zk.QRe)
                try {
                    const t = await navigator.storage.estimate()
                      , i = t.quota
                      , e = t.usage
                      , s = Math.round(1e3 * e / i) / 10;
                    _B.odt(this.Kqn, self.tG("ui.dialogs.storageCleanup.storage-usage-header", _B.Iye(e), _B.Iye(i), s))
                } catch (t) {
                    return (() => {})("Error estimating storage usage: ", t),
                    void (this.Kqn.style.display = "none")
                }
            else
                this.Kqn.style.display = "none"
        }
        async uXn() {
            await self.app.Lj(),
            await _B.Ars.SIt();
            let t = 0
              , i = 0;
            try {
                const e = self.wXn.mXn()
                  , s = await e.keys()
                  , n = s.indexOf(self.wXn.gXn());
                n >= 0 && s.splice(n, 1);
                const r = await Promise.all(s.map(t => e.getItem(t)));
                t = r.length,
                i = r.reduce( (t, i) => t + i.size, 0),
                this.hXn.set("linux-cef", {
                    yXn: i,
                    bXn: t,
                    delete: () => Promise.all(s.map(t => e.removeItem(t)))
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning Linux CEF storage: ", t),
                self.app.Lii("StorageCleanupDialog", "ScanError-LinuxCEF:" + t)
            }
            _B.odt(this.Qqn, PB("ui.dialogs.storageCleanup.linux-cef.label", {
                bD: !0
            }, t, _B.Iye(i))),
            this.Zqn.checked = !0
        }
        async cXn() {
            let t = 0
              , i = 0;
            try {
                const e = _B.qs.Ys.UHn.pKn()
                  , s = await localforage.getItem(e);
                if (s)
                    for (const e of s)
                        e.blob && (t++,
                        i += e.blob.size);
                this.hXn.set("export-manager", {
                    yXn: i,
                    bXn: t,
                    delete: () => localforage.removeItem(e)
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning export manager storage: ", t),
                self.app.Lii("StorageCleanupDialog", "ScanError-exports:" + t)
            }
            _B.odt(this.Xqn, PB("ui.dialogs.storageCleanup.export-manager.label", {
                bD: !0
            }, t, _B.Iye(i))),
            this.qqn.checked = !0
        }
        async dXn() {
            let t = 0
              , i = 0;
            try {
                const e = []
                  , s = await caches.keys();
                await Promise.all(s.map(async s => {
                    const n = await caches.open(s)
                      , r = (await n.keys()).filter(t => /example-?projects\/(.*)\.c3p/i.test(t.url));
                    t += r.length;
                    const h = await Promise.all(r.map(async t => {
                        const i = await n.match(t);
                        return (await i.blob()).size
                    }
                    ));
                    i += h.reduce( (t, i) => t + i, 0),
                    e.push( () => Promise.all(r.map(t => n.delete(t))))
                }
                )),
                this.hXn.set("example-projects", {
                    yXn: i,
                    bXn: t,
                    delete: () => Promise.all(e.map(t => t()))
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning example projects storage: ", t),
                self.app.Lii("StorageCleanupDialog", "ScanError-exampleprojs:" + t)
            }
            _B.odt(this.Jqn, PB("ui.dialogs.storageCleanup.example-projects.label", {
                bD: !0
            }, t, _B.Iye(i))),
            this.Yqn.checked = !0
        }
        async fXn() {
            let t = 0
              , i = 0;
            try {
                const e = await caches.keys();
                t = e.length,
                t >= 2 && t--,
                await Promise.all(e.map(async t => {
                    const e = await caches.open(t)
                      , s = await e.keys()
                      , n = await Promise.all(s.map(async t => {
                        const i = await e.match(t);
                        return (await i.blob()).size
                    }
                    ));
                    i += n.reduce( (t, i) => t + i, 0)
                }
                )),
                this.hXn.set("c3-offline", {
                    yXn: i,
                    bXn: t,
                    delete: async () => {
                        await Promise.all(e.map(t => caches.delete(t)));
                        const t = await navigator.serviceWorker.getRegistrations();
                        await Promise.all(t.map(t => t.unregister()))
                    }
                })
            } catch (t) {
                console.error("[Storage cleanup] Error scanning C3 offline storage: ", t),
                self.app.Lii("StorageCleanupDialog", "ScanError-c3:" + t)
            }
            _B.odt(this.iXn, PB("ui.dialogs.storageCleanup.c3-offline.label", {
                bD: !0
            }, t, _B.Iye(i))),
            this.tXn.checked = !1
        }
        pXn() {
            this.Wp() && (this.lKi.removeAttribute("disabled"),
            this.Wqn.style.display = "none",
            this.Hqn.style.display = "")
        }
        gwt() {
            const t = self.app;
            if (!(this.Zqn.checked || this.qqn.checked || this.Yqn.checked || this.tXn.checked)) {
                return void _B.qs.Ys.$s("OK").Qa(TB("ui.dialogs.storageCleanup.nothing-to-clear"))
            }
            this.lKi.setAttribute("disabled", ""),
            (async () => {
                const i = _B.qs.Ys.$s("Progress");
                i.Qa(TB("ui.dialogs.storageCleanup.clearing-storage"));
                let e = 0;
                const s = [];
                this.Zqn.checked && s.push("linux-cef"),
                this.qqn.checked && s.push("export-manager"),
                this.Yqn.checked && !this.tXn.checked && s.push("example-projects"),
                this.tXn.checked && s.push("c3-offline");
                let n = !1;
                try {
                    await Promise.all(s.map(t => {
                        const i = this.hXn.get(t);
                        if (i)
                            return e += i.yXn,
                            i.delete()
                    }
                    ))
                } catch (i) {
                    n = !0,
                    console.error("[Storage cleanup] Error deleting storage: ", i),
                    t.Lii("StorageCleanupDialog", "DeleteError:" + i)
                }
                t.Lii("StorageCleanupDialog", "DidCleanup-" + (n ? "Error" : "Success")),
                i.PR(),
                super.gwt();
                _B.qs.Ys.$s("OK").Qa(n ? TB("ui.dialogs.storageCleanup.error-clearing") : self.tP("ui.dialogs.storageCleanup.successfully-cleared", _B.Iye(e)))
            }
            )()
        }
        tWt() {
            self.app.Lii("StorageCleanupDialog", "Cancelled"),
            super.tWt()
        }
        VW() {}
    }
    ;
    _B.qs.HY.ipt.addEventListener("load", () => {
        _B.qs.Ys.opt(kB, OB)
    }
    )
}
{
    const DB = self.t
      , FB = self.lang
      , LB = DB.ek(import.meta.url)
      , BB = LB.getElementById("svgPreviewDialog")
      , UB = DB.tk(LB.URL);
    DB.p.ik(UB + "lang");
    const NB = "SVGPreview"
      , jB = DB.qs.Jj.vXn = class extends DB.qs.Ys {
        constructor() {
            super(BB),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.SXn = this.dwt("svgPreviewTitle"),
            this.xXn = this.dwt("svgPreviewEditXml"),
            this.xXn.onclick = () => this.MXn(),
            this.EXn = null,
            this.xh = null,
            this.bhs = null,
            this.frs = "",
            this.CXn = this.dwt("headerWrap")
        }
        Swt() {
            DB.p.u("ui.dialogs.svgPreview"),
            this.Ya(FB(".caption")),
            this.lKi.textContent = FB("common.close-dialog"),
            DB.p.j()
        }
        async Qa(t, i) {
            if (this.xXn.style.display = "none",
            this.dwt("svgPreviewDash").style.display = "none",
            DB.$l(t, globalThis.fh)) {
                let i;
                this.xh = t;
                let e = t.xc();
                if (i = DB.g2t(e) ? e : DB.CU([e], this.xh.Fa(), {
                    type: e.type
                }),
                !await DB.P0t(i))
                    throw new Error("expected image");
                await DB._2t(i) ? (this.Ya(FB("ui.dialogs.svgPreview.caption")),
                this.xXn.style.display = "",
                this.dwt("svgPreviewDash").style.display = "",
                this.xXn.textContent = FB("ui.dialogs.svgPreview.edit-xml")) : await DB.I0t(i) ? this.Ya(FB("ui.dialogs.svgPreview.caption-animation")) : this.Ya(FB("ui.dialogs.svgPreview.caption-image"))
            } else {
                let i;
                if (this.bhs = t,
                i = DB.g2t(t) ? t : DB.CU([t], "", {
                    type: t.type
                }),
                this.xXn.textContent = FB(".view-xml"),
                !await DB.P0t(i))
                    throw new Error("expected image");
                await DB._2t(i) ? (this.Ya(FB("ui.dialogs.svgPreview.caption")),
                this.xXn.style.display = "",
                this.dwt("svgPreviewDash").style.display = "",
                this.xXn.textContent = FB("ui.dialogs.svgPreview.view-xml")) : await DB.I0t(i) ? this.Ya(FB("ui.dialogs.svgPreview.caption-animation")) : this.Ya(FB("ui.dialogs.svgPreview.caption-image"))
            }
            this.SXn.textContent = self.tP("ui.dialogs.svgPreview.svg-title", this.HKn(t), this.qKn(t)),
            this.EXn = new Image,
            this.EXn.className = "transparent-checkerboard-pattern",
            this.EXn.src = await this.XKn(t);
            const e = globalThis.app.dT();
            return e && this.EXn.setAttribute("sampling", e.bn()),
            this.y5t().appendChild(this.EXn),
            super.Qa(i)
        }
        MXn() {
            if (this.xh) {
                const t = this.xh;
                this.PR();
                self.app.DA().TU(t)
            }
            this.bhs && DB.qs.Ys.$s("TextPreview").Qa(this.bhs, this.bhs.type)
        }
        _Xn(t) {
            return DB.$l(t, globalThis.fh) ? t.dL().uL() : DB.MimeType.NAs(t).uL()
        }
        HKn(t) {
            return DB.$l(t, globalThis.fh) ? t.dh() : t.name ?? ""
        }
        qKn(t) {
            return DB.$l(t, globalThis.fh) ? DB.Iye(t.xc().size) : DB.Iye(t.size)
        }
        async XKn(t) {
            return DB.$l(t, globalThis.fh) ? t.zU() : (this.frs = URL.createObjectURL(t),
            this.frs)
        }
        VW() {
            this.xh = null,
            this.bhs = null,
            DB.qs.BW(this.EXn),
            this.EXn = null,
            this.SXn.textContent = "",
            this.frs && URL.revokeObjectURL(this.frs),
            this.frs = ""
        }
    }
    ;
    DB.qs.HY.ipt.addEventListener("load", () => {
        DB.qs.Ys.opt(NB, jB)
    }
    )
}
{
    const $B = self.t
      , zB = self.lang
      , VB = $B.ek(import.meta.url)
      , WB = VB.getElementById("videoPreviewDialog")
      , HB = $B.tk(VB.URL);
    $B.p.ik(HB + "lang");
    const KB = "VideoPreview"
      , qB = $B.qs.Jj.TXn = class extends $B.qs.Ys {
        constructor() {
            super(WB),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.SXn = null,
            this.QIe = null,
            this.xh = null,
            this.bhs = null,
            this.frs = "",
            this.CXn = this.dwt("headerWrap")
        }
        Swt() {
            this.lKi.textContent = zB("common.close-dialog"),
            this.Ya(zB("ui.dialogs.videoPreview.caption"))
        }
        async Qa(t, i) {
            return this.SXn = document.createElement("h3"),
            this.QIe = document.createElement("video"),
            this.QIe.addEventListener("loadedmetadata", () => this.IXn()),
            $B.$l(t, globalThis.fh) ? this.xh = t : this.bhs = t,
            this.QIe.src = await this.XKn(),
            this.QIe.controls = !0,
            this.QIe.autoplay = !0,
            this.IXn(),
            this.CXn.appendChild(this.SXn),
            this.y5t().appendChild(this.QIe),
            super.Qa(i)
        }
        IXn() {
            if (!this.QIe)
                return;
            const t = this.QIe.videoWidth || "?"
              , i = this.QIe.videoHeight || "?";
            this.SXn.textContent = self.tP("ui.dialogs.videoPreview.video-title", this.HKn(), this.KKn(), t, i, this.qKn())
        }
        KKn() {
            return this.xh ? this.xh.dL().aAs() : this.bhs ? $B.MimeType.NAs(this.bhs).aAs() : void 0
        }
        HKn() {
            return this.xh ? this.xh.dh() : this.bhs ? this.bhs.name : void 0
        }
        qKn() {
            return this.xh ? $B.Iye(this.xh.xc().size) : this.bhs ? $B.Iye(this.bhs.size) : void 0
        }
        async XKn() {
            return this.xh ? this.xh.zU() : this.bhs ? (this.frs = URL.createObjectURL(this.bhs),
            this.frs) : void 0
        }
        VW() {
            this.QIe.pause(),
            this.QIe.src = "",
            $B.qs.BW(this.QIe),
            this.QIe = null,
            this.SXn = null,
            this.xh = null,
            this.bhs = null,
            this.frs && URL.revokeObjectURL(this.frs),
            this.frs = "",
            $B.qs.BYt(this.CXn)
        }
    }
    ;
    $B.qs.HY.ipt.addEventListener("load", () => {
        $B.qs.Ys.opt(KB, qB)
    }
    )
}
{
    const XB = self.t
      , YB = XB.ek(import.meta.url)
      , JB = YB.getElementById("viewIconSheetsDialog")
      , ZB = (XB.tk(YB.URL),
    "ViewIconSheets")
      , QB = XB.qs.Jj.PXn = class extends XB.qs.Ys {
        constructor() {
            super(JB),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.GXn = this.dwt("viewIconSheetsList"),
            this.AXn = []
        }
        Swt() {}
        Qa(t) {
            let i = -1
              , e = null
              , s = 0
              , n = 0
              , r = 0
              , h = 0;
            for (let t of XB.qs.T5e.s6e()) {
                let o = t.X5e();
                if (!o)
                    continue;
                let a = t.n5e();
                a !== i && (i = a,
                h = 0,
                e && this.GXn.appendChild(e),
                e = document.createElement("div"),
                e.className = "sizeWrap",
                e.insertAdjacentHTML("beforeend", `<h3>Icon size ${a} x ${a}</h3>`)),
                ++n,
                r += t.Y5e();
                let l = document.createElement("div");
                l.className = "sheetWrap";
                let u = t.d5e();
                l.insertAdjacentHTML("beforeend", `<p>Sheet #${h} (${u} x ${u}, ${t.Y5e()} icons)`),
                o.className = "transparent-checkerboard-pattern",
                o.style.width = t.u5e() + "px",
                o.style.height = t.u5e() + "px",
                this.AXn.push(o),
                l.appendChild(o),
                e.appendChild(l),
                s += u * u,
                ++h
            }
            e && this.GXn.appendChild(e);
            let o = s / 1048576;
            return this.GXn.insertAdjacentHTML("afterbegin", `<p>Total icon sheet area: ${Math.round(100 * o) / 100} megapixels (${r} images over ${n} sheets)</p>`),
            super.Qa(t)
        }
        VW() {
            XB.qs.BYt(this.GXn);
            for (let t of this.AXn)
                t.style.width = "",
                t.style.height = "",
                t.className = "";
            XB.sc(this.AXn)
        }
    }
    ;
    XB.qs.HY.ipt.addEventListener("load", () => {
        XB.qs.Ys.opt(ZB, QB)
    }
    )
}
{
    const tU = self.t
      , iU = self.lang
      , eU = self.tP
      , sU = self.tG
      , nU = tU.ek(import.meta.url)
      , rU = nU.getElementById("viewSpritesheetsDialog")
      , hU = tU.tk(nU.URL);
    tU.p.ik(hU + "lang");
    const oU = "ViewSpritesheets"
      , aU = [.1, 1 / 4, 1 / 3, .5, 2 / 3, 3 / 4, 1, 1.5, 2]
      , lU = tU.qs.Jj.RXn = class extends tU.qs.Ys {
        constructor() {
            super(rU),
            this.kXn = this.dwt("statusText"),
            this.OXn = this.dwt("zoomSlider"),
            this.OXn.addEventListener("input", () => this.DXn()),
            this.FXn = this.dwt("zoomLabel"),
            this.pwt = null,
            this.LXn = 0,
            this.BXn = 0,
            this.UXn = 0,
            this.NXn = 0,
            this.jXn = [],
            this.$Xn = new Map,
            this.zXn = [],
            this.GXn = this.dwt("viewSpritesheetsList")
        }
        Swt() {}
        Qa(t, i) {
            tU.U(t, self.gh),
            tU.p.u("ui.dialogs.view-spritesheets"),
            this.pwt = t,
            this.Ya(eU(".caption", this.pwt.Fa())),
            this.kXn.textContent = self.lang(".loading"),
            this.OXn.value = 6,
            this.DXn(),
            tU.qs.BYt(this.GXn),
            tU.sc(this.zXn),
            localforage.getItem("view-spritesheets-options").then(t => {
                t && (this.OXn.value = t.zoomSetting ?? 6,
                this.DXn())
            }
            ).catch(tU.Gv),
            this.LXn = 0,
            this.BXn = 0;
            const e = [];
            for (const t of this.pwt.eni())
                this.LXn++,
                e.push(t.Hns().then( () => this.VXn()));
            return Promise.all(e).then( () => this.WXn()),
            tU.p.j(),
            super.Qa(i)
        }
        VXn() {
            this.BXn++;
            const t = this.BXn / this.LXn;
            this.kXn.textContent = eU("ui.dialogs.view-spritesheets.building-spritesheets", Math.round(1e3 * t) / 10)
        }
        WXn() {
            this.UXn = 0,
            this.NXn = 0;
            for (const t of this.pwt.eni())
                for (const i of t.srs())
                    this.UXn++,
                    this.jXn.push(i);
            this.HXn().then( () => this.KXn())
        }
        HXn() {
            const t = this.jXn.map(t => t.Crs().then( () => {
                this.pwt && this.qXn(t)
            }
            ));
            return Promise.all(t)
        }
        qXn(t) {
            this.$Xn.set(t, {
                blob: t.Prs(),
                XXn: t.krs()
            }),
            this.NXn++;
            const i = this.NXn / this.UXn;
            this.kXn.textContent = eU("ui.dialogs.view-spritesheets.rendering-spritesheets", Math.round(1e3 * i) / 10)
        }
        KXn() {
            if (!this.pwt)
                return;
            tU.p.u("ui.dialogs.view-spritesheets");
            let t = 0
              , i = 0
              , e = 0;
            for (const s of this.pwt.ini()) {
                const n = [...s.brs().srs()];
                if (0 === n.length)
                    continue;
                const r = document.createElement("div");
                r.className = "objectWrap";
                const h = document.createElement("h3")
                  , o = s.jns() ? iU(".lossless") : iU(".lossy");
                h.textContent = eU(".shared-collection-header", s.Fa(), s.bos(), o),
                r.appendChild(h);
                const a = document.createElement("div");
                a.className = "sheetCollectionWrap",
                r.appendChild(a);
                let l = 1;
                for (const r of n) {
                    ++i,
                    e += r.Grs();
                    const n = document.createElement("div");
                    if (n.className = "sheetWrap",
                    !this.$Xn.has(r))
                        throw new Error("missing spritesheet");
                    const {blob: h, XXn: o} = this.$Xn.get(r)
                      , u = s.jns() ? iU(".lossless") : eU(".lossy-quality", Math.round(100 * r.Srs()))
                      , c = document.createElement("p")
                      , d = eU(".shared-sheet-number", l);
                    tU.odt(c, sU(".sheet-details", d, r.ns(), r.Kn(), tU.Iye(r.ns() * r.Kn() * 4), tU.Iye(h.size), tU.MimeType.$s(h.type).aAs(), u)),
                    n.appendChild(c);
                    const f = new Image;
                    f.className = "spriteSheet transparent-checkerboard-pattern",
                    f.src = o,
                    this.zXn.push({
                        YXn: f,
                        width: r.ns(),
                        height: r.Kn(),
                        JXn: n
                    }),
                    n.appendChild(f),
                    a.appendChild(n),
                    t += r.ns() * r.Kn(),
                    ++l
                }
                this.GXn.appendChild(r)
            }
            for (const s of this.pwt.Xl()) {
                if (!s.su() && !s.nu())
                    continue;
                if (s.kds())
                    continue;
                const n = document.createElement("div");
                n.className = "objectWrap flex";
                for (let r = 0; r < 2; ++r) {
                    const h = 0 === r
                      , o = s.Ads(h)
                      , a = [...o.srs()];
                    if (0 === a.length)
                        continue;
                    const l = iU(h ? ".lossless" : ".lossy")
                      , u = document.createElement("div");
                    u.className = "objectCollectionWrap",
                    n.appendChild(u);
                    const c = document.createElement("h3");
                    c.textContent = eU(".collection-header", o.Fa(), l),
                    u.appendChild(c);
                    const d = document.createElement("div");
                    d.className = "sheetCollectionWrap",
                    u.appendChild(d);
                    let f = 1;
                    for (const s of a) {
                        ++i,
                        e += s.Grs();
                        const n = document.createElement("div");
                        if (n.className = "sheetWrap",
                        !this.$Xn.has(s))
                            throw new Error("missing spritesheet");
                        const {blob: r, XXn: o} = this.$Xn.get(s)
                          , a = h ? iU(".lossless") : eU(".lossy-quality", Math.round(100 * s.Srs()))
                          , l = document.createElement("p")
                          , u = eU(".sheet-number", f);
                        tU.odt(l, sU(".sheet-details", u, s.ns(), s.Kn(), tU.Iye(s.ns() * s.Kn() * 4), tU.Iye(r.size), tU.MimeType.$s(r.type).aAs(), a)),
                        n.appendChild(l);
                        const c = new Image;
                        c.className = "spriteSheet transparent-checkerboard-pattern",
                        c.src = o,
                        this.zXn.push({
                            YXn: c,
                            width: s.ns(),
                            height: s.Kn(),
                            JXn: n
                        }),
                        n.appendChild(c),
                        d.appendChild(n),
                        t += s.ns() * s.Kn(),
                        ++f
                    }
                }
                this.GXn.appendChild(n)
            }
            const s = t / 1048576;
            this.kXn.textContent = eU(".summary", Math.round(100 * s) / 100, e, i),
            tU.p.j(),
            this.DXn()
        }
        DXn() {
            const t = aU[this.OXn.value];
            this.FXn.textContent = eU("ui.dialogs.view-spritesheets.zoom-label", Math.floor(100 * t));
            for (const {YXn: i, width: e, height: s, JXn: n} of this.zXn) {
                const r = e * t
                  , h = s * t;
                i.width = r,
                i.height = h,
                n.style.width = r < 200 ? "200px" : ""
            }
        }
        gwt() {
            this.Oue(),
            super.gwt()
        }
        tWt() {
            this.Oue(),
            super.tWt()
        }
        Oue() {
            localforage.setItem("view-spritesheets-options", {
                zoomSetting: this.OXn.value
            }).catch(tU.Gv)
        }
        VW() {
            this.pwt = null,
            tU.qs.BYt(this.GXn),
            tU.sc(this.zXn),
            this.$Xn.clear(),
            tU.sc(this.jXn)
        }
    }
    ;
    tU.qs.HY.ipt.addEventListener("load", () => {
        tU.qs.Ys.opt(oU, lU)
    }
    )
}
{
    const uU = self.t
      , cU = uU.ek(import.meta.url)
      , dU = cU.getElementById("viewTileTexturesDialog")
      , fU = (uU.tk(cU.URL),
    "ViewTileTextures")
      , pU = uU.qs.Jj.ZXn = class extends uU.qs.Ys {
        constructor() {
            super(dU),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.QXn = this.dwt("previousButton"),
            this.QXn.onclick = () => this.tYn(-1),
            this.rhs = this.dwt("nextButton"),
            this.rhs.onclick = () => this.tYn(1),
            this.xG = this.dwt("tiles"),
            this.TTt = this.xG.getContext("2d"),
            this.uvi = this.dwt("tileTexturesControls"),
            this.iYn = this.uvi.querySelector("span"),
            this.jsn = 1,
            this.$sn = 1
        }
        Swt() {}
        Qa() {
            return this.jsn = 1,
            this.$sn = 1,
            this.eYn(1),
            super.Qa()
        }
        VW() {}
        tYn(t) {
            this.$sn += t,
            this.$sn < 1 ? this.$sn = 1 : this.$sn > this.jsn && (this.$sn = this.jsn),
            this.eYn(this.$sn)
        }
        eYn(t) {
            this.jsn = 1,
            this.TTt.clearRect(0, 0, this.xG.width, this.xG.height),
            this.TTt.setTransform(1, 0, 0, 1, 0, 0);
            let i = 0
              , e = 0;
            for (let s of self.app.dT().Xl()) {
                if (!(s.Ja().gk()instanceof uU.ei.OM))
                    continue;
                let n = [...s.gcs()];
                if (!n.length)
                    continue;
                let r = n[0].Nl().wb()
                  , h = r.UM()
                  , o = r.HM()
                  , a = r.WM()
                  , l = r.XM()
                  , u = r.$M()
                  , c = r.YM()
                  , d = r.zM();
                for (let s of r.sYn()) {
                    let n = s.nYn() * (h + u) + a
                      , r = s.rYn() * (o + c) + l;
                    t === this.jsn && this.TTt.drawImage(d, n, r, h, o, i, e, h, o),
                    i += h,
                    i > this.xG.width && (i = 0,
                    e += o,
                    e > this.xG.height && (e = 0,
                    this.jsn++))
                }
            }
            this.iYn.textContent = `   ${this.$sn}/${this.jsn}  `
        }
    }
    ;
    uU.qs.HY.ipt.addEventListener("load", () => {
        uU.qs.Ys.opt(fU, pU)
    }
    )
}
{
    const mU = self.t
      , wU = self.lang
      , gU = self.idt
      , yU = self.tG
      , bU = self.tP
      , vU = mU.ek(import.meta.url)
      , SU = vU.getElementById("viewUsedAddonsDialog")
      , xU = mU.tk(vU.URL);
    mU.p.ik(xU + "lang");
    const MU = "ViewUsedAddons"
      , EU = 5
      , CU = mU.qs.Jj.hYn = class extends mU.qs.Ys {
        constructor() {
            super(SU),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.xot = mU.v(mU.qs.Jj.Table, this.y5t(), {
                border: !0
            });
            let t = this.xot.Got();
            mU.p.u("ui.dialogs.viewUsedAddons"),
            t.kot("icon", self.app.Gk() + 4),
            t.kot("name", 90, wU(".name")),
            t.kot("type", 60, wU(".type")),
            t.kot("author", 80, wU(".author")),
            t.kot("source", 80, wU(".source")),
            t.kot("version", 110, wU(".version")),
            t.Mot("references", wU(".references")),
            mU.p.j(),
            this.xot.iKt(),
            this.pwt = null,
            this.yh = mU.v(mU.kh, mU.jh.Gh(this.xot, "rowcontextmenu", t => this.Zot(t)), mU.jh.Gh(this.xot, "tablecontextmenu", t => this.hKt(t)))
        }
        Swt() {
            this.lKi.textContent = wU("common.ok")
        }
        Qa(t, i) {
            return this.Ya(bU("ui.dialogs.viewUsedAddons.caption", t.Fa())),
            this.pwt = t,
            this.oYn(t),
            super.Qa(i)
        }
        oYn(t) {
            mU.p.u("ui.dialogs.viewUsedAddons");
            let i = t.Ise()
              , e = [...t.MDt()]
              , s = [...i.vPs].sort(self.Plugin.Ame)
              , n = [...i.GPs].sort(self.las.Qde)
              , r = [...i.jse].sort(self.MQ.Zls);
            s.forEach(t => this.aYn(t, e)),
            n.forEach(t => this.lYn(t, e)),
            r.forEach(i => this.uYn(i, t, e)),
            mU.p.j()
        }
        aYn(t, i) {
            let e = this.xot.Eot(t);
            if (e.Lot("icon", t.uj()),
            e.Aot("name", t.Fa()),
            e.Aot("type", wU(".addon-types.plugin")),
            e.Aot("author", t.Ote()),
            e.Aot("source", gU(".addon-sources." + t.YMt())),
            "project" === t.YMt() && mU.Di.Eas(t.vR(), null)) {
                const i = t.$te()
                  , s = mU.Di.Jm(t.vR(), null).$te();
                s === i ? e.Aot("version", yU(".version-bundled-same-as-builtin", i, i)) : e.Aot("version", yU(".version-bundled-different-to-builtin", i, s))
            } else
                e.Aot("version", t.$te());
            let s = this.cYn(t, i);
            e.Aot("references", this.dYn(s))
        }
        lYn(t, i) {
            let e = this.xot.Eot(t);
            if (e.Lot("icon", t.uj()),
            e.Aot("name", t.Fa()),
            e.Aot("type", wU(".addon-types.behavior")),
            e.Aot("author", t.Ote()),
            e.Aot("source", gU(".addon-sources." + t.YMt())),
            "project" === t.YMt() && mU.F.Eas(t.vR(), null)) {
                const i = t.$te()
                  , s = mU.F.Jm(t.vR(), null).$te();
                s === i ? e.Aot("version", yU(".version-bundled-same-as-builtin", i, i)) : e.Aot("version", yU(".version-bundled-different-to-builtin", i, s))
            } else
                e.Aot("version", t.$te());
            let s = this.fYn(t, i);
            e.Aot("references", this.dYn(s))
        }
        uYn(t, i, e) {
            let s = this.xot.Eot(t);
            if (s.Lot("icon", self.app.Tk("effect")),
            s.Aot("name", t.Fa()),
            s.Aot("type", wU(".addon-types.effect")),
            s.Aot("author", t.Ote()),
            s.Aot("source", gU(".addon-sources." + t.YMt())),
            "project" === t.YMt() && mU.pls.Eas(t.vR(), null)) {
                const i = t.$te()
                  , e = mU.pls.Jm(t.vR(), null).$te();
                e === i ? s.Aot("version", yU(".version-bundled-same-as-builtin", i, i)) : s.Aot("version", yU(".version-bundled-different-to-builtin", i, e))
            } else
                s.Aot("version", t.$te());
            let n = this.pYn(t, i, e);
            s.Aot("references", this.dYn(n))
        }
        cYn(t, i) {
            return i.filter(i => i.Ja() === t).map(t => t.Fa())
        }
        fYn(t, i) {
            let e = [];
            for (let s of i)
                if (s.Ja().$N())
                    for (let i of s.yus())
                        i.sxt() === t && e.push(s.Fa());
            return e
        }
        pYn(t, i, e) {
            let s = [];
            for (let i of e)
                if (i.Ja().GN())
                    for (let e of i.ycs())
                        e.hne() === t && s.push(i.Fa());
            for (let e of i.wD()) {
                for (let i of e.ycs())
                    if (i.hne() === t) {
                        s.push(bU(".layout-reference", e.Fa()));
                        break
                    }
                for (let i of e.UR())
                    for (let n of i.ycs())
                        if (n.hne() === t) {
                            s.push(bU(".layer-reference", e.Fa(), i.Fa()));
                            break
                        }
            }
            return s
        }
        dYn(t) {
            return t.length > EU ? t.slice(0, EU).join(", ") + "... " + bU(".more-references", t.length - EU) : t.join(", ")
        }
        hKt(t) {
            this.nmt(null, t.clientX, t.clientY)
        }
        Zot(t) {
            this.nmt(t.ght, t.clientX, t.clientY)
        }
        nmt(t, i, e) {
            let s = mU.v(mU.qs.Ek, this.y5t());
            if (mU.p.u("ui.dialogs.viewUsedAddons.context-menu"),
            t) {
                const i = t.Pp();
                if (s.Pk("search", wU("common.find-all-references"), () => this.OD(i)),
                s.Nk(),
                "project" === i.YMt() && mU.lj.Eas(i.Vdt(), i.vR(), null)) {
                    const t = i.$te()
                      , e = mU.lj.Jm(i.Vdt(), i.vR(), null).$te();
                    mU.GBe(t, e) < 0 && (s.Pk("update", wU(".update-to-editor-version"), () => this.mYn(i, t, e)),
                    s.Nk())
                }
            }
            s.Pk("help", wU(".help"), () => this.JOt()),
            s.nF(i, e),
            mU.p.j()
        }
        OD(t) {
            const i = this.pwt;
            this.gwt(),
            self.JA.$A(t, i)
        }
        mYn(t, i, e) {
            this.pwt.vni(t);
            mU.qs.Ys.$s("OK").Qa(yU("ui.dialogs.viewUsedAddons.update-confirmation", t.Fa(), i, e))
        }
        JOt() {
            self.app.s_("", "ViewUsedAddonsHelp")
        }
        VW() {
            this.xot.tC(),
            this.pwt = null
        }
    }
    ;
    mU.qs.HY.ipt.addEventListener("load", () => {
        mU.qs.Ys.opt(MU, CU)
    }
    )
}
{
    const _U = self.t
      , TU = self.lang
      , IU = self.tP
      , PU = _U.ek(import.meta.url)
      , GU = PU.getElementById("textPreviewDialog")
      , AU = _U.tk(PU.URL);
    _U.p.ik(AU + "lang");
    const RU = "TextPreview"
      , kU = new Map([["application/javascript", "javascript"], ["text/javascript", "javascript"], ["application/typescript", "javascript"], ["text/typescript", "javascript"], ["text/css", "css"], ["text/markdown", "markdown"], ["text/html", "html"], ["application/json", "json"], ["text/xml", "xml"], ["image/svg+xml", "xml"]])
      , OU = _U.qs.Jj.wYn = class extends _U.qs.Ys {
        #z = null;
        #V = NaN;
        #W = null;
        #H = "";
        constructor() {
            super(GU),
            this.#z = null,
            this.#W = () => this.#K(),
            this.addEventListener("resize", this.#W),
            this.addEventListener("widthchange", this.#W),
            this.addEventListener("heightchange", this.#W),
            this.y5t().addEventListener("contextmenu", _U.qs.ck)
        }
        Swt() {}
        async Qa(t, i) {
            _U.e0t(t),
            _U.zt(i),
            this.#H = kU.get(i),
            _U.A0t(t.name) && (this.#H = "javascript"),
            _U.x0t(t.name) && (this.#H = "javascript");
            const e = TU(`ui.dialogs.textPreview.${this.#H ?? "other"}`);
            this.Ya(IU("ui.dialogs.textPreview.caption", e));
            const s = super.Qa();
            await _U.fgt._gt();
            let n = await _U.gle(t);
            const r = globalThis.app.r0()
              , h = {
                dropIntoEditor: {
                    enabled: !1
                },
                contextmenu: !1,
                links: !1,
                hover: {
                    enabled: !1
                },
                theme: _U.fgt.mgt(),
                fontSize: r.textEditorFontSize || 12,
                autoIndent: r.textEditorAutoIndent ? "advanced" : "keep",
                wordWrap: r.textEditorEnableWordWrap ? "on" : "off",
                minimap: {
                    enabled: r.textEditorEnableMinimap,
                    scale: r.textEditorMinimapScale
                },
                stickyScroll: {
                    enabled: r.textEditorEnableStickyScrolling
                },
                folding: r.textEditorEnableCodeFolding,
                value: n,
                readOnly: !0
            };
            this.#H && (h.language = this.#H),
            this.#z = globalThis.monaco.editor.create(this.y5t(), h);
            const o = this.#z.getModel()
              , a = /\bhttps?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b(?:\/[-a-zA-Z0-9@:%_+.~#?&/=]*)?/gi;
            n = o.getValue();
            const l = [];
            let u = a.exec(n);
            for (; u; ) {
                const t = u[0]
                  , i = u.index
                  , e = i + t.length
                  , s = o.getPositionAt(i)
                  , r = o.getPositionAt(e);
                l.push({
                    range: new globalThis.monaco.Range(s.lineNumber,s.column,r.lineNumber,r.column),
                    options: {
                        inlineClassName: "link-decoration"
                    }
                }),
                u = a.exec(n)
            }
            return this.#z.deltaDecorations([], l),
            this.#z.onMouseDown(t => {
                const i = t.target.position;
                if (!i)
                    return;
                const e = o.getOffsetAt(i);
                let s = ""
                  , r = a.exec(n);
                for (; r; ) {
                    const t = r.index
                      , i = r.index + r[0].length;
                    if (e >= t && e <= i) {
                        s = r[0];
                        break
                    }
                    r = a.exec(n)
                }
                s && globalThis.open(s, "_blank")
            }
            ),
            globalThis.requestAnimationFrame( () => {
                this.#z && this.#z.layout()
            }
            ),
            s
        }
        VW() {
            this.#z && (this.#z.dispose(),
            this.#z = null),
            this.#H = ""
        }
        #K() {
            _U.Go(this.#V) || (this.#V = globalThis.requestAnimationFrame( () => {
                this.#z && this.#z.layout(),
                this.#V = NaN
            }
            ))
        }
    }
    ;
    _U.qs.HY.ipt.addEventListener("load", () => {
        _U.qs.Ys.opt(RU, OU)
    }
    )
}
{
    const DU = self.t
      , FU = self.lang
      , LU = self.tP
      , BU = DU.ek(import.meta.url)
      , UU = BU.getElementById("addonManagerDialog")
      , NU = DU.tk(BU.URL);
    DU.p.ik(NU + "lang");
    const jU = "AddonManager";
    function $U(t, i) {
        const e = t.trim().split(".").map(t => Number.parseInt(t, 10))
          , s = i.trim().split(".").map(t => Number.parseInt(t, 10));
        for (; e.length < s.length; )
            e.push(0);
        for (; s.length < e.length; )
            s.push(0);
        for (let t = 0, i = e.length; t < i; ++t) {
            const i = e[t] - s[t];
            if (0 !== i)
                return i
        }
        return 0
    }
    let zU = !1;
    const VU = new Map
      , WU = DU.qs.Jj.Fj = class extends DU.qs.Ys {
        constructor() {
            super(UU),
            this.pP = this.dwt("searchInput"),
            this.pP.setAttribute("placeholder", FU("common.search-input-placeholder")),
            this.pP.addEventListener("input", () => this.gYn()),
            this.yYn = this.dwt("showBuiltInCheck"),
            this.yYn.addEventListener("input", () => this.gYn()),
            this.bYn = this.dwt("showUpdatesCheck"),
            this.bYn.addEventListener("input", () => this.gYn()),
            this.vYn = this.dwt("showOnlySdkV1"),
            this.vYn.addEventListener("input", () => this.gYn()),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.SYn = this.dwt("installAddon"),
            this.SYn.onclick = () => this.xYn(),
            this.MYn = this.dwt("updateAll"),
            this.MYn.onclick = () => this.EYn([...VU.values()]),
            this.CYn = this.dwt("installDevAddon"),
            this.CYn.onclick = () => this._Yn(),
            this.CYn.style.display = "none",
            this.xot = DU.v(DU.qs.Jj.Table, this.y5t(), {
                border: !0
            }),
            this.TYn = 0;
            let t = this.xot.Got();
            DU.p.u("ui.dialogs.addonManager"),
            t.kot("icon", self.app.Gk() + 4),
            t.kot("name", 110, FU(".name")),
            t.kot("type", 70, FU(".type")),
            t.kot("version", 100, FU(".version")),
            t.kot("author", 100, FU(".author")),
            t.kot("source", 100, FU(".source")),
            t.Mot("description", FU(".description")),
            DU.p.j();
            let i = DU.v(DU.qs.kmt, self.app.oi("info"))
              , e = this.dwt("restartPendingMessage");
            e.insertBefore(i.hk(), e.firstChild),
            this.xot.addEventListener("rowcontextmenu", t => this.OW(t, t.ght)),
            this.xot.iKt()
        }
        Swt() {
            DU.p.u("ui.dialogs.addonManager"),
            this.lKi.textContent = FU("common.done"),
            this.Ya(FU(".caption")),
            this.dwt("addonManagerHeaderText").textContent = FU(".loading-text"),
            this.dwt("showBuiltInCheckLabel").textContent = FU(".show-built-in"),
            this.dwt("showUpdatesLabel").textContent = FU(".show-updates-only"),
            this.dwt("showOnlySdkV1Label").textContent = FU(".show-only-legacy-addons"),
            this.dwt("restartPendingMessageText").textContent = FU(".restart-pending-message"),
            this.SYn.textContent = FU(".install-new-addon"),
            this.MYn.textContent = FU(".update-all"),
            this.CYn.textContent = FU(".add-dev-addon");
            const t = this.dwt("addonExchangeLink");
            t.textContent = FU(".get-addons"),
            t.onclick = () => self.app.e_(DU.o_.URL.t_, "AddonManager", "GetAddons"),
            DU.p.j()
        }
        Qa(t) {
            this.xot.hk().style.display = "none",
            Promise.all([DU.Di.Kde(), DU.F.Kde()]).then( () => this.oYn()),
            this.IYn(),
            this.pP.value = "",
            this.yYn.checked = !0,
            this.bYn.checked = !1,
            this.vYn.checked = !1;
            const i = super.Qa(t);
            return this.CYn.style.display = self.app.Xj() ? "" : "none",
            localforage.getItem("addon-manager-options").then(t => {
                t && (this.yYn.checked = !!t.showBuiltIn,
                this.bYn.checked = !!t.showUpdatesOnly,
                this.vYn.checked = !!t.showOnlySdkV1,
                this.gYn())
            }
            ).catch(DU.Gv),
            i
        }
        oYn() {
            DU.p.u("ui.dialogs.addonManager"),
            this.xot.hk().style.display = "",
            this.dwt("addonManagerHeaderText").textContent = FU(".header-text");
            const t = [DU.Di.e8s(), ...DU.Di.plugins(null, !0)];
            t.sort(self.Plugin.Ame);
            const i = [...DU.F.Yde(null, !0)];
            i.sort(self.las.Qde);
            const e = [...DU.pls.effects(null, !0)];
            e.sort(self.MQ.Zls);
            const s = [...DU.lj.addons("theme", null)];
            s.sort(self.fUn.Zls);
            const n = [...DU.lj.addons("tour", null)];
            n.sort(self.MUn.Zls);
            const r = [...n, ...s, ...t, ...i, ...e];
            for (const t of r)
                (DU.Ots(t) || "built-in" !== t.YMt()) && this.jKt(t);
            for (const t of r)
                DU.Ots(t) || "built-in" !== t.YMt() || this.jKt(t);
            DU.p.j(),
            DU.qs.CD(this.MYn, "hidden", 0 === VU.size),
            this.gYn()
        }
        jKt(t) {
            if (DU.Ots(t)) {
                const i = this.xot.Eot(t);
                if (i.Lot("icon", globalThis.app.Tk("warning")),
                i.Aot("name", t.QLn),
                i.Aot("type", FU(".addon-types." + t.p$n)),
                i.Aot("source", FU(".addon-sources." + t.source)),
                i.Aot("author", t.Q7s || ""),
                DU.lj.$jn())
                    i.Aot("description", FU(".safe-mode-deactivated"));
                else {
                    let e = (t.version || "") + " (SDK v1)";
                    const s = VU.get(t.p$n + "," + t.QLn)?.tzn;
                    s && (e += `\n[b]${LU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
                    i.Aot("version", new DU.MC(e,{
                        O0: !0
                    })),
                    i.Aot("description", FU(".sdkv1-no-longer-supported"))
                }
                return
            }
            const i = t.Vdt();
            if ("plugin" === i)
                this.aYn(t);
            else if ("behavior" === i)
                this.lYn(t);
            else if ("effect" === i)
                this.uYn(t);
            else if ("theme" === i)
                this.PYn(t);
            else {
                if ("tour" !== i)
                    throw new Error(`unknown addon type '${i}'`);
                this.GYn(t)
            }
        }
        aYn(t) {
            const i = this.xot.Eot(t);
            i.Lot("icon", t.uj()),
            i.Aot("name", t.Fa()),
            i.Aot("type", FU(".addon-types.plugin")),
            i.Aot("author", t.Ote()),
            i.Aot("source", FU(".addon-sources." + t.YMt())),
            i.Aot("description", t.dj());
            let e = t.$te();
            const s = VU.get("plugin," + t.vR())?.tzn;
            s && (e += `\n[b]${LU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Aot("version", new DU.MC(e,{
                O0: !0
            }))
        }
        lYn(t) {
            const i = this.xot.Eot(t);
            i.Lot("icon", t.uj()),
            i.Aot("name", t.Fa()),
            i.Aot("type", FU(".addon-types.behavior")),
            i.Aot("author", t.Ote()),
            i.Aot("source", FU(".addon-sources." + t.YMt())),
            i.Aot("description", t.dj());
            let e = t.$te();
            const s = VU.get("behavior," + t.vR())?.tzn;
            s && (e += `\n[b]${LU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Aot("version", new DU.MC(e,{
                O0: !0
            }))
        }
        uYn(t) {
            const i = this.xot.Eot(t);
            i.Lot("icon", self.app.Tk("effect")),
            i.Aot("name", t.Fa()),
            i.Aot("type", FU(".addon-types.effect")),
            i.Aot("author", t.Ote()),
            i.Aot("source", FU(".addon-sources." + t.YMt())),
            i.Aot("description", t.dj());
            let e = t.$te();
            const s = VU.get("effect," + t.vR())?.tzn;
            s && (e += `\n[b]${LU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Aot("version", new DU.MC(e,{
                O0: !0
            }))
        }
        PYn(t) {
            const i = this.xot.Eot(t);
            i.Lot("icon", t.uj()),
            i.Aot("name", t.Fa()),
            i.Aot("type", FU(".addon-types.theme")),
            i.Aot("author", t.Ote()),
            i.Aot("source", FU(".addon-sources." + t.YMt())),
            i.Aot("description", t.dj());
            let e = t.$te();
            const s = VU.get("theme," + t.vR())?.tzn;
            s && (e += `\n[b]${LU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Aot("version", new DU.MC(e,{
                O0: !0
            }))
        }
        GYn(t) {
            const i = this.xot.Eot(t);
            i.Lot("icon", t.uj()),
            i.Aot("name", t.Fa()),
            i.Aot("type", FU(".addon-types.tour")),
            i.Aot("author", t.Ote()),
            i.Aot("source", FU(".addon-sources." + t.YMt())),
            i.Aot("description", t.dj());
            let e = t.$te();
            const s = VU.get("tour," + t.vR())?.tzn;
            s && (e += `\n[b]${LU("ui.dialogs.addonManager.available-version", s.version)}[/b]`),
            i.Aot("version", new DU.MC(e,{
                O0: !0
            }))
        }
        gYn() {
            const t = this.pP.value.toLowerCase()
              , i = this.yYn.checked
              , e = this.bYn.checked
              , s = this.vYn.checked;
            for (const n of this.xot.rows()) {
                const r = n.Pp();
                let h = ""
                  , o = ""
                  , a = ""
                  , l = ""
                  , u = ""
                  , c = !1
                  , d = 1;
                DU.Ots(r) ? (h = r.QLn,
                o = r.QLn,
                a = r.p$n,
                d = r.m$n) : (h = r.vR(),
                o = r.Fa(),
                a = r.Vdt(),
                l = r.Ote(),
                u = r.dj(),
                c = "built-in" === r.YMt(),
                ("plugin" === r.Vdt() && r instanceof globalThis.ani || "behavior" === r.Vdt() && r instanceof globalThis.lni) && (d = r.kPs()));
                const f = FU("ui.dialogs.addonManager.addon-types." + a);
                n.x_((!c || i) && (!e || VU.has(a + "," + h)) && (!s || !c && 1 === d) && (!t || o.toLowerCase().includes(t) || f.toLowerCase().includes(t) || l.toLowerCase().includes(t) || u.toLowerCase().includes(t)))
            }
        }
        VW() {
            this.xot.tC()
        }
        OW(t, i) {
            if (!i)
                return;
            const e = self.app;
            let s = this.y5t()
              , n = i.Pp();
            DU.p.u("ui.dialogs.addonManager.menu");
            let r = DU.v(DU.qs.Ek, s);
            this.AYn(n, r),
            DU.Ots(n) ? r.Pk("delete", FU(".uninstall"), () => {
                this.RYn(n.p$n, n.QLn, n.source, "").then(t => {
                    t && this.xot.J7t(i)
                }
                )
            }
            ) : ("effect" === n.Vdt() ? r.Pk("help", FU(".effects-help"), () => e.s_("project-primitives/objects/effects", "AddonManager-EffectHelp")) : "tour" === n.Vdt() ? r.Pk("help", FU(".visit-website"), () => e.e_(n.kUn(), "AddonManager-TourHelp")) : r.Pk("help", LU(".help", n.Fa()), () => e.s_(n.NA(), "AddonManager-AddonHelp")),
            "addon" === n.YMt() && (r.Pk("download", FU(".download-c3addon"), () => this.kYn(n)),
            r.Nk()),
            "addon" !== n.YMt() && "dev" !== n.YMt() || r.Pk("delete", FU(".uninstall"), () => {
                this.RYn(n.Vdt(), n.vR(), n.YMt(), n.Fa()).then(t => {
                    t && this.xot.J7t(i)
                }
                )
            }
            )),
            r.nF(t.clientX, t.clientY),
            DU.p.j()
        }
        AYn(t, i) {
            let e, s;
            DU.Ots(t) ? (e = t.QLn,
            s = t.p$n) : (e = t.vR(),
            s = t.Vdt());
            const n = VU.get(s + "," + e);
            if (n) {
                const t = n.tzn;
                i.Pk("update", LU(".update", t.version), () => this.EYn([n])),
                t.Q$n && i.Pk("link", FU(".visit-addon-page"), () => globalThis.app.e_(t.Q$n)),
                i.Nk()
            }
        }
        async xYn() {
            const t = this.y5t()
              , i = new DU.qs.Qyi
              , e = await i.Qa(".c3addon", t, !0);
            null !== e && this.Bj() && DU.qs.Jj.Fj.c2t(e, this)
        }
        static async c2t(t, i, e=!1) {
            const s = i ? i.y5t() : null;
            i && i.OYn(!0);
            let n = !1;
            const r = [];
            for (const i of t)
                try {
                    await DU.lj.$hi(i, null, s, e) && (zU = !0,
                    n = !0,
                    r.push(i))
                } catch (t) {
                    console.error("Error installing addon: ", t);
                    const i = DU.qs.Ys.$s("OK");
                    "min-version" === t.message ? await i.Qa(DU.v(DU.MC, LU("ui.dialogs.addonManager.install-min-version-error-message", DU.Vhi(t.S$n), DU.o_.Lhi), {
                        links: [location.origin + "/" + DU.nDn(t.S$n)]
                    }), s) : "sdkv1-addon" === t.message ? await i.Qa(DU.v(DU.MC, LU("ui.dialogs.addonManager.install-sdkv1-error-message", t.QLn, t.v$n), {
                        links: [DU.o_.URL.oSe + "releases/lts"]
                    }), s) : await i.Qa(FU("ui.dialogs.addonManager.install-error-message"), s),
                    r.push(t)
                }
            if (i && (i.IYn(),
            i.OYn(!1)),
            n && !e) {
                const t = DU.qs.Ys.$s("OK");
                t.Ya(FU("ui.dialogs.addonManager.install-confirmation.title")),
                await t.Qa(FU("ui.dialogs.addonManager.install-confirmation.message"), s)
            }
            return r
        }
        async RYn(t, i, e, s) {
            const n = this.y5t();
            DU.p.u("ui.dialogs.addonManager.uninstall-confirmation");
            const r = DU.qs.Ys.$s("Confirm").Qa({
                caption: FU(".caption"),
                message: LU(".message", s || i),
                jD: FU(".uninstall")
            }, n);
            DU.p.j();
            if (null === await r)
                return !1;
            this.OYn(!0);
            try {
                await DU.lj.x$n(t, i, e),
                zU = !0,
                this.IYn();
                const s = DU.qs.Ys.$s("OK");
                return s.Ya(FU("ui.dialogs.addonManager.uninstall-finished.title")),
                await s.Qa(FU("ui.dialogs.addonManager.uninstall-finished.message"), n),
                !0
            } catch (t) {
                console.error("Error uninstalling addon: ", t);
                const i = DU.qs.Ys.$s("OK");
                return await i.Qa(FU("ui.dialogs.addonManager.uninstall-error-message"), n),
                !1
            } finally {
                this.OYn(!1)
            }
        }
        kYn(t) {
            const i = t.yhi();
            DU._Lt(t.Fa() + ".c3addon", i)
        }
        IYn() {
            zU && this.dwt("restartPendingMessage").removeAttribute("hidden")
        }
        async _Yn() {
            DU.qs.Jj.Fj.qj(this)
        }
        static async qj(t) {
            const i = t ? t.y5t() : null
              , e = DU.qs.Ys.$s("Input");
            DU.p.u("ui.dialogs.addonManager.dev-addon-install");
            const s = e.Qa({
                caption: FU(".caption"),
                message: FU(".message"),
                label: FU(".url-label"),
                c0e: "https://localhost:65432/addon.json",
                spellcheck: !1
            });
            DU.p.j();
            const n = await s;
            if (null !== n)
                try {
                    const e = await DU.Z1t(n);
                    DU.lj.b$n(e),
                    await DU.lj.C$n(n, e, i),
                    zU = !0,
                    t && t.IYn();
                    DU.qs.Ys.$s("OK").Qa(LU("ui.dialogs.addonManager.dev-install-confirmation", e.id))
                } catch (t) {
                    console.error("Error loading addon JSON: ", t);
                    DU.qs.Ys.$s("OK").Qa(FU("ui.dialogs.addonManager.dev-install-failed"))
                }
        }
        OYn(t) {
            t ? this.TYn++ : this.TYn--,
            DU.qs.CD(this.lKi, "disabled", this.TYn > 0)
        }
        gwt() {
            this.TYn > 0 || (localforage.setItem("addon-manager-options", {
                showBuiltIn: this.yYn.checked,
                showUpdatesOnly: this.bYn.checked,
                showOnlySdkV1: this.vYn.checked
            }).catch(DU.Gv),
            super.gwt())
        }
        FP(t) {
            return t.which === DU.kE.IE && document.activeElement === this.pP ? (this.pP.value = "",
            this.gYn(),
            t.preventDefault(),
            void t.stopPropagation()) : super.FP(t)
        }
        static async DYn() {
            await globalThis.app.Lj();
            const t = ["plugin", "behavior", "effect", "theme"]
              , i = [];
            for (const e of t)
                for (const t of DU.lj.w$n(e)) {
                    const s = DU.lj.f$n(e, t).nBn;
                    i.push({
                        p$n: e,
                        QLn: t,
                        version: s.version
                    })
                }
            const e = {
                addons: i.map(t => ({
                    type: t.p$n,
                    id: t.QLn,
                    currentVersion: t.version
                }))
            };
            try {
                const t = await fetch("/checkaddons.json", {
                    method: "POST",
                    body: JSON.stringify(e)
                });
                if (!t.ok)
                    throw new Error(`fetch '${t.url}' response returned ${t.status} ${t.statusText}`);
                const i = await t.json();
                if (!0 !== i.success || "object" != typeof i.data || !Array.isArray(i.data.foundAddons))
                    throw i;
                for (const t of i.data.foundAddons) {
                    const i = t.type;
                    if (!DU.lj.D$n(i))
                        continue;
                    const e = t.id;
                    let s = "";
                    DU.lj.Eas(i, e) && (s = DU.lj.Jm(i, e)?.Fa()),
                    s || (s = t.name || e);
                    const n = DU.lj.f$n(i, e);
                    if (!n)
                        continue;
                    const r = n.nBn.version
                      , h = t.releases.filter(t => "Stable" === t.branch);
                    if (0 === h.length)
                        continue;
                    h.sort( (t, i) => $U(t.version, i.version));
                    const o = h.at(-1);
                    if ($U(r, o.version) >= 0)
                        continue;
                    const a = {
                        version: o.version,
                        J$n: new Date(o.date),
                        Z$n: h.map(t => ({
                            version: t.version,
                            szn: t.bbCodeReleaseNotes
                        })),
                        FYn: o.downloadURL,
                        Q$n: t.url
                    };
                    VU.set(i + "," + e, {
                        p$n: i,
                        QLn: e,
                        izn: s,
                        ezn: r,
                        tzn: a
                    })
                }
                if (VU.size > 0) {
                    const t = DU.p.Ok("ui.dialogs.addonManager.addon-updates-available-notification");
                    DU.qs.Notification.nF("info", t.yD(".title", null, VU.size), t(".message"), {
                        align: "bottom-left",
                        z7t: 1e4,
                        onclick: async () => {
                            DU.qs.Ys.$s("AddonManager").Qa()
                        }
                    })
                }
            } catch (t) {
                (() => {})("Failed to check for addon updates: ", t)
            }
        }
        async EYn(t) {
            const i = DU.p.Ok("ui.dialogs.addonManager")
              , e = DU.qs.Ys.$s("AddonUpdateReview");
            if (null === await e.Qa(t, this.hk()))
                return;
            const s = DU.qs.Ys.$s("Progress");
            let n = 0;
            s.onprogress = () => n,
            s.Qa(i(".downloading-updates")),
            this.OYn(!0);
            try {
                const e = await DU.RPe(t.map(t => DU.Kl(t.tzn.FYn)), (t, i) => n = t / i);
                s.PR(),
                await DU.qs.Jj.Fj.c2t(e, this, !0);
                const r = DU.qs.Ys.$s("OK");
                r.Ya(i(".update-confirmation.title")),
                r.Qa(i(".update-confirmation.message"));
                for (const {p$n: i, QLn: e} of t)
                    VU.delete(i + "," + e);
                DU.qs.CD(this.MYn, "hidden", 0 === VU.size),
                this.gYn()
            } catch (t) {
                s.PR();
                DU.qs.Ys.$s("OK").Qa(i(".update-error-message"))
            } finally {
                this.OYn(!1)
            }
        }
    }
    ;
    DU.qs.HY.ipt.addEventListener("load", () => {
        DU.qs.Ys.opt(jU, WU)
    }
    )
}
{
    const HU = self.t
      , KU = self.G1t
      , qU = self.lang
      , XU = HU.ek(import.meta.url)
      , YU = XU.getElementById("settingsDialog")
      , JU = HU.tk(XU.URL);
    HU.p.ik(JU + "lang");
    const ZU = "Settings"
      , QU = HU.qs.Jj.LYn = class extends HU.qs.Ys {
        constructor() {
            super(YU),
            this.lKi = this.dwt("okButton"),
            this.lKi.onclick = () => this.gwt(),
            this.BYn = this.dwt("resetUserInterface"),
            this.BYn.onclick = () => this.UYn(),
            this.NYn = this.dwt("enableMultiMonitor"),
            this.NYn.onclick = () => this.jYn(),
            this.$Yn = this.dwt("enableMultiMonitorWrap"),
            this.zYn = this.dwt("clearRecentProjects"),
            this.zYn.onclick = () => this.zYn.setAttribute("clearRecentProjects", ""),
            this.VYn = this.dwt("downloadBrowserSaves"),
            this.VYn.onclick = () => this.WYn(),
            this.LKs = this.dwt("languageSetting"),
            this.HYn = this.dwt("uiMode"),
            this.KYn = this.dwt("useSimplifiedMode"),
            this.qYn = this.dwt("enableExampleBrowser"),
            this.XYn = this.dwt("theme"),
            this.YYn = this.dwt("useDefaultIconColor"),
            this.JYn = this.dwt("iconColor"),
            this.ZYn = this.dwt("defaultSaveLocation"),
            this.QYn = this.dwt("enableAutosave"),
            this.tJn = this.dwt("autosaveDuration"),
            this.iJn = this.dwt("autosaveLocation"),
            this.iJn.addEventListener("change", () => this.eJn()),
            this.sJn = this.dwt("localBackupFolderSection"),
            this.nJn = this.dwt("localBackupFolderStatus"),
            this.rJn = this.dwt("localBackupFolderChoose"),
            this.rJn.addEventListener("click", () => this.hJn()),
            this.oJn = this.dwt("textEditorFontSize"),
            this.aJn = this.dwt("textEditorAutoIndent"),
            this.lJn = this.dwt("textEditorWordWrap"),
            this.uJn = this.dwt("textEditorShowMinimap"),
            this.cJn = this.dwt("textEditorMinimapScale"),
            this.dJn = this.dwt("textEditorStickyScrolling"),
            this.fJn = this.dwt("textEditorEnableCodeFolding"),
            this.pJn = this.dwt("enableUIAnims"),
            this.mJn = this.dwt("enableUIEffects"),
            this.wJn = this.dwt("enableNotifications"),
            this.gJn = this.dwt("showTakeBreakReminders"),
            this.yJn = this.dwt("zoomMouseWheelOnly"),
            this.bJn = this.dwt("useFakeClipboard"),
            this.vJn = this.dwt("inProgressLanguages"),
            this.SJn = this.dwt("experimentalFeatures"),
            this.xJn = this.dwt("enableDeveloperMode"),
            this.MJn = this.dwt("cacheCloudMetadata"),
            this.EJn = this.dwt("limitToWebGL1"),
            this.CJn = this.dwt("enableWebGPUInEditor"),
            this._Jn = this.dwt("showStartPage"),
            this.TJn = this.dwt("autoHideStartPage"),
            this.IJn = this.dwt("showStartPageMessageBanners"),
            this.PJn = this.dwt("hideAddActionRows"),
            this.GJn = this.dwt("translateExpressions"),
            this.AJn = this.dwt("gpuPowerPreference"),
            this.RJn = this.dwt("previewMode"),
            this.kJn = this.dwt("updateChannel"),
            this.OJn = this.dwt("enableAddonUpdateChecks"),
            this.DJn = this.dwt("defaultProjectAuthor"),
            this.FJn = this.dwt("defaultProjectEmail"),
            this.LJn = this.dwt("defaultProjectWebsite"),
            this.BJn = this.dwt("defaultAnimationSpeed"),
            this.UJn = () => this.NJn(),
            this.jJn = () => this.$Jn(),
            this.zJn = () => this.VJn(),
            this.YYn.onclick = () => this.WJn(),
            this.QYn.onclick = () => this.HJn(),
            this.KJn = "",
            this.qJn = 0,
            this.v6i().addEventListener("pointerdown", () => this.XJn()),
            globalThis.app.Rj() || (this.dwt("enableAddonUpdateChecksWrap").style.display = "none"),
            HU.Vl && (this.YJn("synthetic-rockdots", " (synthetic-rockdots)"),
            this.YJn("synthetic-leet", "|_337 (synthetic-leet)"),
            this.YJn("synthetic-uppercase", "UPPERCASE (synthetic-uppercase)"),
            this.YJn("synthetic-lowercase", "lowercase (synthetic-lowercase)"),
            this.YJn("synthetic-repeat-2", "rreeppeeaatt22 (synthetic-repeat-2)"),
            this.YJn("synthetic-repeat-3", "rrreeepppeeeaaattt333 (synthetic-repeat-3)"),
            this.YJn("synthetic-repeat-4", "rrrreeeeppppeeeeaaaatttt4444 (synthetic-repeat-4)")),
            (HU.Vl || self.app.r0().showInProgressLanguages) && (this.YJn("id-ID", "Bahasa Indonesia [incomplete]", "Indonesian"),
            this.YJn("bs-BA", "Bosanski [incomplete]", "Bosnian"),
            this.YJn("pl-PL", "Polski [incomplete]", "Polish"),
            this.YJn("ro-RO", "Romn [incomplete]", "Romanian"),
            this.YJn("ko-KR", " [incomplete]", "Korean"),
            this.YJn("th-TH", " [incomplete]", "Thai"))
        }
        YJn(t, i, e) {
            const s = document.createElement("option");
            s.value = t,
            s.text = i,
            e && s.setAttribute("title", e),
            this.LKs.add(s)
        }
        Swt() {
            const t = self.app;
            HU.p.u("ui.dialogs.settings"),
            this.Ya(qU(".caption")),
            this.lKi.textContent = qU(".close");
            const i = this.dwt("helpLink");
            i.textContent = qU("common.help"),
            i.onclick = () => t.s_("interface/dialogs/settings", "SettingsDialog"),
            this.dwt("settingsUIHeader").textContent = qU(".user-interface.header"),
            HU.p.u(".editor-settings"),
            this.dwt("languageLabel").textContent = qU(".language"),
            this.dwt("uiModeLabel").textContent = qU(".ui-mode.label");
            for (let t = 0, i = this.HYn.options.length; t < i; ++t) {
                const i = this.HYn.options[t];
                i.textContent = qU(".ui-mode." + i.value)
            }
            this.dwt("useSimplifiedModeLabel").textContent = qU(".simplified-mode"),
            this.dwt("enableExampleBrowserLabel").textContent = qU(".enable-example-browser"),
            this.dwt("themeLabel").textContent = qU(".theme.label");
            const e = document.createElement("option");
            e.value = "",
            e.textContent = qU(".theme.default"),
            this.XYn.add(e);
            const s = [...HU.lj.addons("theme")].sort(self.fUn.Zls);
            for (const t of s) {
                const i = document.createElement("option");
                i.value = t.vR(),
                i.textContent = t.Fa(),
                this.XYn.add(i)
            }
            this.NYn.textContent = qU(".enable-multi-monitor-features"),
            this.BYn.textContent = qU(".reset-user-interface.label"),
            this.zYn.textContent = qU(".clear-recent-projects"),
            this.VYn.textContent = qU(".download-browser-saves"),
            this.dwt("useDefaultIconColorLabel").textContent = qU(".use-default-icon-color"),
            this.dwt("iconColorLabel").textContent = qU(".icon-color-label"),
            this.dwt("enableUIAnimsLabel").textContent = qU(".enable-ui-animations"),
            this.dwt("enableUIEffectsLabel").textContent = qU(".enable-ui-effects"),
            this.dwt("enableNotificationsLabel").textContent = qU(".enable-notifications"),
            this.dwt("showTakeBreakRemindersLabel").textContent = qU(".show-take-a-break-reminder"),
            this.dwt("zoomMouseWheelOnlyLabel").textContent = qU(".zoom-mouse-wheel-only"),
            this.dwt("useFakeClipboardLabel").textContent = qU(".use-in-app-clipboard"),
            this.dwt("enableDeveloperModeLabel").textContent = qU(".enable-developer-mode"),
            this.dwt("cacheCloudMetadataLabel").textContent = qU(".cache-cloud-meta"),
            this.dwt("limitToWebGL1Label").textContent = qU(".limit-to-webgl1"),
            HU.p.u(".gpu-power-preference"),
            this.dwt("gpuPowerPreferenceLabel").textContent = qU(".label");
            for (let t = 0, i = this.AJn.options.length; t < i; ++t) {
                const i = this.AJn.options[t];
                i.textContent = qU("." + i.value)
            }
            HU.p.j(),
            HU.p.u(".enable-webgpu-in-editor"),
            this.dwt("enableWebGPUInEditorLabel").textContent = qU(".label");
            for (let t = 0, i = this.CJn.options.length; t < i; ++t) {
                const i = this.CJn.options[t];
                i.textContent = qU("." + i.value)
            }
            if (HU.p.j(),
            HU.p.j(),
            HU.p.u(".text-editor-settings"),
            this.dwt("settingsTextEditorHeader").textContent = qU(".header"),
            this.dwt("textEditorFontSizeLabel").textContent = qU(".font-size"),
            this.dwt("textEditorAutoIndentLabel").textContent = qU(".auto-indent"),
            this.dwt("textEditorWordWrapLabel").textContent = qU(".word-wrap"),
            this.dwt("textEditorShowMinimapLabel").textContent = qU(".show-minimap"),
            this.dwt("textEditorStickyScrollingLabel").textContent = qU(".use-sticky-scrolling"),
            this.dwt("textEditorEnableCodeFoldingLabel").textContent = qU(".enable-code-folding"),
            HU.p.u(".minimap-scale"),
            this.dwt("textEditorMinimapScaleLabel").textContent = qU(".label"),
            this.cJn.item(0).textContent = qU(".1x"),
            this.cJn.item(1).textContent = qU(".2x"),
            this.cJn.item(2).textContent = qU(".3x"),
            HU.p.j(),
            HU.p.j(),
            HU.p.u(".backup-settings"),
            this.dwt("settingsSaveHeader").textContent = qU(".header"),
            HU.p.u(".default-save-location"),
            this.dwt("defaultSaveLocationLabel").textContent = qU(".label"),
            this.ZYn.item(0).textContent = qU(".cloud"),
            this.ZYn.item(1).textContent = qU(".local-browser"),
            this.ZYn.item(2).textContent = qU(".download-a-copy"),
            HU.zk.Lk) {
                const t = document.createElement("option");
                t.value = "save-as",
                t.textContent = qU(".save-as"),
                this.ZYn.add(t)
            }
            HU.p.j(),
            this.dwt("enableAutosaveLabel").textContent = qU(".autosave"),
            this.dwt("autosaveDurationLabel").textContent = qU(".autosave-duration"),
            this.dwt("autosaveLocationLabel").textContent = qU(".autosave-location"),
            this.iJn.item(0).textContent = qU(".locations.browser"),
            this.iJn.item(4).textContent = qU(".locations.match"),
            this.iJn.item(5).textContent = qU(".locations.local-folder"),
            HU.zk.Lk || (this.iJn.item(5).style.display = "none"),
            HU.p.u(".local-backup-folder"),
            this.dwt("localBackupFolderLabel").textContent = qU(".label"),
            this.rJn.textContent = qU(".choose"),
            HU.p.j(),
            HU.p.j(),
            HU.p.u(".default-properties-settings"),
            this.dwt("settingsDefaultPropsHeader").textContent = qU(".header"),
            this.dwt("defaultProjectAuthorLabel").textContent = qU(".default-project-author"),
            this.dwt("defaultProjectEmailLabel").textContent = qU(".default-project-email"),
            this.dwt("defaultProjectWebsiteLabel").textContent = qU(".default-project-website"),
            this.dwt("defaultAnimationSpeedLabel").textContent = qU(".default-animation-speed"),
            HU.p.j(),
            HU.p.u("ui.bars.properties.project"),
            this.FJn.placeholder = qU(".email.placeholder"),
            this.LJn.placeholder = qU(".website.placeholder"),
            HU.p.j(),
            HU.p.u(".update-settings"),
            this.dwt("settingsUpdatesHeader").textContent = qU(".header"),
            this.dwt("updatesDescription").textContent = qU(".beta-description"),
            this.dwt("updateChannelLabel").textContent = qU(".notify-updates-label"),
            this.kJn.item(0).textContent = qU(".stable-releases"),
            this.kJn.item(1).textContent = qU(".beta-releases"),
            this.kJn.item(2).textContent = qU(".disable-update-notifications"),
            this.dwt("enableAddonUpdateChecksLabel").textContent = qU(".check-for-addon-updates"),
            HU.p.j(),
            HU.p.u(".start-page-settings"),
            this.dwt("startPageHeader").textContent = qU(".header"),
            this.dwt("showStartPageLabel").textContent = qU(".show-start-page"),
            this.dwt("autoHideStartPageLabel").textContent = qU(".auto-hide-start-page"),
            this.dwt("showStartPageMessageBannersLabel").textContent = qU(".show-start-page-message-banners"),
            HU.p.j(),
            HU.p.u(".event-sheet-settings"),
            this.dwt("eventSheetHeader").textContent = qU(".header"),
            this.dwt("hideAddActionRowsLabel").textContent = qU(".hide-add-action-rows"),
            this.dwt("translateExpressionsLabel").textContent = qU(".translate-expressions"),
            HU.p.j(),
            HU.p.u(".preview-settings"),
            this.dwt("settingsPreviewHeader").textContent = qU(".header"),
            this.dwt("previewModeLabel").textContent = qU(".preview-with.label");
            for (let t = 0, i = this.RJn.options.length; t < i; ++t) {
                const i = this.RJn.options[t];
                i.textContent = qU(".preview-with." + i.value)
            }
            HU.p.j(),
            HU.p.u(".advanced-settings"),
            this.dwt("settingsAdvancedHeader").textContent = qU(".header"),
            this.dwt("inProgressLanguagesLabel").textContent = qU(".show-in-progress-languages"),
            this.dwt("experimentalFeaturesLabel").textContent = qU(".enable-experimental-features"),
            HU.p.j(),
            HU.p.j(),
            t.Hk().then(t => {
                t || (this.ZYn.item(1).style.display = "none",
                this.iJn.item(0).style.display = "none",
                this.VYn.style.display = "none")
            }
            )
        }
        Qa(t, i) {
            const e = super.Qa(t)
              , s = self.app
              , n = s.r0();
            return this.LKs.value = n.language,
            this.HYn.value = n.uiMode,
            this.KYn.checked = n.useSimplifiedMode,
            this.qYn.checked = n.enableExampleBrowser,
            this.XYn.value = n.theme,
            this.XYn.value !== n.theme && (this.XYn.value = "",
            n.theme = ""),
            this.BYn.disabled = !1,
            this.$Yn.style.display = "none",
            this.JJn(),
            this.YYn.checked = n.useDefaultIconColor,
            this.JYn.value = n.iconColor,
            this.ZYn.value = n.defaultSaveLocation,
            this.QYn.checked = n.autoSave,
            this.oJn.value = n.textEditorFontSize,
            this.aJn.checked = n.textEditorAutoIndent,
            this.lJn.checked = n.textEditorEnableWordWrap,
            this.uJn.checked = n.textEditorEnableMinimap,
            this.uJn.addEventListener("input", this.zJn),
            this.cJn.value = n.textEditorMinimapScale + "x",
            this.dJn.checked = n.textEditorEnableStickyScrolling,
            this.fJn.checked = n.textEditorEnableCodeFolding,
            this.VJn(),
            this.tJn.value = n.autosaveDuration,
            this.iJn.value = n.autosaveLocation,
            this.pJn.checked = n.enableUIAnimations,
            this.mJn.checked = n.enableUIEffects,
            this.wJn.checked = n.enableNotifications,
            this.gJn.checked = n.showTakeBreakReminders,
            this.yJn.checked = n.zoomMouseWheelOnly,
            this.bJn.checked = n.useFakeClipboard,
            this.vJn.checked = n.showInProgressLanguages,
            this.SJn.checked = n.experimentalFeatures,
            this.xJn.checked = n.developerMode,
            this._Jn.checked = n.showStartPageOnStartup,
            this.TJn.checked = n.autoHideStartPage,
            this.IJn.checked = n.showStartPageMessageBanners,
            this.PJn.checked = n.hideAddActionRows,
            this.GJn.checked = n.translateExpressions,
            this.AJn.value = n.gpuPowerPreference,
            this.RJn.value = n.previewMode,
            this.kJn.value = n.updateChannel,
            this.OJn.checked = n.checkForAddonUpdates,
            this.MJn.checked = n.cloudCache,
            this.EJn.checked = n.limitToWebGL1,
            this.CJn.value = n.enableWebGPUInEditor,
            this.DJn.value = n.defaultProjectAuthor,
            this.FJn.value = n.defaultProjectEmail,
            this.LJn.value = n.defaultProjectWebsite,
            this.BJn.value = n.defaultAnimationSpeed,
            s.k_() && (this.IJn.checked = !0,
            this.IJn.disabled = !0),
            this.JYn.addEventListener("change", this.UJn),
            this.mJn.addEventListener("change", this.jJn),
            this.WJn(),
            this.KJn = s.B6e(),
            this.qJn = 0,
            s.Xj() || (this.dwt("developerModeWrap").style.display = "none"),
            this.HJn(),
            this.ZJn(),
            "backup" === i && (this.dwt("settingsSaveHeader").scrollIntoView(!0),
            this.QYn.focus()),
            e
        }
        Oue() {
            const t = self.app
              , i = t.r0()
              , e = i.uiMode !== this.HYn.value || i.theme !== this.XYn.value
              , s = this.zYn.hasAttribute("clearRecentProjects");
            this.zYn.removeAttribute("clearRecentProjects");
            const n = this.LKs.value || i.language
              , r = e || i.language !== n || i.developerMode !== !!this.xJn.checked || i.gpuPowerPreference !== this.AJn.value || i.previewMode !== this.RJn.value || i.showInProgressLanguages !== this.vJn.checked || i.translateExpressions !== !!this.GJn.checked || i.limitToWebGL1 !== !!this.EJn.checked || i.enableWebGPUInEditor !== this.CJn.value;
            return i.language = n,
            i.uiMode = this.HYn.value,
            i.useSimplifiedMode = !!this.KYn.checked,
            i.enableExampleBrowser = !!this.qYn.checked,
            i.theme = this.XYn.value,
            i.useDefaultIconColor = !!this.YYn.checked,
            i.iconColor = this.JYn.value,
            i.defaultSaveLocation = this.ZYn.value,
            i.autoSave = !!this.QYn.checked,
            i.autosaveDuration = HU.Ne(+this.tJn.value, 1, 60),
            i.textEditorFontSize = HU.Ne(this.oJn.value, 6, 100),
            i.textEditorAutoIndent = !!this.aJn.checked,
            i.textEditorEnableWordWrap = !!this.lJn.checked,
            i.textEditorEnableMinimap = !!this.uJn.checked,
            i.textEditorMinimapScale = Number.parseInt(this.cJn.value, 10),
            i.textEditorEnableStickyScrolling = !!this.dJn.checked,
            i.textEditorEnableCodeFolding = !!this.fJn.checked,
            i.autosaveLocation = this.iJn.value,
            i.enableUIAnimations = !!this.pJn.checked,
            i.enableUIEffects = !!this.mJn.checked,
            i.enableNotifications = !!this.wJn.checked,
            i.showTakeBreakReminders = !!this.gJn.checked,
            i.zoomMouseWheelOnly = !!this.yJn.checked,
            i.useFakeClipboard = !!this.bJn.checked,
            i.showInProgressLanguages = !!this.vJn.checked,
            i.experimentalFeatures = !!this.SJn.checked,
            i.developerMode = !!this.xJn.checked,
            i.showStartPageOnStartup = !!this._Jn.checked,
            i.autoHideStartPage = !!this.TJn.checked,
            i.showStartPageMessageBanners = !!this.IJn.checked,
            i.hideAddActionRows = !!this.PJn.checked,
            i.translateExpressions = !!this.GJn.checked,
            i.gpuPowerPreference = this.AJn.value,
            i.previewMode = this.RJn.value,
            i.updateChannel = this.kJn.value,
            i.checkForAddonUpdates = !!this.OJn.checked,
            i.cloudCache = !!this.MJn.checked,
            i.limitToWebGL1 = !!this.EJn.checked,
            i.enableWebGPUInEditor = this.CJn.value,
            i.defaultProjectAuthor = this.DJn.value,
            i.defaultProjectEmail = this.FJn.value,
            i.defaultProjectWebsite = this.LJn.value,
            i.defaultAnimationSpeed = HU.Ne(+this.BJn.value, 0, 60),
            this.KJn !== t.B6e() && this.QJn(),
            e && t.tZn(),
            s && self.kk.tC(),
            t.X6i(),
            r
        }
        async JJn() {
            if (HU.qs.Lqe())
                try {
                    "prompt" === (await navigator.permissions.query({
                        name: "window-management"
                    })).state && (this.$Yn.style.display = "")
                } catch (t) {
                    (() => {})("Unable to query 'window-management' permission state: ", t)
                }
        }
        async jYn() {
            await HU.qs.Bqe();
            try {
                "prompt" !== (await navigator.permissions.query({
                    name: "window-management"
                })).state && (this.$Yn.style.display = "none")
            } catch (t) {
                (() => {})("Unable to query 'window-management' permission state: ", t)
            }
        }
        UYn() {
            this.BYn.disabled = !0,
            globalThis.app.tZn();
            HU.qs.Ys.$s("OK").Qa(qU("ui.dialogs.settings.editor-settings.reset-user-interface.confirmation-message"))
        }
        async iZn() {
            const t = new KU("C3_localFiles")
              , i = await t.keys()
              , e = new Map;
            for (const s of i)
                try {
                    const i = await t.get(s)
                      , n = await HU.cQ(i);
                    e.set(s, n)
                } catch (t) {
                    (() => {})("Unable to read blob " + s + ", skipping")
                }
            const s = new KU("localforage")
              , n = await s.get("C3_localMeta");
            return e.set("metadata.json", new Blob([JSON.stringify(n)])),
            e
        }
        async eZn() {
            const t = new HU.FRt
              , i = HU.qs.Ys.$s("Progress");
            i.onprogress = () => {
                let i = t._Pe()
                  , e = t.xPe();
                return 0 === e ? null : i / e
            }
            ,
            i.Qa();
            try {
                const i = await this.iZn();
                return await t.yLt(i)
            } catch (t) {
                throw t
            } finally {
                i.PR()
            }
        }
        async WYn() {
            try {
                const t = await this.eZn()
                  , i = new Date
                  , e = `${i.getDate()}-${i.getMonth() + 1}-${i.getFullYear()}T${i.getHours()}-${i.getMinutes()}-${i.getSeconds()}`;
                await HU._Lt("browser_saves_" + e + ".zip", t)
            } catch (t) {
                console.error("Error downloading browser saves: ", t);
                HU.qs.Ys.$s("OK").Qa(qU("ui.dialogs.settings.editor-settings.download-browser-saves-failed"))
            }
        }
        sZn() {
            if (self.app.r0().useSimplifiedMode) {
                return HU.qs.Ys.$s("OK").Qa(qU("ui.dialogs.settings.simplified-mode-notification"))
            }
            return Promise.resolve()
        }
        nZn() {
            if (self.app.r0().showInProgressLanguages) {
                return HU.qs.Ys.$s("OK").Qa(qU("ui.dialogs.settings.in-progress-languages-notification"))
            }
            return Promise.resolve()
        }
        gwt() {
            const t = this.Oue();
            (async () => {
                if (await this.sZn(),
                await this.nZn(),
                this.rZn() && !await this.hZn()) {
                    const t = HU.qs.Ys.$s("OK");
                    return void await t.Qa(qU("ui.dialogs.settings.backup-settings.local-backup-folder.need-to-pick-folder"), this.hk())
                }
                if (t) {
                    const t = HU.qs.Ys.$s("OK");
                    t.Ya(qU("ui.dialogs.settings.restart-notification.caption")),
                    await t.Qa(qU("ui.dialogs.settings.restart-notification.message"), this.hk())
                }
                this.PR(),
                self.app.Xpn("settingschange")
            }
            )()
        }
        tWt() {
            this.gwt()
        }
        VW() {
            this.uJn.removeEventListener("input", this.zJn),
            this.JYn.removeEventListener("change", this.UJn),
            this.mJn.removeEventListener("change", this.jJn)
        }
        WJn() {
            HU.qs.CD(this.JYn, "disabled", this.YYn.checked),
            HU.qs.CD(this.dwt("iconColorLabel"), "disabled", this.YYn.checked)
        }
        HJn() {
            const t = !this.QYn.checked;
            HU.qs.CD(this.tJn, "disabled", t),
            HU.qs.CD(this.iJn, "disabled", t),
            HU.qs.CD(this.dwt("autosaveLocationLabel"), "disabled", t),
            HU.qs.CD(this.dwt("autosaveDurationLabel"), "disabled", t),
            this.eJn()
        }
        VJn() {
            HU.qs.CD(this.cJn, "disabled", !this.uJn.checked)
        }
        rZn() {
            return this.QYn.checked && HU.zk.Lk && ("MATCH" === this.iJn.value || "WEBFS FOLDER" === this.iJn.value)
        }
        eJn() {
            this.sJn.style.display = this.rZn() ? "" : "none"
        }
        async hZn() {
            try {
                return await localforage.getItem("local-backup-folder")
            } catch (t) {
                return (() => {})("Error loading backup folder handle: ", t),
                null
            }
        }
        async ZJn() {
            if (!HU.zk.Lk)
                return;
            const t = await this.hZn();
            this.nJn.textContent = t ? t.name : qU("ui.dialogs.settings.backup-settings.local-backup-folder.none-chosen")
        }
        async hJn() {
            self.assert(HU.zk.Lk, "WebFS not supported");
            let t = null;
            try {
                t = await window.showDirectoryPicker({
                    id: "local-backup-folder",
                    mode: "readwrite"
                })
            } catch (t) {
                return
            }
            if (t)
                try {
                    await localforage.setItem("local-backup-folder", t),
                    this.nJn.textContent = t.name
                } catch (t) {
                    (() => {})("Unable to save local backup folder: ", t)
                }
        }
        NJn() {
            self.app.r0().iconColor = this.JYn.value
        }
        async QJn() {
            const t = HU.qs.oX.fXe();
            self.app.Xpn("settingschange"),
            await t
        }
        $Jn() {
            self.app.r0().enableUIEffects = !!this.mJn.checked,
            self.app.Jpn()
        }
        XJn() {
            if (this.qJn++,
            this.qJn >= 10 && self.app.Rj()) {
                HU.qs.Ys.$s("Confirm").Qa({
                    caption: qU("ui.dialogs.settings.developer-mode-confirmation.caption"),
                    message: qU("ui.dialogs.settings.developer-mode-confirmation.message"),
                    jD: qU("common.ok"),
                    vD: qU("common.cancel")
                }).then(t => {
                    null !== t ? this.dwt("developerModeWrap").style.display = "" : this.qJn = 0
                }
                )
            }
        }
    }
    ;
    HU.qs.HY.ipt.addEventListener("load", () => {
        HU.qs.Ys.opt(ZU, QU)
    }
    )
}
{
    const tN = self.t
      , iN = new Map
      , eN = new Map
      , sN = new Map;
    window.eP = class extends tN.Me {
        constructor(t, i, e, s, n, r=!0, h=void 0) {
            tN.U(t, tN.qs.fA),
            tN.zt(i),
            tN.zt(e),
            tN.zt(s),
            tN.rAe(n, "#document"),
            super();
            const o = self.app;
            if (this.oZn = s,
            this.lct = !1,
            this.aZn = !1,
            this.lZn = !!r,
            this.n6t = () => {
                this.lct = !0,
                this.he()
            }
            ,
            this.nP = t.fG(i, self.lang(e), this.oZn, h),
            this.nP.addEventListener("remove", this.n6t),
            this.x_(!1),
            this.lZn || this.nP.v2e(),
            this.Xbi = this.PH(),
            this.lZn && o.bk(s, this, n),
            iN.has(s))
                throw new Error(`Component already exists with name ${s}`);
            this.lZn && (iN.set(s, this),
            o.uZn(this.oZn, this)),
            this.l6t = t => this.c6t(t),
            this.f6t = t => this.p6t(t),
            o.addEventListener("next-tab", this.l6t),
            o.addEventListener("previous-tab", this.f6t)
        }
        he() {
            const t = self.app;
            this.nP.removeEventListener("remove", this.n6t),
            this.n6t = null,
            t.removeEventListener("next-tab", this.l6t),
            this.l6t = null,
            t.removeEventListener("previous-tab", this.f6t),
            this.f6t = null,
            this.lZn && (t.Wpn(this.oZn),
            iN.delete(this.oZn)),
            this.nP = null,
            this.oZn = null,
            this.Xbi = null,
            this.aZn = !0,
            tN.he(this)
        }
        gE(t) {
            tN.E4()
        }
        Fa() {
            return this.oZn
        }
        dH() {
            return this.nP
        }
        sKt() {
            return this.nP.hk()
        }
        mP() {
            return this.nP.mP()
        }
        x_(t) {
            return this.nP.x_(t)
        }
        __() {
            return this.nP && (this.nP.__() || this.nP.eX())
        }
        NF() {
            return this.lct
        }
        b_() {
            return this.aZn
        }
        g_() {
            this.lZn && self.app.uZn(this.oZn, null),
            this.aZn || this.nP.g_()
        }
        PH() {
            const t = this.nP.mP();
            return t ? (this.Xbi = t.ownerDocument,
            this.Xbi) : this.Xbi
        }
        jW() {
            return this.PH().defaultView
        }
        async dUt(t=!0) {
            self.app.pRt() || await self.app.Lj(t)
        }
        async GBt(t) {
            return await this.dUt(),
            tN.qs.Ys.$s(t)
        }
        async cZn(t, i) {
            return (await this.GBt(t)).Ej(i)
        }
        async TBt(t, i) {
            return (await this.GBt(t)).Qa(i)
        }
        c6t(t) {
            if (!this.nP.Yct())
                return;
            if (!this.nP.eX())
                return;
            let i = this.nP.sX().Sk();
            if (!i)
                return;
            let e = i.hX()
              , s = i.K6t(e) + 1;
            s >= i.Q6t() || i.X6t(s)
        }
        p6t(t) {
            if (!this.nP.Yct())
                return;
            if (!this.nP.eX())
                return;
            let i = this.nP.sX().Sk();
            if (!i)
                return;
            let e = i.hX()
              , s = i.K6t(e) - 1;
            s < 0 || i.X6t(s)
        }
        Tqt(t) {
            tN.E4()
        }
        Sqt(t) {
            tN.E4()
        }
        hqt() {
            const t = this.nP.uWt();
            t && this.Tqt(t)
        }
        lqt(t) {
            let i = this.nP.uWt();
            i || (i = {}),
            i = this.Sqt(i, t),
            this.nP.Y4i(i)
        }
        static dZn(t) {
            if (tN.doe(t))
                return iN.get(t);
            if (tN.XOt(t)) {
                const i = sN.get(t);
                return iN.get(i)
            }
            if (tN.$l(t, tN.qs.fA.W6t))
                for (const [i,e] of iN)
                    if (e.dH() === t)
                        return e
        }
        static bH(t, i) {
            if (eN.has(t))
                throw new Error(`Component constructor already exists with name ${t}`);
            eN.set(t, i),
            sN.set(i, t)
        }
        static k1e(t, i=!1) {
            const e = eN.get(t)
              , s = iN.get(t);
            return s || (e ? e.y_(i) : null)
        }
    }
}
{
    const nN = self.t
      , rN = self.assert
      , hN = self.lang
      , oN = self.tG
      , aN = self.iG
      , lN = self.tP
      , uN = 2e3;
    function cN(t) {
        return t.map(t => String.fromCharCode(t)).join("")
    }
    const dN = {}.toString().substr(4, 1);
    let fN = !1;
    const pN = 6e4
      , mN = [["de-DE", "de"], ["en-US", "en"], ["fr-FR", "fr"], ["hr-HR", "hr"], ["hu-HU", "hu"], ["ru-RU", "ru"], ["cs-CZ", "cs"], ["es-ES", "es"], ["pt-BR", "pt"], ["nl-NL", "nl"], ["it-IT", "it"], ["sv-SE", "sv"], ["tr-TR", "tr"], ["uk-UA", "uk"], ["zh-CN", ""], ["zh-TW", ""]]
      , wN = new Set([])
      , gN = [["be-BY", "be", "Belarusian"], ["bn-IN", "bn", "Bengali"], ["bs-BA", "bs", "Bosnian"], ["da-DK", "da", "Danish"], ["fil-PH", "fil", "Filipino"], ["el-GR", "el", "Greek"], ["hi-IN", "hi", "Hindi"], ["id-ID", "id", "Indonesian"], ["ja-JP", "ja", "Japanese"], ["ko-KR", "ko", "Korean"], ["ms-MY", "ms", "Malay"], ["pa-IN", "pa", "Punjabi"], ["pl-PL", "pl", "Polish"], ["ro-RO", "ro", "Romanian"], ["sr-RS", "sr", "Serbian"], ["sh", "sh", "Serbo-Croatian"], ["sl-SI", "sl", "Slovenian"], ["th-TH", "th", "Thai"], ["vi-VN", "vi", "Vietnamese"]]
      , yN = {
        isZipFormat: !0,
        toLayoutView: !0
    }
      , bN = {
        duplicate: !1,
        Zhi: !1,
        fZn: !1,
        fileHandle: null,
        h2t: "(unknown)",
        L0t: !0
    }
      , vN = {
        showNotification: !0,
        pZn: !1,
        xis: !1
    }
      , SN = cN([102, 114]) + dN + dN;
    let xN = null
      , MN = "games"
      , EN = null
      , CN = "personal"
      , _N = ""
      , TN = !1
      , IN = -1
      , PN = !1
      , GN = ""
      , AN = -1
      , RN = !1
      , kN = !1
      , ON = 25
      , DN = 2
      , FN = 2
      , LN = 1
      , BN = !1
      , UN = null;
    const NN = 6048e5
      , jN = 9e5;
    function $N() {
        EN.mZn()
    }
    function zN(t) {
        return Math.floor(Math.random() * t)
    }
    const VN = new Set(["free", "personal", "educational", "gamejam", "startupbusiness", "business"]);
    async function WN(t) {
        if (!t.verificationHash || !t.verificationDate)
            return !1;
        const i = t.verificationHash
          , e = t.verificationDate.toUpperCase().trim()
          , s = t.type.toUpperCase().trim()
          , n = Date.parse(e)
          , r = Date.now()
          , h = Math.floor(3024e5);
        if (n < r - h || n > r + h)
            return !1;
        let o = cN([97, 118, 88, 84, 82, 51, 66, 77, 55, 75, 112, 117, 88, 66, 51, 115])
          , a = cN([99, 74, 70, 74, 101, 72, 119, 68, 89, 72, 108, 55, 108, 112, 77, 103]);
        s.length > 4 && (o += [...e].reduce( (t, i) => t + ("5" === i ? 1 : 0), 0)),
        [...e].reduce( (t, i) => t + ("0" === i ? 1 : 0), 0) > 6 && (a += o.substring(0, 3),
        o = "_" + o);
        let l = 0;
        for (const t of e) {
            const i = Number(t);
            isFinite(i) && (l += i)
        }
        l % 3 == 0 && (a = a.substring(0, 5));
        const u = (o + "A" + e + "A" + s + "" + a).normalize()
          , c = await nN.Crypto.aos(u);
        return i.toLowerCase() === c.toLowerCase()
    }
    async function HN(t) {
        if (nN._U(t),
        t && !VN.has(t.type) && (t.type = SN),
        !TN || !t || t.type !== SN) {
            if (PN = !1,
            GN = "",
            t) {
                const i = t.type;
                if (await WN(t)) {
                    CN = t.type;
                    const e = CN === SN;
                    _N = t.hash,
                    RN = !!t.scriptingEnabled && !e,
                    kN = !!t.canShareProject,
                    TN = !!t.isAccessCode,
                    BN = !!t.gamejamLicenseAvailable,
                    e ? ("number" == typeof t.maxEvents && (ON = Math.min(t.maxEvents, 200)),
                    "number" == typeof t.maxLayers && (DN = Math.min(t.maxLayers, 10)),
                    "number" == typeof t.maxEffects && (FN = Math.min(t.maxEffects, 10)),
                    "number" == typeof t.maxWebFonts && (LN = Math.min(t.maxWebFonts, 5))) : ON = DN = FN = LN = 1 / 0,
                    IN = t.expires ? t.expires : -1,
                    BN && t.hasOwnProperty("activeGamejamLicense") ? (UN = t.activeGamejamLicense,
                    "gamejam" === CN && -1 === IN && UN.hasOwnProperty("endTime") && (IN = UN.endTime)) : UN = null,
                    t.suspended && (PN = !0,
                    GN = t.suspensionReason || "unknown"),
                    i !== CN && (t = null)
                } else
                    t = null
            }
            (!t || PN || !nN.fgt.QKe() && "function" == typeof self[cN([114, 101, 113, 117, 105, 114, 101])]) && (CN = SN,
            _N = "",
            RN = !1,
            kN = !1,
            TN = !1,
            IN = -1,
            ON = 25,
            DN = 2,
            FN = 2,
            LN = 1,
            BN = !1,
            UN = null),
            TN ? -1 === AN && (AN = window.setInterval($N, jN)) : -1 !== AN && (window.clearInterval(AN),
            AN = -1),
            self.app.wZn(),
            CN = "personal"
        }
    }
    async function KN(t, i) {
        const e = zN(86400)
          , s = zN(NN)
          , n = RN ? 22 : zN(14)
          , r = zN(1e8)
          , h = zN(365);
        if (TN || PN)
            return;
        if ("gamejam" === CN)
            return;
        const o = Date.now();
        let a = o + NN;
        if (IN > 0) {
            const t = 1e3 * IN;
            t < a && (a = t)
        }
        let l = DN * FN * LN;
        isFinite(l) || (l = ".");
        let u = ON;
        isFinite(u) || (u = ".");
        const c = "." + (r + i) + t + l + [...(h + nN.o_.Nti).toString()].reverse().join("") + "." + u + s + CN + n + Math.floor(o / 14 + a / 14 - s) + "845193"
          , d = await nN.Crypto.aos(c);
        localforage.removeItem(","),
        localforage.setItem(".", [h, DN, s, t, e, FN, o, i, n, CN, r, a, ON, nN.o_.Nti, LN, d]).catch(t => self.app.OA(t))
    }
    async function qN(t) {
        const i = [localforage.removeItem("."), localforage.removeItem(",")];
        if (t) {
            const t = nN.qs.Ys.$s("OK");
            i.push(t.Qa(hN("ui.offline-login-expired")))
        }
        return await Promise.all(i),
        null
    }
    async function XN() {
        const t = await localforage.getItem(".");
        if (!t)
            return null;
        if (EN.$j())
            return null;
        let i = t[0]
          , e = t[1]
          , s = t[2]
          , n = t[3]
          , r = (t[4],
        t[5])
          , h = t[6]
          , o = t[7]
          , a = t[8]
          , l = t[9]
          , u = t[10]
          , c = t[11]
          , d = t[12]
          , f = t[13]
          , p = t[14]
          , m = t[15]
          , w = e * r * p;
        isFinite(w) || (w = ".");
        let g = d;
        isFinite(g) || (g = ".");
        const y = "." + (u + o) + n + w + [...(i + nN.o_.Nti).toString()].reverse().join("") + "." + g + s + l + a + Math.floor(h / 14 + c / 14 - s) + "845193"
          , b = await Promise.all([nN.Crypto.aos(y), localforage.getItem(",")]);
        if (EN.$j())
            return null;
        const v = b[0]
          , S = b[1];
        if (v !== m)
            return qN(!1);
        const x = Date.now();
        if ("number" == typeof S && S > x)
            return qN(!1);
        if (localforage.setItem(",", x).catch(t => self.app.OA(t)),
        x < h)
            return qN(!1);
        if (x > c)
            return qN(!0);
        if (nN.o_.Nti !== f)
            return qN(!1);
        CN = l;
        return _N = "",
        TN = !1,
        RN = 22 === a,
        CN === SN ? (ON = d,
        DN = e,
        FN = r,
        LN = p) : ON = DN = FN = LN = 1 / 0,
        IN = Math.floor(c / 1e3),
        self.app.wZn(),
        {
            username: n,
            gZn: o
        }
    }
    let YN = null;
    window.yZn = class extends nN.XYe {
        constructor() {
            if (super(),
            this.rVt = "animation" === MN ? "Construct Animate" : "Construct 3",
            nN.o_.sDn(MN),
            this.bZn = null,
            this.GQ = null,
            this.Uan = null,
            this.xk = null,
            this.vZn = null,
            this.bG = null,
            this.wCt = null,
            this.dst = null,
            this.SZn = null,
            this.xZn = null,
            this.MZn = null,
            this.EZn = null,
            this.CZn = null,
            this._Ut = null,
            this._Zn = null,
            this.TZn = null,
            this.IZn = null,
            this.PZn = null,
            this.GZn = null,
            this.AZn = null,
            this.RZn = null,
            this.kZn = null,
            this.OZn = null,
            this.DZn = null,
            this.FZn = null,
            this.LZn = null,
            this.BZn = !1,
            this.UZn = !1,
            this.iLs = null,
            this.NZn = null,
            this.jZn = nN.v(nN.gP, () => this.$Zn(), uN),
            this.zZn = [],
            this.xP = null,
            this.VZn = null,
            this.WZn = new Promise(t => this.VZn = t),
            this.HZn = !1,
            this.yh = nN.v(nN.kh, nN.jh.Gh(this, "undo", () => this.F_()), nN.jh.Gh(this, "redo", () => this.K_()), nN.jh.Gh(this, "settingschange", () => this.Zon()), nN.jh.Gh(window, "hashchange", t => this.KZn(t))),
            this.qZn = null,
            this.XZn = null,
            this.YZn = null,
            this.JZn = null,
            this.ZZn = null,
            this.QZn = null,
            this.tQn = self.devicePixelRatio,
            this.iQn = !1,
            this.eQn = !1,
            this.sQn = 1,
            this.nQn = !1,
            this.rQn = -1,
            this.hQn = !1,
            this.oQn = 0,
            this.aQn = !1,
            this.lQn = 0,
            this.uQn = 0,
            this.cQn = !1,
            this.dQn = new Set,
            this.fQn = nN.v(nN.aWe, () => this.V$n(), pN, {
                enabled: !1,
                oWe: !0
            }),
            this.pQn = nN.v(nN.aWe, () => this.mQn(), 72e5, {
                enabled: !1,
                oWe: !0
            }),
            this.wQn = !1,
            this.gQn = !1,
            this.yQn = [],
            this.bQn = null,
            this.kfn || (window.C3_SetBeforeInstallPromptCallback(t => this.vQn(t)),
            window.C3_SetAppInstalledCallback(t => this.SQn(t))),
            nN.XOt(window.ClaimAnalyticsSandbox) && (window.ClaimAnalyticsSandbox(t => {
                xN = t.securePostMessage
            }
            ),
            window.C3_LogAnalyticsEvent = (...t) => this.Lii(...t)),
            this.kfn || window.addEventListener("beforeunload", t => this.xQn(t)),
            "iOS" === nN.kt.OS) {
                let t = 0;
                document.addEventListener("touchend", i => {
                    const e = Date.now();
                    e - t <= 500 && i.preventDefault(),
                    t = e
                }
                , !0)
            }
            document.addEventListener("gesturestart", nN.qs.Lzt),
            document.addEventListener("gesturechange", nN.qs.Lzt),
            document.addEventListener("gestureend", nN.qs.Lzt),
            document.addEventListener("MSGestureStart", nN.qs.Lzt),
            document.addEventListener("MSGestureChange", nN.qs.Lzt),
            document.addEventListener("MSGestureEnd", nN.qs.Lzt),
            document.addEventListener("touchmove", t => {
                "number" == typeof t.scale && 1 !== t.scale && t.preventDefault()
            }
            , !1),
            YN = this
        }
        async SIt(t) {
            if (nN.n0("AppLoad"),
            !nN.jii() && nN.M9s.lVs("testanimationmode") && (MN = "animation",
            this.rVt = "Construct Animate",
            nN.o_.sDn(MN),
            this.oei()),
            this.QZn = new nN.qs.Afn(this),
            this.QZn.Dfn(self.MQn),
            this.kfn)
                return Promise.resolve(!0);
            window.addEventListener("resize", () => this.Ngi()),
            nN._Ct.CCt(!0);
            const i = nN.qs.SH.gH("wait", document);
            this.tmn();
            const e = nN.lj.Wjn(this);
            await Promise.all(nN.qTe()),
            await nN.qs.HY.qYe(this),
            this.EQn(),
            await t.CQn,
            await e;
            const s = nN.lj.k$n();
            await nN.p.SIt(),
            await this.$pn(),
            EN = this.zj("useraccount"),
            await this._Qn(),
            await EN.TQn(HN, KN, XN),
            await this.IQn(),
            await s,
            await this.jpn(),
            nN.lj.d$n(),
            nN._Ct.CCt(!1),
            nN.qs.SH.CH(i),
            window.addEventListener("dragover", t => t.preventDefault()),
            window.addEventListener("drop", t => {
                t.preventDefault(),
                this.xwt(t)
            }
            ),
            nN.I0("AppLoad")
        }
        PQn(t, i, e=!1) {
            nN.zt(t);
            const s = t.toLowerCase();
            for (const t of i) {
                const i = t[0]
                  , n = i.toLowerCase()
                  , r = t[1].toLowerCase()
                  , h = e ? t[2] : i;
                if (s.startsWith(n))
                    return h;
                if (r && r === s)
                    return h
            }
            return null
        }
        GQn() {
            const t = navigator.languages || [navigator.language];
            for (const i of t) {
                const t = this.PQn(i, mN);
                if (t)
                    return t
            }
            return "en-US"
        }
        AQn() {
            const t = navigator.languages || [navigator.language];
            for (const i of t) {
                if (this.PQn(i, mN))
                    return "";
                const t = this.PQn(i, gN, !0);
                if (t)
                    return t
            }
            return ""
        }
        Hpn() {
            return {
                language: this.GQn(),
                uiMode: "auto",
                useSimplifiedMode: !1,
                enableExampleBrowser: !0,
                theme: window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "",
                useDefaultIconColor: !0,
                iconColor: "#000000",
                enableUIAnimations: !window.matchMedia("(prefers-reduced-motion: reduce)").matches,
                enableUIEffects: !0,
                enableNotifications: !0,
                showTakeBreakReminders: !0,
                zoomMouseWheelOnly: !1,
                useFakeClipboard: !1,
                experimentalFeatures: !1,
                developerMode: !1,
                showInProgressLanguages: !1,
                defaultSaveLocation: nN.zk.Lk ? "save-as" : "cloud",
                textEditorFontSize: 12,
                textEditorAutoIndent: !0,
                textEditorEnableMinimap: !0,
                textEditorMinimapScale: 1,
                textEditorEnableStickyScrolling: !0,
                textEditorEnableCodeFolding: !0,
                textEditorEnableWordWrap: !0,
                autoSave: !1,
                autosaveDuration: 10,
                autosaveLocation: "MATCH",
                cloudCache: !0,
                limitToWebGL1: !1,
                enableWebGPUInEditor: "auto",
                updateChannel: "stable",
                checkForAddonUpdates: !0,
                gpuPowerPreference: "default",
                previewMode: "popup-window",
                hideAddActionRows: !1,
                translateExpressions: !0,
                showStartPageOnStartup: !0,
                autoHideStartPage: !1,
                showStartPageMessageBanners: !0,
                defaultProjectAuthor: "",
                defaultProjectEmail: "",
                defaultProjectWebsite: "",
                defaultAnimationSpeed: 5
            }
        }
        async Kpn() {
            const t = await super.Kpn();
            "boolean" == typeof t.enableWebGPUInEditor && (t.enableWebGPUInEditor = t.enableWebGPUInEditor ? "yes" : "auto"),
            document.documentElement.setAttribute("lang", this.iwt()),
            this.RQn()
        }
        Zon() {
            this.RQn();
            const t = this.kQn();
            t !== this.pQn.gWe() && (t ? this.pQn.ke() : this.pQn.rjs())
        }
        B6e() {
            const t = this.r0();
            return t.useDefaultIconColor ? nN.qs.oX.dXe() : t.iconColor
        }
        zmt() {
            return nN.zk.WRe && !!this.r0().enableUIAnimations && !nN.M9s.lVs("disable-ui-animations")
        }
        RQn() {
            const t = document.body.parentElement
              , i = this.zmt() ? "uianimationsenabled" : "uianimationsdisabled"
              , e = this.zmt() ? "uianimationsdisabled" : "uianimationsenabled";
            t.removeAttribute(e),
            t.setAttribute(i, "")
        }
        kQn() {
            return !!this.r0().showTakeBreakReminders
        }
        J1() {
            return !!this.r0().enableUIEffects
        }
        Ipn() {
            return !!this.r0().enableNotifications
        }
        tH() {
            return !!this.r0().useFakeClipboard
        }
        Xj() {
            return "animation" !== MN && !!this.r0().developerMode
        }
        KLn() {
            return !!this.r0().experimentalFeatures
        }
        PE() {
            return !!this.r0().useSimplifiedMode && !this.aj()
        }
        iwt() {
            let t = this.r0().language;
            return t.startsWith("synthetic-") && (t = "en-US"),
            t
        }
        oQs() {
            return this.r0().translateExpressions
        }
        OQn() {
            return "animation" === MN ? nN.qs.fA.oDn.uDn : nN.qs.fA.oDn.aDn
        }
        DQn() {
            if (nN.kt.mj)
                this.NZn = null;
            else {
                const t = this.bZn.o2e();
                !(t && t[0]) || nN.M9s.lVs("default-layout") || t[0].devicePixelRatio !== window.devicePixelRatio ? this.NZn = this.OQn() : this.NZn = t
            }
        }
        vH() {
            return !!this.NZn
        }
        tZn() {
            this.bZn.y2e()
        }
        M_() {
            this.jZn.IF()
        }
        $Zn() {
            if (this.NZn = null,
            !this.Ik().wj())
                try {
                    this.bZn && this.BZn && !nN.kt.mj && this.bZn.b2e()
                } catch (t) {
                    console.error("Error saving UI state: ", t)
                }
        }
        async _Qn(t=!1) {
            const i = this.NZn;
            if (i) {
                nN.M9s.lVs("log-pane") && console.info("Rebuilding with layout", JSON.stringify(i, null, 4));
                try {
                    nN.qs.fA.E1e(i);
                    const t = JSON.parse(JSON.stringify(i));
                    nN.qs.fA.P1e(t, this.bZn)
                } catch (e) {
                    if ((() => {})("Failed to restore layout", JSON.stringify(i)),
                    console.error(e),
                    t)
                        throw e;
                    this.NZn = this.OQn(),
                    this._Qn(!0)
                }
            }
            this.BZn = !0
        }
        G3e() {
            this.M_()
        }
        EQn() {
            const t = cN([108, 111, 99, 97, 116, 105, 111, 110])
              , i = cN([104, 111, 115, 116, 110, 97, 109, 101])
              , e = self[t][i]
              , s = cN([101, 100, 105, 116, 111, 114, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 46, 110, 101, 116])
              , n = cN([101, 100, 105, 116, 111, 114, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 100, 101, 118, 46, 110, 101, 116])
              , r = cN([97, 110, 105, 109, 97, 116, 101, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 46, 110, 101, 116])
              , h = cN([97, 110, 105, 109, 97, 116, 101, 46, 99, 111, 110, 115, 116, 114, 117, 99, 116, 100, 101, 118, 46, 110, 101, 116])
              , o = "games" === MN ? e === s || e === n : e === r || e === h
              , a = e === cN([108, 111, 99, 97, 108, 104, 111, 115, 116])
              , l = location.port
              , u = parseInt(l, 10)
              , c = o && !l || a && (!nN.jii() || u >= 61e3 && u <= 61005);
            this.Npn(),
            this.bZn = this.Apn.I0e("1fr", "Main area", "main"),
            this.bZn.eue("main"),
            this.Apn.so(),
            this.DQn(),
            this.Uan = nN.v(nN.qs.Jj.Pan),
            nN.p.u("ui.status-indicators"),
            this.qZn = new nN.qs.Jj.Ban(this.Uan,hN(".building-spritesheets")),
            this.XZn = new nN.qs.Jj.Ban(this.Uan,hN(".rendering-spritesheets")),
            this.YZn = new nN.qs.Jj.Ban(this.Uan,hN(".compressing-spritesheets")),
            this.JZn = new nN.qs.Jj.Ban(this.Uan,hN(".creating-textures")),
            this.ZZn = new nN.qs.Jj.Ban(this.Uan,hN(".loading-fonts")),
            nN.p.j(),
            c && self === self.top && (this.bZn.T0e(!0),
            this.GQ = this.bZn.n1e("middle", !0))
        }
        async IQn() {
            this.GQ.so(),
            this.xk = this.zj("mainMenu"),
            this.vZn = this.zj("midPane"),
            this.MZn = this.zj("propertiesBar"),
            this.EZn = this.zj("projectBar"),
            this.CZn = this.zj("layersBar"),
            this._Ut = this.zj("tilemapBar"),
            this.RZn = this.zj("startPage2"),
            this.kZn = this.zj("exampleBrowser"),
            this.OZn = this.zj("buyNowPage"),
            this.DZn = this.zj("guidedtourcontroller"),
            this.FZn = this.zj("remotePreviewBar"),
            this.LZn = this.zj("assetBrowserBar"),
            nN.fk.addEventListener("registercomponent", t => {
                this.uZn(t.component.vR(), t.component.gk())
            }
            ),
            nN.fk.addEventListener("unregistercomponent", t => {
                this.uZn(t.component.vR(), null)
            }
            ),
            this.bZn.addEventListener("replacesubgrid", t => {
                this.GQ = t.w2e
            }
            ),
            await this.zpn()
        }
        h4e() {
            return this.UZn
        }
        async Zpn(t) {
            const i = self.app;
            if (this.kfn)
                return;
            this.UZn = !0,
            self.rOe = new self.qWe,
            "Safari" === nN.kt.Nr && self.rOe.ski(),
            this.tQn = self.devicePixelRatio,
            nN.jii() && !this.Xj() && (nN.p.u("ui.console-warning"),
            console.log("%c" + hN(".title"), "color: red; font-size: 4em; font-weight: bold; -webkit-text-stroke: 1px black"),
            console.log("%c" + hN(".message"), "font-size: 2em;"),
            console.log("%c" + hN(".message2"), "font-size: 2em; font-weight: bold;"),
            nN.p.j());
            const e = performance.now();
            nN.j_t && console.info(`[Perf] Startup time: ${Math.round(10 * e) / 10} ms`),
            this.fQn.ke(),
            this.kQn() && this.pQn.ke();
            const s = super.Zpn();
            window.OfflineClientInfo && window.OfflineClientInfo.SetMessageCallback( (t, i) => this.FQn(t, i)),
            this.LQn(t, s).catch(t => window.C3_OnAppFatalLoadError(t)),
            "en-US" !== this.r0().language && this.oei();
            const n = await Promise.all([localforage.getItem("c3-done-first-run"), localforage.getItem("c3-last-release"), localforage.getItem("c3-launch-count")])
              , r = n[0]
              , h = n[1];
            this.sQn = n[2] || 1,
            localforage.setItem("c3-launch-count", this.sQn + 1).catch(t => i.OA(t)),
            this.eQn = !r || nN.M9s.lVs("firstrun");
            const o = !this.eQn && h && h < nN.o_.Nti
              , a = this.eQn ? "cold" : o ? "update-cold" : "warm";
            if (this.BQn("StartUp", e, a),
            nN.Vl)
                return this.vZn.M6t(!1),
                void this.UQn();
            if (wN.has(this.r0().language)) {
                const t = this.r0().language;
                this.Lii("LanguageUnderReviewPrompt", {
                    event_label: "Shown",
                    lang_tag: t
                }),
                nN.p.u("ui.language-under-review-prompt");
                const e = nN.qs.Ys.$s("Confirm").Qa({
                    message: lN(".message", nN.p.fje()),
                    jD: lN(".continue", nN.p.fje()),
                    vD: hN(".switch-to-english"),
                    eQe: !0
                });
                nN.p.j();
                null === await e ? (this.Lii("LanguageUnderReviewPrompt", {
                    event_label: "SwitchToEnglish",
                    lang_tag: t
                }),
                this.r0().language = "en-US",
                await i.X6i(),
                await nN.KTi(100),
                location.reload()) : this.Lii("LanguageUnderReviewPrompt", {
                    event_label: "Confirmed",
                    lang_tag: t
                })
            }
            if (this.rj() && (this.eQn || nN.M9s.lVs("startTour"))) {
                const t = nN.qs.Ys.$s("WelcomeTour");
                await t.Qa()
            }
            if (o) {
                try {
                    await localforage.setItem("c3-last-release", nN.o_.Nti)
                } catch (t) {
                    this.OA(t)
                }
                if (!this.aj()) {
                    nN.p.u("ui.update-notification");
                    const t = nN.qs.Ys.$s("Confirm");
                    t.sOe = () => this.e_(nN.o_.URL.oSe + nN.o_.URL.zOn + nN.o_.hDn, "ReleaseNotes");
                    const i = t.Qa({
                        caption: hN(".caption"),
                        message: oN(".message", nN.Vhi(h), nN.Vhi(nN.o_.Nti)),
                        jD: hN(".view-release-notes"),
                        vD: hN(".not-now")
                    });
                    nN.p.j(),
                    await i
                }
            } else if (!h)
                try {
                    await localforage.setItem("c3-last-release", nN.o_.Nti)
                } catch (t) {
                    this.OA(t)
                }
            if (this.QVn() ? localforage.setItem("c3-last-beta-release", nN.o_.hDn).catch(t => this.OA(t)) : this.NQn() && localforage.setItem("c3-last-lts-release", nN.o_.hDn).catch(t => this.OA(t)),
            nN.jii() && "iOS" === nN.kt.OS && "Safari" === nN.kt.Nr && "browser" === nN.Xke() && !this.aj()) {
                nN.p.u("ui.safari-a2hs-prompt");
                const t = nN.qs.Ys.$s("OK");
                t.Ya(hN(".title"));
                const i = t.Qa(self.idt(".message"));
                nN.p.j(),
                await i
            }
            if (nN.kt.mj && "browser" === nN.kt.Tj && !nN.Pj() && nN.zk.Uj && window.matchMedia("(max-width: 500px), (max-height: 500px)").matches && !this.aj()) {
                const t = nN.qs.Ys.$s("FullscreenPrompt");
                await t.Qa(document.body)
            }
            this.eQn && localforage.setItem("c3-done-first-run", !0).catch(t => this.OA(t)),
            this.r0().showStartPageOnStartup && this.RZn.Ej(),
            nN.DRe.lVs("open-example-browser") && this.Gj() && (this.kZn.Ej(),
            nN.DRe.IRe()),
            this.vZn.M6t(!1),
            window.launchQueue && window.LaunchParams && "files"in window.LaunchParams.prototype && nN.zk.Lk && window.launchQueue.setConsumer(async t => {
                if (1 !== t.files.length)
                    return;
                const i = t.files[0]
                  , e = i.name;
                if (e.toLowerCase().endsWith(".c3p"))
                    try {
                        const t = await i.getFile()
                          , s = await this.a2t(t, {
                            h2t: "webfs-launch-queue"
                        });
                        if (!nN.$l(s, self.gh))
                            return;
                        s.gii(e),
                        await s.wii("webfs-single-file", {
                            fileHandle: i
                        })
                    } catch (t) {
                        (() => {})("Failed to open file from launch queue: ", t)
                    }
            }
            ),
            await this.zj("useraccount").FKt(),
            this.k_() && this.OZn.Ej(!1),
            this.aj() || (await this.jQn(),
            await this.$Qn(),
            await this.zQn(),
            this.VQn()),
            this.WQn()
        }
        async LQn(t, i) {
            nN.n0("StartupBackgroundLoading");
            const e = self.app;
            let s = 0;
            const n = (t, i) => this.BQn("BackgroundLoad", performance.now() - i, t);
            let r = e.ZPe(hN("ui.loading-screen.still-loading"));
            r.Ej(),
            this.HQn(t).catch(t => window.C3_OnAppFatalLoadError(t));
            const h = this.kZn.KQn();
            await Promise.all([i, this.WZn]),
            r.he(),
            await h,
            "Android" === nN.kt.OS && (nN.wHe.Ent(),
            nN.wHe.cR( () => this.qQn())),
            await Promise.all([nN.Ars.SIt(), this.kZn.XQn()]),
            await nN._Ct(async () => {
                if (!this.bG.ga()) {
                    s = performance.now();
                    try {
                        await this.Pv()
                    } catch (t) {}
                    n("CreateWebGLRenderer", s)
                }
            }
            ),
            r = e.ZPe(hN("ui.loading-screen.loading-icons")),
            r.Ej(),
            s = performance.now(),
            await this.Qpn(),
            n("PrefetchAllIcons", s),
            r.pa(hN("ui.loading-screen.loading-addons")),
            s = performance.now(),
            await this.Rii(),
            n("PreloadAllAddons", s),
            r.pa(hN("ui.loading-screen.loading-addon-events")),
            s = performance.now(),
            await nN.lj.G$n(),
            n("PreParseDisplayTexts", s),
            r.he(),
            this.BQn("StartUp", performance.now(), "AllBackgroundLoadingDone"),
            nN.I0("StartupBackgroundLoading"),
            this.YQn(),
            nN.qs.Jj.rqn.mqn()
        }
        async HQn(t) {
            if (this.kfn)
                return;
            nN.n0("BackgroundLoadProjectResources");
            const i = nN.FRt.SIt()
              , e = nN.twt.vp()
              , s = new nN.BOe("BLPR-ProjectResourcesImport");
            await nN.MAe("projectResources.html", !0),
            s.next("BLPR-ComponentImports"),
            await Promise.all([...t.JQn.values()].map(t => nN.MAe(t, !1))),
            s.next("BLPR-LoadAddons"),
            await Promise.all([nN.lj.qjn(), nN.lj.SIt(), nN.pls.SIt()]),
            s.next("BLPR-LoadLang1"),
            await nN.p.SIt(),
            s.next("BLPR-AddonsReady"),
            await Promise.all([nN.lj.Yjn(), nN.Di.W7t(this), nN.F.W7t(this), nN.pls.W7t(this)]),
            s.next("BLPR-WaitForJobScheduler"),
            await Promise.all([i, e]),
            s.next("BLPR-LoadLang2"),
            await nN.p.SIt(),
            s.next("BLPR-LoadComponents"),
            await this.$pn(),
            s.next("BLPR-AfterLoadComponents"),
            this.bG = this.zj("layoutViewManager"),
            this.wCt = this.zj("eventSheetViewManager"),
            this.dst = this.zj("flowchartViewManager"),
            this.SZn = this.zj("textEditorManager"),
            this.xZn = this.zj("dataEditorManager"),
            await this.zpn(),
            this.dispatchEvent(new nN.Event("allcomponentsloaded")),
            s.next("BLPR-LoadDialogs"),
            await Promise.all([nN.qs.HY.qYe(this), nN.lj.O$n()]),
            this.HZn = !0,
            this.BQn("StartUp", performance.now(), "ProjectResourcesLoadingDone"),
            s.end(),
            this.VZn(),
            this.VZn = null,
            nN.I0("BackgroundLoadProjectResources")
        }
        async Lj(t) {
            let i = null;
            t && !this.HZn && (i = nN.qs.Ys.$s("Progress"),
            i.Qa(hN("ui.loading-screen.still-loading"))),
            await this.WZn,
            i && i.PR()
        }
        pRt() {
            return this.HZn
        }
        async YQn() {
            if (nN.jii() && nN.o_.OOn && navigator.serviceWorker)
                try {
                    const t = await navigator.serviceWorker.register("sw.js");
                    console.log("Registered service worker on " + t.scope)
                } catch (t) {
                    console.error("Failed to register service worker: ", t)
                }
        }
        ZQn() {
            if (this.gQn)
                return;
            this.gQn = !0;
            let t = document.createElement("iframe");
            const i = "https://preview.construct.net/local.html"
              , e = new URL(i).origin
              , s = () => {
                t && (t.parentElement.removeChild(t),
                t = null)
            }
            ;
            t.addEventListener("load", () => {
                try {
                    t.contentWindow.postMessage({
                        type: "register-sw"
                    }, e)
                } catch (t) {
                    s()
                }
            }
            ),
            t.addEventListener("error", s),
            t.style.display = "none",
            t.src = i,
            document.body.appendChild(t),
            window.setTimeout(s, 5e3)
        }
        FQn(t, i) {
            const e = t.data;
            "root" === i ? this.QQn(e) : "main" === i ? this.t0n(e) : (() => {})("Unknown broadcast source: ", i)
        }
        QQn(t) {
            switch (t.type) {
            case "downloading":
                this.ZQn();
                break;
            case "update-pending":
                this.i0n();
                break;
            case "update-ready":
                this.e0n(t.version)
            }
        }
        t0n(t) {
            switch (t.type) {
            case "downloading":
                this.ZQn();
                break;
            case "offline-ready":
                this.s0n()
            }
        }
        i0n() {
            nN.p.u("ui.update-alerts.update-pending"),
            nN.qs.Notification.nF("download", hN(".title"), hN(".message"), {
                align: "bottom-left",
                z7t: 1e4
            }),
            nN.p.j()
        }
        e0n(t) {
            this.BQn("UpdateAvailable", performance.now() - 3e3),
            t > nN.o_.Nti && (this.rQn = t),
            this.hQn && (this.a7t() > 0 || nN.qs.HY.DY() ? this.n0n() : this.r0n())
        }
        s0n() {
            this.BQn("OfflineCached", performance.now() - 3e3, this.eQn ? "FirstRun" : "NotFirstRun", 6e5),
            nN.p.u("ui.update-alerts.offline-ready"),
            nN.qs.Notification.nF("download", hN(".title"), hN(".message"), {
                align: "bottom-left",
                z7t: 8e3
            }),
            nN.p.j()
        }
        $Qn() {
            return rN(!this.hQn, "should only be called once"),
            this.hQn = !0,
            this.h0n(this.r0().updateChannel),
            this.rQn >= 0 ? this.r0n() : Promise.resolve()
        }
        r0n() {
            if (this.rQn < 0)
                return Promise.resolve();
            const t = nN.qs.Ys.$s("Confirm");
            nN.p.u("ui.update-alerts.update-available-prompt"),
            t.sOe = () => location.reload(!0);
            const i = t.Qa({
                caption: hN(".title"),
                message: oN(".message", nN.o_.Lhi, nN.Vhi(this.rQn)),
                jD: hN(".update"),
                vD: hN(".not-now")
            });
            return nN.p.j(),
            i
        }
        n0n() {
            this.rQn < 0 || (nN.p.u("ui.update-alerts.update-available-notification"),
            nN.qs.Notification.nF("download", hN(".title"), hN(".message"), {
                align: "bottom-left",
                z7t: 1e4
            }),
            nN.p.j())
        }
        async zQn() {
            if (!nN.zk.QRe)
                return;
            let t, i, e;
            try {
                const s = await navigator.storage.estimate();
                if (t = s.quota,
                i = s.usage,
                e = Math.min(Math.round(100 * i / t), 100),
                e < 90)
                    return
            } catch (t) {
                return void (() => {})("Error estimating storage usage: ", t)
            }
            this.Lii("StorageQuotaFullPrompt", "Shown"),
            nN.p.u("ui.storage-quota-full-prompt");
            const s = nN.qs.Ys.$s("Confirm").Qa({
                caption: hN(".caption"),
                message: oN(".message", e, nN.Iye(i), nN.Iye(t)),
                jD: hN(".storage-cleanup")
            });
            nN.p.j();
            if (null === await s)
                return void this.Lii("StorageQuotaFullPrompt", "Cancelled");
            this.Lii("StorageQuotaFullPrompt", "OK-StorageCleanup");
            nN.qs.Ys.$s("StorageCleanup").Qa()
        }
        WQn() {
            this.PE() && (nN.p.u("ui.simplified-mode-notification"),
            nN.qs.Notification.nF("info", hN(".title"), hN(".message"), {
                align: "bottom-left",
                z7t: 1e4
            }),
            nN.p.j())
        }
        async h0n(t) {
            if ("none" === t)
                return;
            const i = this.tke();
            try {
                const e = await fetch("/versions.json");
                if (!e.ok)
                    throw new Error(e.status + " " + e.statusText);
                const s = await e.json();
                let n = -1
                  , r = ""
                  , h = -1
                  , o = ""
                  , a = -1
                  , l = "";
                for (const t of s) {
                    const i = t.branchName;
                    "Stable" === i ? (h = nN.rDn(t.releaseName),
                    o = t.launchURL) : "Beta" === i ? (a = nN.rDn(t.releaseName),
                    l = t.launchURL) : "LTS" === i && (n = nN.rDn(t.releaseName),
                    r = t.launchURL)
                }
                if ("lts" === i) {
                    if (n > nN.o_.Nti) {
                        const t = nN.p.Ok("ui.update-alerts.lts-update-available-prompt")
                          , i = nN.qs.Ys.$s("Confirm");
                        i.sOe = () => location.href = r,
                        await i.Qa({
                            caption: t(".title"),
                            message: t.hDt(".message", nN.o_.Lhi, nN.Vhi(n)),
                            jD: t(".update"),
                            vD: t(".not-now")
                        })
                    }
                } else if ("stable" === i) {
                    if ("beta" === t && a > nN.o_.Nti) {
                        const t = nN.p.Ok("ui.update-alerts.beta-update-available-prompt")
                          , i = nN.qs.Ys.$s("Confirm");
                        i.sOe = () => location.href = l,
                        await i.Qa({
                            caption: t(".title"),
                            message: t.hDt(".message", nN.o_.Lhi, nN.Vhi(a)),
                            jD: t(".update"),
                            vD: t(".not-now")
                        })
                    } else if ("stable" === t && h > nN.o_.Nti && "/" !== location.pathname) {
                        const t = nN.p.Ok("ui.update-alerts.update-available-prompt")
                          , i = nN.qs.Ys.$s("Confirm");
                        i.sOe = () => location.href = location.origin,
                        await i.Qa({
                            caption: t(".title"),
                            message: t.hDt(".message", nN.o_.Lhi, nN.Vhi(h)),
                            jD: t(".update"),
                            vD: t(".not-now")
                        })
                    }
                } else if (h > nN.o_.Nti && h > a) {
                    const t = nN.p.Ok("ui.update-alerts.update-available-prompt")
                      , i = nN.qs.Ys.$s("Confirm");
                    i.sOe = () => location.href = o,
                    await i.Qa({
                        caption: t(".title"),
                        message: t.hDt(".message", nN.o_.Lhi, nN.Vhi(h)),
                        jD: t(".update"),
                        vD: t(".not-now")
                    })
                } else if (a > nN.o_.Nti) {
                    const t = nN.p.Ok("ui.update-alerts.beta-update-available-prompt")
                      , i = nN.qs.Ys.$s("Confirm");
                    i.sOe = () => location.href = l,
                    await i.Qa({
                        caption: t(".title"),
                        message: t.hDt(".message", nN.o_.Lhi, nN.Vhi(a)),
                        jD: t(".update"),
                        vD: t(".not-now")
                    })
                }
            } catch (t) {
                (() => {})("Failed to check for beta update: ", t)
            }
        }
        async VQn() {
            if (this.r0().checkForAddonUpdates && !nN.lj.$jn() && !this.PE() && this.Rj())
                return await nN.qs.Jj.Fj.DYn()
        }
        vQn(t) {
            this.bQn = t,
            this.Lii("WebAppInstall", "InstallAvailable")
        }
        SQn(t) {
            this.Lii("WebAppInstall", "AppInstalled")
        }
        Yj() {
            return !!this.bQn && "browser" === nN.kt.Tj
        }
        async Zj() {
            const t = this.bQn;
            if (this.bQn = null,
            !t)
                return;
            t.prompt(),
            this.Lii("WebAppInstall", "InstallPromptShown");
            const i = await t.userChoice;
            this.Lii("WebAppInstall", "InstallPromptOutcome-" + i.outcome)
        }
        async Rii() {
            const t = new nN.BOe("PreloadAllAddons-ForceLoad");
            await Promise.all([nN.Di.Kde(), nN.F.Kde()]),
            t.next("PreloadAllAddons-LoadIcons");
            const i = [];
            i.push(nN._Ct( () => nN.Di.e8s().uj()));
            for (const t of nN.Di.plugins())
                i.push(nN._Ct( () => t.uj()));
            for (const t of nN.F.Yde())
                i.push(nN._Ct( () => t.uj()));
            await Promise.all(i),
            t.end()
        }
        KZn(t) {
            nN.DRe.GRe(location.hash),
            0 === this.a7t() && this.Gj() && this.kZn.KQn()
        }
        qE() {
            return this.GQ
        }
        o0n() {
            return this.xk
        }
        a0n() {
            return this.xk.pk()
        }
        aA() {
            return this.bZn
        }
        Ik() {
            return this.vZn
        }
        Ij() {
            return this.RZn
        }
        Gj() {
            return this.r0().enableExampleBrowser
        }
        Oj() {
            return this.kZn
        }
        f7t() {
            return this.OZn
        }
        hj() {
            return this.DZn
        }
        aj() {
            const t = this.hj();
            return !!t && t.l0n()
        }
        rj() {
            return nN.kt.lA
        }
        ULt() {
            return !this.aj()
        }
        p7t(t, i) {
            this.vZn.p7t(t, i)
        }
        Y5t() {
            this.vZn.Y5t()
        }
        uZn(t, i) {
            switch (t) {
            case "propertiesBar":
                this.MZn = i;
                break;
            case "projectBar":
                this.EZn = i;
                break;
            case "layersBar":
                this.CZn = i;
                break;
            case "tilemapBar":
                this._Ut = i;
                break;
            case "zOrderBar":
                this._Zn = i;
                break;
            case "bookmarksBar":
                this.TZn = i;
                break;
            case "findResultsBar":
                this.IZn = i;
                break;
            case "findReferencesBar":
                this.PZn = i;
                break;
            case "timelineBar":
                this.GZn = i;
                break;
            case "instanceBar":
                this.AZn = i;
                break;
            case "remotePreviewBar":
                this.FZn = i;
                break;
            case "assetBrowserBar":
                this.LZn = i
            }
        }
        Qh() {
            return !(!this.MZn || this.MZn.b_()) || (this.MZn = null,
            !1)
        }
        Zh(t) {
            if (t = void 0 === t,
            !this.MZn && t)
                throw new Error("properties bar unavailable");
            return this.MZn
        }
        nde() {
            return !(!this.EZn || this.EZn.b_()) || (this.EZn = null,
            !1)
        }
        fj(t) {
            if (t = void 0 === t,
            !this.EZn && t)
                throw new Error("project bar unavailable");
            return this.EZn
        }
        u0n() {
            return !(!this.CZn || this.CZn.b_()) || (this.CZn = null,
            !1)
        }
        bj(t) {
            if (t = void 0 === t,
            !this.CZn && t)
                throw new Error("layers bar unavailable");
            return this.CZn
        }
        iX() {
            return !(!this._Ut || this._Ut.b_()) || (this._Ut = null,
            !1)
        }
        gj(t) {
            if (t = void 0 === t,
            !this._Ut && t)
                throw new Error("tilemap bar unavailable");
            return this._Ut
        }
        xF() {
            return !(!this._Zn || this._Zn.b_()) || (this._Zn = null,
            !1)
        }
        yj(t) {
            if (t = void 0 === t,
            !this._Zn && t)
                throw new Error("zorder bar unavailable");
            return this._Zn
        }
        VL() {
            return !(!this.GZn || this.GZn.b_()) || (this.GZn = null,
            !1)
        }
        Mj(t) {
            if (t = void 0 === t,
            !this.GZn && t)
                throw new Error("timeline bar unavailable");
            return this.GZn
        }
        c0n() {
            return !(!this.TZn || this.TZn.b_()) || (this.TZn = null,
            !1)
        }
        kj(t) {
            if (t = void 0 === t,
            !this.TZn && t)
                throw new Error("bookmarks bar unavailable");
            return this.TZn
        }
        uY() {
            return !(!this.AZn || this.AZn.b_()) || (this.AZn = null,
            !1)
        }
        _j(t) {
            if (t = void 0 === t,
            !this.AZn && t)
                throw new Error("hierarchy bar unavailable");
            return this.AZn
        }
        d0n() {
            return !(!this.LZn || this.LZn.b_()) || (this.LZn = null,
            !1)
        }
        Aj(t) {
            if (t = void 0 === t,
            !this.LZn && t)
                throw new Error("hierarchy bar unavailable");
            return this.LZn
        }
        w_e() {
            return this.FZn
        }
        f0n() {
            let t = this.w_e();
            return t || (t = self.p0n.y_()),
            t.x_(!0),
            t
        }
        jj() {
            return this.IZn
        }
        rde() {
            return this.PZn
        }
        bDt() {
            if (this.DA().B7t())
                return;
            let t = this.jj();
            const i = this.Oj()
              , e = i.dH() && i.dH().__();
            t && t.dH() && t.dH().__() || !e ? (t || (t = self.m_.y_()),
            t.x_(!0),
            t.dH().lX(),
            t.hRe()) : i.hRe()
        }
        m0n() {
            this.fj().DE()
        }
        w0n(t, i, e=!0) {
            if (nN.Kq(i),
            e = !!e,
            nN.kt.mj) {
                if (i && e) {
                    nN.qs.Ys.$s("OK").Qa(oN("ui.errors.feature-not-available-in-mobile", i))
                }
                return !1
            }
            return !0
        }
        xj(t) {
            return !!this.w0n(t)
        }
        jL(t) {
            const i = hN("ui.bars.project.items.timelines");
            return !!this.w0n(t, i)
        }
        GX() {
            return !this.PE()
        }
        Sj(t=!0) {
            return !0
        }
        g0n() {
            return nN.Vl || this.QVn() || this.KLn()
        }
        async Hk() {
            return !nN.zk.Lk || !await self.jk.oXn()
        }
        XMt() {
            return !!this.bG
        }
        zs() {
            if (!this.bG)
                throw new Error("layout view manager unavailable");
            return this.bG
        }
        JR() {
            if (!this.wCt)
                throw new Error("event sheet view manager unavailable");
            return this.wCt
        }
        Fut() {
            return !!this.dst
        }
        Mst() {
            if (!this.dst)
                throw new Error("flowchart view manager unavailable");
            return this.dst
        }
        KPe() {
            return this.zs().ga()
        }
        ln() {
            return this.zs().ba()
        }
        async Pv() {
            return await self.app.Lj(),
            await this.zs().Pv()
        }
        PL(t) {
            nN.U(t, self.CO);
            const i = t.yn();
            if (this.jL(i))
                return self.w_.PL(t)
        }
        HR(t) {
            return nN.U(t, self.fA),
            this.bG.HR(t)
        }
        GR(t) {
            return nN.U(t, self.lF),
            this.wCt.GR(t)
        }
        XL(t) {
            return nN.U(t, self.vO),
            this.dst.XL(t)
        }
        oL(t, i=null) {
            return nN.U(t, window.fh),
            nN._U(i),
            self.c_.oL(t, i)
        }
        _G(t, i, e) {
            t.l2e(),
            this.vZn.L6t(t, i, e)
        }
        t0(t) {
            this.vZn.D6t(t)
        }
        TF() {
            return this.bG ? this.zs().TF() : null
        }
        y0n() {
            return !!this.SZn
        }
        DA() {
            if (!this.SZn)
                throw new Error("text editor manager unavailable");
            return this.SZn
        }
        b0n() {
            return !!this.xZn
        }
        yU() {
            if (!this.xZn)
                throw new Error("data editor manager unavailable");
            return this.xZn
        }
        dUn(t, i) {
            nN.qd(t),
            nN.Wat(i),
            i = Object.assign({}, yN, i),
            this.yQn.push({
                vsn: t,
                v0n: !!i.isZipFormat,
                S0n: !!i.toLayoutView
            })
        }
        async xwt(t) {
            if (nN.qs.HY.DY())
                return;
            if (this.aj())
                return;
            const i = t.dataTransfer.files
              , e = this.dT()
              , s = this.TF();
            if (1 === i.length) {
                const n = i[0]
                  , r = {
                    h2t: "drag-and-drop"
                };
                switch (nN.Uh(n.name).toLowerCase().slice(1)) {
                case "capx":
                    return void this.l2t(n, r);
                case "caproj":
                    return void this.x0n();
                case "c3p":
                    {
                        let i = null;
                        const e = t.dataTransfer.items[0];
                        if (e && e.getAsFileSystemHandle && nN.zk.Lk)
                            try {
                                i = await e.getAsFileSystemHandle(),
                                i && (r.h2t = "webfs-drag-and-drop")
                            } catch (t) {
                                (() => {})("Failed to get file system handle from drop: ", t),
                                i = null
                            }
                        const s = await this.a2t(n, r);
                        if (!nN.$l(s, self.gh))
                            return;
                        if (i)
                            try {
                                s.gii(n.name),
                                await s.wii("webfs-single-file", {
                                    fileHandle: i
                                })
                            } catch (t) {
                                (() => {})("Failed to set origin file system from drop: ", t)
                            }
                        return
                    }
                case "c3proj":
                    return void this.M0n();
                case "zip":
                    return void this.E0n(n, t.clientX, t.clientY);
                case "png":
                case "apng":
                case "webp":
                case "avif":
                case "avifs":
                case "jpg":
                case "gif":
                    return void (e && s && s.dH().__() && s.hQ(Array.from(i), t.clientX, t.clientY));
                case "svg":
                    return void (e && s && s.dH().__() && s.pQ(n, t.clientX, t.clientY));
                case "wav":
                case "webm":
                case "flac":
                case "opus":
                case "ogg":
                case "m4a":
                    {
                        const t = nN.qs.Ys.$s("ImportAudio");
                        return void (e && t.o2t([n], e, document.body))
                    }
                case "c3addon":
                    return void (this.Rj() && nN.qs.Jj.Fj.c2t([n], null))
                }
                if (await this.C0n(t))
                    return;
                this._0n(n, t.clientX, t.clientY)
            } else if (i.length > 1) {
                let n = null
                  , r = !1;
                for (let t of i)
                    switch (nN.Uh(t.name).toLowerCase().slice(1)) {
                    case "png":
                    case "apng":
                    case "webp":
                    case "avif":
                    case "avifs":
                    case "jpg":
                    case "gif":
                        null !== n && "image" !== n ? r = !0 : n = "image";
                        break;
                    case "wav":
                    case "webm":
                    case "flac":
                    case "opus":
                    case "ogg":
                    case "m4a":
                        null !== n && "audio" !== n ? r = !0 : n = "audio";
                        break;
                    case "c3addon":
                        null !== n && "c3addon" !== n ? r = !0 : n = "c3addon";
                        break;
                    default:
                        r = !0
                    }
                if (r)
                    (() => {})("[Construct] Cannot import mixed file types via drag-and-drop");
                else
                    switch (n) {
                    case "audio":
                        {
                            const t = nN.qs.Ys.$s("ImportAudio");
                            e && t.o2t(i, e, document.body);
                            break
                        }
                    case "image":
                        s && s.dH().__() && s.hQ(Array.from(i), t.clientX, t.clientY);
                        break;
                    case "c3addon":
                        this.Rj() && nN.qs.Jj.Fj.c2t(i, null)
                    }
            }
        }
        async C0n(t) {
            const i = t.dataTransfer.items[0];
            if (!i || !i.getAsFileSystemHandle || !nN.zk.Lk)
                return !1;
            let e = null;
            try {
                if (e = await i.getAsFileSystemHandle(),
                !(e && e instanceof FileSystemDirectoryHandle))
                    return !1;
                if (!await nN.E0t.gqe(e, ".c3proj"))
                    return !1
            } catch (t) {
                return !1
            }
            const s = await this.T0n(e, {
                h2t: "webfs-drag-and-drop"
            });
            if (!nN.$l(s, self.gh))
                return !0;
            try {
                s.gii(e.name),
                await s.wii("webfs-local-folder", {
                    folderHandle: e
                })
            } catch (t) {
                (() => {})("Failed to set origin file system from drop: ", t)
            }
            return !0
        }
        async _0n(t, i, e) {
            const s = this.TF()
              , n = new nN.FRt;
            let r = !1
              , h = null;
            try {
                await n.HRt(t),
                r = !0,
                h = new window.SDK.IZipFile(n)
            } catch (t) {
                r = !1
            }
            for (const {vsn: n, v0n: o, S0n: a} of this.yQn) {
                if (a && !s)
                    continue;
                let l = !1
                  , u = {};
                a && (u = {
                    layoutView: s.IQ(),
                    clientX: i,
                    clientY: e,
                    layoutX: s.LK(i - s.TZ()),
                    layoutY: s.UK(e - s.kZ())
                });
                try {
                    o && r ? l = await n(t.name, h, u) : o || r || (l = await n(t.name, t, u))
                } catch (t) {
                    console.error("Error calling SDK import handler: ", t),
                    l = !1
                }
                if ("boolean" != typeof l && (() => {})(`[SDK] Import handler did not resolve with a boolean. Please make sure the callback passed to AddDragDropFileImportHandler() returns a promise that resolves with either true or false. (Returned: ${l})`),
                l)
                    break
            }
            n.YRt()
        }
        x0n() {
            nN.qs.Ys.$s("OK").Qa(hN("ui.errors.cannot-open-c2-folder-project"))
        }
        M0n() {
            nN.qs.Ys.$s("OK").Qa(hN("ui.cannot-open-folder-project"))
        }
        async I0n(t) {
            const i = t.path;
            i.toLowerCase().endsWith(".c3p") ? await this.a2t(t, {
                h2t: "desktopapp-activation"
            }) : i.toLowerCase().endsWith(".c3proj") ? this.M0n() : (() => {})("Unknown file extension to open for file: " + i)
        }
        P0n(t) {
            t.fZn || null === t.h2t || (this.Lii("OpenProjectMethod", t.h2t),
            t.h2t = null)
        }
        async G0n(t, i) {
            nN.zt(t),
            nN.Wat(i),
            i = Object.assign({}, bN, i),
            this.P0n(i),
            this.vZn.M6t(!0);
            let e = nN.qs.Ys.$s("Download");
            try {
                const s = await e.Qa(t);
                return await this.l2t(s, i)
            } catch (t) {
                return console.error("[Project] Exception opening: ", t),
                e.vwt(),
                e = nN.qs.Ys.$s("OK"),
                e.Qa(hN("ui.errors.failed-to-download-project")),
                t
            } finally {
                this.vZn.M6t(!1)
            }
        }
        async l2t(t, i) {
            nN.U(t, Blob),
            nN.Wat(i),
            i = Object.assign({}, bN, i),
            this.P0n(i),
            this.vZn.M6t(!0),
            this.uQn++;
            const e = new nN.FRt;
            if (i.L0t) {
                let t = nN.qs.Ys.$s("Progress");
                t.onprogress = () => {
                    const t = e.LRt()
                      , i = e.WRt();
                    return 0 === i ? 0 : t / i
                }
                ,
                t.Qa(hN("ui.projects.importing-caption"))
            }
            const s = performance.now();
            try {
                await e.HRt(t),
                await this.Lj(!1);
                const n = await self.gh.toi(e, !!i.duplicate);
                return n.Yii(i.fZn),
                i.L0t && nN.qs.Ys.$s("Progress").PR(),
                this.Lii("ImportC2Capx", {
                    proj_id: n.CL()
                }),
                i.fZn || await this.A0n(n, !!i.Zhi),
                nN.j_t && console.info(`[Project] Opened C2 Capx in ${performance.now() - s} ms`),
                n
            } catch (t) {
                return i.L0t && nN.qs.Ys.$s("Progress").vwt(),
                await this.R0n("ui.errors.failed-to-open-c2-project", t),
                t
            } finally {
                this.uQn--,
                e.YRt(),
                this.vZn.M6t(!1)
            }
        }
        async k0n(t, i) {
            nN.zt(t),
            nN.Wat(i),
            i = Object.assign({}, bN, i),
            this.P0n(i),
            this.vZn.M6t(!0),
            this.uQn++;
            let e = nN.qs.Ys.$s("Download");
            try {
                const s = await e.Qa(t);
                i.O0n && i.O0n(s);
                return await this.a2t(s, i)
            } catch (t) {
                return console.error("[Project] Exception opening: ", t),
                e.vwt(),
                e = nN.qs.Ys.$s("OK"),
                e.Qa(hN("ui.errors.failed-to-download-project")),
                t
            } finally {
                this.vZn.M6t(!1),
                this.uQn--
            }
        }
        async a2t(t, i) {
            nN.U(t, Blob),
            nN.Wat(i),
            i = Object.assign({}, bN, i),
            this.P0n(i),
            this.vZn.M6t(!0),
            this.uQn++;
            const e = new nN.FRt
              , s = {
                indeterminate: !1,
                duplicate: !!i.duplicate,
                Zhi: !!i.Zhi,
                Qhi: !!i.Qhi
            };
            if (i.L0t) {
                let t = nN.qs.Ys.$s("Progress");
                t.onprogress = () => {
                    if (s.indeterminate)
                        return t.Ya(hN("ui.projects.opening-caption-no-progress")),
                        null;
                    const i = e.LRt()
                      , n = e.WRt();
                    return 0 === n ? 0 : i / n
                }
                ,
                t.Qa(hN("ui.projects.opening-caption"))
            }
            const n = performance.now();
            try {
                await e.HRt(t),
                await this.Lj(!1);
                const r = await self.gh.Ohi(e, s);
                if (r.Yii(i.fZn),
                nN.g2t(t)) {
                    const i = t.name;
                    r.gii(i)
                }
                return i.fileHandle && await r.wii("webfs-single-file", {
                    fileHandle: i.fileHandle
                }),
                i.fZn || await this.A0n(r, !!i.Zhi),
                nN.j_t && console.info(`[Project] Opened C3 project in ${performance.now() - n} ms`),
                i.L0t && nN.qs.Ys.$s("Progress").PR(),
                r
            } catch (t) {
                return i.L0t && nN.qs.Ys.$s("Progress").vwt(),
                await this.R0n("ui.errors.failed-to-open-c3-project", t),
                t
            } finally {
                this.uQn--,
                e.YRt(),
                this.vZn.M6t(!1)
            }
        }
        async T0n(t, i) {
            nN.U(t, FileSystemDirectoryHandle),
            rN(nN.zk.Lk, "web filesystem not supported"),
            nN.Wat(i),
            i = Object.assign({}, bN, i),
            this.P0n(i),
            this.vZn.M6t(!0),
            this.uQn++;
            const e = {
                indeterminate: !1,
                duplicate: !1
            }
              , s = nN.qs.Ys.$s("Progress");
            s.Qa(hN("ui.projects.opening-caption-no-progress"));
            try {
                await this.Lj(!1);
                const i = await nN.E0t.gqe(t, ".c3proj")
                  , n = await i.getFile()
                  , r = nN.v(nN.oes, t)
                  , h = await self.gh.zhi(n, r, e);
                return h.gii(t.name + "/"),
                await h.wii("webfs-local-folder", {
                    folderHandle: t
                }),
                await this.A0n(h),
                await h.Hni(t),
                s.PR(),
                h
            } catch (t) {
                return s.vwt(),
                this.R0n("ui.errors.failed-to-open-c3-folder-project", t),
                t
            } finally {
                this.vZn.M6t(!1),
                this.uQn--
            }
        }
        async E0n(t, i, e) {
            const s = new nN.FRt
              , n = {
                h2t: "drag-and-drop"
            };
            try {
                if (await s.HRt(t),
                s.$Rt(".c3proj"))
                    return await this.a2t(t, n);
                const r = [...s.DKe()].filter(t => !t.filename.toLowerCase().startsWith("__macosx"))
                  , h = r.filter(t => t.filename.toLowerCase().endsWith(".c3p"));
                if (1 === h.length) {
                    const t = h[0]
                      , i = await s.JRt(t);
                    return await this.a2t(i, n)
                }
                const o = r.filter(t => t.filename.toLowerCase().endsWith(".capx"));
                if (1 === o.length) {
                    const t = o[0]
                      , i = await s.JRt(t);
                    return await this.l2t(i, n)
                }
                this._0n(t, i, e)
            } catch (t) {
                this.R0n("ui.errors.failed-to-open-c3-project", t)
            } finally {
                s.YRt()
            }
        }
        R0n(t, i) {
            if ("missing-addons" === i.type) {
                return nN.qs.Ys.$s("MissingAddons").Qa({
                    dni: i.dni,
                    Nhi: i.Nhi
                })
            }
            if ("saved-with-future-release" === i.type) {
                const t = nN.o_.Lhi
                  , e = nN.Vhi(i.Bhi)
                  , s = nN.nDn(i.Bhi);
                return nN.qs.Ys.$s("OK").Qa(nN.v(nN.MC, lN("ui.errors.project-saved-in-newer-release", e, t), {
                    links: [location.origin + "/" + s]
                }))
            }
            if ("expression-name-collision" === i.type) {
                const t = i.El
                  , e = i.name
                  , s = i.Cos
                  , n = t.yn().qds()
                  , r = nN.Vhi(n)
                  , h = nN.nDn(n)
                  , o = nN.p.Ok("ui.errors.expression-name-collision")
                  , a = nN.qs.Ys.$s("OK");
                return a.Ya(o(".title")),
                a.Qa(nN.v(nN.MC, o.oj(".message", t.Fa(), o(".types." + s), e, t.Ja().Fa(), r), {
                    links: [location.origin + "/" + h]
                }))
            }
            if ("invalid-spaces-in-name" === i.type) {
                return nN.qs.Ys.$s("OK").Qa(nN.v(nN.MC, lN("ui.errors.invalid-spaces-in-name", i.path), {
                    links: ["https://www.construct.net/tutorials/fix-open-project-errors-due-3139"]
                }))
            }
            console.error("[Project] Exception opening: ", i);
            return nN.qs.Ys.$s("OK").Qa({
                message: hN(t),
                HZe: !0
            })
        }
        Aoi(t) {
            nN.zt(t);
            for (let i of this.zZn)
                if (i.CL() === t)
                    return !0;
            return !1
        }
        tj() {
            return nN.qs.Ys.$s("NewProject").Qa()
        }
        vWn(t, i="event-sheet") {
            return this.LD(this.D0n(t, i))
        }
        async D0n(t, i) {
            this.vZn.M6t(!0),
            await this.Lj(!0);
            try {
                nN.X_t(t),
                nN.zt(i);
                const e = nN.v(self.gh);
                let s = null;
                if ("event-sheet" === i)
                    s = nN.v(self.lF, e),
                    e.eN().cR(s);
                else if ("javascript" === i)
                    self.c_.rL(e);
                else {
                    if ("typescript" !== i)
                        throw new Error("invalid parameter");
                    self.c_.hL(e)
                }
                const n = nN.v(self.fA, e)
                  , r = nN.v(self.TR, n);
                r.FR(!1),
                n.BR().cR(r),
                e.tN().cR(n),
                s && n._R(s);
                const h = e.gL(e.sN())
                  , o = e.YL(e.nN())
                  , a = this.hj().EDt();
                if (a && (a.xDt("<first-layout>", n),
                s && a.xDt("<first-event-sheet>", s),
                a.xDt("<first-layer>", r),
                a.xDt("<first-timeline>", h),
                a.xDt("<first-flowchart>", o)),
                "animation" === this.QPe()) {
                    const t = nN.Di.Jm("Timeline")
                      , i = t.ZA(e, t.Fa());
                    await i.Mfs(),
                    e.zH().cR(i)
                }
                const l = this.r0();
                e.B(l.defaultProjectAuthor),
                e.Rte(l.defaultProjectEmail),
                e.Hte(l.defaultProjectWebsite),
                await e.zni(),
                t && t(e),
                e.Pii(),
                await this.A0n(e, !0, !1)
            } catch (t) {
                console.error("Error creating new project: ", t);
                nN.qs.Ys.$s("OK").Qa(hN("ui.errors.failed-to-create-project"))
            } finally {
                this.vZn.M6t(!1)
            }
        }
        async A0n(t, i=!1, e=!0) {
            if (nN.U(t, self.gh),
            rN(!t.kx(), "project still loading"),
            this.zZn.includes(t))
                throw new Error("project already open");
            if (1 === this.zZn.length && await this.F0n(this.zZn[0]),
            this.r0().autoHideStartPage && this.RZn.Cj(),
            this.zZn.push(t),
            this.yii(t, "projectopen"),
            await this.L0n(t, "afterprojectopen"),
            e && t.Nii(),
            self.app.Qh() && this.MZn.mR(!0),
            i)
                if (this.vZn.$6t(t)) {
                    let i = this.vZn.k6t(t)
                      , e = this.vZn.q6t(t);
                    i ? await this.B0n(i) : e ? await this.U0n(e) : await this.B0n(t.Jte() || t.vds())
                } else
                    await this.B0n(t.Jte() || t.vds());
            else
                this.vZn.$6t(t) || await this.B0n(t.Jte() || t.vds());
            self.app.Qh() && this.MZn.mR(!1),
            await nN.qs.Jj.TN.aEe(t),
            this.N0n() && [...t.MDt()].length && !nN.Vl && this.j0n(t)
        }
        async B0n(t) {
            if (!t)
                return;
            const i = await this.HR(t)
              , e = t.$R();
            if (e)
                this.GR(e);
            else {
                const i = nN.eu(t.yn().Eni())
                  , e = this.DA();
                i && !e.S7t(i) && await self.c_.oL(i)
            }
            i && this.t0(i.dH())
        }
        async U0n(t) {
            if (!t)
                return;
            const i = this.GR(t)
              , e = t.qm();
            e && await this.HR(e),
            this.t0(i.dH())
        }
        async sj(t) {
            nN.zk.Lk ? await this.$0n() : await this.z0n(t)
        }
        async $0n() {
            let t = null;
            try {
                [t] = await window.showOpenFilePicker({
                    multiple: !1,
                    id: "open-project-file",
                    types: [{
                        description: hN("ui.project-file-picker.c3-and-c2-single-file-projects"),
                        accept: {
                            "application/x-construct-project": [".c3p", ".capx"]
                        }
                    }, {
                        description: hN("ui.project-file-picker.c3-single-file-project"),
                        accept: {
                            "application/x-construct3-project": [".c3p"]
                        }
                    }, {
                        description: hN("ui.project-file-picker.c2-single-file-project"),
                        accept: {
                            "application/x-construct2-project": [".capx"]
                        }
                    }]
                })
            } catch (t) {
                return
            }
            try {
                const i = await t.getFile()
                  , e = i.name.toLowerCase();
                if (e.endsWith(".c3p")) {
                    const e = await this.a2t(i, {
                        h2t: "webfs-file-picker"
                    });
                    if (!nN.$l(e, self.gh))
                        return;
                    e.gii(i.name),
                    await e.wii("webfs-single-file", {
                        fileHandle: t
                    })
                } else if (e.endsWith(".capx"))
                    this.l2t(i, {
                        h2t: "webfs-file-picker"
                    });
                else {
                    if (e.endsWith(".c3proj"))
                        return void this.M0n();
                    nN.qs.Ys.$s("OK").Qa(hN("ui.errors.unknown-file-extension"))
                }
            } catch (t) {
                this.R0n("ui.errors.failed-to-open-c3-project", t),
                console.error("File read error: ", t)
            }
        }
        async z0n(t) {
            const i = await nN.qs.Qyi.tbi(".c3p,.c3proj,.capx,.caproj", t, !1, !1);
            if (null === i)
                return;
            const e = {
                h2t: "file-picker"
            };
            if (i.name.toLowerCase().endsWith(".c3p"))
                this.a2t(i, e);
            else if (i.name.toLowerCase().endsWith(".capx"))
                this.l2t(i, e);
            else if (i.name.toLowerCase().endsWith(".caproj"))
                this.x0n();
            else if (i.name.toLowerCase().endsWith(".c3proj"))
                this.M0n();
            else {
                nN.qs.Ys.$s("OK").Qa(hN("ui.errors.unknown-file-extension"))
            }
        }
        async nj() {
            let t = null;
            try {
                t = await window.showDirectoryPicker({
                    id: "open-project-folder",
                    mode: "readwrite"
                })
            } catch (t) {
                return
            }
            this.T0n(t, {
                h2t: "webfs-folder-picker"
            })
        }
        async ej(t, i=!1) {
            if (rN(!t.kx(), "project still loading"),
            t.NF())
                return;
            if (t.TA() && !i) {
                const i = nN.qs.Ys.$s("ConfirmMultiple")
                  , e = await i.Qa({
                    message: lN("ui.unsaved-project-warning", t.Fa()),
                    options: [{
                        text: hN("ui.save-and-close"),
                        tag: "save"
                    }, {
                        text: hN("ui.dont-save"),
                        tag: "discard"
                    }],
                    PD: !0
                }, document.body);
                if (null === e)
                    return "cancelled";
                if ("save" === e) {
                    if (null === await self.app.Vk(t))
                        return "cancelled"
                }
            }
            if (t.NF())
                return;
            self.app.Y5t(),
            t.oii(),
            this.yii(t, "projectclose"),
            this.dT() === t && this.KF(null);
            const e = this.zZn.indexOf(t);
            e >= 0 && this.zZn.splice(e, 1),
            this.yii(t, "afterprojectclose"),
            this.Qh() && this.Zh().tC(),
            t.he(),
            nN.lj.I$n(t)
        }
        async V0n() {
            if (this.zZn.length) {
                const t = await this.ej(this.zZn[0]);
                return "cancelled" === t ? t : this.V0n()
            }
        }
        async F0n(t) {
            nN.U(t, self.gh);
            const i = self.app
              , e = "close-existing-project-dont-ask-again";
            if (await localforage.getItem(e))
                return;
            i.Lii("CloseExistingProjectPrompt", "Shown"),
            nN.p.u("ui.confirm-open-second-project-prompt");
            const s = nN.qs.Ys.$s("ConfirmCheck")
              , n = s.Qa({
                caption: hN(".caption"),
                message: hN(".message"),
                jD: hN(".close-project"),
                vD: hN(".open-both"),
                lQe: hN("common.dont-ask-again")
            });
            nN.p.j();
            if (null === await n) {
                if (s.dQe()) {
                    i.Lii("CloseExistingProjectPrompt", "Cancelled-DontAskAgain");
                    try {
                        await localforage.setItem(e, !0)
                    } catch (t) {
                        (() => {})('Failed to save "Don\'t ask again" preference: ', t)
                    }
                } else
                    i.Lii("CloseExistingProjectPrompt", "Cancelled");
                return
            }
            const r = await this.ej(t);
            i.Lii("CloseExistingProjectPrompt", "cancelled" === r ? "Cancelled-ClosingProject" : "Confirmed")
        }
        *PA() {
            for (let t of this.zZn)
                yield t
        }
        a7t() {
            return this.zZn.length
        }
        W0n() {
            return this.lQn > 0
        }
        H0n() {
            return this.uQn > 0
        }
        async K0n(t, i) {
            nN.U(t, self.gh),
            i = !!i,
            rN(!t.kx(), "project still loading");
            const e = new nN.FRt;
            let s;
            i || (s = nN.qs.Ys.$s("Progress"),
            s.onprogress = () => {
                let t = e._Pe()
                  , i = e.xPe();
                return 0 === i ? null : t / i
            }
            ,
            s.Qa());
            try {
                const i = await t.Phi()
                  , s = await e.yLt(i.khi);
                if (0 === s.size)
                    throw new Error("project save is zero size");
                return s
            } catch (t) {
                throw console.error("[Project] Exception saving project to blob: ", t),
                t
            } finally {
                i || s.PR()
            }
        }
        async qk(t, i) {
            nN.U(t, self.gh);
            const e = t.Fa() + ".c3p";
            let s = e;
            if (i) {
                nN.p.u("ui.save-download-name-prompt");
                const t = nN.qs.Ys.$s("Input").Qa({
                    caption: hN(".caption"),
                    message: hN(".message"),
                    label: hN(".label"),
                    c0e: e
                });
                nN.p.j();
                const i = await t;
                if (null === i)
                    return;
                "string" == typeof i && i && (s = i,
                s.toLowerCase().endsWith(".c3p") || (s += ".c3p"))
            }
            this.lQn++;
            try {
                const i = await this.K0n(t);
                await nN._Lt(s, i),
                t.vii(),
                this.Lii("SaveProjectMethod", "download")
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                nN.qs.Ys.$s("OK").Qa(hN("ui.save-error"))
            } finally {
                this.lQn--
            }
        }
        async Rk(t) {
            nN.U(t, self.gh),
            this.lQn++;
            try {
                return await self.jk.Zht(t)
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                nN.qs.Ys.$s("OK").Qa(hN("ui.save-error"))
            } finally {
                this.lQn--
            }
        }
        async Xk(t) {
            nN.U(t, self.gh),
            this.lQn++;
            try {
                return await self.jk.Zht(t, !0)
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                nN.qs.Ys.$s("OK").Qa(hN("ui.save-error"))
            } finally {
                this.lQn--
            }
        }
        async q0n(t) {
            nN.U(t, self.gh),
            rN(nN.zk.Lk, "web filesystem not supported"),
            rN("webfs-single-file" === t.kB(), "expected webfs-single-file project"),
            this.lQn++;
            try {
                const i = t.xB();
                if (!i)
                    throw new Error("missing metadata");
                const e = i.fileHandle;
                if (!e)
                    throw new Error("missing file handle");
                let s = await e.queryPermission({
                    mode: "readwrite"
                });
                if ("denied" === s)
                    throw new Error("file write permission denied");
                if ("prompt" === s && (s = await e.requestPermission({
                    mode: "readwrite"
                }),
                "granted" !== s))
                    throw new Error("file write permission denied");
                const n = await this.K0n(t);
                await nN.E0t.B0t(e, n),
                await t.wii("webfs-single-file", i),
                t.vii(),
                this.Lii("SaveProjectMethod", "webfs-local-file")
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                nN.qs.Ys.$s("OK").Qa(hN("ui.save-error"))
            } finally {
                this.lQn--
            }
        }
        async Wk(t) {
            if (nN.U(t, self.gh),
            rN(nN.zk.Lk, "web filesystem not supported"),
            await this.X0n())
                return;
            let i = null;
            try {
                i = await window.showSaveFilePicker({
                    id: "save-project-file",
                    types: [{
                        description: hN("ui.project-file-picker.c3-single-file-project"),
                        accept: {
                            "application/x-construct3-project": [".c3p"]
                        }
                    }]
                })
            } catch (t) {
                return
            }
            this.lQn++;
            try {
                t.Kii();
                const e = await this.K0n(t);
                await nN.E0t.B0t(i, e),
                t.gii(i.name),
                await t.wii("webfs-single-file", {
                    fileHandle: i
                }),
                t.vii(),
                this.Lii("SaveProjectMethod", "webfs-local-file")
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                nN.qs.Ys.$s("OK").Qa(hN("ui.save-error"))
            } finally {
                this.lQn--
            }
        }
        async Y0n(t) {
            nN.U(t, self.gh),
            rN(nN.zk.Lk, "web filesystem not supported"),
            rN("webfs-local-folder" === t.kB(), "expected webfs-local-folder project"),
            this.lQn++;
            let i = null;
            try {
                const e = t.xB();
                if (!e)
                    throw new Error("missing metadata");
                const s = e.folderHandle;
                if (!s)
                    throw new Error("missing folder handle");
                await nN.E0t.pqe(s);
                let n = -1;
                const r = (t, i) => n = t / i;
                i = nN.qs.Ys.$s("Progress"),
                i.onprogress = () => -1 === n ? null : n,
                i.Qa();
                const h = await t.Phi({
                    kgs: "save"
                })
                  , o = h.khi
                  , a = h.Fhi
                  , l = h.Thi;
                await nN.E0t.mqe(s, a),
                await nN.E0t.wqe(s, l),
                await nN.E0t.PPs(s, o, r, !0),
                n = -1,
                t.gii(s.name + "/"),
                await t.wii("webfs-local-folder", e),
                i.PR(),
                t.vii(),
                this.Lii("SaveProjectMethod", "webfs-local-folder")
            } catch (t) {
                console.error("[Project] Exception saving: ", t),
                i && i.vwt();
                nN.qs.Ys.$s("OK").Qa(hN("ui.save-error"))
            } finally {
                this.lQn--
            }
        }
        async $k(t) {
            if (nN.U(t, self.gh),
            rN(nN.zk.Lk, "web filesystem not supported"),
            await this.X0n())
                return;
            let i = null;
            try {
                i = await window.showDirectoryPicker({
                    id: "save-project-folder",
                    mode: "readwrite"
                })
            } catch (t) {
                return
            }
            let e = null;
            try {
                await nN.E0t.pqe(i);
                let s = -1;
                const n = (t, i) => s = t / i;
                e = nN.qs.Ys.$s("Progress"),
                e.onprogress = () => -1 === s ? null : s,
                e.Qa(),
                this.lQn++,
                t.Kii();
                const r = await t.Phi({
                    kgs: "save-as"
                });
                r.khi.set(".gitignore", "*.uistate.json\nts-defs"),
                await nN.E0t.PPs(i, r.khi, n),
                t.gii(i.name + "/"),
                await t.wii("webfs-local-folder", {
                    folderHandle: i
                }),
                e.PR(),
                t.vii(),
                this.Lii("SaveProjectMethod", "webfs-local-folder")
            } catch (t) {
                console.error("[Project] Exception saving: ", t),
                e && e.vwt();
                nN.qs.Ys.$s("OK").Qa(hN("ui.save-error"))
            } finally {
                this.lQn--
            }
        }
        async Vk(t) {
            if (nN.Mw(t, self.gh),
            !t)
                return;
            if (nN.Lat() && (document.activeElement.blur(),
            await nN.Mme()),
            t.Tgs()) {
                return void nN.qs.Ys.$s("OK").Qa(hN("ui.save-busy-autosaving"))
            }
            const i = t.zii();
            if (null !== i) {
                const e = nN.qs.Ys.$s("Confirm")
                  , s = oN("ui.save-autosave-to-original", i.name);
                if (!await e.Qa({
                    message: s
                }))
                    return;
                t.gii(i.name),
                await t.wii(i.mode, i.meta),
                t.Kii()
            }
            switch (t.kB()) {
            case "cloud":
                return self.jk.J0n(t);
            case "webfs-single-file":
                return this.q0n(t);
            case "webfs-local-folder":
                return this.Y0n(t);
            default:
                switch (this.r0().defaultSaveLocation) {
                case "cloud":
                default:
                    return this.Rk(t);
                case "local-browser":
                    return this.Xk(t);
                case "download":
                    return this.qk(t, !0);
                case "save-as":
                    return nN.zk.Lk ? this.Wk(t) : this.Rk(t)
                }
            }
        }
        async X0n() {
            if (this.r0().autoSave)
                return !1;
            let t = !1
              , i = await localforage.getItem("local-file-save-count");
            if (("number" != typeof i || i >= 10) && (i = 0,
            t = !0),
            localforage.setItem("local-file-save-count", i + 1).catch(t => this.OA(t)),
            t) {
                this.Lii("PromptToSetUpBackupsDlg", "Shown");
                const t = nN.qs.Ys.$s("Confirm")
                  , i = nN.p.Ok("ui.configure-backups-prompt")
                  , e = await t.Qa({
                    caption: i(".caption"),
                    message: nN.v(nN.MC, i(".message"), {
                        links: [ () => this.s_("tips-and-guides/best-practices")]
                    }),
                    jD: i(".open-settings"),
                    vD: i(".save-anyway")
                });
                return e ? (this.Lii("PromptToSetUpBackupsDlg", "OpenSettings"),
                nN.qs.Ys.$s("Settings").Qa(null, "backup")) : this.Lii("PromptToSetUpBackupsDlg", "SaveAnyway"),
                !!e
            }
            return !1
        }
        async Z0n(t) {
            const i = t.system;
            let e, s;
            this.uQn++;
            try {
                switch (i) {
                case "cloud":
                    return await self.jk.Q0n(t);
                case "webfs-single-file":
                    const n = t.ref.fileHandle;
                    if (s = await n.requestPermission({
                        mode: "readwrite"
                    }),
                    "granted" !== s)
                        throw new Error("user declined permission");
                    return e = await n.getFile(),
                    await this.a2t(e, {
                        fileHandle: n,
                        h2t: "webfs-recent-project-file"
                    });
                case "webfs-local-folder":
                    const r = t.ref.folderHandle;
                    if (s = await r.requestPermission({
                        mode: "readwrite"
                    }),
                    "granted" !== s)
                        throw new Error("user declined permission");
                    return await this.T0n(r, {
                        h2t: "webfs-recent-project-folder"
                    });
                default:
                    throw new Error(`bad origin ${i}`)
                }
            } finally {
                this.uQn--
            }
        }
        fqn() {
            for (const t of this.zZn)
                nN.zk.Lk ? this.Wk(t) : this.qk(t, !1)
        }
        xQn(t) {
            if (!nN.Vl) {
                if (this.W0n()) {
                    const i = hN("ui.still-saving-warning");
                    return t.returnValue = i,
                    i
                }
                if (self.jk.t1n()) {
                    const i = hN("ui.still-saving-warning");
                    return t.returnValue = i,
                    i
                }
                for (let i of this.zZn)
                    if (i.TA()) {
                        let e = lN("ui.unsaved-changes-warning", i.Fa());
                        return t.returnValue = e,
                        e
                    }
            }
        }
        qQn() {
            if (nN.kt.mj && nN.qs.RW.l4e())
                return nN.qs.RW.u4e(!1),
                void Promise.resolve().then( () => nN.wHe.cR( () => this.qQn(), "app"));
            if (0 === this.a7t())
                return void nN.wHe.mHe();
            nN.p.u("ui.back-confirmation");
            nN.qs.Ys.$s("Confirm").Qa({
                caption: hN(".caption"),
                message: hN(".message"),
                jD: hN(".go-back"),
                vD: hN(".stay"),
                sQe: !0
            }).then(t => {
                null === t ? Promise.resolve().then( () => nN.wHe.cR( () => this.qQn())) : nN.wHe.mHe()
            }
            ),
            nN.p.j()
        }
        Kk(t, i="auto") {
            if (nN.Mw(t, self.gh),
            t && !this.H0n() && !this.W0n() && (t.IN() || !nN.qs.HY.DY()))
                return this.qAe(t, t.Jte() || t.vds(), {
                    ZAe: i
                })
        }
        Qk(t) {
            if (nN.Mw(t, self.gh),
            t && !this.H0n() && !this.W0n() && !nN.qs.HY.DY()) {
                if (!(window.RTCDataChannel || window.webkitRTCDataChannel || window.mozRTCDataChannel || window.msRTCDataChannel)) {
                    return void nN.qs.Ys.$s("OK").Qa(hN("ui.errors.remote-preview-not-supported"))
                }
                return this.qAe(t, t.Jte() || t.vds(), {
                    rPe: !0
                })
            }
        }
        Yk(t, i="auto") {
            if (nN.Mw(t, self.gh),
            t && !this.H0n() && !this.W0n() && !nN.qs.HY.DY())
                return this.qAe(t, t.Jte() || t.vds(), {
                    Vl: !0,
                    ZAe: i
                })
        }
        AA(t, i="auto") {
            if (nN.Mw(t, self.fA),
            !(this.H0n() || this.W0n() || nN.qs.HY.DY())) {
                if (t || (t = this.zs().Y0()) && t.yn() !== this.dT() && (t = null),
                !t) {
                    const i = this.dT();
                    i && (t = i.vds())
                }
                if (t)
                    return this.qAe(t.yn(), t, {
                        ZAe: i
                    })
            }
        }
        IA(t, i="auto") {
            if (nN.Mw(t, self.fA),
            !(this.H0n() || this.W0n() || nN.qs.HY.DY())) {
                if (t || (t = this.zs().Y0()) && t.yn() !== this.dT() && (t = null),
                !t) {
                    const i = this.dT();
                    i && (t = i.vds())
                }
                if (t)
                    return this.qAe(t.yn(), t, {
                        Vl: !0,
                        ZAe: i
                    })
            }
        }
        qAe(t, i, e) {
            nN.U(t, self.gh),
            nN.U(i, self.fA),
            nN.Wat(e);
            if (e = Object.assign({}, {
                Vl: !1,
                rPe: !1,
                ZAe: !1,
                ePe: null
            }, e),
            i.yn() !== t)
                throw new Error("first layout from wrong project");
            return "auto" === e.ZAe && (e.ZAe = nN.OF.PF(nN.kE.OZ)),
            e.ZAe = !!e.ZAe,
            this.H0n() || this.W0n() || nN.qs.HY.LYe() && !e.ePe ? Promise.resolve(null) : (this.sY(),
            nN.Ars.qAe(t, i, e))
        }
        async Zk(t) {
            if (nN.Mw(t, self.gh),
            t && !this.H0n() && !this.W0n() && !nN.qs.HY.DY())
                try {
                    await nN.Ars.lPe(t)
                } catch (t) {
                    if (console.error("Error exporting: ", t),
                    t && "remote-minify-error" === t.type) {
                        nN.qs.Ys.$s("OK").Qa(hN("ui.errors.failed-remote-minify"))
                    } else if (t && "minify-error" === t.type) {
                        nN.qs.Ys.$s("MinifyError").Qa(t.log)
                    } else {
                        nN.qs.Ys.$s("OK").Qa(hN("ui.errors.failed-to-export"))
                    }
                }
        }
        i1n(t, i) {
            return nN.U(t, self.gh),
            nN.Yq(i),
            this.qAe(t, t.Jte() || t.vds(), {
                ePe: i
            })
        }
        async F_(t) {
            t = Object.assign({}, vN, t);
            const i = nN.qs.HY.N$i();
            if (nN.qs.HY.IJi() && i && !i.Cwt())
                return;
            const e = nN.Lat();
            if (!t.xis && e && document.activeElement && !nN.jgt(document.activeElement, ["ui-propertygrid"]))
                return void this.QZn.Ffn();
            const s = this.dT();
            if (!s)
                return;
            const n = this.DA();
            if (!t.pZn) {
                const t = n.VA(nN.qs.iA.RA());
                if (t) {
                    if (t.LA())
                        return void t.F_();
                    if (!t.x7t() && t.P7t())
                        return void n.wp(t.jSt())
                }
            }
            if (!s.$ei())
                return;
            if (!s.Lei())
                return;
            await this.opi();
            const r = (async () => {
                if (await this.e1n("beforeundo"),
                s.GOt())
                    return;
                const t = this.zs()
                  , i = t.DV();
                i && t.W0(!1);
                const e = await s.F_();
                return i && t.W0(!0),
                await this.e1n("afterundo"),
                s.rU(),
                e
            }
            )()
              , h = await this.LD(r);
            h && (t.showNotification && nN.qs.Notification.nF("undo", hN("main-menu.undo"), h.Fa(), {
                align: "bottom-left",
                C6i: nN.qs.HY.IJi()
            }),
            this.J_s())
        }
        async K_(t) {
            t = Object.assign({}, vN, t);
            const i = nN.qs.HY.N$i();
            if (nN.qs.HY.IJi() && i && !i.Cwt())
                return;
            const e = nN.Lat();
            if (!t.xis && e && document.activeElement && !nN.jgt(document.activeElement, ["ui-propertygrid"]))
                return void this.QZn.Ffn();
            const s = this.dT();
            if (!s)
                return;
            const n = this.DA();
            if (!t.pZn) {
                const t = n.VA(nN.qs.iA.RA());
                if (t && t.zA())
                    return void t.K_()
            }
            if (!s.$ei())
                return;
            if (!s.Bei())
                return;
            await this.opi();
            const r = (async () => {
                if (await this.e1n("beforeundo"),
                s.GOt())
                    return;
                const t = this.zs()
                  , i = t.DV();
                i && t.W0(!1);
                const e = await s.K_();
                return i && t.W0(!0),
                await this.e1n("afterundo"),
                s.rU(),
                e
            }
            )()
              , h = await this.LD(r);
            h && (t.showNotification && nN.qs.Notification.nF("redo", hN("main-menu.redo"), h.Fa(), {
                align: "bottom-left",
                C6i: nN.qs.HY.IJi()
            }),
            this.J_s())
        }
        async _A(t) {
            nN.Ge(t),
            t <= 0 || (await this.oQi(t),
            nN.qs.Notification.nF("undo", hN("main-menu.undo"), aN("main-menu.undo-multiple-changes", null, t), {
                align: "bottom-left",
                C6i: nN.qs.HY.IJi()
            }))
        }
        async oQi(t) {
            if (nN.Ge(t),
            !(t <= 0))
                return t--,
                await this.F_({
                    showNotification: !1,
                    pZn: !0
                }),
                this.oQi(t)
        }
        async SA(t) {
            nN.Ge(t),
            t <= 0 || (await this.wQi(t),
            nN.qs.Notification.nF("redo", hN("main-menu.undo"), aN("main-menu.redo-multiple-changes", null, t), {
                align: "bottom-left",
                C6i: nN.qs.HY.IJi()
            }))
        }
        async wQi(t) {
            if (nN.Ge(t),
            !(t <= 0))
                return t--,
                await this.K_({
                    showNotification: !1,
                    pZn: !0
                }),
                this.wQi(t)
        }
        B$() {
            for (let t of this.zZn)
                t.B$()
        }
        mjs(t) {
            nN.U(t, window.fA);
            let i = self.app.zs().Rq(t);
            i && i.uz()
        }
        KI(t) {
            nN.U(t, window.Vb),
            t.xJ() ? this.mjs(t.kq().qm()) : this.mjs(t.qm())
        }
        Fs() {
            this.zs().Fs(),
            this.Qh() && this.Zh().uu()
        }
        J_s() {
            this.zs().Fs(),
            this.Qh() && this.Zh().Kh()
        }
        KF(t) {
            if (nN.Mw(t, self.gh),
            this.xP !== t) {
                if (t && !this.zZn.includes(t))
                    throw new Error("invalid active project");
                this.yii(this.xP, "beforeprojectactive"),
                this.xP = t,
                this.oei(),
                this.yii(this.xP, "projectactive")
            }
        }
        Fa() {
            return this.QVn() ? lN("ui.title-beta", super.Fa()) : this.NQn() ? lN("ui.title-lts", super.Fa()) : super.Fa()
        }
        oei() {
            let t;
            t = "Chromium" === nN.kt.NRe && "standalone" === nN.Xke() ? this.xP ? this.xP.Fa() : "animation" === this.QPe() ? hN("ui.title-make-animations") : hN("ui.title-make-games") : this.xP ? this.xP.Fa() + " - " + this.Fa() : "animation" === this.QPe() ? this.Fa() + " - " + hN("ui.title-make-animations") : this.Fa() + " - " + hN("ui.title-make-games"),
            document.title = t
        }
        dT() {
            return this.zZn.length ? 1 === this.zZn.length ? this.zZn[0] : this.xP ? this.xP : this.zZn.length ? this.zZn[0] : null : null
        }
        ye() {
            this.aQn = !0,
            this.oQn = performance.now()
        }
        ZQ() {
            return this.aQn
        }
        KV() {
            return this.aQn ? performance.now() - this.oQn : 0
        }
        sY() {
            this.aQn = !1,
            this.Mgt("livepreviewstop")
        }
        async wZn() {
            if (await this.JN()) {
                const t = this.dT();
                t && t.pKs()
            } else
                this.Y5t();
            this.dispatchEvent(new nN.Event("accountstatechange"))
        }
        QPe() {
            return MN
        }
        UZs(t) {
            return nN.zt(t),
            !t || "all" === t || MN === t
        }
        k_() {
            return CN === SN
        }
        JN() {
            return Promise.resolve(CN === SN)
        }
        HVn() {
            return TN
        }
        Rj() {
            return "animation" !== this.QPe()
        }
        jQn() {
            if ("gamejam" !== this.LWn())
                return Promise.resolve();
            if (!UN)
                return Promise.resolve();
            const t = UN.name
              , i = new Date(1e3 * IN);
            nN.p.u("user-account.gamejam-license-warning");
            const e = nN.qs.Ys.$s("OK");
            e.Ya(hN(".title"));
            const s = e.Qa(oN(".message", i.toLocaleDateString(self.app.iwt(), {
                weekday: "long",
                day: "numeric",
                month: "long",
                year: "numeric"
            }), t));
            return nN.p.j(),
            s
        }
        s1n() {
            if (!PN)
                return Promise.resolve();
            nN.p.u("user-account.subscription-suspended-notification");
            const t = nN.qs.Ys.$s("OK");
            t.Ya(hN(".title"));
            const i = t.Qa(oN(".message", GN));
            return nN.p.j(),
            i
        }
        LWn() {
            return TN ? "access-code" : CN
        }
        ske() {
            return _N
        }
        FWn() {
            return IN
        }
        jU() {
            return RN
        }
        pkt() {
            return Promise.resolve(RN)
        }
        Fk() {
            return kN
        }
        async Jk(t) {
            if (nN.U(t, self.gh),
            !this.Fk())
                return;
            const i = t.Fa() + ".c3p";
            let e = i;
            const s = nN.p.Ok("ui.share-with-sub-admin-prompt")
              , n = nN.qs.Ys.$s("Input")
              , r = await n.Qa({
                caption: s(".caption"),
                message: nN.v(nN.MC, s(".message"), {
                    O0: !0,
                    links: [nN.o_.URL.NOn]
                }),
                label: s(".label"),
                c0e: i
            });
            if (null === r)
                return;
            "string" == typeof r && r && (e = r,
            e.toLowerCase().endsWith(".c3p") || (e += ".c3p")),
            this.lQn++;
            let h = null
              , o = 0;
            try {
                const i = await this.K0n(t);
                if (o = i.size,
                i.size > 104857600)
                    throw {
                        responseCode: "FileTooLarge"
                    };
                h = this.n1n(s(".progress-status")),
                h.zan(0);
                const n = await this.zj("useraccount").r1n(i, e, this.HVn(), t => {
                    h && h.zan(t)
                }
                );
                if (!n.succeeded)
                    throw n;
                nN.qs.Notification.nF("share-arrow", s(".completed.title"), s(".completed.message"), {
                    align: "bottom-left",
                    z7t: 1e4
                }),
                this.Lii("SaveProjectMethod", "share-with-admin")
            } catch (t) {
                console.error("[Project] Error sharing with subscription admin: ", t);
                let i = "";
                if (t && t.responseCode) {
                    const e = t.responseCode;
                    i = "FileTooLarge" === e ? s.oj(".errors.file-too-large", nN.Iye(o)) : "SubscriptionExpired" === e ? s(".errors.subscription-expired") : s.hDt(".errors.failed", e)
                } else
                    i = s.hDt(".errors.failed", "unknown error");
                nN.qs.Ys.$s("OK").Qa(i)
            } finally {
                this.lQn--,
                h && h.he()
            }
        }
        eAt() {
            return ON
        }
        rri() {
            return 1 / 0
        }
        UVt() {
            return DN
        }
        iri() {
            return FN
        }
        sL() {
            return LN
        }
        j_(t, i) {
            return nN.Ge(i),
            nN.Mw(t, self.gh),
            new Promise(e => {
                window.setTimeout( () => this.h1n(t, i), 20)
            }
            )
        }
        h1n(t, i) {
            nN.qs.Ys.$s("FreeEditionLimit").Qa(t, i)
        }
        gU(t, i) {
            return nN.U(t, self.gh),
            nN.Ge(i),
            new Promise(e => {
                window.setTimeout( () => this.o1n(t, i).then(e), 20)
            }
            )
        }
        o1n(t, i) {
            return nN.qs.Ys.$s("ScriptingFeatureLimit").Qa(t, i)
        }
        Mgt(t) {
            nN.zt(t);
            const i = new nN.Event(t);
            i.app = this,
            this.dispatchEvent(i)
        }
        async JKe(t) {
            nN.zt(t);
            const i = new nN.Event(t);
            i.app = this,
            await this.eze(i)
        }
        async e1n(t) {
            nN.zt(t);
            const i = new nN.Event(t);
            i.app = this,
            await this.oWt(i)
        }
        yii(t, i) {
            if (nN.Mw(t, self.gh),
            nN.zt(i),
            t && t.kx())
                return;
            let e = new nN.Event(i);
            e.sx = t,
            this.dispatchEvent(e)
        }
        async L0n(t, i) {
            if (nN.Mw(t, self.gh),
            nN.zt(i),
            t && t.kx())
                return;
            let e = new nN.Event(i);
            e.sx = t,
            await this.oWt(e)
        }
        Mvt(t, i) {
            if (nN.U(t, self.kF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.VP = t,
            this.dispatchEvent(e)
        }
        oJs(t, i) {
            if (nN.U(t, self.fA),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.layout = t,
            this.dispatchEvent(e)
        }
        lHs(t, i) {
            if (nN.U(t, self.oF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.KP = t,
            this.dispatchEvent(e)
        }
        WVt(t, i, e) {
            if (nN.U(t, self.TR),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.$Z = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        Hzs(t, i) {
            if (nN.U(t, self.z$s),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.a1n = t,
            this.dispatchEvent(e)
        }
        lWs(t, i) {
            if (nN.U(t, self.lF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.XP = t,
            this.dispatchEvent(e)
        }
        EWs(t, i) {
            if (nN.U(t, self.fF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.QP = t,
            this.dispatchEvent(e)
        }
        Bcs(t, i) {
            if (nN.U(t, self.EF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.El = t,
            this.dispatchEvent(e)
        }
        lps(t, i) {
            if (nN.U(t, self.aD),
            nN.zt(i),
            t.yn().kx())
                return;
            const e = new nN.Event(i);
            e.qO = t,
            this.dispatchEvent(e)
        }
        rcs(t, i, e) {
            if (nN.U(t, self.Yls),
            nN.Mw(i, self.EF),
            nN.zt(e),
            t.yn().kx())
                return;
            let s = new nN.Event(e);
            s.container = t,
            s.El = i,
            this.dispatchEvent(s)
        }
        lT(t, i, e) {
            if (nN.U(t, self.AM),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.i3 = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        kos(t, i) {
            if (nN.U(t, self.yte),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.Aee = t,
            this.dispatchEvent(e)
        }
        das(t, i) {
            if (nN.U(t, self.bte),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.akt = t,
            this.dispatchEvent(e)
        }
        hls(t, i) {
            if (nN.U(t, self.gte),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.Ree = t,
            this.dispatchEvent(e)
        }
        ams(t, i, e) {
            if (nN.U(t, self.gy),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.animation = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        Lds(t, i) {
            if (nN.U(t, self.Iw),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.yw = t,
            this.dispatchEvent(e)
        }
        cms(t, i) {
            if (nN.U(t, self.nfs),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.l1n = t,
            this.dispatchEvent(e)
        }
        Xxs(t, i, e) {
            if (nN.U(t, self.fh),
            nN.zt(i),
            t.yn().kx())
                return;
            const s = new nN.Event(i);
            s._h = t,
            e && Object.assign(s, e),
            this.dispatchEvent(s)
        }
        UAs(t, i) {
            if (nN.U(t, self.hF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.iE = t,
            this.dispatchEvent(e)
        }
        ute(t, i) {
            nN.zt(t),
            nN._U(i);
            let e = new nN.Event(t);
            e.$dt = self.app.Zh(),
            this.dispatchEvent(Object.assign(e, i))
        }
        u1n(t) {
            if (nN.zt(t),
            !self.app.VL())
                return;
            let i = new nN.Event(t);
            i.EH = self.app.Mj(),
            this.dispatchEvent(i)
        }
        tOs(t, i, ...e) {
            if (nN.U(t, self.CO),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.timeline = t,
            s.C2 = e,
            s.Bx = () => t,
            this.dispatchEvent(s)
        }
        yMs(t, i, ...e) {
            if (nN.U(t, self.kce),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.track = t,
            s.C2 = e,
            s.Bx = () => t.Bx(),
            this.dispatchEvent(s)
        }
        eRs(t, i, ...e) {
            if (nN.U(t, self.xce),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.Pee = t,
            s.C2 = e,
            this.dispatchEvent(s)
        }
        hRs(t, i) {
            if (nN.U(t, self.X4),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.Nee = t,
            this.dispatchEvent(e)
        }
        oRs(t, i) {
            if (nN.U(t, self.z4),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.$ee = t,
            this.dispatchEvent(e)
        }
        lRs(t, i) {
            if (nN.U(t, self.uF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.RO = t,
            this.dispatchEvent(e)
        }
        iRs(t, i) {
            if (nN.U(t, self.bce),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.qee = t,
            e.Bx = () => t.Bx(),
            this.dispatchEvent(e)
        }
        nRs(t, i) {
            if (nN.U(t, self.Gce),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.jee = t,
            e.Bx = () => t.Bx(),
            this.dispatchEvent(e)
        }
        rRs(t, i) {
            if (nN.U(t, self.jce),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.Iee = t,
            this.dispatchEvent(e)
        }
        kBs(t, i) {
            if (nN.U(t, self.mF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.transition = t,
            this.dispatchEvent(e)
        }
        d$s(t, i) {
            if (nN.U(t, self.TBs),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.c1n = t,
            this.dispatchEvent(e)
        }
        D$s(t, i) {
            if (nN.U(t, self.dF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.JO = t,
            this.dispatchEvent(e)
        }
        W9s(t, i) {
            if (nN.U(t, self.vO),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.EO = t,
            this.dispatchEvent(e)
        }
        X7s(t, i) {
            if (nN.U(t, self.pF),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.BO = t,
            this.dispatchEvent(e)
        }
        H9s(t, i) {
            if (nN.U(t, self.uet),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.Vst = t,
            this.dispatchEvent(e)
        }
        H7s(t, i) {
            if (nN.U(t, self.aht),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.dnt = t,
            this.dispatchEvent(e)
        }
        qps(t, i) {
            if (nN.U(t, self.Kps),
            nN.zt(i),
            t.yn().kx())
                return;
            let e = new nN.Event(i);
            e.Kci = t,
            this.dispatchEvent(e)
        }
        vJ(t, i, e) {
            nN.U(t, self.lG),
            nN.zt(i),
            nN._U(e);
            let s = new nN.Event(i);
            s.Wr = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        m9(t, i) {
            nN.zt(t),
            nN._U(i);
            let e = new nN.Event(t);
            e.GRt = this.zs().TF().bK(),
            e.C2 = i,
            this.dispatchEvent(e)
        }
        X$(t, i) {
            nN.YJ(t, window.Vb),
            nN.zt(i),
            rN("topOfLayer" === i || "bottomOfLayer" === i || "otherLayer" === i, "invalid moveTo value");
            let e = new Map;
            for (let i of t) {
                let t = i.sl();
                e.has(t) ? e.get(t).push(i) : e.set(t, [i])
            }
            for (let t of e.values())
                t.sort(self.Vb.ZCs);
            let s = new nN.Event("objectinstanceszorderchange");
            s.moveTo = i,
            s.R9t = e,
            this.dispatchEvent(s)
        }
        bJt(t, i, e) {
            nN.zt(i),
            nN._U(e);
            let s = new nN.Event(i);
            s.i3s = t,
            e && (s.C2 = e),
            this.dispatchEvent(s)
        }
        tWs(t, i, e) {
            if (nN.U(t, self.K$s),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.d1n = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        q7s(t, i, e) {
            if (nN.U(t, self.Mwt),
            nN.zt(i),
            t.yn().kx())
                return;
            let s = new nN.Event(i);
            s.f1n = t,
            this.dispatchEvent(Object.assign(s, e))
        }
        ZPe(t) {
            return nN.zt(t),
            new nN.qs.Jj.Van(this.Uan,t)
        }
        n1n(t) {
            return nN.zt(t),
            new nN.qs.Jj.jan(this.Uan,t)
        }
        Wns() {
            return this.qZn
        }
        Irs() {
            return this.XZn
        }
        _rs() {
            return this.YZn
        }
        Nrs() {
            return this.JZn
        }
        oAs() {
            return this.ZZn
        }
        async LD(t) {
            nN.U(t, Promise),
            rN(!this.dQn.has(t), "async work promise already added"),
            this.dQn.add(t);
            try {
                return await t
            } finally {
                this.dQn.delete(t)
            }
        }
        opi() {
            return Promise.all([...this.dQn])
        }
        UD() {
            return this.dQn.size > 0
        }
        Ngi() {
            if (this.iQn)
                return;
            const t = self.devicePixelRatio;
            if (Math.abs(t - this.tQn) >= .01) {
                this.iQn = !0;
                nN.qs.Ys.$s("OK").Qa(hN("ui.zoom-level-changed-message"))
            }
        }
        Yse(t) {
            return nN.zt(t),
            t.startsWith("http:") || t.startsWith("https:") || (t && !t.startsWith("/") && (t = "/" + t),
            t = nN.o_.URL.C6t + t),
            t
        }
        s_(t, i) {
            nN.zt(t),
            nN.Kq(i),
            this.e_(this.Yse(t), "OpenManualLink", i)
        }
        hEe(t, i, e) {
            let s = null;
            try {
                s = new URL(t)
            } catch (i) {
                return console.error(`Invalid URL '${t}': `, i),
                t
            }
            if ("construct.net" === s.hostname || "www.construct.net" === s.hostname) {
                const t = new URLSearchParams(s.search);
                return t.append("utm_campaign", "C3Editor"),
                t.append("utm_source", nN.Xke()),
                t.append("utm_medium", nN.o_.Lhi),
                i && t.append("utm_term", i),
                e && t.append("utm_content", e),
                s.search = t.toString(),
                s.toString()
            }
            return t
        }
        e_(t, i, e) {
            nN.zt(t),
            nN.Kq(i),
            nN.Kq(e),
            t = this.hEe(t, i, e),
            window.open(t)
        }
        N0n() {
            return this.eQn
        }
        p1n() {
            return this.sQn
        }
        QVn() {
            return "beta" === this.tke()
        }
        NQn() {
            return "lts" === this.tke()
        }
        tke(t) {
            let i = nN.o_.kOn;
            return "lts" === i && t && (i = "LTS"),
            i
        }
        j0n(t) {
            if (this.aj())
                return;
            if (this.nQn)
                return;
            const i = this.xk.vk().nA().bA("preview");
            i && (nN.p.u("ui.first-run.run-project-tip"),
            nN.qs.Jj.QY.nF(i.hk(), "info", hN(".title"), hN(".description"), {
                align: "bottom"
            }),
            nN.p.j(),
            this.nQn = !0)
        }
        Lii(t, i) {
            let e;
            if (nN.zt(t),
            "string" == typeof i)
                e = {
                    event_label: i
                };
            else {
                if ("object" != typeof i)
                    throw new TypeError("invalid analytics label");
                e = i
            }
            this.aj() && !t.startsWith("tutorial_") || this.m1n({
                type: "event",
                eventAction: t,
                eventData: e
            })
        }
        BQn(t, i, e, s=3e5) {
            nN.zt(t),
            nN.Ge(i),
            nN.Kq(e),
            (i = Math.round(i)) >= s || this.m1n({
                type: "timing",
                timingVar: t,
                timingValue: i,
                timingLabel: e
            })
        }
        cqn(t) {
            nN.zt(t),
            this.Xj() || this.m1n({
                type: "crash",
                description: t,
                release_name: nN.o_.Lhi,
                product_type: MN
            })
        }
        async w1n(t) {
            if (fN)
                this.Lii("LoginStateChanged", t);
            else {
                fN = !0,
                await this.WZn,
                await this.bG.M0();
                let i = "(none)"
                  , e = "no-webgl"
                  , s = 0;
                if (this.KPe()) {
                    const t = this.ln();
                    t.Rgn() ? (i = "webgl" + t.Qxn(),
                    e = t.o_n()) : (i = "webgpu",
                    e = "n/a"),
                    t.Agn() && (i += "-majorperfcaveat"),
                    s = t.Yyn()
                }
                this.m1n({
                    type: "pageview",
                    page_title: document.title,
                    page_location: document.location.toString(),
                    page_referrer: document.referrer,
                    user_properties: {
                        product_type: MN,
                        login_state: t
                    },
                    custom_dimensions: {
                        release_name: nN.o_.Lhi + " (" + this.tke(!0) + ")",
                        language_setting: this.r0().language || "(unknown)",
                        theme: this.r0().theme || "(default)",
                        display_mode: nN.Xke(),
                        ui_mode: nN.kt.mj ? "mobile" : "desktop",
                        webgl_support: i,
                        webgl_extensions: e,
                        webgl_max_texture_size: s,
                        device_pixel_ratio: Math.round(10 * (self.devicePixelRatio || 0)) / 10
                    }
                })
            }
        }
        m1n(t) {
            xN ? xN(t) : (() => {})("[Analytics] Sandbox iframe unavailable, skipped logging")
        }
        async V$n() {
            let t = await localforage.getItem("c3-time-spent-in-editor");
            "number" != typeof t && (t = 0),
            localforage.setItem("c3-time-spent-in-editor", t + pN / 1e3).catch(t => this.OA(t))
        }
        async mQn() {
            await nN.qs.HY.VYe();
            const t = nN.qs.Ys.$s("OK");
            await t.Qa(hN("ui.take-a-break-reminder"))
        }
        OA(t, i) {
            if (nN.Kq(i),
            (() => {})("Storage error:", t),
            this.wQn || this.aj())
                return;
            this.wQn = !0,
            this.Lii("StorageError", t ? t.toString() : "<unknown>"),
            nN.p.u("ui.errors.storage-error");
            const e = nN.qs.Ys.$s("Confirm");
            e.Ya(),
            e.Qa({
                caption: hN(".caption"),
                message: i || hN(".message"),
                jD: hN(".storage-cleanup")
            }).then(t => {
                if (null === t)
                    return void this.Lii("StorageErrorPrompt", "Cancelled");
                this.Lii("StorageErrorPrompt", "OK-StorageCleanup");
                nN.qs.Ys.$s("StorageCleanup").Qa()
            }
            ),
            nN.p.j()
        }
        nAt(t, i) {
            nN.Kq(t),
            nN.Kq(i),
            "UserAccountMenu" === t || "WelcomeDialog" === t || "ScriptingFeatureLimit" === t ? this.e_(nN.o_.URL.HOn, t, i) : this.OZn.Bj() ? (this.OZn.g1n(t, i),
            this.t0(this.OZn.dH())) : (this.OZn.g1n(t, i),
            this.OZn.Ej(!0))
        }
        async UQn() {
            if (!new URLSearchParams(location.search).has("openmru"))
                return;
            const t = await self.kk.ml();
            if (0 === t.length)
                return;
            const i = nN.qs.Ys.$s("OK");
            await i.Qa("Click OK to open most recently used project, as this may need a user gesture."),
            await self.kk.ij(t[0])
        }
        eLs() {
            return this.iLs || (this.iLs = new AudioContext),
            this.iLs
        }
    }
    ,
    Object.freeze(window.yZn.prototype);
    const JN = window.yZn.prototype
      , ZN = [JN.k_, JN.LWn, JN.FWn, JN.eAt, JN.UVt, JN.iri, JN.sL, JN.JN, JN.HVn, JN.ske, JN.jU, JN.pkt, JN.QPe, JN.UZs]
      , QN = new Set(["https://account.construct.net", "https://accountbeta.construct.net", "https://addons.construct.net", "https://cloud.construct.net", "https://stats.construct.net"])
      , tj = new Map
      , ij = 4e3;
    let ej = -1;
    const sj = window.setTimeout
      , nj = document.getElementsByTagName("iframe")
      , rj = document;
    function hj(t) {
        let i = t.parentNode;
        for (; i; ) {
            if (i === rj)
                return !0;
            i = i.parentNode
        }
        return !1
    }
    function oj() {
        throw YN.bZn = null,
        YN.GQ = null,
        YN.Uan = null,
        YN.xk = null,
        YN.vZn = null,
        YN.bG = null,
        YN.wCt = null,
        YN.dst = null,
        YN.MZn = null,
        YN.EZn = null,
        YN.CZn = null,
        YN._Ut = null,
        YN._Zn = null,
        YN.TZn = null,
        YN.IZn = null,
        YN.PZn = null,
        YN.GZn = null,
        YN.AZn = null,
        YN.RZn = null,
        YN.kZn = null,
        YN.DZn = null,
        YN.FZn = null,
        YN.LZn = null,
        YN.QZn = null,
        YN.zZn = [],
        YN.xP = null,
        YN.yh && YN.yh.he(),
        YN.yh = null,
        HN(null),
        new Error("security exception")
    }
    function aj() {
        ej = -1,
        lj()
    }
    function lj() {
        if (-1 !== ej && window.clearTimeout(ej),
        !nN.yc())
            return;
        ej = sj(aj, ij);
        const t = new Set;
        for (let i = 0, e = nj.length; i < e; ++i) {
            const e = nj[i];
            if (!e.src)
                continue;
            const s = new URL(e.src).origin.toLowerCase();
            if (QN.has(s)) {
                if (tj.has(s)) {
                    if (tj.get(s) !== e)
                        return void oj()
                } else
                    tj.set(s, e);
                if (t.has(s))
                    return void oj();
                t.add(s)
            }
        }
        for (const t of tj.values())
            if (!hj(t))
                return void oj();
        if (ZN) {
            const t = ZN
              , i = self.app;
            if (t[0] !== i.k_ || t[1] !== i.LWn || t[2] !== i.FWn || t[3] !== i.eAt || t[4] !== i.UVt || t[5] !== i.iri || t[6] !== i.sL || t[7] !== i.JN || t[8] !== i.HVn || t[9] !== i.ske || t[10] !== i.jU || t[11] !== i.pkt || t[12] !== i.QPe || t[13] !== i.UZs || Object.getPrototypeOf(i) !== JN)
                return void oj()
        }
    }
    document.addEventListener("pointermove", lj, !0),
    sj(aj, ij)
}
{
    const uj = self.t;
    function cj(t, i, e=!0) {
        e && uj.qs.HY.IJi() || t.dispatchEvent(uj.v(uj.Event, i, !0))
    }
    function dj() {}
    const fj = uj.kt.w$t ? "meta" : "ctrl"
      , pj = [new uj.qs.yfn(uj.kE.Jct,"delete"), new uj.qs.yfn(uj.kE.F2,"rename"), new uj.qs.yfn(uj.kE.w9,"edit"), new uj.qs.yfn(fj,uj.kE.A,"select-all"), new uj.qs.yfn(fj,uj.kE.D,"unselect"), new uj.qs.yfn(fj,uj.kE.Dje,"scroll-to-start"), new uj.qs.yfn(fj,uj.kE.Oje,"scroll-to-end"), new uj.qs.yfn("alt","shift",uj.kE.F7,"back"), new uj.qs.yfn("alt","shift",uj.kE.V7,"next"), new uj.qs.yfn("alt","shift",uj.kE.B,"back")._fn(), new uj.qs.yfn("alt","shift",uj.kE.N,"next")._fn(), new uj.qs.yfn(fj,uj.kE.Z,t => cj(t, "undo", !1)), new uj.qs.yfn(fj,uj.kE.Y,t => cj(t, "redo", !1)), new uj.qs.yfn(fj,uj.kE.lGt,"zoom-in").Ifn(), new uj.qs.yfn(fj,uj.kE.rGt,"zoom-out").Ifn(), new uj.qs.yfn(fj,"shift",uj.kE.lGt,"zoom-in-more").Ifn(), new uj.qs.yfn(fj,"shift",uj.kE.rGt,"zoom-out-more").Ifn(), new uj.qs.yfn(fj,uj.kE.ZLt,"reset-zoom").Ifn(), new uj.qs.yfn(fj,uj.kE.F,t => t.bDt())._fn(), new uj.qs.yfn(fj,"shift",uj.kE.F,t => t.m0n()), new uj.qs.yfn(fj,uj.kE.P,t => cj(t, "print")), new uj.qs.yfn(fj,uj.kE.N,t => t.tj()), new uj.qs.yfn("alt",uj.kE.N,t => t.vWn()), new uj.qs.yfn(fj,uj.kE.O,t => t.sj(t.a0n())), new uj.qs.yfn(fj,uj.kE.S,t => t.Vk(t.dT()))._fn(), new uj.qs.yfn(uj.kE.F4,t => t.Kk(t.dT(), !1))._fn(), new uj.qs.yfn("shift",uj.kE.F4,t => t.Yk(t.dT(), !1))._fn(), new uj.qs.yfn(uj.kE.F5,t => t.AA(null, !1))._fn(), new uj.qs.yfn(fj,uj.kE.F5,t => t.IA(null, !1))._fn(), new uj.qs.yfn("shift",uj.kE.F5,t => t.IA(null, !1))._fn(), new uj.qs.yfn("alt",uj.kE.$Vi,t => t.Kk(t.dT(), !0)), new uj.qs.yfn("alt","shift",uj.kE.$Vi,t => t.Yk(t.dT(), !0)), new uj.qs.yfn("alt",uj.kE.HVi,t => t.AA(null, !0)), new uj.qs.yfn("alt","shift",uj.kE.HVi,t => t.IA(null, !0)), new uj.qs.yfn(uj.kE.F6,t => t.Zk(t.dT()))._fn(), new uj.qs.yfn(uj.kE.F9,t => {
        const i = t.dT();
        i && "webfs-local-folder" === i.kB() && i.RU(i.wN())
    }
    )._fn(), new uj.qs.yfn(fj,uj.kE.E,"go-to-event-sheet"), new uj.qs.yfn("shift",uj.kE.S,"go-to-associated"), new uj.qs.yfn(fj,"shift",uj.kE.K7,"move-to-top"), new uj.qs.yfn(fj,"shift",uj.kE.j7,"move-to-bottom"), new uj.qs.yfn(fj,uj.kE.R,"start-all-live-previews"), new uj.qs.yfn(fj,"shift",uj.kE.R,t => t.sY()), new uj.qs.yfn(fj,uj.kE.L,"go-to-layout"), new uj.qs.yfn("ctrl","shift",uj.kE.V7,t => cj(t, "next-tab")), new uj.qs.yfn("ctrl","shift",uj.kE.F7,t => cj(t, "previous-tab")), new uj.qs.yfn("alt",uj.kE.W,t => cj(t, "close-current-tab"))._fn(), new uj.qs.yfn(fj,uj.kE.c$e,t => cj(t, "replace-whole-hierarchy")), new uj.qs.yfn(fj,uj.kE.d$e,t => cj(t, "modify-existing-hierarchy")), new uj.qs.yfn("alt-gr",uj.kE.m$t("open-square-bracket"),t => cj(t, "replace-whole-hierarchy")), new uj.qs.yfn("alt-gr",uj.kE.m$t("close-square-bracket"),t => cj(t, "modify-existing-hierarchy")), new uj.qs.yfn("alt",uj.kE.V7,dj), new uj.qs.yfn("alt",uj.kE.F7,dj), new uj.qs.yfn("meta",uj.kE.V7,dj), new uj.qs.yfn("meta",uj.kE.F7,dj)];
    window.MQn = pj
}
{
    const mj = self.t;
    let wj = null;
    const gj = !!window.C3_IsPopupWindow
      , yj = new Map([["propertiesbar", "components/bars/propertiesBar/propertiesBar.html"], ["midpane", "components/misc/midPane/midPane.html"], ["projectbar", "components/bars/projectBar/projectBar.html"], ["layersbar", "components/bars/layersBar/layersBar.html"], ["tilemapbar", "components/bars/tilemapBar/tilemapBar.html"], ["zorderbar", "components/bars/zOrderBar/zOrderBar.html"], ["instancebar", "components/bars/instanceBar/instanceBar.html"], ["bookmarksbar", "components/bars/bookmarksBar/bookmarksBar.html"], ["mainMenu", "components/misc/mainMenu/mainMenu.html"], ["findresultsbar", "components/bars/findResultsBar/findResultsBar.html"], ["findreferencesbar", "components/bars/findReferencesBar/findReferencesBar.html"], ["startpage2", "components/misc/startPage2/startPage2.html"], ["examplebrowser", "components/misc/exampleBrowser/exampleBrowser.html"], ["useraccount", "components/misc/userAccount/userAccount.html"], ["buynowpage", "components/misc/buyNowPage/buyNowPage.html"], ["timelineBar", "components/bars/timelineBar/timelineBar.html"], ["guidedtourcontroller", "components/misc/tourController/tourController.html"], ["remotePreviewBar", "components/bars/remotePreviewBar/remotePreviewBar.html"], ["assetBrowserBar", "components/bars/assetBrowserBar/assetBrowserBar.html"]])
      , bj = new Map([["layoutview", "components/editors/layoutView/layoutView.html"], ["eventsheetview", "components/editors/eventSheetView/eventSheetView.html"], ["flowchartview", "components/editors/flowchartView/flowchartView.html"], ["texteditor", "components/editors/textEditor/textEditor.html"], ["dataeditor", "components/editors/dataEditor/dataEditor.html"]]);
    function vj(t) {
        self.C3_SetLoadingHTML(t)
    }
    window.C3_OnAppFatalLoadError = function(t) {
        if (window.C3_HadLoaderError)
            return;
        window.C3_HadLoaderError = !0;
        const i = document.createElement("div");
        i.classList.add("apploaderrorcontainer");
        const e = document.createElement("div");
        e.classList.add("apploadererrormessage"),
        e.innerHTML = "<strong>Oops! There was an error loading Construct.</strong><br>Try the following:<ul ><li>Check your Internet connection is working.</li><li>Try disabling any browser addons you have installed. These can sometimes break Construct. In particular, Kaspersky Internet Security has been known to cause problems.</li><li>Check ad or tracking blocking settings which can also sometimes break Construct, including if you use a VPN. In particular, NordVPN has been known to cause problems.</li><li>Clear your browser cache and try again.</li><li>Press F12 and look for any additional errors in the browser console.</li></ul>Error details: " + t,
        i.appendChild(e),
        document.body.appendChild(i),
        wj && wj.Lii("LoadError", "" + t)
    }
    ;
    let Sj = 0
      , xj = 0;
    async function Mj() {
        mj.n0("Bootstrap"),
        mj.$Te(),
        gj || vj("Loading UI..."),
        wj = mj.v(self.yZn),
        !mj.jii() && mj.XTe || Object.seal(wj),
        await wj.Kpn();
        const t = wj.r0().uiMode;
        "mobile" === t ? (mj.kt.mj = !0,
        mj.kt.lA = !1,
        mj.qs.Fqe()) : "desktop" === t && (mj.kt.mj = !1,
        mj.kt.lA = !0,
        mj.qs.Fqe()),
        gj || (vj("Loading..."),
        Tj());
        const i = mj.p.vp(wj.r0().language)
          , e = mj.qs.oX.SIt("default")
          , s = Cj(yj);
        gj || s.then( () => {
            Ij(),
            vj("Starting...")
        }
        ),
        await Promise.all([i, e]),
        mj.I0("Bootstrap"),
        await Pj({
            CQn: s,
            JQn: bj
        })
    }
    async function Ej(t, i) {
        await mj.MAe(i, !1),
        xj++
    }
    function Cj(t) {
        const i = [];
        for (const [e,s] of t)
            i.push(Ej(0, s));
        return Sj += i.length,
        Promise.all(i)
    }
    window.c3_mainLoadPromise = Mj().catch(t => window.C3_OnAppFatalLoadError(t));
    let _j = -1;
    function Tj() {
        let t = -1;
        _j = window.setInterval( () => {
            const i = xj
              , e = Sj;
            if (0 === e)
                return;
            const s = Math.round(100 * i / e);
            s !== t && (vj("Loading (" + s + "%)..."),
            t = s)
        }
        , 100)
    }
    function Ij() {
        -1 !== _j && (window.clearInterval(_j),
        _j = -1)
    }
    async function Pj(t) {
        if (!window.C3_HadLoaderError && (await wj.SIt(t),
        gj ? mj.jii() || (await mj.MAe("projectResources.html", !0),
        await Promise.all([...t.JQn.values()].map(t => mj.MAe(t, !1)))) : (mj.qs.Iqe(),
        await wj.Zpn(t)),
        mj.Vl)) {
            const t = mj.M9s.$s("project");
            if (t) {
                if ("new" === t)
                    return void wj.vWn();
                await wj.G0n(`exampleProjects/debug/${t}.capx`);
                const i = wj.zZn[0]
                  , e = mj.M9s.$s("layout");
                if (e) {
                    const t = i.Qte(e);
                    t && wj.HR(t)
                } else {
                    const t = mj.M9s.$s("eventsheet");
                    if (t) {
                        const e = i.sne(t);
                        e && wj.GR(e)
                    }
                }
            }
        }
    }
}
{
    const Gj = self.t
      , Aj = self.lang
      , Rj = "C3_RecentProjects"
      , kj = 2
      , Oj = 10
      , Dj = new Set(["cloud", "webfs-single-file", "webfs-local-folder"])
      , Fj = new Set(["DROPBOX", "ONE DRIVE", "GOOGLE DRIVE", "LOCAL STORAGE"]);
    let Lj = []
      , Bj = null;
    function Uj(t) {
        const i = {};
        for (const [e,s] of t)
            Object.defineProperty(i, e, {
                writable: !1,
                value: s,
                enumerable: !0
            });
        return i
    }
    async function Nj(t, i) {
        Gj.U(t, self.gh),
        Gj.zt(i);
        const e = t.kB();
        if (!Dj.has(e))
            return;
        const s = await t.mii()
          , n = t.Fa()
          , r = t.CL()
          , h = t.$te()
          , o = Date.now()
          , a = t.xB()
          , l = Uj([["modified", o], ["system", e], ["project", n], ["version", h], ["name", i], ["uuid", s], ["project-id", r], ["ref", a]]);
        if (!$j(l))
            throw console.error("[Construct] Invalid recent project entry: ", l),
            new Error("invalid recent project entry");
        let u;
        if (u = "webfs-single-file" === e ? await Kj(a.fileHandle) : "webfs-local-folder" === e ? await qj(a.folderHandle) : Hj(r) || Hj(s),
        u) {
            const t = Lj.indexOf(u);
            Lj.splice(t, 1)
        }
        Lj.push(l),
        Lj.sort( (t, i) => i.modified - t.modified),
        Lj.length > Oj && (Lj = Lj.slice(0, Oj)),
        await Yj()
    }
    async function jj(t, i) {
        if (Gj.zt(t),
        Gj.Kq(i),
        i)
            for (let e = 0, s = Lj.length; e < s; e++) {
                const s = Lj[e]
                  , n = s.ref;
                if ("cloud" === s.system && (!n || n.service === i && n.id === t)) {
                    Lj.splice(e, 1),
                    await Yj();
                    break
                }
            }
        else
            for (let i = 0, e = Lj.length; i < e; i++)
                if (Lj[i].uuid === t) {
                    Lj.splice(i, 1),
                    await Yj();
                    break
                }
    }
    function $j(t) {
        if (!Gj.Ots(t))
            return !1;
        if (!("ref"in t))
            return !1;
        const i = t.system;
        return !!Dj.has(i) && ("cloud" === i ? zj(t.ref) : "webfs-single-file" === i ? Vj(t.ref) : "webfs-local-folder" === i ? Wj(t.ref) : Gj.doe(t.ref))
    }
    function zj(t) {
        if (!Gj.Ots(t))
            return !1;
        const i = t.service
          , e = t.name
          , s = t.id
          , n = t.parent;
        return !!(Gj.doe(i) && Gj.doe(e) && Gj.doe(s) && Gj.doe(n)) && Fj.has(i)
    }
    function Vj(t) {
        return !!Gj.Ots(t) && t.fileHandle instanceof FileSystemFileHandle
    }
    function Wj(t) {
        return !!Gj.Ots(t) && t.folderHandle instanceof FileSystemDirectoryHandle
    }
    function Hj(t) {
        Gj.zt(t);
        for (const i of Lj)
            if (i.uuid === t)
                return i
    }
    async function Kj(t) {
        try {
            for (const i of Lj)
                if ("webfs-single-file" === i.system) {
                    const e = i.ref.fileHandle;
                    if (await t.isSameEntry(e))
                        return i
                }
            return null
        } catch (t) {
            return (() => {})("Error looking for existing recent project file: ", t),
            null
        }
    }
    async function qj(t) {
        try {
            for (const i of Lj)
                if ("webfs-local-folder" === i.system) {
                    const e = i.ref.folderHandle;
                    if (await t.isSameEntry(e))
                        return i
                }
            return null
        } catch (t) {
            return (() => {})("Error looking for existing recent project folder: ", t),
            null
        }
    }
    async function Xj() {
        try {
            await Jj()
        } catch (t) {
            (() => {})("Failed to retrieve recent project meta data: ", t),
            Lj = []
        }
    }
    async function Yj() {
        try {
            await localforage.setItem(Rj, {
                version: kj,
                data: Lj
            })
        } catch (t) {
            (() => {})("Unable to store recent project meta data: ", t),
            await Jj()
        }
        self.app.Mgt("recentprojectschange")
    }
    async function Jj() {
        const t = await localforage.getItem(Rj);
        if (null === t)
            Lj = [];
        else {
            const i = t.version
              , e = t.data;
            i === kj && (Lj = e)
        }
    }
    Bj = Xj(),
    window.kk = {
        async so(t, i) {
            Gj.U(t, self.gh),
            Gj.zt(i),
            await Bj;
            try {
                await Nj(t, i)
            } catch (t) {
                console.error("Failed to update recent projects", t)
            }
        },
        ml: async () => (await Bj,
        Lj.slice(0)),
        async bx(t, i) {
            Gj.zt(t),
            Gj.Kq(i),
            await Bj,
            await jj(t, i)
        },
        async tC() {
            await Bj,
            Lj.length = 0,
            await Yj()
        },
        async ij(t) {
            if (!self.app.H0n())
                try {
                    await self.app.Z0n(t)
                } catch (i) {
                    let e;
                    (() => {})("Failed to open recent project: ", i),
                    "string" == typeof i ? e = i : 404 === i.code || "ENOENT" === i.code || "path/not_found/.." === i.message || "path/not_found/." === i.message ? (await jj(t.uuid, null),
                    e = Aj("main-menu.project-menu.open-recent-not-found")) : e = "aborted" === i.message ? Aj("main-menu.project-menu.open-recent-abort") : "webfs-single-file" === t.system || "webfs-local-folder" === t.system ? Aj("main-menu.project-menu.open-recent-webfs-error") : Aj("main-menu.project-menu.open-recent-fail");
                    Gj.qs.Ys.$s("OK").Qa(e)
                }
        }
    }
}
{
    const Zj = self.t
      , Qj = self.kk
      , t$ = self.lang;
    window.C3_IsPopupWindow || (self.jk = class {
        static qU(t, i, e) {
            return Zj.zt(t),
            Zj.zt(i),
            Zj.zt(e),
            this.b1n.$s(e).y1n(i, t).then(i => Zj._Lt(t, i))
        }
        static async GB(t, i, e, s) {
            return Zj.zt(i),
            Zj.zt(t),
            Zj.zt(e),
            Zj.zt(s),
            await Qj.bx(t, this.rVt),
            this.b1n.$s(e).v1n(t, s, i)
        }
        static oVn(t, i, e) {
            return Zj.zt(i),
            Zj.zt(e),
            Zj.zt(t),
            this.b1n.$s(e).oVn(t, i)
        }
        static bVn(t) {
            return Zj.zt(t),
            this.b1n.$s(t).bVn()
        }
        static async lD(t, i, e) {
            return Zj.zt(i),
            Zj.zt(t),
            Zj.zt(e),
            await Qj.bx(t, this.rVt),
            this.b1n.$s(e).S1n(t, i)
        }
        static lVn(t, i, e, s, n) {
            return Zj.Tke(t, Blob),
            Zj.Kq(i),
            Zj.zt(s),
            Zj.zt(e),
            Zj.zt(n),
            this.b1n.$s(n).x1n(t, e, i, s)
        }
        static t1n(t) {
            return this.b1n.t1n(t)
        }
        static async oXn() {
            try {
                return await this.b1n.$s("LOCAL STORAGE").lN()
            } catch (t) {
                return console.error(t),
                !1
            }
        }
        static async ij(t) {
            t = !!t;
            const i = Zj.qs.Ys.$s("FileList")
              , e = await i.PVn(t, !1);
            if (!e)
                return null;
            const [s,n] = e;
            try {
                return await this.b1n.$s(s).A0n(n.id, n.name, n.parent)
            } catch (t) {
                this.b1n.M1n(t, t$("ui.errors.failed-to-open-c3-project"))
            }
        }
        static async Zht(t, i) {
            Zj.U(t, self.gh),
            i = !!i;
            const e = Zj.qs.Ys.$s("FileList")
              , s = t.tF() || t.Fa() + ".c3p"
              , n = await e.AVn(s, i, !1);
            if (!n)
                return null;
            let[r,h,o,a] = n;
            return this.b1n.$s(r).Vk(t, h, o, a, !1, null)
        }
        static async Q0n(t) {
            Zj.Hut(t);
            const i = t.ref
              , e = i.service
              , s = i.id
              , n = i.name || t.name
              , r = i.parent
              , h = this.b1n.$s(e);
            if ("GOOGLE DRIVE" != e || await h.E1n(s, r))
                return h.A0n(s, n, r);
            throw {
                code: 404,
                message: "Not Found",
                response: "Not Found",
                status: "Not Found"
            }
        }
        static async J0n(t) {
            Zj.U(t, self.gh);
            const i = t.kB()
              , e = t.xB();
            try {
                if ("cloud" !== i)
                    throw new Error(`${t.Fa()} does not originate from the cloud, and therefore cannot be quick saved`);
                const s = this.b1n.$s(e.service)
                  , n = e.id
                  , r = e.parent
                  , h = e.name;
                await s.Vk(t, h, n, r, !1, null)
            } catch (t) {
                console.error("[Project] Exception saving: ", t);
                Zj.qs.Ys.$s("OK").Qa(t$("ui.save-error"))
            }
        }
        static Xfs(t, i, e) {
            return Zj.zt(t),
            Zj.Kq(e),
            i = !!i,
            this.b1n.$s(t).Xfs(i, e)
        }
    }
    )
}
{
    const i$ = self.t
      , e$ = self.app
      , s$ = self.jk
      , n$ = self.lang
      , r$ = self.tP
      , h$ = new Set(["cloud", "webfs-single-file", "webfs-local-folder"])
      , o$ = new Set(["DROPBOX", "ONE DRIVE", "GOOGLE DRIVE", "LOCAL STORAGE"]);
    let a$ = 6e4
      , l$ = null
      , u$ = null;
    function c$() {
        i$.qs.Ys.$s("Settings").Qa()
    }
    async function d$(t) {
        const i = [...e$.PA()].filter(i => {
            if (s$.t1n(i))
                return !1;
            const e = i.kB();
            return !("MATCH" === t && !h$.has(e)) && (null === i.zii() && (!!i.tF() && i.bii()))
        }
        ).map(i => {
            let e = t;
            const s = i.kB()
              , n = i.xB();
            return "MATCH" === e && (e = "webfs-single-file" === s || "webfs-local-folder" === s ? "WEBFS FOLDER" : n.service),
            {
                sx: i,
                location: e
            }
        }
        );
        if (0 === i.length)
            return;
        if (i.some(t => "WEBFS FOLDER" === t.location)) {
            if (!await f$())
                return
        }
        let e = !1;
        for (const s of i) {
            const i = s.sx
              , n = s.location;
            if ("WEBFS FOLDER" === n) {
                await p$(i) || (e = !0)
            } else if (o$.has(n)) {
                const e = "MATCH" === t;
                await m$(i, n, e)
            }
        }
        if (e) {
            const t = i$.qs.Ys.$s("OK");
            await t.Qa(n$("ui.local-backup-folder-messages.folder-permission-denied")),
            c$()
        }
    }
    async function f$() {
        const t = i$.qs.Ys.$s("OK");
        if (!l$ || !i$.zk.Lk)
            return await t.Qa(n$("ui.local-backup-folder-messages.folder-unavailable")),
            c$(),
            !1;
        let i = await l$.queryPermission({
            mode: "readwrite"
        });
        if ("denied" === i)
            return await t.Qa(n$("ui.local-backup-folder-messages.folder-permission-denied")),
            c$(),
            !1;
        if ("prompt" === i) {
            await t.Qa(n$("ui.local-backup-folder-messages.folder-permission-prompt")),
            i$.qs.cqe.Ej();
            try {
                i = await l$.requestPermission({
                    mode: "readwrite"
                })
            } catch (t) {
                (() => {})("Backup folder permission prompt failed: ", t),
                i = "declined"
            } finally {
                i$.qs.cqe.Cj()
            }
            return "granted" === i || (await t.Qa(n$("ui.local-backup-folder-messages.folder-permission-denied")),
            c$(),
            !1)
        }
        return !0
    }
    async function p$(t) {
        const i = t.kB()
          , e = t.tF()
          , s = i$.Fms(`${i$._ye(e).name}-${t.CL()}.c3p`)
          , n = n$("ui.local-backup-folder-messages.location")
          , r = s$.b1n.C1n(r$("ui.cloud-save.autosaving-project-to", t.Fa(), n));
        try {
            if (s$.b1n.t1n(t))
                throw new Error(r$("ui.cloud-save.already-saving", t.Fa()));
            t.Wii({
                mode: i,
                name: e
            }),
            t.Xii(!0);
            const r = await s$.b1n._1n(t, !0);
            return t.Kii(),
            t.Xii(!1),
            await i$.E0t.yPs(l$, s, r),
            i$.qs.Notification.nF("open-folder", n, r$("ui.cloud-save.save-succeeded", s), {
                align: "bottom-left"
            }),
            !0
        } catch (t) {
            return (() => {})("Error autosaving project to local backup folder: ", t),
            !1
        } finally {
            r.he(),
            t.Kii(),
            t.Xii(!1)
        }
    }
    async function m$(t, i, e) {
        const s = t.kB()
          , n = t.xB()
          , r = t.tF()
          , h = i$._ye(r).name + "._autosave_.c3p"
          , o = s$.b1n.$s(i)
          , a = o.MEt()
          , l = s$.b1n.C1n(r$("ui.cloud-save.autosaving-project-to", t.Fa(), a));
        try {
            const i = e ? n.parent : "root"
              , a = (await o.Xfs(!1, i)).filter( ({name: t}) => t === h)
              , l = 1 === a.length ? a[0].id : null
              , u = {
                mode: s,
                name: r,
                meta: n
            };
            if (o.t1n(t))
                throw new Error(r$("ui.cloud-save.already-saving", t.Fa()));
            await o.Vk(t, h, l, i, !0, u)
        } catch (i) {
            await s$.b1n.M1n(i, r$("ui.cloud-save.unknown-error-while-saving", t.Fa(), a))
        } finally {
            l.he()
        }
    }
    async function w$() {
        const t = 60 * (e$.r0().autosaveDuration || 1) * 1e3;
        t !== a$ && u$.Mws(t),
        a$ = t;
        try {
            l$ = await localforage.getItem("local-backup-folder")
        } catch (t) {
            l$ = null,
            (() => {})("Failed to load local backup folder handle: ", t)
        }
    }
    window.C3_IsPopupWindow || (u$ = i$.v(i$.aWe, async () => {
        const t = e$.r0()
          , i = t && t.autoSave
          , e = i$.qs.Jj.rqn;
        i && !e.pqn() && (await i$.qs.HY.VYe(),
        await d$(t.autosaveLocation))
    }
    , a$, {
        oWe: !0
    }),
    i$.jh.Gh(e$, "settingschange", w$),
    i$.jh.Gh(i$.fk, "afterload", w$))
}
window.T1n = function(t, i) {
    const e = new Map
      , s = new Map;
    let n = 0;
    function r(t, i, e) {
        h("reply", t, i, e)
    }
    function h(i, e, s, n) {
        n instanceof Error && (n = {
            message: n.message,
            stack: n.stack
        }),
        t({
            type: i,
            supplement: e,
            id: s,
            data: n
        })
    }
    return {
        I1n: async function(t) {
            const n = t.type
              , h = t.id
              , o = t.data;
            if ("reply" === n) {
                const i = e.get(h)
                  , s = t.supplement;
                i && ("success" === s && (i.P1n(o),
                e.delete(h)),
                "error" === s && (i.error(o),
                e.delete(h)),
                "update" === s && i.update && i.update(o))
            }
            if ("request" === n) {
                const e = t.supplement
                  , n = t => r("update", h, t)
                  , a = window.t ? window.t.Cye : new window.Cye;
                s.set(h, a);
                try {
                    const t = i ? await i(e, o, n, a) : null;
                    r("success", h, t)
                } catch (t) {
                    r("error", h, t)
                }
            }
            if ("cancel" === n) {
                const i = t.data
                  , e = s.get(i);
                try {
                    e && await e.Vh(),
                    r("success", h)
                } catch (t) {
                    r("error", h, t)
                }
            }
        },
        request: function(t, i, s, r) {
            return new Promise( (o, a) => {
                const l = n++;
                e.set(l, {
                    P1n: o,
                    error: a,
                    update: s
                }),
                r && r.Aze( () => {
                    h("cancel", null, n++, l)
                }
                ),
                function(t, i, e) {
                    h("request", t, i, e)
                }(t, l, i)
            }
            )
        }
    }
}
;
{
    const g$ = self.t
      , y$ = self.app
      , b$ = self.jk
      , v$ = self.lang
      , S$ = "cloud/sandbox.html"
      , x$ = g$.v(g$.qs.Jj.Pan)
      , M$ = new Map;
    let E$ = null
      , C$ = !1;
    function _$() {
        if (E$)
            return E$;
        const t = T$(S$, location.protocol + "//" + location.host, "allow-scripts allow-popups allow-modals allow-same-origin allow-popups-to-escape-sandbox", function(t, i) {
            if ("authenticate" === t)
                return I$(i);
            if ("sign-out" === t)
                return P$(i);
            throw new Error("Unknown request type")
        });
        return E$ = t,
        t
    }
    async function T$(t, i, e, s) {
        let n;
        const {I1n: r, request: h} = self.T1n(function(t) {
            n.lOe(t)
        }, s);
        return n = await g$.hOe({
            src: t,
            oOe: i,
            aOe: t => r(t.data),
            sandbox: e
        }),
        h
    }
    async function I$(t) {
        const i = t.auth
          , e = t.redirect
          , s = t.token;
        t.service;
        g$.zt(i),
        g$.zt(e),
        g$.zt(s);
        const n = window.screenX + window.outerWidth / 2 - 240
          , r = window.screenY + window.outerHeight / 2 - 320;
        let h = await g$.qs.oYe.EYe(i, {
            features: `width=480,height=640,left=${n},top=${r},menubar=no,toolbar=no,location=no,personalbar=no,status=no,dependent=yes,dialog=yes,resizable=yes,scrollbars=no`,
            name: "Cloud Auth"
        });
        if (!h)
            throw v$("ui.dialogs.fileList.popupBlocked");
        h = h.window;
        const o = v$("ui.cloud-save.awaiting-authentication")
          , a = g$.v(g$.qs.Jj.Van, x$, o);
        a.Ej();
        const l = g$.qs.Ys.$s("FileList");
        return l.Bj() && l.hVn(o),
        new Promise( (t, i) => {
            const e = async () => {
                let n;
                try {
                    const r = await localforage.getItem("auth_" + s);
                    if (r) {
                        try {
                            await localforage.removeItem("auth_" + s)
                        } catch (t) {}
                        n = r,
                        a.he(),
                        t(n)
                    } else {
                        let t = !1;
                        try {
                            h.closed && (t = !0)
                        } catch (t) {}
                        n || (t ? (a.he(),
                        i(v$("ui.dialogs.fileList.userAuthenticationCancelled"))) : setTimeout(e, 50))
                    }
                } catch (t) {}
            }
            ;
            e()
        }
        )
    }
    async function P$(t) {
        const i = t.url;
        g$.zt(i);
        const e = window.screenX + window.outerWidth / 2 - 240
          , s = window.screenY + window.outerHeight / 2 - 320;
        if (!await g$.qs.oYe.EYe(i, {
            features: `width=480,height=640,left=${e},top=${s},menubar=no,toolbar=no,location=no,personalbar=no,status=no,dependent=yes,dialog=yes,resizable=yes,scrollbars=no`,
            name: "Cloud Auth Signout"
        }))
            throw v$("ui.dialogs.fileList.popupBlocked")
    }
    if (!window.C3_IsPopupWindow) {
        function G$() {
            const t = y$.r0();
            C$ = t.cloudCache || !1
        }
        g$.jh.Gh(y$, "settingschange", G$),
        g$.jh.Gh(g$.fk, "afterload", G$),
        b$.G1n = class {
            constructor(t) {
                this.rVt = t,
                this.A1n = new Map,
                this.R1n = null
            }
            k1n(t) {
                if (!C$)
                    return null;
                const i = this.A1n.get(t)
                  , e = i && i.children;
                return e || null
            }
            O1n(t) {
                this.A1n.get(t)
            }
            D1n(t) {
                t.detached = !0,
                this.A1n.set(t.id, t)
            }
            F1n(t) {
                if ("folder" === t.type) {
                    const i = this.A1n.get(t.id);
                    if (i && !0 === i.stub) {
                        const e = i.children;
                        null !== e && (t.children = e)
                    }
                }
                this.A1n.set(t.id, t)
            }
            async L1n(t, i) {
                if (g$.U(i, Promise),
                g$.zt(t),
                !C$)
                    return await i;
                let e = this.A1n.get(t);
                e || ("root" != t && (() => {})("Non root caching call"),
                e = {
                    type: "folder",
                    id: t,
                    name: "",
                    children: null,
                    date: "",
                    size: 0,
                    parent: null,
                    detached: !0
                },
                this.A1n.set(t, e)),
                e.children = i,
                this.A1n.set(t, e);
                try {
                    const t = await i;
                    e.children = t;
                    for (const i of t)
                        this.F1n(i);
                    return t
                } catch (t) {
                    throw e.children = null,
                    t
                }
            }
            B1n() {
                return C$ ? this.R1n : null
            }
            U1n(t) {
                return g$.zt(t),
                this.R1n = C$ ? t : null,
                t
            }
            async N1n(t) {
                let i = null;
                try {
                    i = await t.children
                } catch (i) {
                    (() => {})("Unable to resolve entry list for " + t.id)
                }
                return i
            }
            async j1n(t, i, ...e) {
                g$.zt(t),
                g$._U(i);
                let {xDn: s, cancel: n} = i || {};
                g$.X_t(s),
                g$.Mw(n, g$.Cye);
                const r = {
                    method: t,
                    data: e
                };
                return (await _$())(this.rVt, r, s, n)
            }
            async $1n(t, i, e) {
                await this.z1n(t, i),
                await this.V1n(e)
            }
            async z1n(t, i) {
                if (C$) {
                    const e = this.A1n.get(t);
                    if (e) {
                        const t = await this.N1n(e);
                        if (t) {
                            const e = t.length;
                            let s = -1;
                            for (let n = 0; n < e; n++) {
                                t[n].id === i && (s = n)
                            }
                            s > -1 && t.splice(s, 1)
                        }
                    }
                    this.A1n.delete(i)
                }
            }
            async V1n(t) {
                if (C$) {
                    const i = this.A1n.get(t.parent);
                    if (i) {
                        const e = await this.N1n(i);
                        e && (e.push(t),
                        i.children = this.pVn(e))
                    }
                    if ("folder" === t.type) {
                        const i = this.A1n.get(t.id);
                        if (i && !0 === i.detached) {
                            const e = i.children;
                            null !== e && (t.children = e)
                        }
                    }
                    this.A1n.set(t.id, t)
                }
            }
            pVn(t) {
                return t.sort( (t, i) => t.type === i.type ? t.name === i.name ? 0 : t.name.toLowerCase() > i.name.toLowerCase() ? 1 : -1 : "file" === t.type ? 1 : -1)
            }
            async Tye(t) {
                const i = await this.j1n("getFiles", null, t);
                return this.pVn(i)
            }
            async E1n(t, i) {
                if (g$.zt(t),
                g$.zt(i),
                "GOOGLE DRIVE" != this.rVt)
                    throw new Error("Method not implemented");
                if (C$ && this.A1n.has(t))
                    return !0;
                const e = await this.j1n("getMeta", null, t);
                return e && 0 == e.trashed
            }
            lN() {
                if ("LOCAL STORAGE" != this.rVt)
                    throw new Error("Method not implemented");
                return this.j1n("isEmpty")
            }
            async Xfs(t, i) {
                if (g$.zt(i),
                !t) {
                    const t = this.k1n(i);
                    if (t)
                        return t
                }
                const e = this.Tye(i);
                return this.L1n(i, e)
            }
            async JHi(t, i, e) {
                return g$.zt(t),
                g$.X_t(i),
                g$.Mw(e, g$.Cye),
                await this.j1n("getFile", {
                    xDn: i,
                    cancel: e
                }, t)
            }
            async W1n() {
                const t = this.B1n();
                if (t)
                    return t;
                const i = await this.j1n("getID");
                return this.U1n(i)
            }
            async x1n(t, i, e, s, n) {
                g$.zt(t),
                g$.zt(e),
                g$.U(i, Blob);
                const r = await this.j1n("uploadFile", {
                    xDn: s,
                    cancel: n
                }, t, e, i);
                return await this.V1n(r),
                r
            }
            async CU(t, i) {
                g$.zt(t),
                g$.zt(i);
                const e = await this.j1n("createFile", null, t, i);
                return await this.V1n(e),
                e
            }
            async oVn(t, i) {
                g$.zt(t),
                g$.zt(i);
                const e = await this.j1n("createFolder", null, t, i);
                return await this.V1n(e),
                e
            }
            async H1n(t, i, e, s, n) {
                g$.zt(t),
                g$.U(i, Blob),
                g$.zt(e),
                g$.X_t(s),
                g$.U(n, g$.Cye);
                const r = await this.j1n("updateFile", {
                    xDn: s,
                    cancel: n
                }, t, i, e);
                return await this.$1n(e, t, r),
                r
            }
            async v1n(t, i, e) {
                g$.zt(t),
                g$.zt(i),
                g$.zt(e);
                const s = await this.j1n("renameFile", null, t, i, e);
                return await this.$1n(e, t, s),
                s
            }
            async S1n(t, i) {
                g$.zt(t),
                g$.zt(i),
                await this.j1n("deleteFile", null, t),
                await this.z1n(i, t)
            }
            async bVn() {
                const t = await this.j1n("logout");
                return this.A1n.clear(),
                this.R1n = null,
                t
            }
            static K1n(t) {
                g$.zt(t);
                let i = M$.get(t);
                return i || (i = g$.v(b$.G1n, t),
                M$.set(t, i)),
                i
            }
        }
    }
}
{
    const A$ = self.t
      , R$ = self.app
      , k$ = self.jk
      , O$ = self.tP
      , D$ = new WeakSet
      , F$ = new Map;
    let L$ = 0;
    if (!window.C3_IsPopupWindow) {
        const B$ = A$.v(A$.qs.Jj.Pan);
        k$.b1n = class t {
            constructor(t) {
                switch (A$.zt(t),
                this.rVt = t,
                this.R1n = null,
                this.Vzn = k$.G1n.K1n(this.rVt),
                this.X1t = null,
                this.q1n = new WeakSet,
                this.rVt) {
                case "GOOGLE DRIVE":
                    this.X1t = "google-drive";
                    break;
                case "ONE DRIVE":
                    this.X1t = "onedrive";
                    break;
                case "DROPBOX":
                    this.X1t = "dropbox";
                    break;
                case "LOCAL STORAGE":
                    this.X1t = "open-folder"
                }
            }
            MEt() {
                return A$.iPs(this.rVt)
            }
            async X1n() {
                const t = await this.Vzn.W1n();
                return this.R1n = t,
                this.R1n
            }
            Y1n(t) {
                A$.U(t, self.gh),
                L$++,
                this.q1n.add(t)
            }
            J1n(t) {
                A$.U(t, self.gh),
                L$--,
                this.q1n.delete(t)
            }
            t1n(t) {
                return this.q1n.has(t)
            }
            lN() {
                return this.Vzn.lN()
            }
            async y1n(i, e, s) {
                A$.zt(i),
                A$.zt(e),
                s = !!s;
                const n = O$("ui.cloud-save.downloading", this.MEt(), e);
                if (s) {
                    const t = A$.v(A$.Cye);
                    let e = 0
                      , s = A$.qs.Ys.$s("Progress");
                    s.onprogress = () => e,
                    s.Qa(n, null, () => t.Vh());
                    try {
                        return await this.Vzn.JHi(i, t => e = t, t)
                    } finally {
                        s.PR()
                    }
                } else {
                    const e = t.Z1n(n + " {0}%");
                    try {
                        return await this.Vzn.JHi(i, t => e.zan(t))
                    } finally {
                        e.he()
                    }
                }
            }
            v1n(t, i, e) {
                return A$.zt(t),
                A$.zt(i),
                A$.zt(e),
                this.Vzn.v1n(t, i, e)
            }
            S1n(t, i) {
                return A$.zt(t),
                A$.zt(i),
                this.Vzn.S1n(t, i)
            }
            oVn(t, i) {
                return A$.zt(t),
                A$.zt(i),
                this.Vzn.oVn(t, i)
            }
            async x1n(i, e, s, n) {
                A$.Tke(i, Blob),
                A$.zt(e),
                A$.Kq(s),
                A$.zt(n);
                const r = this.MEt()
                  , h = t.Z1n(O$("ui.cloud-save.uploading", r, e) + " {0}%")
                  , o = t => h.zan(t)
                  , a = A$.v(A$.Cye);
                try {
                    s ? await this.Vzn.H1n(s, i, n, o, a) : await this.Vzn.x1n(e, i, n, o, a),
                    A$.qs.Notification.nF(this.X1t, r, O$("ui.cloud-save.upload-succeeded", e), {
                        align: "bottom-left"
                    })
                } catch (i) {
                    await t.M1n(i, O$("ui.cloud-save.unknown-error-while-saving", e, r))
                } finally {
                    h.he()
                }
            }
            async Vk(i, e, s, n, r, h) {
                if (A$.U(i, self.gh),
                A$.zt(e),
                A$.Kq(s),
                A$.zt(n),
                A$.Wat(h),
                r = !!r,
                this.t1n(i))
                    return t.M1n(new Error(O$("ui.cloud-save.already-saving", e)));
                this.Y1n(i);
                const o = A$.iPs(this.rVt)
                  , a = t.Z1n(O$("ui.cloud-save.saving-project-to", e, this.MEt()) + " {0}%")
                  , l = t => a.zan(t)
                  , u = A$.v(A$.Cye);
                try {
                    h ? (i.Wii(h),
                    i.Xii(!0)) : (i.Kii(),
                    i.Xii(!1));
                    const a = await t._1n(i, r);
                    if (i.Kii(),
                    i.Xii(!1),
                    s)
                        await this.Vzn.H1n(s, a, n, l, u);
                    else {
                        s = (await this.Vzn.x1n(e, a, n, l, u)).id
                    }
                    r || (i.gii(e),
                    await i.wii("cloud", {
                        parent: n,
                        service: this.rVt,
                        name: e,
                        id: s
                    })),
                    R$.Lii("SaveProjectMethod", "LOCAL STORAGE" === this.rVt ? "browser-storage" : "cloud"),
                    A$.qs.Notification.nF(this.X1t, o, O$("ui.cloud-save.save-succeeded", e), {
                        align: "bottom-left"
                    })
                } catch (i) {
                    await t.M1n(i, O$("ui.cloud-save.unknown-error-while-saving", e, o))
                } finally {
                    a.he(),
                    i.Kii(),
                    i.Xii(!1),
                    this.J1n(i)
                }
            }
            E1n(t, i) {
                return A$.zt(t),
                A$.zt(i),
                this.Vzn.E1n(t, i)
            }
            async A0n(i, e, s) {
                A$.zt(e),
                A$.zt(i),
                A$.zt(s);
                const n = ".capx" === A$.Uh(e).toLowerCase()
                  , r = [...R$.PA()].filter(t => "cloud" === t.kB()).map(t => t.xB()).filter(t => t.service === this.rVt && t.id === i);
                if (r[0])
                    return t.M1n(new Error(O$("ui.cloud-save.already-open", e)));
                const h = await this.y1n(i, e, !0)
                  , o = {
                    h2t: "LOCAL STORAGE" === this.rVt ? "browser-storage" : "cloud"
                };
                let a = null;
                a = n ? await R$.l2t(h, o) : await R$.a2t(h, o),
                A$.$l(a, self.gh) && (n ? a.gii(e.slice(0, -4) + "c3p") : (a.gii(e),
                await a.wii("cloud", {
                    parent: s,
                    service: this.rVt,
                    name: e,
                    id: i
                })))
            }
            Xfs(t, i) {
                return A$.zt(i),
                t = !!t,
                this.Vzn.Xfs(t, i)
            }
            bVn() {
                return this.Vzn.bVn()
            }
            static async _1n(t, i) {
                if (A$.U(t, self.gh),
                i = !!i,
                D$.has(t))
                    throw new Error(self.lang("ui.cloud-save.already-archiving"));
                D$.add(t);
                const e = this.C1n(O$("ui.cloud-save.archiving-project", t.Fa()));
                try {
                    const e = await R$.K0n(t, !0);
                    return i || t.vii(),
                    e
                } finally {
                    e.he(),
                    D$.delete(t)
                }
            }
            static t1n(t) {
                if (t) {
                    for (const i of F$.values())
                        if (i.t1n(t))
                            return !0;
                    return !1
                }
                return L$ > 0
            }
            static $s(i) {
                A$.zt(i);
                let e = F$.get(i);
                return e || (e = t.y_(i)),
                e
            }
            static y_(i) {
                if (A$.zt(i),
                F$.has(i))
                    throw new Error(`Interface "${i}" already exists`);
                const e = A$.v(t, i);
                return F$.set(i, e),
                e
            }
            static C1n(t) {
                A$.zt(t);
                const i = A$.v(A$.qs.Jj.Van, B$, t);
                return i.Ej(),
                i
            }
            static M1n(t, i) {
                console.error("Error saving: ", t);
                let e = t.message;
                return e || (e = i),
                A$.zt(e),
                A$.qs.Ys.$s("OK").Qa(e, document.body)
            }
            static Z1n(t) {
                A$.zt(t);
                const i = A$.v(A$.qs.Jj.jan, B$, t);
                return i.zan(0),
                i
            }
        }
    }
}
